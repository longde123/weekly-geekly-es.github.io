<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéõÔ∏è üë©‚Äçüåæ üö© Proxy DNS √† faire soi-m√™me sur Node.JS üôáüèæ üë©üèæ‚Äçüè≠ ‚ÜñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Un paquet sur les bosses dans une for√™t lointaine pour DNS ... 
 L. Kaganov "Hamlet au fond" 

 Lors du d√©veloppement d'une application r√©seau, il dev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Proxy DNS √† faire soi-m√™me sur Node.JS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440050/"><blockquote> Un paquet sur les bosses dans une for√™t lointaine pour DNS ... <br>  <em>L. Kaganov "Hamlet au fond"</em> </blockquote><p>  Lors du d√©veloppement d'une application r√©seau, il devient parfois n√©cessaire de l'ex√©cuter localement, mais d'y acc√©der en utilisant un vrai nom de domaine.  La solution standard √©prouv√©e consiste √† enregistrer le domaine dans le fichier hosts.  L'inconv√©nient de l'approche est que les h√¥tes n√©cessitent une correspondance claire des noms de domaine, c'est-√†-dire  ne prend pas en charge les √©toiles.  C'est-√†-dire  s'il existe des domaines du formulaire: </p><br><pre><code class="plaintext hljs">dom1.example.com, dom2.example.com, dom3.example.com, ................ domN.example.com,</code> </pre> <br><p>  puis dans les h√¥tes, vous devez tous les enregistrer.  Dans certains cas, le domaine de troisi√®me niveau n'est pas connu √† l'avance.  Il y a un d√©sir (j'√©cris pour moi, quelqu'un pourrait dire que c'est normal) de s'en sortir avec une ligne comme celle-ci: </p><br><pre> <code class="plaintext hljs">*.example.com</code> </pre> <br><p>  La solution au probl√®me peut √™tre d'utiliser votre propre serveur DNS, qui traitera les demandes conform√©ment √† la logique sp√©cifi√©e.  Il existe de tels serveurs, √† la fois enti√®rement gratuits et avec une interface graphique pratique, comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CoreDNS</a> .  Vous pouvez √©galement modifier les enregistrements DNS sur le routeur.  Enfin, utilisez un service comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">xip.io</a> , ce n'est pas tout √† fait un serveur DNS √† part enti√®re, mais il est parfait pour certaines t√¢ches.  Bref, des solutions toutes faites existent, vous pouvez les utiliser et ne pas vous emb√™ter. </p><br><p>  Mais cet article d√©crit une autre fa√ßon - √©crire votre propre v√©lo, le point de d√©part pour cr√©er un outil comme ceux √©num√©r√©s ci-dessus.  Nous √©crirons notre proxy DNS, qui √©coutera les requ√™tes DNS entrantes, et si le nom de domaine demand√© est dans la liste, il renverra l'IP sp√©cifi√©e, et sinon, il demandera un serveur DNS sup√©rieur et transmettra la r√©ponse re√ßue sans modifications au programme demandeur. </p><a name="habracut"></a><br><p>  Dans le m√™me temps, vous pouvez enregistrer les demandes et les r√©ponses re√ßues.  √âtant donn√© que le DNS est n√©cessaire √† tout le monde - navigateurs, messagers et antivirus, et services de syst√®me d'exploitation, etc., il peut √™tre tr√®s informatif. </p><br><p>  Le principe est simple.  Dans les param√®tres de connexion r√©seau pour IPv4, nous changeons l'adresse du serveur DNS en l'adresse de la machine avec notre proxy DNS auto-√©crit en cours d'ex√©cution (127.0.0.1, si nous ne travaillons pas sur le r√©seau), et dans ses param√®tres, nous sp√©cifions l'adresse du serveur DNS sup√©rieur.  Et, semble-t-il, c'est tout! </p><br><p>  Nous n'utiliserons pas les fonctions standard pour r√©soudre les noms de domaine <em>nslookup</em> et <em>nsresolve</em> , donc les param√®tres du syst√®me DNS et le contenu du <em>fichier hosts</em> n'affecteront pas le fonctionnement du programme.  Selon la situation, cela peut √™tre utile ou non, il suffit de s'en souvenir.  Par souci de simplicit√©, nous nous limitons √† l'impl√©mentation de la fonctionnalit√© de base elle-m√™me: </p><br><ul><li>  Usurpation d'adresse IP uniquement pour les enregistrements de type A (adresse d'h√¥te) et de classe IN (Internet) </li><li>  adresses IP usurp√©es uniquement version 4 </li><li>  connexion pour les demandes entrantes locales sur UDP uniquement </li><li>  connexion au serveur DNS en amont via UDP ou TLS </li><li>  s'il y a plusieurs interfaces r√©seau, les demandes locales entrantes seront accept√©es sur l'une d'entre elles </li><li>  pas de support EDNS </li></ul><br><div class="spoiler">  <b class="spoiler_title">En parlant de tests</b> <div class="spoiler_text"><p>  Il y a peu de tests unitaires dans le projet.  Certes, ils fonctionnent selon le principe: je l'ai lanc√©, et si quelque chose de sain est affich√© dans la console, alors tout va bien, mais si une exception vole, alors il y a un probl√®me.  Mais m√™me une approche aussi maladroite vous permet de localiser avec succ√®s le probl√®me, alors Unit. </p></div></div><br><h2 id="nachalo--server-na-53-m-portu">  D√©marrer - serveur sur le port 53 </h2><br><p>  Commen√ßons.  Tout d'abord, vous devez apprendre √† l'application √† accepter les requ√™tes DNS entrantes.  Nous √©crivons un simple serveur TCP qui √©coute simplement le port 53 et enregistre les connexions entrantes.  Dans les propri√©t√©s de la connexion r√©seau, nous √©crivons l'adresse du serveur DNS 127.0.0.1, lan√ßons l'application, allons sur le navigateur pour plusieurs pages - et ... silence dans la console, le navigateur affiche la page normalement.  Eh bien, nous changeons TCP en UDP, nous commen√ßons, nous passons par le navigateur - dans le navigateur il y a une erreur de connexion, des donn√©es binaires vers√©es dans la console.  Ainsi, le syst√®me envoie des requ√™tes via UDP, et nous √©couterons les connexions entrantes via UDP sur le port 53.  Une demi-heure de travail, dont 15 minutes pour savoir comment √©lever un serveur TCP et UDP sur NodeJS - et nous avons r√©solu la t√¢che fondamentale du projet, qui d√©termine la structure de la future application.  Le code est le suivant: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dgram = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dgram'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = dgram.createSocket(<span class="hljs-string"><span class="hljs-string">'udp4'</span></span>); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">function</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">server</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">on</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'error'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, (err</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`server error:\n</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${err.stack}</span></span></span><span class="hljs-string">`</span></span>); server.close(); }); server.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (localReq, linfo) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(localReq); <span class="hljs-comment"><span class="hljs-comment">//            }); server.on('listening', () =&gt; { const address = server.address(); console.log(`server listening ${address.address}:${address.port}`); }); const localListenPort = 53; const localListenAddress = 'localhost'; server.bind(localListenPort, localListenAddress); // server listening 0.0.0.0:53 }());</span></span></code> </pre> <br><p>  <em>Listing 1. Le code minimum n√©cessaire pour recevoir des requ√™tes DNS locales</em> </p><br><p>  Le point suivant est de lire le message afin de comprendre s'il est n√©cessaire de renvoyer notre IP en r√©ponse, ou simplement de le transmettre. </p><br><h2 id="dns-soobschenie">  Message DNS </h2><br><p>  La structure du message DNS est d√©crite dans la RFC-1035.  Les demandes et les r√©ponses suivent cette structure et, en principe, diff√®rent par un indicateur de bit (champ QR) dans l'en-t√™te du message.  Le message comprend cinq sections: </p><br><pre> <code class="plaintext hljs">+---------------------+ | Header | +---------------------+ | Question | the question for the name server +---------------------+ | Answer | RRs answering the question +---------------------+ | Authority | RRs pointing toward an authority +---------------------+ | Additional | RRs holding additional information +---------------------+</code> </pre> <br><p>  <em>Structure (s) g√©n√©rale (s) des messages DNS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1</a></em> </p><br><p>  Un message DNS commence par un en-t√™te de longueur fixe (il s'agit de la section dite en- <em>t√™te</em> ), qui contient des champs de 1 bit √† deux octets (ainsi, un octet dans l'en-t√™te peut contenir plusieurs champs).  L'en-t√™te commence par le champ ID - il s'agit de l'identifiant de requ√™te 16 bits, la r√©ponse doit avoir le m√™me ID.  Les champs suivants d√©crivent le type de demande, le r√©sultat de son ex√©cution et le nombre d'enregistrements dans chacune des sections suivantes du message.  D√©crivez-les tous pendant longtemps, alors peu importe - bien dans la RFC: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1.1</a> .  La section <em>En</em> - <em>t√™te</em> est toujours pr√©sente dans le message DNS. </p><br><pre> <code class="plaintext hljs"> 1 1 1 1 1 1 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ID | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |QR| Opcode |AA|TC|RD|RA| Z | RCODE | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | QDCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ANCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | NSCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ARCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code> </pre> <br><p>  <em>Structure (s) d'en-t√™te de message DNS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1.1</a></em> </p><br><h3 id="sekciya-question">  Section des questions </h3><br><p>  La section <em>Question</em> contient une entr√©e indiquant au serveur exactement quelles informations sont n√©cessaires.  Th√©oriquement, dans la section de ces enregistrements, il peut y en avoir un ou plusieurs, leur nombre est indiqu√© dans le champ QDCOUNT de l'en-t√™te du message et peut √™tre 0, 1 ou plus.  Mais en pratique, la section Question ne peut contenir qu'une seule entr√©e.  Si la section <em>Question</em> contenait plusieurs enregistrements et que l'un d'entre eux entra√Ænait une erreur lors du traitement de la demande sur le serveur, une situation ind√©finie se produirait.  Bien que le serveur renvoie un code d'erreur dans le champ RCODE du message de r√©ponse, il ne pourra pas indiquer lors du traitement de l'enregistrement de l'incident, la sp√©cification ne le d√©crit pas.  Les enregistrements n'ont √©galement aucun champ contenant une indication de l'erreur et de son type.  Par cons√©quent, il existe un accord (non document√©), selon lequel la section <em>Question</em> ne peut contenir qu'un seul enregistrement et le champ QDCOUNT a une valeur de 1. Il n'est pas non plus enti√®rement clair comment traiter la demande c√¥t√© serveur, si elle contient toujours plusieurs enregistrements dans <em>Question</em> .  Quelqu'un conseille de renvoyer un message avec une erreur de demande.  Et, par exemple, Google DNS ne traite que le premier enregistrement de la section <em>Question</em> , il ignore simplement le reste.  Apparemment, cela reste √† la discr√©tion des d√©veloppeurs de services DNS. </p><br><p>  Dans le message DNS de r√©ponse du serveur, la section <em>Question</em> est √©galement pr√©sente et doit copier compl√®tement la <em>question de la</em> demande (afin d'√©viter les conflits, au cas o√π un champ ID ne suffirait pas). </p><br><p>  La seule entr√©e dans la section <em>Question</em> contient les champs: QNAME (nom de domaine), QTYPE (type), QCLASS (classe).  QTYPE et QCLASS sont des nombres √† deux octets indiquant le type et la classe de la demande.  Les types et classes possibles sont d√©crits dans la RFC-1035 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc1035#section-3.2</a> , tout y est clair.  Mais sur la m√©thode d'enregistrement d'un nom de domaine, nous nous attarderons plus en d√©tail dans la section "Format d'enregistrement des noms de domaine". </p><br><p>  Dans le cas d'une requ√™te, le message DNS se termine le plus souvent par la section <em>Question</em> , parfois la section <em>suppl√©mentaire</em> peut le suivre. </p><br><p>  Si une erreur s'est produite lors du traitement de la demande sur le serveur (par exemple, une demande entrante a √©t√© mal form√©e), le message de r√©ponse se terminera √©galement par la section <em>Question</em> ou <em>suppl√©mentaire</em> , et le champ RCODE de l'en-t√™te du message de r√©ponse contiendra un code d'erreur. </p><br><h3 id="sekcii-answer-authority-i-additional">  <em>R√©ponse</em> , <em>autorisation</em> et sections <em>suppl√©mentaires</em> </h3><br><p>  Les sections suivantes sont <em>R√©ponse</em> , <em>Autorit√©</em> et <em>Suppl√©mentaire</em> (La <em>r√©ponse</em> et l' <em>Autorit√©</em> sont contenues uniquement dans le message DNS de r√©ponse, des informations <em>suppl√©mentaires</em> peuvent appara√Ætre dans la demande et dans la r√©ponse).  Ils sont facultatifs, c'est-√†-dire  l'un d'eux peut √™tre pr√©sent ou non, selon la demande.  Ces sections ont la m√™me structure et contiennent des informations au format des ¬´enregistrements de ressources¬ª (enregistrement de ressource, ou RR).  Au sens figur√©, chacune de ces sections est un tableau d'enregistrements de ressources, et un enregistrement est un objet avec des champs.  Chaque section peut contenir un ou plusieurs enregistrements, leur num√©ro est indiqu√© dans le champ correspondant de l'en-t√™te du message (ANCOUNT, NSCOUNT, ARCOUNT, respectivement).  Par exemple, une demande IP pour le domaine "google.com" renverra plusieurs adresses IP, il y aura donc √©galement plusieurs entr√©es dans la section <em>R√©ponse</em> , une pour chaque adresse.  Si la section est absente, le champ d'en-t√™te correspondant contient 0. </p><br><p>  Chaque <em>enregistrement de ressource</em> (RR) commence par un champ NAME contenant un nom de domaine.  Le format de ce champ est le m√™me que le champ QNAME de la section <em>Question</em> . <br>  √Ä c√¥t√© de NAME se trouvent les champs TYPE (type d'enregistrement) et CLASS (sa classe), les deux champs sont num√©riques sur 16 bits, indiquent le type et la classe de l'enregistrement.  Cela ressemble √©galement √† la section <em>Question</em> , √† la diff√©rence que ses QTYPE et QCLASS peuvent avoir toutes les m√™mes valeurs que TYPE et CLASS, et certaines autres qui leur sont propres.  Autrement dit, dans un langage scientifique sec, l'ensemble des valeurs QTYPE et QCLASS est un sur-ensemble des valeurs TYPE et CLASS.  En savoir plus sur les diff√©rences sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc1035#section-3.2.2</a> . <br>  Les champs restants sont: </p><br><ul><li>  TTL est un nombre de 32 bits indiquant la derni√®re fois que l'enregistrement a √©t√© (en secondes). </li><li>  RDLENGTH est un nombre de 16 bits qui indique la longueur du champ RDATA suivant en octets. </li><li>  RDATA est en fait une charge utile, le format d√©pend du type d'enregistrement.  Par exemple, pour un enregistrement de type A (adresse d'h√¥te) et de classe IN (Internet), ce sont 4 octets repr√©sentant une adresse IPv4. </li></ul><br><h2 id="format-zapisi-domennyh-imyon">  Format d'enregistrement de nom de domaine </h2><br><p>  Le format d'enregistrement des noms de domaine est le m√™me pour les champs QNAME et NAME, ainsi que pour le champ RDATA, s'il s'agit d'un enregistrement CNAME, MX, NS ou autre enregistrement de classe qui suppose un nom de domaine comme r√©sultat. </p><br><p>  Un nom de domaine est une s√©quence d'√©tiquettes (sections d'un nom, sous-domaines - c'est une <strong>√©tiquette</strong> dans l'original, je n'ai pas trouv√© de meilleure traduction).  Une √©tiquette est un seul octet de longueur contenant un nombre - la longueur du contenu de l'√©tiquette en octets, suivie d'une s√©quence d'octets de la longueur sp√©cifi√©e.  Les √©tiquettes se succ√®dent jusqu'√† ce qu'un octet de longueur contenant 0 soit rencontr√©. La toute premi√®re √©tiquette peut √™tre imm√©diatement de longueur nulle, cela indique le domaine racine (domaine racine) avec un nom de domaine vide (parfois √©crit ""). </p><br><p>  Dans les versions ant√©rieures de DNS, les octets de l'√©tiquette pouvaient avoir n'importe quelle valeur de (0 √† 255).  Il y avait des r√®gles qui √©taient de la nature d'une recommandation urgente: que le libell√© commence par une lettre, se termine par une lettre ou un chiffre et ne contienne que des lettres, des chiffres ou des tirets en codage ASCII 7 bits, avec le bit z√©ro le plus significatif.  La sp√©cification EDNS actuelle exige d√©j√† le respect de ces r√®gles clairement, sans d√©viation. </p><br><p>  Les deux bits les plus significatifs de l'octet de longueur sont utilis√©s comme attribut de type d'√©tiquette.  S'ils sont nuls ( <em>0b00xxxxxx</em> ), il s'agit alors d'une √©tiquette normale et les bits restants de l'octet de longueur indiquent le nombre d'octets de donn√©es inclus dans sa composition.  La longueur maximale de l'√©tiquette est de 63 caract√®res.  63 en codage binaire est juste <em>0b00111111</em> . </p><br><p>  Si les deux bits de poids fort sont respectivement 0 et 1 ( <em>0b01xxxxxx</em> ), il s'agit d'une √©tiquette de type √©tendue de la norme EDNS ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc2671#section-3.1</a> ), qui nous est parvenue le 1er f√©vrier 2019.  Les six bits inf√©rieurs contiendront la valeur de l'√©tiquette.  Nous ne discutons pas d'EDNS dans cet article, mais il est utile de savoir que cela se produit √©galement. </p><br><p>  La combinaison des deux bits les plus significatifs, √©gaux √† 1 et 0 ( <em>0b10xxxxxx</em> ), est r√©serv√©e pour une utilisation future. </p><br><p>  Si les deux bits hauts sont √©gaux √† 1 ( <em>0b11xxxxxx</em> ), cela signifie que les noms de domaine sont compress√©s ( <em>compression</em> ), et nous nous attarderons sur cela plus en d√©tail. </p><br><h3 id="szhatie-domennyh-imyon">  Compression des noms de domaine </h3><br><p>  Donc, si un octet de longueur a deux bits hauts √©gaux √† 1 ( <em>0b11xxxxxx</em> ), c'est un signe de compression de nom de domaine.  La compression est utilis√©e pour rendre les messages plus courts et plus concis.  Cela est particuli√®rement vrai lorsque vous travaillez sur UDP, lorsque la longueur totale du message DNS est limit√©e √† 512 octets (bien qu'il s'agisse de l'ancienne norme, voir <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc1035#section-2.3.4</a> Limites de taille</em> , le nouveau EDNS permet d'envoyer des messages UPD et plus).  L'essence du processus est que si un message DNS contient des noms de domaine avec les m√™mes sous-domaines de premier niveau (par exemple, <em>mail.yandex.ru</em> et <em>yandex.ru</em> ), au lieu de re-sp√©cifier le nom de domaine entier, le num√©ro d'octet dans le message DNS √† partir duquel Continuez √† lire le nom de domaine.  Il peut s'agir de n'importe quel octet du message DNS, non seulement dans l'enregistrement ou la section en cours, mais √† condition qu'il s'agisse d'un octet de la longueur de l'√©tiquette de domaine.  Vous ne pouvez pas vous r√©f√©rer au milieu de la marque.  Supposons qu'il y ait un domaine <em>mail.yandex.ru</em> dans le message, puis √† l'aide de la compression, il est possible de d√©signer √©galement les <em>domaines yandex.ru</em> , <em>ru</em> et root "" (bien s√ªr, la racine est plus facile √† √©crire sans compression, mais il est techniquement possible de le faire avec la compression), et ici pour faire <em>ndex.ru</em> ne fonctionnera pas.  De plus, tous les noms de domaine d√©riv√©s se termineront dans le domaine racine, c'est-√†-dire que l'√©criture, disons, <em>mail.yandex</em> √©chouera √©galement. </p><br><p>  Un nom de domaine peut: </p><br><ul><li>  √™tre enti√®rement enregistr√© sans compression, </li><li>  partir d'un endroit qui utilise la compression </li><li>  commencez par une ou plusieurs √©tiquettes sans compression, puis passez en compression, </li><li>  √™tre vide (pour le domaine racine). </li></ul><br><p>  Par exemple, nous compilons un message DNS, et nous y avions d√©j√† rencontr√© le nom "dom3.example.com", nous devons maintenant sp√©cifier "dom4.dom3.example.com".  Dans ce cas, vous pouvez enregistrer la section "dom4" sans compression, puis basculer vers la compression, c'est-√†-dire ajouter un lien vers "dom3.example.com".  Ou vice versa, si le nom "dom4.dom3.example.com" a d√©j√† √©t√© rencontr√©, pour indiquer "dom3.example.com", vous pouvez imm√©diatement utiliser la compression en vous r√©f√©rant √† l'√©tiquette "dom3".  Ce que nous ne pouvons pas faire est, comme cela a d√©j√† √©t√© dit, d'indiquer la partie de "dom4.dom3" par compression, car le nom doit se terminer par une section de niveau sup√©rieur.  Si vous devez soudainement sp√©cifier des segments √† partir du milieu, ils sont simplement indiqu√©s sans compression. </p><br><p>  Par souci de simplicit√©, notre programme ne sait pas √©crire les noms de domaine avec compression, il ne peut que lire.  La norme le permet, la lecture doit √™tre impl√©ment√©e n√©cessairement, l'√©criture est facultative.  Techniquement, la lecture est impl√©ment√©e comme ceci: si les deux bits les plus significatifs d'un octet de longueur contiennent 1, alors nous lisons l'octet qui le suit et traitons ces deux octets comme un entier non sign√© de 16 bits, avec l'ordre des bits Big Endian.  Nous supprimons les deux bits les plus significatifs (contenant 1), lisons le nombre de 14 bits r√©sultant et continuons √† lire le nom de domaine de l'octet dans le message DNS sous le num√©ro correspondant √† ce num√©ro. </p><br><p>  Le code de la fonction de lecture de nom de domaine est le suivant: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readDomainName</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buf, startOffset, objReturnValue = {}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currentByteIndex = startOffset; <span class="hljs-comment"><span class="hljs-comment">//    ,  DNS- ,      let initOctet = buf.readUInt8(currentByteIndex); let domain = ''; //      , ..       0, //  ,      // "the root domain name has no labels." (c) RFC-1035, p. 4.1.4. Message compression objReturnValue['endOffset'] = currentByteIndex; let lengthOctet = initOctet; while (lengthOctet &gt; 0) { //     var label; if (lengthOctet &gt;= 192) { //   :  0b1100 0000   const pointer = buf.readUInt16BE(currentByteIndex) - 49152; // 49152 === 0b1100 0000 0000 0000 === 192 * 256 const returnValue = {} label = readDomainName(buf, pointer, returnValue); domain += ('.' + label); objReturnValue['endOffset'] = currentByteIndex + 1; //      ,      break; } else { currentByteIndex++; label = buf.toString('ascii', currentByteIndex, currentByteIndex + lengthOctet); domain += ('.' + label); currentByteIndex += lengthOctet; lengthOctet = buf.readUInt8(currentByteIndex); objReturnValue['endOffset'] = currentByteIndex; } } return domain.substring(1); //    ‚Äî  "." }</span></span></code> </pre> <br><p>  <em>Listing 2. Lecture de noms de domaine √† partir d'une requ√™te DNS</em> </p><br><p>  Code complet de la fonction pour lire l'enregistrement DNS √† partir du tampon binaire: </p><br><div class="spoiler">  <b class="spoiler_title">Listing 3. Lecture d'un enregistrement DNS √† partir d'un tampon binaire</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseDnsMessageBytes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buf</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> msgFields = {}; <span class="hljs-comment"><span class="hljs-comment">// (c) RFC 1035 p. 4.1.1. Header section format msgFields['ID'] = buf.readUInt16BE(0); const byte_2 = buf.readUInt8(2); //  #2 (starting from 0) const mask_QR = 0b10000000; msgFields['QR'] = !!(byte_2 &amp; mask_QR); //  : 0 "false" =&gt; , 1 "true" =&gt;  const mask_Opcode = 0b01111000; const opcode = (byte_2 &amp; mask_Opcode) &gt;&gt;&gt; 3; //   (): 0, 1, 2,   msgFields['Opcode'] = opcode; const mask_AA = 0b00000100; msgFields['AA'] = !!(byte_2 &amp; mask_AA); const mask_TC = 0b00000010; msgFields['TC'] = !!(byte_2 &amp; mask_TC); const mask_RD = 0b00000001; msgFields['RD'] = !!(byte_2 &amp; mask_RD); const byte_3 = buf.readUInt8(3); //  #3 const mask_RA = 0b10000000; msgFields['RA'] = !!(byte_3 &amp; mask_RA); const mask_Z = 0b01110000; msgFields['Z'] = (byte_3 &amp; mask_Z) &gt;&gt;&gt; 4; //  0,  const mask_RCODE = 0b00001111; msgFields['RCODE'] = (byte_3 &amp; mask_RCODE); // 0 =&gt; no error; (dec) 1, 2, 3, 4, 5 - errors, see RFC msgFields['QDCOUNT'] = buf.readUInt16BE(4); //     Question,   0  1 msgFields['ANCOUNT'] = buf.readUInt16BE(6); //     Answer msgFields['NSCOUNT'] = buf.readUInt16BE(8); //     Authority msgFields['ARCOUNT'] = buf.readUInt16BE(10); //     Additional //    Question let currentByteIndex = 12; //  Question   12-  DNS- (c) RFC 1035 p. 4.1.2. Question section format msgFields['questions'] = []; for (let qdcount = 0; qdcount &lt; msgFields['QDCOUNT']; qdcount++) { const question = {}; const resultByteIndexObj = { endOffset: undefined }; const domain = readDomainName(buf, currentByteIndex, resultByteIndexObj); currentByteIndex = resultByteIndexObj.endOffset + 1; question['domainName'] = domain; question['qtype'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "A" record currentByteIndex += 2; question['qclass'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "IN" Internet currentByteIndex += 2; msgFields['questions'].push(question); } // (c) RFC 1035 p. 4.1.3. Resource record format //    (Resourse Records, RR)  Answer, Authority, Additional ['answer', 'authority', 'additional'].forEach(function(section, i, arr) { let msgFieldsName, countFieldName; switch(section) { case 'answer': msgFieldsName = 'answers'; countFieldName = 'ANCOUNT'; break; case 'authority': msgFieldsName = 'authorities'; countFieldName = 'NSCOUNT'; break; case 'additional': msgFieldsName = 'additionals'; countFieldName = 'ARCOUNT'; break; } msgFields[msgFieldsName] = []; for (let recordsCount = 0; recordsCount &lt; msgFields[countFieldName]; recordsCount++) { let record = {}; const objReturnValue = {}; const domain = readDomainName(buf, currentByteIndex, objReturnValue); currentByteIndex = objReturnValue['endOffset'] + 1; record['domainName'] = domain; record['type'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "A" record currentByteIndex += 2; record['class'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "IN" Internet currentByteIndex += 2; // TTL  4  record['ttl'] = buf.readUIntBE(currentByteIndex, 4); currentByteIndex += 4; record['rdlength'] = buf.readUInt16BE(currentByteIndex); currentByteIndex += 2; const rdataBinTempBuf = buf.slice(currentByteIndex, currentByteIndex + record['rdlength']); record['rdata_bin'] = Buffer.alloc(record['rdlength'], rdataBinTempBuf); if (record['type'] === 1 &amp;&amp; record['class'] === 1) { //      IPv4,      let ipStr = ''; for (ipv4ByteIndex = 0; ipv4ByteIndex &lt; 4; ipv4ByteIndex++) { ipStr += '.' + buf.readUInt8(currentByteIndex).toString(); currentByteIndex++; } record['IPv4'] = ipStr.substring(1); //    '.' } else { //    ,   currentByteIndex += record['rdlength']; } msgFields[msgFieldsName].push(record); } }); return msgFields; }</span></span></code> </pre> <br><p> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3. Lecture d'un enregistrement DNS √† partir d'un tampon binaire</font></font></em> </p></div></div><br><p> ,       . ,     ,   ,    .   ,     DNS-,     ,   .  ,       . </p><br><p>  ,        - <code>server.on("message", () =&gt; {})</code>   1.   : </p><br><div class="spoiler"> <b class="spoiler_title"> 4.    DNS-</b> <div class="spoiler_text"><pre> <code class="javascript hljs">server.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (localReq, linfo) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dnsRequest = functions.parseDnsMessageBytes(localReq); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> question = dnsRequest.questions[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// currently, only one question per query is supported by DNS implementations let forgingHostParams = undefined; // ,         IP for (let i = 0; i &lt; config.requestsToForge.length; i++) { const requestToForge = config.requestsToForge[i]; const targetDomainName = requestToForge.hostName; if (functions.domainNameMatchesTemplate(question.domainName, targetDomainName) &amp;&amp; question.qclass === 1 &amp;&amp; question.qtype === 1) { forgingHostParams = requestToForge; break; } } //  ,    DNS-      if (!!forgingHostParams) { const forgeIp = forgingHostParams.ip; const answers = []; answers.push({ domainName: question.domainName, type: question.qtype, class: question.qclass, ttl: forgedRequestsTTL, rdlength: 4, rdata_bin: functions.ip4StringToBuffer(forgeIp), IPv4: forgeIp }); const localDnsResponse = { ID: dnsRequest.ID, QR: dnsRequest.QR, Opcode: dnsRequest.Opcode, AA: dnsRequest.AA, TC: false, // dnsRequest.TC, RD: dnsRequest.RD, RA: true, Z: dnsRequest.Z, RCODE: 0, // dnsRequest.RCODE, 0 - no errors, look in RFC-1035 for other error conditions QDCOUNT: dnsRequest.QDCOUNT, ANCOUNT: answers.length, NSCOUNT: dnsRequest.NSCOUNT, ARCOUNT: dnsRequest.ARCOUNT, questions: dnsRequest.questions, answers: answers } //     DNS-    const responseBuf = functions.composeDnsMessageBin(localDnsResponse); console.log('response composed for: ', localDnsResponse.questions[0]); server.send(responseBuf, linfo.port, linfo.address, (err, bytes) =&gt; {}); } // ,     DNS-,         else { //     DNS-  UDP,     const responseBuf = await functions.getRemoteDnsResponseBin(localReq, upstreamDnsIP, upstreamDnsPort); //        server.send(responseBuf, linfo.port, linfo.address, (err, bytes) =&gt; {}); //     DNS-  TLS,   , .  9 } });</span></span></code> </pre> <br><p> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 4. Traitement d'une requ√™te DNS locale entrante</font></font></em> </p></div></div><br><h2 id="dobavlyaem-podderzhku-tls">   TLS </h2><br><p>        DNS-.    ,      DNS-   TLS (HTTPS    ).  DNS-  TLS     TCP,    ,   TLS    .          TCP,   RFC-7766 DNS Transport over TCP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc7766</a> ).    ,  :      TLS,   TCP   ( ,       DNS  TCP,      TLS-  TCP-,     ). </p><br><h3 id="ustanovka-tls-soedineniya">  TLS- </h3><br><p>  TLS-           ,       ,   .  ,         TLS-,       .  RFC-7858 -        : </p><br><pre> <code class="plaintext hljs">In order to amortize TCP and TLS connection setup costs, clients and servers SHOULD NOT immediately close a connection after each response. Instead, clients and servers SHOULD reuse existing connections for subsequent queries as long as they have sufficient resources. In some cases, this means that clients and servers may need to keep idle connections open for some amount of time. () https://tools.ietf.org/html/rfc7858#section-3.4</code> </pre> <br><p>       ,   TLS-,   ,     ,   ,   ,       .   ,        30 ,   ,      ,        DNS-.  30  ~  ~   ,   15  60 ,         .        ,         .   - . </p><br><p> TLS-     NodeJS.    ,    TLS-     : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tls = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'tls'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TLS_SOCKET_IDLE_TIMEOUT = <span class="hljs-number"><span class="hljs-number">30000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,     TLS- function Module(connectionOptions, funcOnData, funcOnError, funcOnClose, funcOnEnd) { let socket; function connect() { socket = tls.connect(connectionOptions, () =&gt; { console.log('client connection established:', socket.authorized ? 'authorized' : 'unauthorized'); }); socket.on('data', funcOnData); // connection.on('end', () =&gt; {}); socket.on('close', (hasTransmissionError) =&gt; { //   ,     . //   ,     console.log('connection closed; transmission error:', hasTransmissionError); }); socket.on('end', () =&gt; { console.log('remote TLS server connection closed.') }); socket.on('error', (err) =&gt; { console.log('connection error:', err); console.log('\tmessage:', err.message); console.log('\tstack:', err.stack); }) socket.setTimeout(TLS_SOCKET_IDLE_TIMEOUT); socket.on('timeout', () =&gt; { console.log('socket idle timeout, disconnected.'); socket.end(); }); } this.write = function (dataBuf) { if (socket &amp;&amp; socket.writable) { //  ,     } else { connect(); } socket.write(dataBuf); } return this; } module.exports = Module;</span></span></code> </pre> <br><p> <em> 5. ,   TLS-</em> </p><br><p>       DNS-over-TLS ,   Google DNS.        ,               <code>socket = tls.connect(connectionOptions, () =&gt; {})</code> .     NodeJS: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://nodejs.org/api/tls.html#tls_tls_connect_options_callback</a> ,       . </p><br><p>  TLS-   : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">port</span></span>: config.upstreamDnsTlsPort, <span class="hljs-comment"><span class="hljs-comment">//        host: config.upstreamDnsTlsHost } const onData = (data) =&gt; { //     , .       7 }; remoteTlsClient = new TlsClient(options, onData);</span></span></code> </pre> <br><p> <em> 6.  TLS-</em> </p><br><p>     ,        TCP-.   TCP/TLS-      DNS-,     ,    ,     ,   .    TCP (  TLS),  DNS-   512 ,    UDP (,  EDNS    UDP  ).  ,  DNS-    UDP,             .       <strong>onData()</strong>   6. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    DNS-,       TLS-   //    ,     2 ,       let dataCurrentPos = 0; try { while (dataCurrentPos &lt; data.length) { const respLen = data.readUInt16BE(dataCurrentPos); respBuf = data.slice(dataCurrentPos + 2, dataCurrentPos + 2 + respLen); const respData = functions.parseDnsMessageBytes(respBuf); const requestKey = functions.getRequestIdentifier(respData); const localResponseParams = localRequestsAwaiting.get(requestKey); localRequestsAwaiting.delete(requestKey); server.send(respBuf, localResponseParams.port, localResponseParams.address, (err, bytesNum) =&gt; {}); dataCurrentPos += 2 + respLen; } } catch (err) { console.error(err); //   ,     throw err; } };</span></span></code> </pre> <br><p> <em> 7.   TLS-   DNS-   6</em> </p><br><h3 id="poryadok-otvetov-ot-udalyonnogo-dns-servera">     DNS- </h3><br><p>  ,            ,     .   ,         ID     QNAME, QTYPE  QCLASS  <em>Question</em> : </p><br><pre> <code class="plaintext hljs">Since pipelined responses can arrive out of order, clients MUST match responses to outstanding queries on the same TLS connection using the Message ID. If the response contains a Question Section, the client MUST match the QNAME, QCLASS, and QTYPE fields. () https://tools.ietf.org/html/rfc7858#section-3.3</code> </pre> <br><p>     ,  ,    ,   ID   <em>Question</em> (   ,      ). </p><br><p>        UDP (.  4),    ,         -,    ,   UDP-     .        ,       DNS-,       .          ,       -.  ,         ,      UDP-         -.  ,  ,    . </p><br><p>      TLS,               .         (IP  ),    ,       . </p><br><p>        IP      "-".   ,    ,   ,     DNS-.   ,    ,         IP  ,     .        7: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const requestKey = functions.getRequestIdentifier(respData); //    IP    ,   const localResponseParams = localRequestsAwaiting.get(requestKey); localRequestsAwaiting.delete(requestKey); //      IP   server.send(respBuf, localResponseParams.port, localResponseParams.address, (err, bytesNum) =&gt; {});</span></span></code> </pre> <br><p> <em> 8.        7</em> </p><br><p>      TLS-: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     const localReqParams = { address: linfo.address, port: linfo.port }; //        const requestKey = functions.getRequestIdentifier(dnsRequest); //       localRequestsAwaiting.set(requestKey, localReqParams); //       ,      const lenBuf = Buffer.alloc(2); lenBuf.writeUInt16BE(localReq.length); const prepReqBuf = Buffer.concat([lenBuf, localReq], 2 + localReq.length); remoteTlsClient.write(prepReqBuf); //  RFC-7766 p.8, 2               </span></span></code> </pre> <br><p> <em> 9.    DNS-  TLS- (  .  4)</em> </p><br><h2 id="chtenie-konfiguracii-iz-fayla-i-eyo-obnovlenie">        </h2><br><p>   ,   ,      .     JSON,    ,   NodeJS   JSON-      .  JSON ‚Äî      ,      .  ,    JSON-  "comment" (  )       . ,  ,  ,    ,  .  ,        ,     .      ,   -  ,    ,            NodeJS.    ,   ,     .  ,         ,       ;   ,   .           ,     - . </p><br><div class="spoiler"> <b class="spoiler_title"> 10.     </b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CONFIG_FILE_PATH = path.resolve(<span class="hljs-string"><span class="hljs-string">'./config.json'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Module</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// config  -,       . //    config        , //         . ,    : // const conf = config; //   conf     ,    : // const requestsToForge = config.requestsToForge; //    , requestsToForge   . const config = {}; Object.defineProperty(this, 'config', { get() { return config; }, enumerable: true }) this.initConfig = async function() { const fileContents = await readConfigFile(CONFIG_FILE_PATH); console.log('initConfig:'); console.log(fileContents); console.log('fileContents logged ^^'); const parsedConfigData = parseConfig(fileContents); Object.assign(config, parsedConfigData); }; async function readConfigFile(configPath) { const promise = new Promise((resolve, reject) =&gt; { fs.readFile(configPath, { encoding: 'utf8', flag: 'r' }, (err, data) =&gt; { if (err) { console.log('readConfigFile err to throw'); throw err; } resolve(data); }); }) .then( fileContents =&gt; { return fileContents; } ) .catch(err =&gt; { console.log('readConfigFile error: ', err); }); return promise; } function parseConfig(fileContents) { const configData = JSON.parse(fileContents); return configData; } //   ,       . //  Windows,    fs.watch     , //      ,   configReadInProgress let configReadInProgress = false; fs.watch(CONFIG_FILE_PATH, async () =&gt; { if(!configReadInProgress) { configReadInProgress = true; console.log('===== config changed, run initConfig() ====='); try { await this.initConfig(); } catch (err) { console.log('===== error initConfig(), skip =====,', err); configReadInProgress = false; } configReadInProgress = false; } else { console.log('===== config changed, initConfig() already running, skip ====='); } }); } let instance; async function getInstance() { if(!instance) { instance = new Module(); await instance.initConfig(); } return instance; } module.exports = getInstance;</span></span></code> </pre> <br><p> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 10. Lecteur et module de mise √† jour de la configuration</font></font></em> </p></div></div><br><h2 id="itogo">  Total </h2><br><p>    DNS-  NodeJS,     <em>npm</em>   .    ,        ,   ,  ,         . </p><br><p> <strong><a href="">   GitHub</a></strong> </p><br><h3 id="istochniki"> : </h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RFC-1035</a> DOMAIN NAMES ‚Äî IMPLEMENTATION AND SPECIFICATION </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RFC-7858</a> Specification for DNS over Transport Layer Security (TLS) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RFC-7766</a> DNS Transport over TCP ‚Äî Implementation Requirements </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://stackoverflow.com/questions/4082081/requesting-a-and-aaaa-records-in-single-dns-query/4083071#4083071</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440050/">https://habr.com/ru/post/fr440050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440036/index.html">Saisie tactile</a></li>
<li><a href="../fr440040/index.html">En d√©veloppement - chacun pour soi. Mais parfois, cela conduit √† une impasse.</a></li>
<li><a href="../fr440044/index.html">Historique d√©taill√© de Qualcomm</a></li>
<li><a href="../fr440046/index.html">Le√ßon ouverte "Cr√©ation de clients REST au printemps"</a></li>
<li><a href="../fr440048/index.html">Statistiques pr√©f√©r√©es: 5 indicateurs que chaque √©quipe commerciale doit suivre</a></li>
<li><a href="../fr440052/index.html">Analyse statique du BIOS / UEFI ou comment obtenir un graphique de d√©pendance</a></li>
<li><a href="../fr440054/index.html">Transf√©rer le service Web vers Yandex.Cloud avec AWS</a></li>
<li><a href="../fr440058/index.html">Rapport sur les probl√®mes et la disponibilit√© d'Internet 2018-2019</a></li>
<li><a href="../fr440060/index.html">TensorFlow sur Apache Ignite</a></li>
<li><a href="../fr440062/index.html">Planifier avec plaisir. Comment nous mettons en place des processus sans managers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>