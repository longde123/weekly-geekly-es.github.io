<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>餃勇 游눥 游꼹 Desarrollo de pruebas visuales basadas en Gemini y Storybook. 久勇 游녡游 游</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! En este art칤culo quiero compartir la experiencia de desarrollar pruebas visuales en nuestro equipo. 

 Sucedi칩 que no pensamos de inmediato...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo de pruebas visuales basadas en Gemini y Storybook.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454464/">  Hola Habr!  En este art칤culo quiero compartir la experiencia de desarrollar pruebas visuales en nuestro equipo. <br><br>  Sucedi칩 que no pensamos de inmediato en las pruebas de dise침o.  Bueno, algunos cuadros se mover치n por un par de p칤xeles, bueno, arr칠glenlo.  Al final, hay probadores: la mosca no volar치 m치s all치 de ellos.  Pero el factor humano todav칤a no se puede enga침ar: detectar cambios menores en la interfaz de usuario est치 lejos de ser siempre f칤sicamente posible, incluso para un probador.  La pregunta surgi칩 cuando se comenz칩 la optimizaci칩n seria del dise침o y la transici칩n a BEM.  Aqu칤, ciertamente no habr칤a sido sin p칠rdidas, y necesit치bamos desesperadamente una forma automatizada de detectar situaciones cuando, como resultado de ediciones, algo en la interfaz de usuario comienza a cambiar no seg칰n lo previsto, o no como estaba previsto. <br><a name="habracut"></a><br>  Cualquier desarrollador sabe acerca de las pruebas de c칩digo de unidad.  Las pruebas unitarias dan confianza de que los cambios en el c칩digo no rompieron nada.  Bueno, al menos no se rompieron en la parte para la que hay pruebas.  El mismo principio se puede aplicar a la interfaz de usuario.  Al igual que las clases de prueba de prueba, las pruebas visuales prueban los componentes visuales que conforman la interfaz de usuario de una aplicaci칩n. <br><br>  Para los componentes visuales, puede escribir pruebas unitarias "cl치sicas", que, por ejemplo, inician la representaci칩n de componentes con diferentes valores de par치metros de entrada y comprueban el estado esperado del 치rbol DOM utilizando declaraciones de aserci칩n, comparando elementos individuales o una instant치nea del 치rbol DOM del componente con la referencia en general  Las pruebas visuales tambi칠n se basan en instant치neas, pero ya en instant치neas de la visualizaci칩n del componente (capturas de pantalla).  La esencia de la prueba visual es comparar la imagen tomada durante la prueba con la de referencia y, si se encuentran diferencias, aceptar la nueva imagen como referencia o corregir el error que caus칩 estas diferencias. <br><br>  Por supuesto, el "examen" de los componentes visuales individuales no es muy efectivo.  Los componentes no viven en el vac칤o y su visualizaci칩n puede depender de los componentes de nivel superior o de los vecinos.  No importa c칩mo probamos los componentes individuales, la imagen en su conjunto puede tener defectos.  Por otro lado, si toma im치genes de toda la ventana de la aplicaci칩n, muchas de las im치genes contendr치n los mismos componentes, lo que significa que si cambia un componente, nos veremos obligados a actualizar todas las im치genes en las que este componente est치 presente. <br><br>  La verdad, como de costumbre, est치 en alg칰n lugar en el medio: puede dibujar la p치gina completa de la aplicaci칩n, pero tomar una fotograf칤a de solo un 치rea bajo la cual se crea la prueba, en el caso particular, esta 치rea puede coincidir con el 치rea de un componente espec칤fico, pero esto no ser치 un componente en vac칤o, pero en un entorno muy real.  Y esto ya ser치 similar a una prueba visual de la unidad, aunque dif칤cilmente se puede decir acerca de la modularidad si la "unidad" sabe algo sobre el medio ambiente.  Bueno, est치 bien, no es tan importante si la categor칤a de pruebas incluye pruebas visuales, modulares o de integraci칩n.  Como dice el refr치n, "revisas o te vas?" <br><br><h2>  Selecci칩n de herramienta </h2><br>  Para acelerar la ejecuci칩n de las pruebas, la representaci칩n de la p치gina se puede hacer en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">navegador sin cabeza</a> que hace todo el trabajo en la memoria sin mostrarse en la pantalla y garantiza el m치ximo rendimiento.  Pero en nuestro caso, fue fundamental garantizar que la aplicaci칩n funcionara en Internet Explorer (IE), que no tiene un modo sin cabeza, y necesit치bamos una herramienta para administrar los navegadores mediante programaci칩n.  Afortunadamente, todo ha sido inventado antes que nosotros y existe un instrumento de este tipo: se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">selenio</a> .  Como parte del proyecto Selenium, se est치n desarrollando controladores para administrar varios navegadores, incluido un controlador para IE.  El servidor Selenium puede administrar navegadores no solo localmente, sino tambi칠n de forma remota, formando un grupo de servidores de selenio, la llamada grilla de selenio. <br><br>  El selenio es una herramienta poderosa, pero el umbral para ingresar es bastante alto.  Decidimos buscar herramientas listas para usar para pruebas visuales basadas en selenio y encontramos un maravilloso producto de Yandex llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gemini</a> .  Gemini puede tomar fotograf칤as, incluidas im치genes de un 치rea determinada de la p치gina, comparar im치genes con referencias, visualizar la diferencia y tener en cuenta momentos como el suavizado o un cursor parpadeante.  Adem치s, Gemini puede hacer repeticiones de pruebas ca칤das, paralelizar la ejecuci칩n de pruebas y muchas otras ventajas.  En general, decidimos intentarlo. <br><br>  Las pruebas de G칠minis son f치ciles de escribir.  Primero debe preparar la infraestructura: instale <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">selenium-standalone</a> e inicie el servidor de selenium.  Luego configure gemini, especificando la direcci칩n de la aplicaci칩n bajo prueba (rootUrl), la direcci칩n del servidor de selenio (gridUrl), la composici칩n y configuraci칩n de los navegadores, as칤 como los complementos necesarios para generar informes, optimizando la compresi칩n de im치genes.  Ejemplo de configuraci칩n: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//.gemini.js module.exports = { rootUrl: 'http://my-app.ru', gridUrl: 'http://127.0.0.1:4444/wd/hub', browsers: { chrome: { windowSize: '1920x1080', screenshotsDir:'gemini/screens/1920x1080' desiredCapabilities: { browserName: 'chrome' } } }, system: { projectRoot: '', plugins: { 'html-reporter/gemini': { enabled: true, path: './report' }, 'gemini-optipng': true }, exclude: [ '**/report/*' ], diffColor: '#EC041E' } };</span></span></code> </pre> <br>  Las pruebas en s칤 mismas son una colecci칩n de suites, en cada una de las cuales se toman una o m치s im치genes (estados).  Antes de tomar una instant치nea (m칠todo de captura ()), puede establecer el 치rea de la p치gina que se tomar치 mediante el m칠todo setCaptureElements (), y tambi칠n realizar algunas acciones preparatorias si es necesario en el contexto del navegador utilizando los m칠todos del objeto de acciones o utilizando un c칩digo JavaScript arbitrario - para Esto en acciones tiene un m칠todo executeJS (). <br><br>  Un ejemplo: <br><br><pre> <code class="javascript hljs">gemini.suite(<span class="hljs-string"><span class="hljs-string">'login-dialog'</span></span>, suite =&gt; { suite.setUrl(<span class="hljs-string"><span class="hljs-string">'/'</span></span>) .setCaptureElements(<span class="hljs-string"><span class="hljs-string">'.login__form'</span></span>) .capture(<span class="hljs-string"><span class="hljs-string">'default'</span></span>); .capture(<span class="hljs-string"><span class="hljs-string">'focused'</span></span>, actions =&gt; actions.focus(<span class="hljs-string"><span class="hljs-string">'.login__editor'</span></span>)); });</code> </pre> <br><h2>  Datos de prueba </h2><br>  Se eligi칩 una herramienta de prueba, pero a칰n quedaba un largo camino hacia la soluci칩n final.  Era necesario entender qu칠 hacer con los datos que se muestran en las im치genes.  Perm칤tanme recordarles que en las pruebas decidimos no dibujar componentes individuales, sino toda la p치gina de la aplicaci칩n, para probar los componentes visuales no en el vac칤o, sino en el entorno real de otros componentes.  Si necesita transferir los datos de prueba necesarios a los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">accesorios</a> ee (estoy hablando de componentes de reacci칩n) para renderizar un componente individual, se necesita mucho m치s para renderizar toda la p치gina de la aplicaci칩n, y preparar el entorno para tal prueba puede ser un dolor de cabeza. <br><br>  Por supuesto, puede dejar que la aplicaci칩n misma reciba datos para que durante la prueba ejecute solicitudes al backend, que, a su vez, recibir칤a datos de alg칰n tipo de base de datos de referencia, pero 쯤u칠 pasa con el control de versiones?  No puedes poner una base de datos en un repositorio git.  No, por supuesto que puedes, pero hay algunas deficiencias. <br><br>  Alternativamente, para ejecutar pruebas, puede reemplazar el servidor de fondo real con uno falso, lo que le dar칤a a la aplicaci칩n web no datos de la base de datos, sino datos est치ticos almacenados, por ejemplo, en formato json, ya con las fuentes.  Sin embargo, la preparaci칩n de tales datos tampoco es demasiado trivial.  Decidimos seguir el camino m치s f치cil: no extraer los datos del servidor, sino simplemente restaurar el estado de la aplicaci칩n (en nuestro caso, el estado del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">almacenamiento redux</a> ), que estaba en la aplicaci칩n en el momento en que se tom칩 la imagen de referencia, antes de ejecutar la prueba. <br><br>  Para serializar el estado actual de la tienda redux, se ha agregado el m칠todo snapshot () al objeto de ventana: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> snapshotStore = (store: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>, <span class="hljs-attr"><span class="hljs-attr">fileName</span></span>: string): <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = store.getState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Blob( [ <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(state, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) ], { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span> } ); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); a.href = URL.createObjectURL(file); a.download = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${fileName}</span></span></span><span class="hljs-string">.testdata.json`</span></span>; a.click(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`State downloaded to </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a.download}</span></span></span><span class="hljs-string">`</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(reducer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.snapshot = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileName</span></span></span><span class="hljs-function"> =&gt;</span></span> snapshotStore(store, fileName); };</code> </pre><br>  Usando este m칠todo, usando la l칤nea de comandos de la consola del navegador, puede guardar el estado actual del almacenamiento redux en un archivo: <br><br><img src="https://habrastorage.org/webt/qf/t0/yq/qft0yqppzfe_issnjy74jon-vbs.png" alt="imagen"><br><br>  Como infraestructura para las pruebas visuales, se eligi칩 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Storybook</a> , una herramienta para el desarrollo interactivo de bibliotecas de componentes visuales.  La idea principal era que, en lugar de los diversos estados de los componentes en el 치rbol de historias, arreglara los diversos estados de nuestra aplicaci칩n y los utilizara para tomar capturas de pantalla.  Al final, no hay una diferencia fundamental entre componentes simples y complejos, excepto en la preparaci칩n del medio ambiente. <br><br>  Por lo tanto, cada prueba visual es una historia, antes de mostrar el estado del almacenamiento redux previamente guardado en el archivo.  Esto se hace usando el componente Proveedor de la biblioteca react-redux, a la propiedad de la tienda de la cual se pasa el estado deserializado restaurado del archivo guardado previamente: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> preloadedState <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./incoming-letter.testdata'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(rootReducer, preloadedState); storiesOf(<span class="hljs-string"><span class="hljs-string">'regression/Cards'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>) .add(<span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">store</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MemoryRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ContextContainer</span></span></span></span><span class="xml"><span class="hljs-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...dummyProps</span></span></span></span><span class="xml"><span class="hljs-tag">}/&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MemoryRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); });</span></span></code> </pre><br>  En el ejemplo anterior, ContextContainer es un componente que incluye el "esqueleto" de la aplicaci칩n: el 치rbol de navegaci칩n, el encabezado y el 치rea de contenido.  En el 치rea de contenido, se pueden representar varios componentes (lista, tarjeta, di치logo, etc.) seg칰n el estado actual del almacenamiento redux.  Para que el componente no cumpla solicitudes innecesarias al backend para la entrada, se le pasan las propiedades de c칩digo auxiliar correspondientes. <br><br>  En el contexto de un Storybook, se ve m치s o menos as칤: <br><br><img src="https://habrastorage.org/webt/jx/0m/ux/jx0muxytucrqrwzpvtnskjuqs1a.png" alt="imagen"><br><br><h2>  Libro de cuentos Gemini + </h2><br>  Entonces, descubrimos los datos para las pruebas.  La siguiente tarea es hacer amigos con Gemini y Storybook.  A primera vista, todo es simple: en la configuraci칩n de Gemini especificamos la direcci칩n de la aplicaci칩n bajo prueba.  En nuestro caso, esta es la direcci칩n del servidor de Storybook.  Solo necesita elevar el servidor del libro de cuentos antes de comenzar las pruebas de gemini.  Puede hacerlo directamente desde el c칩digo utilizando la suscripci칩n de evento Gemini START_RUNNER y END_RUNNER: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> port = <span class="hljs-number"><span class="hljs-number">6006</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cofiguration = { <span class="hljs-attr"><span class="hljs-attr">rootUrl</span></span>:<span class="hljs-string"><span class="hljs-string">`localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${port}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">gridUrl</span></span>: seleniumGridHubUrl, <span class="hljs-attr"><span class="hljs-attr">browsers</span></span>: { <span class="hljs-string"><span class="hljs-string">'chrome'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">screenshotsDir</span></span>:<span class="hljs-string"><span class="hljs-string">'gemini/screens'</span></span>, <span class="hljs-attr"><span class="hljs-attr">desiredCapabilities</span></span>: chromeCapabilities } } }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Gemini = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gemini'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HttpServer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http-server'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> runner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Gemini(cofiguration); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = HttpServer.createServer({ <span class="hljs-attr"><span class="hljs-attr">root</span></span>: <span class="hljs-string"><span class="hljs-string">'./storybook-static'</span></span>}); runner.on(runner.events.START_RUNNER, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`storybook server is listening on </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${port}</span></span></span><span class="hljs-string">...`</span></span>); server.listen(port); }); runner.on(runner.events.END_RUNNER, () =&gt; { server.close(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'storybook server is closed'</span></span>); }); runner .readTests(path) .done(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tests</span></span></span><span class="hljs-function"> =&gt;</span></span> runner.test(tests));</code> </pre> <br>  Como servidor para las pruebas, utilizamos http-server, que devuelve el contenido de la carpeta con el libro de cuentos ensamblado est치ticamente (para construir el libro de cuentos est치tico, use el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comando build-storybook</a> ). <br><br>  Hasta ahora, todo ha ido bien, pero los problemas no se han hecho esperar.  El hecho es que el libro de cuentos muestra la historia dentro del marco.  Inicialmente, quer칤amos poder establecer la regi칩n selectiva de la imagen usando setCaptureElements (), pero esto solo se puede hacer si especifica la direcci칩n del marco como la direcci칩n del conjunto, algo como esto: <br><br><pre> <code class="javascript hljs">gemini.suite(<span class="hljs-string"><span class="hljs-string">'VisualRegression'</span></span>, suite =&gt; suite.setUrl(<span class="hljs-string"><span class="hljs-string">'http://localhost:6006/iframe.html?selectedKind=regression%2Fcards&amp;selectedStory=IncomingLetter'</span></span>) .setCaptureElements(<span class="hljs-string"><span class="hljs-string">'.some-component'</span></span>) .capture(<span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>) );</code> </pre><br>  Pero luego resulta que para cada toma debemos crear nuestra propia suite, porque  La URL se puede configurar para la suite en su conjunto, pero no para una sola instant치nea dentro de la suite.  Debe entenderse que cada suite se ejecuta en una sesi칩n de navegador separada.  Esto, en principio, es correcto: las pruebas no deber칤an depender unas de otras, pero abrir una sesi칩n de navegador separada y la posterior carga del Storybook lleva bastante tiempo, mucho m치s que simplemente moverse a trav칠s de las historias en el marco del Storybook ya abierto.  Por lo tanto, con un gran n칰mero de suites, el tiempo de ejecuci칩n de la prueba es muy lento.  Parte del problema puede resolverse paralelizando la ejecuci칩n de las pruebas, pero la paralelizaci칩n consume muchos recursos (memoria, procesador).  Por lo tanto, habiendo decidido ahorrar en recursos y al mismo tiempo no perder demasiado en la duraci칩n de la ejecuci칩n de la prueba, nos negamos a abrir el marco en una ventana separada del navegador.  Las pruebas se realizan dentro de una sola sesi칩n del navegador, pero antes de cada disparo, la siguiente historia se carga en el marco como si simplemente abri칠ramos el libro de historias y hici칠ramos clic en nodos individuales en el 치rbol de historias.  츼rea de imagen - fotograma completo: <br><br><pre> <code class="javascript hljs">gemini.suite(<span class="hljs-string"><span class="hljs-string">'VisualRegression'</span></span>, suite =&gt; suite.setUrl(<span class="hljs-string"><span class="hljs-string">'/'</span></span>) .setCaptureElements(<span class="hljs-string"><span class="hljs-string">'#storybook-preview-iframe'</span></span>) .capture(<span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>, actions =&gt; openStory(actions, <span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>)) .capture(<span class="hljs-string"><span class="hljs-string">'ProjectDocument'</span></span>, actions =&gt; openStory(actions, <span class="hljs-string"><span class="hljs-string">'ProjectDocumentAccess'</span></span>)) .capture(<span class="hljs-string"><span class="hljs-string">'RelatedDocuments'</span></span>, actions =&gt; { openStory(actions, <span class="hljs-string"><span class="hljs-string">'RelatedDocuments'</span></span>); hover(actions, <span class="hljs-string"><span class="hljs-string">'.related-documents-tree-item__title'</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }) );</code> </pre> <br>  Desafortunadamente, en esta opci칩n, adem치s de la capacidad de seleccionar el 치rea de la imagen, tambi칠n perdimos la capacidad de usar acciones est치ndar del motor Gemini para trabajar con elementos del 치rbol DOM (mouseDown (), mouseMove (), focus (), etc.), etc. a.  Los elementos dentro del marco de Gemini no "ven".  Pero a칰n tenemos la oportunidad de usar la funci칩n executeJS (), con la que puede ejecutar c칩digo JavaScript en un contexto de navegador.  En funci칩n de esta funci칩n, implementamos los an치logos de las acciones est치ndar que necesitamos, que ya funcionan en el contexto del marco de Storybook.  Aqu칤 tuvimos que "evocar" un poco para transferir los valores de los par치metros del contexto de prueba al contexto del navegador. Lamentablemente, executeJS () no brinda esa oportunidad.  Por lo tanto, a primera vista, el c칩digo parece un poco extra침o: la funci칩n se traduce en una cadena, parte del c칩digo se reemplaza con valores de par치metros y en ExecuteJs () la funci칩n se restaura de la cadena usando eval (): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openStory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actions, storyName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> storyNameLowered = storyName.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clickTo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">window</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.document.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'a'</span></span>)).filter( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> el.textContent.toLowerCase() === <span class="hljs-string"><span class="hljs-string">'storyNameLowered'</span></span>; })[<span class="hljs-number"><span class="hljs-number">0</span></span>].click(); }; actions.executeJS(<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">`(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${clickTo.toString().replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'storyNameLowered'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, storyNameLowered)}</span></span></span><span class="hljs-string">)`</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatchEvents</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actions, targets, index, events</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dispatch = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">window</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.document.querySelector(<span class="hljs-string"><span class="hljs-string">'#storybook-preview-iframe'</span></span>).contentWindow.document; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> target = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'targets'</span></span>)[index || <span class="hljs-number"><span class="hljs-number">0</span></span>]; events.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clickEvent = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createEvent(<span class="hljs-string"><span class="hljs-string">'MouseEvents'</span></span>); clickEvent.initEvent(event, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); target.dispatchEvent(clickEvent); }); }; actions.executeJS(<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">`(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dispatch.toString() .replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'targets'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, targets) .replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'index'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, index) .replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'events'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`["</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${events.join(</span></span></span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'","'</span></span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">)}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">"]`</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">)`</span></span> )); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hover</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actions, selectors, index</span></span></span><span class="hljs-function">) </span></span>{ dispatchEvents(actions, selectors, index, [ <span class="hljs-string"><span class="hljs-string">'mouseenter'</span></span>, <span class="hljs-string"><span class="hljs-string">'mouseover'</span></span> ]); } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">openStory</span></span>: openStory, <span class="hljs-attr"><span class="hljs-attr">hover</span></span>: hover };</code> </pre><br><h2>  Repeticiones de ejecuci칩n </h2><br>  Despu칠s de que se escribieron las pruebas visuales y comenzaron a funcionar, result칩 que algunas de las pruebas no eran muy estables.  En alg칰n lugar, el icono no tendr치 tiempo para dibujar, en alg칰n lugar la selecci칩n no se eliminar치 y obtendremos una discrepancia con la imagen de referencia.  Por lo tanto, se decidi칩 incluir nuevas pruebas de ejecuci칩n de la prueba.  Sin embargo, en Gemini, los reintentos funcionan para toda la suite y, como se mencion칩 anteriormente, tratamos de evitar situaciones en las que se crea una suite para cada disparo; esto ralentiza demasiado la ejecuci칩n de las pruebas.  Por otro lado, cuantas m치s tomas se tomen dentro del marco de una suite, mayor es la probabilidad de que la ejecuci칩n repetida de la suite caiga tan bien como la anterior.  Por lo tanto, fue necesario implementar reintentos.  En nuestro esquema, la repetici칩n de la ejecuci칩n no se realiza para toda la suite, sino solo para aquellas im치genes que no pasaron en la ejecuci칩n fallida anterior.  Para hacer esto, en el controlador de eventos TEST_RESULT, analizamos el resultado de comparar la instant치nea con el est치ndar, y para las instant치neas que no pasaron la comparaci칩n, y solo para ellas, creamos un nuevo conjunto: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SuiteCollection = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gemini/lib/suite-collection'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Suite = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gemini/lib/suite'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retrySuiteCollection; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retryCount = <span class="hljs-number"><span class="hljs-number">2</span></span>; runner.on(runner.events.BEGIN, () =&gt; { retrySuiteCollection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SuiteCollection(); }); runner.on(runner.events.TEST_RESULT, args =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testId = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args.state.name}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args.suite.name}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args.browserId}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!args.equal) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retryCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.yellow(<span class="hljs-string"><span class="hljs-string">`failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testId}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.red(<span class="hljs-string"><span class="hljs-string">`failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testId}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suite = retrySuiteCollection.topLevelSuites().find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.name === args.suite.name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!suite) { suite = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Suite(args.suite.name); suite.url = args.suite.url; suite.file = args.suite.file; suite.path = args.suite.path; suite.captureSelectors = [ ...args.suite.captureSelectors ]; suite.browsers = [ ...args.suite.browsers ]; suite.skipped = [ ...args.suite.skipped ]; suite.beforeActions = [ ...args.suite.beforeActions ]; retrySuiteCollection.add(suite); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!suite.states.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.name === args.state.name)) { suite.addState(args.state.clone()); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.green(<span class="hljs-string"><span class="hljs-string">`passed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testId}</span></span></span><span class="hljs-string">`</span></span>)); });</code> </pre> <br>  Por cierto, el evento TEST_RESULT tambi칠n fue 칰til para visualizar el progreso de las pruebas a medida que pasaban.  Ahora el desarrollador no necesita esperar hasta que se completen todas las pruebas, puede interrumpir la ejecuci칩n si ve que algo sali칩 mal.  Si se interrumpe la ejecuci칩n de la prueba, Gemini cerrar치 correctamente las sesiones de navegador abiertas por el servidor de selenio. <br><br>  Al finalizar la ejecuci칩n de la prueba, si el nuevo conjunto no est치 vac칤o, ejec칰telo hasta que se agote el n칰mero m치ximo de repeticiones: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((retryCount--) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; result.failed &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; retrySuiteCollection.topLevelSuites().length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { runner.test(retrySuiteCollection, {}).done(onComplete); } } runner.readTests(path).done(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tests</span></span></span><span class="hljs-function"> =&gt;</span></span> runner.test(tests).done(onComplete));</code> </pre> <br><h2>  Resumen </h2><br>  Hoy tenemos alrededor de cincuenta pruebas visuales que cubren los principales estados visuales de nuestra aplicaci칩n.  Por supuesto, no hay necesidad de hablar sobre la cobertura total de las pruebas de IU, pero a칰n no hemos establecido ese objetivo.  Las pruebas funcionan con 칠xito tanto en las estaciones de trabajo de los desarrolladores como en los agentes de compilaci칩n.  Si bien las pruebas se realizan solo en el contexto de Chrome e Internet Explorer, en el futuro es posible conectar otros navegadores.  Toda esta econom칤a sirve a la red Selemium con dos nodos implementados en m치quinas virtuales. <br><br>  De vez en cuando, nos enfrentamos con el hecho de que despu칠s del lanzamiento de la nueva versi칩n de Chrome es necesario actualizar las im치genes de referencia debido al hecho de que algunos elementos comenzaron a mostrarse de manera un poco diferente (por ejemplo, desplazadores), pero no hay nada que hacer al respecto.  Es raro, pero sucede que al cambiar la estructura de un almacenamiento redux, debe recuperar los estados guardados para las pruebas.  Por supuesto, restaurar exactamente el mismo estado que estaba en la prueba en el momento de su creaci칩n no es f치cil.  Como regla general, nadie recuerda en qu칠 base de datos se tomaron estas im치genes y debe tomar una nueva imagen con otros datos.  Este es un problema, pero no grande.  Para resolverlo, puede tomar fotograf칤as en una base de demostraci칩n, ya que tenemos scripts para su generaci칩n y estamos actualizados. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/454464/">https://habr.com/ru/post/454464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454452/index.html">Mostramos contenido en la imagen reconocida de acuerdo con ciertas reglas</a></li>
<li><a href="../454456/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. D칤a 7. Preguntas frecuentes</a></li>
<li><a href="../454458/index.html">Pruebas metam칩rficas: por qu칠 casi nadie sabe acerca de esta t칠cnica prometedora</a></li>
<li><a href="../454460/index.html">El resumen de materiales interesantes para el desarrollador m칩vil # 300 (27 de mayo - 2 de junio)</a></li>
<li><a href="../454462/index.html">Fotograma sin papel fotogr치fico</a></li>
<li><a href="../454470/index.html">La vida antes del tiempo de ejecuci칩n. Informe Yandex</a></li>
<li><a href="../454472/index.html">Lo que necesita saber sobre el 칰ltimo parche de enrutador de Cisco</a></li>
<li><a href="../454474/index.html">Eventos digitales en Mosc칰 del 3 al 9 de junio.</a></li>
<li><a href="../454476/index.html">Mejores pr치cticas Node.js - Consejos de estructura del proyecto</a></li>
<li><a href="../454478/index.html">Se anuncia la extensi칩n de Azure IoT Edge Tools (Vista previa)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>