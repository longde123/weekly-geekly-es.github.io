<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>◻️ 💦 🍮 Desarrollo de pruebas visuales basadas en Gemini y Storybook. ⛄️ 👆🏾 🚠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! En este artículo quiero compartir la experiencia de desarrollar pruebas visuales en nuestro equipo. 

 Sucedió que no pensamos de inmediato...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo de pruebas visuales basadas en Gemini y Storybook.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454464/">  Hola Habr!  En este artículo quiero compartir la experiencia de desarrollar pruebas visuales en nuestro equipo. <br><br>  Sucedió que no pensamos de inmediato en las pruebas de diseño.  Bueno, algunos cuadros se moverán por un par de píxeles, bueno, arréglenlo.  Al final, hay probadores: la mosca no volará más allá de ellos.  Pero el factor humano todavía no se puede engañar: detectar cambios menores en la interfaz de usuario está lejos de ser siempre físicamente posible, incluso para un probador.  La pregunta surgió cuando se comenzó la optimización seria del diseño y la transición a BEM.  Aquí, ciertamente no habría sido sin pérdidas, y necesitábamos desesperadamente una forma automatizada de detectar situaciones cuando, como resultado de ediciones, algo en la interfaz de usuario comienza a cambiar no según lo previsto, o no como estaba previsto. <br><a name="habracut"></a><br>  Cualquier desarrollador sabe acerca de las pruebas de código de unidad.  Las pruebas unitarias dan confianza de que los cambios en el código no rompieron nada.  Bueno, al menos no se rompieron en la parte para la que hay pruebas.  El mismo principio se puede aplicar a la interfaz de usuario.  Al igual que las clases de prueba de prueba, las pruebas visuales prueban los componentes visuales que conforman la interfaz de usuario de una aplicación. <br><br>  Para los componentes visuales, puede escribir pruebas unitarias "clásicas", que, por ejemplo, inician la representación de componentes con diferentes valores de parámetros de entrada y comprueban el estado esperado del árbol DOM utilizando declaraciones de aserción, comparando elementos individuales o una instantánea del árbol DOM del componente con la referencia en general  Las pruebas visuales también se basan en instantáneas, pero ya en instantáneas de la visualización del componente (capturas de pantalla).  La esencia de la prueba visual es comparar la imagen tomada durante la prueba con la de referencia y, si se encuentran diferencias, aceptar la nueva imagen como referencia o corregir el error que causó estas diferencias. <br><br>  Por supuesto, el "examen" de los componentes visuales individuales no es muy efectivo.  Los componentes no viven en el vacío y su visualización puede depender de los componentes de nivel superior o de los vecinos.  No importa cómo probamos los componentes individuales, la imagen en su conjunto puede tener defectos.  Por otro lado, si toma imágenes de toda la ventana de la aplicación, muchas de las imágenes contendrán los mismos componentes, lo que significa que si cambia un componente, nos veremos obligados a actualizar todas las imágenes en las que este componente está presente. <br><br>  La verdad, como de costumbre, está en algún lugar en el medio: puede dibujar la página completa de la aplicación, pero tomar una fotografía de solo un área bajo la cual se crea la prueba, en el caso particular, esta área puede coincidir con el área de un componente específico, pero esto no será un componente en vacío, pero en un entorno muy real.  Y esto ya será similar a una prueba visual de la unidad, aunque difícilmente se puede decir acerca de la modularidad si la "unidad" sabe algo sobre el medio ambiente.  Bueno, está bien, no es tan importante si la categoría de pruebas incluye pruebas visuales, modulares o de integración.  Como dice el refrán, "¿revisas o te vas?" <br><br><h2>  Selección de herramienta </h2><br>  Para acelerar la ejecución de las pruebas, la representación de la página se puede hacer en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">navegador sin cabeza</a> que hace todo el trabajo en la memoria sin mostrarse en la pantalla y garantiza el máximo rendimiento.  Pero en nuestro caso, fue fundamental garantizar que la aplicación funcionara en Internet Explorer (IE), que no tiene un modo sin cabeza, y necesitábamos una herramienta para administrar los navegadores mediante programación.  Afortunadamente, todo ha sido inventado antes que nosotros y existe un instrumento de este tipo: se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">selenio</a> .  Como parte del proyecto Selenium, se están desarrollando controladores para administrar varios navegadores, incluido un controlador para IE.  El servidor Selenium puede administrar navegadores no solo localmente, sino también de forma remota, formando un grupo de servidores de selenio, la llamada grilla de selenio. <br><br>  El selenio es una herramienta poderosa, pero el umbral para ingresar es bastante alto.  Decidimos buscar herramientas listas para usar para pruebas visuales basadas en selenio y encontramos un maravilloso producto de Yandex llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gemini</a> .  Gemini puede tomar fotografías, incluidas imágenes de un área determinada de la página, comparar imágenes con referencias, visualizar la diferencia y tener en cuenta momentos como el suavizado o un cursor parpadeante.  Además, Gemini puede hacer repeticiones de pruebas caídas, paralelizar la ejecución de pruebas y muchas otras ventajas.  En general, decidimos intentarlo. <br><br>  Las pruebas de Géminis son fáciles de escribir.  Primero debe preparar la infraestructura: instale <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">selenium-standalone</a> e inicie el servidor de selenium.  Luego configure gemini, especificando la dirección de la aplicación bajo prueba (rootUrl), la dirección del servidor de selenio (gridUrl), la composición y configuración de los navegadores, así como los complementos necesarios para generar informes, optimizando la compresión de imágenes.  Ejemplo de configuración: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//.gemini.js module.exports = { rootUrl: 'http://my-app.ru', gridUrl: 'http://127.0.0.1:4444/wd/hub', browsers: { chrome: { windowSize: '1920x1080', screenshotsDir:'gemini/screens/1920x1080' desiredCapabilities: { browserName: 'chrome' } } }, system: { projectRoot: '', plugins: { 'html-reporter/gemini': { enabled: true, path: './report' }, 'gemini-optipng': true }, exclude: [ '**/report/*' ], diffColor: '#EC041E' } };</span></span></code> </pre> <br>  Las pruebas en sí mismas son una colección de suites, en cada una de las cuales se toman una o más imágenes (estados).  Antes de tomar una instantánea (método de captura ()), puede establecer el área de la página que se tomará mediante el método setCaptureElements (), y también realizar algunas acciones preparatorias si es necesario en el contexto del navegador utilizando los métodos del objeto de acciones o utilizando un código JavaScript arbitrario - para Esto en acciones tiene un método executeJS (). <br><br>  Un ejemplo: <br><br><pre> <code class="javascript hljs">gemini.suite(<span class="hljs-string"><span class="hljs-string">'login-dialog'</span></span>, suite =&gt; { suite.setUrl(<span class="hljs-string"><span class="hljs-string">'/'</span></span>) .setCaptureElements(<span class="hljs-string"><span class="hljs-string">'.login__form'</span></span>) .capture(<span class="hljs-string"><span class="hljs-string">'default'</span></span>); .capture(<span class="hljs-string"><span class="hljs-string">'focused'</span></span>, actions =&gt; actions.focus(<span class="hljs-string"><span class="hljs-string">'.login__editor'</span></span>)); });</code> </pre> <br><h2>  Datos de prueba </h2><br>  Se eligió una herramienta de prueba, pero aún quedaba un largo camino hacia la solución final.  Era necesario entender qué hacer con los datos que se muestran en las imágenes.  Permítanme recordarles que en las pruebas decidimos no dibujar componentes individuales, sino toda la página de la aplicación, para probar los componentes visuales no en el vacío, sino en el entorno real de otros componentes.  Si necesita transferir los datos de prueba necesarios a los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">accesorios</a> ee (estoy hablando de componentes de reacción) para renderizar un componente individual, se necesita mucho más para renderizar toda la página de la aplicación, y preparar el entorno para tal prueba puede ser un dolor de cabeza. <br><br>  Por supuesto, puede dejar que la aplicación misma reciba datos para que durante la prueba ejecute solicitudes al backend, que, a su vez, recibiría datos de algún tipo de base de datos de referencia, pero ¿qué pasa con el control de versiones?  No puedes poner una base de datos en un repositorio git.  No, por supuesto que puedes, pero hay algunas deficiencias. <br><br>  Alternativamente, para ejecutar pruebas, puede reemplazar el servidor de fondo real con uno falso, lo que le daría a la aplicación web no datos de la base de datos, sino datos estáticos almacenados, por ejemplo, en formato json, ya con las fuentes.  Sin embargo, la preparación de tales datos tampoco es demasiado trivial.  Decidimos seguir el camino más fácil: no extraer los datos del servidor, sino simplemente restaurar el estado de la aplicación (en nuestro caso, el estado del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">almacenamiento redux</a> ), que estaba en la aplicación en el momento en que se tomó la imagen de referencia, antes de ejecutar la prueba. <br><br>  Para serializar el estado actual de la tienda redux, se ha agregado el método snapshot () al objeto de ventana: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> snapshotStore = (store: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>, <span class="hljs-attr"><span class="hljs-attr">fileName</span></span>: string): <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = store.getState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Blob( [ <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(state, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) ], { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span> } ); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); a.href = URL.createObjectURL(file); a.download = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${fileName}</span></span></span><span class="hljs-string">.testdata.json`</span></span>; a.click(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`State downloaded to </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a.download}</span></span></span><span class="hljs-string">`</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(reducer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.snapshot = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileName</span></span></span><span class="hljs-function"> =&gt;</span></span> snapshotStore(store, fileName); };</code> </pre><br>  Usando este método, usando la línea de comandos de la consola del navegador, puede guardar el estado actual del almacenamiento redux en un archivo: <br><br><img src="https://habrastorage.org/webt/qf/t0/yq/qft0yqppzfe_issnjy74jon-vbs.png" alt="imagen"><br><br>  Como infraestructura para las pruebas visuales, se eligió <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Storybook</a> , una herramienta para el desarrollo interactivo de bibliotecas de componentes visuales.  La idea principal era que, en lugar de los diversos estados de los componentes en el árbol de historias, arreglara los diversos estados de nuestra aplicación y los utilizara para tomar capturas de pantalla.  Al final, no hay una diferencia fundamental entre componentes simples y complejos, excepto en la preparación del medio ambiente. <br><br>  Por lo tanto, cada prueba visual es una historia, antes de mostrar el estado del almacenamiento redux previamente guardado en el archivo.  Esto se hace usando el componente Proveedor de la biblioteca react-redux, a la propiedad de la tienda de la cual se pasa el estado deserializado restaurado del archivo guardado previamente: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> preloadedState <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./incoming-letter.testdata'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(rootReducer, preloadedState); storiesOf(<span class="hljs-string"><span class="hljs-string">'regression/Cards'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>) .add(<span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">store</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MemoryRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ContextContainer</span></span></span></span><span class="xml"><span class="hljs-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...dummyProps</span></span></span></span><span class="xml"><span class="hljs-tag">}/&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MemoryRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); });</span></span></code> </pre><br>  En el ejemplo anterior, ContextContainer es un componente que incluye el "esqueleto" de la aplicación: el árbol de navegación, el encabezado y el área de contenido.  En el área de contenido, se pueden representar varios componentes (lista, tarjeta, diálogo, etc.) según el estado actual del almacenamiento redux.  Para que el componente no cumpla solicitudes innecesarias al backend para la entrada, se le pasan las propiedades de código auxiliar correspondientes. <br><br>  En el contexto de un Storybook, se ve más o menos así: <br><br><img src="https://habrastorage.org/webt/jx/0m/ux/jx0muxytucrqrwzpvtnskjuqs1a.png" alt="imagen"><br><br><h2>  Libro de cuentos Gemini + </h2><br>  Entonces, descubrimos los datos para las pruebas.  La siguiente tarea es hacer amigos con Gemini y Storybook.  A primera vista, todo es simple: en la configuración de Gemini especificamos la dirección de la aplicación bajo prueba.  En nuestro caso, esta es la dirección del servidor de Storybook.  Solo necesita elevar el servidor del libro de cuentos antes de comenzar las pruebas de gemini.  Puede hacerlo directamente desde el código utilizando la suscripción de evento Gemini START_RUNNER y END_RUNNER: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> port = <span class="hljs-number"><span class="hljs-number">6006</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cofiguration = { <span class="hljs-attr"><span class="hljs-attr">rootUrl</span></span>:<span class="hljs-string"><span class="hljs-string">`localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${port}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">gridUrl</span></span>: seleniumGridHubUrl, <span class="hljs-attr"><span class="hljs-attr">browsers</span></span>: { <span class="hljs-string"><span class="hljs-string">'chrome'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">screenshotsDir</span></span>:<span class="hljs-string"><span class="hljs-string">'gemini/screens'</span></span>, <span class="hljs-attr"><span class="hljs-attr">desiredCapabilities</span></span>: chromeCapabilities } } }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Gemini = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gemini'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HttpServer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http-server'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> runner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Gemini(cofiguration); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = HttpServer.createServer({ <span class="hljs-attr"><span class="hljs-attr">root</span></span>: <span class="hljs-string"><span class="hljs-string">'./storybook-static'</span></span>}); runner.on(runner.events.START_RUNNER, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`storybook server is listening on </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${port}</span></span></span><span class="hljs-string">...`</span></span>); server.listen(port); }); runner.on(runner.events.END_RUNNER, () =&gt; { server.close(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'storybook server is closed'</span></span>); }); runner .readTests(path) .done(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tests</span></span></span><span class="hljs-function"> =&gt;</span></span> runner.test(tests));</code> </pre> <br>  Como servidor para las pruebas, utilizamos http-server, que devuelve el contenido de la carpeta con el libro de cuentos ensamblado estáticamente (para construir el libro de cuentos estático, use el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comando build-storybook</a> ). <br><br>  Hasta ahora, todo ha ido bien, pero los problemas no se han hecho esperar.  El hecho es que el libro de cuentos muestra la historia dentro del marco.  Inicialmente, queríamos poder establecer la región selectiva de la imagen usando setCaptureElements (), pero esto solo se puede hacer si especifica la dirección del marco como la dirección del conjunto, algo como esto: <br><br><pre> <code class="javascript hljs">gemini.suite(<span class="hljs-string"><span class="hljs-string">'VisualRegression'</span></span>, suite =&gt; suite.setUrl(<span class="hljs-string"><span class="hljs-string">'http://localhost:6006/iframe.html?selectedKind=regression%2Fcards&amp;selectedStory=IncomingLetter'</span></span>) .setCaptureElements(<span class="hljs-string"><span class="hljs-string">'.some-component'</span></span>) .capture(<span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>) );</code> </pre><br>  Pero luego resulta que para cada toma debemos crear nuestra propia suite, porque  La URL se puede configurar para la suite en su conjunto, pero no para una sola instantánea dentro de la suite.  Debe entenderse que cada suite se ejecuta en una sesión de navegador separada.  Esto, en principio, es correcto: las pruebas no deberían depender unas de otras, pero abrir una sesión de navegador separada y la posterior carga del Storybook lleva bastante tiempo, mucho más que simplemente moverse a través de las historias en el marco del Storybook ya abierto.  Por lo tanto, con un gran número de suites, el tiempo de ejecución de la prueba es muy lento.  Parte del problema puede resolverse paralelizando la ejecución de las pruebas, pero la paralelización consume muchos recursos (memoria, procesador).  Por lo tanto, habiendo decidido ahorrar en recursos y al mismo tiempo no perder demasiado en la duración de la ejecución de la prueba, nos negamos a abrir el marco en una ventana separada del navegador.  Las pruebas se realizan dentro de una sola sesión del navegador, pero antes de cada disparo, la siguiente historia se carga en el marco como si simplemente abriéramos el libro de historias y hiciéramos clic en nodos individuales en el árbol de historias.  Área de imagen - fotograma completo: <br><br><pre> <code class="javascript hljs">gemini.suite(<span class="hljs-string"><span class="hljs-string">'VisualRegression'</span></span>, suite =&gt; suite.setUrl(<span class="hljs-string"><span class="hljs-string">'/'</span></span>) .setCaptureElements(<span class="hljs-string"><span class="hljs-string">'#storybook-preview-iframe'</span></span>) .capture(<span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>, actions =&gt; openStory(actions, <span class="hljs-string"><span class="hljs-string">'IncomingLetter'</span></span>)) .capture(<span class="hljs-string"><span class="hljs-string">'ProjectDocument'</span></span>, actions =&gt; openStory(actions, <span class="hljs-string"><span class="hljs-string">'ProjectDocumentAccess'</span></span>)) .capture(<span class="hljs-string"><span class="hljs-string">'RelatedDocuments'</span></span>, actions =&gt; { openStory(actions, <span class="hljs-string"><span class="hljs-string">'RelatedDocuments'</span></span>); hover(actions, <span class="hljs-string"><span class="hljs-string">'.related-documents-tree-item__title'</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }) );</code> </pre> <br>  Desafortunadamente, en esta opción, además de la capacidad de seleccionar el área de la imagen, también perdimos la capacidad de usar acciones estándar del motor Gemini para trabajar con elementos del árbol DOM (mouseDown (), mouseMove (), focus (), etc.), etc. a.  Los elementos dentro del marco de Gemini no "ven".  Pero aún tenemos la oportunidad de usar la función executeJS (), con la que puede ejecutar código JavaScript en un contexto de navegador.  En función de esta función, implementamos los análogos de las acciones estándar que necesitamos, que ya funcionan en el contexto del marco de Storybook.  Aquí tuvimos que "evocar" un poco para transferir los valores de los parámetros del contexto de prueba al contexto del navegador. Lamentablemente, executeJS () no brinda esa oportunidad.  Por lo tanto, a primera vista, el código parece un poco extraño: la función se traduce en una cadena, parte del código se reemplaza con valores de parámetros y en ExecuteJs () la función se restaura de la cadena usando eval (): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openStory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actions, storyName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> storyNameLowered = storyName.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clickTo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">window</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.document.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'a'</span></span>)).filter( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> el.textContent.toLowerCase() === <span class="hljs-string"><span class="hljs-string">'storyNameLowered'</span></span>; })[<span class="hljs-number"><span class="hljs-number">0</span></span>].click(); }; actions.executeJS(<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">`(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${clickTo.toString().replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'storyNameLowered'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, storyNameLowered)}</span></span></span><span class="hljs-string">)`</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatchEvents</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actions, targets, index, events</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dispatch = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">window</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.document.querySelector(<span class="hljs-string"><span class="hljs-string">'#storybook-preview-iframe'</span></span>).contentWindow.document; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> target = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'targets'</span></span>)[index || <span class="hljs-number"><span class="hljs-number">0</span></span>]; events.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clickEvent = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createEvent(<span class="hljs-string"><span class="hljs-string">'MouseEvents'</span></span>); clickEvent.initEvent(event, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); target.dispatchEvent(clickEvent); }); }; actions.executeJS(<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">`(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dispatch.toString() .replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'targets'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, targets) .replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'index'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, index) .replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'events'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`["</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${events.join(</span></span></span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'","'</span></span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">)}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">"]`</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">)`</span></span> )); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hover</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actions, selectors, index</span></span></span><span class="hljs-function">) </span></span>{ dispatchEvents(actions, selectors, index, [ <span class="hljs-string"><span class="hljs-string">'mouseenter'</span></span>, <span class="hljs-string"><span class="hljs-string">'mouseover'</span></span> ]); } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">openStory</span></span>: openStory, <span class="hljs-attr"><span class="hljs-attr">hover</span></span>: hover };</code> </pre><br><h2>  Repeticiones de ejecución </h2><br>  Después de que se escribieron las pruebas visuales y comenzaron a funcionar, resultó que algunas de las pruebas no eran muy estables.  En algún lugar, el icono no tendrá tiempo para dibujar, en algún lugar la selección no se eliminará y obtendremos una discrepancia con la imagen de referencia.  Por lo tanto, se decidió incluir nuevas pruebas de ejecución de la prueba.  Sin embargo, en Gemini, los reintentos funcionan para toda la suite y, como se mencionó anteriormente, tratamos de evitar situaciones en las que se crea una suite para cada disparo; esto ralentiza demasiado la ejecución de las pruebas.  Por otro lado, cuantas más tomas se tomen dentro del marco de una suite, mayor es la probabilidad de que la ejecución repetida de la suite caiga tan bien como la anterior.  Por lo tanto, fue necesario implementar reintentos.  En nuestro esquema, la repetición de la ejecución no se realiza para toda la suite, sino solo para aquellas imágenes que no pasaron en la ejecución fallida anterior.  Para hacer esto, en el controlador de eventos TEST_RESULT, analizamos el resultado de comparar la instantánea con el estándar, y para las instantáneas que no pasaron la comparación, y solo para ellas, creamos un nuevo conjunto: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SuiteCollection = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gemini/lib/suite-collection'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Suite = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gemini/lib/suite'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retrySuiteCollection; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retryCount = <span class="hljs-number"><span class="hljs-number">2</span></span>; runner.on(runner.events.BEGIN, () =&gt; { retrySuiteCollection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SuiteCollection(); }); runner.on(runner.events.TEST_RESULT, args =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testId = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args.state.name}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args.suite.name}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args.browserId}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!args.equal) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retryCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.yellow(<span class="hljs-string"><span class="hljs-string">`failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testId}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.red(<span class="hljs-string"><span class="hljs-string">`failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testId}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suite = retrySuiteCollection.topLevelSuites().find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.name === args.suite.name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!suite) { suite = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Suite(args.suite.name); suite.url = args.suite.url; suite.file = args.suite.file; suite.path = args.suite.path; suite.captureSelectors = [ ...args.suite.captureSelectors ]; suite.browsers = [ ...args.suite.browsers ]; suite.skipped = [ ...args.suite.skipped ]; suite.beforeActions = [ ...args.suite.beforeActions ]; retrySuiteCollection.add(suite); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!suite.states.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.name === args.state.name)) { suite.addState(args.state.clone()); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.green(<span class="hljs-string"><span class="hljs-string">`passed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testId}</span></span></span><span class="hljs-string">`</span></span>)); });</code> </pre> <br>  Por cierto, el evento TEST_RESULT también fue útil para visualizar el progreso de las pruebas a medida que pasaban.  Ahora el desarrollador no necesita esperar hasta que se completen todas las pruebas, puede interrumpir la ejecución si ve que algo salió mal.  Si se interrumpe la ejecución de la prueba, Gemini cerrará correctamente las sesiones de navegador abiertas por el servidor de selenio. <br><br>  Al finalizar la ejecución de la prueba, si el nuevo conjunto no está vacío, ejecútelo hasta que se agote el número máximo de repeticiones: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((retryCount--) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; result.failed &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; retrySuiteCollection.topLevelSuites().length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { runner.test(retrySuiteCollection, {}).done(onComplete); } } runner.readTests(path).done(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tests</span></span></span><span class="hljs-function"> =&gt;</span></span> runner.test(tests).done(onComplete));</code> </pre> <br><h2>  Resumen </h2><br>  Hoy tenemos alrededor de cincuenta pruebas visuales que cubren los principales estados visuales de nuestra aplicación.  Por supuesto, no hay necesidad de hablar sobre la cobertura total de las pruebas de IU, pero aún no hemos establecido ese objetivo.  Las pruebas funcionan con éxito tanto en las estaciones de trabajo de los desarrolladores como en los agentes de compilación.  Si bien las pruebas se realizan solo en el contexto de Chrome e Internet Explorer, en el futuro es posible conectar otros navegadores.  Toda esta economía sirve a la red Selemium con dos nodos implementados en máquinas virtuales. <br><br>  De vez en cuando, nos enfrentamos con el hecho de que después del lanzamiento de la nueva versión de Chrome es necesario actualizar las imágenes de referencia debido al hecho de que algunos elementos comenzaron a mostrarse de manera un poco diferente (por ejemplo, desplazadores), pero no hay nada que hacer al respecto.  Es raro, pero sucede que al cambiar la estructura de un almacenamiento redux, debe recuperar los estados guardados para las pruebas.  Por supuesto, restaurar exactamente el mismo estado que estaba en la prueba en el momento de su creación no es fácil.  Como regla general, nadie recuerda en qué base de datos se tomaron estas imágenes y debe tomar una nueva imagen con otros datos.  Este es un problema, pero no grande.  Para resolverlo, puede tomar fotografías en una base de demostración, ya que tenemos scripts para su generación y estamos actualizados. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/454464/">https://habr.com/ru/post/454464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454452/index.html">Mostramos contenido en la imagen reconocida de acuerdo con ciertas reglas</a></li>
<li><a href="../454456/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. Día 7. Preguntas frecuentes</a></li>
<li><a href="../454458/index.html">Pruebas metamórficas: por qué casi nadie sabe acerca de esta técnica prometedora</a></li>
<li><a href="../454460/index.html">El resumen de materiales interesantes para el desarrollador móvil # 300 (27 de mayo - 2 de junio)</a></li>
<li><a href="../454462/index.html">Fotograma sin papel fotográfico</a></li>
<li><a href="../454470/index.html">La vida antes del tiempo de ejecución. Informe Yandex</a></li>
<li><a href="../454472/index.html">Lo que necesita saber sobre el último parche de enrutador de Cisco</a></li>
<li><a href="../454474/index.html">Eventos digitales en Moscú del 3 al 9 de junio.</a></li>
<li><a href="../454476/index.html">Mejores prácticas Node.js - Consejos de estructura del proyecto</a></li>
<li><a href="../454478/index.html">Se anuncia la extensión de Azure IoT Edge Tools (Vista previa)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>