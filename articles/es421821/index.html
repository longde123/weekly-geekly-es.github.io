<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöü ‚è© üåä Usamos mosaico, pixelaci√≥n y m√°scaras geom√©tricas de Voronoi en sombreadores para decorar el sitio. ü•ê ü§öüèø üö∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo es una continuaci√≥n l√≥gica de la introducci√≥n de sombreadores de programaci√≥n para dise√±adores de dise√±o . En √©l, creamos una plantilla ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usamos mosaico, pixelaci√≥n y m√°scaras geom√©tricas de Voronoi en sombreadores para decorar el sitio.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421821/"><img src="https://habrastorage.org/webt/tw/dv/y5/twdvy5bonlmr47omgfhgmi9rjqu.jpeg" alt="imagen"><br><br><p>  Este art√≠culo es una continuaci√≥n l√≥gica de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">introducci√≥n de sombreadores de programaci√≥n para dise√±adores de dise√±o</a> .  En √©l, creamos una plantilla para crear varios efectos bidimensionales con fotos usando sombreadores y observamos un par de ejemplos.  En este art√≠culo, agregaremos un par de texturas m√°s, aplicaremos la divisi√≥n Voronoi en la pr√°ctica para crear mosaicos a partir de ellos, hablaremos sobre la creaci√≥n de varias m√°scaras en sombreadores, sobre pixelaci√≥n y tambi√©n tocaremos algunos problemas de la antigua sintaxis GLSL que todav√≠a existe en nuestros navegadores. </p><br><p> Al igual que la √∫ltima vez, habr√° un m√≠nimo de teor√≠a y un m√°ximo de pr√°ctica y razonamiento en un lenguaje cotidiano mundano.  Los principiantes encontrar√°n aqu√≠ una secuencia de acciones con consejos y notas √∫tiles, y los vendedores frontales experimentados pueden encontrar un par de ideas para inspirarse. </p><a name="habracut"></a><br><p>  <em>Una encuesta en un art√≠culo anterior mostr√≥ que el tema de los efectos de WebGL para los sitios puede ser de inter√©s no solo para las m√°quinas de escribir, sino tambi√©n para nuestros colegas de otras especializaciones.</em>  <em>Para no confundirlos con las √∫ltimas caracter√≠sticas de ES, nos restringimos deliberadamente a construcciones de sintaxis m√°s tradicionales que todos entienden.</em>  <em>Y nuevamente, llamo la atenci√≥n de los lectores sobre el hecho de que los editores integrados de CodePen afectan el rendimiento de lo que se hace en ellos.</em> </p><br><p>  Pero empecemos ... </p><br><h2 id="shablon-dlya-raboty-s-sheyderami">  Plantilla para trabajar con sombreadores </h2><br><p>  Para aquellos que no han le√≠do el art√≠culo anterior, creamos esta plantilla para trabajar con sombreadores: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/ZMBMPJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  En √©l se crea un plano (en nuestro caso, un cuadrado) en el que se "dibuja" la textura de la imagen.  Sin dependencias innecesarias y un sombreador de v√©rtices muy simple.  Luego desarrollamos esta plantilla, pero ahora comenzaremos desde el momento en que a√∫n no hay l√≥gica en el sombreador de fragmentos. </p><br><h2 id="mozaika">  Mosaico </h2><br><p>  Mosaico es un plano dividido en peque√±as √°reas, donde cada una de las √°reas se rellena con un determinado color o, como en nuestro caso, textura.  ¬øC√≥mo podemos incluso romper nuestro avi√≥n en pedazos?  Obviamente, puedes dividirlo en rect√°ngulos.  Pero esto ya es tan f√°cil de hacer con la ayuda de SVG, arrastrar WebGL a esta tarea y dejar todo de la nada sin ning√∫n prop√≥sito. </p><br><p>  Para que el mosaico sea interesante, debe tener diferentes fragmentos, tanto en forma como en tama√±o.  Hay un enfoque muy simple, pero al mismo tiempo muy entretenido para construir tal partici√≥n.  Es conocido como el mosaico de Voronoi o la partici√≥n de Dirichlet, y en Wikipedia escriben que Descartes us√≥ algo similar en el lejano siglo XVII.  La idea es algo como esto: </p><br><ul><li>  Toma un conjunto de puntos en el avi√≥n. </li><li>  Para cada punto en el plano, encuentre el punto m√°s cercano de este conjunto. </li><li>  Eso es todo  El plano se divide en √°reas poligonales, cada una de las cuales est√° determinada por uno de los puntos del conjunto. </li></ul><br><p>  Probablemente sea mejor mostrar este proceso con un ejemplo pr√°ctico.  Existen diferentes algoritmos para generar esta partici√≥n, pero actuaremos en la frente, porque calcular algo para cada punto en el plano es solo la tarea del sombreador.  Primero necesitamos hacer un conjunto de puntos aleatorios.  Para no cargar el c√≥digo de ejemplos, crearemos una variable global para ellos. </p><br><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { POINTS.push([<span class="hljs-type"><span class="hljs-type">Math.random</span></span>(), <span class="hljs-type"><span class="hljs-type">Math.random</span></span>()]); } }</code> </pre> <br><p>  Ahora tenemos que pasarlos a los sombreadores.  Los datos son globales, por lo que utilizaremos el modificador <code>uniform</code> .  Pero hay un punto sutil: no podemos simplemente pasar una matriz.  Parecer√≠a que el siglo XXI est√° en el patio, pero sin embargo no saldr√° nada.  Como resultado, debe transferir una matriz de puntos uno a la vez. </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { GL.uniform2fv(GL.getUniformLocation(PROGRAM, <span class="hljs-string"><span class="hljs-string">'u_points['</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-string"><span class="hljs-string">']'</span></span>), POINTS[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); }</code> </pre> <br><p>  Hoy, a menudo encontraremos problemas similares de inconsistencia entre lo que se espera y lo que est√° en los navegadores reales.  Por lo general, las lecciones de WebGL usan THREE.js y esta biblioteca oculta parte de la suciedad en s√≠ misma, como jQuery alguna vez hizo en sus tareas, pero si la elimina, realmente le duele el cerebro. </p><br><p>  En el sombreador de fragmentos, tenemos una variable de matriz para puntos.  Solo podemos crear matrices de una longitud fija.  Comencemos con 10 puntos: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUMBER_OF_POINTS 10 uniform vec2 u_points[NUMBER_OF_POINTS];</span></span></code> </pre> <br><p>  Aseg√∫rese de que todo esto funciona dibujando c√≠rculos en los lugares de los puntos.  Tal dibujo de varias primitivas geom√©tricas se usa a menudo durante la depuraci√≥n: son claramente visibles y puede comprender de inmediato qu√© se encuentra y hacia d√≥nde se mueve. </p><br><blockquote>  Use el "dibujo" de c√≠rculos, l√≠neas y otros puntos de referencia para los objetos invisibles sobre los que se construyen las animaciones.  Esto dar√° pistas obvias sobre c√≥mo funcionan, especialmente si los algoritmos son complejos de entender r√°pidamente sin una preparaci√≥n previa.  Luego, todo esto puede comentarse y dejarse en manos de sus colegas: dir√°n gracias. </blockquote><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) &lt; <span class="hljs-number"><span class="hljs-number">0.02</span></span>) { gl_FragColor = WHITE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/pONOme" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Bueno  Agreguemos tambi√©n algo de movimiento a los puntos.  Para comenzar, deje que se muevan en c√≠rculo, luego volveremos a este tema m√°s adelante.  Los coeficientes tambi√©n se ponen en el ojo, solo para ralentizar ligeramente su movimiento y reducir la amplitud de las oscilaciones. </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movePoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeStamp)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timeStamp) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] += Math.sin(i * timeStamp / <span class="hljs-number"><span class="hljs-number">5000.0</span></span>) / <span class="hljs-number"><span class="hljs-number">500.0</span></span>; POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] += Math.cos(i * timeStamp / <span class="hljs-number"><span class="hljs-number">5000.0</span></span>) / <span class="hljs-number"><span class="hljs-number">500.0</span></span>; } } }</code> </pre> <br><p>  Regresa al sombreador.  Para futuros experimentos, encontraremos n√∫meros √∫tiles de √°reas en las que se dividir√° todo.  Entonces, encontramos el punto m√°s cercano al p√≠xel actual del conjunto y guardamos el n√∫mero de ese punto: es el n√∫mero de √°rea. </p><br><pre> <code class="hljs matlab">float min_distance = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; int area_index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { float current_distance = distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current_distance &lt; min_distance) { min_distance = current_distance; area_index = <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; } }</code> </pre> <br><p>  Para probar el rendimiento, nuevamente pintamos todo en colores brillantes: </p><br><pre> <code class="hljs pgsql">gl_FragColor = texture2D(u_texture, texture_coord); gl_FragColor.g = abs(sin(<span class="hljs-type"><span class="hljs-type">float</span></span>(area_index))); gl_FragColor.b = abs(sin(<span class="hljs-type"><span class="hljs-type">float</span></span>(area_index)));</code> </pre> <br><blockquote>  La combinaci√≥n de m√≥dulo (abs) y funciones limitadas (en particular, sin y cos) se utilizan a menudo cuando se trabaja con efectos similares.  Por un lado, esto agrega un poco de aleatoriedad, y por otro lado, inmediatamente da un resultado normalizado de 0 a 1, lo cual es muy conveniente: tenemos muchos valores que se encuentran precisamente dentro de estos l√≠mites. </blockquote><p>  Tambi√©n encontraremos puntos m√°s o menos equidistantes de varios puntos del conjunto y los colorearemos.  Esta acci√≥n no lleva una carga √∫til especial, pero mirar el resultado sigue siendo interesante. </p><br><pre> <code class="hljs matlab">int number_of_near_points = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) &lt; min_distance + EPSILON) { number_of_near_points++; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number_of_near_points &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { gl_FragColor.rgb = vec3(<span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Deber√≠as obtener algo como esto: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/xaRavJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Esto todav√≠a es un borrador, todav√≠a lo finalizaremos.  Pero ahora el concepto general de tal separaci√≥n del avi√≥n es claro. </p><br><h2 id="mozaika-iz-fotografiy">  Mosaico de fotos </h2><br><p>  Est√° claro que en su forma pura no hay mucho beneficio de tal partici√≥n.  Para ampliar tus horizontes y solo por diversi√≥n, puedes jugar con √©l, pero en un sitio real valdr√≠a la pena agregar un par de fotos m√°s y hacer un mosaico de ellas.  Vamos a rehacer un poco la funci√≥n de crear texturas, para que haya m√°s de una. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTextures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(let i = 0; i &lt; URLS.textures.length; i++)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">; } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(index)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crossOrigin</span></span></span><span class="hljs-function"> = '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anonymous</span></span></span><span class="hljs-function">'; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onload</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt; { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texture</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activeTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL['TEXTURE' + index])</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, texture)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pixelStorei</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.UNPACK_FLIP_Y_WEBGL, true)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texImage2D</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, 0, GL.RGB, GL.RGB, GL.UNSIGNED_BYTE, image)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uniform1i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.getUniformLocation(PROGRAM, 'u_textures[' + index + ']')</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-function">); }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">src</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLS</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[index]</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><p>  No sucedi√≥ nada inusual, simplemente reemplazamos los ceros con el par√°metro de <code>index</code> y reutilizamos el c√≥digo existente para cargar las tres texturas.  En el sombreador, ahora tenemos una variedad de texturas: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUMBER_OF_TEXTURES 3 uniform sampler2D u_textures[NUMBER_OF_TEXTURES];</span></span></code> </pre> <br><p>  Ahora podemos usar el n√∫mero de √°rea guardado anteriormente para seleccionar una de las tres texturas.  Pero ... </p><br><p>  Pero antes de eso me gustar√≠a hacer una peque√±a digresi√≥n.  Sobre dolor  Sobre la sintaxis.  Javascript moderno (condicionalmente ES6 +) es un buen lenguaje.  Le permite expresar sus pensamientos a medida que surgen, no limita el marco a ning√∫n paradigma de programaci√≥n espec√≠fico, completa algunos puntos para nosotros y le permite centrarse m√°s en la idea que en su implementaci√≥n.  Para el creador, eso es todo.  Algunas personas creen que les da demasiada libertad y cambian a TypeScript, por ejemplo.  Pure C es un lenguaje m√°s riguroso.  Tambi√©n permite mucho, puedes atraer cualquier cosa, pero despu√©s de JS se percibe como un poco inc√≥modo, anticuado o algo as√≠.  Sin embargo, √©l todav√≠a es bueno.  GLSL tal como existe en los navegadores es simplemente algo.  No solo es un orden de magnitud m√°s estricto que C, sino que tambi√©n carece de muchos operadores familiares y construcciones de sintaxis.  Este es probablemente el mayor problema al escribir sombreadores m√°s o menos complejos para WebGL.  Detr√°s del horror en que se convierte el c√≥digo, puede ser muy dif√≠cil echar un vistazo al algoritmo original.  Algunos programadores piensan que hasta que aprendan C, el camino hacia los sombreadores est√° cerrado para ellos.  Entonces: el conocimiento de C no ayudar√° particularmente aqu√≠.  Aqu√≠ hay una especie de mundo propio.  El mundo de la locura, dinosaurios y muletas. </p><br><p>  ¬øC√≥mo puedo elegir una de las tres texturas que tienen un n√∫mero? El n√∫mero de √°rea.  El resto viene a la mente dividiendo el n√∫mero por el n√∫mero de texturas.  Buena idea  Solo el operador <code>%</code> , que las manos ya escriben, no est√° aqu√≠.  La impresi√≥n de comprender este hecho est√° bien descrita en la imagen: </p><br><p><img src="https://habrastorage.org/webt/3j/w3/on/3jw3on4pazjczkana82degd6gcc.png" alt="imagen"></p><br><p>  Por supuesto, usted dice: "S√≠, no hay problema, hay una funci√≥n de <code>mod</code> , ¬°vamos a tomarla!".  Pero resulta que ella no acepta dos enteros, solo fracciones.  Ok, bueno, haz un <code>float</code> con ellos.  Tambi√©n tenemos un <code>float</code> , pero necesitamos un <code>int</code> .  Debe volver a convertir todo, de lo contrario, existe una posibilidad no falsa de obtener un error de compilaci√≥n. </p><br><pre> <code class="hljs lisp">int texture_index = int(<span class="hljs-name"><span class="hljs-name">mod</span></span>(<span class="hljs-name"><span class="hljs-name">float</span></span>(<span class="hljs-name"><span class="hljs-name">area_index</span></span>), float(<span class="hljs-name"><span class="hljs-name">NUMBER_OF_TEXTURES</span></span>)))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Y aqu√≠ hay una pregunta ret√≥rica: ¬øtal vez ser√° m√°s f√°cil realizar su funci√≥n del resto de la divisi√≥n de enteros que tratar de ensamblarla a partir de m√©todos est√°ndar?  Y esta sigue siendo una funci√≥n simple, y sucede que se obtienen secuencias muy profundas de tales transformaciones en las que ya no est√° claro lo que est√° sucediendo. </p><br><p>  Bien, dej√©moslo como est√° por ahora.  Simplemente tome el color del p√≠xel deseado de la textura seleccionada y <code>gl_FragColor</code> a la variable <code>gl_FragColor</code> .  Entonces?  ¬øYa hicimos esto?  Y entonces este gato aparece de nuevo.  No puede usar una no constante al acceder a una matriz.  Y todo lo que calculamos ya no es una constante.  Ba-dum-tsss !!! </p><br><p>  Tienes que hacer algo como esto: </p><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">0</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">1</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">2</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">2</span></span>], texture_coord); }</code> </pre> <br><p>  De acuerdo, dicho c√≥digo es un camino directo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">govnokod.ru</a> , pero no obstante, es diferente de alguna manera.  Incluso la <code>switch-case</code> no est√° aqu√≠ para al menos de alguna manera ennoblecer esta desgracia.  Realmente hay otra muleta menos obvia que resuelve el mismo problema: </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>], texture_coord); } }</code> </pre> <br><p>  Contadores de ciclos, que aumentan en uno, el compilador puede contar como una constante.  Pero esto no funcion√≥ con una variedad de texturas: en el √∫ltimo Chrome, apareci√≥ un error que dec√≠a que era imposible hacer esto con una variedad de texturas.  Con una serie de n√∫meros, funcion√≥.  ¬øAdivina por qu√© funciona con una matriz, pero no con otra?  Si pensabas que el sistema de conversi√≥n de tipos en JS estaba lleno de magia, ordena el sistema "constante - no constante" en GLSL.  Lo curioso es que los resultados tambi√©n dependen de la tarjeta de video utilizada, por lo que las muletas dif√≠ciles que funcionaron en la tarjeta gr√°fica NVIDIA pueden descomponerse en AMD. </p><br><blockquote>  Es mejor evitar tales decisiones basadas en suposiciones sobre el compilador.  Tienden a romperse y son dif√≠ciles de probar. </blockquote><p>  La tristeza es tristeza.  Pero, si queremos hacer cosas interesantes, necesitamos abstraernos de todo esto y continuar. </p><br><p>  Por el momento, tenemos un mosaico de fotos.  Pero hay un detalle: si los puntos se acercan mucho, entonces hay una transici√≥n r√°pida de dos √°reas.  No es muy bonita  Debe agregar alg√∫n algoritmo que no permita que los puntos se acerquen.  Puede hacer una opci√≥n simple, en la que se verifican las distancias entre puntos y, si es menor que un cierto valor, los separamos.  Esta opci√≥n no est√° exenta de inconvenientes, en particular, a veces conduce a una peque√±a contracci√≥n de los puntos, pero en muchos casos puede ser suficiente, especialmente porque no hay muchos c√°lculos aqu√≠.  Las opciones m√°s avanzadas ser√≠an un sistema de cargas m√≥viles y una "telara√±a" en la cual pares de puntos est√°n conectados por resortes invisibles.  Si est√° interesado en implementarlos, puede encontrar f√°cilmente todas las f√≥rmulas en el libro de referencia de f√≠sica para la escuela secundaria. </p><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let j = i; j &lt; NUMBER_OF_POINTS; j++) { let deltaX = POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] - POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; let deltaY = POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] - POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>]; let distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) { POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaX); POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] += <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaY); POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] -= <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaX); POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] -= <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaY); } } }</code> </pre> <br><p>  El principal problema con este enfoque, as√≠ como con el que usamos en el sombreador, es comparar todos los puntos con todos.  No necesita ser un gran matem√°tico para comprender que la cantidad de c√°lculos de distancia ser√° incre√≠ble si no hacemos 10 puntos, sino 1000. S√≠, incluso 100 es suficiente para que todo disminuya la velocidad.  Por lo tanto, tiene sentido aplicarlo solo para un peque√±o n√∫mero de puntos. </p><br><p>  Si queremos hacer un mosaico para una gran cantidad de puntos, entonces podemos usar la divisi√≥n familiar del plano en cuadrados id√©nticos.  La idea es poner un punto en cada cuadrado y luego llevar a cabo todas las comparaciones solo con puntos de cuadrados vecinos.  Una buena idea, pero los experimentos han demostrado que con una gran cantidad de puntos, las computadoras port√°tiles econ√≥micas con tarjetas de video integradas a√∫n no pueden hacer frente.  Por lo tanto, vale la pena pensar diez veces antes de decidir hacer un mosaico en su sitio a partir de una gran cantidad de fragmentos. </p><br><blockquote>  No sean r√°banos, verifique el rendimiento de sus artesan√≠as no solo en su granja minera, sino tambi√©n en computadoras port√°tiles comunes.  Los usuarios ser√°n b√°sicamente los √∫nicos. </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/VGmEYN" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="razbienie-ploskosti-na-chasti-po-grafiku-funkcii">  Particionar un plano de acuerdo con un gr√°fico de funci√≥n </h2><br><p>  Veamos otra opci√≥n para dividir un plano en partes.  Ya no requerir√° una gran potencia inform√°tica.  La idea principal es tomar alguna funci√≥n matem√°tica y construir su gr√°fica.  La l√≠nea resultante dividir√° el plano en dos partes.  Si usamos una funci√≥n de la forma <code>y = f(x)</code> , obtenemos la divisi√≥n en forma de corte.  Reemplazando X con Y, podemos cambiar la secci√≥n horizontal a vertical.  Si toma la funci√≥n en coordenadas polares, entonces necesita traducir todo al cartesiano y viceversa, pero la esencia de los c√°lculos no cambiar√°.  En este caso, el resultado no es un corte en dos partes, sino un corte de agujero.  Pero veremos la primera opci√≥n. </p><br><p>  Para cada Y, calcularemos el valor de X para hacer una secci√≥n vertical.  Podr√≠amos tomar una onda sinusoidal para estos fines, por ejemplo, pero es demasiado aburrido.  Es mejor tomar algunas piezas a la vez y doblarlas. </p><br><p>  Tomamos varias sinusoides, cada una de las cuales est√° vinculada a una coordenada a lo largo de Y y al tiempo, y las sumamos.  Los f√≠sicos llamar√≠an a esta adici√≥n superposici√≥n.  Obviamente, multiplicando el resultado completo por alg√∫n n√∫mero, cambiamos la amplitud.  S√°calo en una macro separada.  Si multiplica la coordenada, el par√°metro seno, la frecuencia cambiar√°.  Ya hemos visto esto en un art√≠culo anterior.  Tambi√©n eliminamos el modificador de frecuencia com√∫n a todos los sinusoides de la f√≥rmula.  No ser√° superfluo jugar con el tiempo, un signo negativo dar√° el efecto de mover la l√≠nea en la direcci√≥n opuesta. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span> = u_time * SPEED; <span class="hljs-type"><span class="hljs-type">float</span></span> x = (sin(texture_coord.y * FREQUENCY) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">2.1</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">1.72</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">1.121</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">2.221</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">0.437</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">3.1122</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">4.269</span></span>)) * AMPLITUDE;</code> </pre> <br><p>  Habiendo hecho tales ajustes globales para nuestra funci√≥n, enfrentaremos el problema de repetir el mismo movimiento a intervalos bastante cortos.  Para resolver este problema, necesitamos multiplicar todo por coeficientes para los cuales el m√∫ltiplo com√∫n m√°s peque√±o es muy grande.  Algo similar tambi√©n se usa en el generador de n√∫meros aleatorios, ¬ørecuerdas?  En este caso, no pensamos y tomamos n√∫meros ya preparados de alg√∫n ejemplo de Internet, pero nadie se molesta en experimentar con nuestros valores. </p><br><p>  Solo queda elegir una de las dos texturas para los puntos por encima de nuestro gr√°fico de funciones y la segunda para los puntos debajo de ella.  M√°s precisamente a izquierda y derecha, todos giramos: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (texture_coord.x - <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> &gt; x) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord); }</code> </pre> <br><p>  Lo que recibimos se parece a las ondas sonoras.  M√°s precisamente, su imagen en el osciloscopio.  De hecho, podr√≠amos, en lugar de nuestros sinusoides, transmitir datos desde alg√∫n tipo de archivo de sonido.  Pero trabajar con sonido es un tema para un art√≠culo separado. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/VGmEeO" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="maski">  Mascaras </h2><br><p>  Los ejemplos anteriores deber√≠an llevar a un comentario bastante l√≥gico: todo esto se parece al trabajo de las m√°scaras en SVG (si no ha trabajado con ellas, vea ejemplos del art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">M√°scaras SVG y efectos wow</a> ).  Es solo que aqu√≠ los hacemos un poco diferente.  Y el resultado es el mismo: algunas √°reas est√°n pintadas con una textura, otras con otra.  Solo las transiciones suaves a√∫n no han sido.  As√≠ que hagamos uno. </p><br><p>  Eliminamos todo lo innecesario y devolvemos las coordenadas del mouse.  Haga un degradado radial con el centro en la ubicaci√≥n del cursor y √∫selo como m√°scara.  En este ejemplo, el comportamiento del sombreador se parecer√° m√°s a la l√≥gica de las m√°scaras en SVG que en los ejemplos anteriores.  Necesitamos una funci√≥n de <code>mix</code> y alguna funci√≥n de distancia.  El primero mezclar√° los valores de color de p√≠xel de ambas texturas, tomando como tercer par√°metro un coeficiente (de 0 a 1) que determina cu√°l de los valores prevalecer√° como resultado.  Tomamos el m√≥dulo seno en funci√≥n de la distancia; solo dar√° un cambio suave en el valor entre 0 y 1. </p><br><pre> <code class="hljs lisp">gl_FragColor = mix( <span class="hljs-name"><span class="hljs-name">texture2D</span></span>(<span class="hljs-name"><span class="hljs-name">u_textures</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord), texture2D(<span class="hljs-name"><span class="hljs-name">u_textures</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord), abs(<span class="hljs-name"><span class="hljs-name">sin</span></span>(<span class="hljs-name"><span class="hljs-name">length</span></span>(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span> - u_mouse_position / u_canvas_size))))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Eso es todo  Veamos el resultado: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/bxBmwB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  La principal ventaja sobre SVG es obvia: </p><br><blockquote>  A diferencia de SVG, aqu√≠ podemos hacer f√°cilmente gradientes suaves para diversas funciones matem√°ticas, y no recopilarlos de muchos gradientes lineales. </blockquote><p>  Si tiene una tarea m√°s simple que no requiere transiciones suaves o formas complejas que se calculan en el proceso, lo m√°s probable es que sea m√°s f√°cil de implementar sin el uso de sombreadores.  S√≠, y es probable que el rendimiento en hardware d√©bil sea mejor.  Elija una herramienta basada en sus tareas. </p><br><p>  Para fines educativos, veamos otro ejemplo.  Primero, haz un c√≠rculo en el que la textura permanecer√° como est√°: </p><br><pre> <code class="hljs objectivec">gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = distance(texture_coord, u_mouse_position / u_canvas_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dist &lt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  Y rellena el resto con rayas diagonales: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = sin((texture_coord.y - texture_coord.x) * <span class="hljs-number"><span class="hljs-number">200.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>) { gl_FragColor.rgb *= dist; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gl_FragColor.rgb *= dist / <span class="hljs-number"><span class="hljs-number">10.0</span></span>; }</code> </pre> <br><p>  Las aceptaciones son las mismas: multiplicamos el par√°metro para el seno para aumentar la frecuencia de las rayas;  dividir los valores obtenidos en dos partes;  Para cada una de las mitades, transformamos el color de los p√≠xeles a nuestra manera.  Es √∫til recordar que dibujar l√≠neas diagonales generalmente se asocia con la adici√≥n de coordenadas en X e Y. Tenga en cuenta que tambi√©n usamos la distancia al cursor del mouse cuando cambiamos los colores, creando as√≠ una especie de sombra.  De la misma manera, puede usarlo con transformaciones geom√©tricas, pronto veremos esto en el ejemplo de pixelaci√≥n.  Mientras tanto, mira el resultado de este sombreador: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/rZWqyK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Simple y bonita </p><br><blockquote>  Y s√≠, si se confunde un poco, puede crear texturas no a partir de im√°genes, sino a partir de cuadros de videos (hay muchos ejemplos en la red, puede resolverlos f√°cilmente) y aplicarles todos nuestros efectos.  Muchos sitios de directorio como Awwwards usan estos efectos junto con el video. </blockquote><p>  Vale la pena recordar un pensamiento m√°s: </p><br><blockquote>  Nadie se molesta en usar una de las texturas como m√°scara.  Podemos tomar una foto y usar los valores de color de sus p√≠xeles en nuestras transformaciones, ya sea cambios en otros colores, cambios a los lados o algo m√°s que se te ocurra. </blockquote><p>  Pero volvamos a dividir el avi√≥n en partes. </p><br><h2 id="pikselizaciya">  Pixelizaci√≥n </h2><br><p>  Este efecto es algo obvio, pero al mismo tiempo es tan com√∫n que ser√≠a un error pasar por alto.  Divida nuestro plano en cuadrados, de la misma manera que en el ejemplo con el generador de ruido, y luego para todos los p√≠xeles dentro de cada cuadrado establecemos el mismo color.  Se obtiene mezclando valores de las esquinas de un cuadrado, ya hicimos algo similar.  Para este efecto, no necesitamos f√≥rmulas complejas, as√≠ que solo suma todos los valores y divide entre 4, el n√∫mero de √°ngulos del cuadrado. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> block_size = abs(sin(u_time)) / <span class="hljs-number"><span class="hljs-number">20.0</span></span>; vec2 block_position = floor(texture_coord / block_size) * block_size; gl_FragColor = ( texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>) * block_size) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * block_size) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * block_size) ) / <span class="hljs-number"><span class="hljs-number">4.0</span></span>;</code> </pre> <br><p>  Nuevamente vinculamos uno de los par√°metros al tiempo a trav√©s del m√≥dulo seno para ver visualmente qu√© sucede cuando cambia. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/eLBPej" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="pikselnye-volny">  Olas de p√≠xeles </h2><br><p>            ,       . </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> block_size = abs(sin( length(texture_coord - u_mouse_position / u_canvas_size) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - u_time)) / <span class="hljs-number"><span class="hljs-number">100.0</span></span> + <span class="hljs-number"><span class="hljs-number">0.001</span></span>;</code> </pre> <br><p>   ,       0  1;        , ,    ,     .       ,      . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/sfi0zy/embed/preview/EeNdEr" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>    "" ,              ,    -.     .       " ",     ,         .     .      ‚Äî  .       . </p><br><h2 id="itogi">  Resumen </h2><br><p>         ,     ,  ,    ,           .                    -.     -       -  .          .          .    ,      ,      ,      . </p><br><hr><br><p> <em>PS:  ,   WebGL (      )          ?     ,   ,   .          ?</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421821/">https://habr.com/ru/post/es421821/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es421809/index.html">API de concurrencia Java EE</a></li>
<li><a href="../es421811/index.html">El IETF ha propuesto un nuevo est√°ndar para la mensajer√≠a: lo que necesita saber</a></li>
<li><a href="../es421815/index.html">Metal l√≠quido en una computadora port√°til seis meses despu√©s</a></li>
<li><a href="../es421817/index.html">Trabajando con formularios en React.js usando herramientas b√°sicas</a></li>
<li><a href="../es421819/index.html">ELK Stack para almacenar registros de aplicaciones de Django</a></li>
<li><a href="../es421823/index.html">C√≥mo trajimos X-Ray x64</a></li>
<li><a href="../es421827/index.html">¬øQu√© leer sobre Java en este momento?</a></li>
<li><a href="../es421829/index.html">La anomal√≠a de Frango: un romance fant√°stico con personas reales de TI</a></li>
<li><a href="../es421833/index.html">Escribimos nuestro programa m√°s simple para ARM Cortex-M3</a></li>
<li><a href="../es421835/index.html">La Comisi√≥n Interagencial desarrolla nueva tecnolog√≠a para bloquear Telegram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>