<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíó üé∑ üëÇüèª Fil√≥sofos bem alimentados ou programa√ß√£o .NET competitiva üññüèº üò™ üç£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vamos ver como a programa√ß√£o simult√¢nea e paralela no .Net funciona, usando o problema dos fil√≥sofos gastron√¥micos como exemplo. Esse plano, da sincro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fil√≥sofos bem alimentados ou programa√ß√£o .NET competitiva</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447898/"><p><img src="https://habrastorage.org/webt/ox/lr/6d/oxlr6dmndsfjh_zjsowzpozt-30.png"></p><br><p>  Vamos ver como a programa√ß√£o simult√¢nea e paralela no .Net funciona, usando o problema dos fil√≥sofos gastron√¥micos como exemplo.  Esse plano, da sincroniza√ß√£o de threads / processos, ao modelo de atores (nas seguintes partes).  O artigo pode ser √∫til para um primeiro conhecido ou para atualizar seu conhecimento. </p><br><p>  Por que ser capaz de fazer isso?  Os transistores atingem seu tamanho m√≠nimo, a lei de Moore baseia-se na limita√ß√£o da velocidade da luz e, portanto, √© observado crescimento em quantidade, mais transistores podem ser feitos.  Ao mesmo tempo, a quantidade de dados est√° aumentando e os usu√°rios esperam uma rea√ß√£o imediata dos sistemas.  Em tal situa√ß√£o, a programa√ß√£o "normal", quando temos um thread em execu√ß√£o, n√£o √© mais eficaz.  √â necess√°rio resolver de alguma forma o problema da execu√ß√£o simult√¢nea ou competitiva.  Al√©m disso, esse problema existe em diferentes n√≠veis: no n√≠vel dos fluxos, no n√≠vel dos processos, no n√≠vel das m√°quinas na rede (sistemas distribu√≠dos).  O .NET possui tecnologias testadas pelo tempo, de alta qualidade, para solucionar r√°pida e efetivamente esses problemas. </p><a name="habracut"></a><br><br><h2 id="anchorproblemanchor-zadacha"><a name="problem"></a>  Desafio </h2><br><p>  Edsger Dijkstra colocou esse problema para seus alunos desde 1965. A reda√ß√£o estabelecida √© essa.  H√° um n√∫mero (geralmente cinco) de fil√≥sofos e tantos garfos.  Eles est√£o sentados √† mesa redonda, com garfos no meio.  Os fil√≥sofos podem comer de seus pratos com comida sem fim, pensar ou esperar.  Para comer o fil√≥sofo, voc√™ precisa pegar dois garfos (o √∫ltimo divide o garfo com o primeiro).  Para tirar e colocar um garfo - duas a√ß√µes separadas.  Todos os fil√≥sofos est√£o calados.  A tarefa √© encontrar um algoritmo que todos pensem e fiquem cansados, mesmo ap√≥s 54 anos. </p><br><p>  Primeiro, vamos tentar resolver esse problema usando espa√ßo compartilhado.  Os garfos est√£o sobre a mesa e os fil√≥sofos os pegam quando est√£o e os colocam de volta.  H√° problemas com a sincroniza√ß√£o, quando exatamente para tirar os plugues?  O que fazer se n√£o houver plug?  e outros, mas primeiro, vamos lan√ßar os fil√≥sofos. </p><br><p> Para iniciar threads, use o pool de threads atrav√©s do m√©todo <code>Task.Run</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cancelTokenSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; create = (i) =&gt; RunPhilosopher(i, cancelTokenSource.Token); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; philosophersAmount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> icopy = i; <span class="hljs-comment"><span class="hljs-comment">//      .  RunDeadlock   // ,    .  . philosophers[i] = Task.Run(() =&gt; create(icopy), cancelTokenSource.Token); }</span></span></code> </pre> <br><p>  Conjunto de threads criado para otimizar a cria√ß√£o e exclus√£o de threads.  Esse pool tem uma fila de tarefas e o CLR cria ou exclui threads, dependendo do n√∫mero dessas tarefas.  Um pool para todos os AppDomains.  Esse pool deve ser usado quase sempre, porque  voc√™ n√£o precisa se preocupar em criar, excluir segmentos, suas filas etc. √â poss√≠vel sem um pool, mas √© necess√°rio usar o <code>Thread</code> diretamente, √© aconselh√°vel nos casos em que voc√™ precise alterar a prioridade de um segmento, quando tivermos uma opera√ß√£o longa, em Primeiro plano de um segmento, etc. </p><br><p>  E a classe <code>System.Threading.Tasks.Task</code> facilita o trabalho com esse pool de threads (ou mesmo sem ele).  √â uma opera√ß√£o ass√≠ncrona.  Grosso modo, esse √© o mesmo <code>Thread</code> , mas com todos os tipos de conveni√™ncias: a capacidade de iniciar tarefas ap√≥s um bloco de outras tarefas, devolv√™-las de fun√ß√µes, √© conveniente interromp√™-las e muito mais.  etc. Eles s√£o necess√°rios para suportar constru√ß√µes ass√≠ncronas / aguardadas (padr√£o ass√≠ncrono baseado em tarefas, a√ß√∫car sint√°tico para aguardar a opera√ß√£o de E / S).  Vamos falar sobre isso novamente. </p><br><p>  <code>CancelationTokenSource</code> √© necess√°rio aqui para que o pr√≥prio encadeamento possa ser encerrado pelo sinal do encadeamento de chamada. </p><br><h2 id="problemy-s-sinhronizaciey">  Problemas de sincroniza√ß√£o </h2><br><h3 id="blokirovannye-filosofy">  Fil√≥sofos bloqueados </h3><br><p>  Ok, podemos criar threads, vamos tentar almo√ßar: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    .  : 1 1 3 3 - 1  3    . private int[] forks = Enumerable.Repeat(0, philosophersAmount).ToArray(); //  ,  RunPhilosopher() private void RunDeadlock(int i, CancellationToken token) { //  ,  . : // while(true) // if forks[fork] == 0 // forks[fork] = i+1 // break // Thread.Sleep()  Yield()  SpinWait() void TakeFork(int fork) =&gt; SpinWait.SpinUntil(() =&gt; Interlocked.CompareExchange(ref forks[fork], i+1, 0) == 0); //  ,    Interlocked.Exchange: void PutFork(int fork) =&gt; forks[fork] = 0; while (true) { TakeFork(Left(i)); TakeFork(Right(i)); eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); PutFork(Left(i)); PutFork(Right(i)); Think(i); //   -. token.ThrowIfCancellationRequested(); } }</span></span></code> </pre> <br><p>  Aqui, primeiro tentamos pegar os garfos esquerdo e depois direito, e se funcionar, ent√£o comemos e os colocamos de volta.  Tomar um garfo √© at√¥mico, ou seja,  dois fluxos n√£o podem receber um ao mesmo tempo (incorretamente: o primeiro l√™ que o plugue est√° livre, o segundo tamb√©m, o primeiro leva, o segundo leva).  Para fazer isso, <code>Interlocked.CompareExchange</code> , que deve ser implementado usando uma instru√ß√£o de processador ( <code>TSL</code> , <code>XCHG</code> ), que bloqueia um peda√ßo de mem√≥ria para leitura e grava√ß√£o seq√ºencial at√¥mica.  E o SpinWait √© equivalente a uma constru√ß√£o <code>while(true)</code> com apenas um pouco de "m√°gica" - o thread ocupa o processador ( <code>Thread.SpinWait</code> ), mas √†s vezes transfere o controle para outro thread ( <code>Thread.Yeild</code> ) ou adormece ( <code>Thread.Sleep</code> ). </p><br><p>  Mas essa solu√ß√£o n√£o funciona, porque  os fluxos logo ser√£o bloqueados (para mim em um segundo): todos os fil√≥sofos pegam o garfo esquerdo, mas n√£o o direito.  A matriz de garfos possui valores: 1 2 3 4 5. </p><br><p><img src="https://habrastorage.org/webt/4l/0x/h9/4l0xh9rwiyjh1l8u2z2szlnv--o.png" alt="Livelock"></p><br><p>  Na figura, bloqueando threads (deadlock).  Verde indica execu√ß√£o, vermelho indica sincroniza√ß√£o e cinza indica suspens√£o.  Os diamantes indicam a hora de in√≠cio da tarefa. </p><br><h3 id="golod-filosofov">  A fome dos fil√≥sofos </h3><br><p>  Embora n√£o seja necess√°rio pensar em muita comida, voc√™ deve for√ßar algu√©m a desistir da filosofia.  Vamos tentar simular a situa√ß√£o dos fluxos de jejum em nosso problema.  A fome ocorre quando o fluxo funciona, mas sem trabalho significativo, em outras palavras, √© o mesmo impasse, s√≥ que agora o fluxo n√£o dorme, mas procura ativamente algo para comer, mas n√£o h√° comida.  Para evitar o bloqueio frequente, colocaremos o plugue de volta se n√£o pudermos usar outro. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      RunDeadlock,         . private void RunStarvation(int i, CancellationToken token) { while (true) { bool hasTwoForks = false; var waitTime = TimeSpan.FromMilliseconds(50); //      : bool hasLeft = forks[Left(i)] == i + 1; if (hasLeft || TakeFork(Left(i), i + 1, waitTime)) { if (TakeFork(Right(i), i + 1, TimeSpan.Zero)) hasTwoForks = true; else PutFork(Left(i)); //      . } if (!hasTwoForks) { if (token.IsCancellationRequested) break; continue; } eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); bool goodPhilosopher = i % 2 == 0; //        : if (goodPhilosopher) PutFork(Left(i)); //      ,      . PutFork(Right(i)); Think(i); if (token.IsCancellationRequested) break; } } //     . bool TakeFork(int fork, int philosopher, TimeSpan? waitTime = null) { return SpinWait.SpinUntil( () =&gt; Interlocked.CompareExchange(ref forks[fork], philosopher, 0) == 0, waitTime ?? TimeSpan.FromMilliseconds(-1) ); }</span></span></code> </pre> <br><p>  Nesse c√≥digo, √© importante que dois em cada quatro fil√≥sofos se esque√ßam de colocar o garfo esquerdo.  E acontece que eles comem mais comida, enquanto outros come√ßam a passar fome, embora os fluxos tenham a mesma prioridade.  Aqui eles realmente n√£o passam fome, porque  maus fil√≥sofos √†s vezes recolhem seus garfos.  Acontece que os bons comem cerca de 5 vezes menos que os ruins.  Portanto, um pequeno erro no c√≥digo leva a uma queda no desempenho.  Aqui vale a pena notar que uma situa√ß√£o rara √© poss√≠vel quando todos os fil√≥sofos tomam o garfo esquerdo, n√£o h√° direito, eles colocam o esquerdo, esperam, tomam o esquerdo novamente, etc.  Esta situa√ß√£o tamb√©m √© fome, mais como um impasse.  Eu n√£o pude repetir.  Abaixo est√° uma foto de uma situa√ß√£o em que dois maus fil√≥sofos pegaram os garfos e dois bons fil√≥sofos est√£o passando fome. </p><br><p><img src="https://habrastorage.org/webt/2v/iw/b_/2viwb_qgxqznj1timeklnwscluw.png" alt="Fome"></p><br><p>  Aqui voc√™ pode ver que os t√≥picos s√£o ativados algumas vezes e tentam obter um recurso.  Dois dos quatro n√∫cleos n√£o fazem nada (o gr√°fico verde na parte superior). </p><br><h3 id="smert-filosofa">  A morte do fil√≥sofo </h3><br><p>  Bem, outro problema que pode interromper o glorioso jantar dos fil√≥sofos √© se um deles de repente morre com garfos nas m√£os (e eles o enterram assim).  Os vizinhos ser√£o deixados sem almo√ßo.  Voc√™ pode <code>NullReferenceException</code> c√≥digo de exemplo para esse caso, por exemplo, uma <code>NullReferenceException</code> lan√ßada depois que o fil√≥sofo pegar os garfos.  E, a prop√≥sito, a exce√ß√£o n√£o ser√° processada e o c√≥digo de chamada simplesmente n√£o a capturar√° (para isso, <code>AppDomain.CurrentDomain.UnhandledException</code> , etc.).  Portanto, os manipuladores de erro s√£o necess√°rios nos pr√≥prios threads e com a finaliza√ß√£o correta. </p><br><h2 id="oficiant">  Gar√ßom </h2><br><p>  Bem, como resolvemos esse problema com impasses, fome e morte?  Permitiremos que apenas um fil√≥sofo garfo, adicione exclus√£o m√∫tua de fluxos para esse local.  Como fazer isso?  Suponha que um gar√ßom esteja ao lado dos fil√≥sofos que d√° permiss√£o a um fil√≥sofo para pegar garfos.  Como fazemos esse gar√ßom e como os fil√≥sofos fazem perguntas interessantes. </p><br><p>  A maneira mais simples √© quando os fil√≥sofos simplesmente pedem constantemente ao gar√ßom acesso aos garfos.  I.e.  agora os fil√≥sofos n√£o esperam um plugue por perto, mas esperam ou perguntam a um gar√ßom.  Primeiro, usamos apenas o Espa√ßo do Usu√°rio para isso, pois n√£o usamos interrup√ß√µes para chamar nenhum procedimento do kernel (sobre eles abaixo). </p><br><h3 id="resheniya-v-prostranstve-polzovatelya">  Solu√ß√µes de espa√ßo do usu√°rio </h3><br><p>  Aqui faremos o mesmo que costum√°vamos fazer com um garfo e dois fil√≥sofos, girar√≠amos em um ciclo e esperamos.  Mas agora ser√£o todos os fil√≥sofos e como se apenas um garfo, ou seja,  podemos dizer que haver√° apenas aquele fil√≥sofo que pegou esse "garfo de ouro" do gar√ßom.  Para isso, usamos o SpinLock. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> SpinLock spinLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpinLock(); <span class="hljs-comment"><span class="hljs-comment">//  "" private void RunSpinLock(int i, CancellationToken token) { while (true) { //    busy waiting.   try,  //        SpinLock. bool hasLock = false; spinLock.Enter(ref hasLock); try { //       (mutual exclusion). forks[Left(i)] = i + 1; //   ,  . forks[Right(i)] = i + 1; eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); forks[Left(i)] = 0; forks[Right(i)] = 0; } finally { if(hasLock) spinLock.Exit(); //     . } Think(i); if (token.IsCancellationRequested) break; } }</span></span></code> </pre> <br><p>  <code>SpinLock</code> √© um bloqueador, com, grosso modo, o mesmo <code>while(true) { if (!lock) break; }</code>  <code>while(true) { if (!lock) break; }</code> , mas com ainda mais "m√°gica" do que no <code>SpinWait</code> (que √© usado l√°).  Agora ele sabe contar os que est√£o esperando, faz√™-los dormir um pouco e muito mais.  etc. Em geral, faz todo o poss√≠vel para otimizar.  Mas devemos lembrar que esse ainda √© o mesmo ciclo ativo que consome recursos do processador e mant√©m um encadeamento que pode levar √† fome se um dos fil√≥sofos se tornar uma prioridade sobre os outros, mas n√£o tiver um garfo de ouro (problema de invers√£o de prioridade).  Portanto, n√≥s o usamos apenas para altera√ß√µes muito curtas na mem√≥ria compartilhada, sem chamadas de terceiros, bloqueios aninhados, etc. surpresas. </p><br><p><img src="https://habrastorage.org/webt/ev/wu/kk/evwukkxrcgfutky1cihoe5dns0e.png" alt="Spinlock"></p><br><p>  Figura para o <code>SpinLock</code> .  As correntes est√£o constantemente "lutando" pelo garfo de ouro.  Falhas acontecem - na figura, a √°rea selecionada.  Os n√∫cleos n√£o s√£o totalmente usados: apenas cerca de 2/3 desses quatro threads. </p><br><p>  Outra solu√ß√£o aqui seria usar apenas <code>Interlocked.CompareExchange</code> com a mesma expectativa ativa, conforme mostrado no c√≥digo acima (em fil√≥sofos famintos), mas isso, como j√° mencionado, teoricamente poderia levar ao bloqueio. </p><br><p>  Sobre o <code>Interlocked</code> , vale a pena dizer que n√£o existem apenas o <code>CompareExchange</code> , mas tamb√©m outros m√©todos para leitura e grava√ß√£o at√¥mica.  E, repetindo as altera√ß√µes caso outro encadeamento consiga fazer suas altera√ß√µes (leia 1, leia 2, escreva 2, escreva 1 √© ruim), ele pode ser usado para altera√ß√µes complexas de um valor (padr√£o Interlocked Anything). </p><br><h3 id="resheniya-v-rezhime-yadra">  Solu√ß√µes em modo kernel </h3><br><p>  Para evitar a perda de recursos em um loop, vamos ver como voc√™ pode bloquear um fluxo.  Em outras palavras, continuando nosso exemplo, veremos como o gar√ßom coloca o fil√≥sofo para dormir e o acorda somente quando necess√°rio.  Primeiro, vamos ver como fazer isso no modo kernel do sistema operacional.  Todas as estruturas existentes costumam ser mais lentas do que aquelas no espa√ßo do usu√°rio.  V√°rias vezes mais lento, por exemplo, o <code>AutoResetEvent</code> pode ser 53 vezes mais lento que o <code>SpinLock</code> [Richter].  Por√©m, com a ajuda deles, voc√™ pode sincronizar processos por todo o sistema, gerenciados ou n√£o. </p><br><p>  A principal constru√ß√£o aqui √© o sem√°foro proposto por Dijkstroy mais de meio s√©culo atr√°s.  Um sem√°foro √©, em termos simples, um n√∫mero inteiro positivo controlado por um sistema e duas opera√ß√µes nele - aumentam e diminuem.  Se a redu√ß√£o n√£o funcionar, zero, o encadeamento de chamada ser√° bloqueado.  Quando o n√∫mero √© aumentado por algum outro encadeamento / processo ativo, os encadeamentos s√£o ignorados e o sem√°foro diminui novamente pelo n√∫mero de passados.  Voc√™ pode imaginar trens em um gargalo com um sem√°foro.  O .NET oferece v√°rios designs com recursos semelhantes: <code>AutoResetEvent</code> , <code>ManualResetEvent</code> , <code>Mutex</code> e o pr√≥prio <code>Semaphore</code> .  Usaremos <code>AutoResetEvent</code> , essa √© a mais simples dessas constru√ß√µes: apenas dois valores s√£o 0 e 1 (falso, verdadeiro).  Seu m√©todo <code>WaitOne()</code> bloqueia o segmento de chamada se o valor for 0 e, se 1, reduz para 0 e ignora.  E o m√©todo <code>Set()</code> aumenta para 1 e pula uma espera, que novamente diminui para 0. Ele age como uma catraca no metr√¥. </p><br><p>  Vamos complicar a solu√ß√£o e usaremos a trava para cada fil√≥sofo, e n√£o para todos de uma vez.  I.e.  agora pode haver v√°rios fil√≥sofos ao mesmo tempo, e n√£o um.  Mais uma vez, bloqueamos o acesso √† mesa para pegar garfos corretamente, evitando corridas (condi√ß√µes da corrida). </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    . // : new AutoResetEvent(true)  . private AutoResetEvent[] philosopherEvents; //     /   . private AutoResetEvent tableEvent = new AutoResetEvent(true); //  . public void Run(int i, CancellationToken token) { while (true) { TakeForks(i); //  . // .    . eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); PutForks(i); //     . Think(i); if (token.IsCancellationRequested) break; } } //    . void TakeForks(int i) { bool hasForks = false; while (!hasForks) //    (  ). { //    ,    . tableEvent.WaitOne(); if (forks[Left(i)] == 0 &amp;&amp; forks[Right(i)] == 0) forks[Left(i)] = forks[Right(i)] = i + 1; hasForks = forks[Left(i)] == i + 1 &amp;&amp; forks[Right(i)] == i + 1; if (hasForks) //   ,   .  Set //  ,   true. philosopherEvents[i].Set(); //   .    tableEvent  false. tableEvent.Set(); //   true,  ,   false,    Set  . philosopherEvents[i].WaitOne(); } } //     . void PutForks(int i) { tableEvent.WaitOne(); //    . forks[Left(i)] = 0; //  ,     ,  AutoResetEvent  true. philosopherEvents[LeftPhilosopher(i)].Set(); forks[Right(i)] = 0; philosopherEvents[RightPhilosopher(i)].Set(); tableEvent.Set(); }</span></span></code> </pre> <br><p>  Para entender o que est√° acontecendo aqui, considere o caso em que o fil√≥sofo falhou em pegar os garfos, ent√£o suas a√ß√µes ser√£o assim.  Ele est√° esperando pelo acesso √† mesa.  Tendo recebido, ele tenta pegar os garfos.  N√£o deu certo.  Ele d√° acesso √† mesa (exclus√£o m√∫tua).  E passa seu "torniquete" ( <code>AutoResetEvent</code> ) (a princ√≠pio eles est√£o abertos).  Entra no ciclo novamente, porque  ele n√£o tem garfos.  Tenta peg√°-los e para na catraca dele.  Um vizinho mais afortunado √† direita ou √† esquerda, depois de terminar de comer, destranca nosso fil√≥sofo, "abrindo sua catraca".  Nosso fil√≥sofo passa (e ele fecha atr√°s) pela segunda vez.  Tenta pela terceira vez pegar os garfos.  Boa sorte  E passa a catraca para jantar. </p><br><p>  Quando h√° erros aleat√≥rios nesse c√≥digo (eles sempre existem), por exemplo, um vizinho √© especificado incorretamente ou o mesmo objeto <code>AutoResetEvent</code> √© <code>AutoResetEvent</code> para todos ( <code>Enumerable.Repeat</code> ), ent√£o os fil√≥sofos aguardam os desenvolvedores, porque  encontrar erros nesse c√≥digo √© uma tarefa bastante dif√≠cil.  Outro problema com esta solu√ß√£o √© que ela n√£o garante que nenhum fil√≥sofo passe fome. </p><br><h3 id="gibridnye-resheniya">  Solu√ß√µes h√≠bridas </h3><br><p>  Examinamos duas abordagens para sincroniza√ß√£o quando permanecemos no modo de usu√°rio e giramos em um loop e quando bloqueamos um thread no kernel.  O primeiro m√©todo √© bom para bloqueios curtos, o segundo para os longos.  Freq√ºentemente, voc√™ primeiro precisa esperar brevemente que uma vari√°vel seja alterada no loop e depois bloquear o thread quando a espera for longa.  Essa abordagem √© implementada no chamado  projetos h√≠bridos.  Existem as mesmas constru√ß√µes que eram para o modo kernel, mas agora com um loop no modo usu√°rio: <code>SemaphorSlim</code> , <code>ManualResetEventSlim</code> , etc. A constru√ß√£o mais popular aqui √© o <code>Monitor</code> , porque  C # tem uma sintaxe de <code>lock</code> conhecida.  <code>Monitor</code> √© o mesmo sem√°foro com um valor m√°ximo de 1 (mutex), mas com suporte para espera em um loop, recurs√£o, padr√£o de vari√°vel de condi√ß√£o (sobre isso abaixo), etc. Vamos olhar para uma solu√ß√£o com ele. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      ,   . private readonly object _lock = new object(); //   . private DateTime?[] _waitTimes = new DateTime?[philosophersAmount]; public void Run(int i, CancellationToken token) { while (true) { TakeForks(i); eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); PutForks(i); Think(i); if (token.IsCancellationRequested) break; } } //     Condition Variable . bool CanIEat(int i) { //   : if (forks[Left(i)] != 0 &amp;&amp; forks[Right(i)] != 0) return false; var now = DateTime.Now; // ,     ,  . foreach(var p in new int[] {LeftPhilosopher(i), RightPhilosopher(i)}) if (_waitTimes[p] != null &amp;&amp; now - _waitTimes[p] &gt; now - _waitTimes[i]) return false; return true; } void TakeForks(int i) { //   .   : lock(_lock) {..}. //   try,     . bool lockTaken = false; Monitor.Enter(_lock, ref lockTaken); try { _waitTimes[i] = DateTime.Now; // Condition Variable .  ,    //  .    -  Pulse / PulseAll. while (!CanIEat(i)) Monitor.Wait(_lock); forks[Left(i)] = i + 1; forks[Right(i)] = i + 1; _waitTimes[i] = null; } finally { if (lockTaken) Monitor.Exit(_lock); } } void PutForks(int i) { //   : lock (_lock) {..}. bool lockTaken = false; Monitor.Enter(_lock, ref lockTaken); try { forks[Left(i)] = 0; forks[Right(i)] = 0; //        Monitor.Exit. Monitor.PulseAll(_lock); } finally { if (lockTaken) Monitor.Exit(_lock); } }</span></span></code> </pre> <br><p>  Aqui novamente trancamos a mesa inteira para acessar os garfos, mas agora desbloqueamos todos os fluxos de uma s√≥ vez, e n√£o os vizinhos quando algu√©m termina de comer.  I.e.  primeiro, algu√©m come e bloqueia os vizinhos, e quando ele termina, mas quer comer imediatamente novamente, ele entra na fechadura e acorda os vizinhos, porque  o tempo de espera √© mais curto. </p><br><p>  Portanto, evitamos os impasses e a fome de algum fil√≥sofo.  Usamos um loop para uma breve espera e bloqueamos o fluxo por um longo.  Desbloquear tudo de uma vez funciona mais lentamente do que se apenas o vizinho fosse desbloqueado, como na solu√ß√£o com <code>AutoResetEvent</code> , mas a diferen√ßa n√£o deve ser grande, porque  os threads devem permanecer no modo de usu√°rio primeiro. </p><br><p>  O <code>lock</code> sintaxe tem surpresas desagrad√°veis.  Eles recomendam o uso do <code>Monitor</code> diretamente [Richter] [Eric Lippert].  Uma delas √© que o <code>lock</code> sempre sai do <code>Monitor</code> , mesmo se houver uma exce√ß√£o, e outro segmento pode alterar o estado da mem√≥ria compartilhada.  Nesses casos, geralmente √© melhor ir para o impasse ou concluir de alguma forma com seguran√ßa o programa.  Outra surpresa √© que o Monitor usa blocos de sincroniza√ß√£o ( <code>SyncBlock</code> ), que est√£o em todos os objetos.  Portanto, se voc√™ selecionar o objeto errado, poder√° obter facilmente um impasse (por exemplo, se voc√™ bloquear a cadeia interna).  Sempre usamos um objeto oculto para isso. </p><br><p>  O padr√£o Vari√°vel de condi√ß√£o permite implementar de forma mais concisa a expectativa de uma condi√ß√£o complexa.  No .NET, ele est√° incompleto, na minha opini√£o, porque  em teoria, deve haver v√°rias filas em v√°rias vari√°veis ‚Äã‚Äã(como em Posix Threads), e n√£o em um bloqueio.  Ent√£o algu√©m poderia faz√™-los para todos os fil√≥sofos.  Mas, mesmo nesta forma, permite reduzir o c√≥digo. </p><br><h3 id="mnogo-filosofov-ili-async--await">  Muitos fil√≥sofos ou <code>async</code> / <code>await</code> </h3><br><p>  Ok, agora podemos efetivamente bloquear threads.  Mas, e se tivermos muitos fil√≥sofos?  100?  10000?  Por exemplo, recebemos 100.000 solicita√ß√µes para um servidor web.  A cria√ß√£o de um fluxo para cada solicita√ß√£o ser√° uma sobrecarga, porque  tantos threads n√£o ser√£o executados em paralelo.  Somente quantos n√∫cleos l√≥gicos ser√£o executados (eu tenho 4).  E todos os outros simplesmente usar√£o recursos.  Uma solu√ß√£o para esse problema √© o padr√£o ass√≠ncrono / espera.  Sua id√©ia √© que uma fun√ß√£o n√£o mantenha um fluxo, se voc√™ precisar esperar que continue.  E quando ela faz isso, algo acontece, ela retoma sua execu√ß√£o (mas n√£o necessariamente no mesmo encadeamento!).  No nosso caso, esperaremos pelo plugue. </p><br><p>  <code>SemaphoreSlim</code> tem um m√©todo <code>WaitAsync()</code> para isso.  Aqui est√° uma implementa√ß√£o usando esse padr√£o. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,  . -  : Task.Run(() =&gt; Run(i, cancelTokenSource.Token)); //  . //   async --      . public async Task Run(int i, CancellationToken token) { while (true) { // await --   - . await TakeForks(i); //  await,     . eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); //      . await PutForks(i); Think(i); if (token.IsCancellationRequested) break; } } async Task TakeForks(int i) { bool hasForks = false; while (!hasForks) { //    : await _tableSemaphore.WaitAsync(); if (forks[Left(i)] == 0 &amp;&amp; forks[Right(i)] == 0) { forks[Left(i)] = i+1; forks[Right(i)] = i+1; hasForks = true; } _tableSemaphore.Release(); //  ,    : if (!hasForks) await _philosopherSemaphores[i].WaitAsync(); } } //       . async Task PutForks(int i) { await _tableSemaphore.WaitAsync(); forks[Left(i)] = 0; // "" ,   "". _philosopherSemaphores[LeftPhilosopher(i)].Release(); forks[Right(i)] = 0; _philosopherSemaphores[RightPhilosopher(i)].Release(); _tableSemaphore.Release(); }</span></span></code> </pre> <br><p>   <code>async</code> / <code>await</code>     ,      <code>Task</code> .      ,     ,     Task.  ,  ,  .   ,    ,   ,   ,   .         .      <code>async</code> / <code>await</code> . </p><br><p> .  100     4  , 8 .    Monitor   4  ,     .    4    2.    async / await   100,       6.8 . ,      6         .    Monitor    . </p><br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>      , .NET    .  , , ,   .     .    ,     ,   , TPL Dataflow, Reactive , Software Transaction   . </p><br><h2 id="istochniki">  Fontes </h2><br><ul><li>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Concurrency Visualizer</a> </li><li> MSDN: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Threading</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Asynchronous programming patterns</a>  . . </li><li> [] ‚Äî CLR via C#, Jeffrey Richter </li><li> [ ] ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> lock</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> </li><li>  ‚Äî "  ", .  </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt447898/">https://habr.com/ru/post/pt447898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt447886/index.html">An√°lise de log do Nginx usando o Amazon Athena e o Cube.js</a></li>
<li><a href="../pt447890/index.html">Gra√ßas a Deus eu n√£o sou gerente</a></li>
<li><a href="../pt447892/index.html">Dois novos concursos PHDays: desvio de IDS e hackers de f√°brica</a></li>
<li><a href="../pt447894/index.html">MODX Digest # 3 (25 de mar√ßo a 8 de abril de 2019)</a></li>
<li><a href="../pt447896/index.html">Fotos de esbo√ßos aproximados: exatamente como a rede neural NVIDIA GauGAN funciona</a></li>
<li><a href="../pt447900/index.html">Fechar contatos ADL</a></li>
<li><a href="../pt447902/index.html">O GitHub "excluiu" completamente o reposit√≥rio do utilit√°rio de reposit√≥rio de bloqueios e toda a conta do criador</a></li>
<li><a href="../pt447904/index.html">Os especialistas da Positive Technologies identificam tentativas de explorar em massa a vulnerabilidade cr√≠tica no Confluence</a></li>
<li><a href="../pt447906/index.html">Inova√ß√µes reais: o que esperar do mercado de data centers em 2019?</a></li>
<li><a href="../pt447908/index.html">Duas maneiras de coletar recompensas por publicidade em jogos para celular ou rob√¥s devem funcionar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>