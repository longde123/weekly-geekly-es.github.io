<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🚀 👨‍🔧 🧤 Strukturieren von Reaktionsanwendungen 👨🏾‍🍳 😐 🏓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Material, dessen Übersetzung wir heute veröffentlichen, zeigt die Ansätze des Autors bei der Strukturierung von React-Anwendungen. Insbesondere we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Strukturieren von Reaktionsanwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/460793/">  Das Material, dessen Übersetzung wir heute veröffentlichen, zeigt die Ansätze des Autors bei der Strukturierung von React-Anwendungen.  Insbesondere werden wir hier die verwendete Ordnerstruktur, die Benennung von Entitäten, die Orte, an denen sich die Testdateien befinden, und andere ähnliche Dinge diskutieren. <br><br>  Eine der angenehmsten Eigenschaften von React ist, dass diese Bibliothek den Entwickler nicht zwingt, bestimmte Konventionen bezüglich der Struktur des Projekts strikt einzuhalten.  Vieles davon liegt im Ermessen des Programmierers.  Dieser Ansatz unterscheidet sich von dem, der beispielsweise in den Ember.js- oder Angular-Frameworks verwendet wird.  Sie bieten Entwicklern mehr Standardfunktionen.  Diese Frameworks enthalten Konventionen zur Struktur von Projekten und Regeln zum Benennen von Dateien und Komponenten. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/k6/9y/ug/k69yugvbt27p3wtccvzeqrf_v4w.jpeg"></a> <br><br>  Persönlich mag ich den Ansatz von React.  Tatsache ist, dass ich es vorziehe, etwas selbst zu kontrollieren, ohne mich auf bestimmte „Vereinbarungen“ zu verlassen.  Der Ansatz zur Strukturierung von Projekten, den Angular bietet, bietet jedoch viele Vorteile.  Die Wahl zwischen Freiheit und mehr oder weniger strengen Regeln hängt davon ab, was Ihnen und Ihrem Team näher kommt. <br><br>  In den Jahren der Arbeit mit React habe ich viele verschiedene Möglichkeiten ausprobiert, um Anwendungen zu strukturieren.  Einige der Ideen, die ich angewendet habe, erwiesen sich als erfolgreicher als andere.  Deshalb werde ich hier über alles sprechen, was sich in der Praxis gut gezeigt hat.  Ich hoffe, Sie finden hier etwas, das Ihnen nützlich ist. <br><a name="habracut"></a><br>  Ich versuche hier nicht, eine "nur richtige" Art der Strukturierung von Anwendungen aufzuzeigen.  Sie können einige meiner Ideen aufgreifen und an Ihre Bedürfnisse anpassen.  Sie können mir durchaus widersprechen, wenn Sie weiterarbeiten wie zuvor.  Unterschiedliche Teams erstellen unterschiedliche Anwendungen und verwenden unterschiedliche Mittel, um ihre Ziele zu erreichen. <br><br>  Es ist wichtig zu beachten, dass Sie, wenn Sie sich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thread-</a> Website ansehen, an der ich beteiligt bin, und das Gerät der Benutzeroberfläche ansehen, Orte finden, an denen die Regeln, über die ich sprechen werde, nicht eingehalten werden.  Tatsache ist, dass alle „Regeln“ in der Programmierung nur als Empfehlungen und nicht als umfassende Standards verstanden werden sollten, die in jeder Situation gültig sind.  Und wenn Sie der Meinung sind, dass eine Art von "Regeln" nicht zu Ihnen passt, sollten Sie die Kraft finden, von diesen "Regeln" abzuweichen, um die Qualität Ihrer Arbeit zu verbessern. <br><br>  Eigentlich biete ich Ihnen jetzt ohne weiteres meine Geschichte über die Strukturierung von React-Anwendungen an. <br><br><h2>  <font color="#3AC1EF">Mach dir keine Sorgen über die Regeln.</font> </h2><br>  Vielleicht entscheiden Sie, dass die Empfehlung, dass Sie sich nicht zu viele Gedanken über die Regeln machen, zu Beginn unseres Gesprächs seltsam erscheint.  Aber genau das meine ich, wenn ich sage, dass der Hauptfehler, den Programmierer bei der Einhaltung der Regeln haben, darin besteht, dass die Programmierer den Regeln zu viel Bedeutung beimessen.  Dies gilt insbesondere zu Beginn der Arbeit an einem neuen Projekt.  Zum Zeitpunkt der Erstellung der ersten <code>index.jsx</code> einfach unmöglich zu wissen, was für dieses Projekt am besten ist.  Während sich das Projekt entwickelt, werden Sie natürlich zu einer Art Datei- und Ordnerstruktur kommen, die für dieses Projekt wahrscheinlich recht gut ist.  Wenn sich während der Fortsetzung der Arbeit herausstellt, dass die vorhandene Struktur etwas erfolglos ist, kann sie verbessert werden. <br><br>  Wenn Sie dies lesen und sich denken, dass in Ihrer Anwendung nichts besprochen wird, ist dies kein Problem.  Jede Anwendung ist einzigartig, es gibt keine zwei absolut identischen Entwicklungsteams.  Daher trifft jedes Team, das an einem Projekt arbeitet, einige Vereinbarungen hinsichtlich seiner Struktur und Arbeitsweise.  Dies hilft den Teammitgliedern, produktiv zu arbeiten.  Versuchen Sie nicht, sich sofort vorzustellen, nachdem Sie erfahren haben, wie jemand etwas tut.  Versuchen Sie nicht, in Ihre Arbeit das einzuführen, was in bestimmten Materialien genannt wird, und auch dies ist der "effektivste Weg", ein Problem zu lösen.  Ich habe mich in Bezug auf solche Empfehlungen immer an die folgende Strategie gehalten und diese eingehalten.  Ich habe meine eigenen Regeln, aber wenn ich lese, wie andere in bestimmten Situationen handeln, wähle ich, was mir erfolgreich und für mich geeignet erscheint.  Dies führt dazu, dass sich meine Arbeitsmethoden im Laufe der Zeit verbessern.  Gleichzeitig habe ich keine Schocks und es besteht keine Lust, alles von Grund auf neu zu schreiben. <br><br><h2>  <font color="#3AC1EF">Wichtige Komponenten befinden sich in separaten Ordnern</font> </h2><br>  Der Ansatz zum Platzieren von Komponentendateien in Ordnern, zu denen ich gekommen bin, besteht darin, dass diejenigen Komponenten, die im Anwendungskontext als "wichtig", "grundlegend", "grundlegend" angesehen werden können, in separaten Ordnern abgelegt werden.  Diese Ordner befinden sich wiederum im <code>components</code> .  Wenn es sich beispielsweise um eine Anwendung für ein elektronisches Geschäft handelt, kann die zur Beschreibung des Produkts verwendete <code>&lt;Product&gt;</code> -Komponente als ähnliche Komponente erkannt werden.  Folgendes meine ich: <br><br><pre> <code class="plaintext hljs">- src/  - components/    - product/      - product.jsx      - product-price.jsx    - navigation/      - navigation.jsx    - checkout-flow/      - checkout-flow.jsx</code> </pre> <br>  In diesem Fall befinden sich die "sekundären" Komponenten, die nur von bestimmten "Haupt" -Komponenten verwendet werden, im selben Ordner wie diese "Haupt" -Komponenten.  Dieser Ansatz hat sich in der Praxis bewährt.  Tatsache ist, dass aufgrund seiner Anwendung eine bestimmte Struktur im Projekt angezeigt wird, die Ebene der Ordnerverschachtelung jedoch nicht zu groß ist.  Seine Anwendung führt nicht zum Erscheinen von etwas wie <code>../../../</code> in den Komponentenimportbefehlen, es macht es nicht schwierig, sich im Projekt zu bewegen.  Mit diesem Ansatz können Sie eine klare Hierarchie von Komponenten erstellen.  Diese Komponente, deren Name mit dem Namen des Ordners übereinstimmt, wird als "grundlegend" betrachtet.  Andere Komponenten, die sich im selben Ordner befinden, dienen dazu, die "Basiskomponente" in Teile zu unterteilen, was die Arbeit mit dem Code dieser Komponente und ihrer Unterstützung vereinfacht. <br><br>  Obwohl ich das Vorhandensein einer bestimmten Ordnerstruktur im Projekt unterstütze, glaube ich, dass das Wichtigste die Auswahl guter Dateinamen ist.  Ordner selbst sind weniger wichtig. <br><br><h2>  <font color="#3AC1EF">Verwenden von Unterordnern für Unterkomponenten</font> </h2><br>  Einer der Nachteile des obigen Ansatzes besteht darin, dass seine Verwendung dazu führen kann, dass Ordner mit „grundlegenden“ Komponenten angezeigt werden, die viele Dateien enthalten.  Betrachten Sie beispielsweise die Komponente <code>&lt;Product&gt;</code> .  CSS-Dateien werden daran angehängt (wir werden später darauf eingehen), Testdateien, viele Unterkomponenten und möglicherweise andere Ressourcen - wie Bilder und SVG-Symbole.  Diese Liste der "Ergänzungen" ist nicht beschränkt.  All dies wird in den gleichen Ordner wie die "Basis" -Komponente fallen. <br><br>  Das interessiert mich wirklich nicht wirklich.  Dies passt zu mir, wenn die Dateien gut durchdachte Namen haben und leicht zu finden sind (mithilfe der Dateisuchwerkzeuge im Editor).  Wenn dies der Fall ist, tritt die Ordnerstruktur in den Hintergrund.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist ein</a> Tweet zu diesem Thema. <br><br>  Wenn Sie jedoch eine umfangreichere Struktur Ihres Projekts bevorzugen, ist es nicht schwierig, Unterkomponenten in ihre eigenen Ordner zu verschieben: <br><br><pre> <code class="javascript hljs">- src/  - components/    - product/      - product.jsx      - ...      - product-price/        - product-price.jsx</code> </pre> <br><h2>  <font color="#3AC1EF">Testdateien befinden sich an derselben Stelle wie die Dateien der zu testenden Komponenten.</font> </h2><br>  Wir beginnen diesen Abschnitt mit einer einfachen Empfehlung: Die Testdateien sollten an derselben Stelle abgelegt werden wie die Dateien mit dem Code, den sie mit ihrer Hilfe überprüfen.  Ich werde auch darüber sprechen, wie ich die Komponenten lieber strukturiere, um sicherzustellen, dass sie nahe beieinander liegen.  Aber jetzt kann ich sagen, dass ich es bequem finde, die Testdateien in denselben Ordnern wie die Komponentendateien abzulegen.  In diesem Fall sind die Namen der Dateien mit den Tests identisch mit den Namen der Dateien mit dem Code.  Zu den <code>.test</code> vor der Dateinamenerweiterung nur das Suffix <code>.test</code> hinzugefügt: <br><br><ul><li>  Name der Komponentendatei: <code>auth.js</code> </li><li>  Name der <code>auth.test.js</code> : <code>auth.test.js</code> </li></ul><br>  Dieser Ansatz hat mehrere Stärken: <br><br><ul><li>  Es macht es einfach, Testdateien zu finden.  Auf einen Blick können Sie verstehen, ob es einen Test für die Komponente gibt, mit der ich arbeite. </li><li>  Alle notwendigen Importbefehle sind sehr einfach.  Um den getesteten Code zu importieren, müssen Sie im Test keine Strukturen erstellen, die beispielsweise den Ausstieg aus dem Ordner <code>__tests__</code> .  Solche Teams sehen extrem einfach aus.  Beispiel: <code>import Auth from './auth'</code> . </li></ul><br>  Wenn während des Tests einige Daten verwendet werden, z. B. API-Anforderungs-Mocks, legen wir sie in demselben Ordner ab, in dem sich die Komponente und ihr Test bereits befinden.  Wenn alles, was benötigt wird, in einem Ordner liegt, trägt dies zur Steigerung der Produktivität bei.  Wenn Sie beispielsweise eine verzweigte Ordnerstruktur verwenden und der Programmierer sicher ist, dass eine bestimmte Datei vorhanden ist, sich aber nicht an ihren Namen erinnern kann, muss der Programmierer in vielen Unterverzeichnissen nach dieser Datei suchen.  Schauen Sie sich bei dem vorgeschlagenen Ansatz nur den Inhalt eines Ordners an, und alles wird klar. <br><br><h2>  <font color="#3AC1EF">CSS-Module</font> </h2><br>  Ich bin ein großer Fan von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSS-Modulen</a> .  Wir haben festgestellt, dass sie sich hervorragend zum Erstellen modularer CSS-Regeln für Komponenten eignen. <br><br>  Außerdem mag ich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Styled-Components-</a> Technologie sehr.  Bei der Arbeit an Projekten, an denen viele Entwickler beteiligt waren, stellte sich jedoch heraus, dass das Vorhandensein realer CSS-Dateien im Projekt die Benutzerfreundlichkeit erhöht. <br><br>  Wie Sie wahrscheinlich bereits vermutet haben, befinden sich unsere CSS-Dateien wie andere Dateien neben den Komponentendateien in denselben Ordnern.  Dies vereinfacht das Verschieben zwischen Dateien erheblich, wenn Sie die Bedeutung einer Klasse schnell verstehen müssen. <br><br>  Eine allgemeinere Empfehlung, deren Kern das gesamte Material durchdringt, lautet, dass der gesamte Code für eine bestimmte Komponente in demselben Ordner aufbewahrt werden sollte, in dem sich diese Komponente befindet.  Vorbei sind die Zeiten, in denen separate Ordner zum Speichern von CSS- und JS-Code, Testcode und anderen Ressourcen verwendet wurden.  Die Verwendung komplexer Ordnerstrukturen erschwert das Verschieben zwischen Dateien und hat keinen offensichtlichen Vorteil, außer dass es hilft, "den Code zu organisieren".  Bewahren Sie miteinander verbundene Dateien im selben Ordner auf. Dies bedeutet, dass Sie während der Arbeit weniger Zeit zwischen Ordnern wechseln müssen. <br><br>  Wir haben sogar einen Webpack-Loader für CSS erstellt, dessen Funktionen den Funktionen unserer Arbeit entsprechen.  Es überprüft die deklarierten Klassennamen und gibt einen Fehler in der Konsole aus, wenn auf eine Klasse verwiesen wird, die nicht vorhanden ist. <br><br><h2>  <font color="#3AC1EF">Fast immer wird nur ein Komponentencode in einer Datei abgelegt</font> </h2><br>  Meine Erfahrung zeigt, dass Programmierer normalerweise zu streng an der Regel festhalten, dass der Code für eine und nur eine React-Komponente in einer Datei enthalten sein sollte.  Gleichzeitig unterstütze ich voll und ganz die Idee, dass es sich nicht lohnt, zu viele Komponenten in einer Datei zu platzieren (stellen Sie sich nur die Schwierigkeiten vor, solche Dateien zu benennen!).  Ich glaube jedoch, dass es nichts Falsches ist, den Code einer bestimmten „großen“ Komponente und den Code der damit verbundenen „kleinen“ Komponente in derselben Datei zu platzieren.  Wenn ein solcher Schritt dazu beiträgt, die Reinheit des Codes zu erhalten, wenn die "kleine" Komponente nicht zu groß ist, um sie in einer separaten Datei abzulegen, schadet dies niemandem. <br><br>  Wenn ich beispielsweise eine <code>&lt;Product&gt;</code> -Komponente erstelle und einen kleinen Code zur Anzeige des Preises benötige, kann ich Folgendes tun: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Price = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ price, currency }</span></span></span><span class="hljs-function">) =&gt;</span></span> (  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">    {currency}    {formatPrice(price)}  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Product = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> {  <span class="hljs-comment"><span class="hljs-comment">// ,      !  return (    &lt;div&gt;      &lt;Price price={props.price} currency={props.currency} /&gt;      &lt;div&gt;loads more stuff...&lt;/div&gt;    &lt;/div&gt;  ) }</span></span></code> </pre> <br>  Das Gute an diesem Ansatz ist, dass ich keine separate Datei für die <code>&lt;Price&gt;</code> -Komponente erstellen musste und dass diese Komponente ausschließlich für die <code>&lt;Product&gt;</code> -Komponente verfügbar ist.  Wir exportieren diese Komponente nicht, daher kann sie nicht an anderer Stelle in der Anwendung importiert werden.  Dies bedeutet, dass Sie auf die Frage, ob <code>&lt;Price&gt;</code> in eine separate Datei eingefügt werden soll, eine klare, positive Antwort geben können, wenn Sie sie an einen anderen Ort importieren müssen.  Andernfalls können Sie auf den Code <code>&lt;Price&gt;</code> , der in einer separaten Datei gespeichert wird. <br><br><h2>  <font color="#3AC1EF">Separate Ordner für universelle Komponenten</font> </h2><br>  Wir haben kürzlich universelle Komponenten verwendet.  Sie bilden zwar unser Designsystem (das wir eines Tages veröffentlichen wollen), aber bisher haben wir klein angefangen - mit Komponenten wie <code>&lt;Button&gt;</code> und <code>&lt;Logo&gt;</code> .  Eine Komponente wird als „universell“ betrachtet, wenn sie nicht an einen bestimmten Teil der Site gebunden ist, sondern einer der Bausteine ​​der Benutzeroberfläche ist. <br><br>  Ähnliche Komponenten befinden sich in Ihrem eigenen Ordner ( <code>src/components/generic</code> ).  Dies vereinfacht die Arbeit mit allen universellen Komponenten erheblich.  Sie sind an einem Ort - es ist sehr praktisch.  Mit dem Wachstum des Projekts planen wir im Laufe der Zeit die Entwicklung eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Styleguides</a> (wir sind große Fans von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React-Styleguidist</a> ), um die Arbeit mit universellen Komponenten weiter zu vereinfachen. <br><br><h2>  <font color="#3AC1EF">Verwenden von Aliasen zum Importieren von Entitäten</font> </h2><br>  Die relativ flache Ordnerstruktur in unseren Projekten stellt sicher, dass die Importbefehle keine zu langen Strukturen wie <code>../../</code> .  Aber es ist schwer, ohne sie auszukommen.  Daher haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">babel-plugin-module-resolver verwendet</a> , um Aliase zu konfigurieren, die Importbefehle vereinfachen. <br><br>  Sie können dasselbe mit Webpack tun, aber dank des Babel-Plugins können dieselben Importbefehle in Tests verwendet werden. <br><br>  Wir haben dies mit zwei Aliasen konfiguriert: <br><br><pre> <code class="javascript hljs">{  <span class="hljs-attr"><span class="hljs-attr">components</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/components'</span></span>,  <span class="hljs-string"><span class="hljs-string">'^generic/([\\w_]+)'</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/components/generic/\\1/\\1'</span></span>, }</code> </pre> <br>  Der erste ist sehr einfach.  Sie können jede Komponente importieren und den Befehl mit den Wortkomponenten starten.  Im normalen Ansatz sehen Importbefehle ungefähr so ​​aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Product <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../components/product/product'</span></span></code> </pre> <br>  Stattdessen können wir sie so schreiben: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Product <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'components/product/product'</span></span></code> </pre> <br>  Beide Befehle importieren dieselbe Datei.  Dies ist sehr praktisch, da Sie nicht an die Ordnerstruktur denken müssen. <br><br>  Der zweite Alias ​​ist etwas komplizierter: <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'^generic/([\\w_]+)'</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/components/generic/\\1/\\1'</span></span>,</code> </pre> <br>  Wir verwenden hier Regex.  Es werden Importbefehle gefunden, die mit <code>generic</code> beginnen (mit dem Zeichen <code>^</code> am Anfang des Ausdrucks können Sie nur die Befehle auswählen, die mit <code>generic</code> beginnen), und es wird erfasst, was nach <code>generic/</code> in der Gruppe steht.  Danach verwenden wir das erfasste Fragment ( <code>\\1</code> ) im Konstrukt <code>./src/components/generic/\\1/\\1</code> . <br><br>  Daher können wir die Importbefehle für universelle Komponenten dieser Art verwenden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Button <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'generic/button'</span></span></code> </pre> <br>  Sie werden in die folgenden Befehle konvertiert: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Button <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'src/components/generic/button/button'</span></span></code> </pre> <br>  Dieser Befehl dient beispielsweise zum Importieren einer JSX-Datei, die eine universelle Schaltfläche beschreibt.  Wir haben dies alles getan, weil dieser Ansatz den Import universeller Komponenten erheblich vereinfacht.  Darüber hinaus wird es uns gute Dienste leisten, wenn wir uns entscheiden, die Struktur der Projektdateien zu ändern (dies ist durchaus möglich, da unser Designsystem wächst). <br><br>  An dieser Stelle möchte ich darauf hinweisen, dass Sie beim Arbeiten mit Pseudonymen vorsichtig sein sollten.  Wenn Sie nur wenige davon haben und diese zur Lösung von Standardimportproblemen entwickelt wurden, ist alles in Ordnung.  Aber wenn Sie viele von ihnen haben, können sie mehr Verwirrung als Nutzen bringen. <br><br><h2>  <font color="#3AC1EF">Universeller lib-Ordner für Dienstprogramme</font> </h2><br>  Ich möchte die Zeit, die ich damit verbracht habe, den perfekten Ort für Code zu finden, der kein Komponentencode ist, wiedererlangen.  Ich teilte dies alles nach verschiedenen Prinzipien und hob den Code der Dienstprogramme, Dienste und Hilfsfunktionen hervor.  All dies hat so viele Namen, dass ich nicht alle erwähnen werde.  Jetzt versuche ich nicht, den Unterschied zwischen dem "Dienstprogramm" und der "Hilfsfunktion" herauszufinden, um den richtigen Ort für eine bestimmte Datei zu finden.  Jetzt benutze ich einen viel einfacheren und verständlicheren Ansatz: All dies fällt in einen einzigen <code>lib</code> Ordner. <br><br>  Auf lange Sicht kann sich herausstellen, dass der Ordner so groß ist, dass Sie ihn irgendwie strukturieren müssen, aber das ist völlig normal.  Es ist immer einfacher, etwas mit einer bestimmten Struktur auszustatten, als Fehler übermäßiger Strukturierung zu beseitigen. <br><br>  In unserem Thread-Projekt enthält der <code>lib</code> Ordner ungefähr 100 Dateien.  Sie sind ungefähr zu gleichen Teilen in Dateien mit der Implementierung bestimmter Funktionen und in Testdateien unterteilt.  Es gab keine Schwierigkeiten, die erforderlichen Dateien zu finden.  Dank der intelligenten Suchmaschinen <code>lib/name_of_thing</code> die in den meisten Editoren integriert sind, muss ich fast immer so etwas wie <code>lib/name_of_thing</code> , und was ich brauche, wird gefunden. <br><br>  Darüber hinaus verfügen wir über einen Alias, der den Import aus dem <code>lib</code> Ordner vereinfacht und es Ihnen ermöglicht, Befehle dieser Art zu verwenden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> formatPrice <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lib/format_price'</span></span></code> </pre> <br>  Lassen Sie sich nicht von den flachen Ordnerstrukturen beunruhigen, die dazu führen können, dass mehrere Dateien in einem Ordner gespeichert werden.  Normalerweise reicht eine solche Struktur für ein bestimmtes Projekt aus. <br><br><h2>  <font color="#3AC1EF">Ausblenden von Bibliotheken von Drittanbietern hinter nativen APIs</font> </h2><br>  Ich mag das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sentry</a> Bug Monitoring System sehr.  Ich habe es oft verwendet, wenn ich Server- und Client-Teile von Anwendungen entwickelt habe.  Mit seiner Hilfe können Sie Ausnahmen abfangen und Benachrichtigungen über deren Auftreten erhalten.  Dies ist ein großartiges Tool, mit dem wir uns über die auf der Website aufgetretenen Probleme auf dem Laufenden halten können. <br><br>  Wenn ich in meinem Projekt eine Bibliothek eines Drittanbieters verwende, denke ich darüber nach, wie ich sie so gestalten kann, dass sie bei Bedarf so einfach wie möglich durch etwas anderes ersetzt werden kann.  Wie bei demselben Sentry-System, das wir wirklich mögen, ist dies oft nicht erforderlich.  Aber nur für den Fall, es tut nie weh, einen Weg zu finden, um die Verwendung eines bestimmten Dienstes zu vermeiden oder ihn in etwas anderes zu ändern. <br><br>  Die beste Lösung für dieses Problem besteht darin, eine eigene API zu entwickeln, die die Tools anderer Personen verbirgt.  Dies ist so etwas wie das Erstellen eines <code>lib/error-reporting.js</code> <code>reportError()</code> <code>lib/error-reporting.js</code> Moduls, das die Funktion <code>reportError()</code> exportiert.  Der Kern dieses Moduls verwendet Sentry.  Sentry wird jedoch nur in diesem Modul und nirgendwo anders direkt importiert.  Dies bedeutet, dass das Ersetzen von Sentry durch ein anderes Tool sehr einfach aussieht.  Dazu reicht es aus, eine Datei an einem Ort zu ändern.  Solange die öffentliche API dieser Datei unverändert bleibt, weiß der Rest des Projekts nicht einmal, dass beim Aufrufen von <code>reportError()</code> nicht Sentry verwendet wird, sondern etwas anderes. <br><br>  Bitte beachten Sie, dass die öffentliche API des Moduls als die exportierten Funktionen und deren Argumente bezeichnet wird.  Sie werden auch als öffentliche Schnittstelle des Moduls bezeichnet. <br><br><h2>  <font color="#3AC1EF">Verwenden von PropTypes (oder Tools wie TypeScript oder Flow)</font> </h2><br>  Wenn ich programmiere, denke ich an drei Versionen von mir: <br><br><ul><li>  Jack aus der Vergangenheit und der Code, den er geschrieben hat (manchmal zweifelhafter Code). </li><li>  Der heutige Jack und der Code, den er jetzt schreibt. </li><li>  Jack aus der Zukunft.  Wenn ich selbst über diese Zukunft nachdenke, frage ich mich in der Gegenwart, wie ich Code schreiben kann, der mir in Zukunft das Leben leichter macht. </li></ul><br>  Es mag seltsam klingen, aber ich fand es nützlich, über das Schreiben von Code nachzudenken und die folgende Frage zu stellen: "Wie wird es in sechs Monaten wahrgenommen?". <br><br>  Eine einfache Möglichkeit, sich präsent und produktiver zu machen, besteht darin, die von den Komponenten verwendeten Eigenschaftstypen ( <code>PropTypes</code> ) anzugeben.  Dies spart Zeit bei der Suche nach möglichen Tippfehlern.  Dies schützt Sie vor Situationen, in denen bei Verwendung der Komponente Eigenschaften der falschen Typen angewendet werden oder die Übertragung von Eigenschaften vollständig vergessen wird.  In unserem Fall ist die <a href="">Regel eslint-react / prop-types</a> eine gute Erinnerung an die Notwendigkeit, <code>PropTypes</code> zu verwenden. <br><br>  Wenn Sie noch weiter gehen, wird empfohlen, die Eigenschaften so genau wie möglich zu beschreiben.  Zum Beispiel können Sie dies tun: <br><br><pre> <code class="javascript hljs">blogPost: PropTypes.object.isRequired</code> </pre> <br>  Aber es wäre viel besser, dies zu tun: <br><br><pre> <code class="javascript hljs">blogPost: PropTypes.shape({  <span class="hljs-attr"><span class="hljs-attr">id</span></span>: PropTypes.number.isRequired,  <span class="hljs-attr"><span class="hljs-attr">title</span></span>: PropTypes.string.isRequired,  <span class="hljs-comment"><span class="hljs-comment">//    }).isRequired</span></span></code> </pre> <br>  Im ersten Beispiel wird die minimal erforderliche Prüfung durchgeführt.  Im zweiten Schritt erhält der Entwickler viel nützlichere Informationen.  Sie sind beispielsweise sehr nützlich, wenn jemand ein bestimmtes Feld vergisst, das im Objekt verwendet wird. <br><br><h2>  <font color="#3AC1EF">Bibliotheken von Drittanbietern werden nur verwendet, wenn sie wirklich benötigt werden.</font> </h2><br>  Dieser Tipp ist mit dem Aufkommen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React-Hooks</a> relevanter denn je.  Zum Beispiel war ich an einer großen Änderung eines Teils der Thread-Site beteiligt und habe beschlossen, der Verwendung von Bibliotheken von Drittanbietern besondere Aufmerksamkeit zu widmen.  ,       ,          .   (   ),  .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,      React-.      —  ,    ,   React  API Context,        . <br><br> ,  ,  Redux,    .       ,      (            ,     ). ,           ,   ,           . <br><br><h2> <font color="#3AC1EF">   </font> </h2><br>   —   ,       ,   .      . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     emitter.send('user_add_to_cart') //     emitter.on('user_add_to_cart', () =&gt; {  //  -  })</span></span></code> </pre> <br>      ,            .     ,             .      ,   «   ».   ,      ,   ,    .         . «»      - ,       .  ,    ,        . <br><br>      Redux.       .     ,  .  ,     ,  <code>user_add_to_cart</code> ,   .       .  , ,       Redux,      .     ,    Redux    ,     . <br><br>  ,       ,   ,  ,     : <br><br><ul><li>  ,   , .         . </li><li>  ,  ,   .       ,    . </li><li>  ,  -  , . ,     ,    . </li></ul><br>    - ,    .    ,        ,   .      ,        ,   ,           «» . <br><br>       ,       ,  API Context  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-</a> . <br><br><h2> <font color="#3AC1EF">     </font> </h2><br>         ,    (, ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ).     :    ,      . <br><br> ,    ,          ,     .        : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapper = mount(  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">UserAuth.Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span></span><span class="xml"><span class="hljs-tag">=&gt;</span></span></span><span class="xml">    </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ComponentUnderTest</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">UserAuth.Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> )</span></span></code> </pre> <br>      : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapper = mountWithAuth(ComponentUnderTest, {  <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Jack'</span></span>,  <span class="hljs-attr"><span class="hljs-attr">userId</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, })</code> </pre> <br>       : <br><br><ul><li>     .       —     ,     ,   ,      . </li><li>      —    <code>mountWithAuth</code>       .    ,          . </li></ul><br>   ,           <code>test-utils.js</code> . ,       —   .       . <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>       .     ,     , ,  ,      .         ,  ,              .        ,   :       .               .           -     ,   . <br><br>  <b>Liebe Leser!</b>     React-? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460793/">https://habr.com/ru/post/de460793/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460777/index.html">Dies ist die Wende: Warum Apple die Anforderungen für Anwendungsentwickler geändert hat</a></li>
<li><a href="../de460779/index.html">Erweitertes Debug</a></li>
<li><a href="../de460783/index.html">Konsens über die Reputation des Knotens. Ist es notwendig</a></li>
<li><a href="../de460785/index.html">Anwendungen für E-Books auf dem Android-Betriebssystem. Teil 1. Einführung und Office-Anwendungen</a></li>
<li><a href="../de460789/index.html">Schließlich ist Verjüngung eine Sache</a></li>
<li><a href="../de460795/index.html">12 Tipps zur Verbesserung der Leistung von JavaScript-Anwendungen</a></li>
<li><a href="../de460797/index.html">Verantwortliche JavaScript-Entwicklung Teil 2</a></li>
<li><a href="../de460799/index.html">Standard Browser API Zahlungsanforderung</a></li>
<li><a href="../de460801/index.html">27 fantastische VS Code-Tools für moderne JavaScript-Entwickler</a></li>
<li><a href="../de460803/index.html">Lesen für den Sommer: Bücher für Technikfreaks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>