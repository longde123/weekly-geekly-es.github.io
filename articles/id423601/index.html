<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥟 👶 😒 Sistem pekerjaan dan jalur pencarian 🌙 🏳️‍🌈 ⏭️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Peta 
 Dalam artikel sebelumnya, saya melihat apa sistem Job yang baru, bagaimana cara kerjanya, cara membuat tugas, mengisinya dengan data dan melaku...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistem pekerjaan dan jalur pencarian</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423601/"><h3>  Peta </h3><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya,</a> saya melihat apa <b>sistem Job yang</b> baru, bagaimana cara kerjanya, cara membuat tugas, mengisinya dengan data dan melakukan perhitungan multi-threaded, dan hanya menjelaskan secara singkat di mana Anda dapat menggunakan sistem ini.  Pada artikel ini, saya akan mencoba mem-parsing contoh spesifik di mana Anda dapat menggunakan sistem ini untuk mendapatkan lebih banyak kinerja. <br><a name="habracut"></a><br>  Karena sistem ini awalnya dikembangkan dengan tujuan bekerja dengan data, itu bagus untuk menyelesaikan tugas-tugas pencarian jalur. <br><br>  <b>Unity</b> telah memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pathfinder NavMesh yang</a> baik, tetapi tidak berfungsi dalam proyek 2D, meskipun ada banyak solusi siap pakai pada <i>aset yang</i> sama.  Baiklah, dan kami akan mencoba untuk membuat bukan hanya sistem yang akan mencari cara pada peta yang dibuat, tetapi membuat peta ini sangat dinamis, sehingga setiap kali ada perubahan, sistem akan membuat peta baru, dan semua ini tentu saja akan kami hitung menggunakan sistem tugas baru, agar tidak memuat utas utama. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh pengoperasian sistem</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/527/a69/ec1/527a69ec1543218ffe1df7c4b1deddb0.gif" alt="gambar"><br></div></div><br>  Dalam contoh ini, kotak dibangun di peta, ada bot dan hambatan.  Kotak dibangun kembali setiap kali kami mengubah properti peta apa pun, baik ukuran maupun posisinya. <br><br>  Untuk pesawat, saya menggunakan <b>SpriteRenderer</b> sederhana, komponen ini memiliki properti <b>batas yang</b> luar biasa yang dengannya Anda dapat dengan mudah mengetahui ukuran peta. <br><br>  Pada dasarnya itu semua hanya untuk permulaan, tetapi kami tidak akan berhenti dan segera memulai bisnis. <br><br>  Mari kita mulai dengan skrip.  Dan yang pertama adalah naskah penghalang <b>Rintangan</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Rintangan</b> <div class="spoiler_text"><pre><code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br></div></div><br>  Di dalam kelas <b>Rintangan</b> , kita akan menangkap semua perubahan hambatan pada peta, misalnya, mengubah posisi atau ukuran suatu objek. <br>  Selanjutnya, Anda bisa membuat kelas peta peta, di mana kotak akan dibangun, dan mewarisinya dari kelas <b>Kendala</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Peta</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br></div></div><br>  Kelas <b>Peta</b> juga akan melacak semua perubahan pada peta untuk membangun kembali kisi jika perlu. <br><br>  Untuk melakukan ini, isi kelas dasar <b>Rintangan</b> dengan semua variabel dan metode yang diperlukan untuk melacak perubahan objek. <br><br><div class="spoiler">  <b class="spoiler_title">Rintangan</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpriteRenderer renderer { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempSize; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempPos; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer = GetComponent&lt;SpriteRenderer&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> virtual bool CheckChanges() { Vector2 newSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size; float diff = (newSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize = newSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } Vector2 newPos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; diff = (newPos - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos = newPos; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 size { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.bounds.size;} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position;} } }</code> </pre> <br></div></div><br>  Di sini, variabel <b>renderer</b> akan memiliki referensi ke komponen <b>SpriteRenderer</b> , dan <b>variabel tempSize</b> dan <b>tempPos</b> akan digunakan untuk melacak perubahan dalam ukuran dan posisi objek. <br><br>  Metode virtual <b>Sedar</b> akan digunakan untuk menginisialisasi variabel, dan metode virtual <b>CheckChanges</b> akan melacak perubahan saat ini dalam ukuran dan posisi objek dan mengembalikan hasil <b>boolean</b> . <br><br>  Untuk saat ini, mari kita tinggalkan skrip <b>Rintangan</b> dan beralih ke skrip peta <b>Peta</b> itu sendiri, di mana kita juga mengisinya dengan parameter yang diperlukan untuk pekerjaan. <br><br><div class="spoiler">  <b class="spoiler_title">Peta</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ [Range(<span class="hljs-number"><span class="hljs-number">0.1</span></span>f, <span class="hljs-number"><span class="hljs-number">1</span></span>f)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); }</code> </pre> <br></div></div><br>  Variabel <b>nodeSize</b> akan menunjukkan ukuran sel pada peta, di sini saya membatasi ukurannya dari 0,1 hingga 1 sehingga sel-sel pada grid tidak terlalu kecil, tetapi juga terlalu besar.  Variabel <b>offset</b> akan digunakan untuk membuat inden peta saat membuat kisi sehingga kisi tidak membangun di sepanjang tepi peta. <br><br>  Karena sekarang ada dua variabel baru di peta, ternyata perubahan mereka juga perlu dilacak.  Untuk melakukan ini, tambahkan beberapa variabel dan overload metode <b>CheckChanges</b> di kelas <b>Peta</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Peta</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ [Range(<span class="hljs-number"><span class="hljs-number">0.1</span></span>f, <span class="hljs-number"><span class="hljs-number">1</span></span>f)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> float tempNodeSize; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempOffset; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { base.Awake(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool CheckChanges() { float diff = Mathf.Abs(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } diff = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.CheckChanges(); } }</code> </pre> <br></div></div><br>  Selesai  Sekarang Anda dapat membuat sprite peta di atas panggung dan melemparkan skrip <b>Peta</b> di atasnya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d75/60f/db8/d7560fdb8abeb5f00a7a5e1ec5e444df.png" alt="gambar"><br><br>  Kami akan melakukan hal yang sama dengan penghalang - buat sprite sederhana di atas panggung dan lemparkan skrip <b>Hambatan</b> ke atasnya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/347/ffa/e8d/347ffae8dd2b4cd3a3a50c881d5674df.png" alt="gambar"><br><br>  Sekarang kita memiliki objek peta dan rintangan di atas panggung. <br><br>  Skrip <b>Peta</b> akan bertanggung jawab untuk melacak semua perubahan pada peta, di mana dalam metode <b>Pembaruan</b> kami akan memeriksa setiap frame untuk perubahan. <br><br><div class="spoiler">  <b class="spoiler_title">Peta</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> bool requireRebuild; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() { UpdateChanges(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(“  ,   !”); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> }</code> </pre> <br></div></div><br>  Jadi, dalam metode <b>UpdateChanges,</b> peta hanya akan melacak perubahannya sejauh ini.  Anda bahkan dapat memulai permainan sekarang dan mencoba mengubah ukuran peta atau <b>mengimbangi offset</b> untuk memastikan bahwa semua perubahan dilacak. <br><br>  Sekarang Anda perlu melacak perubahan hambatan itu sendiri di peta.  Untuk melakukan ini, kami akan menempatkan setiap rintangan dalam daftar di peta, yang pada gilirannya akan memperbarui setiap bingkai dalam metode <b>Pembaruan</b> . <br><br>  Di kelas <b>Peta</b> , buat daftar semua hambatan yang mungkin ada di peta dan beberapa metode statis untuk mendaftarkannya. <br><br><div class="spoiler">  <b class="spoiler_title">Peta</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map ObjInstance; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Obstacle&gt; obstacles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Obstacle&gt;(); <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool RegisterObstacle(Obstacle obstacle) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle == Instance) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Instance.obstacles.Contains(obstacle) == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { Instance.obstacles.Add(obstacle); Instance.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool UnregisterObstacle(Obstacle obstacle) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Instance.obstacles.Remove(obstacle)) { Instance.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ObjInstance == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ObjInstance = FindObjectOfType&lt;Map&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ObjInstance; } } }</code> </pre> <br></div></div><br>  Dalam metode <b>RegisterObstacle</b> statis, kami akan mendaftarkan hambatan <b>Kendala</b> baru di peta dan menambahkannya ke daftar, tetapi pertama-tama penting untuk mempertimbangkan bahwa peta itu sendiri juga diwarisi dari kelas <b>Kendala</b> dan oleh karena itu kita perlu memeriksa apakah kita mencoba mendaftarkan kartu itu sendiri sebagai hambatan. <br><br>  Metode statis <b>UnregisterObstacle</b> , sebaliknya, menghilangkan hambatan dari peta dan menghilangkannya dari daftar ketika kita membiarkannya dihancurkan. <br><br>  Pada saat yang sama, setiap kali kita menambah atau menghapus hambatan dari peta, kita perlu membuat ulang peta itu sendiri, jadi setelah menjalankan metode statis ini, setel variabel <b>requireRebuild</b> menjadi <b>true</b> . <br><br>  Juga, untuk memiliki akses mudah ke skrip <b>Peta</b> dari skrip apa pun, saya membuat properti <b>Instance</b> statis yang akan mengembalikan kepada saya instance dari <b>Peta ini</b> . <br><br>  Sekarang, mari kita kembali ke skrip <b>Rintangan di</b> mana kita akan mendaftarkan penghalang pada peta. Untuk melakukan ini, tambahkan beberapa metode <b>OnEnable</b> dan <b>OnDisable</b> untuk itu. <br><br><div class="spoiler">  <b class="spoiler_title">Rintangan</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { Map.RegisterObstacle(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() { Map.UnregisterObstacle(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br></div></div><br>  Setiap kali kita membuat penghalang baru saat bermain di peta, itu akan secara otomatis mendaftar di metode <b>OnEnable</b> , di mana ia akan diperhitungkan ketika membangun kisi baru dan menghapus diri kita dari peta dalam metode <b>OnDisable</b> ketika dihancurkan atau dinonaktifkan. <br><br>  Tetap hanya melacak perubahan hambatan itu sendiri dalam skrip <b>Peta</b> dalam metode <b>CheckChanges yang</b> kelebihan beban. <br><br><div class="spoiler">  <b class="spoiler_title">Peta</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool CheckChanges() { float diff = Mathf.Abs(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } diff = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } foreach(Obstacle obstacle <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle.CheckChanges()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.CheckChanges(); } <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> }</code> </pre> <br></div></div><br>  Sekarang kita memiliki peta, rintangan - secara umum, semua yang Anda butuhkan untuk membangun kisi dan sekarang Anda dapat beralih ke hal yang paling penting. <br><br><h4>  Meshing </h4><br>  Kotak, dalam bentuknya yang paling sederhana, adalah susunan titik dua dimensi.  Untuk membangunnya, Anda perlu mengetahui ukuran peta dan ukuran titik di atasnya, setelah beberapa perhitungan kami mendapatkan jumlah titik secara horizontal dan vertikal, ini adalah kisi kami. <br><br>  Ada banyak cara untuk menemukan jalur di grid.  Dalam artikel ini, bagaimanapun, hal utama adalah untuk memahami bagaimana cara yang benar menggunakan kemampuan sistem tugas, jadi di sini saya tidak akan mempertimbangkan opsi yang berbeda untuk menemukan jalan, kelebihan dan kekurangannya, tetapi saya akan mengambil opsi pencarian paling sederhana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">A *</a> . <br><br>  Dalam hal ini, semua titik pada grid harus memiliki, selain posisi, koordinat dan properti patensi. <br><br>  Dengan patensi, saya pikir semuanya jelas mengapa diperlukan, tetapi koordinat akan menunjukkan urutan titik pada grid, koordinat ini tidak terikat secara khusus dengan posisi titik di ruang angkasa.  Gambar di bawah ini menunjukkan grid sederhana yang menunjukkan perbedaan koordinat dari suatu posisi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/c12/466/7c1c124662f7c41ecb2a1c55939a1a64.png" alt="gambar"><br>  <i>Kenapa koordinatnya?</i> <br>  Faktanya adalah bahwa dalam kesatuan, untuk menunjukkan posisi suatu objek di ruang angkasa, <b>float</b> sederhana <b>digunakan</b> yang sangat tidak akurat dan dapat berupa angka pecahan atau negatif, sehingga akan sulit untuk menggunakannya untuk mengimplementasikan pencarian jalur pada peta.  Koordinat dibuat dalam bentuk <b>int</b> yang jelas yang akan selalu positif dan dengan itu lebih mudah untuk bekerja dengan ketika mencari titik tetangga. <br><br>  Pertama, mari kita tentukan objek titik, ini akan menjadi struktur <b>Node</b> sederhana. <br><br><div class="spoiler">  <b class="spoiler_title">Node</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int coords; }</code> </pre> <br></div></div><br>  Struktur ini akan berisi posisi <b>posisi</b> dalam bentuk <b>Vector2</b> , di mana dengan variabel ini kita akan menggambar titik di ruang angkasa.  <b>Variabel</b> koordinat koordinat dalam bentuk <b>Vector2Int</b> akan menunjukkan koordinat suatu titik di peta, dan variabel <b>id</b> , nomor akun numeriknya, dengan menggunakannya kita akan membandingkan titik-titik yang berbeda di grid dan memeriksa keberadaan suatu titik. <br><br>  Patensi titik akan ditunjukkan dalam bentuk properti <b>booleannya</b> , tetapi karena kita tidak dapat menggunakan <i>tipe</i> data yang dapat <i>dikonversi</i> dalam sistem tugas, kami akan menunjukkan patennya dalam bentuk nomor <b>int</b> , karena ini saya menggunakan enumerasi sederhana <b>NodeType</b> , di mana: 0 bukan titik yang bisa dilewati, dan 1 lumayan. <br><br><div class="spoiler">  <b class="spoiler_title">NodeType dan Node</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> enum NodeType { NonWalkable = <span class="hljs-number"><span class="hljs-number">0</span></span>, Walkable = <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int coords; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> int nodeType; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool isWalkable { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeType == (int)NodeType.Walkable;} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node(int id, Vector2 position, Vector2Int coords, NodeType type) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = id; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.coords = coords; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeType = (int)type; } }</code> </pre> <br></div></div><br>  Juga, untuk kenyamanan bekerja dengan suatu titik, saya akan membebani metode <b>Persamaan</b> untuk membuatnya lebih mudah untuk membandingkan titik dan juga melengkapi metode verifikasi untuk keberadaan suatu titik. <br><br><div class="spoiler">  <b class="spoiler_title">Node</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool Equals(object obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Node) { Node other = (Node)obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id == other.id; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.Equals(obj); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> implicit operator bool(Node node) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.id &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br></div></div><br>  Karena nomor <b>id</b> titik di grid akan mulai dengan 1 unit, saya akan memeriksa keberadaan titik sebagai syarat bahwa <b>idnya</b> lebih besar dari 0. <br><br>  Pergi ke kelas <b>Peta di</b> mana kami akan menyiapkan segalanya untuk membuat peta. <br>  Kami sudah memiliki pemeriksaan untuk mengubah parameter peta, sekarang kita perlu menentukan bagaimana proses membangun grid akan dilakukan.  Untuk melakukan ini, buat satu variabel baru dan beberapa metode. <br><br><div class="spoiler">  <b class="spoiler_title">Peta</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool rebuilding { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() {} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() {} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() {} <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> }</code> </pre> <br></div></div><br>  Properti <b>pembangunan kembali</b> akan menunjukkan apakah proses <b>meshing</b> sedang berlangsung.  Metode <b>Rebuild</b> akan mengumpulkan data dan tugas untuk membangun grid, maka metode <b>OnRebuildStart</b> akan memulai proses pembuatan grid dan metode <b>OnRebuildFinish</b> akan mengumpulkan data dari tugas. <br><br>  Sekarang mari kita ubah metode <b>UpdateChanges sedikit</b> sehingga kondisi grid diperhitungkan. <br><br><div class="spoiler">  <b class="spoiler_title">Peta</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool rebuilding { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) { print(“  ...”); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(“  ,   !”); Rebuild(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; print(“ !”); OnRebuildStart(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> }</code> </pre> <br></div></div><br>  Seperti yang Anda lihat sekarang dalam metode <b>UpdateChanges ada</b> kondisi bahwa saat membangun mesh lama tidak mulai membangun yang baru, dan juga dalam metode <b>Rebuild</b> , tindakan pertama memeriksa apakah proses meshing sudah dalam proses. <br><br><h4>  Pemecahan masalah </h4><br>  Sekarang sedikit tentang proses membangun peta. <br>  Karena kita akan menggunakan sistem tugas dan membangun grid secara paralel untuk membangun peta, saya menggunakan jenis tugas <b>IJobParallelFor</b> , yang akan dieksekusi beberapa kali.  Agar tidak memuat proses konstruksi dengan satu tugas terpisah, kami akan menggunakan kumpulan tugas yang dikemas ke dalam satu <b>JobHandle</b> . <br><br>  Paling sering, untuk membangun kisi, gunakan dua siklus yang saling bersarang untuk membangun, misalnya, secara horizontal dan vertikal.  Dalam contoh ini, kita juga akan membangun grid terlebih dahulu secara horizontal dan kemudian secara vertikal.  Untuk melakukan ini, kita menghitung jumlah titik horizontal dan vertikal dalam metode <b>Rebuild</b> , kemudian dalam metode <b>Rebuild</b> kita melalui siklus di sepanjang titik-titik vertikal, dan kita akan membangun yang horisontal secara paralel dalam tugas.  Untuk lebih membayangkan proses pembangunan, lihat animasi di bawah ini. <br><br><div class="spoiler">  <b class="spoiler_title">Meshing</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/101/625/183/10162518305232afb889f9d8a45b70da.gif" alt="gambar"><br></div></div><br>  Jumlah titik vertikal akan menunjukkan jumlah tugas, pada gilirannya, setiap tugas akan membangun poin hanya secara horizontal, setelah menyelesaikan semua tugas, poin-poin tersebut dijumlahkan dalam satu daftar.  Itulah sebabnya saya perlu menggunakan tugas seperti <b>IJobParallelFor</b> untuk melewati indeks titik di grid secara horizontal ke metode <b>Execute</b> . <br><br>  Jadi kami memiliki struktur titik, sekarang Anda dapat membuat struktur tugas <b>Pekerjaan</b> dan mewarisinya dari antarmuka <b>IJobParallelFor</b> , semuanya sederhana di sini. <br><br><div class="spoiler">  <b class="spoiler_title">Ayub</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Job : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Kami kembali ke metode <b>Rebuild</b> kelas <b>peta</b> , di mana kami akan membuat perhitungan yang diperlukan untuk pengukuran grid. <br><br><div class="spoiler">  <b class="spoiler_title">Peta</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; print(“ !”); Vector2 mapSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset * <span class="hljs-number"><span class="hljs-number">2</span></span>f; int horizontals = Mathf.RoundToInt(mapSize.x / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); int verticals = Mathf.RoundToInt(mapSize.y / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (horizontals &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { OnRebuildFinish(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); OnRebuildStart(); } <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> }</code> </pre> <br></div></div><br>  Dalam metode <b>Rebuild</b> , kami menghitung ukuran persis peta <b>mapSize</b> , dengan mempertimbangkan lekukan, kemudian secara <b>vertikal</b> kami menulis jumlah titik secara vertikal, dan dalam <b>horizontal</b> jumlah titik secara horizontal.  Jika jumlah titik vertikal adalah 0, maka kita berhenti membangun peta dan memanggil metode <b>OnRebuildFinish</b> untuk menyelesaikan proses.  Variabel <b>asal</b> akan menunjukkan tempat dari mana kita akan mulai membangun kisi - dalam contoh, ini adalah titik kiri bawah pada peta. <br><br>  Sekarang Anda dapat pergi ke tugas sendiri dan mengisinya dengan data. <br>  Selama konstruksi grid, tugas akan membutuhkan array <b>NativeArray di</b> mana kita akan menempatkan titik, juga karena kita memiliki hambatan pada peta, kita juga akan perlu untuk meneruskannya ke tugas, untuk ini kita akan menggunakan array <b>NativeArray</b> lain, maka kita perlu ukuran poin dalam masalah , posisi awal dari tempat kita akan membangun poin, serta koordinat awal seri. <br><br><div class="spoiler">  <b class="spoiler_title">Ayub</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Job : IJobParallelFor { [WriteOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Node&gt; array; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Rect&gt; bounds; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 startPos; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int startCoords; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Saya menandai array poin dengan atribut <b>WriteOnly,</b> karena dalam tugas itu hanya perlu untuk " <i>menulis</i> " poin yang diterima ke array, sebaliknya, array <b>batas</b> rintangan ditandai dengan atribut <b>ReadOnly</b> karena dalam tugas kita hanya akan " <i>membaca</i> " data dari array ini. <br><br>  Nah, untuk sekarang, mari kita lanjutkan ke penghitungan poin sendiri nanti. <br><br>  Sekarang kembali ke kelas <b>Peta</b> , di mana kami menunjukkan semua variabel yang terlibat dalam tugas. <br>  Di sini, pertama-tama, kita perlu <b>menangani</b> tugas <b>-</b> tugas global, serangkaian hambatan dalam bentuk <b>NativeArray</b> , daftar tugas yang akan berisi semua poin yang diterima di grid dan <b>Kamus</b> dengan semua koordinat dan poin di peta, sehingga akan lebih mudah untuk mencari mereka nanti. <br><br><div class="spoiler">  <b class="spoiler_title">Peta</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Rect&gt; bounds; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> HashSet&lt;NativeArray&lt;Node&gt;&gt; jobs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;NativeArray&lt;Node&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;Vector2Int, Node&gt; nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Vector2Int, Node&gt;(); <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> }</code> </pre> <br></div></div><br>  Sekarang lagi, kita kembali ke metode <b>Rebuild</b> dan terus membangun grid. <br>  Pertama, inisialisasi array <b>batas</b> rintangan untuk meneruskannya ke tugas. <br><br><div class="spoiler">  <b class="spoiler_title">Bangun kembali</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Di sini kita membuat instance <b>NativeArray</b> melalui konstruktor baru dengan tiga parameter.  Saya memeriksa dua parameter pertama dalam artikel sebelumnya, tetapi parameter ketiga akan membantu kita menghemat sedikit waktu membuat array.  Faktanya adalah bahwa kita akan menulis data ke array segera setelah pembuatannya, yang berarti kita tidak perlu memastikan bahwa itu dihapus.  Parameter ini berguna untuk <b>NativeArray</b> yang hanya akan digunakan dalam mode <i>baca</i> dalam tugas. <br><br>  Jadi, kemudian kita mengisi array <b>batas</b> dengan data. <br><br><div class="spoiler">  <b class="spoiler_title">Bangun kembali</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Sekarang kita dapat beralih ke membuat tugas, untuk ini kita akan melalui siklus melalui semua baris vertikal grid. <br><br><div class="spoiler">  <b class="spoiler_title">Bangun kembali</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Untuk mulai dengan, di <b>xPos</b> dan <b>yPos</b> kita mendapatkan posisi horizontal awal seri. <br><br><div class="spoiler">  <b class="spoiler_title">Bangun kembali</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; NativeArray&lt;Node&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Node&gt;(horizontals, Allocator.Persistent); Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); job.startCoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(i * horizontals, i); job.startPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(xPos, yPos); job.nodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; job.bounds = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds; job.array = array; } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Selanjutnya, kita membuat array <b>NativeArray</b> sederhana di mana titik-titik dalam tugas akan ditempatkan, di sini untuk array <b>array</b> Anda perlu menentukan berapa banyak poin yang akan dibuat secara horizontal dan jenis alokasi <b>Persistent</b> , karena tugas dapat memakan waktu lebih dari satu frame. <br>  Setelah itu, buat contoh tugas <b>Pekerjaan</b> itu sendiri, letakkan koordinat awal dari seri <b>startCoords</b> , posisi awal dari seri <b>startPos</b> , ukuran titik <b>nodeSize</b> , <b>batas</b> array hambatan, dan pada akhirnya array titik itu sendiri. <br>  Tinggal <b>menangani</b> tugas dan daftar tugas global. <br><br><div class="spoiler">  <b class="spoiler_title">Bangun kembali</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; NativeArray&lt;Node&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Node&gt;(horizontals, Allocator.Persistent); Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); job.startCoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(i * horizontals, i); job.startPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(xPos, yPos); job.nodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; job.bounds = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds; job.array = array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(horizontals, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs.Add(array); } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Selesai  Kami memiliki daftar tugas dan <b>pegangan</b> umum mereka, sekarang kami dapat menjalankan <b>pegangan</b> ini <b>dengan</b> memanggil metode <b>Lengkapnya di</b> metode <b>OnRebuildStart</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Onrebuildstart</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  Karena variabel <b>pembangunan kembali</b> akan menunjukkan bahwa proses <b>meshing</b> sedang berlangsung, metode <b>UpdateChanges itu sendiri</b> juga harus menentukan kondisi ketika proses ini akan berakhir menggunakan <b>pegangan</b> dan properti <b>IsCompleted</b> -nya. <br><br><div class="spoiler">  <b class="spoiler_title">Pembaruan perubahan</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) { print(“  ...”); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted) OnRebuildFinish(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(“  ,   !”); Rebuild(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } }</code> </pre> <br></div></div><br>  Setelah menyelesaikan tugas, metode <b>OnRebuildFinish</b> akan dipanggil di mana kami akan mengumpulkan poin yang diterima ke dalam satu daftar <b>Kamus</b> umum, dan yang paling penting, untuk menghapus sumber daya yang ditempati. <br><br><div class="spoiler">  <b class="spoiler_title">OnRebuildFinish</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Clear(); foreach (NativeArray&lt;Node&gt; array <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs) { foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> array) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Add(node.coords, node); array.Dispose(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds.IsCreated) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds.Dispose(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, kita menghapus kamus </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari titik sebelumnya, kemudian menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foreach loop untuk</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memilah-milah semua poin yang kita terima dari tugas dan menempatkannya dalam kamus </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di mana kuncinya adalah koordinat ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUKAN posisi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !) Dari titik tersebut, dan nilainya adalah titik itu sendiri. </font><font style="vertical-align: inherit;">Dengan bantuan kamus ini, akan lebih mudah bagi kami untuk mencari titik tetangga di peta. </font><font style="vertical-align: inherit;">Setelah mengisi, kami menghapus array </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">array</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menggunakan metode </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan pada akhirnya kami menghapus daftar tugas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pekerjaan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> itu sendiri </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda juga perlu menghapus </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">batasan batasan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jika itu sebelumnya dibuat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah semua tindakan ini, kami mendapatkan daftar semua poin di peta dan sekarang Anda dapat menggambarnya di atas panggung.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sesuatu seperti ini</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/65f/2d0/5a8/65f2d05a86a6a508900fcf321d546089.gif" alt="gambar"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melakukan ini, di kelas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">buat metode </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnDrawGizmos di</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mana kita akan menggambar poin.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() {} #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang melalui loop kita menggambar setiap titik. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() { foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Values) { Gizmos.DrawWireSphere(node.position, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">10</span></span>f); } } #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setelah semua tindakan ini, peta kami terlihat agak membosankan, untuk benar-benar mendapatkan kisi, Anda perlu titik untuk terhubung satu sama lain. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesh</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/460/01d/f10/46001df105fcb2bd9fb90ef382888f26.gif" alt="gambar"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mencari titik tetangga, kita hanya perlu menemukan titik yang diinginkan dengan koordinatnya dalam 8 arah, jadi di kelas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kita akan </font><font style="vertical-align: inherit;">membuat array statis arah </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arah</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan metode pencarian sel dengan koordinat </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetNode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -nya </font><font style="vertical-align: inherit;">.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly Vector2Int[] Directions = { Vector2Int.up, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), Vector2Int.right, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Vector2Int.down, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Vector2Int.left, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), }; <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node GetNode(Vector2Int coords) { Node result = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(Node); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes[coords]; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() {} #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetNode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan mengembalikan titik dengan koordinat dari daftar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi Anda harus melakukan ini dengan hati-hati, karena jika koordinat </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vector2Int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> salah, kesalahan akan terjadi, jadi di sini kami menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blok</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pintas </font><b><font style="vertical-align: inherit;">try catch</font></b><font style="vertical-align: inherit;"> exception </font><font style="vertical-align: inherit;">, yang akan membantu memotong pengecualian dan tidak " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggantung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " seluruh aplikasi dengan kesalahan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, kita akan melalui siklus di semua arah dan mencoba untuk menemukan titik-titik tetangga dalam metode </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnDrawGizmos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan yang paling penting, jangan lupa untuk mempertimbangkan paten dari titik tersebut.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ondrawgizmos</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() { Color c = Gizmos.color; foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Values) { Color newColor = Color.white; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.isWalkable) newColor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32(<span class="hljs-number"><span class="hljs-number">153</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">51</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> newColor = Color.red; Gizmos.color = newColor; Gizmos.DrawWireSphere(node.position, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">10</span></span>f); newColor = Color.green; Gizmos.color = newColor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.isWalkable) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; Directions.Length; i++) { Vector2Int coords = node.coords + Directions[i]; Node connection = GetNode(coords); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connection) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connection.isWalkable) Gizmos.DrawLine(node.position, connection.position); } } } } Gizmos.color = c; } #endif</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang Anda dapat dengan aman memulai permainan dan melihat apa yang terjadi. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta dinamis</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/302/3ae/4e3/3023ae4e31ba9b2f888c27c4a9144ab7.gif" alt="gambar"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam contoh ini, kami hanya membuat grafik itu sendiri menggunakan tugas, tetapi inilah yang terjadi setelah saya mengacaukan sistem algoritma </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> itu sendiri </font><font style="vertical-align: inherit;">, yang juga menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistem Pekerjaan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk menemukan jalan, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sumber di akhir artikel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencarian peta dan jalur</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/769/46c/b2a76946c68d7af5dc30d3226e27b5a1.gif" alt="gambar"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi Anda dapat menggunakan sistem tugas baru untuk tujuan Anda dan membangun sistem yang menarik tanpa banyak usaha. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti pada artikel sebelumnya, sistem tugas digunakan tanpa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi jika Anda menggunakan sistem ini bersama dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Anda dapat mencapai hasil yang luar biasa dalam keuntungan kinerja. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Good luck</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber Proyek Path Finder</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423601/">https://habr.com/ru/post/id423601/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423589/index.html">Bagaimana kami memilih TTS, misalnya, suara dalam Kamus</a></li>
<li><a href="../id423591/index.html">Lagu-lagu lama tentang hal utama. Permintaan Java dan keluar</a></li>
<li><a href="../id423593/index.html">Google mengumumkan kontes untuk serangan pada algoritma visi mesin</a></li>
<li><a href="../id423595/index.html">Frango Anomaly, Interchange</a></li>
<li><a href="../id423597/index.html">Bagaimana dan cluster mana yang dapat dialokasikan di basis klien</a></li>
<li><a href="../id423603/index.html">RxSwift bagian 1</a></li>
<li><a href="../id423607/index.html">Linus Torvalds menyerah dengan gaya yang sulit dan menghabiskan waktu</a></li>
<li><a href="../id423609/index.html">Ke mana situs web pergi setelah kematian? Pengalaman pribadi</a></li>
<li><a href="../id423611/index.html">Pembayaran sekali klik - baik atau buruk?</a></li>
<li><a href="../id423615/index.html">Keterampilan profesional dibutuhkan di antara spesialis-UX (potongan 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>