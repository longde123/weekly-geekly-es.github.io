<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💯 👩‍🚒 🌁 Estruturas de dados para armazenamento de gráficos: uma revisão das existentes e duas "quase novas" 👂🏾 🤘🏽 🚶🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá pessoal. 

 Nesta nota, decidi listar as principais estruturas de dados usadas para armazenar gráficos em ciência da computação e também falar sob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estruturas de dados para armazenamento de gráficos: uma revisão das existentes e duas "quase novas"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469967/">  Olá pessoal. <br><br>  Nesta nota, decidi listar as principais estruturas de dados usadas para armazenar gráficos em ciência da computação e também falar sobre algumas outras estruturas que de alguma forma se cristalizaram por mim. <br><br>  Então, vamos começar.  Mas não desde o início - acho que o que é um gráfico e o que é (orientado, não orientado, ponderado, não ponderado, com várias arestas e loops ou sem eles), todos nós já sabemos. <br><br>  Então vamos lá.  Quais são as opções para estruturas de dados que temos para "armazenamento de gráficos". <br><a name="habracut"></a><br><h2>  1. Estruturas de dados matriciais </h2><br>  1.1 <b>Matriz de adjacência.</b>  A matriz de adjacência é uma matriz em que os títulos de linha e coluna correspondem aos números dos vértices do gráfico e o valor de cada um de seus elementos a (i, j) é determinado pela presença ou ausência de arestas entre os vértices iej (é claro que essa matriz para um gráfico não direcionado será simétrico, ou você pode concordar que armazenamos todos os valores somente acima da diagonal principal).  Para gráficos não ponderados, a (i, j) pode ser especificado pelo número de arestas de i a j (se não houver essa aresta, então a (i, j) = 0) e, para os ponderados, pelo peso (peso total) das arestas mencionadas. <br><br>  1.2 <b>A matriz de incidência.</b>  Nesse caso, nosso gráfico também é armazenado em uma tabela na qual, como regra, os números de linhas correspondem aos números de seus vértices e os números das colunas correspondem às arestas pré-numeradas.  Se o vértice e a aresta são incidentes um ao outro, um valor diferente de zero é gravado na célula correspondente (para gráficos não direcionados, 1 é gravado no caso de incidência do vértice e aresta, para gráficos orientados "1" se a aresta "sai" do vértice e "-1" se "entra" (é lembrado facilmente, porque o sinal de menos também parece estar "incluído" no número "-1")).  Para gráficos ponderados, novamente, em vez de 1 e -1, você pode especificar o peso total da aresta. <br><br><h2>  2. Estruturas de dados de enumeração </h2><br>  2.1 <b>lista de adjacência.</b>  Bem, tudo parece ser simples.  Em geral, cada vértice de um gráfico pode ser associado a qualquer estrutura de enumeração (lista, vetor, matriz, ...), na qual os números de todos os vértices adjacentes a este serão armazenados.  Para gráficos orientados, listaremos apenas vértices nos quais existe uma aresta "direcionada" do atributo de vértice.  Para gráficos ponderados, a implementação será mais complexa. <br><br>  2.2 <b>Lista de costelas.</b>  Estrutura de dados bastante popular.  A lista de arestas, como o Capitão Evidence nos diz, é na verdade uma lista de arestas do gráfico, cada uma delas definida por um vértice inicial, um vértice final (para gráficos não direcionados, a ordem não é importante aqui, embora regras diferentes possam ser usadas para a unificação, por exemplo, especifique vértices em ordem). crescente) e peso (apenas para gráficos ponderados). <br><br>  Sobre as listas de matrizes listadas acima, você pode ver (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ) com mais detalhes. <br><br>  2.3 <b>Matriz de adjacência.</b>  Não é a estrutura mais comum.  Na sua essência, é uma forma de "empacotar" listas de adjacência em uma estrutura de enumeração (matriz, vetor).  Os primeiros n elementos (pelo número de vértices do gráfico) de uma matriz contêm índices iniciais da mesma matriz, a partir dos quais todos os vértices adjacentes a ela são gravados nela em uma linha. <br><br>  Aqui encontrei a explicação mais compreensível (para mim): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ejuo.livejournal.com/4518.html</a> <br><br><h2>  3. Vetor de adjacência e matriz associativa de adjacência </h2><br>  Aconteceu que o autor dessas linhas, não sendo um programador profissional, mas lidando periodicamente com gráficos, costumava lidar com listas de arestas.  De fato, é conveniente se o gráfico tiver vários loops e arestas.  E agora, no desenvolvimento das listas clássicas de arestas, proponho prestar atenção ao seu “desenvolvimento / ramificação / modificação / mutação”, a saber: o vetor de adjacência e a matriz associativa de adjacência. <br><br>  <b>3.1 Vetor de adjacência</b> <br><br>  <i>Caso (A1): contagem não ponderada</i> <br><br>  Vamos chamar o vetor de adjacência para um gráfico não ponderado de um conjunto ordenado de um número par de números inteiros (a [2i], a [2i + 1], ..., onde i é numerado c 0), no qual cada par de números a [2i], a [2i +1] define a aresta do gráfico entre os vértices a [2i] e a [2i + 1], respectivamente. <br>  Este formato de gravação não contém informações sobre a orientação do gráfico (as duas opções são possíveis).  Ao usar o formato do dígrafo, supõe-se que a aresta seja direcionada de um [2i] para um [2i + 1].  A seguir: para gráficos não direcionados, se necessário, os requisitos para a ordem dos vértices de gravação podem ser aplicados (por exemplo, para que o vértice com o valor mais baixo do número atribuído a ele vá primeiro). <br><br>  Em C ++, é aconselhável especificar o vetor de adjacência usando std :: vector, no qual o nome dessa estrutura de dados foi escolhido. <br><br>  <i>Caso (a2): gráfico não ponderado, pesos de arestas inteiras</i> <br><br>  Por analogia com o caso (a1), chamamos o vetor de adjacência para um gráfico ponderado com pesos de arestas inteiras um conjunto ordenado (matriz dinâmica) de números (a [3i], [3i + 1], [[3i + 2], ..., onde i é numerado c 0), onde cada "trigêmeo" dos números a [3i], a [3i + 1], a [3i + 2] define a aresta do gráfico entre os vértices sob os números a [3i] e [3i + 1], respectivamente, e o valor de a [3i + 2] é o peso dessa aresta.  Esse gráfico também pode ser orientado ou não. <br><br>  <i>Caso (b): gráfico não ponderado, pesos das arestas não inteiras</i> <br><br>  Como os elementos heterogêneos não podem ser armazenados em uma matriz (vetor), a seguinte implementação é possível, por exemplo.  O gráfico é armazenado em um par de vetores, no qual o primeiro vetor é o vetor de adjacência do gráfico sem indicar pesos e o segundo vetor contém os pesos correspondentes (uma possível implementação para C ++ é: std :: pair &lt;std :: vector, std :: vector&gt;).  Assim, para uma aresta definida por um par de vértices sob os índices 2i, 2i + 1 do primeiro vetor, o peso será igual ao elemento sob o índice i do segundo vetor. <br><br>  <i>Bem, por que isso é necessário?</i> <br><br>  Bem, para o autor dessas linhas, por resolver vários problemas, isso parecia bastante útil.  Bem, do ponto de vista formal, haverá essas vantagens: <br><br><ul><li>  O vetor de adjacência, como qualquer outra estrutura "enumerativa", é compacto o suficiente, ocupa menos memória que a matriz de adjacência (para gráficos esparsos) e é relativamente fácil de implementar. </li><li>  Os vértices do gráfico, em princípio, podem ser marcados com números negativos.  De repente, essa "perversão" também é necessária. </li><li>  Os gráficos podem conter várias arestas e vários loops, com pesos diferentes (positivo, negativo e até zero).  Não há restrições aqui. </li><li>  E as costelas podem receber propriedades diferentes - mas, para isso, consulte o parágrafo 4. </li></ul><br>  No entanto, devo admitir, esse “listot” não implica acesso rápido à costela.  E aqui a matriz de adjacência associativa se apressa para ajudar, sobre a qual - abaixo. <br><br>  <b>3.2 Matriz de adjacência associativa</b> <br><br>  Portanto, se o acesso a uma borda em particular é crítico, seu peso e outras propriedades são críticos, e os requisitos de memória não permitem o uso de uma matriz de adjacência, vamos pensar em como você pode alterar o vetor de adjacência para resolver esse problema.  Portanto, a chave é a borda do gráfico, que pode ser definida como um par ordenado de números inteiros.  Como é isso?  Poderia ser uma chave em uma matriz associativa?  E se sim, por que não implementamos isso?  Vamos ter uma matriz associativa em que cada chave - um par ordenado de números inteiros - seja associada a um valor - um número inteiro ou um número real que especifique o peso da aresta.  Em C ++, é recomendável implementar essa estrutura com base no contêiner std :: map (std :: map &lt;std :: pair &lt;int, int&gt;, int&gt; ou std :: map &lt;std :: pair &lt;int, int&gt;, double&gt;) ou std :: multimap se várias arestas forem assumidas.  Bem, e aqui temos uma estrutura para armazenar gráficos, que ocupa menos memória do que estruturas "matrizes", pode definir gráficos com vários loops e arestas e mesmo sem requisitos estritos para a não-negatividade dos números de vértices (não sei quem precisa, mas ainda). <br><br><h2>  4. Estruturas de dados pelo menos “inundam”, mas algo está faltando </h2><br>  E a verdade é: ao resolver vários problemas, podemos precisar atribuir alguns atributos às bordas do gráfico e, consequentemente, armazená-los.  Se for possível reduzir inequivocamente esses recursos para números inteiros, é possível armazenar esses “gráficos com recursos adicionais” usando versões estendidas do vetor de adjacência e a matriz de adjacência associativa. <br><br>  Portanto, vamos ter um gráfico não ponderado, para cada extremidade da qual é necessário armazenar, por exemplo, 2 sinais adicionais especificados por números inteiros.  Nesse caso, é possível especificar seu vetor de adjacência como um conjunto ordenado de não "pares", mas "quartetos" de números inteiros (a [2i], a [2i + 1], a [2i + 2], a [2i + 3] .. .), onde a [2i + 2] e a [2i + 3] determinam os recursos da aresta correspondente.  Para um gráfico com pesos de arestas inteiras, a ordem é geralmente semelhante (a única diferença é que os sinais seguem o peso da aresta e são dados pelos elementos a [2i + 3] e a [2i + 4], e a aresta em si será especificada não 4, mas 5 números ordenados).  E para um gráfico com pesos de aresta não inteiros, os atributos podem ser gravados em seu componente não ponderado. <br><br>  Ao usar uma matriz de adjacência associativa para gráficos com pesos de arestas inteiras, é possível especificar não um número individual, mas uma matriz (vetor) de números que, além do peso da aresta, especifica todos os outros atributos necessários.  Ao mesmo tempo, o inconveniente para o caso de pesos não inteiros será a necessidade de especificar um caractere com um número de ponto flutuante (sim, isso é um inconveniente, mas se não houver muitos desses sinais e se você não os definir demasiado "complicado" em dobro, poderá não ser nada) .  Assim, em C ++, as matrizes de adjacência associativa estendida podem ser definidas da seguinte forma: std :: map &lt;std :: pair &lt;int, int&gt;, std :: vector&gt; ou std :: map &lt;std :: pair &lt;int, int&gt;, std :: vector, com o primeiro valor em "vetor-valor-por-chave" é o peso da aresta e, em seguida, as designações numéricas de seus recursos são localizadas. <br><br><h2>  Referências: </h2><br>  <i>Sobre gráficos e algoritmos em geral:</i> <br><br>  1. Cormen, Thomas H., Leiserson, Charles I., Rivest, Ronald L., Stein, Clifford.  Algoritmos: construção e análise, 2ª edição: Per.  do inglês  - M .: Williams Publishing House, 2011. <br>  2. Harari Frank.  Teoria dos grafos.  M .: Mir, 1973. <br>  <i>O relatório do autor sobre esses mesmos vetores e matriz associativa de adjacência:</i> <br>  3. Chernoukhov S.A.  Vetor de adjacência e matriz de adjacência associativa como formas de representação e armazenamento de gráficos / SA Chernouhov.  Vetor de adjacência e mapa de adjacência como estruturas de dados para representar um gráfico // Coleção de artigos da conferência científica e prática internacional "Problemas na implementação dos resultados de desenvolvimentos inovadores e maneiras de resolvê-los" (Saratov, 14 de setembro de 2019).  - Sterlitamak: AMI, 2019, p.  65-69 <br>  <i>Fontes úteis da Internet sobre o tópico:</i> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.prog-cpp.ru/data-graph</a> <br>  5. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ejuo.livejournal.com/4518.html</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt469967/">https://habr.com/ru/post/pt469967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt469949/index.html">No aniversário de Yuri Knorozov: estudamos o básico da escrita maia</a></li>
<li><a href="../pt469951/index.html">Controle segmentado DIY, como no iOS 13.0 e posterior</a></li>
<li><a href="../pt469955/index.html">Custdev, serviços sofisticados e a arte da apresentação: o que ensinamos aos participantes do acelerador VTB</a></li>
<li><a href="../pt469961/index.html">Confie na Microsoft (ou na criação do Security Daemon Azure IoT Edge)</a></li>
<li><a href="../pt469963/index.html">SonarQube e IntelliJ IDEA: integração correta</a></li>
<li><a href="../pt469971/index.html">Desdock de dez páginas - um modelo baseado em um livro de Scott Rogers com um exemplo de jogo da Pixonic</a></li>
<li><a href="../pt469975/index.html">Caminho de Santiago com laptop</a></li>
<li><a href="../pt469979/index.html">Registros de relatórios do segundo iOS mitap Redmadrobot</a></li>
<li><a href="../pt469981/index.html">O que há dentro do bot de bate-papo?</a></li>
<li><a href="../pt469983/index.html">Como criar uma estratégia para derrotar o envelhecimento?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>