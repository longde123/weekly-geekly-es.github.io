<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👦‍👦 ⛔️ 👩🏿‍🏭 Mega Servidor Arduino e Relógio em Tempo Real 🍿 👩🏾‍🤝‍👩🏻 🦁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, você aprenderá como o Arduino Mega Server funciona com o tempo e como criar projetos no Arduino vinculados em tempo real, independenteme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mega Servidor Arduino e Relógio em Tempo Real</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/385349/"><img src="https://habrastorage.org/files/ce4/e16/81f/ce4e1681f98841af80ec3eeef2fce455.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste artigo, você aprenderá como o Arduino Mega Server funciona com o tempo e como criar projetos no Arduino vinculados em tempo real, independentemente de terem ou não um módulo RTC "de ferro" instalado. </font><font style="vertical-align: inherit;">Todas as questões relacionadas ao trabalho em tempo real no Arduino serão discutidas em detalhes e, depois de ler este artigo, você se tornará um verdadeiro "relojoeiro".</font></font><br>
<a name="habracut"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essência da questão</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qualquer projeto mais ou menos sério no Arduino deve ter uma idéia do tempo real atual. Por exemplo, as leituras do sensor devem ter limite de tempo (caso contrário, seria impossível criar estatísticas e até gráficos elementares), o controlador deve executar determinadas ações, dependendo da hora atual do dia, fins de semana, feriados etc. Se o seu controlador não tiver idéia em tempo real, ele se transforma em uma máquina simples que só pode executar ações básicas em um programa rigidamente definido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desde o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arduino Mega Server</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como é um sistema poderoso e desenvolvido, esse estado de coisas (falta de trabalho em tempo real) não pode ser adequado para mim e para todos os outros usuários do sistema. </font><font style="vertical-align: inherit;">Portanto, a questão da integração no sistema RTC foi uma das primeiras da agenda.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relógio virtual em tempo real</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo ficaria bem, mas nem eu, nem a maioria dos usuários de AMS possuímos o mesmo módulo RTC "de ferro", por isso foi decidido fazer um "passeio a cavalo" e, como medida temporária, organizar relógios em tempo real trabalhando dentro do sistema, sem módulo físico real. </font><font style="vertical-align: inherit;">Qual foi implementado com sucesso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então, como organizar um RTC virtual, sem um módulo real. </font><font style="vertical-align: inherit;">Existe uma maravilhosa </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biblioteca do Tempo,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que faz a maior parte do trabalho de nos fornecer um tempo preciso. </font><font style="vertical-align: inherit;">Para começar a trabalhar com ele, é necessário fazer o download, descompacte-o e coloque-o no local padrão de todas as bibliotecas do ambiente Arduino, a saber, na pasta:</font></font><br>
<br>
<pre><code class="java hljs">\rduino\libraries\
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois disso, todas as possibilidades de trabalhar com o tempo que ele fornece se tornam disponíveis para nós.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como funciona</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O princípio é muito simples. A biblioteca “lança” o relógio virtual “dentro” do controlador e fornece a capacidade de sincronizá-los de várias maneiras, para escolher. Você pode escolher o método que melhor lhe convier. Como o Mega Server do Arduino é um dispositivo de rede, foi escolhida a opção de sincronizar o relógio através da rede com a hora exata dos servidores. Podem ser servidores na Internet ou servidores na rede local na qual o serviço correspondente está sendo executado. Por exemplo, na versão básica do AMS, o relógio é sincronizado com o servidor </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MajorDoMo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , e você não precisa configurar nada para isso, tudo funciona </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">imediatamente</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, para que isso funcione, você precisa conectar as bibliotecas apropriadas no início do esboço.</font></font><br>
<br>
<pre><code class="java hljs">#include &lt;SPI.h&gt;<font></font>
#include &lt;Ethernet.h&gt;<font></font>
#include &lt;EthernetUdp.h&gt;<font></font>
#include &lt;Time.h&gt; <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O arquivo Time.h é realmente uma biblioteca para trabalhar com o tempo, e o restante dos arquivos é necessário para trabalhar com a rede e para sincronizar o tempo usando o protocolo NTP (a biblioteca Ethernet também deve estar instalada no seu computador). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, você precisa especificar o endereço IP do servidor com o qual deseja sincronizar o horário</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">IPAddress <span class="hljs-title">timeServer</span><span class="hljs-params">(<span class="hljs-number">192</span>, <span class="hljs-number">168</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>)</span></span>; <span class="hljs-comment">//   MajorDoMo  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
e porta correspondente</font></font><br>
<br>
<pre><code class="java hljs">unsigned <span class="hljs-keyword">int</span> localPort = <span class="hljs-number">8888</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mas há um ponto: a porta 8888 é adequada para sincronização em uma rede local e a maioria dos servidores na Internet não responde a ela. Portanto, se você planeja sincronizar a hora com os servidores de hora exata na Internet, é melhor definir a porta 123:</font></font><br>
<br>
<pre><code class="java hljs">unsigned <span class="hljs-keyword">int</span> localPort = <span class="hljs-number">123</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
resta apenas indicar o fuso horário</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> timeZone = <span class="hljs-number">4</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
e crie um objeto EthernetUDP</font></font><br>
<br>
<pre><code class="java hljs">EthernetUDP Udp;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com isso, as operações preparatórias podem ser consideradas concluídas e você pode descrever a funcionalidade necessária para trabalhar com o tempo. </font><font style="vertical-align: inherit;">Função de inicialização:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rtcInit</span><span class="hljs-params">()</span> </span>{<font></font>
  Udp.begin(localPort);<font></font>
  Serial.println(<span class="hljs-string">"Waiting for NTP sync..."</span>);<font></font>
  setSyncProvider(getNtpTime);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui você precisa prestar atenção à função</font></font><br>
<br>
<pre><code class="java hljs">setSyncProvider(getNtpTime);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta função define a fonte de sincronização da hora (neste caso, sincronização NTP através da rede). Mas poderia ser qualquer outra fonte, por exemplo, o módulo RTC físico. O desempenho desta função leva à instalação de uma fonte de sincronização (para o futuro) e, ao mesmo tempo, à própria sincronização de tempo através dessa fonte. É no momento de executar esta função que a hora exata “aparece” em seu sistema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A própria biblioteca tem outro recurso interessante,</font></font><br>
<br>
<pre><code class="java hljs">setSyncInterval(interval);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
que permite definir o intervalo desejado entre as sincronizações (definido em segundos, a sincronização ocorre automaticamente, sem a participação de sua parte). </font></font><br>
<br>
<img src="https://habrastorage.org/files/994/655/c68/994655c686114b5c897a038f300e1e61.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora você pode usar a hora exata dentro do esboço do Arduino, por exemplo, exibir eventos no monitor serial não é fácil, mas vinculado a uma hora exata específica. </font><font style="vertical-align: inherit;">Isso é feito usando a função timeStamp ():</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">timeStamp</span><span class="hljs-params">()</span> </span>{<font></font>
  serialRTC();<font></font>
  Serial.print(<span class="hljs-string">" "</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
que é um wrapper para a função serialRTC ():</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">serialRTC</span><span class="hljs-params">()</span> </span>{<font></font>
  Serial.print(year()); <font></font>
  Serial.print(<span class="hljs-string">"-"</span>);<font></font>
  printDigits(month());<font></font>
  Serial.print(<span class="hljs-string">"-"</span>);<font></font>
  printDigits(day());<font></font>
  Serial.print(<span class="hljs-string">" "</span>);<font></font>
  printDigits(hour());<font></font>
  Serial.print(<span class="hljs-string">":"</span>);<font></font>
  printDigits(minute());<font></font>
  Serial.print(<span class="hljs-string">":"</span>);<font></font>
  printDigits(second());<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A análise do mecanismo de transmissão e exibição de tempo na interface da Web do AMS está além do escopo desta história e é digna de um artigo separado. Se houver interesse, podemos escrever uma sequela e explicar em detalhes como a “mágica” do tempo é exibida na interface da web do Arduino Mega. Servidor </font></font><br>
<br>
<img src="https://habrastorage.org/files/ca9/d1c/bec/ca9d1cbec3084d169566dbaa1cf2cf99.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na verdade, é tudo. </font><font style="vertical-align: inherit;">É assim que os relógios virtuais em tempo real foram organizados no AMS até a versão 0.12, inclusive, e você também pode organizar o trabalho com tempo preciso em seus projetos, mesmo se você não tiver um módulo físico para relógios em tempo real. </font><font style="vertical-align: inherit;">Mas este não é o fim da história, mas apenas o começo.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código completo do módulo RTC do Arduino Mega Server 0.12</font></font></b><div class="spoiler_text">/*<br>
 Modul Virtual RTC<br>
 part of Arduino Mega Server project<br>
*/<br>
<br>
// Virtual RTC<br>
<br>
IPAddress timeServer(192, 168, 2, 8);<br>
unsigned int localPort = 8888; // local port to listen for UDP packets<br>
EthernetUDP Udp;<br>
<br>
const int timeZone = 4;<br>
time_t prevDisplay = 0; // when the digital clock was displayed<br>
<br>
void rtcInit() {<br>
 Udp.begin(localPort);<br>
 Serialprint(«Waiting for NTP sync… \n»);<br>
 setSyncProvider(getNtpTime);<br>
 modulRtc = 1;<br>
}<br>
<br>
void rtcWorks() {<br>
 if (timeStatus() != timeNotSet) {<br>
 if (now() != prevDisplay) { // update the display only if time has changed<br>
 setLifer();<br>
 prevDisplay = now();<br>
 //digitalClockDisplay(); <br>
 }<br>
 }<br>
}<br>
<br>
void printDigits(int digits) {<br>
 if(digits &lt; 10) {<br>
 Serial.print('0');<br>
 }<br>
 Serial.print(digits);<br>
}<br>
<br>
void serialRTC() {<br>
 Serial.print(year()); <br>
 Serial.print("-");<br>
 printDigits(month());<br>
 Serial.print("-");<br>
 printDigits(day());<br>
 Serial.print(" ");<br>
 printDigits(hour());<br>
 Serial.print(":");<br>
 printDigits(minute());<br>
 Serial.print(":");<br>
 printDigits(second());<br>
}<br>
<br>
void timeStamp() {<br>
 serialRTC();<br>
 Serial.print(" ");<br>
}<br>
<br>
void printRTC(){<br>
 serialRTC();<br>
 Serial.println();<br>
}<br>
<br>
// NTP code<br>
<br>
const int NTP_PACKET_SIZE = 48; // NTP time is in the first 48 bytes of message<br>
byte packetBuffer[NTP_PACKET_SIZE]; //buffer to hold incoming &amp; outgoing packets<br>
<br>
#ifdef RTC_FEATURE<br>
<br>
time_t getNtpTime() {<br>
 while (Udp.parsePacket() &gt; 0); // discard any previously received packets<br>
 Serialprint(«Transmit NTP request\n»);<br>
 sendNTPpacket(timeServer);<br>
 uint32_t beginWait = millis();<br>
 while (millis() — beginWait &lt; 1500) {<br>
 int size = Udp.parsePacket();<br>
 if (size &gt;= NTP_PACKET_SIZE) {<br>
 Serialprint(«Receive NTP response\n»);<br>
 Udp.read(packetBuffer, NTP_PACKET_SIZE); // read packet into the buffer<br>
 unsigned long secsSince1900;<br>
 // convert four bytes starting at location 40 to a long integer<br>
 secsSince1900 = (unsigned long)packetBuffer[40] &lt;&lt; 24;<br>
 secsSince1900 |= (unsigned long)packetBuffer[41] &lt;&lt; 16;<br>
 secsSince1900 |= (unsigned long)packetBuffer[42] &lt;&lt; 8;<br>
 secsSince1900 |= (unsigned long)packetBuffer[43];<br>
 return secsSince1900 — 2208988800UL + timeZone * SECS_PER_HOUR;<br>
 }<br>
 }<br>
 Serialprint(«No NTP response\n»);<br>
 return 0; // return 0 if unable to get the time<br>
}<br>
<br>
// send an NTP request to the time server at the given address<br>
void sendNTPpacket(IPAddress &amp;address) {<br>
 // set all bytes in the buffer to 0<br>
 memset(packetBuffer, 0, NTP_PACKET_SIZE);<br>
 // Initialize values needed to form NTP request<br>
 // (see URL above for details on the packets)<br>
 packetBuffer[0] = 0b11100011; // LI, Version, Mode<br>
 packetBuffer[1] = 0; // Stratum, or type of clock<br>
 packetBuffer[2] = 6; // Polling Interval<br>
 packetBuffer[3] = 0xEC; // Peer Clock Precision<br>
 // 8 bytes of zero for Root Delay &amp; Root Dispersion<br>
 packetBuffer[12] = 49;<br>
 packetBuffer[13] = 0x4E;<br>
 packetBuffer[14] = 49;<br>
 packetBuffer[15] = 52;<br>
 // all NTP fields have been given values, now<br>
 // you can send a packet requesting a timestamp: <br>
 Udp.beginPacket(address, 123); //NTP requests are to port 123<br>
 Udp.write(packetBuffer, NTP_PACKET_SIZE);<br>
 Udp.endPacket();<br>
}<br>
<br>
#endif<br>
<br>
// Duration<br>
<br>
void showDuration(time_t duration) {<br>
 // prints the duration in days, hours, minutes and seconds<br>
 Serialprint(" (duration ");<br>
 if(duration &gt;= SECS_PER_DAY){<br>
 Serial.print(duration / SECS_PER_DAY);<br>
 Serialprint(" day "); <br>
 duration = duration % SECS_PER_DAY; <br>
 }<br>
 if(duration &gt;= SECS_PER_HOUR){<br>
 Serial.print(duration / SECS_PER_HOUR);<br>
 Serialprint(" hour "); <br>
 duration = duration % SECS_PER_HOUR; <br>
 }<br>
 if(duration &gt;= SECS_PER_MIN){<br>
 Serial.print(duration / SECS_PER_MIN);<br>
 Serialprint(" min "); <br>
 duration = duration % SECS_PER_MIN; <br>
 }<br>
 Serial.print(duration);<br>
 Serialprint(" sec) \n"); <br>
}<br>
<br>
void checkEvent(time_t* prevEvent) {<br>
 time_t duration = 0;<br>
 time_t timeNow = now();<br>
 <br>
 if (*prevEvent &gt; 0) {<br>
 duration = timeNow — *prevEvent;<br>
 } <br>
 if (duration &gt; 0) {<br>
 showDuration(duration);<br>
 } <br>
 *prevEvent = timeNow;<br>
}<br>
<br>
</div></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma surpresa agradável</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu não estaria ocupado integrando módulos RTC ao sistema por um longo tempo (também existem outras tarefas urgentes), mas aqui, no âmbito da cooperação tecnológica com nosso projeto, a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CHIPSTER</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> forneceu </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">equipamentos</font></a><font style="vertical-align: inherit;"> para teste e integração ao AMS, entre os quais havia módulos Ethernet baseados no chip </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W5500</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e ... o módulo de relógio em tempo real no chip </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DS3231</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que se mostrou o mais oportuno e serviu de impulso para a integração dos módulos RTC no sistema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verificou-se que a empresa CHIPSTER não apenas vende equipamentos eletrônicos, mas também desenvolve seus próprios produtos para Arduino e automação sob a marca </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geegrow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e tem grandes planos para o futuro nessa direção, em particular, ela tem um projeto para o lançamento de uma versão especializada do Arduino Mega 2560 com recursos avançados e "aprimorados" especificamente para o Arduino Mega Server. </font><font style="vertical-align: inherit;">E, se este fórum for lançado, será um evento muito interessante. </font><font style="vertical-align: inherit;">Mas voltando ao relógio em tempo real.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relógio de tempo real</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como o módulo RTC estava ao meu alcance, seria pecado não integrá-lo ao sistema. Felizmente, isso acabou sendo muito simples, graças à mesma biblioteca de tempo. Mas as primeiras coisas primeiro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para quem não sabe, existem dois tipos de módulos em tempo real - "comum" (geralmente em um chip DS1307) e "avançado" (em um chip DS3231, que eu recebi). A diferença entre os dois é que os primeiros não são muito precisos e podem "fugir" muito rapidamente e com muita força, e o segundo é um relógio de alta precisão com atendimento normalizado de não mais de dois minutos por ano, ou seja, realmente aplicável na prática. E a precisão é alcançada graças a um projeto de circuito mais complexo e compensação térmica integrada.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Porém, programaticamente, ambas as versões dos módulos são compatíveis e funcionam com a biblioteca e o código. </font><font style="vertical-align: inherit;">A diferença estará apenas na precisão. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E, é claro, uma das principais propriedades de um relógio em tempo real é a capacidade de trabalhar quando a energia é desligada, devido à bateria embutida.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conexão física</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos falar sobre como conectar fisicamente o módulo RTC ao Mega Server do Arduino ou ao seu projeto do Arduino. Devo dizer que isso é muito simples e você precisará de apenas dois resistores e alguns fios. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A conexão é trivial: você precisa encontrar quatro contatos em seu módulo - GND (terra), VCC (tensão de alimentação), SCL (sinal de relógio), SDA (dados). Outros contatos são usados ​​em casos raros e específicos e você pode ignorá-los. </font></font><br>
<br>
<img src="https://habrastorage.org/files/7ec/49a/566/7ec49a56688f40f2a824adef2f625774.jpg" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, conectamos o pino GND ao terra, o pino VCC à tensão de alimentação do controlador. Tudo é simples aqui e nenhuma pergunta deve surgir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O restante das conclusões não é muito mais complicado. </font><font style="vertical-align: inherit;">O módulo RTC se comunica com o controlador por meio da interface I2C, que possui apenas dois fios: sincronização e dados, e os controladores Arduino já possuem contatos para conectar essa interface. </font><font style="vertical-align: inherit;">O Arduino Uno é A4 (SDA) e A5 (SCL), enquanto o arduino Mega é D20 (SDA) e D21 (SCL). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A única sutileza é que os pinos SCL e SDA precisam ser "puxados" para a fonte de energia através de resistores de 4,7 kΩ. </font><font style="vertical-align: inherit;">Se você não tiver exatamente essa classificação, poderá usar resistores na faixa de 2 KOhm a 10 KOhm.</font></font><br>
<br>
<img src="https://habrastorage.org/files/490/875/26d/49087526d1544d56947ee66ed7b19150.jpg" alt="imagem"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suporte de software</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, resta apenas adicionar suporte ao módulo no código AMS ou no seu projeto. </font><font style="vertical-align: inherit;">Como eu disse, será muito simples, porque a mesma biblioteca de tempo funcionará com o módulo. </font><font style="vertical-align: inherit;">É verdade que precisaremos adicionar outra biblioteca, a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biblioteca DS1307RTC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Também o descompactamos e o colocamos na pasta da biblioteca padrão:</font></font><br>
<br>
<pre><code class="java hljs">\rduino\libraries\
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adicione as seguintes linhas ao seu código de esboço</font></font><br>
<br>
<pre><code class="java hljs">#include &lt;Wire.h&gt;<font></font>
#include &lt;DS1307RTC.h&gt;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora estamos totalmente equipados e podemos começar a escrever o código para o próprio esboço, trabalhando com o módulo físico RTC. </font><font style="vertical-align: inherit;">Em função</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rtcInit</span><span class="hljs-params">()</span> </span>{<font></font>
  Udp.begin(localPort);<font></font>
  Serial.println(<span class="hljs-string">"Waiting for NTP sync..."</span>);<font></font>
  setSyncProvider(getNtpTime);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
substituir string</font></font><br>
<br>
<pre><code class="java hljs">setSyncProvider(getNtpTime);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
no</font></font><br>
<br>
<pre><code class="java hljs">setSyncProvider(RTC.get);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
e o horário interno do Arduino Mega Server (ou do seu controlador) será sincronizado com o controlador RTC "iron", e não com os servidores na Internet ou na rede local. </font><font style="vertical-align: inherit;">Assim, chamando as funções setSyncProvider (getNtpTime) e setSyncProvider (RTC.get), você pode manipular as fontes de sincronização de tempo e sincronizar o tempo como desejar, dependendo de várias condições. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra função que você precisa conhecer é</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">if</span> (timeStatus() != timeNotSet) {<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
que permite descobrir se a hora está sincronizada e, dependendo dessa condição, executar as ações necessárias.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Momento sutil</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você precisa distinguir entre duas coisas: o tempo que passa no módulo RTC “ferro” e o tempo que passa no seu controlador. Isto não é a mesma coisa. A coisa “principal” para você é o tempo no controlador e o tempo no módulo é apenas uma fonte para sincronização. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas! como o tempo no RTC físico também está gradualmente se esgotando, ele também precisa ser ajustado pela sincronização com fontes mais precisas, por exemplo, servidores na Internet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, o algoritmo ideal deve ser este: se possível, sincronize todos os relógios com os servidores na Internet, se a rede estiver indisponível, então começaremos a sincronizar o tempo no controlador com o módulo RTC, assim que a rede aparecer, volte para a sincronização pela Internet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você estiver em condições extremas, sem acesso a nenhuma fonte de sincronização, poderá ajustar manualmente o curso do relógio de ferro de tempos em tempos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos, por exemplo, considerar a função de sincronização do relógio interno do controlador e do módulo RTC via rede:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rtcSync</span><span class="hljs-params">()</span> </span>{<font></font>
  setSyncProvider(getNtpTime);<font></font>
  Serial.println(<span class="hljs-string">"...getNtpTime..."</span>);
  <span class="hljs-keyword">if</span> (timeStatus() != timeNotSet) {<font></font>
    Serial.println(<span class="hljs-string">"...set!..."</span>);<font></font>
    time_t t = getNtpTime();<font></font>
    RTC.set(t);<font></font>
    setSyncProvider(RTC.get);<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui, obtemos o tempo exato pela rede.</font></font><br>
<br>
<pre><code class="java hljs">setSyncProvider(getNtpTime);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
se for bem-sucedido, instale-o no módulo RTC</font></font><br>
<br>
<pre><code class="java hljs">RTC.set(t);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
e, a partir deste módulo, definimos o tempo do controlador</font></font><br>
<br>
<pre><code class="java hljs">setSyncProvider(RTC.get);
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lançamento inicial</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas isso não é tudo. </font><font style="vertical-align: inherit;">Há também o problema da inicialização inicial, quando o módulo RTC está conectado apenas, mas o tempo não está definido e, portanto, é impossível sincronizar com ele. </font><font style="vertical-align: inherit;">Você precisa, de alguma forma, definir a hora certa. </font><font style="vertical-align: inherit;">Há duas maneiras de resolver esse problema no Mega Server do Arduino: você pode sincronizar o RTC físico pela rede (se houver servidores de horário exato) ou usar o utilitário Arduino Serial Commander.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para definir a hora no módulo RTC, basta ... clicar no botão. </font><font style="vertical-align: inherit;">Tudo o mais será feito por você por dois jovens chamados Arduino Mega Server e Arduino Serial Commander. </font><font style="vertical-align: inherit;">Se você não usa o AMS, mas está desenvolvendo seu próprio projeto, pode pegar o código no kit de distribuição do Arduino Mega Server (o código está disponível e totalmente gratuito) ou procurar uma solução para esse problema na Internet (existem várias soluções).</font></font><br>
<br>
<img src="https://habrastorage.org/files/df7/2b1/c4b/df72b1c4b4594bd082d9a0b8c7cdc6c6.png" alt="imagem"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versão com suporte RTC real</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Arduino Mega Server, começando na versão 0.13, suporta RTC "iron". </font><font style="vertical-align: inherit;">Você pode fazer o download da versão atual mais recente no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">site oficial do projeto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e fazer suas perguntas no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fórum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E, é claro, expresso minha gratidão à </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CHIPSTER</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pela cooperação e pelo equipamento fornecido para teste e integração ( </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">falarei</font></a><font style="vertical-align: inherit;"> sobre o módulo W5500 e a aceleração da operação da rede AMS em um dos seguintes artigos). </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adição</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Um canal do Youtube está aberto e aqui está um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vídeo promocional do</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arduino Mega Server, que demonstra como trabalhar com um sistema real.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt385349/">https://habr.com/ru/post/pt385349/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt385339/index.html">Intel introduziu o SSD mais rápido</a></li>
<li><a href="../pt385341/index.html">Produzido artificialmente em carne de laboratório estará à venda nos próximos 5 anos</a></li>
<li><a href="../pt385343/index.html">Um pouco de mágica da Apple - novo Magic Keyboard, Trackpad, Mouse e iMac</a></li>
<li><a href="../pt385345/index.html">Martelo de Thor na vida real: scanner de impressões digitais e ímãs</a></li>
<li><a href="../pt385347/index.html">Fabricante de computadores Bitcoin 21 Bitcoin lança cursos para desenvolvedores</a></li>
<li><a href="../pt385351/index.html">В НАСА отвергли проект доставки орбитальных грузов от Lockheed Martin как слишком сложный и дорогой</a></li>
<li><a href="../pt385353/index.html">Foi criado um protótipo de um módulo acelerador de micropartículas com 1,5 cm de comprimento</a></li>
<li><a href="../pt385355/index.html">Онлайн-пиратство в Австралии уменьшилось благодаря Netflix</a></li>
<li><a href="../pt385361/index.html">Windows 10 Mobile — билд 10549 доступен инсайдерам</a></li>
<li><a href="../pt385363/index.html">Vídeo do piloto automático Tesla sobre tráfego urbano</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>