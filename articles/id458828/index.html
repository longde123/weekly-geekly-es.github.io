<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😔 🤟🏻 🕹️ Mengapa, mengapa, dan kapan menggunakan ValueTask 😽 👨‍🚒 🦑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terjemahan ini muncul berkat komentar baik 0x1000000 . 
 




 NET Framework. 4 memperkenalkan ruang System.Threading.Tasks, dan dengan itu kelas Tuga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengapa, mengapa, dan kapan menggunakan ValueTask</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458828/"><p>  <sup>Terjemahan ini muncul berkat komentar baik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">0x1000000</a> .</sup> <sup><br></sup> </p><p><img src="https://habrastorage.org/webt/4t/kr/wh/4tkrwhp_br-sobqvgwwyimflsjq.jpeg" alt="gambar"></p><br><p>  NET Framework. 4 memperkenalkan ruang System.Threading.Tasks, dan dengan itu kelas Tugas.  Tipe ini dan Tugas &lt;TResult&gt; yang dihasilkannya telah menunggu lama sampai mereka dikenali oleh standar di .NET sebagai aspek kunci dari model pemrograman asinkron yang diperkenalkan pada C # 5 dengan pernyataan async / menunggu.  Pada artikel ini, saya akan berbicara tentang tipe-tipe baru ValueTask / ValueTask &lt;TResult&gt;, yang dirancang untuk meningkatkan kinerja metode asinkron dalam kasus-kasus di mana alokasi alokasi memori harus diperhitungkan. </p><a name="habracut"></a><br><h3 id="task">  Tugas </h3><br><p> Tugas bertindak dalam peran yang berbeda, tetapi yang utama adalah "janji" (janji), objek yang mewakili kemungkinan penyelesaian beberapa operasi.  Anda memulai operasi dan mendapatkan objek Tugas untuk itu, yang akan dieksekusi ketika operasi selesai, yang dapat terjadi dalam mode sinkron sebagai bagian dari inisialisasi operasi (misalnya, menerima data yang sudah ada dalam buffer), dalam mode asinkron dengan eksekusi pada saat ketika Anda mendapatkan Tugas (menerima data bukan dari buffer, tetapi sangat cepat), atau dalam mode asinkron, tetapi setelah Anda memiliki Tugas (menerima data dari sumber daya jarak jauh).  Karena operasi dapat berakhir secara tidak sinkron, Anda memblokir aliran eksekusi, menunggu hasilnya (yang sering membuat asinkron panggilan tidak berarti), atau membuat fungsi panggilan balik yang akan diaktifkan setelah operasi selesai.  Di .Net 4, pembuatan callback diimplementasikan oleh metode ContinueWith dari objek Task, yang dengan jelas menunjukkan model ini dengan menerima fungsi delegasi untuk menjalankannya setelah Task dieksekusi: </p><br><pre><code class="plaintext hljs">SomeOperationAsync().ContinueWith(task =&gt; { try { TResult result = task.Result; UseResult(result); } catch (Exception e) { HandleException(e); } });</code> </pre> <br><p>  Namun dalam .NET Framework 4.5 dan C # 5, objek Tugas dapat dengan mudah dipanggil oleh operator yang menunggu, yang membuatnya mudah untuk mendapatkan hasil dari operasi asinkron, dan kode yang dihasilkan yang dioptimalkan untuk opsi di atas akan bekerja dengan benar dalam semua kasus ketika operasi selesai dalam mode sinkron, asinkron cepat atau asinkron dengan membuat panggilan balik: </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  Tugas adalah kelas yang sangat fleksibel dan memiliki sejumlah keunggulan.  Misalnya, Anda dapat melakukan menunggu beberapa kali untuk sejumlah konsumen sekaligus.  Anda dapat meletakkannya di koleksi (kamus) untuk ditunggu-tunggu lagi di masa mendatang, untuk menggunakannya sebagai cache dari hasil panggilan tidak sinkron.  Anda dapat memblokir eksekusi sambil menunggu Tugas selesai jika perlu.  Dan Anda dapat menulis dan menerapkan berbagai operasi pada objek Task (kadang-kadang disebut "combinators"), misalnya, "when any" untuk asynchronous menunggu penyelesaian pertama beberapa Task. <br>  Tetapi fleksibilitas ini menjadi berlebihan dalam kasus yang paling umum: panggil saja operasi asinkron dan tunggu tugas selesai: </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  Di sini kita tidak perlu menunggu eksekusi beberapa kali.  Kita tidak perlu memastikan bahwa harapan itu kompetitif.  Kami tidak perlu melakukan penguncian sinkron.  Kami tidak akan menulis kombinator.  Kami hanya menunggu janji operasi asinkron diselesaikan.  Pada akhirnya, ini adalah cara kami menulis kode sinkron (misalnya, hasil TResult = SomeOperation ();), dan biasanya diterjemahkan ke dalam async / menunggu. </p><br><p>  Selain itu, Tugas memiliki kelemahan potensial, terutama ketika sejumlah besar instance dibuat, dan throughput dan kinerja tinggi adalah persyaratan utama - Tugas adalah kelas.  Ini berarti bahwa setiap operasi yang membutuhkan Tugas dipaksa untuk membuat dan menempatkan objek, dan semakin banyak objek dibuat, semakin banyak pekerjaan untuk pengumpul sampah (GC), dan pekerjaan ini menghabiskan sumber daya yang bisa kita pakai untuk sesuatu yang lebih bermanfaat. </p><br><p>  Pustaka runtime dan sistem membantu mengurangi masalah ini dalam banyak situasi.  Sebagai contoh, jika kita menulis metode seperti ini: </p><br><pre> <code class="plaintext hljs">public async Task WriteAsync(byte value) { if (_bufferedCount == _buffer.Length) { await FlushAsync(); } _buffer[_bufferedCount++] = value; }</code> </pre> <br><p>  sebagai aturan, akan ada ruang kosong yang cukup di buffer, dan operasi akan dijalankan secara serempak.  Ketika ini terjadi, tidak perlu melakukan apa pun dengan Tugas, yang harus dikembalikan, karena tidak ada nilai kembali, ini menggunakan Tugas sebagai setara dengan metode sinkron mengembalikan nilai kosong (batal).  Oleh karena itu, lingkungan dapat dengan mudah melakukan cache satu tugas non-generik dan menggunakannya lagi dan lagi sebagai hasil dari eksekusi untuk setiap metode async yang selesai secara sinkron (singleton cache ini dapat diperoleh melalui Task.CompletedTask).  Atau, misalnya, Anda menulis: </p><br><pre> <code class="plaintext hljs">public async Task&lt;bool&gt; MoveNextAsync() { if (_bufferedCount == 0) { await FillBuffer(); } return _bufferedCount &gt; 0; }</code> </pre> <br><p>  dan secara umum, perkirakan data sudah ada di buffer, jadi metode ini cukup memeriksa nilai _bufferedCount, melihat bahwa itu lebih besar dari 0, dan mengembalikan true;  dan hanya jika belum ada data dalam buffer, Anda perlu melakukan operasi asinkron.  Dan karena hanya ada dua hasil yang mungkin dari tipe Boolean (benar dan salah), hanya ada dua objek Tugas yang mungkin diperlukan untuk mewakili hasil ini, lingkungan dapat men-cache objek ini dan mengembalikannya dengan nilai yang sesuai tanpa mengalokasikan memori.  Hanya dalam hal penyelesaian asinkron, metode perlu membuat Tugas baru, karena itu harus dikembalikan sebelum hasil operasi diketahui. <br></p><p>  Lingkungan menyediakan caching untuk beberapa jenis lain, tetapi tidak realistis untuk men-cache semua jenis yang mungkin.  Sebagai contoh, metode berikut: </p><br><pre> <code class="plaintext hljs">public async Task&lt;int&gt; ReadNextByteAsync() { if (_bufferedCount == 0) { await FillBuffer(); } if (_bufferedCount == 0) { return -1; } _bufferedCount--; return _buffer[_position++]; }</code> </pre> <br><p>  juga akan sering dieksekusi secara serempak.  Tetapi tidak seperti varian dengan hasil tipe Boolean, metode ini mengembalikan Int32, yang memiliki sekitar 4 miliar nilai, dan caching semua varian Tugas &lt;int&gt; akan membutuhkan ratusan gigabytes memori.  Lingkungan menyediakan cache kecil untuk Tugas &lt;int&gt;, tetapi sekumpulan nilai yang sangat terbatas, misalnya, jika metode ini berakhir secara serempak (data sudah ada dalam buffer) dengan nilai balik 4, itu akan menjadi tugas yang di-cache, tetapi jika nilai 42 dikembalikan, Anda harus membuat yang baru Tugas &lt;int&gt;, mirip dengan memanggil Task.FromResult (42). </p><br><p>  Banyak metode pustaka mencoba untuk memuluskan ini dengan menyediakan cache mereka sendiri.  Misalnya, kelebihan dalam .NET Framework 4.5 dari metode MemoryStream.ReadAsync selalu berakhir secara sinkron, karena membaca data dari memori.  ReadAsync mengembalikan Tugas &lt;int&gt;, di mana hasil Int32 menunjukkan berapa banyak byte yang telah dibaca.  Metode ini sering digunakan dalam satu lingkaran, seringkali dengan jumlah byte yang diperlukan yang sama untuk setiap panggilan, dan seringkali kebutuhan ini terpenuhi secara penuh.  Jadi untuk panggilan berulang ke ReadAsync, masuk akal untuk mengharapkan bahwa Tugas &lt;int&gt; akan kembali secara sinkron dengan nilai yang sama seperti pada panggilan sebelumnya.  Oleh karena itu, MemoryStream membuat cache untuk satu objek yang dikembalikan dalam panggilan terakhir yang berhasil.  Dan pada panggilan berikutnya, jika hasilnya diulang, itu akan mengembalikan objek yang di-cache, dan jika tidak, buat yang baru dengan Task.FromResult, simpan ke cache dan kembalikan. </p><br><p>  Namun demikian, ada banyak kasus lain ketika operasi dilakukan secara serempak, tetapi objek &lt;TResult&gt; Tugas dipaksa untuk dibuat. </p><br><h4 id="valuetasktresult-i-sinhronnoe-vypolnenie">  ValueTask &lt;TResult&gt; dan eksekusi sinkron </h4><br><p>  Semua ini membutuhkan implementasi tipe baru di .NET Core 2.0, yang tersedia di versi .NET sebelumnya di Sistem NuGet .Threading.Tasks.Extensions: Paket ValueTask &lt;TResult&gt;. <br>  ValueTask &lt;TResult&gt; dibuat di .NET Core 2.0 sebagai struktur yang mampu membungkus baik TResult maupun Task &lt;TResult&gt;.  Ini berarti dapat dikembalikan dari metode async, dan jika metode ini dijalankan secara sinkron dan berhasil, Anda tidak perlu meletakkan objek apa pun di heap: Anda cukup menginisialisasi struktur ValueTask &lt;TResult&gt; ini dengan nilai TResult dan mengembalikannya.  Hanya dalam kasus eksekusi asinkron, objek Task &lt;TResult&gt; akan ditempatkan, dan ValueTask &lt;TResult&gt; akan membungkusnya (untuk meminimalkan ukuran struktur dan mengoptimalkan kasus eksekusi yang sukses, metode async, yang berakhir dengan pengecualian yang tidak didukung, juga akan menempatkan Tugas &lt;TResult&gt;, jadi ValueTask &lt;TResult&gt; juga hanya membungkus Tugas &lt;TResult&gt;, dan tidak akan membawa bidang tambahan untuk menyimpan Pengecualian). </p><br><p>  Berdasarkan ini, metode seperti MemoryStream.ReadAsync, tetapi mengembalikan ValueTask &lt;int&gt;, tidak boleh berurusan dengan caching, tetapi sebaliknya dapat ditulis seperti ini: </p><br><pre> <code class="plaintext hljs">public override ValueTask&lt;int&gt; ReadAsync(byte[] buffer, int offset, int count) { try { int bytesRead = Read(buffer, offset, count); return new ValueTask&lt;int&gt;(bytesRead); } catch (Exception e) { return new ValueTask&lt;int&gt;(Task.FromException&lt;int&gt;(e)); } }</code> </pre> <br><h4 id="valuetasktresult-i-asinhronnoe-vypolnenie">  ValueTask &lt;TResult&gt; dan Eksekusi Asinkron </h4><br><p>  Kemampuan untuk menulis metode async yang dapat menyelesaikan secara serempak tanpa perlu penempatan tambahan untuk hasilnya adalah kemenangan besar.  Itu sebabnya ValueTask &lt;TResult&gt; ditambahkan dalam .NET Core 2.0, dan metode baru yang mungkin digunakan dalam aplikasi yang membutuhkan kinerja sekarang diumumkan dengan kembalinya ValueTask &lt;TResult&gt; alih-alih Tugas &lt;TResult&gt;.  Misalnya, ketika kami menambahkan kelebihan ReadAsync baru dari kelas Stream ke .NET Core 2.1, agar dapat meneruskan Memori alih-alih byte [], kami mengembalikan tipe ValueTask &lt;int&gt; di dalamnya.  Dalam bentuk ini, objek Stream (di mana metode ReadAsync sangat sering dieksekusi secara serempak, seperti dalam contoh sebelumnya untuk MemoryStream) dapat digunakan dengan alokasi memori yang jauh lebih sedikit. <br></p><p>  Namun, ketika kami bekerja dengan layanan dengan bandwidth yang sangat tinggi, kami masih ingin menghindari alokasi memori sebanyak mungkin, yang berarti mengurangi dan menghilangkan alokasi memori di sepanjang rute eksekusi yang tidak sinkron juga. <br>  Dalam model penantian, untuk operasi apa pun yang menyelesaikan secara serempak, kita membutuhkan kemampuan untuk mengembalikan objek yang mewakili kemungkinan penyelesaian operasi: penelepon perlu mengarahkan kembali callback yang akan dimulai pada akhir operasi, dan ini membutuhkan objek unik di heap, yang dapat berfungsi sebagai saluran transmisi untuk operasi khusus ini.  Ini, pada saat yang sama, tidak berarti apa-apa apakah objek ini akan digunakan kembali setelah operasi selesai.  Jika objek ini dapat digunakan kembali, API dapat mengatur cache untuk satu atau lebih objek ini, dan menggunakannya untuk operasi sekuensial, dalam arti tidak menggunakan objek yang sama untuk beberapa operasi async menengah, tetapi menggunakannya untuk akses non-kompetitif. <br>  Di .NET Core 2.1, kelas ValueTask &lt;TResult&gt; telah ditingkatkan untuk mendukung pengumpulan dan penggunaan kembali yang serupa.  Alih-alih hanya membungkus TResult atau Tugas &lt;TResult&gt;, kelas yang direvisi dapat membungkus antarmuka IValueTaskSource &lt;TResult&gt; baru.  Antarmuka ini menyediakan fungsionalitas dasar yang diperlukan untuk menemani operasi asinkron dengan objek ValueTask &lt;TResult&gt; dengan cara yang sama seperti Tugas &lt;TResult&gt;: </p><br><pre> <code class="plaintext hljs">public interface IValueTaskSource&lt;out TResult&gt; { ValueTaskSourceStatus GetStatus(short token); void OnCompleted(Action&lt;object&gt; continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags); TResult GetResult(short token); }</code> </pre> <br><p>  Metode GetStatus digunakan untuk mengimplementasikan properti seperti ValueTask &lt;TResult&gt; .IsCompleted, yang mengembalikan informasi apakah operasi asinkron dilakukan atau diselesaikan, dan bagaimana ia selesai (berhasil atau tidak).  Metode OnCompleted digunakan oleh objek menunggu untuk melampirkan panggilan balik untuk melanjutkan eksekusi dari titik menunggu ketika operasi selesai.  Dan metode GetResult diperlukan untuk mendapatkan hasil operasi, jadi setelah operasi selesai, pemanggil bisa mendapatkan objek TResult atau memberikan pengecualian yang dilemparkan. </p><br><p>  Sebagian besar pengembang tidak memerlukan antarmuka ini: metode hanya mengembalikan objek ValueTask &lt;TResult&gt;, yang dapat dibuat sebagai pembungkus untuk objek yang mengimplementasikan antarmuka ini, dan metode pemanggilan akan tetap dalam kegelapan.  Antarmuka ini untuk pengembang yang perlu menghindari alokasi memori saat menggunakan API yang kritis terhadap kinerja. </p><br><p>  Ada beberapa contoh API semacam itu di .NET Core 2.1.  Metode yang paling terkenal adalah Socket. Menerima ASync dan Socket. MengirimAsync dengan kelebihan baru ditambahkan pada 2.1, misalnya </p><br><pre> <code class="plaintext hljs">public ValueTask&lt;int&gt; ReceiveAsync(Memory&lt;byte&gt; buffer, SocketFlags socketFlags, CancellationToken cancellationToken = default);</code> </pre> <br><p>  Kelebihan ini mengembalikan ValueTask &lt;int&gt;.  Jika operasi selesai secara sinkron, cukup dengan mengembalikan ValueTask &lt;int&gt; dengan nilai yang sesuai: </p><br><pre> <code class="plaintext hljs">int result = …; return new ValueTask&lt;int&gt;(result);</code> </pre> <br><p>  Saat dihentikan secara asinkron, ia dapat menggunakan objek dari kumpulan yang mengimplementasikan antarmuka: </p><br><pre> <code class="plaintext hljs">IValueTaskSource&lt;int&gt; vts = …; return new ValueTask&lt;int&gt;(vts);</code> </pre> <br><p>  Implementasi Socket mendukung satu objek seperti itu di kumpulan untuk penerimaan, dan satu untuk transmisi, karena tidak boleh ada lebih dari satu objek untuk setiap arah yang menunggu untuk dieksekusi pada satu waktu.  Kelebihan ini tidak mengalokasikan memori, bahkan dalam kasus operasi asinkron.  Perilaku ini lebih jelas terlihat di kelas NetworkStream. <br>  Misalnya, dalam .NET Core 2.1 Stream menyediakan: </p><br><pre> <code class="plaintext hljs">public virtual ValueTask&lt;int&gt; ReadAsync(Memory&lt;byte&gt; buffer, CancellationToken cancellationToken);</code> </pre> <br><p>  yang didefinisikan ulang di NetworkStream.  Metode NetworkStream.ReadAsync hanya menggunakan metode Socket.ReceiveAsync, sehingga kemenangan dalam Socket disiarkan ke NetworkStream, dan NetworkStream.ReadAsync sebenarnya tidak mengalokasikan memori juga. </p><br><h4 id="neobobschyonnyy-valuetask">  ValueTask yang dibagikan </h4><br><p>  Ketika ValueTask &lt;TResult&gt; muncul di .NET Core 2.0, itu hanya mengoptimalkan kasus eksekusi sinkron untuk mengecualikan penempatan objek Tugas &lt;TResult&gt;, jika nilai TResult sudah siap.  Ini berarti bahwa kelas ValueTask non-generik tidak diperlukan: untuk kasus eksekusi sinkron, Task singleton. CompletedTask hanya dapat dikembalikan dari metode, dan ini dilakukan oleh lingkungan secara implisit dalam metode async yang mengembalikan Task. </p><br><p>  Namun, dengan mendapatkan operasi asinkron tanpa mengalokasikan memori, penggunaan ValueTask yang dibagikan lagi menjadi relevan.  Di .NET Core 2.1, kami memperkenalkan ValueTask umum dan IValueTaskSource.  Mereka menyediakan setara langsung untuk versi generik, untuk penggunaan serupa, dengan hanya nilai pengembalian kosong. </p><br><h4 id="realizaciya-ivaluetasksourceivaluetasksourcet">  Terapkan IValueTaskSource / IValueTaskSource &lt;T&gt; </h4><br><p>  Sebagian besar pengembang seharusnya tidak mengimplementasikan antarmuka ini.  Apalagi itu tidak mudah.  Jika Anda memutuskan untuk melakukan ini, beberapa implementasi di .NET Core 2.1 dapat berfungsi sebagai titik awal, misalnya: </p><br><ul><li>  AocketableSocketAsyncEventArgs </li><li>  AsyncOperation &lt;TResult&gt; </li><li>  DefaultPipeReader </li></ul><br><p>  Untuk mempermudah ini, di .NET Core 3.0 kami berencana untuk memperkenalkan semua logika yang diperlukan yang termasuk dalam tipe ManualResetValueTaskSourceCore &lt;TResult&gt;, struktur yang dapat disematkan di objek lain yang mengimplementasikan IValueTaskSource &lt;TResult&gt; dan / atau IValueTaskSource, sehingga dapat didelegasikan ke Struktur ini adalah sebagian besar fungsi.  Anda dapat mempelajari lebih lanjut tentang ini dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/dotnet/corefx/issues/32664</a> di repositori dotnet / corefx. </p><br><h4 id="patterny-primeneniya-valuetasks">  Pola Aplikasi ValueTasks </h4><br><p>  Pada pandangan pertama, ruang lingkup ValueTask dan ValueTask &lt;TResult&gt; jauh lebih terbatas daripada Tugas dan Tugas &lt;TResult&gt;.  Ini bagus, dan bahkan diharapkan, karena cara utama untuk menggunakannya hanya menggunakan operator yang menunggu. </p><br><p>  Namun, karena mereka dapat membungkus objek yang digunakan kembali, ada batasan signifikan dalam penggunaannya dibandingkan dengan Tugas dan Tugas &lt;TResult&gt;, jika Anda menyimpang dari cara biasa menunggu yang sederhana.  Dalam kasus umum, operasi berikut tidak boleh dilakukan dengan ValueTask / ValueTask &lt;TResult&gt;: </p><br><ul><li>  <strong>Tunggu berulang ValueTask / ValueTask &lt;TResult&gt;</strong> Objek hasil mungkin sudah dibuang dan digunakan dalam operasi lain.  Sebaliknya, Tugas / Tugas &lt;TResult&gt; tidak pernah transisi dari kondisi selesai ke yang tidak lengkap, sehingga Anda dapat mengharapkannya sebanyak yang diperlukan dan mendapatkan hasil yang sama setiap kali. </li><li>  <strong>ValueTask / ValueTask menunggu paralel.</strong> Objek hasil mengharapkan pemrosesan dengan hanya satu panggilan balik dari satu konsumen pada satu waktu, dan mencoba menunggu dari aliran yang berbeda pada saat yang sama dapat dengan mudah menyebabkan balapan dan kesalahan program yang halus.  Selain itu, ini juga merupakan kasus yang lebih spesifik dari operasi "tunggu-ulang" yang tidak valid sebelumnya.  Sebagai perbandingan, Tugas / Tugas &lt;TResult&gt; menyediakan sejumlah paralel yang menunggu. </li><li>  <strong>Menggunakan .GetAwaiter (). GetResult () ketika operasi belum selesai.</strong> Implementasi IValueTaskSource / IValueTaskSource &lt;TResult&gt; tidak perlu mengunci dukungan sampai operasi selesai, dan kemungkinan besar tidak akan melakukannya, sehingga operasi seperti itu pasti akan mengarah ke balap dan mungkin tidak akan dieksekusi seperti yang diharapkan oleh metode panggilan.  Tugas / Tugas &lt;TResult&gt; memblokir utas panggilan sampai tugas selesai. </li></ul><br><p>  Jika Anda menerima ValueTask atau ValueTask &lt;TResult&gt;, tetapi Anda harus melakukan salah satu dari tiga operasi ini, Anda dapat menggunakan .AsTask (), dapatkan Tugas / Tugas &lt;TResult&gt; dan kemudian bekerja dengan objek yang diterima.  Setelah itu, Anda tidak bisa lagi menggunakan ValueTask / ValueTask itu &lt;TResult&gt;. </p><br><p>  Singkatnya, aturannya adalah ini: ketika menggunakan ValueTask / ValueTask &lt;TResult&gt; Anda harus menunggunya secara langsung (mungkin dengan .ConfigureAwait (false)) atau memanggil AsTask () dan tidak menggunakannya lagi: </p><br><pre> <code class="plaintext hljs">//   ,  ValueTask&lt;int&gt; public ValueTask&lt;int\&gt; SomeValueTaskReturningMethodAsync(); ... // GOOD int result = await SomeValueTaskReturningMethodAsync(); // GOOD int result = await SomeValueTaskReturningMethodAsync().ConfigureAwait(false); // GOOD Task&lt;int&gt; t = SomeValueTaskReturningMethodAsync().AsTask(); // WARNING ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); //       , //     // BAD: await   ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = await vt; int result2 = await vt; // BAD: await  (    ) ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); Task.Run(async () =&gt; await vt); Task.Run(async () =&gt; await vt); // BAD:  GetAwaiter().GetResult(),     ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = vt.GetAwaiter().GetResult();</code> </pre> <br><p>  Ada satu lagi pola canggih yang bisa diterapkan oleh para pemrogram, saya harap, hanya setelah pengukuran yang cermat dan mendapatkan keuntungan yang signifikan.  Kelas ValueTask / ValueTask &lt;TResult&gt; memiliki beberapa properti yang melaporkan keadaan operasi saat ini, misalnya, properti IsCompleted mengembalikan true jika operasi selesai (yaitu, tidak lagi berjalan dan selesai dengan sukses atau tidak berhasil), dan properti IsCompletedSuccessfully mengembalikan true, hanya jika berhasil diselesaikan (sambil menunggu dan menerima hasilnya, itu tidak membuang pengecualian).  Untuk utas eksekusi yang paling menuntut, di mana pengembang ingin menghindari biaya yang muncul dalam mode asinkron, properti ini dapat diperiksa sebelum operasi yang benar-benar menghancurkan objek ValueTask / ValueTask &lt;TResult&gt;, misalnya menunggu, .AsTask ().  Misalnya, dalam implementasi SocketsHttpHandler di .NET Core 2.1, kode membaca dari koneksi dan menerima ValueTask &lt;int&gt;.  Jika operasi ini dilakukan secara serempak, kami tidak perlu khawatir tentang penghentian operasi lebih awal.  Tetapi jika itu berjalan secara tidak sinkron, kita harus menghubungkan proses interupsi sehingga permintaan interupsi memutuskan koneksi.  Karena ini adalah bagian kode yang sangat menegangkan, jika pembuatan profil menunjukkan perlunya perubahan kecil berikut, ini dapat disusun seperti ini: </p><br><pre> <code class="plaintext hljs">int bytesRead; { ValueTask&lt;int&gt; readTask = _connection.ReadAsync(buffer); if (readTask.IsCompletedSuccessfully) { bytesRead = readTask.Result; } else { using (_connection.RegisterCancellation()) { bytesRead = await readTask; } } }</code> </pre> <br><h4 id="dolzhen-li-kazhdyy-novyy-metod-asinhronnogo-api-vozvraschat-valuetaskvaluetasktresult">  Haruskah setiap metode API asinkron baru mengembalikan ValueTask / ValueTask &lt;TResult&gt;? </h4><br><p>  Untuk menjawab secara singkat: tidak, secara default masih layak untuk memilih Tugas / Tugas &lt;TResult&gt;. <br>  Seperti yang disorot di atas, Tugas dan Tugas &lt;TResult&gt; lebih mudah digunakan dengan benar daripada ValueTask dan ValueTask &lt;TResult&gt;, dan selama persyaratan kinerja tidak melebihi persyaratan kepraktisan, Tugas dan Tugas &lt;TResult&gt; lebih disukai.  Selain itu, ada biaya kecil yang terkait dengan mengembalikan ValueTask &lt;TResult&gt; alih-alih Tugas &lt;TResult&gt;, yaitu, micro-benchmark menunjukkan bahwa menunggu Task &lt;TResult&gt; lebih cepat daripada menunggu ValueTask &lt;TResult&gt;.  Jadi, jika Anda menggunakan caching tugas, misalnya, metode Anda mengembalikan Tugas atau Tugas, untuk kinerja sebaiknya tetap menggunakan Tugas atau Tugas.  Objek ValueTask / ValueTask &lt;TResult&gt; menempati beberapa kata dalam memori, oleh karena itu, ketika mereka diharapkan dan bidang mereka dicadangkan di mesin negara yang memanggil metode async, mereka akan menempati lebih banyak memori di dalamnya. <br></p><p>  - ValueTask/ValueTask&lt;TResult&gt;    : )  ,        await, )        , )     ,          .   ,                /  . </p><br><h4 id="chto-dalshe-s-valuetask-i-valuetasktresult">    ValueTask  ValueTask&lt;TResult&gt;? </h4><br><p>    .NET      ,  Task/Task&lt;TResult&gt;,  ,  ValueTask/ValueTask&lt;TResult&gt;,     ,   .      –   IAsyncEnumerator&lt;T&gt;,     .NET Core 3.0. IEnumerator&lt;T&gt;   MoveNext,   bool,     IAsyncEnumerator&lt;T&gt;   MoveNextAsync.     , ,     Task,             . ,   ,       ,        (           ),        await   foreach,      ValueTask.        ,         .      C#   ,    ,     ,   . </p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458828/">https://habr.com/ru/post/id458828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458812/index.html">JVM TI: cara membuat plugin untuk mesin virtual</a></li>
<li><a href="../id458814/index.html">Meluncurkan situs untuk produk dengan permintaan yang belum terbentuk</a></li>
<li><a href="../id458818/index.html">Orang-orang sezamannya yang terkemuka</a></li>
<li><a href="../id458820/index.html">Tentang implementasi genre terkenal di platform Minecraft</a></li>
<li><a href="../id458826/index.html">Cara menyingkirkan artikel lama sehingga tumbuh tajam di organik: + 104% lalu lintas selama enam bulan</a></li>
<li><a href="../id458830/index.html">Dell Technologies Webinar: Semua Detail Tutorial Kami</a></li>
<li><a href="../id458832/index.html">Lima siswa dan tiga toko nilai kunci didistribusikan</a></li>
<li><a href="../id458834/index.html">Sisi kepribadian Paul Allen, tentang yang tidak banyak orang tahu seperti yang saya inginkan</a></li>
<li><a href="../id458836/index.html">Indeks Borsch. Pendekatan sistematis untuk menilai, membandingkan, menentukan rasio harga / kualitas</a></li>
<li><a href="../id458840/index.html">Bagaimana kami menembus Great Chinese Firewall (bagian 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>