<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåë üîÆ ‚ôüÔ∏è Perf e flamegraphs ü¶í üíå ü¶ã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O t√≥pico de melhorar o desempenho dos sistemas operacionais e encontrar gargalos est√° ganhando imensa popularidade. Neste artigo, falaremos sobre uma ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perf e flamegraphs</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/selectel/blog/437808/"><img src="https://habrastorage.org/webt/pa/ue/x8/pauex8un6--wep6-1ehqvmciieg.png"><br><br>  O t√≥pico de melhorar o desempenho dos sistemas operacionais e encontrar gargalos est√° ganhando imensa popularidade.  Neste artigo, falaremos sobre uma ferramenta para encontrar esses mesmos lugares usando o exemplo da pilha de blocos no Linux e um caso de solu√ß√£o de problemas em um host. <br><br><h2>  Exemplo 1. Teste </h2><br><h3>  Nada funciona </h3><br>  Os testes em nosso departamento s√£o sint√©ticos no hardware do produto e, posteriormente - testes de software de aplicativos.  Recebemos uma unidade Intel Optane para teste.  J√° escrevemos sobre o teste de unidades Optane <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em nosso blog</a> . <br><br>  O disco foi instalado em um servidor padr√£o criado por um tempo relativamente longo em um dos projetos em nuvem. <br><a name="habracut"></a><br>  Durante o teste, o disco n√£o se mostrou da melhor maneira: durante o teste com a profundidade da fila de 1 solicita√ß√£o por 1 fluxo, em blocos de 4Kbytes sobre ~ 70Kiops.  E isso significa que o tempo de resposta √© enorme: aproximadamente 13 microssegundos por solicita√ß√£o! <br><br>  √â estranho, porque a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">especifica√ß√£o</a> promete "Lat√™ncia - Leia 10 ¬µs" e temos 30% a mais, a diferen√ßa √© bastante significativa.  O disco foi reorganizado em outra plataforma, uma montagem mais "nova" usada em outro projeto. <br><br><h3>  Por que isso funciona? </h3><br>  √â engra√ßado, mas a unidade na nova plataforma funcionou como deveria.  Desempenho aumentado, lat√™ncia diminu√≠da, CPU por prateleira, 1 fluxo por solicita√ß√£o, blocos de 4K bytes, ~ 106Kiops a ~ 9 microssegundos por solicita√ß√£o. <br><br>  E ent√£o √© hora de <s>comparar as configura√ß√µes</s> para obter <b>desempenho</b> de <b>pernas</b> largas.  Afinal, nos perguntamos por que?  Com <b>perf,</b> voc√™ pode: <br><br><ul><li>  Fa√ßa leituras de contador de hardware: o n√∫mero de chamadas de instru√ß√µes, falhas de cache, ramifica√ß√µes previstas incorretamente etc.  (Eventos da PMU) </li><li>  Remova as informa√ß√µes dos pontos de negocia√ß√£o est√°ticos, o n√∫mero de ocorr√™ncias </li><li>  Realizar rastreamento din√¢mico </li></ul><br>  Para verifica√ß√£o, usamos a amostragem da CPU. <br><br>  A conclus√£o √© que o <b>perf</b> pode compilar todo o rastreamento de pilha de um programa em execu√ß√£o.  Naturalmente, a execu√ß√£o do <b>perf</b> apresentar√° um atraso na opera√ß√£o de todo o sistema.  Mas temos a flag <i>-F #</i> , onde <i>#</i> √© a frequ√™ncia de amostragem, medida em Hz. <br><br>  √â importante entender que quanto maior a frequ√™ncia de amostragem, maior a probabilidade de receber uma chamada para uma fun√ß√£o espec√≠fica, mas mais freios o gerador de perfil acarreta no sistema.  Quanto menor a frequ√™ncia, maior a chance de n√£o vermos parte da pilha. <br><br>  Ao escolher uma frequ√™ncia, voc√™ precisa ser guiado pelo senso comum e um truque - tente n√£o definir uma frequ√™ncia uniforme, para n√£o entrar em uma situa√ß√£o em que algum trabalho executado em um timer com essa frequ√™ncia entre nas amostras. <br><br>  Outro ponto que √© inicialmente enganador - o software deve ser compilado com o sinalizador <i>-fno-omit-frame-pointer</i> , se isso for, √© claro, poss√≠vel.  Caso contr√°rio, no rastreamento, em vez de nomes de fun√ß√µes, veremos s√≥lidos valores <i>desconhecidos</i> .  Para alguns softwares, os s√≠mbolos de depura√ß√£o v√™m como um pacote separado, por exemplo, <i>someutil-dbg</i> .  √â recomend√°vel que voc√™ os instale antes de executar o <b>perf</b> . <br><br>  Realizamos as seguintes a√ß√µes: <br><br><ul><li>  Obtido fio do git: //git.kernel.dk/fio.git, tag fio-3.9 </li><li>  Adicionada a op√ß√£o <em>-fno-omit-frame-pointer</em> ao CPPFLAGS no Makefile </li><li>  Lan√ßado <em>make -j8</em> </li></ul><br><pre><code class="bash hljs">perf record -g ~/fio/fio --name=<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> --rw=randread --bs=4k --ioengine=pvsync2 --filename=/dev/nvme0n1 --direct=1 --hipri --filesize=1G</code> </pre> <br>  A op√ß√£o -g √© necess√°ria para capturar a pilha de rastreios. <br><br>  Voc√™ pode visualizar o resultado pelo comando: <br><br><pre> <code class="bash hljs">perf report -g fractal</code> </pre> <br>  A op√ß√£o <i>-g fractal</i> √© necess√°ria para que as porcentagens que refletem o n√∫mero de amostras com esta fun√ß√£o e mostradas por <b>perf</b> sejam relativas √† fun√ß√£o de chamada, cujo n√∫mero de chamadas √© considerado 100%. <br><br>  No final da pilha de chamadas longas na plataforma "build nova", veremos: <br><br><img src="https://habrastorage.org/webt/_y/pn/jb/_ypnjb3xkf3urq140p0qssevtku.png"><br><br>  E na plataforma "build antigo": <br><br><img src="https://habrastorage.org/webt/gq/kx/ul/gqkxulpyxspbmfudoxhh7ysdv1e.png"><br><br>  √ìtimo!  Mas quero lindos desenhos de flamingo. <br><br><h3>  Constru√ß√£o de flamegramas </h3><br>  Para ser bonita, existem duas ferramentas: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Flamegraph</a> relativamente mais est√°tico </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Flamescope</a> , que permite selecionar um per√≠odo espec√≠fico de tempo das amostras coletadas.  Isso √© muito √∫til quando o c√≥digo de pesquisa carrega a CPU com rajadas curtas. </li></ul><br>  Esses utilit√°rios aceitam <b>resultado perf script&gt;</b> como entrada. <br><br>  Fa√ßa o download do <i>resultado</i> e envie-o atrav√©s de pipes para <i>svg</i> : <br><br><pre> <code class="bash hljs">FlameGraph/stackcollapse-perf.pl ./result | FlameGraph/flamegraph.pl &gt; ./result.svg</code> </pre> <br>  Abra em um navegador e desfrute de uma imagem clic√°vel. <br><br>  Voc√™ pode usar outro m√©todo: <br><br><ol><li>  Adicionar <i>resultado</i> ao flamescope / exemplo / </li><li>  Execute python ./run.py </li><li>  Passamos pelo navegador at√© a porta 5000 do host local </li></ol><br><h3>  O que vemos no final? </h3><br>  Um bom fio gasta muito tempo na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pesquisa</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/o1/zg/wy/o1zgwy-l6idzwcxniq16ndbskvo.png"></div><br>  Um fio ruim passa tempo em qualquer lugar, mas n√£o nas pesquisas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3z/er/bz/3zerbzvtrpwznzewdteyf6bexfq.png"></div><br>  √Ä primeira vista, parece que a pesquisa n√£o funciona no host antigo, mas em todos os lugares o kernel 4.15 √© do mesmo conjunto e a pesquisa √© ativada por padr√£o nos discos NVMe.  Verifique se a pesquisa est√° ativada no <b>sysfs</b> : <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># cat /sys/class/block/nvme0n1/queue/io_poll 1</span></span></code> </pre> <br>  Durante os testes, <i>as</i> chamadas <i>preadv2</i> com o sinalizador <i>RWF_HIPRI</i> s√£o <i>usadas</i> - uma condi√ß√£o necess√°ria para que a pesquisa funcione.  E, se voc√™ estudar cuidadosamente o gr√°fico de chama (ou a captura de tela anterior da sa√≠da do <b>relat√≥rio perf</b> ), poder√° encontr√°-lo, mas isso leva uma quantidade muito pequena de tempo. <br><br>  A segunda coisa que √© vis√≠vel √© a pilha de chamadas diferente para a fun√ß√£o submit_bio () e a falta de chamadas io_schedule ().  Vamos dar uma olhada na diferen√ßa dentro de submit_bio (). <br><br>  Plataforma lenta "build antigo": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/ba/ew/sdbaewdxmxq2qqy7w6xwlkmpuia.png"></div><br>  Plataforma r√°pida "fresca": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_a/d2/_w/_ad2_wholhggbeewyuoxvqdpuas.png"></div><br>  Parece que em uma plataforma lenta, a solicita√ß√£o percorre um longo caminho at√© o dispositivo, ao mesmo tempo em que <b>entra no agendador kyber</b> .  Voc√™ pode ler mais sobre agendadores de E / S em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nosso artigo</a> . <br><br>  Depois que o <b>kyber</b> foi desligado, o mesmo teste de fio mostrou uma lat√™ncia m√©dia de cerca de 10 microssegundos, exatamente como declarado na especifica√ß√£o.  √ìtimo! <br><br>  Mas de onde vem a diferen√ßa em outro microssegundo? <br><br><h3>  E se um pouco mais profundo? </h3><br>  Como j√° mencionado, o <b>perf</b> permite coletar estat√≠sticas de contadores de hardware.  Vamos tentar ver o n√∫mero de falhas de cache e instru√ß√µes por ciclo: <br><br><pre> <code class="bash hljs">perf <span class="hljs-built_in"><span class="hljs-built_in">stat</span></span> -e cycles,instructions,cache-references,cache-misses,bus-cycles /root/fio/fio --clocksource=cpu --name=<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> --bs=4k --filename=/dev/nvme0n1p4 --direct=1 --ioengine=pvsync2 --hipri --rw=randread --filesize=4G --loops=10</code> </pre> <br><img src="https://habrastorage.org/webt/ue/pc/fo/uepcfo8up5ehpvqb1ophotqjzb8.png"><br><br><img src="https://habrastorage.org/webt/p5/ln/al/p5lnalg0u05xtvc5792ghegtv34.png"><br><br>  Pode-se ver pelos resultados que uma plataforma r√°pida executa mais instru√ß√µes para o ciclo da CPU e tem uma porcentagem menor de erros de cache durante a execu√ß√£o.  Obviamente, n√£o entraremos em detalhes da opera√ß√£o de diferentes plataformas de hardware na estrutura deste artigo. <br><br><h2>  Exemplo 2. Mercearia </h2><br><h3>  Algo est√° errado </h3><br>  No trabalho de um sistema de armazenamento distribu√≠do, foi observado um aumento na carga da CPU em um dos hosts com um aumento no tr√°fego de entrada.  Hosts s√£o pares, pares e t√™m hardware e software id√™nticos. <br><br>  Vejamos a carga da CPU: <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># pidstat -p 1441734 1 Linux 3.13.0-96-generic (lol) 10/10/2018 _x86_64_ (24 CPU) 09:23:30 PM UID PID %usr %system %guest %CPU CPU Command 09:23:44 PM 0 1441734 23.00 1.00 0.00 24.00 4 ceph-osd 09:23:45 PM 0 1441734 85.00 34.00 0.00 119.00 4 ceph-osd 09:23:46 PM 0 1441734 0.00 130.00 0.00 130.00 4 ceph-osd 09:23:47 PM 0 1441734 121.00 0.00 0.00 121.00 4 ceph-osd 09:23:48 PM 0 1441734 28.00 82.00 0.00 110.00 4 ceph-osd 09:23:49 PM 0 1441734 4.00 13.00 0.00 17.00 4 ceph-osd 09:23:50 PM 0 1441734 1.00 6.00 0.00 7.00 4 ceph-osd</span></span></code> </pre> <br>  O problema surgiu √†s 09:23:46 e vemos que o processo funcionou no espa√ßo do kernel exclusivamente por todo o segundo.  Vamos ver o que estava acontecendo l√° dentro. <br><br><h3>  Por que t√£o lento? </h3><br>  Nesse caso, coletamos amostras de todo o sistema: <br><br><pre> <code class="bash hljs">perf record -a -g -- sleep 22 perf script &gt; perf.results</code> </pre> <br>  A op√ß√£o <i>-a</i> √© necess√°ria aqui para o <b>perf</b> remover tra√ßos de todas as CPUs. <br><br>  Abra <b>perf.results</b> com <b>flamescope</b> para rastrear o momento de aumento da carga da CPU. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa de calor</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ao/db/hq/aodbhqbwotkcwaq99bvmbznkbrg.png"></div><br></div></div><br>  √Ä nossa frente est√° um "mapa de calor", cujos dois eixos (X e Y) representam o tempo. <br><br>  No eixo X, o espa√ßo √© dividido em segundos e, no eixo Y, em segmentos de 20 milissegundos em X segundos. O tempo √© executado de baixo para cima e da esquerda para a direita.  Os quadrados mais brilhantes t√™m o maior n√∫mero de amostras.  Ou seja, a CPU no momento trabalhava mais ativamente. <br><br>  Na verdade, estamos interessados ‚Äã‚Äãna mancha vermelha no meio.  Selecione-o com o mouse, clique e veja o que oculta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gv/kk/ko/gvkkkomg9vl7u1ylpwx7h8pceqc.png"></div><br>  Em geral, j√° √© evidente que o problema √© a opera√ß√£o lenta <i>tcp_recvmsg</i> e <i>skb_copy_datagram_iovec</i> . <br><br>  Para maior clareza, compare com amostras de outro host em que a mesma quantidade de tr√°fego de entrada n√£o causa problemas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v6/_j/72/v6_j72zqvscfolhkaipeoyx9lg8.png"></div><br>  Com base no fato de termos a mesma quantidade de tr√°fego recebido, plataformas id√™nticas que funcionam h√° muito tempo sem parar, podemos assumir que os problemas surgiram do lado do ferro.  A fun√ß√£o <i>skb_copy_datagram_iovec</i> copia dados da estrutura do kernel para a estrutura no espa√ßo do usu√°rio para transmitir ao aplicativo.  Provavelmente h√° problemas com a mem√≥ria do host.  Ao mesmo tempo, n√£o h√° erros nos logs. <br><br>  N√≥s reiniciamos a plataforma.  Ao carregar o BIOS, vemos uma mensagem sobre uma barra de mem√≥ria quebrada.  Substitui√ß√£o, o host inicia e o problema com uma CPU sobrecarregada n√£o √© mais reproduzido. <br><br><h2>  Postscript </h2><br><h3>  Desempenho do sistema com perf </h3><br>  De um modo geral, em um sistema ocupado, a execu√ß√£o do <b>perf</b> pode apresentar um atraso no processamento de solicita√ß√µes.  O tamanho desses atrasos tamb√©m depende da carga no servidor. <br><br>  Vamos tentar encontrar esse atraso: <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># /root/fio/fio --clocksource=cpu --name=test --bs=4k --filename=/dev/nvme0n1p4 --direct=1 --ioengine=pvsync2 --hipri --rw=randread --filesize=4G --loops=1 test: (g=0): rw=randread, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=pvsync2, iodepth=1 fio-3.9-dirty Starting 1 process Jobs: 1 (f=1): [r(1)][100.0%][r=413MiB/s][r=106k IOPS][eta 00m:00s] test: (groupid=0, jobs=1): err= 0: pid=109786: Wed Dec 12 17:25:56 2018 read: IOPS=106k, BW=414MiB/s (434MB/s)(4096MiB/9903msec) clat (nsec): min=8161, max=84768, avg=9092.68, stdev=1866.73 lat (nsec): min=8195, max=92651, avg=9127.03, stdev=1867.13 ‚Ä¶ ~# perf record /root/fio/fio --clocksource=cpu --name=test --bs=4k --filename=/dev/nvme0n1p4 --direct=1 --ioengine=pvsync2 --hipri --rw=randread --filesize=4G --loops=1 test: (g=0): rw=randread, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=pvsync2, iodepth=1 fio-3.9-dirty Starting 1 process Jobs: 1 (f=1): [r(1)][100.0%][r=413MiB/s][r=106k IOPS][eta 00m:00s] test: (groupid=0, jobs=1): err= 0: pid=109839: Wed Dec 12 17:27:50 2018 read: IOPS=106k, BW=413MiB/s (433MB/s)(4096MiB/9916msec) clat (nsec): min=8259, max=55066, avg=9102.88, stdev=1903.37 lat (nsec): min=8293, max=55096, avg=9135.43, stdev=1904.01</span></span></code> </pre> <br>  A diferen√ßa n√£o √© muito percept√≠vel, apenas cerca de ~ 8 nanossegundos. <br><br>  Vamos ver o que acontece se voc√™ aumentar a carga: <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># /root/fio/fio --clocksource=cpu --name=test --numjobs=4 --bs=4k --filename=/dev/nvme0n1p4 --direct=1 --ioengine=pvsync2 --hipri --rw=randread --filesize=4G --loops=1 test: (g=0): rw=randread, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=pvsync2, iodepth=1 ... fio-3.9-dirty Starting 4 processes Jobs: 4 (f=4): [r(4)][100.0%][r=1608MiB/s][r=412k IOPS][eta 00m:00s] ~# perf record /root/fio/fio --clocksource=cpu --name=test --numjobs=4 --bs=4k --filename=/dev/nvme0n1p4 --direct=1 --ioengine=pvsync2 --hipri --rw=randread --filesize=4G --loops=1 test: (g=0): rw=randread, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=pvsync2, iodepth=1 ... fio-3.9-dirty Starting 4 processes Jobs: 4 (f=4): [r(4)][100.0%][r=1584MiB/s][r=405k IOPS][eta 00m:00s]</span></span></code> </pre> <br>  Aqui a diferen√ßa j√° est√° se tornando percept√≠vel.  Pode-se dizer que o sistema diminuiu a velocidade em menos de 1%, mas essencialmente a perda de 7Kiops em um sistema muito carregado pode levar a problemas. <br><br>  √â claro que este exemplo √© sint√©tico, no entanto, √© muito revelador. <br><br>  Vamos tentar executar outro teste sint√©tico que calcula n√∫meros primos - <i>sysbench</i> : <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># sysbench --max-time=10 --test=cpu run --num-threads=10 --cpu-max-prime=100000 ... Test execution summary: total time: 10.0140s total number of events: 3540 total time taken by event execution: 100.1248 per-request statistics: min: 28.26ms avg: 28.28ms max: 28.53ms approx. 95 percentile: 28.31ms Threads fairness: events (avg/stddev): 354.0000/0.00 execution time (avg/stddev): 10.0125/0.00 ~# perf record sysbench --max-time=10 --test=cpu run --num-threads=10 --cpu-max-prime=100000 ‚Ä¶ Test execution summary: total time: 10.0284s total number of events: 3498 total time taken by event execution: 100.2164 per-request statistics: min: 28.53ms avg: 28.65ms max: 28.89ms approx. 95 percentile: 28.67ms Threads fairness: events (avg/stddev): 349.8000/0.40 execution time (avg/stddev): 10.0216/0.01</span></span></code> </pre> <br>  Aqui voc√™ pode ver que mesmo o tempo m√≠nimo de processamento aumentou em 270 microssegundos. <br><br><h3>  Em vez de uma conclus√£o </h3><br>  <b>O Perf</b> √© uma ferramenta muito poderosa para analisar o desempenho e a depura√ß√£o do sistema.  No entanto, como em qualquer outra ferramenta, voc√™ precisa manter-se no controle e lembrar que qualquer sistema carregado sob supervis√£o rigorosa funciona pior. <br><br>  Links relacionados: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exemplos de linha √∫nica com perf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Wiki Perf</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437808/">https://habr.com/ru/post/pt437808/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437796/index.html">AlphaStar implementou a velocidade sobre-humana como um patch para erros de treinamento em simula√ß√£o?</a></li>
<li><a href="../pt437800/index.html">ScrumMas na equipe de an√°lise: antes da decolagem</a></li>
<li><a href="../pt437802/index.html">Inove a tecnologia da nuvem: nuvem catastr√≥fica</a></li>
<li><a href="../pt437804/index.html">Posso usar o Redux em um servidor?</a></li>
<li><a href="../pt437806/index.html">EcmaScript 10 - JavaScript deste ano (ES2019)</a></li>
<li><a href="../pt437810/index.html">Realidade corporativa</a></li>
<li><a href="../pt437812/index.html">Xcode 10.2, macOS Mojave 10.14.4, iOS 12.1 e outros betas</a></li>
<li><a href="../pt437814/index.html">Xcode 10.2, macOS Mojave 10.14.4, iOS 12.1 e outras vers√µes beta</a></li>
<li><a href="../pt437816/index.html">MPLS est√° em todo lugar. Como √© a infraestrutura de rede Yandex.Cloud</a></li>
<li><a href="../pt437818/index.html">Ensinamos um computador a distinguir sons: conhecendo o concurso DCASE e montando seu classificador de √°udio em 30 minutos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>