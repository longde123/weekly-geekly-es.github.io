<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìÜ üëõ üíπ De la latence Ceph √©lev√©e au patch du noyau avec eBPF / BCC ‚ù§Ô∏è üíáüèæ „äóÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Linux dispose d'un grand nombre d'outils et d'applications de d√©bogage du noyau. La plupart d'entre eux affectent n√©gativement les performances des ap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>De la latence Ceph √©lev√©e au patch du noyau avec eBPF / BCC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/selectel/blog/458592/"><img src="https://habrastorage.org/webt/-8/ok/na/-8okna9qfyroicvgoz-zenv7-si.png" alt="image"><br><br>  Linux dispose d'un grand nombre d'outils et d'applications de d√©bogage du noyau.  La plupart d'entre eux affectent n√©gativement les performances des applications et ne peuvent pas √™tre utilis√©s en production. <br><a name="habracut"></a><br>  Il y a quelques ann√©es, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un autre outil a</a> √©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©velopp√©</a> - eBPF.  Il permet de tracer le noyau et les applications utilisateur avec une faible surcharge et sans avoir besoin de reconstruire des programmes et de charger des modules tiers dans le noyau. <br><br>  Il existe d√©j√† de nombreux utilitaires d'application qui utilisent eBPF, et dans cet article, nous verrons comment √©crire notre propre utilitaire de profilage bas√© sur la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PythonBCC</a> .  L'article est bas√© sur des √©v√©nements r√©els.  Nous passerons de l'apparition du probl√®me √† sa correction pour montrer comment les utilitaires existants peuvent √™tre utilis√©s dans des situations sp√©cifiques. <br><br><h2>  Ceph est lent </h2><br>  Un nouvel h√¥te a √©t√© ajout√© au cluster Ceph.  Apr√®s avoir migr√© certaines des donn√©es vers celui-ci, nous avons remarqu√© que la vitesse de traitement des demandes d'√©criture est beaucoup plus faible que sur d'autres serveurs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4c/_r/yv/4c_ryvapivstw8l-nr7dipfvh8e.png"></div><br>  Contrairement √† d'autres plateformes, bcache et le nouveau noyau linux 4.15 ont √©t√© utilis√©s sur cet h√¥te.  Un h√¥te de cette configuration a √©t√© utilis√© ici pour la premi√®re fois.  Et √† cette √©poque, il √©tait clair que, th√©oriquement, tout pouvait √™tre √† l'origine du probl√®me. <br><br><h3>  Enqu√™te sur l'h√¥te </h3><br>  Pour commencer, voyons ce qui se passe √† l'int√©rieur du processus ceph-osd.  Pour ce faire, nous utilisons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">perf</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">flamescope</a> (plus d'informations √† ce sujet peuvent √™tre lues <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uw/gj/ox/uwgjoxekagdl-noj-wp_uy5g8q8.png"></div><br>  L'image nous indique que la fonction <strong>fdatasync () a</strong> pass√© beaucoup de temps √† envoyer une requ√™te √† la fonction <strong>generic_make_request ()</strong> .  Cela signifie que la cause des probl√®mes se situe probablement quelque part en dehors du d√©mon osd lui-m√™me.  Il peut s'agir d'un noyau ou de disques.  La sortie iostat a montr√© une latence √©lev√©e dans le traitement des demandes avec des disques bcache. <br><br>  Lors de la v√©rification de l'h√¥te, nous avons constat√© que le d√©mon systemd-udevd consomme une grande quantit√© de temps CPU - environ 20% sur plusieurs c≈ìurs.  C'est un comportement √©trange, vous devez donc en d√©couvrir la cause.  Puisque Systemd-udevd fonctionne avec les uevents, nous avons d√©cid√© de les regarder √† travers le <strong>moniteur udevadm</strong> .  Il s'av√®re qu'un grand nombre d'√©v√©nements de modification ont √©t√© g√©n√©r√©s pour chaque p√©riph√©rique de bloc du syst√®me.  Ceci est assez inhabituel, vous devrez donc voir ce qui g√©n√®re tous ces √©v√©nements. <br><br><h3>  Utilisation de la bo√Æte √† outils BCC </h3><br>  Comme nous l'avons d√©j√† d√©couvert, le noyau (et le d√©mon ceph dans l'appel syst√®me) passe beaucoup de temps dans <strong>generic_make_request ()</strong> .  Essayons de mesurer la vitesse de cette fonction.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BCC a</a> d√©j√† une grande utilit√© - <strong>funclatency</strong> .  Nous allons tracer le d√©mon par son PID avec un intervalle entre les sorties d'information de 1 seconde et afficher le r√©sultat en millisecondes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/o7/zw/rl/o7zwrly0nejoo5r7zbezws3jxmo.png"></div><br>  Habituellement, cette fonction est rapide.  Tout ce qu'elle fait, c'est envoyer la demande √† la file d'attente des pilotes de p√©riph√©rique. <br><br>  <strong>Bcache</strong> est un p√©riph√©rique complexe qui se compose en fait de trois disques: <br><br><ul><li>  p√©riph√©rique de sauvegarde (disque mis en cache), dans ce cas, il s'agit d'un disque dur lent; </li><li>  p√©riph√©rique de mise en cache (disque de mise en cache), il s'agit ici d'une section du p√©riph√©rique NVMe; </li><li>  p√©riph√©rique virtuel bcache avec lequel l'application fonctionne. </li></ul><br>  Nous savons que la transmission des demandes est lente, mais pour lequel de ces appareils?  Nous y reviendrons un peu plus tard. <br><br>  Nous savons maintenant que les √©v√©nements provoquent probablement des probl√®mes.  Trouver ce qui cause exactement leur g√©n√©ration n'est pas si simple.  Supposons que ce soit une sorte de logiciel qui s'ex√©cute p√©riodiquement.  Voyons quel <strong>type</strong> de logiciel est lanc√© sur le syst√®me √† l'aide du script <strong>execsnoop</strong> du m√™me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ensemble d'utilitaires BCC</a> .  Ex√©cutez-le et dirigez la sortie vers un fichier. <br><br>  Par exemple, comme ceci: <br><br><pre><code class="bash hljs">/usr/share/bcc/tools/execsnoop | tee ./execdump</code> </pre> <br>  Nous ne donnerons pas la sortie compl√®te d'execsnoop ici, mais une ligne d'int√©r√™t pour nous ressemblait √† ceci: <br><br><pre> <code class="bash hljs">sh 1764905 5802 0 sudo arcconf getconfig 1 AD | grep Temperature | awk -F <span class="hljs-string"><span class="hljs-string">'[:/]'</span></span> <span class="hljs-string"><span class="hljs-string">'{print $2}'</span></span> | sed <span class="hljs-string"><span class="hljs-string">'s/^ \([0-9]*\) C.*/\1/'</span></span></code> </pre><br>  La troisi√®me colonne est le PPID (PID parent) du processus.  Le processus avec le PID 5802 s'est av√©r√© √™tre l'un des fils de notre syst√®me de surveillance.  Lors de la v√©rification de la configuration du syst√®me de surveillance, des param√®tres erron√©s ont √©t√© trouv√©s.  La temp√©rature de l'adaptateur HBA a √©t√© prise une fois toutes les 30 secondes, ce qui est beaucoup plus souvent que n√©cessaire.  Apr√®s avoir modifi√© l'intervalle de v√©rification en un intervalle plus long, nous avons constat√© que le retard dans le traitement des demandes sur cet h√¥te a cess√© de se d√©marquer du reste des h√¥tes. <br><br>  Mais on ne sait toujours pas pourquoi le p√©riph√©rique bcache √©tait si lent.  Nous avons pr√©par√© une plate-forme de test avec une configuration identique et essay√© de reproduire le probl√®me en ex√©cutant fio sur bcache, en d√©marrant p√©riodiquement le d√©clencheur udevadm pour g√©n√©rer des √©v√©nements. <br><br><h3>  √âcriture d'outils bas√©s sur BCC </h3><br>  Essayons d'√©crire un utilitaire simple pour tracer et afficher les appels les plus lents √† <strong>generic_make_request ()</strong> .  Nous sommes √©galement int√©ress√©s par le nom du lecteur pour lequel cette fonction a √©t√© appel√©e. <br><br>  Le plan est simple: <br><br><ul><li>  Enregistrez <strong>kprobe</strong> dans <strong>generic_make_request ()</strong> : <br><ul><li>  Nous enregistrons le nom du disque accessible via l'argument de fonction; </li><li>  Enregistrez l'horodatage. </li></ul><br></li></ul><ul><li>  Enregistrez <strong>kretprobe</strong> pour revenir de <strong>generic_make_request ()</strong> : <br><ul><li>  Obtenez l'horodatage actuel; </li><li>  Nous recherchons l'horodatage enregistr√© et le comparons avec l'actuel; </li><li>  Si le r√©sultat est sup√©rieur √† celui sp√©cifi√©, alors nous trouvons le nom du disque enregistr√© et l'afficher sur le terminal. </li></ul><br></li></ul>  <strong>Les kprobes</strong> et les <strong>kretprobes</strong> utilisent un m√©canisme de point d'arr√™t pour changer le code de fonction √† la vol√©e.  Vous pouvez lire la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> et un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bon</a> article sur ce sujet.  Si vous regardez le code de divers utilitaires dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BCC</a> , vous remarquerez qu'ils ont une structure identique.  Donc, dans cet article, nous allons omettre l'analyse des arguments de script et passer au programme BPF lui-m√™me. <br><br>  Le texte eBPF √† l'int√©rieur du script python ressemble √† ceci: <br><br><pre> <code class="python hljs">bpf_text = ‚Äú‚Äù‚Äù <span class="hljs-comment"><span class="hljs-comment"># Here will be the bpf program code ‚Äú‚Äù‚Äù</span></span></code> </pre><br>  Pour √©changer des donn√©es entre fonctions, les programmes eBPF utilisent <a href="">des tables de hachage</a> .  Nous aussi.  Comme cl√©, nous utiliserons le PID du processus, et comme valeur nous d√©finirons la structure: <br><br><pre> <code class="python hljs">struct data_t { u64 pid; u64 ts; char comm[TASK_COMM_LEN]; u64 lat; char disk[DISK_NAME_LEN]; }; BPF_HASH(p, u64, struct data_t); BPF_PERF_OUTPUT(events);</code> </pre><br>  Nous enregistrons ici une table de hachage appel√©e <em>p</em> , avec une cl√© de type <em>u64</em> et une valeur de type <em>struct data_t</em> .  Le tableau sera disponible dans le cadre de notre programme BPF.  La macro BPF_PERF_OUTPUT enregistre une autre table appel√©e <em>√©v√©nements</em> , qui est utilis√©e pour <a href="">transf√©rer des donn√©es</a> vers l'espace utilisateur. <br><br>  Lors de la mesure des retards entre un appel de fonction et son retour, ou entre des appels √† diff√©rentes fonctions, il convient de garder √† l'esprit que les donn√©es re√ßues doivent appartenir au m√™me contexte.  En d'autres termes, vous devez vous souvenir du lancement parall√®le possible de fonctions.  Nous avons la possibilit√© de mesurer le d√©lai entre l'appel d'une fonction dans le contexte d'un processus et le retour de cette fonction dans le contexte d'un autre processus, mais cela est tr√®s probablement inutile.  Un bon exemple ici est l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilitaire de biolatence</a> , o√π un pointeur vers une <em>demande de structure</em> , qui refl√®te une seule <em>demande de</em> disque, est d√©fini comme cl√© dans la table de hachage. <br><br>  Ensuite, nous devons √©crire le code qui sera ex√©cut√© lorsque la fonction √©tudi√©e est appel√©e: <br><br><pre> <code class="python hljs">void start(struct pt_regs *ctx, struct bio *bio) { u64 pid = bpf_get_current_pid_tgid(); struct data_t data = {}; u64 ts = bpf_ktime_get_ns(); data.pid = pid; data.ts = ts; bpf_probe_read_str(&amp;data.disk, sizeof(data.disk), (void*)bio-&gt;bi_disk-&gt;disk_name); p.update(&amp;pid, &amp;data); }</code> </pre><br>  Ici, le deuxi√®me argument de la fonction appel√©e <a href="">generic_make_request ()</a> sera remplac√© comme deuxi√®me argument.  Apr√®s cela, nous obtenons le PID du processus dans lequel nous travaillons, et l'horodatage actuel en nanosecondes.  Nous √©crivons tout cela dans la <em>nouvelle structure struct data_t data</em> .  Nous obtenons le nom du disque de la structure <em>biologique</em> , qui est transmis lors de l'appel de <strong>generic_make_request ()</strong> , et l'enregistrons dans la m√™me structure de <em>donn√©es</em> .  La derni√®re √©tape consiste √† ajouter une entr√©e √† la table de hachage mentionn√©e pr√©c√©demment. <br><br>  La fonction suivante sera appel√©e au retour de <strong>generic_make_request ()</strong> : <br><br><pre> <code class="python hljs">void stop(struct pt_regs *ctx) { u64 pid = bpf_get_current_pid_tgid(); u64 ts = bpf_ktime_get_ns(); struct data_t* data = p.lookup(&amp;pid); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; data-&gt;ts &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { bpf_get_current_comm(&amp;data-&gt;comm, sizeof(data-&gt;comm)); data-&gt;lat = (ts - data-&gt;ts)/<span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data-&gt;lat &gt; MIN_US) { FACTOR data-&gt;pid &gt;&gt;= <span class="hljs-number"><span class="hljs-number">32</span></span>; events.perf_submit(ctx, data, sizeof(struct data_t)); } p.delete(&amp;pid); } }</code> </pre><br>  Cette fonction est similaire √† la pr√©c√©dente: nous reconnaissons le PID et l'horodatage du processus, mais n'allouons pas de m√©moire pour la nouvelle structure de donn√©es.  Au lieu de cela, nous recherchons dans la table de hachage une structure existante avec la cl√© == PID actuel.  Si la structure est trouv√©e, nous trouverons le nom du processus en cours et nous y ajouterons. <br><br>  Le d√©calage binaire que nous utilisons ici est n√©cessaire pour obtenir le thread GID.  c'est-√†-dire  Le PID du processus principal qui a d√©marr√© le thread dans le contexte duquel nous travaillons.  La fonction <a href="">bpf_get_current_pid_tgid () que</a> nous <a href="">appelons</a> renvoie √† la fois le GID du thread et son PID dans une valeur de 64 bits. <br><br>  Lors de la sortie vers le terminal, nous ne sommes plus int√©ress√©s par le flux, mais par le processus principal.  Apr√®s avoir compar√© le retard re√ßu avec un seuil donn√©, nous transf√©rons notre structure de <em>donn√©es</em> vers l'espace utilisateur via la table des <em>√©v√©nements</em> , puis supprimons l'enregistrement de <em>p</em> . <br><br>  Dans le script python qui chargera ce code, nous devons remplacer MIN_US et FACTOR par les seuils de retard et les unit√©s de temps, que nous passerons par les arguments: <br><br><pre> <code class="python hljs">bpf_text = bpf_text.replace(<span class="hljs-string"><span class="hljs-string">'MIN_US'</span></span>,str(min_usec)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.milliseconds: bpf_text = bpf_text.replace(<span class="hljs-string"><span class="hljs-string">'FACTOR'</span></span>,<span class="hljs-string"><span class="hljs-string">'data-&gt;lat /= 1000;'</span></span>) label = <span class="hljs-string"><span class="hljs-string">"msec"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: bpf_text = bpf_text.replace(<span class="hljs-string"><span class="hljs-string">'FACTOR'</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>) label = <span class="hljs-string"><span class="hljs-string">"usec"</span></span></code> </pre><br>  Maintenant, nous devons pr√©parer le programme BPF via la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">macro BPF</a> et enregistrer les exemples: <br><br><pre> <code class="python hljs">b = BPF(text=bpf_text) b.attach_kprobe(event=<span class="hljs-string"><span class="hljs-string">"generic_make_request"</span></span>,fn_name=<span class="hljs-string"><span class="hljs-string">"start"</span></span>) b.attach_kretprobe(event=<span class="hljs-string"><span class="hljs-string">"generic_make_request"</span></span>,fn_name=<span class="hljs-string"><span class="hljs-string">"stop"</span></span>)</code> </pre><br>  Nous devrons √©galement d√©finir <em>struct data_t</em> dans notre script, sinon nous ne pourrons rien lire: <br><br><pre> <code class="python hljs">TASK_COMM_LEN = <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-comment"><span class="hljs-comment"># linux/sched.h DISK_NAME_LEN = 32 # linux/genhd.h class Data(ct.Structure): _fields_ = [("pid", ct.c_ulonglong), ("ts", ct.c_ulonglong), ("comm", ct.c_char * TASK_COMM_LEN), ("lat", ct.c_ulonglong), ("disk",ct.c_char * DISK_NAME_LEN)]</span></span></code> </pre><br>  La derni√®re √©tape est la sortie des donn√©es vers le terminal: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cpu, data, size)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> start event = ct.cast(data, ct.POINTER(Data)).contents <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start == <span class="hljs-number"><span class="hljs-number">0</span></span>: start = event.ts time_s = (float(event.ts - start)) / <span class="hljs-number"><span class="hljs-number">1000000000</span></span> print(<span class="hljs-string"><span class="hljs-string">"%-18.9f %-16s %-6d %-1s %s %s"</span></span> % (time_s, event.comm, event.pid, event.lat, label, event.disk)) b[<span class="hljs-string"><span class="hljs-string">"events"</span></span>].open_perf_buffer(print_event) <span class="hljs-comment"><span class="hljs-comment"># format output start = 0 while 1: try: b.perf_buffer_poll() except KeyboardInterrupt: exit()</span></span></code> </pre><br>  Le script lui-m√™me est disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GItHub</a> .  Essayons de l'ex√©cuter sur une plate-forme de test o√π fio est √©crit en bcache et appelons udevadm monitor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0q/wl/yo/0qwlyofk3ynh0ksh1rcqe_9kt6w.png"></div><br>  Enfin!  Nous voyons maintenant que ce qui ressemblait √† un p√©riph√©rique bcache de freinage est en fait un appel de freinage √† <strong>generic_make_request ()</strong> sur un lecteur mis en cache. <br><br><h3>  Creusez dans le noyau </h3><br>  Qu'est-ce qui ralentit exactement lors de la transmission de la demande?  On voit que le retard intervient avant m√™me le d√©but de la comptabilisation de la demande, c'est-√†-dire  la prise en compte d'une demande sp√©cifique de statistiques compl√©mentaires (/ proc / diskstats ou iostat) n'a pas encore commenc√©.  Cela peut √™tre facilement v√©rifi√© en ex√©cutant iostat tout en reproduisant le probl√®me, ou le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">script de biolatence BCC</a> , qui est bas√© sur le d√©but et la fin de la comptabilisation des demandes.  Aucun de ces utilitaires ne pr√©sentera de probl√®mes pour les requ√™tes sur le lecteur mis en cache. <br><br>  Si nous jetons un ≈ìil √† la fonction <strong>generic_make_request ()</strong> , nous verrons que deux fonctions suppl√©mentaires sont appel√©es avant l' <strong>enregistrement de</strong> la demande.  Le premier, <strong>generic_make_request_checks ()</strong> , v√©rifie la l√©gitimit√© d'une demande de param√®tres de disque.  Le second est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blk_queue_enter ()</a> , qui a un appel int√©ressant √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wait_event_interruptible ()</a> : <br><br><pre> <code class="python hljs">ret = wait_event_interruptible(q-&gt;mq_freeze_wq, (atomic_read(&amp;q-&gt;mq_freeze_depth) == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; (preempt || !blk_queue_preempt_only(q))) || blk_queue_dying(q));</code> </pre><br>  Dans celui-ci, le noyau attend le d√©givrage de la file d'attente.  Nous mesurons le retard <strong>blk_queue_enter ()</strong> : <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># /usr/share/bcc/tools/funclatency blk_queue_enter -i 1 -m Tracing 1 functions for "blk_queue_enter"... Hit Ctrl-C to end. msecs : count distribution 0 -&gt; 1 : 341 |****************************************| msecs : count distribution 0 -&gt; 1 : 316 |****************************************| msecs : count distribution 0 -&gt; 1 : 255 |****************************************| 2 -&gt; 3 : 0 | | 4 -&gt; 7 : 0 | | 8 -&gt; 15 : 1 | |</span></span></code> </pre><br>  Il semble que nous soyons proches d'une solution.  Les fonctions utilis√©es pour ¬´figer / d√©geler¬ª la file d'attente sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blk_mq_freeze_queue</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blk_mq_unfreeze_queue</a> .  Ils sont utilis√©s lorsqu'il est n√©cessaire de modifier les param√®tres de la file d'attente de requ√™tes, qui sont potentiellement dangereux pour les requ√™tes de cette file d'attente.  Lorsque <strong>blk_mq_freeze_queue () est</strong> appel√©, la fonction <strong>blk_freeze_queue_start ()</strong> incr√©mente le <strong>compteur q-&gt; mq_freeze_depth</strong> .  Apr√®s cela, le noyau attend la vidange de la file d'attente dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blk_mq_freeze_queue_wait ()</a> . <br><br>  Le temps d'attente pour effacer cette file d'attente √©quivaut √† la latence du disque, car le noyau attend la fin de toutes les op√©rations en file d'attente.  D√®s que la file d'attente est vide, les modifications de param√®tres sont appliqu√©es.  Ensuite, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blk_mq_unfreeze_queue ()</a> est appel√©, d√©cr√©mentant le compteur <strong>freeze_depth</strong> . <br><br>  Nous en savons maintenant assez pour rectifier la situation.  La commande de d√©clenchement udevadm entra√Æne l'application de param√®tres pour le p√©riph√©rique de bloc.  Ces param√®tres sont d√©crits dans les r√®gles udev.  Nous pouvons savoir exactement quels param√®tres ¬´g√®lent¬ª la file d'attente en essayant de les modifier via sysfs ou en consultant le code source du noyau.  Nous pouvons √©galement essayer l'utilitaire de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trace</a> BCC, qui affiche la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trace de</a> la pile du noyau et de l'espace utilisateur pour le terminal pour chaque appel <strong>blk_freeze_queue</strong> , par exemple: <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># /usr/share/bcc/tools/trace blk_freeze_queue -K -U PID TID COMM FUNC 3809642 3809642 systemd-udevd blk_freeze_queue blk_freeze_queue+0x1 [kernel] elevator_switch+0x29 [kernel] elv_iosched_store+0x197 [kernel] queue_attr_store+0x5c [kernel] sysfs_kf_write+0x3c [kernel] kernfs_fop_write+0x125 [kernel] __vfs_write+0x1b [kernel] vfs_write+0xb8 [kernel] sys_write+0x55 [kernel] do_syscall_64+0x73 [kernel] entry_SYSCALL_64_after_hwframe+0x3d [kernel] __write_nocancel+0x7 [libc-2.23.so] [unknown] 3809631 3809631 systemd-udevd blk_freeze_queue blk_freeze_queue+0x1 [kernel] queue_requests_store+0xb6 [kernel] queue_attr_store+0x5c [kernel] sysfs_kf_write+0x3c [kernel] kernfs_fop_write+0x125 [kernel] __vfs_write+0x1b [kernel] vfs_write+0xb8 [kernel] sys_write+0x55 [kernel] do_syscall_64+0x73 [kernel] entry_SYSCALL_64_after_hwframe+0x3d [kernel] __write_nocancel+0x7 [libc-2.23.so] [unknown]</span></span></code> </pre><br>  Les r√®gles Udev changent assez rarement et cela se produit g√©n√©ralement sous contr√¥le.  Nous voyons donc que m√™me l'utilisation de valeurs d√©j√† d√©finies entra√Æne une augmentation du d√©lai de transmission de la demande de l'application au disque.  Bien s√ªr, g√©n√©rer des √©v√©nements udev lorsqu'il n'y a aucun changement dans la configuration du disque (par exemple, le p√©riph√©rique ne se connecte / se d√©connecte pas) n'est pas une bonne pratique.  Cependant, nous pouvons aider le noyau √† ne pas faire de travail inutile et √† ne pas geler la file d'attente des requ√™tes si cela n'est pas n√©cessaire.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trois</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">petits</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commits</a> corrigent la situation. <br><br><h2>  Conclusion </h2><br>  eBPF est un outil tr√®s flexible et puissant.  Dans l'article, nous avons examin√© un cas pratique et d√©montr√© une petite partie de ce qui est possible de faire.  Si vous √™tes int√©ress√© par le d√©veloppement des utilitaires BCC, vous devriez jeter un ≈ìil au <a href="">tutoriel officiel</a> , qui d√©crit bien les bases. <br><br>  Il existe d'autres outils de d√©bogage et de profilage int√©ressants bas√©s sur eBPF.  L'un d'eux est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bpftrace</a> , qui vous permet d'√©crire de puissants programmes √† ligne unique et petits dans un langage de type awk.  Un autre - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ebpf_exporter</a> , vous permet de collecter des m√©triques de haute r√©solution de bas niveau directement dans votre serveur prometheus, avec la possibilit√© d'obtenir une belle visualisation et m√™me des alertes √† l'avenir. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458592/">https://habr.com/ru/post/fr458592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458572/index.html">Anatoly Slyusar: ¬´La p√©riode de l'ordinateur europ√©en nous a permis de former des programmeurs syst√®me et appliqu√©s¬ª</a></li>
<li><a href="../fr458576/index.html">Gestion et localisation de texte dans une application web</a></li>
<li><a href="../fr458582/index.html">Un ing√©nieur d'Amazon a cr√©√© un dispositif de blocage de l'IA qui emp√™che les chats de sortir de la rue</a></li>
<li><a href="../fr458584/index.html">11 juillet, Webinaire Group-IB ¬´Analyse des logiciels malveillants pour les d√©butants: approches de base¬ª</a></li>
<li><a href="../fr458590/index.html">Approches architecturales dans les applications iOS</a></li>
<li><a href="../fr458594/index.html">N'oubliez pas d'augmenter les chances de r√©ponse au client en utilisant une demande r√©p√©t√©e dans l'√©quilibrage L7</a></li>
<li><a href="../fr458596/index.html">Petty Little Joy # 6: OpenAI Gym - Jouez √† des jeux et contr√¥lez des robots</a></li>
<li><a href="../fr458598/index.html">Reconnaissance des sources lumineuses sur les cartes de l'environnement</a></li>
<li><a href="../fr458600/index.html">Que sont les v√©los √©lectriques (examen de groupe en deux parties de cinq mod√®les de deux fabricants), partie 1</a></li>
<li><a href="../fr458602/index.html">Comment nous avons perc√© le grand pare-feu chinois (partie 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>