<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏚️ 🔁 📜 # Catatan. Perhatian operasi atom di ConcurrentHashMap 👨🏾‍💻 🈵 🕥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sejak dahulu kala, Java telah memiliki antarmuka Peta yang luar biasa dan implementasinya, khususnya, HashMap . Dan mulai dengan Java 5, ada juga Conc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1># Catatan. Perhatian operasi atom di ConcurrentHashMap</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/krista/blog/479778/"><img src="https://habrastorage.org/webt/n3/kl/xh/n3klxhqmcb1xqgomjbzvprnoyvo.jpeg"><br><br>  Sejak dahulu kala, Java telah memiliki antarmuka <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">Peta yang</a> luar biasa dan implementasinya, khususnya, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a> .  Dan mulai dengan Java 5, ada juga <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html">ConcurrentHashMap</a> .  Pertimbangkan dua implementasi ini, evolusi mereka dan apa yang evolusi ini dapat menyebabkan pengembang lalai. <br><br>  Peringatan: artikel ini menggunakan kutipan dari kode sumber OpenJDK 8, didistribusikan di bawah GNU General Public License versi 2. <br><a name="habracut"></a><br><h2>  Waktu Sebelum Jawa 8 </h2><br>  Mereka yang menemukan waktu tunggu yang sangat lama, pertama Java 7, dan kemudian Java 8 (tidak seperti sekarang, setiap enam bulan versi baru), ingat operasi dengan Map mana yang paling populer.  Ini adalah: <br><br><ul><li>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">V Map.put (kunci K, nilai V)</a> </li><li>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">V Map.get (kunci Objek)</a> </li></ul><br>  Jika Anda perlu memasukkan nilai dalam koleksi, kami menggunakan metode pertama, dan untuk mendapatkan nilai yang ada, gunakan yang kedua. <br><br>  Tetapi bagaimana jika inisialisasi malas diperlukan?  Kemudian kode semacam ini muncul: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrPut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String key)</span></span></span><span class="hljs-function"> </span></span>{ String result = map.get(key); <span class="hljs-comment"><span class="hljs-comment">//(1) if (result == null) { //(2) result = createValue(key); //(3) map.put(key, result); //(4) } return result; }</span></span></code> </pre> <br><ol><li>  kami mendapatkan nilai dengan kunci </li><li>  periksa apakah nilai yang diinginkan ditemukan </li><li>  jika tidak ada nilai yang ditemukan, maka buatlah </li><li>  menambah nilai koleksi dengan kunci </li></ol><br>  Ternyata sedikit merepotkan, bukan?  Selain itu, dalam kasus ketika HashMap sederhana digunakan, maka ini hanya kode yang tidak nyaman untuk dibaca, karena  dia tidak di utas.  Tetapi dalam kasus ConcurrentHashMap, fitur tambahan muncul: metode createValue (2) dapat dipanggil beberapa kali jika beberapa utas mengatur untuk memeriksa kondisi (1) sebelum salah satu dari mereka menulis nilai ke koleksi (3).  Perilaku seperti itu seringkali dapat menimbulkan konsekuensi yang tidak diinginkan. <br><br>  Sebelum Java 8, tidak ada pilihan yang elegan.  Jika Anda perlu menghindari beberapa kreasi nilai, maka Anda harus menggunakan kunci tambahan. <br>  Java 8 membuat segalanya lebih mudah.  Tampaknya ... <br><br><h2>  Java 8 mendatangi kami ... </h2><br>  Apa fitur yang paling diantisipasi yang datang kepada kami dengan Java 8?  Benar, lambda.  Dan bukan hanya llama, tetapi dukungan mereka di semua variasi API dari perpustakaan standar.  Struktur data peta belum diabaikan.  Secara khusus, muncul metode seperti: <br><br><ul><li>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">computeIfAbsent</a> </li><li>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">computeIfPresent</a> </li><li>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">forEach</a> </li><li>  dll. </li></ul><br>  Karena metode ini, dimungkinkan untuk menulis ulang kode yang diberikan sebelumnya jauh lebih sederhana: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrPut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map.computeIfAbsent(key, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::createValue); }</code> </pre><br>  Jelas bahwa tidak ada yang akan memberikan kesempatan untuk menyederhanakan kode mereka.  Selain itu, dalam kasus ConcurrentHashMap, metode <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html">computeIfAbsent</a> juga dijalankan secara atom.  Yaitu  createValue akan dipanggil tepat sekali dan hanya jika nilai yang diinginkan tidak ada. <br><br>  IDE juga tidak lewat.  Jadi IntelliJ IDEA menawarkan penggantian otomatis versi lama dengan yang baru: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ir/5r/nr/ir5rnrjz71vghcycvujmdcunyho.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/uu/ox/eyuuoxjeyqhfc8k3wxq46dlv26m.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sz/6n/br/sz6nbrvaq_-sbj2ljwxktdnxw1y.png"></div><br>  Jelas bahwa penyederhanaan kode dan petunjuk IDE mendorong pengembang untuk menggunakan API baru ini.  Akibatnya, computeIfAbsent yang sama mulai muncul di banyak tempat dalam kode. <br>  Sampai jumpa ... <br><br><h2>  Tiba-tiba! </h2><br>  Sampai saatnya tiba untuk pengujian beban berikutnya.  Dan kemudian sesuatu yang mengerikan muncul: <br><br><img src="https://habrastorage.org/webt/1i/o1/5q/1io15qqi3scznkqnzuemfbbe61g.png"><br><br>  Aplikasi bekerja pada versi Java berikut: <br><br><pre> versi openjdk "1.8.0_222"
 OpenJDK Runtime Environment (build 1.8.0_222-8u222-b10-1ubuntu1 ~ 18.04.1-b10)
 OpenJDK 64-Bit Server VM (build 25.222-b10, mode campuran)
</pre><br><br>  Bagi mereka yang tidak terbiasa dengan alat luar biasa seperti <a href="https://www.yourkit.com/features/">YourKit</a> . <br><br>  Dalam tangkapan layar, garis lebar horizontal menunjukkan pengoperasian utas aplikasi tepat waktu.  Tergantung pada keadaan aliran pada saat tertentu, strip dicat dengan warna yang sesuai: <br><br><ul><li>  kuning - alirannya diam, menunggu pekerjaan; </li><li>  hijau - utas sedang berjalan, menjalankan kode program; </li><li>  merah - utas ini diblokir oleh utas lainnya. </li></ul><br>  Artinya, ternyata hampir semua utas (dan sebenarnya ada lebih banyak dari apa yang ditampilkan dalam tangkapan layar) hampir sepanjang waktu dalam keadaan diblokir.  Dan untuk semua, kuncinya ada di computeIfAbsent dari ConcurrentHashMap!  Dan ini terlepas dari kenyataan bahwa karena spesifik dari uji beban khusus ini, tidak lebih dari 6-8 nilai dapat disimpan dalam koleksi ini.  Yaitu  hampir semua operasi di tempat tertentu secara eksklusif merupakan pembacaan nilai-nilai yang ada. <br><br>  Tapi tunggu, bagaimana?  Memang, bahkan dalam dokumentasi untuk metode pemblokiran, dikatakan hanya dalam lampiran pembaruan: <br>  + Msgstr "Jika kunci yang ditentukan belum dikaitkan dengan nilai, cobalah menghitung nilainya menggunakan fungsi pemetaan yang diberikan dan masukkan ke dalam peta ini kecuali nol.  Seluruh doa metode dilakukan secara atom, sehingga fungsi diterapkan paling banyak sekali per kunci.  Beberapa upaya memperbarui operasi pada peta ini oleh utas lain mungkin diblokir saat perhitungan sedang berlangsung, sehingga perhitungannya harus singkat dan sederhana, dan tidak boleh mencoba memperbarui pemetaan lain dari peta ini. " <br><br>  Padahal, semuanya tidak begitu.  Jika Anda melihat kode sumber metode ini, ternyata mengandung dua blok sinkronisasi yang sangat tebal: <br><br><div class="spoiler">  <b class="spoiler_title">Implementasi ConcurrentHashMap.computeIfAbsent</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeIfAbsent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(K key, Function&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> K, ? extends V&gt; mappingFunction)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || mappingFunction == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NullPointerException(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h = spread(key.hashCode()); V val = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> binCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node&lt;K,V&gt;[] tab = table;;) { Node&lt;K,V&gt; f; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, i, fh; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tab == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || (n = tab.length) == <span class="hljs-number"><span class="hljs-number">0</span></span>) tab = initTable(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((f = tabAt(tab, i = (n - <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; h)) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { Node&lt;K,V&gt; r = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReservationNode&lt;K,V&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (r) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (casTabAt(tab, i, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, r)) { binCount = <span class="hljs-number"><span class="hljs-number">1</span></span>; Node&lt;K,V&gt; node = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((val = mappingFunction.apply(key)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) node = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node&lt;K,V&gt;(h, key, val, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { setTabAt(tab, i, node); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (binCount != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> added = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (f) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tabAt(tab, i) == f) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fh &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { binCount = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node&lt;K,V&gt; e = f;; ++binCount) { K ek; V ev; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; key.equals(ek)))) { val = e.val; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Node&lt;K,V&gt; pred = e; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((e = e.next) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((val = mappingFunction.apply(key)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { added = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; pred.next = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node&lt;K,V&gt;(h, key, val, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> TreeBin) { binCount = <span class="hljs-number"><span class="hljs-number">2</span></span>; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; r, p; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((r = t.root) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; (p = r.findTreeNode(h, key, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) val = p.val; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((val = mappingFunction.apply(key)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { added = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; t.putTreeVal(h, key, val); } } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (binCount != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!added) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) addCount(<span class="hljs-number"><span class="hljs-number">1L</span></span>, binCount); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; }</code> </pre><br></div></div><br>  Dari contoh di atas, dapat dilihat bahwa hasilnya hanya dapat dibentuk pada enam titik, dan hampir semua tempat ini berada di dalam blok sinkronisasi.  Tak disangka-sangka.  Selain itu, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html">get</a> sederhana tidak mengandung sinkronisasi sama sekali: <br><br><div class="spoiler">  <b class="spoiler_title">Implementasi ConcurrentHashMap.get</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object key)</span></span></span><span class="hljs-function"> </span></span>{ Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, eh; K ek; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h = spread(key.hashCode()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((tab = table) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; (e = tabAt(tab, (n - <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; h)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((eh = e.hash) == h) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ek = e.key) == key || (ek != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; key.equals(ek))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.val; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (eh &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (p = e.find(h, key)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? p.val : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((e = e.next) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; key.equals(ek)))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.val; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre><br></div></div><br>  Jadi apa yang harus dilakukan?  Faktanya, hanya ada dua opsi: baik kembali ke kode asli, atau menggunakannya, tetapi dalam versi yang sedikit dimodifikasi: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrPut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String key)</span></span></span><span class="hljs-function"> </span></span>{ String result = map.get(key); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (result != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) ? result : map.computeIfAbsent(key, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::createValue); }</code> </pre><br><h2>  Kesimpulan </h2><br>  Secara umum, konsekuensi fatal seperti itu dari refactoring yang tampaknya dangkal ternyata sangat tak terduga.  Situasi diselamatkan hanya dengan adanya tes stres, yang berhasil mengungkapkan degradasi. <br><br>  Untungnya, versi Java yang lebih baru <a href="https://bugs.openjdk.java.net/browse/JDK-8161372">memperbaiki</a> masalah ini: <a href="https://bugs.openjdk.java.net/browse/JDK-8161372">JDK-8161372</a> . <br><br>  Jadi hati-hati, jangan percaya tip menggoda dan menulis tes.  Sangat menegangkan. <br><br>  Jawa untuk semua orang! <br><br>  <b>UPD1:</b> sebagaimana dicatat dengan benar oleh <a href="https://habr.com/ru/users/coldwind/" class="user_link">coldwind</a> , masalahnya diketahui: <a href="https://bugs.openjdk.java.net/browse/JDK-8161372">JDK-8161372</a> .  Dan, tampaknya, itu diperbaiki untuk Java 9. Tetapi pada saat publikasi artikel di Java 8, Java 11, dan bahkan Java 13, metode ini tetap tidak berubah. <br><br>  <b>UPD2:</b> <a href="https://habr.com/ru/users/vkovalchuk/" class="user_link">vkovalchuk</a> menangkap saya karena kecerobohan.  Memang, untuk Java 9 dan yang lebih baru, masalahnya diperbaiki dengan menambahkan kondisi lain dengan kembalinya hasil tanpa memblokir: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fh == h <span class="hljs-comment"><span class="hljs-comment">// check first node without acquiring lock &amp;&amp; ((fk = f.key) == key || (fk != null &amp;&amp; key.equals(fk))) &amp;&amp; (fv = f.val) != null) return fv;</span></span></code> </pre><br><br>  Awalnya, saya mengalami situasi di versi Java berikutnya: <br><br><pre> versi openjdk "1.8.0_222"
 OpenJDK Runtime Environment (build 1.8.0_222-8u222-b10-1ubuntu1 ~ 18.04.1-b10)
 OpenJDK 64-Bit Server VM (build 25.222-b10, mode campuran)
</pre><br><br>  Dan ketika saya melihat sumber-sumber versi yang lebih baru, saya dengan jujur ​​melewatkan baris-baris ini, yang membuat saya tersesat. <br><br>  Jadi demi keadilan saya mengoreksi teks utama artikel tersebut. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479778/">https://habr.com/ru/post/id479778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479762/index.html">6 kesalahan paling umum yang dibuat pengembang saat menulis HTML dan CSS</a></li>
<li><a href="../id479764/index.html">Jumlah investor swasta di Bursa Moskow melebihi 3,5 juta orang</a></li>
<li><a href="../id479768/index.html">Menginstal dan Mengkonfigurasi AlienVault SIEM (OSSIM)</a></li>
<li><a href="../id479774/index.html">Narasi melalui lingkungan atau mengapa adegan potong bukanlah obat mujarab</a></li>
<li><a href="../id479776/index.html">Perjalanan profesional: bagaimana pramugari hidup</a></li>
<li><a href="../id479780/index.html">DevOps Moscow Meetup 17/12: bergabung dengan siaran</a></li>
<li><a href="../id479790/index.html">Tiga Inkubator mengadakan kursus prototipe untuk kelompok siswa pertama</a></li>
<li><a href="../id479794/index.html">Kami menggabungkan mikrokontroler "anak-anak" dan permainan papan</a></li>
<li><a href="../id479796/index.html">Ancaman Tingkat Thanos Kingston</a></li>
<li><a href="../id479800/index.html">Saya menulis dalam C # sehingga front-end lebih mudah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>