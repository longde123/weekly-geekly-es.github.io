<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♊️ 🙅 👩🏿‍✈️ Réduisez les sauvegardes de 99,5% avec le hachage 🐈 👨🏻‍✈️ 👩🏿‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="hashget est un déduplicateur gratuit basé sur l'opéra - un utilitaire de type archiveur qui peut réduire considérablement la taille des sauvegardes, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Réduisez les sauvegardes de 99,5% avec le hachage</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454826/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hashget</a> est un <em>déduplicateur</em> gratuit basé sur l'opéra - un utilitaire de type archiveur qui peut réduire considérablement la taille des sauvegardes, ainsi qu'organiser des schémas de sauvegarde incrémentiels et différentiels et plus encore. </p><br><p>  Il s'agit d'un article de revue pour décrire les fonctionnalités.  L'utilisation de hashget lui-même (assez simple) est décrite dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">README</a> et la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation wiki</a> du projet. </p><br><h1 id="sravnenie">  Comparaison </h1><br><p>  Selon la loi du genre, je vais commencer tout de suite par l'intrigue - comparer les résultats: </p><br><div class="scrollable-table"><table><thead><tr><th>  Échantillon de données </th><th>  taille déballée </th><th>  .tar.gz </th><th>  hashget .tar.gz </th></tr></thead><tbody><tr><td>  Wordpress-5.1.1 </td><td>  43 Mo </td><td>  11 Mo (26%) </td><td>  155 Ko ( <strong>0,3%</strong> ) </td></tr><tr><td>  Noyau Linux 5.0.4 </td><td>  934 Mo </td><td>  161 Mo (20%) </td><td>  4,7 Mo ( <strong>0,5%</strong> ) </td></tr><tr><td>  Debian 9 (LAMP) LXC VM </td><td>  724 Mo </td><td>  165 Mo (23%) </td><td>  4,1 Mo ( <strong>0,5%</strong> ) </td></tr></tbody></table></div><br><h1 id="predystoriya-kakim-dolzhen-byt-idealnyy-i-effektivnyy-bekap">  Contexte de ce que devrait être une sauvegarde idéale et efficace </h1><br><p>  Chaque fois que je faisais une sauvegarde d'une machine virtuelle fraîchement créée, j'étais hantée par le sentiment que je faisais quelque chose de mal.  Pourquoi est-ce que j'obtiens une sauvegarde lourde d'un système où ma créativité inestimable inestimable est un index.html sur une seule ligne avec le texte "Hello world"? </p><a name="habracut"></a><br><p>  Pourquoi y a-t-il 16 mégaoctets / usr / sbin / mysqld dans ma sauvegarde?  Est-ce vraiment dans ce monde que j'ai l'honneur de stocker cet important fichier, et si je ne peux pas le faire, il sera perdu pour l'humanité?  Probablement pas.  Il est stocké sur des serveurs Debian très fiables (dont la fiabilité et la continuité ne peuvent être comparées à ce que je peux fournir), ainsi que dans des copies de sauvegarde (des millions d'entre eux) d'autres administrateurs.  Avons-nous vraiment besoin de créer 10 000 000 + 1ère copie de ce fichier important pour augmenter la fiabilité? </p><br><p> En général, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hashget</a> résout ce problème.  Lors de l'emballage - il crée une très petite sauvegarde.  Lors du déballage - un système complètement déballé, similaire à celui qui serait avec <code>tar -c</code> / <code>tar -x</code> .  (En d'autres termes, il s'agit d'un emballage sans perte) </p><br><h1 id="kak-rabotaet-hashget">  Comment fonctionne le hashget </h1><br><p>  Hashget a les concepts de Package et HashPackage, avec leur aide, il effectue la déduplication. </p><br><p>  <em>Paquet</em>  Un fichier (généralement une archive .deb ou .tar.gz) qui peut être téléchargé de manière fiable à partir du réseau et à partir duquel un ou plusieurs fichiers peuvent être obtenus. </p><br><p>  <em>HashPackage</em> est un petit fichier JSON représentant le package, y compris l'URL du package et la somme de hachage (sha256) des fichiers qu'il contient.  Par exemple, pour le paquet mariadb-server-core de 5 mégaoctets, la taille du hachage n'est que de 6 kilo-octets.  Un millier de fois plus petit. </p><br><p>  <em>Déduplication</em> - création d'une archive sans fichiers en double (si le dédoublonneur sait où le package d'origine peut être téléchargé, il réduit les doublons de l'archive). </p><br><h2 id="zapakovka">  Emballage </h2><br><p>  Lors de l'emballage, tous les fichiers du répertoire compressé sont affichés, leurs sommes de hachage sont prises en compte et si la somme est trouvée dans l'un des HashPackages connus, les métadonnées du fichier (nom, hachage, autorisations, etc.) sont enregistrées dans un fichier spécial .hashget-restore.json, qui sera également inclus dans l'archive. </p><br><p>  L'emballage lui-même dans le cas le plus simple ne semble pas plus compliqué que le goudron: </p><br><pre> <code class="plaintext hljs">hashget -zf /tmp/mybackup.tar.gz --pack /path/to/data</code> </pre> <br><h2 id="raspakovka">  Déballage </h2><br><p>  Le déballage se fait en deux étapes.  Tout d'abord, le déballage habituel du goudron: </p><br><pre> <code class="plaintext hljs">tar -xf mybackup.tar.gz -C /path/to/data</code> </pre> <br><p>  puis restaurez à partir du réseau: </p><br><pre> <code class="plaintext hljs">hashget -u /path/to/data</code> </pre> <br><p>  Lors de la récupération, hashget lit le fichier .hashget-restore.json, télécharge les packages nécessaires, les décompresse et extrait les fichiers nécessaires, en les définissant dans les bons chemins, avec le propriétaire / groupe / autorisations nécessaires. </p><br><h1 id="bolee-slozhnye-veschi">  Des choses plus compliquées </h1><br><p>  Ce qui est décrit ci-dessus est déjà suffisant pour ceux qui "veulent du tar, mais pour emballer ma Debian dans 4 mégaoctets".  De plus, nous examinerons des choses plus difficiles. </p><br><h2 id="indeksirovanie">  Indexation </h2><br><p>  Si un hashget n'avait pas du tout de HashPackage, il ne pourrait tout simplement pas dédupliquer quoi que ce soit. </p><br><p>  Vous pouvez également créer un HashPackage manuellement (simplement: <code>hashget --submit https://wordpress.org/wordpress-5.1.1.zip -p my</code> ), mais il existe un moyen plus pratique. </p><br><p>  Afin d'obtenir le hashpackage dont vous avez besoin, il y a une étape d' <em>indexation</em> (elle est automatiquement effectuée lorsque la commande <code>--pack</code> est <code>--pack</code> ) et une <em>heuristique</em> .  Lors de l'indexation, le hachage "alimente" chaque fichier trouvé vers toutes les heuristiques existantes qui l'intéressent.  L'heuristique peut ensuite indexer n'importe quel package pour créer un HashPackage. </p><br><p>  Par exemple, une heuristique Debian aime le fichier / var / lib / dpkg / status et détecte les paquets Debian installés, et s'ils ne sont pas indexés (HashPackage n'a pas été créé pour eux), les télécharge et les indexe.  Le résultat est un effet très agréable - hashget dédupliquera toujours efficacement les OS Debian, même s'ils ont les derniers paquets. </p><br><h2 id="fayly-podskazki-hinty">  Fichiers d'indices </h2><br><p>  Si votre réseau utilise une sorte de package propriétaire ou un package public qui n'est pas inclus dans l'heuristique de hachage, vous pouvez lui ajouter un fichier de conseil simple hashget-hint.json comme suit: </p><br><pre> <code class="plaintext hljs">{ "project": "wordpress.org", "url": "https://ru.wordpress.org/wordpress-5.1.1-ru_RU.zip" }</code> </pre> <br><p>  De plus, chaque fois que l'archive est créée, le package sera indexé (si ce n'est précédemment) et les fichiers du package seront dédupliqués à partir de l'archive.  Aucune programmation n'est nécessaire, tout peut être fait à partir de vim et enregistré dans chaque sauvegarde.  Notez que grâce à l'approche via des hachages, si certains fichiers du package sont modifiés localement (par exemple, le fichier de configuration est modifié), les fichiers modifiés seront enregistrés dans l'archive «tels quels» et ne seront pas réduits. </p><br><p>  Si certains de vos propres packages sont mis à jour périodiquement, mais que les modifications ne sont pas très importantes, vous ne pouvez suggérer que des versions majeures.  Par exemple, dans la version 1.0, ils ont fait un indice indiquant mypackage-1.0.tar.gz, et il sera complètement dédupliqué, puis ils ont publié la version 1.1, qui est légèrement différente, mais ils n'ont pas mis à jour l'indice.  Rien à craindre.  Seuls les fichiers qui correspondent (qui peuvent être restaurés) à la version 1.0 sont dédupliqués. </p><br><p>  Une heuristique qui traite un fichier d'indices est un bon exemple pour comprendre le mécanisme interne de l'heuristique.  Il ne traite que les fichiers hashget-hint.json (ou .hashget-hint.json avec un point) et ignore tout le monde.  À l'aide de ce fichier, il détermine quelle URL de package doit être indexée et hashget l'indexe (si cela n'a pas été fait auparavant) </p><br><h2 id="hashserver">  Hashver </h2><br><p>  Il serait assez long de réaliser une indexation complète lors de la création de sauvegardes.  Pour ce faire, vous devez télécharger chaque package, décompresser, indexer.  Par conséquent, hashget utilise un schéma avec un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HashServer</a> .  Si un paquet Debian est installé, s'il ne se trouve pas dans le HashPackage local, une tentative est d'abord faite pour simplement télécharger le HashPackage depuis le serveur de hachage.  Et seulement si cela ne fonctionne pas - hashget lui-même télécharge et hache le paquet (et le télécharge sur hashserver, afin que hashserver le fournisse plus tard). </p><br><p>  HashServer - un élément facultatif du schéma, non critique, est utilisé exclusivement pour accélérer et réduire la charge sur les référentiels.  Il est facilement déconnecté (avec l'option <code>--hashserver</code> sans paramètres).  De plus, vous pouvez facilement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">créer votre propre serveur de hachage</a> . </p><br><h2 id="inkrementalnye-i-differencialnye-bekapy-zaplanirovannoe-ustarevanie">  Sauvegardes incrémentielles et différentielles, obsolescence planifiée </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hashget</a> rend très simple la réalisation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sauvegardes incrémentielles et différentielles</a> .  Pourquoi ne pas indexer notre sauvegarde elle-même (avec tous nos fichiers uniques)?  Une équipe - <code>--submit</code> et vous avez terminé!  La prochaine sauvegarde créée par hashget n'inclura pas les fichiers de cette archive. </p><br><p>  Mais ce n'est pas une très bonne approche, car il peut s'avérer que lors de la récupération, nous devrons récupérer toutes les sauvegardes de hachage pour tout l'historique (si chacun a au moins un fichier unique).  Pour cela, il existe un mécanisme d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">obsolescence de sauvegarde planifiée</a> .  Lors de l'indexation, vous pouvez spécifier la date d'expiration de HashPackage - <code>--expires 2019-06-01</code> , et à cette date (à partir de 00:00), elle ne sera pas utilisée.  L'archive elle-même ne peut pas être supprimée après cette date (bien que hashget puisse facilement afficher les URL de toutes les sauvegardes que nous avons pourries / pourries en ce moment ou à n'importe quelle date). </p><br><p>  Par exemple, si vous effectuez une sauvegarde complète le 1er jour et l'indexez avec une durée de vie avant la fin du mois, nous obtiendrons un schéma de sauvegarde différentielle. </p><br><p>  Si nous indexons également de nouvelles sauvegardes, il y aura un schéma de sauvegardes incrémentielles. </p><br><p>  Contrairement aux schémas traditionnels, hashget vous permet d'utiliser plusieurs sources de base.  La sauvegarde sera réduite en raison de la réduction des fichiers des sauvegardes précédentes (le cas échéant) et des fichiers publics (ce qui peut être téléchargé). </p><br><p>  Si, pour une raison quelconque, nous ne faisons pas confiance à la fiabilité des ressources Debian ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://snapshot.debian.org/</a> ) ou si nous utilisons une autre distribution, nous pouvons simplement effectuer une sauvegarde complète avec tous les paquets une fois, puis nous y fier déjà ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">désactiver l'heuristique</a> )  Maintenant, si tous les serveurs de nos distributions se révèlent inaccessibles pour nous (dans Internet souvenir ou pendant l'apocalypse zombie), mais nos sauvegardes sont en ordre - nous pouvons récupérer à partir de n'importe quelle sauvegarde de différence courte qui ne repose que sur nos sauvegardes précédentes. </p><br><blockquote>  Hashget ne dépend que de sources de récupération fiables à votre discrétion.  Ce que vous considérez fiable - ceux-ci seront utilisés. </blockquote><br><h2 id="filepool-i-glacier">  FilePool et Glacier </h2><br><p>  Le mécanisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FilePool</a> vous permet de ne pas accéder constamment à des serveurs externes pour télécharger des packages, mais d'utiliser des packages à partir d'un répertoire local ou d'un serveur d'entreprise, par exemple: </p><br><pre> <code class="plaintext hljs">$ hashget -u . --pool /tmp/pool</code> </pre> <br><p>  ou </p><br><pre> <code class="plaintext hljs">$ hashget -u . --pool http://myhashdb.example.com/</code> </pre> <br><p>  Pour créer un pool dans un répertoire local - il suffit de créer un répertoire et d'y télécharger des fichiers, hashget lui-même trouvera ce dont il a besoin par hachage.  Pour rendre le pool accessible via HTTP, vous devez créer des liens symboliques d'une manière spéciale, cela se fait avec une seule commande ( <code>hashget-admin --build /var/www/html/hashdb/ --pool /tmp/pool</code> ).  HTTP FilePool lui-même est un fichier statique, donc tout serveur Web simple peut le servir, la charge sur le serveur est presque nulle. </p><br><p>  Grâce à FilePool, non seulement les ressources http (s) peuvent être utilisées comme ressources de base, mais aussi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par exemple</a> , Amazon Glacier. </p><br><p>  Après le téléchargement de sauvegarde sur le glacier, nous obtenons son ID de téléchargement et nous l'utilisons comme URL.  Par exemple: </p><br><pre> <code class="plaintext hljs">hashget --submit Glacier_Upload_ID --file /tmp/my-glacier-backup.tar.gz --project glacier --hashserver --expires 2019-09-01</code> </pre> <br><p>  Désormais, les nouvelles sauvegardes (différentielles) s'appuieront sur cette sauvegarde et seront plus courtes.  Après avoir déballé tar le diffback, nous pouvons voir sur quelles ressources il s'appuie: </p><br><pre> <code class="plaintext hljs">hashget --info /tmp/unpacked/ list</code> </pre> <br><p>  et utilisez simplement le script shell pour télécharger tous ces fichiers du glacier dans le pool et exécutez la récupération habituelle: hashget -u / tmp / unpacked --pool / tmp / pool </p><br><h3 id="stoit-li-ovchinka-vydelki">  Le jeu en vaut-il la chandelle </h3><br><p>  Dans le cas le plus simple, vous paierez simplement moins cher pour les sauvegardes (si vous les stockez quelque part dans le cloud pour de l'argent).  Peut-être - beaucoup, beaucoup moins. </p><br><p>  Mais ce n'est pas le seul.  La quantité va dans la qualité.  Vous pouvez l'utiliser pour obtenir une mise à niveau du schéma de sauvegarde de haute qualité.  Par exemple, puisque nos sauvegardes sont maintenant plus courtes - vous ne pouvez pas faire une sauvegarde mensuelle, mais une sauvegarde quotidienne.  Gardez-les non pas six mois, comme avant, mais 5 ans.  Auparavant, ils étaient stockés dans un stockage "froid" lent mais bon marché (Glacier), vous pouvez désormais le stocker à chaud, d'où vous pouvez toujours télécharger rapidement une sauvegarde et récupérer en quelques minutes, pas en une journée. </p><br><p>  Vous pouvez augmenter la fiabilité du stockage de sauvegarde.  Si nous les stockons maintenant dans un magasin, alors en réduisant le volume des sauvegardes - nous pouvons stocker dans 2-3 magasins et survivre en toute sécurité si l'un d'eux est endommagé. </p><br><h3 id="kak-poprobovat-i-nachat-polzovatsya">  Comment essayer et commencer à utiliser? </h3><br><p>  Nous allons à la page gitlab <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://gitlab.com/yaroslaff/hashget</a> , l'installons avec une seule commande ( <code>pip3 install hashget[plugins]</code> ) et lisons et <code>pip3 install hashget[plugins]</code> simplement le démarrage rapide.  Je pense que toutes les choses simples à faire - cela prendra 10-15 minutes.  Ensuite, vous pouvez essayer de secouer vos machines virtuelles, créer des fichiers de conseil si nécessaire, pour presser plus fort, jouer avec des pools, une base de données de hachage locale et un serveur de hachage, si cela est intéressant, et voir le lendemain quelle sera la taille de la sauvegarde incrémentielle par rapport à hier. </p><br><h3 id="restic--hashget">  Restic + HashGet </h3><br><p>  <em>(Ce chapitre a été ajouté plus tard. Merci aux commentateurs pour leurs critiques et leur motivation.)</em> </p><br><p>  Il existe un bon outil pratique pour les sauvegardes - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">restic</a> .  Il peut également effectuer la déduplication, mais uniquement au sein du référentiel, ne peut pas la déduplication externe, ce que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hashget</a> fait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">facilement</a> .  Mais en combinaison de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">restic + hashget</a> , nous parvenons à utiliser les avantages des deux approches! </p><br><p>  Préparation (déballer wordpress et indexer): </p><br><pre> <code class="plaintext hljs"># wget -q https://wordpress.org/wordpress-5.2.2.tar.gz # hashget --submit https://wordpress.org/wordpress-5.2.2.tar.gz -p my --file wordpress-5.2.2.tar.gz --hashserver # tar -xf wordpress-5.2.2.tar.gz # du -sh wordpress 46M wordpress</code> </pre> <br><p>  Ajout d'un instantané à restic via </p><br><pre> <code class="plaintext hljs"># hashget -X exclude-list --prepack wordpress --hashserver Saved: 1468 files, 1 pkgs, size: 40.5M. Download: 10.7M # restic --exclude-file exclude-list backup wordpress password is correct scan [/tmp/wp/wordpress] scanned 193 directories, 367 files in 0:02 [0:04] 100.00% 700.829 KiB / 700.829 KiB 560 / 560 items 0 errors ETA 0:00 duration: 0:04 snapshot 76b54230 saved # du -sh /tmp/restic-repo/ 2,1M /tmp/restic-repo/</code> </pre> <br><p>  À ce stade, nous avons ajouté un instantané de catalogue (40+ Mo) et la taille du référentiel n'a augmenté que de 1 Mo. </p><br><p>  La récupération se fait par deux commandes: </p><br><pre> <code class="plaintext hljs"># restic restore 76b54230 -t unpacked password is correct restoring &lt;Snapshot 76b54230 of [/tmp/wp/wordpress] at 2019-06-19 04:30:55.760618336 +0700 +07 by root@braconnier&gt; to unpacked # hashget -u unpacked/wordpress/ --hashserver Recovered 1468/1468 files 40.5M bytes (0 downloaded, 0 from pool, 10.7M cached) in 1.56s</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454826/">https://habr.com/ru/post/fr454826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454810/index.html">De l'air frais sur Mars: pliez une molécule de CO2 et obtenez de l'oxygène</a></li>
<li><a href="../fr454816/index.html">Configuration de l'ensemble php-fpm + nginx sous WSL</a></li>
<li><a href="../fr454818/index.html">Rekko Challenge - comment prendre la 2e place au concours pour la création de systèmes de recommandation</a></li>
<li><a href="../fr454820/index.html">Recherche Azure</a></li>
<li><a href="../fr454824/index.html">L'amplificateur opérationnel le plus simple sur des éléments discrets</a></li>
<li><a href="../fr454828/index.html">Création d'une image en mosaïque</a></li>
<li><a href="../fr454830/index.html">3 qualités clés pour un chef de produit réussi: Alexander Belyaev</a></li>
<li><a href="../fr454832/index.html">Pourquoi une semaine de travail de quatre jours est une mauvaise histoire</a></li>
<li><a href="../fr454834/index.html">Les termes réels de l'étude de l'impression tactile à faible motivation</a></li>
<li><a href="../fr454840/index.html">Déménagement prudent aux Pays-Bas avec sa femme et son hypothèque. Partie 2: préparer des documents et déménager</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>