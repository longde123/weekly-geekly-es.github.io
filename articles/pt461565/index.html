<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏿 🐺 🍹 Os 5 mandamentos do desenvolvedor TypeScript 🕡 ✡️ 🔓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mais e mais projetos e equipes estão usando o TypeScript. No entanto, aplicar o TypeScript e extrair o máximo dele é algo muito diferente. 


 Apresen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Os 5 mandamentos do desenvolvedor TypeScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461565/"><p><img src="https://habrastorage.org/webt/mx/7h/yr/mx7hyrh8ms-5uuolkemexd9jkvo.jpeg" alt="imagem"></p><br><p>  Mais e mais projetos e equipes estão usando o TypeScript.  No entanto, aplicar o TypeScript e extrair o máximo dele é algo muito diferente. </p><br><p>  Apresento a você uma lista de práticas recomendadas de alto nível para o uso do TypeScript que o ajudarão a tirar o máximo proveito dessa linguagem. </p><a name="habracut"></a><br><h2 id="ne-lgite">  Não minta </h2><br><p>  <strong>Tipos é um contrato.</strong>  O que isso significa?  Quando você implementa uma função, seu tipo se torna uma promessa para outros desenvolvedores (ou para você mesmo no futuro!) Que, quando chamada, essa função retornará um certo tipo de valor. </p><br><p> No exemplo a seguir, o tipo da função <code>getUser</code> garante que ele retorne um objeto que <strong>sempre</strong> tenha duas propriedades: <code>name</code> e <code>age</code> . </p><br><pre> <code class="javascript hljs">interface User { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string; age: number; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id: number</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  TypeScript é uma linguagem muito flexível.  Possui muitos compromissos projetados para facilitar a introdução do idioma.  Por exemplo, permite implementar a função <code>getUser</code> como esta: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id: number</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> User; }</code> </pre> <br><p>  Não faça isso!  Isso é falso.  Ao criar esse código, você mente para outros desenvolvedores (que usarão sua função em suas funções).  Eles esperam que o objeto retornado por <code>getUser</code> sempre tenha algum tipo de campo de <code>name</code> .  Mas ele não está lá!  Além disso, o que acontece quando seu colega escreve <code>getUser(1).name.toString()</code> ?  Você sabe muito bem que ... </p><br><p>  Aqui, é claro, a mentira parece óbvia.  No entanto, trabalhando com uma grande base de código, muitas vezes você se encontra em situações em que o valor que deseja retornar (ou passar) <em>quase</em> corresponde ao tipo esperado.  <strong>Leva tempo e esforço para encontrar a causa da incompatibilidade de tipos</strong> e você está com pressa ... então decide usar a conversão de tipos. </p><br><p>  No entanto, ao fazer isso, você está <strong>quebrando o contrato sagrado</strong> .  É SEMPRE melhor reservar um tempo e entender por que os tipos não coincidem do que usar a conversão de tipos.  É muito provável que algum bug de tempo de execução esteja oculto sob a superfície. </p><br><p>  <strong>Não minta.</strong>  <strong>Obedeça aos seus contratos.</strong> </p><br><h2 id="budte-tochny">  Seja preciso </h2><br><p>  <strong>Tipos são documentação.</strong>  Ao documentar uma função, você não deseja transmitir o máximo de informação possível? </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   function getUser(id) { /* ... */ } //     : name  age function getUser(id) { /* ... */ } //  id       id , //     : name  age. //     undefined. function getUser(id) { /* ... */ }</span></span></code> </pre> <br><p>  Qual comentário da função <code>getUser</code> você gostaria mais?  Quanto mais você souber que uma função retorna, melhor.  Por exemplo, sabendo que ele pode retornar <code>undefined</code> , você pode escrever um bloco <code>if</code> para verificar se o objeto que a função retornou está definido antes de solicitar as propriedades desse objeto. </p><br><p>  Exatamente o mesmo com os tipos: quanto mais precisamente um tipo é descrito, mais informações ele transmite. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id: number</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id: number</span></span></span><span class="hljs-function">): '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">standard</span></span></span><span class="hljs-function">' | '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">premium</span></span></span><span class="hljs-function">' | '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">admin</span></span></span><span class="hljs-function">' </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  A segunda versão da função <code>getUserType</code> muito mais informativa e, portanto, o chamador está em uma situação muito mais conveniente.  É mais fácil processar o valor se você <strong>provavelmente</strong> sabe (contratos, lembra?) Que será uma das três linhas especificadas, e não apenas uma linha.  Para começar com o que você tem certeza - um valor não pode ser uma sequência vazia. </p><br><p>  Vamos considerar um exemplo mais real.  O tipo <code>State</code> descreve o estado do componente que solicita alguns dados do back-end.  Esse tipo é preciso? </p><br><pre> <code class="javascript hljs">interface State { <span class="hljs-attr"><span class="hljs-attr">isLoading</span></span>: boolean; data?: string[]; errorMessage?: string; }</code> </pre> <br><p>  Um cliente que usa esse tipo deve manipular uma combinação improvável de valores de propriedade do estado.  Por exemplo, uma situação é impossível quando as propriedades <code>data</code> e <code>errorMessage</code> são definidas simultaneamente: uma solicitação de dados pode ter êxito ou falhar. </p><br><p>  Podemos tornar o tipo muito mais preciso com a ajuda de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tipos de união discriminados</a> : </p><br><pre> <code class="javascript hljs">type State = | { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'loading'</span></span> } | { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'successful'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: string[] } | { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'failed'</span></span>, <span class="hljs-attr"><span class="hljs-attr">errorMessage</span></span>: string };</code> </pre> <br><p>  Agora, o cliente que usa esse tipo tem muito mais informações: ele não precisa mais processar combinações incorretas de propriedades. </p><br><p>  <strong>Seja preciso.</strong>  <strong>Passe o máximo de informações possível sobre seus tipos.</strong> </p><br><h2 id="nachinayte-snbsptipov">  Comece com tipos </h2><br><p>  Como os tipos são contrato e documentação, eles são ótimos para <strong>projetar</strong> suas funções (ou métodos). </p><br><p>  Existem muitos artigos na Internet que aconselham os programadores <strong>a pensar antes de escrever código</strong> .  Eu compartilho totalmente essa abordagem.  A tentação de pular diretamente para o código é grande, mas isso geralmente leva a más decisões.  Um pouco de tempo gasto pensando na implementação sempre compensa generosamente. </p><br><p>  Os tipos são extremamente úteis nesse processo.  <em>Pensar</em> leva à criação de assinaturas de tipos de funções relacionadas à solução do seu problema.  E isso é ótimo, porque você se concentra no que suas funções fazem, em vez de pensar em <em>como</em> elas o fazem. </p><br><p>  O React JS tem o conceito de um Higher Order Components (HOC).  Essas são funções que estendem o componente especificado de alguma forma.  Por exemplo, você pode criar um componente de ordem superior com o <code>withLoadingIndicator</code> que adiciona um indicador de carregamento a um componente existente. </p><br><p>  Vamos escrever uma assinatura de tipo para esta função.  A função aceita uma entrada de componente e retorna um componente também.  Para representar um componente, podemos usar o tipo React <code>ComponentType</code> . </p><br><p>  <code>ComponentType</code> é um tipo genérico que é parametrizado pelo tipo de propriedades do componente.  <code>withLoadingIndicator</code> aceita um componente e retorna um novo componente que exibe o componente original ou o indicador de carregamento.  A decisão sobre o que exibir é feita com base no valor da nova propriedade lógica - <code>isLoading</code> .  Portanto, o componente retornado precisa das mesmas propriedades que o original, apenas a nova propriedade <code>isLoading</code> é adicionada. </p><br><p>  Vamos finalizar o tipo.  <code>withLoadingIndicator</code> aceita um componente do tipo <code>ComponentType&lt;P&gt;</code> , em que <code>P</code> indica o tipo de propriedade.  <code>withLoadingIndicator</code> retorna um componente com propriedades avançadas do tipo <code>P &amp; { isLoading: boolean }</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> withLoadingIndicator = &lt;P&gt;(Component: ComponentType&lt;P&gt;) : ComponentType&lt;P &amp; { isLoading: boolean }&gt; =&gt; ({ isLoading, ...props }) =&gt; { /* ... */ }</code> </pre> <br><p>  Ao lidar com os tipos de funções, fomos forçados a pensar sobre o que estará em sua entrada e o que estará em sua saída.  Em outras palavras, tivemos que <em>projetar uma função</em> .  Escrever sua implementação agora é fácil. </p><br><p>  <strong>Comece com tipos.</strong>  <strong>Deixe os tipos forçarem você a projetar primeiro e só então escrever a implementação.</strong> </p><br><h2 id="primite-strogost">  Tome rigor </h2><br><p>  Os três primeiros mandamentos exigem que você preste atenção especial aos tipos.  Felizmente, ao resolver esse problema, você não precisa fazer tudo sozinho. Geralmente, o compilador TypeScript permite que você saiba quando seus tipos estão mentindo ou quando não são precisos o suficiente. </p><br><p>  Você pode ajudar o compilador a fazer isso ainda melhor, incluindo o sinalizador <code>--strict</code> .  Este é um meta flag que <code>--noImplicitAny</code> todas as opções estritas de verificação de tipo: <code>--noImplicitAny</code> , <code>--noImplicitThis</code> , <code>--alwaysStrict</code> , <code>--strictBindCallApply</code> , <code>--strictNullChecks</code> , <code>--strictFunctionTypes</code> e <code>--strictPropertyInitialization</code> . </p><br><p>  O que as bandeiras fazem?  De um modo geral, sua inclusão leva a um aumento no número de erros de compilação TypeScript.  E isso é bom!  Mais erros de compilação - mais ajuda do compilador. </p><br><p>  Vamos ver como ativar o sinalizador <code>--strictNullChecks</code> ajuda a detectar um falso no código. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id: number</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'John'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; } }</code> </pre> <br><p>  O tipo <code>getUser</code> garante que a função sempre retorne um objeto do tipo <code>User</code> .  No entanto, observe a implementação: uma função também pode retornar <code>undefined</code> ! </p><br><p>  Felizmente, ativar o sinalizador <code>--strictNullChecks</code> resulta em um erro de compilação: </p><br><pre> <code class="plaintext hljs">Type 'undefined' is not assignable to type 'User'.</code> </pre> <br><p>  O compilador TypeScript detecta falsidades.  Para se livrar desse erro, diga honestamente toda a verdade: </p><br><pre> <code class="plaintext hljs">function getUser(id: number): User | undefined { /* ... */ }</code> </pre> <br><p>  <strong>Aceite o rigor da verificação de tipo.</strong>  <strong>Deixe o compilador protegê-lo contra erros.</strong> </p><br><h2 id="budte-v-kurse">  Mantenha-se atualizado </h2><br><p>  O TypeScript está se desenvolvendo em um ritmo muito rápido.  Um novo lançamento é lançado a cada dois meses.  Cada versão traz melhorias significativas no idioma e novos recursos. </p><br><p>  Geralmente, os novos recursos do idioma permitem definir tipos com mais precisão e verificá-los com mais rigor. </p><br><p>  Por exemplo, na versão 2.0, tipos de união discriminados foram introduzidos (eu os mencionei no mandamento <em>Seja preciso</em> ). </p><br><p>  A versão 3.2 introduziu o sinalizador do compilador <code>--strictBindCallApply</code> , que inclui a digitação correta para as funções de <code>bind</code> , <code>call</code> e <code>apply</code> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A versão 3.4 melhorou a inferência de tipo em funções de ordem superior</a> , o que facilitou o uso de tipos exatos ao escrever código em um estilo funcional. </p><br><p>  Minha posição é que conhecer os recursos de linguagem introduzidos nas versões recentes do TypeScript realmente vale a pena.  Muitas vezes, isso pode ajudá-lo a seguir os outros quatro mandamentos da lista. </p><br><p>  Um bom ponto de partida é o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">roteiro oficial do TypeScript</a> .  Também será bom verificar regularmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a seção TypeScript no Microsoft Devblog</a> , pois todos os anúncios de lançamento estão lá. </p><br><p>  <strong>Mantenha-se atualizado com os novos recursos do idioma e deixe esse conhecimento funcionar para você.</strong> </p><br><h2 id="rezyume">  Sumário </h2><br><p>  Espero que você ache a lista útil.  Como sempre e em tudo, não se deve seguir cegamente esses mandamentos.  Mas acredito firmemente que essas regras o tornarão um desenvolvedor TypeScript melhor. </p><br><p>  Ficarei feliz em ver seus pensamentos sobre esse assunto nos comentários. </p><br><h2 id="bonus">  Bônus </h2><br><p>  Você gostou deste artigo sobre o TypeScript?  Tenho certeza de que você também gostará deste PDF gratuito: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">10 erros de desenvolvimento TypeScript que tornam seu código inseguro.</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461565/">https://habr.com/ru/post/pt461565/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461547/index.html">Sistema de Informações Médicas (MIS) como produto</a></li>
<li><a href="../pt461553/index.html">Experiência na automação de testes visuais de regressão em Java + Selenium Webdriver + aShot</a></li>
<li><a href="../pt461555/index.html">Visualizações de planilhas do Google</a></li>
<li><a href="../pt461561/index.html">Temporizador Arduino</a></li>
<li><a href="../pt461563/index.html">Sabre de luz a laser caseiro para vapor de cobre - parte 3 final</a></li>
<li><a href="../pt461567/index.html">SQL Quebra-cabeças divertidos</a></li>
<li><a href="../pt461569/index.html">Nota para o front-end: o que verificar antes do teste</a></li>
<li><a href="../pt461571/index.html">SVG na vida real. Relatório Yandex</a></li>
<li><a href="../pt461575/index.html">Criando um PBX 3CX baseado em nuvem em qualquer hospedagem compatível com Openstack</a></li>
<li><a href="../pt461577/index.html">Part 5/2 Bldg. 1: Crossroads of RocketChip Avenue e pista de instrumentação escorregadia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>