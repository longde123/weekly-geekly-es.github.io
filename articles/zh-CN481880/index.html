<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍔 👩🏻‍💼 🤖 移动PvP射击游戏的物理原理以及我们如何与ECS交朋友 🚰 👩🏻‍✈️ 💨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好！ 在本文中，我们将讨论为多人射击游戏的物理引擎工作的个人经验，并将主要关注物理与ECS的交互作用：我们在工作中涉足了什么耙子，学到了什么，为什么选择了特定的解决方案。 



 首先，让我们弄清楚为什么需要物理引擎。 没有一个普遍的答案：在每款游戏中，它都有其目的。 一些游戏使用物理引擎来正...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>移动PvP射击游戏的物理原理以及我们如何与ECS交朋友</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/481880/"> 大家好！ 在本文中，我们将讨论为多人射击游戏的物理引擎工作的个人经验，并将主要关注物理与<abbr title="ECS是一种将数据与逻辑分离的面向数据的方法。数据表示为属于实体的实体和组件。系统中对逻辑进行了描述，该系统通常会遍历实体的组件并进行更改，创建新的组件和实体。">ECS</abbr>的交互作用：我们在工作中涉足了什么耙子，学到了什么，为什么选择了特定的解决方案。 <br><br><img src="https://habrastorage.org/webt/gp/b_/2-/gpb_2-4ml1nwdsb443-f2pp6zyu.png"><br><a name="habracut"></a><br> 首先，让我们弄清楚为什么需要物理引擎。 没有一个普遍的答案：在每款游戏中，它都有其目的。 一些游戏使用物理引擎来正确模拟世界中对象的行为，以达到沉浸玩家的效果。 在其他情况下，物理是游戏玩法的基础-例如，《愤怒的小鸟》和《红色派系》。 还有一些“沙盒”，其物理定律不同于通常的定律，因此使游戏玩法更加有趣和特别（门户，光速较慢）。 <br><br> 从编程的角度来看，物理引擎可以简化模拟游戏中对象行为的过程。 实际上，它是一个存储对象物理特性描述的库。 在存在物理引擎的情况下，我们不需要开发身体与游戏世界将赖以生存的普遍规律之间的相互作用系统。 这样可以节省大量时间和开发精力。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ef/938/61f/5ef93861ff7c4921e44bcf14902cab51.jpg" alt="图片"><br>  <i>上<a href="https://habr.com/ru/company/pixonic/blog/413729/">图</a>描述了播放器的本质，其组件及其数据，以及与播放器及其组件一起工作的系统。</i>  <i>图中的关键对象是玩家：他可以在太空中移动-变换和移动组件MoveSystem；</i>  <i>身体健康，并且可能死亡-组件健康，损害，损害系统；</i>  <i>死亡出现在重生点之后-该位置的Transform组件，即RespawnSystem；</i>  <i>可能无敌-组成无敌。</i> <br><br><h2> 射击游戏实施游戏物理的特征是什么？ </h2><br> 在我们的游戏中，没有复杂的物理交互，但是仍有许多事情需要物理引擎。 最初，我们计划使用它根据预定的法律在世界上移动角色。 通常，这是通过给主体一定的冲动或恒定速度来完成的，然后，使用库的Simulate / Update方法，对其中注册的所有主体进行精确的模拟，向前迈出了一步。 <br><br> 在射击游戏中，3D物理不仅经常用于模拟角色移动，而且还用于正确处理子弹和火箭的弹道，跳跃，角色彼此之间以及环境之间的相互作用。 如果射击者声称自己是现实的并且试图传达射击过程的真实感受，那么他只需要一个物理引擎。 当玩家向目标射击a弹枪时，他希望获得的经验和结果尽可能与他从长期的射击游戏中已经知道的那种结果相类似-某种全新的东西很可能使他感到意外。 <br><br> 但就我们的游戏而言，有许多限制。 由于我们的射手是可移动的，因此它并不意味着角色之间以及与周围世界之间的复杂互动，因此它不需要美丽的弹道，可破坏性，在不平坦的表面上跳跃。 但是出于相同的原因，同时有非常严格的流量要求。 在这种情况下，3D物理将是多余的：它将仅使用其计算资源的一小部分并生成不必要的数据，这在移动网络中以及客户端通过UDP与服务器的持续同步将占用太多空间。 这里值得回顾的是，在我们的网络模型中，仍然存在诸如<a href="https://habr.com/ru/company/pixonic/blog/415959/">预测和对帐之</a>类的东西，这也涉及到客户的结算。 结果，我们认为我们的物理学应尽可能快地工作，以便成功启动并在移动设备上工作，而不会干扰渲染和其他客户端子系统。 <br><br> 因此，3D物理不适用于我们。 但是，这里值得记住的是，即使游戏看起来像是三维的，也不是事实，因为它的物理场也是三维的：一切都决定了物体之间相互作用的本质。 通常2D物理无法涵盖的效果要么是自定义的（即编写的逻辑看上去像三维交互），要么只是被不影响游戏玩法的视觉效果所替代。 在《风暴英雄》，《古代防御》，《英雄联盟》中，二维物理学能够提供游戏的所有游戏功能，而不会影响画面质量或游戏设计师和世界各地艺术家所创造的信誉感。 因此，例如，在这些游戏中有跳跃角色，但是在跳跃高度上没有物理意义，因此可以归结为二维模拟并在角色悬空时设置某种标志，例如_isInTheAir-在计算逻辑时要考虑到这一点。 <br><br> 因此决定使用2D物理学。 我们用Unity编写游戏，但是服务器使用的是Unity无法理解的无Unity的.net。 由于在客户端和服务器之间流传着大部分仿真代码，因此我们开始寻找跨平台的东西-即，用纯C＃编写的物理库，而没有使用本机代码来消除崩溃移动平台的危险。 此外，考虑到<a href="https://habr.com/ru/company/pixonic/blog/415959/">射手的工作</a>细节，尤其是服务器上不断倒带以确定玩家的射击位置，对于我们来说，库可以与历史一起工作很重要-也就是说，我们可以廉价地及时查看N帧尸体的位置。 并且，当然，不应该放弃该项目：作者的支持和能够快速修复错误（如果在操作过程中发现任何错误）非常重要。 <br><br> 事实证明，当时很少有库可以满足我们的要求。 实际上，只有一个适合我们<a href="https://github.com/ashoulson/VolatilePhysics">-VolatilePhysics</a> 。 <br><br> 该库值得注意，因为它可以与Unity和无Unity的解决方案一起使用，并且还允许您开箱即用地对对象的过去状态进行快照。 适用于射手逻辑。 另外，该库的便利之处在于，用于控制Simulate（）模拟开始的机制使您可以在客户端需要时随时生成它。 另一个功能-能够将其他数据写入身体的功能。 当根据reykast的结果对模拟对象进行寻址时，这很有用-但是，这会大大降低性能。 <br><br> 经过几次测试，并确保客户端和服务器与VolatilePhysics交互良好且没有崩溃，我们选择了它。 <br><br><h2> 我们如何进入图书馆以与ECS正常合作的方式及其结果 </h2><br> 与VolatilePhysics合作的第一步是创建VoltWorld的物理世界。 它是一个代理类，主要工作在该类上：调整，模拟有关对象，reykast等的数据。我们将其包装在特殊的外观中，以便将来我们可以将库的实现更改为其他形式。 外观代码如下所示： <br><br><div class="spoiler">  <b class="spoiler_title">查看代码</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PhysicsWorld</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> HistoryLength = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> VoltWorld _voltWorld; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, VoltBody&gt; _cache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, VoltBody&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsWorld</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { _voltWorld = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VoltWorld(HistoryLength) { DeltaTime = deltaTime }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _cache.ContainsKey(tag); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> VoltBody </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { VoltBody body; _cache.TryGetValue(tag, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> body); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> body; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> VoltRayResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RayCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 origin, Vector2 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, VoltBodyFilter filter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticksBehind</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VoltRayCast(origin, direction.normalized, distance); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VoltRayResult(); _voltWorld.RayCast(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> ray, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> result, filter, ticksBehind); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> VoltRayResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CircleCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 origin, Vector2 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, VoltBodyFilter filter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticksBehind</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VoltRayCast(origin, direction.normalized, distance); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VoltRayResult(); _voltWorld.CircleCast(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> ray, radius, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> result, filter, ticksBehind); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _voltWorld.Update(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _cache[tag]; _voltWorld.Update(body, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag, Vector2 position, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> angle</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _cache[tag]; body.Set(position, angle); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateStaticCircle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 origin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = _voltWorld.CreateCircleWorldSpace(origin, radius, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _voltWorld.CreateStaticBody(origin, <span class="hljs-number"><span class="hljs-number">0</span></span>, shape); body.UserData = tag; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDynamicCircle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 origin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = _voltWorld.CreateCircleWorldSpace(origin, radius, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _voltWorld.CreateDynamicBody(origin, <span class="hljs-number"><span class="hljs-number">0</span></span>, shape); body.UserData = tag; body.CollisionFilter = StaticCollisionFilter; _cache.Add(tag, body); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateStaticSquare</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 origin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotationAngle, Vector2 extents, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = _voltWorld.CreatePolygonBodySpace(extents.GetRectFromExtents(), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _voltWorld.CreateStaticBody(origin, rotationAngle, shape); body.UserData = tag; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDynamicSquare</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 origin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotationAngle, Vector2 extents, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = _voltWorld.CreatePolygonBodySpace(extents.GetRectFromExtents(), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _voltWorld.CreateDynamicBody(origin, rotationAngle, shape); body.UserData = tag; body.CollisionFilter = StaticCollisionFilter; _cache.Add(tag, body); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerable&lt;VoltBody&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBodies</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _voltWorld.Bodies; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StaticCollisionFilter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">VoltBody a, VoltBody b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.IsStatic; } }</code> </pre> <br></div></div><br> 创建世界时，将显示历史的规模-图书馆将存储的世界状态数。 在我们的例子中，它们的数量是32：每秒30帧，如果需要更新逻辑，我们将需要它，如果超出调试过程的限制，则需要另外2个。 该代码还考虑了生成物理物体的向外投射方法以及各种莱克斯特。 <br><br> 正如我们<a href="https://habr.com/ru/company/pixonic/blog/429312/">在前几篇文章中</a>所回顾的<a href="https://habr.com/ru/company/pixonic/blog/429312/">那样</a> ，ECS世界实质上围绕着其中包含的所有系统对Execute方法的常规调用。 在每个系统的正确位置，我们使用对外观的调用。 最初，尽管有这样的想法，但我们没有编写任何批处理来挑战物理引擎。 在立面内部，发生了对物理世界的Update（）的调用，并且库模拟了每帧发生的对象的所有交互。 <br><br> 因此，与物理学的工作可归结为两个部分：一帧中物体在空间中的均匀运动以及拍摄所需的许多石，效果的正确操作以及许多其他事情。  Reykast在身体状态的历史中尤其重要。 <br><br> 根据我们的测试结果，我们很快意识到该库在不同的速度下表现非常差，并且以一定的速度，物体很容易开始穿过墙壁。 在我们的引擎中，没有与连续碰撞检测关联的设置可以解决此问题。 但是当时市场上没有其他解决方案，因此我不得不提出自己的版本，在全球范围内移动物体并将物理数据与ECS同步。 因此，例如，我们的运动系统代码如下： <br><br><div class="spoiler">  <b class="spoiler_title">查看代码</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Volatile; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovePhysicsSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ExecutableSystem</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PhysicsWorld _physicsWorld; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> CollisionFilter _moveFilter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> VoltBodyFilter _collisionFilterDelegate; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MovePhysicsSystem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PhysicsWorld physicsWorld</span></span></span><span class="hljs-function">)</span></span> { _physicsWorld = physicsWorld; _moveFilter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CollisionFilter(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, CollisionLayer.ExplosiveBarrel); _collisionFilterDelegate = _moveFilter.Filter; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { _moveFilter.State = gs; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Movement) { ExecuteMovement(gs, pair.Key, pair.Value); } _physicsWorld.Update(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.PhysicsDynamicBody) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pair.Value.IsAlive) { ExecutePhysicsDynamicBody(gs, pair.Key); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> avatarId</span></span></span><span class="hljs-function">)</span></span> { _moveFilter.State = gs; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movement = gs.WorldState.Movement[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (movement != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { ExecuteMovement(gs, avatarId, movement); _physicsWorld.Update(avatarId); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> physicsDynamicBody = gs.WorldState.PhysicsDynamicBody[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (physicsDynamicBody != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; physicsDynamicBody.IsAlive) ExecutePhysicsDynamicBody(gs, avatarId); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecutePhysicsDynamicBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> entityId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _physicsWorld.GetBody(entityId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (body != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = gs.WorldState.Transform[entityId]; transform.Position = body.Position; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteMovement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> entityId, Movement movement</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _physicsWorld.GetBody(entityId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (body != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> raycastRadius; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CalculateRadius(gs, entityId, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> raycastRadius)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } body.AngularVelocity = <span class="hljs-number"><span class="hljs-number">0</span></span>; body.LinearVelocity = movement.Velocity; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movPhysicInfo = gs.WorldState.MovementPhysicInfo[entityId]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collisionDirection = CircleRayCastSpeedCorrection(body, GameState.TickDurationSec, raycastRadius); CheckMoveInWall(movement, movPhysicInfo, collisionDirection, gs.WorldState.Transform[entityId]); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalculateRadius</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> raycastRadius</span></span></span><span class="hljs-function">)</span></span> { raycastRadius = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> circleShape = gs.WorldState.DynamicCircleCollider[id]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (circleShape != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { raycastRadius = circleShape.Radius; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boxShape = gs.WorldState.DynamicBoxCollider[id]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boxShape != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { raycastRadius = boxShape.RaycastRadius; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gs.Log.Error(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"Physics body {0} doesn't contains shape!"</span></span>, id)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMoveInWall</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Movement movement, MovementPhysicInfo movPhysicInfo, Vector2 collisionDirection, Transform transform</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 60 is the max angle when player move in wall and can shoot through the wall from weapon without target. const float maxAngleToWall = 60; if (movement.Velocity.IsEqual(Vector2.zero)) { if (movPhysicInfo.LastCollisionDirection.IsEqual(Vector2.zero)) { var angleToCollision = transform.Angle.GetDirection().CalculateAbsoluteAngleInDegrees(movPhysicInfo.LastCollisionDirection); movPhysicInfo.TurnOnWall = angleToCollision &lt;= maxAngleToWall; } return; } movPhysicInfo.LastCollisionDirection = collisionDirection * -1f; if (movPhysicInfo.LastCollisionDirection.IsEqual(Vector2.zero)) { movPhysicInfo.TurnOnWall = false; movPhysicInfo.LastCollisionDirection = collisionDirection; } else { var angleToCollision = transform.Angle.GetDirection().CalculateAbsoluteAngleInDegrees(movPhysicInfo.LastCollisionDirection); movPhysicInfo.TurnOnWall = angleToCollision &lt;= maxAngleToWall; } } // I can't believe we are using a physics engine and have to write such kludges private Vector2 CircleRayCastSpeedCorrection(VoltBody targetBody, float deltaSeconds, float rayCastRadius) { if (rayCastRadius &lt;= 0) { return Vector2.zero; } var speed = targetBody.LinearVelocity; var position = targetBody.Position; var direction = speed * deltaSeconds; var rayCastResult = _physicsWorld.CircleCast(position + direction.normalized * 0.1f, direction, direction.magnitude, rayCastRadius, _collisionFilterDelegate, 0); if (rayCastResult.Body == null) { return Vector2.zero; } var magSpeed = speed.magnitude; if (rayCastResult.Distance &gt; 0) { var penetratingDistance = magSpeed * deltaSeconds - rayCastResult.Distance; var sinVelocityEdge = Vector2.Dot(-speed.normalized, rayCastResult.Normal); var biasSpeed = penetratingDistance * sinVelocityEdge / deltaSeconds; var biasVector = rayCastResult.Normal * biasSpeed * 1.1f; var resultVelocity = speed + biasVector; if (magSpeed &lt;= 0) { resultVelocity = Vector2.zero; } targetBody.LinearVelocity = resultVelocity; return rayCastResult.Normal; } var destination = rayCastResult.Body.Position; direction = destination - position; var rayCastResultToBody = _physicsWorld.RayCast(position, direction, direction.magnitude, _collisionFilterDelegate, 0); if (rayCastResultToBody.IsValid) targetBody.LinearVelocity = rayCastResultToBody.Normal * magSpeed * deltaSeconds; return rayCastResultToBody.Normal; } }</span></span></code> </pre> <br></div></div><br> 这样的想法是，在每个角色移动之前，我们<a href="https://docs.unity3d.com/ScriptReference/Physics2D.CircleCast.html">都要</a>按照其移动方向制作一个<a href="https://docs.unity3d.com/ScriptReference/Physics2D.CircleCast.html">CircleCast</a> ，以确定其前方是否有障碍物。 之所以需要CircleCast，是因为游戏中角色的投射代表一个圆圈，我们不希望它们陷入不同几何形状之间的角落。 然后，我们考虑速度的增量，并将此值分配给物理世界的对象作为其在一帧中的速度。 下一步是调用物理引擎Update（）的模拟方法，该方法将移动我们需要的所有对象，同时记录历史中的旧状态。 引擎内部的模拟完成后，我们将读取此模拟数据，将其复制到ECS的Transform组件中，然后继续使用它，尤其是通过网络发送。 <br><br> 事实证明，这种用角色的移动速度控制的小块数据更新物理的方法，对于解决客户端和服务器上物理的差异非常有效。 而且由于我们的物理学不是确定性的-也就是说，使用相同的输入数据，模拟结果可能会有所不同-已经有很多讨论，关于是否值得使用它，以及行业中是否有人做类似的事情，拥有确定性的物理引擎。 幸运的是，我们在游戏开发者大会上从NetherRealm Studios的开发者那里获得了一份有关其游戏网络组件的出色报告，并意识到这种方法确实在发生。 完全组装好系统并进行几次测试后，我们得到了大约5,000个滴答的50个错误预测，即在5分钟的战斗中。 通过调节机制和玩家位置的视觉插值，可以很容易地对如此多的错过预测进行平准。 在使用您自己的数据频繁手动更新物理过程中发生的错误微不足道，因此，视觉插值可以相当迅速地进行-仅需要这样做，这样就不会在角色模型中发生视觉跳跃。 <br><br> 为了检查客户端和服务器状态是否匹配，我们使用了以下形式的自写类： <br><br><div class="spoiler">  <b class="spoiler_title">查看代码</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PS.Logs.Unity; <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Compares the same avatar in two states. Compares the values potentially </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> affected by prediction. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public sealed class GameStateComparer : IGameStateComparer { public bool IsSame(GameState s1, GameState s2, uint avatarId) { if (s1 == null &amp;&amp; s2 != null || s1 != null &amp;&amp; s2 == null) { return false; } if (s1 == null &amp;&amp; s2 == null) return false; var entity1 = s1.WorldState[avatarId]; var entity2 = s2.WorldState[avatarId]; if (entity1 == null &amp;&amp; entity2 == null) { return false; } if (entity1 == null || entity2 == null) { LogManager.Debug("entity is different"); return false; } if (s1.Time != s2.Time) { LogManager.Warning(string.Format("Trying to compare states with different time! Predicted time: {0} Server time: {1}", s1.Time, s2.Time)); return false; } if (s1.WorldState.Transform[avatarId] != s2.WorldState.Transform[avatarId]) { LogManager.Debug("Transform is different"); return false; } // ... some code ... return true; } }</span></span></code> </pre> <br></div></div><br> 如有必要，它可以实现自动化，但我们没有这样做，尽管我们在以后考虑过。 <br><br> 转换比较代码： <br><br><div class="spoiler">  <b class="spoiler_title">查看代码</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ==(Transform a, Transform b) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Angle - b.Angle) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Position.x - b.Position.x) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span> || Math.Abs(a.Position.y - b.Position.y) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br></div></div><br><br><h2> 最初的困难 </h2><br> 运动仿真没有问题，尽管可以将其投影到2D平面上-在这种情况下，物理效果很好，但是游戏设计师曾一度说：“我们想要手榴弹！”而且我们认为，什么都不会改变很多，为什么不只用2D数据模拟人体的3D飞行。 <br><br> 他们介绍了一些物体的高度概念。 <br><br> 对于一个废弃的身体来说，高度定律随时间的变化是什么样的，它们通过了八年级的物理课程，因此对弹道学的决定变得微不足道。 但是，解决冲突的方法不再那么简单。 让我们想象一下这种情况：飞行中的手榴弹应该与墙壁碰撞，或者根据其当前高度和墙壁高度飞过墙壁。 我们将仅在二维世界中解决问题，在二维世界中，手榴弹由圆形表示，墙壁由矩形表示。 <br><br><img src="https://habrastorage.org/webt/ej/yr/lk/ejyrlkwa0tu9hm-3j7nobxmazpo.png"><br>  <i>查看对象的几何形状以解决问题。</i> <br><br> 首先，我们关闭了手榴弹的动态物体与其他静态和动态物体的交互作用。 为了专注于目标，这是必要的。 在我们的任务中，当手榴弹在二维平面上的投影彼此相交时，手榴弹应该能够穿过其他物体并“飞过”墙壁。 在正常的交互中，两个物体不能彼此通过，但是在手榴弹具有自定义运动逻辑和高度的情况下，我们允许它在某些条件下执行此操作。 <br><br> 我们为榴弹引入了GrenadeMovement的单独组件，其中引入了高度的概念： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Component</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GrenadeMovement</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Height; [DontPack] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 Velocity; [DontPack] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> VerticalVelocity; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrenadeMovement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, Vector2 velocity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> verticalVelocity</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br> 现在，手榴弹具有高度坐标，但是此信息对世界其他地方一无所获。 因此，我们决定作弊并增加了以下条件：一枚手榴弹可以飞过墙壁，但只能飞到一定高度。 因此，碰撞的整个定义归结为检查投影碰撞，并将墙的高度与GrenadeMovement.Height字段的值进行比较。 如果手榴弹的飞行高度较小，它就会与墙壁碰撞，否则它可以平静地继续沿其路径移动，包括在2D空间中。 <br><br> 在第一个迭代中，手榴弹在找到相交点时就掉了下来，但是随后我们添加了弹性碰撞，并且它的行为与我们在3D中得到的结果几乎没有区别。 <br><br> 下面给出了计算手榴弹和弹性碰撞轨迹的完整代码： <br><br><div class="spoiler">  <b class="spoiler_title">查看代码</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-comment"><span class="hljs-comment">// ... some code ... using Volatile; namespace Common.WorldState { public sealed class GrenadeMovementSystem : ExecutableSystem { private struct Projection { public float Min; public float Max; } private float _r; private readonly Vector2[] _vertices = new Vector2[4]; private readonly Vector2[] _verticesV = new Vector2[4]; private Vector2 _Vunit; private Vector2 _VTunit; private Projection _wallProj1; private Projection _wallProj2; private Projection _wallProj1V; private Projection _wallProj2V; private const float CollisionPrecision = 1e-3f; private static readonly float HalfSlope = Mathf.Cos(Mathf.PI / 4.0f); private readonly ContactPointList _contactPoints = new ContactPointList(3); public override void Execute(GameState gs) { var settings = gs.RuleBook.GrenadeConfig[1]; _r = settings.R; var floorDampeningPerTick = (float)Math.Pow(settings.FloorDampening, 1.0 / GameState.Hz); foreach (var grenade in gs.WorldState.GrenadeMovement) { // Gravity must take effect before collision // because contact with walls may and will adjust vertical velocity // and penetration will even move the ball up. grenade.Value.VerticalVelocity -= settings.Gravity * GameState.TickDurationSec; grenade.Value.Height += grenade.Value.VerticalVelocity * GameState.TickDurationSec; // prevent falling through floor if (grenade.Value.Height &lt;= _r) { // slow down horizontal movement by floor friction // actually, friciton is simplified to just dampening coefficient var spdH = grenade.Value.Velocity.sqrMagnitude; var spdV = grenade.Value.VerticalVelocity; var cos = spdH / Mathf.Sqrt(spdH * spdH + spdV * spdV); grenade.Value.Velocity *= floorDampeningPerTick * cos; // slow down vertical movement grenade.Value.VerticalVelocity = settings.FloorRestitution * Math.Abs(grenade.Value.VerticalVelocity); // move up to the floor level grenade.Value.Height = _r; } // A collision will stop the ball and change its velocity. // Otherwise it will be moved by velocity PerformCollisionAndMovement(gs, grenade.Key, grenade.Value); } } private void PerformCollisionAndMovement(GameState gs, uint id, GrenadeMovement grenade) { var settings = gs.RuleBook.GrenadeConfig[1]; var velocity = grenade.Velocity * GameState.TickDurationSec; var trans = gs.WorldState.Transform[id]; var position = trans.Position; _Vunit = velocity.normalized; _VTunit = new Vector2(-_Vunit.y, _Vunit.x); _vertices[0] = position + _VTunit * _r; _vertices[1] = position - _VTunit * _r; _vertices[2] = _vertices[1] + velocity; _vertices[3] = _vertices[0] + velocity; _contactPoints.Reset(); int collisions = 0; var grenProj1V = ProjectCapsule(_Vunit, _vertices, position, velocity); var grenProj2V = ProjectCapsule(_VTunit, _vertices, position, velocity); collisions += CollideWithStaticBoxes(gs, id, position, velocity, grenade, grenProj1V, grenProj2V); collisions += CollideWithCircles(gs, gs.RuleBook.StaticCircleCollider, gs.RuleBook.Transform, id, position, velocity, grenade, grenProj1V, grenProj2V, (CollisionLayer)~0); collisions += CollideWithCircles(gs, gs.WorldState.DynamicCircleCollider, gs.WorldState.Transform, id, position, velocity, grenade, grenProj1V, grenProj2V, ~CollisionLayer.Character); if (collisions == 0) { trans.Position += velocity; } else { var contactSuperposition = CalculateContactSuperposition(); trans.Position += velocity * contactSuperposition.TravelDistance; var reflectedVelocity = grenade.Velocity - 2.0f * Vector2.Dot(grenade.Velocity, contactSuperposition.Normal) * contactSuperposition.Normal; reflectedVelocity *= settings.WallRestitution; #if DEBUG_GRENADES gs.Log.Debug("contact" + "\n\ttravel " + contactSuperposition.TravelDistance + "\n\tcontactNormal " + contactSuperposition.Normal.x + ":" + contactSuperposition.Normal.y + "\n\treflected V " + reflectedVelocity.x + ":" + reflectedVelocity.y); #endif grenade.Velocity = reflectedVelocity; } } private int CollideWithStaticBoxes( GameState gs, uint id, Vector2 position, Vector2 velocity, GrenadeMovement grenade, Projection grenProj1V, Projection grenProj2V) { var settings = gs.RuleBook.GrenadeConfig[1]; var collisions = 0; // TODO spatial query foreach (var collider in gs.RuleBook.StaticBoxCollider) { var wall = collider.Value; var transform = gs.RuleBook.Transform[collider.Key]; var colliderData = gs.RuleBook.PrecomputedColliderData[collider.Key]; // test projection to V _wallProj1V = ProjectPolygon(_Vunit, colliderData.Vertices); if (!Overlap(_wallProj1V, grenProj1V)) continue; // test projection to VT _wallProj2V = ProjectPolygon(_VTunit, colliderData.Vertices); if (!Overlap(_wallProj2V, grenProj2V)) continue; // test projection to wall axis 1 _wallProj1 = ProjectPolygon(colliderData.Axis1, colliderData.Vertices); var grenProj1 = ProjectCapsule(colliderData.Axis1, _vertices, position, velocity); if (!Overlap(_wallProj1, grenProj1)) continue; // test projection to wall axis 2 _wallProj2 = ProjectPolygon(colliderData.Axis2, colliderData.Vertices); var grenProj2 = ProjectCapsule(colliderData.Axis2, _vertices, position, velocity); if (!Overlap(_wallProj2, grenProj2)) continue; var lowWall = wall.Height &lt; settings.TallWallHeight; if (lowWall) { // the wall is too far below, ignore it completely if (grenade.Height &gt; wall.Height + _r) continue; // if grenade if falling down, it can bounce off the top of the wall if (grenade.VerticalVelocity &lt; 0f) { if (grenade.Height &gt; wall.Height - _r) { var localPV = WorldToBoxLocal(transform.Position, colliderData, position + velocity); #if DEBUG_GRENADES gs.Log.Debug("fall on wall" + "\n\tP+V " + (Px + Vx) + ":" + (Py + Vy) + "\n\tlocal " + localPV.x + ":" + localPV.y + "\n\tH w " + wall.Height + " g " + grenade.Height ); #endif if (Math.Abs(localPV.x) &lt; wall.Size.x * 0.5f || Math.Abs(localPV.y) &lt; wall.Size.y * 0.5f) { grenade.Height = wall.Height + _r; grenade.VerticalVelocity = settings.WallRestitution * Math.Abs(grenade.VerticalVelocity); continue; } } } } // collision detected // try to find minimal V before collision var scaleV = CalcTranslationScaleBeforeCollision(CheckBoxCollision, colliderData, 0, position, velocity); var contactPoint = CalcBoxContactPoint(transform.Position, wall, colliderData, position); #if DEBUG_GRENADES gs.Log.Debug("collision grenade #" + id + " with static box #" + collider.Key + "\n\tP=" + Px + ":" + Py + "\n\tV=" + Vx + ":" + Vy + " scale=" + scaleV + "\n\tP+Vs=" + (Px + Vx * scaleV) + ":" + (Py + Vy * scaleV) + "\n\twall pos " + transform.Position.x + ":" + transform.Position.y + " sz " + wall.Size.x + ":" + wall.Size.y + " angle " + transform.Angle + "\n\tproj V w " + _wallProj1V.Min + ":" + _wallProj1V.Max + " g " + grenProj1V.Min + ":" + grenProj1V.Max + " overlap=" + Overlap(_wallProj1V, grenProj1V) + "\n\tproj VT w " + _wallProj2V.Min + ":" + _wallProj2V.Max + " g " + grenProj2V.Min + ":" + grenProj2V.Max + " overlap=" + Overlap(_wallProj2V, grenProj2V) + "\n\taxis1 " + colliderData.Axis1.x + ":" + colliderData.Axis1.y + "\n\tproj 1 w " + _wallProj1.Min + ":" + _wallProj1.Max + " g " + grenProj1.Min + ":" + grenProj1.Max + " overlap=" + Overlap(_wallProj1, grenProj1) + "\n\taxis2 " + colliderData.Axis2.x + ":" + colliderData.Axis2.y + "\n\tproj 2 w " + _wallProj2.Min + ":" + _wallProj2.Max + " g " + grenProj2.Min + ":" + grenProj2.Max + " overlap=" + Overlap(_wallProj2, grenProj2) + "\n\tpoint " + contactPoint.Point.x + ":" + contactPoint.Point.y + " dotV " + Vector2.Dot(P - contactPoint.Point, V) ); #endif // ignore colliders that are behind if (Vector2.Dot(position - contactPoint.Point, velocity) &gt;= 0.0f) continue; contactPoint.TravelDistance = velocity.magnitude * scaleV; _contactPoints.Add(ref contactPoint); collisions++; } return collisions; } private bool CheckBoxCollision(PrecomputedColliderData colliderData, int x, Vector2 position, Vector2 velocity) { _verticesV[0] = _vertices[0]; _verticesV[1] = _vertices[1]; _verticesV[2] = _vertices[1] + velocity; _verticesV[3] = _vertices[0] + velocity; // test projection to V var grenProj1V = ProjectCapsule(_Vunit, _verticesV, position, velocity); if (!Overlap(_wallProj1V, grenProj1V)) return false; // testing projection to VT would be redundant // test projection to wall axis 1 var grenProj1 = ProjectCapsule(colliderData.Axis1, _verticesV, position, velocity); if (!Overlap(_wallProj1, grenProj1)) return false; // test projection to wall axis 2 var grenProj2 = ProjectCapsule(colliderData.Axis2, _verticesV, position, velocity); if (!Overlap(_wallProj2, grenProj2)) return false; return true; } private int CollideWithCircles( GameState gs, Table&lt;CircleCollider&gt; colliderTable, Table&lt;Transform&gt; transformTable, uint id, Vector2 position, Vector2 velocity, GrenadeMovement grenade, Projection grenProj1V, Projection grenProj2V, CollisionLayer collisionLayers) { var settings = gs.RuleBook.GrenadeConfig[1]; var collisions = 0; foreach (var collider in colliderTable) { if ((int)collisionLayers != ~0) { var body = gs.WorldState.PhysicsDynamicBody[collider.Key]; if (body != null &amp;&amp; (body.CollisionLayer &amp; collisionLayers) == 0) continue; } var wall = collider.Value; var transform = transformTable[collider.Key]; // test projection to V _wallProj1V = ProjectCircle(_Vunit, transform.Position, wall.Radius); if (!Overlap(_wallProj1V, grenProj1V)) continue; // test projection to VT _wallProj2V = ProjectCircle(_VTunit, transform.Position, wall.Radius); if (!Overlap(_wallProj2V, grenProj2V)) continue; // test distance from the circle wall to semicircles on capsule ends var collisionDistance = (_r + wall.Radius) * (_r + wall.Radius); if ((position - transform.Position).sqrMagnitude &gt; collisionDistance) continue; var distSqr = (position + velocity - transform.Position).sqrMagnitude; if (distSqr &gt; collisionDistance) continue; var lowWall = wall.Height &lt; settings.TallWallHeight; if (lowWall) { // the wall is too far below, ignore it completely if (grenade.Height &gt; wall.Height + _r) continue; // if grenade if falling down, it can bounce off the top of the wall if (grenade.VerticalVelocity &lt; 0f) { if (grenade.Height &gt; wall.Height - _r) { #if DEBUG_GRENADES gs.Log.Debug("grenade #" + id + " falls on wall" + "\n\tP+V " + (Px + Vx) + ":" + (Py + Vy) + "\n\tdist " + Mathf.Sqrt(distSqr) + "\n\tH w " + wall.Height + " g " + grenade.Height ); #endif if (distSqr &lt; wall.Radius * wall.Radius) { grenade.Height = wall.Height + _r; grenade.VerticalVelocity = settings.WallRestitution * Math.Abs(grenade.VerticalVelocity); continue; } } } } // collision detected // try to find minimal V before collision var scaleV = CalcTranslationScaleBeforeCollision(CheckCircleCollision, transform.Position, wall, position, velocity); var contactPoint = CalcCircleContactPoint(transform.Position, wall, position); #if DEBUG_GRENADES gs.Log.Debug("collision grenade #" + id + " with circle #" + collider.Key + "\n\tP=" + Px + ":" + Py + "\n\tV=" + Vx + ":" + Vy + " scale=" + scaleV + "\n\tP+Vs=" + (Px + Vx * scaleV) + ":" + (Py + Vy * scaleV) + "\n\tcircle pos " + transform.Position.x + ":" + transform.Position.y + " r " + wall.Radius + "\n\tdist " + (transform.Position - (P + V * scaleV)).magnitude + "\n\tproj V w " + _wallProj1V.Min + ":" + _wallProj1V.Max + " g " + grenProj1V.Min + ":" + grenProj1V.Max + " overlap=" + Overlap(_wallProj1V, grenProj1V) + "\n\tproj VT w " + _wallProj2V.Min + ":" + _wallProj2V.Max + " g " + grenProj2V.Min + ":" + grenProj2V.Max + " overlap=" + Overlap(_wallProj2V, grenProj2V) + "\n\tpoint " + contactPoint.Point.x + ":" + contactPoint.Point.y + " dotV " + Vector2.Dot(P - contactPoint.Point, V) ); #endif // ignore colliders that are behind if (Vector2.Dot(position - contactPoint.Point, velocity) &gt;= 0.0f) continue; contactPoint.TravelDistance = velocity.magnitude * scaleV; _contactPoints.Add(ref contactPoint); collisions++; } return collisions; } private bool CheckCircleCollision(Vector2 wallCentre, CircleCollider wall, Vector2 position, Vector2 velocity) { _verticesV[0] = _vertices[0]; _verticesV[1] = _vertices[1]; _verticesV[2] = _vertices[1] + velocity; _verticesV[3] = _vertices[0] + velocity; // test projection to V var grenProj1V = ProjectCapsule(_Vunit, _verticesV, position, velocity); if (!Overlap(_wallProj1V, grenProj1V)) return false; // testing projection to VT would be redundant // test distance from the circle wall to the semicircle on the second capsule end var dSqr = (_r + wall.Radius) * (_r + wall.Radius); return (position + velocity - wallCentre).sqrMagnitude &lt; dSqr; } private static float CalcTranslationScaleBeforeCollision&lt;TData1, TData2&gt;( Func&lt;TData1, TData2, Vector2, Vector2, bool&gt; collision, TData1 colliderData1, TData2 colliderData2, Vector2 position, Vector2 vector) { var min = 0.0f; var max = 1.0f; while (true) { var d = (max - min) * 0.5f; if (d &lt; CollisionPrecision) break; var scale = min + d; if (collision(colliderData1, colliderData2, position, vector * scale)) { max = scale; } else { min = scale; } } return min; } private ContactPoint CalculateContactSuperposition() { ContactPoint contactSuperposition; _contactPoints.TryPopClosest(1000f, out contactSuperposition); ContactPoint contact; while (_contactPoints.TryPopClosest(contactSuperposition.TravelDistance, out contact)) { contactSuperposition.Normal += contact.Normal; } contactSuperposition.Normal = contactSuperposition.Normal.normalized; return contactSuperposition; } private static Projection ProjectPolygon(Vector2 axisNormalised, Vector2[] vertices) { Projection proj; var d = Vector2.Dot(axisNormalised, vertices[0]); proj.Min = d; proj.Max = d; for (var i = 1; i &lt; vertices.Length; i++) { d = Vector2.Dot(axisNormalised, vertices[i]); proj.Min = Mathf.Min(proj.Min, d); proj.Max = Mathf.Max(proj.Max, d); } return proj; } private Projection ProjectCapsule(Vector2 axisNormalised, Vector2[] vertices, Vector2 p, Vector2 v) { var proj = ProjectPolygon(axisNormalised, vertices); proj = AddCircleProjection(proj, axisNormalised, p, _r); proj = AddCircleProjection(proj, axisNormalised, p + v, _r); return proj; } private static Projection AddCircleProjection(Projection proj, Vector2 axisNormalised, Vector2 centre, float r) { var c = Vector2.Dot(axisNormalised, centre); proj.Min = Mathf.Min(proj.Min, c - r); proj.Max = Mathf.Max(proj.Max, c + r); return proj; } private static Projection ProjectCircle(Vector2 axisNormalised, Vector2 centre, float r) { Projection proj; var c = Vector2.Dot(axisNormalised, centre); proj.Min = c - r; proj.Max = c + r; return proj; } private static bool Overlap(Projection p1, Projection p2) { return p1.Min &lt; p2.Min ? p1.Max &gt; p2.Min : p2.Max &gt; p1.Min; } private static Vector2 WorldToBoxLocal(Vector2 wallCentre, PrecomputedColliderData colliderData, Vector2 position) { return new Vector2( Vector2.Dot(colliderData.Axis1, position) - Vector2.Dot(colliderData.Axis1, wallCentre), Vector2.Dot(colliderData.Axis2, position) - Vector2.Dot(colliderData.Axis2, wallCentre) ); } private static ContactPoint CalcBoxContactPoint(Vector2 wallCentre, BoxCollider wall, PrecomputedColliderData colliderData, Vector2 position) { var contactPoint = CaclBoxLocalContactPoint(wall.Size * 0.5f, WorldToBoxLocal(wallCentre, colliderData, position)); var worldAxisX = new Vector2(colliderData.Axis1.x, -colliderData.Axis1.y); var worldAxisY = new Vector2(colliderData.Axis1.y, colliderData.Axis1.x); contactPoint.Point = wallCentre + new Vector2(Vector2.Dot(worldAxisX, contactPoint.Point), Vector2.Dot(worldAxisY, contactPoint.Point)); contactPoint.Normal = new Vector2(Vector2.Dot(worldAxisX, contactPoint.Normal), Vector2.Dot(worldAxisY, contactPoint.Normal)); return contactPoint; } private static ContactPoint CaclBoxLocalContactPoint(Vector2 boxHalfSize, Vector2 localPosition) { ContactPoint localContactPoint = default(ContactPoint); // cases are numbered like numpad keys // 1, 2, 3 if (localPosition.y &lt; -boxHalfSize.y) { // 1 if (localPosition.x &lt; -boxHalfSize.x) { localContactPoint.Point = new Vector2(-boxHalfSize.x, -boxHalfSize.y); localContactPoint.Normal = new Vector2(-HalfSlope, -HalfSlope); } // 2, 3 else { // 3 if (localPosition.x &gt; boxHalfSize.x) { localContactPoint.Point = new Vector2(boxHalfSize.x, -boxHalfSize.y); localContactPoint.Normal = new Vector2(HalfSlope, -HalfSlope); } // 2 else { localContactPoint.Point = new Vector2(localPosition.x, -boxHalfSize.y); localContactPoint.Normal = new Vector2(0.0f, -1.0f); } } } // 4, 6, 7, 8, 9 else { // 7, 8, 9 if (localPosition.y &gt; boxHalfSize.y) { // 7 if (localPosition.x &lt; -boxHalfSize.x) { localContactPoint.Point = new Vector2(-boxHalfSize.x, boxHalfSize.y); localContactPoint.Normal = new Vector2(-HalfSlope, HalfSlope); } // 8, 9 else { // 9 if (localPosition.x &gt; boxHalfSize.x) { localContactPoint.Point = new Vector2(boxHalfSize.x, boxHalfSize.y); localContactPoint.Normal = new Vector2(HalfSlope, HalfSlope); } // 8 else { localContactPoint.Point = new Vector2(localPosition.x, boxHalfSize.y); localContactPoint.Normal = new Vector2(0.0f, 1.0f); } } } // 4, 6 else { // 4 if (localPosition.x &lt; -boxHalfSize.x) { localContactPoint.Point = new Vector2(-boxHalfSize.x, localPosition.y); localContactPoint.Normal = new Vector2(-1.0f, 0.0f); } // 6 else { localContactPoint.Point = new Vector2(boxHalfSize.x, localPosition.y); localContactPoint.Normal = new Vector2(1.0f, 0.0f); } } } return localContactPoint; } private static ContactPoint CalcCircleContactPoint(Vector2 wallCentre, CircleCollider wall, Vector2 position) { ContactPoint contactPoint = default(ContactPoint); contactPoint.Normal = (position - wallCentre).normalized; contactPoint.Point = wallCentre + wall.Radius * contactPoint.Normal; return contactPoint; } } }</span></span></code> </pre> <br></div></div><br><h2>  . 接下来是什么？ </h2><br>  , ,       -   ,        .         <a href="https://habr.com/ru/company/pixonic/blog/424267/"> ECS  </a> .    ,      ,     JSON,        ECS.    : <br><br><img src="https://habrastorage.org/webt/x6/wv/1w/x6wv1w0hkb13r4rflik9hvacnk0.png"><br><br> ,       «».      ECS,       ,      .   ―  ―   , ,     ECS,        ECS   . ,    API,       ,      ,  .        ,                            . <br><br> -       2D-:        ,       . ,   :      ,      opensource    ,   -    .        ECS,     ,       .  ,             ,      .   -       ,    ,        .   ―    -  . <br><br>  -          ,   3D-,  ,                . <br><br>    , ,          ,      .     ,  ,      ECS      . <br><br><h4> 有用的链接 </h4><br>      : <br><br><ul><li> <a href="https://habr.com/ru/company/pixonic/blog/429312/">      </a> </li><li> <a href="https://habr.com/ru/company/pixonic/blog/415959/">      PvP :    </a> </li><li> <a href="https://habr.com/ru/company/pixonic/blog/413729/">      ECS</a> </li><li> <a href="https://habr.com/ru/company/pixonic/blog/424267/">      ECS   </a> </li></ul><br>   : <br><br><ul><li> <a href="https://www.youtube.com/watch%3Fv%3D7jb0FOcImdg">8 Frames in 16ms: Rollback Networking in Mortal Kombat and Injustice 2</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN481880/">https://habr.com/ru/post/zh-CN481880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN481860/index.html">IT在2020年应该做什么？</a></li>
<li><a href="../zh-CN481862/index.html">Nvidia Jetson嵌入式机器学习系统</a></li>
<li><a href="../zh-CN481866/index.html">DBA：当VACUUM通过时-我们手动清洁桌子</a></li>
<li><a href="../zh-CN481868/index.html">达加斯：新起点</a></li>
<li><a href="../zh-CN481874/index.html">指标-项目运行状况指标</a></li>
<li><a href="../zh-CN481882/index.html">4. Fortinet入门v6.0。 防火墙政策</a></li>
<li><a href="../zh-CN481884/index.html">老年人的十字路口：下一步要去哪里？</a></li>
<li><a href="../zh-CN481886/index.html">如何快速创建考勤日记</a></li>
<li><a href="../zh-CN481890/index.html">向俄罗斯进口德国铀尾矿。 第二部分。浓缩</a></li>
<li><a href="../zh-CN481892/index.html">用位代替位：量子计算机对我们有什么未来？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>