<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🚒 👨🏻 #⃣ Wir erhöhen die Zufälligkeit der Tatsache, dass [wahrscheinlich] [fast] zufällig 🕠 👩🏽‍🎨 👩🏻‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zufallszahlen schmackhafter, wenn ein wenig Pfeffer 

 Wir werden Theorie mit Praxis kombinieren - wir werden zeigen, dass eine Verbesserung der Entro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir erhöhen die Zufälligkeit der Tatsache, dass [wahrscheinlich] [fast] zufällig</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423093/"><img src="https://habrastorage.org/webt/g9/kh/sg/g9khsgflhymunz9z4_dd9qww1ny.jpeg"><br>  <i>Zufallszahlen schmackhafter, wenn ein wenig Pfeffer</i> <br><br>  Wir werden Theorie mit Praxis kombinieren - wir werden zeigen, dass eine Verbesserung der Entropie von Zufallssequenzen möglich ist, wonach wir uns die Quellcodes ansehen, die dies tun. <br><br>  Ich wollte unbedingt darüber schreiben, dass eine qualitativ hochwertige, dh hochentropische Zufallszahlengenerierung für die Lösung einer Vielzahl von Problemen von entscheidender Bedeutung ist, aber dies ist wahrscheinlich überflüssig.  Ich hoffe, jeder weiß das sehr gut. <br><br>  Auf der Suche nach hochwertigen Zufallszahlen erfinden die Leute sehr witzige Geräte (siehe zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ).  Im Prinzip sind ziemlich gute Zufallsquellen in die API von Betriebssystemen integriert, aber dies ist eine ernste Angelegenheit, und ein wenig Zweifel frisst uns: Ist das RNG, das ich verwende, gut genug und wird es verwöhnt ... sagen wir, von Dritten? <br><a name="habracut"></a><br><h3>  Ein bisschen Theorie </h3><br>  <b>Zunächst zeigen wir, dass mit dem richtigen Ansatz die Qualität des vorhandenen RNG nicht beeinträchtigt werden kann.</b>  Der einfachste richtige Ansatz besteht darin, eine andere Sequenz durch die XOR-Operation auf der Hauptsequenz zu überlagern.  <i>Die</i> Hauptsequenz kann zum Beispiel ein systemisches RNG sein, das wir bereits für gut halten, aber es gibt immer noch einige Zweifel, und wir hatten den Wunsch, auf Nummer sicher zu gehen.  <i>Eine zusätzliche</i> Sequenz kann zum Beispiel ein Pseudozufallszahlengenerator sein, dessen Ausgabe gut aussieht, aber wir wissen, dass seine reale Entropie sehr niedrig ist.  <i>Die resultierende</i> Sequenz ist das Ergebnis der Anwendung der XOR-Operation auf die Bits der Primär- und Sekundärsequenz.  <b>Eine signifikante Nuance: Die</b> Primär- und Sekundärsequenzen müssen unabhängig voneinander sein.  Das heißt, ihre Entropie muss aus grundlegend unterschiedlichen Quellen stammen, deren gegenseitige Abhängigkeit nicht berechnet werden kann. <br><br>  Bezeichne mit <b><i>x das</i></b> nächste Bit der Hauptsequenz und <b><i>y</i></b> - das entsprechende Bit der zusätzlichen Sequenz.  Das Bit der resultierenden Sequenz wird mit <b><i>r bezeichnet</i></b> : <br>  r = x⊕y <br><br>  <b>Der erste Versuch zu beweisen.</b>  Versuchen wir, die Informationsentropie von <b><i>x</i></b> , <b><i>y</i></b> und <b><i>r durchzugehen</i></b> .  Wir bezeichnen die Wahrscheinlichkeit von Null <b><i>x</i></b> als <b><i>p <sub>x0</sub></i></b> und die Wahrscheinlichkeit von Null <b><i>y</i></b> als <b><i>p <sub>y0</sub></i></b> .  Die Informationsentropien <b><i>x</i></b> und <b><i>y werden</i></b> nach der Shannon-Formel berechnet: <br><br>  H <sub>x</sub> = - (p <sub>x</sub> <sub>0</sub> log <sub>2</sub> p <sub>x 0</sub> + (1 - p <sub>x 0</sub> ) log <sub>2</sub> (1 - p <sub>x 0</sub> )) <br>  H <sub>y</sub> = - (p <sub>y0</sub> log <sub>2</sub> p <sub>y0</sub> + (1 - p <sub>y0</sub> ) log <sub>2</sub> (1 - p <sub>y0</sub> )) <br><br>  Null in der resultierenden Sequenz wird angezeigt, wenn sich am Eingang zwei Nullen oder zwei Einheiten befinden.  Wahrscheinlichkeit von Null r: <br><br>  p <sub>r0</sub> = p <sub>x0</sub> p <sub>y0</sub> + (1 - p <sub>x0</sub> ) (1 - p <sub>y0</sub> ) <br>  H <sub>r</sub> = - (p <sub>r0</sub> log <sub>2</sub> p <sub>r0</sub> + (1 - p <sub>r0</sub> ) log <sub>2</sub> (1 - p <sub>r0</sub> )) <br><br>  Um die Unveränderlichkeit der Hauptsequenz zu beweisen, muss dies bewiesen werden <br>  <b><i>Hr - Hx ≥ 0</i></b> für alle Werte von <b><i>p <sub>x0</sub></i></b> und <b><i>p <sub>y0</sub></i></b> .  Ich konnte es nicht analytisch beweisen, aber die visualisierte Berechnung zeigt, dass die Zunahme der Entropie eine glatte Oberfläche bildet, die nirgendwo auf Minus gehen wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mb/un/5x/mbun5xdlkm3zmxc-7brg5lypo4q.png"></div><br>  Wenn wir zum Beispiel ein stark verzerrtes zusätzliches Signal mit <i>p <sub>y0</sub></i> = 0,1 zum verzerrten Hauptsignal c <i>p <sub>x0</sub></i> = 0,3 (Entropie 0,881) hinzufügen, erhalten wir das Ergebnis <i>p <sub>r0</sub></i> = 0,66 mit Entropie 0,925. <br><br>  Entropie kann also nicht verdorben werden, aber dies ist noch nicht genau.  Daher ist ein zweiter Versuch erforderlich.  Durch Entropie kann man aber auch beweisen.  Schema (alle Schritte sind recht einfach, Sie können es selbst tun): <br><br><ol><li>  Wir beweisen, dass die Entropie am Punkt <i>p <sub>0</sub></i> = 1/2 ein Maximum hat. </li><li>  Wir beweisen, dass für jedes <i>p <sub>x0</sub></i> und <i>p <sub>y0 der</sub></i> Wert von <i>p <sub>r0</sub></i> nicht weiter von 1/2 als <i>p <sub>x0 entfernt sein kann</sub></i> . </li></ol><br>  <b>Der zweite Versuch zu beweisen.</b>  Durch die Fähigkeit zu raten.  Angenommen, ein Angreifer hat a priori Informationen über die Primär- und Sekundärsequenzen.  Der Besitz von Informationen drückt sich in der Fähigkeit aus, die Werte von <b><i>x</i></b> , <b><i>y</i></b> und als Ergebnis von <b><i>r</i></b> mit einiger Wahrscheinlichkeit im Voraus zu erraten.  Die Wahrscheinlichkeiten für das Erraten von <b><i>x</i></b> und <b><i>y werden</i></b> mit <b><i>g <sub>x</sub></i></b> bzw. <b><i>g</i></b> <b><i>y</i></b> bezeichnet (aus dem Wort "erraten").  Das Bit der resultierenden Sequenz wird entweder erraten, wenn beide Werte richtig erraten wurden, oder wenn beide falsch sind. Die Wahrscheinlichkeit des Erratens ist also folgende: <br>  g <sub>r</sub> = g <sub>x</sub> g <sub>y</sub> + (1 - g <sub>x</sub> ) (1 - g <sub>y</sub> ) = 2 g <sub>x</sub> g <sub>y</sub> - g <sub>x</sub> - g <sub>y</sub> + 1 <br><br>  Wenn wir den perfekten Vermesser haben, haben wir <b><i>g</i></b> = 1.  Wenn wir nichts wissen, ist <b><i>g</i></b> ... nein, nicht null, sondern 1/2.  Dies ist genau die Wahrscheinlichkeit, dass es sich herausstellt, wenn wir eine Entscheidung treffen, indem wir eine Münze werfen.  Ein sehr interessanter Fall ist, wenn <b><i>g</i></b> &lt;1/2 ist.  Einerseits hat ein solcher Vermesser irgendwo in sich Daten über den vorhergesagten Wert, kehrt jedoch aus irgendeinem Grund seine Ausgabe um und die <i>Münze</i> wird <i>schlechter</i> .  Bitte denken Sie an den Satz "schlimmer als eine Münze", er wird uns unten nützlich sein.  Aus Sicht der mathematischen Kommunikationstheorie (und damit der uns bekannten quantitativen Informationstheorie) ist diese Situation absurd, da es sich nicht um eine Informationstheorie handelt, sondern um eine Desinformationstheorie, aber im Leben haben wir diese Situation viel häufiger als wir möchten . <br><br>  Betrachten Sie die Grenzfälle: <br><br><ul><li>  <b><i>g <sub>x</sub> = 1</i></b> , d. <b><i>h.</i></b> die Sequenz <b><i>x ist</i></b> vollständig vorhersagbar: <br>  g <sub>r</sub> = g <sub>x</sub> g <sub>y</sub> + (1 - g <sub>x</sub> ) (1 - g <sub>y</sub> ) = 1 g <sub>y</sub> + (1 - 1) (1 - g <sub>y</sub> ) = g <sub>y</sub> <br>  Das heißt, die Wahrscheinlichkeit, das Ergebnis zu erraten, ist gleich der Wahrscheinlichkeit, die zusätzliche Sequenz zu erraten. </li><li>  <b><i>g <sub>y</sub> = 1</i></b> : Ähnlich wie beim vorherigen.  Die Wahrscheinlichkeit, das Ergebnis zu erraten, entspricht der Wahrscheinlichkeit, die Hauptsequenz zu erraten. </li><li>  <b><i>g <sub>x</sub> = 1/2</i></b> , d. <b><i>h.</i></b> die Sequenz <b><i>x ist</i></b> völlig unvorhersehbar: <br>  g <sub>r</sub> = 2 g <sub>x</sub> g <sub>y</sub> - g <sub>x</sub> - g <sub>y</sub> + 1 = 2/2 g <sub>y</sub> - 1/2 - g <sub>y</sub> + 1 = g <sub>y</sub> - g <sub>y</sub> + 1/2 = 1/2 <br>  Das heißt, das Hinzufügen einer zusätzlichen Sequenz beeinträchtigt nicht die vollständige Unvorhersehbarkeit der Hauptsequenz. </li><li>  <b><i>g <sub>y</sub> = 1/2</i></b> : Ähnlich wie beim vorherigen.  Das Hinzufügen einer völlig unvorhersehbaren zusätzlichen Sequenz macht das Ergebnis völlig unvorhersehbar. </li></ul><br>  Um zu beweisen, dass das Hinzufügen einer zusätzlichen Sequenz zur Hauptsequenz dem Angreifer nicht hilft, müssen wir herausfinden, unter welchen Bedingungen <b><i>g <sub>r</sub></i></b> größer als <b><i>g <sub>x sein kann</sub></i></b> , d. H. <br><br>  2 g <sub>x</sub> g <sub>y</sub> - g <sub>x</sub> - g <sub>y</sub> + 1&gt; g <sub>x</sub> <br><br>  Bewegen Sie g <sub>x</sub> von rechts nach links und g <sub>y</sub> und 1 nach rechts: <br><br>  2 g <sub>x</sub> g <sub>y</sub> - g <sub>x</sub> - g <sub>x</sub> &gt; g <sub>y</sub> - 1 <br>  2 g <sub>x</sub> g <sub>y</sub> - 2 g <sub>x</sub> &gt; g <sub>y</sub> - 1 <br>  Wir nehmen auf der linken Seite 2g <sub>x</sub> aus Klammern heraus: <br>  2 g <sub>x</sub> (g <sub>y</sub> - 1)&gt; g <sub>y</sub> - 1 <br>  Da wir g <sub>y</sub> kleiner als eins haben (der Grenzfall, wenn g <sub>y</sub> = 1 ist, haben wir bereits berücksichtigt), wandeln wir g <sub>y</sub> −1 in 1 - g <sub>y um</sub> , ohne zu vergessen, "mehr" in "weniger" zu ändern: <br>  2 g <sub>x</sub> (1 - g <sub>y</sub> ) &lt;1 - g <sub>y</sub> <br><br>  Reduzieren Sie "1 - g <sub>y</sub> " und erhalten Sie die Bedingung, unter der das Hinzufügen einer zusätzlichen Sequenz die Situation für den Angreifer verbessert: <br><br>  2 g <sub>x</sub> &lt;1 <br>  g <sub>x</sub> &lt;1/2 <br><br>  Das heißt, <b><i>g <sub>r</sub></i></b> kann nur dann größer als <b><i>g <sub>x sein</sub></i></b> , wenn die Hauptsequenz <i>schlechter als eine Münze ist</i> .  Dann, wenn unser Prädiktor in bewusste Sabotage verwickelt ist. <br><br>  <b>Einige zusätzliche Überlegungen zur Entropie.</b> <br><br><ol><li>  Entropie ist ein äußerst mythologisches Konzept.  Informationen - einschließlich.  Das ist sehr beunruhigend.  Informationsentropie wird oft als eine Art subtile Materie dargestellt, die entweder objektiv in den Daten vorhanden ist oder nicht.  Tatsächlich ist die Informationsentropie nicht im Signal selbst vorhanden, sondern eine quantitative Bewertung des a priori-Bewusstseins des Nachrichtenempfängers in Bezug auf die Nachricht selbst.  Das heißt, es geht nicht nur um das Signal, sondern auch um den Empfänger.  Wenn der Empfänger im Voraus überhaupt nichts über das Signal weiß, beträgt die Informationsentropie der übertragenen Binäreinheit genau 1 Bit, unabhängig davon, wie das Signal empfangen wurde und was es ist. </li><li>  Wir haben einen Entropieadditionssatz, nach dem die Gesamtentropie unabhängiger Quellen gleich der Summe der Entropien dieser Quellen ist.  Wenn wir die Hauptsequenz durch Verkettung mit der zusätzlichen Sequenz kombiniert hätten, hätten wir die Entropien der Quellen beibehalten, hätten aber ein schlechtes Ergebnis erzielt, da wir in unserer Aufgabe nicht die Gesamtentropie, sondern die spezifische Entropie in Bezug auf ein separates Bit bewerten müssen.  Die Verkettung von Quellen gibt uns die spezifische Entropie des Ergebnisses, die dem arithmetischen Mittel der Entropie der Quellen entspricht, und die entropieschwache zusätzliche Sequenz verschlechtert natürlich das Ergebnis.  Die Anwendung der XOR-Operation führt dazu, dass wir einen Teil der Entropie verlieren, aber die resultierende Entropie ist garantiert nicht schlechter als die maximale Entropie der Terme. </li><li>  Kryptographen haben ein Dogma: Die Verwendung von Pseudozufallszahlengeneratoren ist unverzeihliche Arroganz.  Weil diese Generatoren eine kleine spezifische Entropie haben.  Aber wir haben gerade herausgefunden, dass Entropie, wenn alles richtig gemacht wird, zu einem Fass Honig wird, das durch keine Menge Teer verdorben werden kann. </li><li>  Wenn wir nur 10 Bytes reale Entropie haben, verteilt auf ein Kilobyte Daten, haben wir aus formaler Sicht nur 1% der spezifischen Entropie, was sehr schlecht ist.  Aber wenn diese 10 Bytes qualitativ verschmiert sind und abgesehen von Brute Force keine Möglichkeit besteht, diese 10 Bytes zu berechnen, sieht nicht alles so schlecht aus.  10 Bytes sind 2 <sup>80</sup> , und wenn unsere Brute Force pro Sekunde eine Billion Optionen durchsucht, benötigen wir durchschnittlich 19.000 Jahre, um zu lernen, wie man das nächste Zeichen errät. </li></ol><br>  Wie oben erwähnt, ist die Informationsentropie ein relativer Wert.  Wenn für ein Subjekt die spezifische Entropie 1 ist, kann sie für ein anderes durchaus 0 sein. Außerdem hat eine mit 1 möglicherweise keine Möglichkeit, den wahren Stand der Dinge zu kennen.  Das System RNG erzeugt einen Stream, der für uns nicht von wirklich zufällig zu unterscheiden ist, aber wir können nur hoffen, dass er <i>für alle</i> wirklich zufällig ist.  Und glauben.  Wenn Paranoia darauf hindeutet, dass die Qualität des Haupt-RNG plötzlich unbefriedigend sein könnte, ist es sinnvoll, sich mit Hilfe eines zusätzlichen abzusichern. <br><br><h3>  Implementieren eines summierenden RNG in Python </h3><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Random, SystemRandom <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> BPF <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _BPF, RECIP_BPF <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _RECIP_BPF <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> reduce <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _reduce <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> operator <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> xor <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _xor <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompoundRandom</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(SystemRandom)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__new__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, *sources)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Positional arguments must be descendants of Random"""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> all(isinstance(src, Random) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sources): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> TypeError(<span class="hljs-string"><span class="hljs-string">"all the sources must be descendants of Random"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> super().__new__(cls) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *sources)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Positional arguments must be descendants of Random"""</span></span> self.sources = sources super().__init__() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getrandbits</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, k)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""getrandbits(k) -&gt; x. Generates an int with k random bits."""</span></span> <span class="hljs-comment"><span class="hljs-comment">########         : return _reduce(_xor, (src.getrandbits(k) for src in self.sources), 0) def random(self): """Get the next random number in the range [0.0, 1.0).""" ########  ,   SystemRandom   .  ... return self.getrandbits(_BPF) * _RECIP_BPF</span></span></code> </pre> <br>  Anwendungsbeispiel: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random_xe <span class="hljs-comment"><span class="hljs-comment"># &lt;&lt;&lt;    &gt;&gt;&gt; from random import Random, SystemRandom &gt;&gt;&gt; #  : &gt;&gt;&gt; myrandom1 = random_xe.CompoundRandom(SystemRandom(), Random()) &gt;&gt;&gt; #    Random: &gt;&gt;&gt; myrandom1.random() 0.4092251189581082 &gt;&gt;&gt; myrandom1.randint(100, 200) 186 &gt;&gt;&gt; myrandom1.gauss(20, 10) 19.106991205743107</span></span></code> </pre> <br>  SystemRandom, das als korrekt angesehen wird, wird als Hauptstrom und als Nebenstrom - als Standard-PRNG-Zufall - verwendet.  Der Punkt dabei ist natürlich nicht sehr viel.  Das Standard-PRNG ist definitiv nicht die Art von Ergänzung, für die es sich gelohnt hat, anzufangen.  Stattdessen können Sie zwei systemische RNGs zusammen heiraten: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>myrandom2 = random_xe.CompoundRandom(SystemRandom(), SystemRandom())</code> </pre> <br>  Der Sinn, die Wahrheit darin ist noch weniger (obwohl Bruce Schneier aus irgendeinem Grund aus irgendeinem Grund in der Angewandten Kryptographie empfiehlt), da die obigen Berechnungen nur für unabhängige Quellen gelten.  Wenn das System-RNG gefährdet ist, wird auch das Ergebnis beeinträchtigt.  Im Prinzip ist der Flug der Phantasie bei der Suche nach einer Quelle zusätzlicher Entropie nicht durch irgendetwas begrenzt (in unserer Welt ist Unordnung viel häufiger als Ordnung), aber als einfache Lösung werde ich das HashRandom PRSP anbieten, das auch in der random_xe-Bibliothek implementiert ist. <br><br><h3>  PRSPs basierend auf Streaming Circular Hashing </h3><br>  Im einfachsten Fall können Sie eine relativ kleine Menge von Anfangsdaten verwenden (z. B. den Benutzer bitten, auf der Tastatur zu trommeln), ihren Hash berechnen und dann den Hash zyklisch zur Eingabe des Hash-Algorithmus hinzufügen und die folgenden Hashes ausführen.  Schematisch kann dies wie folgt dargestellt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ka/fk/ei/kafkeiisv_tow0ib7kibsqwhbuy.png"></div><br><br>  Die kryptografische Stärke dieses Prozesses basiert auf zwei Annahmen: <br><br><ol><li>  Die Wiederherstellung der Originaldaten aus dem Hashwert ist unerträglich kompliziert. </li><li>  Mit dem Hash-Wert kann der interne Status des Hashing-Algorithmus nicht wiederhergestellt werden. </li></ol><br>  Nach Rücksprache mit einem internen Paranoiden erkannte er die zweite Annahme als unnötig an, und daher ist das Schema bei der endgültigen Umsetzung des PRNG etwas kompliziert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rv/mp/hz/rvmphzdunz3q25vy61tm65okwv4.png"></div><br><br>  Wenn es einem Angreifer nun gelingt, einen "Hash 1r" -Wert zu erhalten, kann er den ihm folgenden "Hash 2r" -Wert nicht berechnen, da er keinen "Hash 2h" -Wert hat, den er nicht erkennen kann, ohne die Hash-Funktion "gegen Wolle" zu berechnen.  Somit entspricht die kryptografische Stärke dieses Schemas der kryptografischen Stärke des verwendeten Hashing-Algorithmus. <br><br>  Anwendungsbeispiel: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-comment"><span class="hljs-comment">#  ,  HashRandom     '123': &gt;&gt;&gt; myrandom3 = random_xe.CompoundRandom(SystemRandom(), random_xe.HashRandom('123')) &gt;&gt;&gt; #    Random: &gt;&gt;&gt; myrandom3.random() 0.8257149881148604</span></span></code> </pre> <br>  Standardmäßig wird der SHA-256-Algorithmus verwendet.  Wenn Sie etwas anderes möchten, können Sie den gewünschten Typ des Hashing-Algorithmus mit dem zweiten Parameter an den Konstruktor übertragen.  Lassen Sie uns zum Beispiel ein zusammengesetztes RNG erstellen, das Folgendes in einem Haufen zusammenfasst: <br><br>  1. Systemisches RNG (das ist heilig). <br>  2. Benutzereingaben, die vom SHA3-512-Algorithmus verarbeitet werden. <br>  3. Die für diese Eingabe aufgewendete Zeit, die von SHA-256 verarbeitet wird. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> getpass <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getpass &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> perf_counter &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sha3_512 <span class="hljs-comment"><span class="hljs-comment">#    : &gt;&gt;&gt; def super_myrandom(): t_start = perf_counter() return random_xe.CompoundRandom(SystemRandom(), random_xe.HashRandom( getpass('  :'), sha3_512), random_xe.HashRandom(perf_counter() - t_start)) &gt;&gt;&gt; myrandom4 = super_myrandom()   : &gt;&gt;&gt; myrandom4.random() 0.35381173716740766</span></span></code> </pre> <br>  <b>Schlussfolgerungen:</b> <br><br><ol><li>  Wenn wir uns bei unserem Zufallszahlengenerator nicht sicher sind, können wir dieses Problem einfach und erstaunlich billig lösen. </li><li>  Wenn wir dieses Problem lösen, können wir es nicht schlimmer machen.  Nur besser.  Und es ist mathematisch bewiesen. </li><li>  Wir dürfen nicht vergessen, sicherzustellen, dass die verwendeten Entropiequellen unabhängig sind. </li></ol><br>  Die Bibliotheksquellen befinden sich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423093/">https://habr.com/ru/post/de423093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423083/index.html">Wie ich Entwickler bei ABBYY wurde</a></li>
<li><a href="../de423085/index.html">Feineinstellung des Lastausgleichs</a></li>
<li><a href="../de423087/index.html">Drück mir nicht ins Auge</a></li>
<li><a href="../de423089/index.html">Programmierer bei MBLT DEV 2018</a></li>
<li><a href="../de423091/index.html">Flattern für Android-Entwickler. So erstellen Sie eine Benutzeroberfläche für eine Aktivität mit Flutter</a></li>
<li><a href="../de423095/index.html">Was ist neu bei Apple Presentation?</a></li>
<li><a href="../de423097/index.html">Aufgaben und Lösungen für PostgreSQL Fighter</a></li>
<li><a href="../de423101/index.html">Bereitstellen von LINSTOR Storage für Proxmox</a></li>
<li><a href="../de423103/index.html">Python-Podcasts: Das ist alles, was wir gefunden haben</a></li>
<li><a href="../de423105/index.html">System.IO.Pipelines: Hochleistungs-E / A in .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>