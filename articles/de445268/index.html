<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📰 🍈 👩🏼‍✈️ GraphQL-Details: Was, wie und warum 🧓🏿 🎨 🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="GraphQL ist jetzt ohne Übertreibung der letzte Blick in den IT-Modus. Und wenn Sie noch nicht wissen, um welche Art von Technologie es sich handelt, w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GraphQL-Details: Was, wie und warum</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/445268/">  GraphQL ist jetzt ohne Übertreibung der letzte Blick in den IT-Modus.  Und wenn Sie noch nicht wissen, um welche Art von Technologie es sich handelt, wie Sie sie verwenden und warum sie für Sie nützlich sein kann, ist der Artikel, den wir heute veröffentlichen, für Sie geschrieben.  Hier werden die Grundlagen von GraphQL anhand eines Beispiels einer Datenschema-Implementierung für die API eines Popcorn-Unternehmens erläutert.  Lassen Sie uns insbesondere über Datentypen, Abfragen und Mutationen sprechen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/c7/oq/a1/c7oqa1w2b00akzatd2womwb_daw.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Was ist GraphQL?</font> </h2><br>  GraphQL ist eine Abfragesprache, die von Clientanwendungen zum Arbeiten mit Daten verwendet wird.  GraphQL ist mit einem solchen Konzept wie einem „Schema“ verbunden. Auf diese Weise können Sie das Erstellen, Lesen, Aktualisieren und Löschen von Daten in Ihrer Anwendung organisieren (dh wir haben vier Grundfunktionen, die bei der Arbeit mit Data Warehouses verwendet werden, die normalerweise mit dem Akronym CRUD bezeichnet werden - erstellen, lesen, aktualisieren, löschen). <br><br>  Es wurde oben gesagt, dass GraphQL verwendet wird, um mit Daten in "Ihrer Anwendung" und nicht "in Ihrer Datenbank" zu arbeiten.  Tatsache ist, dass GraphQL ein von Datenquellen unabhängiges System ist, dh es spielt keine Rolle, wo es organisiert ist, um seine Arbeit zu organisieren. <br><br>  Wenn Sie den Namen dieser Technologie betrachten, ohne etwas über GraphQL zu wissen, scheint es, als stünden wir vor etwas sehr Kompliziertem und Verwirrendem.  Der Name der Technologie hat das Wort "Graph".  Bedeutet dies, dass Sie lernen müssen, mit Graphendatenbanken zu arbeiten, um es zu beherrschen?  Und die Tatsache, dass der Name "QL" enthält (was "Abfragesprache", dh "Abfragesprache" bedeuten kann), bedeutet, dass diejenigen, die GraphQL verwenden möchten, eine völlig neue Programmiersprache lernen müssen? <br><br>  Diese Befürchtungen sind nicht ganz berechtigt.  Um Sie zu beruhigen - das ist die grausame Wahrheit über diese Technologie: Es handelt sich nur um verschönerte <code>GET</code> oder <code>POST</code> Anfragen.  Während GraphQL im Allgemeinen einige neue Konzepte in Bezug auf die Datenorganisation und die Interaktion mit GraphQL einführt, stützen sich die internen Mechanismen dieser Technologie auf die guten alten HTTP-Anforderungen. <br><br><h2>  <font color="#3AC1EF">REST-Technologie neu denken</font> </h2><br>  Flexibilität unterscheidet die GraphQL-Technologie von der bekannten REST-Technologie.  Wenn bei Verwendung von REST alles korrekt ausgeführt wird, werden Endpunkte normalerweise unter Berücksichtigung der Merkmale eines bestimmten Ressourcen- oder Anwendungsdatentyps erstellt. <br><br>  Wenn Sie beispielsweise eine <code>GET</code> Anforderung an den Endpunkt <code>/api/v1/flavors</code> ausführen <code>/api/v1/flavors</code> wird erwartet, dass eine Antwort gesendet wird, die ungefähr so ​​aussieht: <br><br><pre> <code class="plaintext hljs">[ {  "id": 1,   "name": "The Lazy Person's Movie Theater",   "description": "That elusive flavor that you begrudgingly carted yourself to the theater for, now in the comfort of your own home, you slob!" }, {   "id": 2,   "name": "What's Wrong With You Caramel",   "description": "You're a crazy person that likes sweet popcorn. Congratulations." }, {   "id": 3,   "name": "Gnarly Chili Lime",   "description": "The kind of popcorn you make when you need a good smack in the face."} ]</code> </pre> <br>  An dieser Antwort ist nichts Katastrophales auszusetzen, aber lassen Sie uns über die Benutzeroberfläche nachdenken, oder vielmehr darüber, wie wir diese Daten nutzen wollen. <br><br>  Wenn wir eine einfache Liste in der Benutzeroberfläche anzeigen möchten, die nur die Namen der verfügbaren Popcornsorten (und sonst nichts) enthält, sieht diese Liste möglicherweise wie die unten gezeigte aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a89/0fd/c56/a890fdc56389815233584327e76011c1.png"></div><br>  <i><font color="#999999">Liste der Popcorn-Typen</font></i> <br><br>  Es ist zu sehen, dass wir uns hier in einer schwierigen Situation befinden.  Wir werden uns vielleicht entscheiden, das <code>description</code> nicht zu verwenden, aber werden wir uns zurücklehnen und so tun, als hätten wir dieses Feld nicht an den Kunden gesendet?  Was können wir noch tun?  Und wenn sie uns nach einigen Monaten fragen, warum die Anwendung für Benutzer so langsam ist, müssen wir nur den Typen lassen und uns nicht mehr mit dem Management des Unternehmens treffen, für das wir diese Anwendung erstellt haben. <br><br>  Tatsächlich ist die Tatsache, dass der Server unnötige Daten als Antwort auf eine Clientanforderung sendet, nicht ganz unsere Schuld.  REST ist ein Datenerfassungsmechanismus, der mit einem Restaurant verglichen werden kann, in dem der Kellner den Besucher fragt: „Was wollen Sie?“ Und ohne seine Wünsche besonders zu berücksichtigen, sagt er ihm: „Ich werde Ihnen bringen, was wir haben.“ . <br><br>  Wenn wir Witze beiseite werfen, kann dies in realen Anwendungen zu Problemsituationen führen.  Beispielsweise können wir verschiedene zusätzliche Informationen zu jeder Popcornsorte anzeigen, z. B. Preisinformationen, Informationen zum Hersteller oder Nährwertangaben („Veganes Popcorn!“).  Gleichzeitig machen es unflexible REST-Endpunkte sehr schwierig, spezifische Daten zu bestimmten Popcornsorten zu erhalten, was zu einer unangemessen hohen Systembelastung und zu der Tatsache führt, dass die daraus resultierenden Lösungen weit von denen entfernt sind, auf die Entwickler stolz sein könnten. <br><br><h2>  <font color="#3AC1EF">Wie die GraphQL-Technologie verbessert, wofür die REST-Technologie verwendet wurde</font> </h2><br>  Eine oberflächliche Analyse der oben beschriebenen Situation scheint, dass wir nur ein kleines Problem sind.  "Was ist falsch daran, dem Client unnötige Daten zu senden?"  Denken Sie daran, dass GraphQL von Facebook entwickelt wurde, um zu verstehen, inwieweit „unnötige Daten“ ein großes Problem darstellen können.  Dieses Unternehmen muss Millionen von Anfragen pro Sekunde bearbeiten. <br><br>  Was bedeutet das?  Und die Tatsache, dass bei solchen Bänden alles zählt. <br><br>  GraphQL bringt genau das, was der Besucher bestellt, wenn wir die Analogie mit einem Restaurant fortsetzen, anstatt dem Besucher „was ist“ zu „tragen“. <br><br>  Wir können eine Antwort von GraphQL erhalten, die sich auf den Kontext konzentriert, in dem die Daten verwendet werden.  In diesem Fall müssen wir dem System keine einmaligen Zugriffspunkte hinzufügen, viele Anforderungen ausführen oder mehrstöckige bedingte Strukturen schreiben. <br><br><h2>  <font color="#3AC1EF">Wie funktioniert GraphQL?</font> </h2><br>  Wie bereits erwähnt, stützt sich GraphQL auf einfache <code>GET</code> oder <code>POST</code> Anforderungen, um Daten an den Client zu senden und von diesem zu empfangen.  Wenn wir diese Idee genauer betrachten, stellt sich heraus, dass es in GraphQL zwei Arten von Abfragen gibt.  Der erste Typ enthält Anforderungen zum Lesen von Daten, die in der GraphQL-Terminologie einfach als Abfragen bezeichnet werden und sich auf den Buchstaben R (Lesen, Lesen) des Akronyms CRUD beziehen.  Abfragen der zweiten Art sind Datenänderungsanforderungen, die in GraphQL als Mutationen bezeichnet werden.  Sie beziehen sich auf die Achskästen C, U und D des Akronyms CRUD, dh sie verwenden sie zum Erstellen, Erstellen, Aktualisieren und Löschen von Datensätzen. <br><br>  Alle diese Abfragen und Mutationen werden in Form von <code>GET</code> oder <code>POST</code> Anforderungen an die URL des GraphQL-Servers gesendet, die beispielsweise wie <code>https://myapp.com/graphql</code> aussehen kann.  Wir werden weiter unten mehr darüber sprechen. <br><br><h2>  <font color="#3AC1EF">GraphQL-Abfragen</font> </h2><br>  GraphQL-Abfragen sind Entitäten, die eine Anforderung an den Server darstellen, bestimmte Daten zu empfangen.  Zum Beispiel haben wir eine bestimmte Benutzeroberfläche, die wir mit Daten füllen möchten.  Für diese Daten wenden wir uns an den Server und führen die Anforderung aus.  Bei Verwendung herkömmlicher REST-APIs erfolgt unsere Anfrage in Form einer GET-Anfrage.  Bei der Arbeit mit GraphQL wird eine neue Abfragesyntax verwendet: <br><br><pre> <code class="plaintext hljs">{ flavors {   name } }</code> </pre> <br>  Ist das JSON?  Oder ein JavaScript-Objekt?  Weder der eine noch der andere.  Wie bereits erwähnt, bedeuten die letzten beiden Buchstaben QL im Namen der GraphQL-Technologie „Abfragesprache“, dh die Abfragesprache.  Dies ist buchstäblich eine neue Sprache zum Schreiben von Datenanforderungen.  All dies klingt nach einer Beschreibung von etwas ziemlich Kompliziertem, aber tatsächlich gibt es hier nichts Kompliziertes.  Lassen Sie uns die obige Abfrage analysieren: <br><br><pre> <code class="plaintext hljs">{ //    ,   . }</code> </pre> <br>  Alle Anforderungen beginnen mit einer „Stammanforderung“. Was Sie während der Ausführung der Anforderung benötigen, wird als Feld bezeichnet.  Um sich vor Verwirrung zu schützen, ist es am besten, diese Entitäten "Abfragefelder im Schema" zu nennen.  Wenn Ihnen ein solcher Name unverständlich erscheint - warten Sie ein bisschen -, werden wir weiter unten mehr über das Schema sprechen.  Hier fordern wir in der Stammabfrage das Feld <code>flavors</code> . <br><br><pre> <code class="plaintext hljs">{ flavors {   //  ,        flavor. } }</code> </pre> <br>  Wenn Sie ein bestimmtes Feld anfordern, müssen Sie auch die verschachtelten Felder angeben, die für jedes Objekt empfangen werden müssen, das als Antwort auf die Anforderung eingeht (auch wenn erwartet wird, dass nur ein Objekt als Antwort auf die Anforderung eingeht). <br><br><pre> <code class="plaintext hljs">{ flavors {   name } }</code> </pre> <br>  Was wird das Ergebnis sein?  Nachdem wir eine solche Anfrage an den GraphQL-Server gesendet haben, erhalten wir eine wohlgeformte Antwort wie die folgende: <br><br><pre> <code class="plaintext hljs">{ "data": {   "flavors": [     { "name": "The Lazy Person's Movie Theater" },     { "name": "What's Wrong With You Caramel" },     { "name": "Gnarly Chili Lime" }   ] } }</code> </pre> <br>  Bitte beachten Sie, dass nichts überflüssig ist.  Um dies klarer zu machen, wird hier eine weitere Anforderung ausgeführt, um Daten auf einer anderen Seite der Anwendung abzurufen: <br><br><pre> <code class="plaintext hljs">{ flavors {   id   name   description } }</code> </pre> <br>  Als Antwort auf diese Anfrage erhalten wir Folgendes: <br><br><pre> <code class="plaintext hljs">{ "data": {   "flavors": [     { "id": 1, "name": "The Lazy Person's Movie Theater", description: "That elusive flavor that you begrudgingly carted yourself to the theater for, now in the comfort of your own home, you slob!" },     { "id": 2, "name": "What's Wrong With You Caramel", description: "You're a crazy person that likes sweet popcorn. Congratulations." },     { "id": 3, "name": "Gnarly Chili Lime", description: "A friend told me this would taste good. It didn't. It burned my kernels. I haven't had the heart to tell him." }   ] } }</code> </pre> <br>  Wie Sie sehen können, ist GraphQL eine sehr leistungsfähige Technologie.  Wir wenden uns demselben Endpunkt zu, und die Antworten auf die Anforderungen entsprechen genau dem, was zum Ausfüllen der Seite erforderlich ist, von der aus diese Anforderungen ausgeführt werden. <br><br>  Wenn wir nur ein <code>flavor</code> Objekt benötigen, können wir die Tatsache nutzen, dass GraphQL mit Argumenten arbeiten kann: <br><br><pre> <code class="plaintext hljs">{ flavors(id: "1") {   id   name   description } }</code> </pre> <br>  Hier setzen wir den spezifischen Bezeichner ( <code>id</code> ) des Objekts im Code fest, die Informationen, die wir benötigen, aber in solchen Fällen können wir dynamische Bezeichner verwenden: <br><br><pre> <code class="plaintext hljs">query getFlavor($id: ID) { flavors(id: $id) {   id   name   description } }</code> </pre> <br>  Hier geben wir in der ersten Zeile der Anfrage einen Namen (der Name wird willkürlich gewählt, <code>getFlavor</code> kann durch etwas wie <code>pizza</code> werden und die Anfrage bleibt betriebsbereit) und deklarieren die Variablen, die die Anfrage erwartet.  In diesem Fall wird davon ausgegangen, dass der Bezeichner ( <code>id</code> ) der skalaren Typ- <code>ID</code> an die Anforderung übergeben wird (wir werden im Folgenden auf Typen eingehen). <br><br>  Unabhängig davon, ob beim Ausführen einer Anforderung eine statische oder eine dynamische <code>id</code> verwendet wird, sieht die Antwort auf eine ähnliche Anforderung folgendermaßen aus: <br><br><pre> <code class="plaintext hljs">{ "data": {   "flavors": [     { "id": 1, "name": "The Lazy Person's Movie Theater", description: "That elusive flavor that you begrudgingly carted yourself to the theater for, now in the comfort of your own home, you slob!" }   ] } }</code> </pre> <br>  Wie Sie sehen können, ist alles sehr bequem angeordnet.  Sie fangen wahrscheinlich an, über die Verwendung von GraphQL in Ihrem eigenen Projekt nachzudenken.  Und obwohl das, worüber wir bereits gesprochen haben, wunderbar aussieht, manifestiert sich die Schönheit von GraphQL wirklich dort, wo es mit verschachtelten Feldern funktioniert.  Angenommen, in unserem Schema gibt es ein anderes Feld namens <code>nutrition</code> , das Informationen über den Nährwert verschiedener Popcornsorten enthält: <br><br><pre> <code class="plaintext hljs">{ flavors {   id   name   nutrition {     calories     fat     sodium   } } }</code> </pre> <br>  Es scheint, dass in unserem Data Warehouse jedes <code>flavor</code> ein verschachteltes <code>nutrition</code> .  Dies ist jedoch nicht ganz richtig.  Mit GraphQL können Sie Aufrufe unabhängiger, aber verwandter Datenquellen in einer einzigen Abfrage kombinieren. Auf diese Weise erhalten Sie Antworten, mit denen Sie bequem mit eingebetteten Daten arbeiten können, ohne die Datenbank denormalisieren zu müssen: <br><br><pre> <code class="plaintext hljs">{ "data": {   "flavors": [     {       "id": 1,       "name": "The Lazy Person's Movie Theater",       "nutrition": {         "calories": 500,         "fat": 12,         "sodium": 1000       }     },     ...   ] } }</code> </pre> <br>  Dies kann die Produktivität des Programmiergeräts und die Geschwindigkeit des Systems erheblich steigern. <br><br>  Bisher haben wir über Leseanfragen gesprochen.  Was ist mit Datenaktualisierungsanfragen?  Geben wir ihnen den gleichen Komfort? <br><br><h2>  <font color="#3AC1EF">GraphQL-Mutationen</font> </h2><br>  Während GraphQL-Abfragen Daten laden, sind Mutationen dafür verantwortlich, Änderungen an den Daten vorzunehmen.  Mutationen können in Form des grundlegenden RPC-Mechanismus (Remote Procedure Call) zum Lösen verschiedener Aufgaben verwendet werden, z. B. zum Senden von Benutzerdaten an eine Drittanbieter-API. <br><br>  Bei der Beschreibung von Mutationen wird eine Syntax verwendet, die der beim Generieren von Abfragen verwendeten ähnelt: <br><br><pre> <code class="plaintext hljs">mutation updateFlavor($id: ID!, $name: String, $description: String) { updateFlavor(id: $id, name: $name, description: $description) {   id   name   description } }</code> </pre> <br>  Hier deklarieren wir die <code>updateFlavor</code> Mutation und geben einige Variablen an - <code>id</code> , <code>name</code> und <code>description</code> .  Nach dem gleichen Schema, das zur Beschreibung von Abfragen verwendet wird, erstellen wir Variablenfelder (Root-Mutation) mit dem Schlüsselwort <code>mutation</code> , gefolgt von einem Namen, der die Mutation beschreibt, und einer Reihe von Variablen, die zur Bildung der entsprechenden Datenänderungsanforderung erforderlich sind. <br><br>  Zu diesen Variablen gehört, was wir ändern möchten oder welche Mutation wir verursachen möchten.  Bitte beachten Sie auch, dass wir nach der Mutation die Rückgabe einiger Felder beantragen können. <br><br>  In diesem Fall müssen wir nach dem Ändern des Datensatzes die Felder <code>id</code> , <code>name</code> und <code>description</code> abrufen.  Dies kann nützlich sein, wenn Sie so etwas wie optimistische Schnittstellen entwickeln, sodass Sie keine Anforderung mehr erfüllen müssen, um geänderte Daten nach dem Ändern zu erhalten. <br><br><h2>  <font color="#3AC1EF">Entwerfen eines Schemas und Verbinden mit einem GraphQL-Server</font> </h2><br>  Bisher haben wir darüber gesprochen, wie GraphQL auf dem Client funktioniert und wie sie Abfragen ausführen.  Lassen Sie uns nun darüber sprechen, wie Sie auf diese Anfragen reagieren können. <br><br><h3>  <font color="#3AC1EF">▍GraphQL-Server</font> </h3><br>  Um eine GraphQL-Abfrage auszuführen, benötigen Sie einen GraphQL-Server, an den Sie eine solche Abfrage senden können.  Ein GraphQL-Server ist ein normaler HTTP-Server (wenn Sie in JavaScript schreiben, kann es sich um einen mit Express oder Hapi erstellten Server handeln), an den ein GraphQL-Diagramm angehängt ist. <br><br><pre> <code class="plaintext hljs">import express from 'express' import graphqlHTTP from 'express-graphql' import schema from './schema' const app = express() app.use('/graphql', graphqlHTTP({ schema: schema, graphiql: true })) app.listen(4000)</code> </pre> <br>  Mit "Beitreten" zu einem Schema meinen wir einen Mechanismus, der vom Client empfangene Anforderungen über das Schema weiterleitet und Antworten darauf zurückgibt.  Es ist wie ein Luftfilter, durch den Luft in den Raum gelangt. <br><br>  Der Prozess des "Filterns" ist mit Anforderungen oder Mutationen verbunden, die vom Client an den Server gesendet werden.  Sowohl Abfragen als auch Mutationen werden mithilfe von Funktionen aufgelöst, die sich auf die in der Stammabfrage oder in der Stammmutation des Schemas definierten Felder beziehen. <br><br>  Das obige Beispiel zeigt ein HTTP-Server-Framework, das mit der Express-JavaScript-Bibliothek erstellt wurde.  Mit der <code>graphqlHTTP</code> Funktion aus dem <code>express-graphql</code> von Facebook „hängen“ wir das Schema an (es wird angenommen, dass es in einer separaten Datei beschrieben wird) und führen den Server auf Port 4000 aus. Das heißt, Clients, die über die lokale Verwendung dieses Servers sprechen, können Anfragen über senden Adresse <code>http://localhost:4000/graphql</code> . <br><br><h3>  <font color="#3AC1EF">▍ Datentypen und Resolver</font> </h3><br>  Um den Betrieb des GraphQL-Servers sicherzustellen, müssen Sie das Schema vorbereiten und daran anhängen. <br><br>  Denken Sie daran, dass wir oben über das Deklarieren von Feldern in einer Root-Abfrage oder in einer Root-Mutation gesprochen haben. <br><br><pre> <code class="plaintext hljs">import gql from 'graphql-tag' import mongodb from '/path/to/mongodb' //  -  . ,  `mongodb`     MongoDB. const schema = { typeDefs: gql`   type Nutrition {     flavorId: ID     calories: Int     fat: Int     sodium: Int   }   type Flavor {     id: ID     name: String     description: String     nutrition: Nutrition   }   type Query {     flavors(id: ID): [Flavor]   }   type Mutation {     updateFlavor(id: ID!, name: String, description: String): Flavor   } `, resolvers: {   Query: {     flavors: (parent, args) =&gt; {       // ,  args  ,  { id: '1' }       return mongodb.collection('flavors').find(args).toArray()     },   },   Mutation: {     updateFlavor: (parent, args) =&gt; {       // ,  args    { id: '1', name: 'Movie Theater Clone', description: 'Bring the movie theater taste home!' }       //  .       mongodb.collection('flavors').update(args)       //  flavor  .       return mongodb.collection('flavors').findOne(args.id)     },   },   Flavor: {     nutrition: (parent) =&gt; {       return mongodb.collection('nutrition').findOne({         flavorId: parent.id,       })     }   }, }, } export default schema</code> </pre> <br>  Die Definition von Feldern in einem GraphQL-Schema besteht aus zwei Teilen - aus Typdeklarationen ( <code>typeDefs</code> ) und <code>resolver</code> .  Die <code>typeDefs</code> enthält Typdeklarationen für die in der Anwendung verwendeten Daten.  Zum Beispiel haben wir früher über eine Anfrage gesprochen, eine Liste von <code>flavor</code> Objekten vom Server zu erhalten.  Um eine ähnliche Anfrage an unseren Server zu stellen, müssen Sie die folgenden drei Schritte ausführen: <br><br><ol><li>  Teilen Sie dem Schema mit, wie die <code>flavor</code> Objektdaten aussehen (im obigen Beispiel sieht es aus wie eine Anzeige vom <code>type Flavor</code> ). </li><li>  Deklarieren Sie das Feld im Stammfeld vom <code>type Query</code> (dies ist die <code>flavors</code> Eigenschaft des <code>type Query</code> ). </li><li>  Deklarieren Sie eine <code>resolvers.Query</code> Objekterkennungsfunktion, die gemäß den im Stammfeld vom <code>type Query</code> deklarierten Feldern geschrieben wurde. </li></ol><br>  Lassen Sie uns nun auf <code>typeDefs</code> .  Hier geben wir dem Schema Informationen über die Form unserer Daten.  Mit anderen Worten, wir informieren GraphQL über die verschiedenen Eigenschaften, die in Entitäten des entsprechenden Typs enthalten sein können. <br><br><pre> <code class="plaintext hljs">type Flavor { id: ID name: String description: String nutrition: Nutrition }</code> </pre> <br>  Eine <code>type Flavor</code> Deklaration gibt an, dass ein <code>flavor</code> Objekt ein <code>id</code> Feld vom Typ <code>ID</code> , ein Namensfeld vom Typ <code>String</code> , ein <code>description</code> vom Typ <code>String</code> und ein <code>nutrition</code> vom Typ <code>Nutrition</code> . <br><br>  Im Falle der <code>nutrition</code> wir hier den Namen eines anderen Typs, der in <code>typeDefs</code> deklariert <code>typeDefs</code> .  Hier beschreibt der <code>type Nutrition</code> Konstrukt die Nährwertform von Popcorn. <br><br>  Beachten Sie, dass es sich hier wie ganz am Anfang dieses Materials um eine „Anwendung“ und nicht um eine „Datenbank“ handelt.  Im obigen Beispiel wird davon ausgegangen, dass wir eine Datenbank haben, die Daten in der Anwendung können jedoch aus einer beliebigen Quelle stammen.  Es kann sich sogar um eine API eines Drittanbieters oder eine statische Datei handeln. <br><br>  Genau wie in der <code>type Flavor</code> geben wir hier die Namen der Felder an, die in <code>nutrition</code> werden, wobei wir als Datentypen dieser Felder (Eigenschaften) das verwenden, was in GraphQL als skalare Datentypen bezeichnet wird.  Zum Zeitpunkt dieses Schreibens unterstützte GraphQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5 integrierte skalare Datentypen</a> : <br><br><ul><li>  <code>Int</code> : vorzeichenbehaftete 32-Bit-Ganzzahl. </li><li>  <code>Float</code> : Eine Gleitkommazahl mit doppelter Genauigkeit und einem Vorzeichen. </li><li>  Zeichenfolge: Eine in UTF-8 codierte Folge von Zeichen. </li><li>  <code>Boolean</code> : Boolean <code>true</code> oder <code>false</code> . </li><li>  <code>ID</code> : Eine eindeutige Kennung, die häufig zum wiederholten Laden von Objekten oder als Schlüssel im Cache verwendet wird.  Werte der Typ- <code>ID</code> wie Zeichenfolgen serialisiert. Ein Hinweis darauf, dass ein <code>ID</code> Typ einen Wert hat, wird jedoch dadurch hervorgehoben, dass dieser Wert nicht für Personen angezeigt werden soll, sondern für die Verwendung in Programmen. </li></ul><br>  Zusätzlich zu diesen Skalartypen können wir Typen, die wir selbst definieren, Eigenschaften zuweisen.  Dies ist genau das, was wir getan haben, indem wir die <code>nutrition</code> zugewiesen haben, die im <code>type Flavor</code> , Typ <code>Nutrition</code> . <br><br><pre> <code class="plaintext hljs">type Query { flavors(id: ID): [Flavor] }</code> </pre> <br>  Im Konstrukt vom Typ "Abfrage", das den Stammtyp der <code>Query</code> (die "Stammabfrage", über die wir zuvor gesprochen haben), deklarieren wir den Namen des Felds, das angefordert werden kann.  Durch Deklarieren dieses Felds geben wir zusätzlich zusammen mit dem Datentyp, den wir voraussichtlich zurückgeben, die Argumente an, die in der Anforderung enthalten sein können. <br><br>  In diesem Beispiel erwarten wir einen möglichen Empfang des <code>id</code> Arguments einer skalaren Typ- <code>ID</code> .  Als Antwort auf eine solche Anfrage wird ein Array von Objekten erwartet, deren Gerät einem Gerät vom Typ <code>Flavor</code> ähnelt. <br><br><h3>  <font color="#3AC1EF">▍Verbinden des Abfrageerkenners</font> </h3><br>  Nachdem wir nun eine Feldtypdefinition in der <code>type Query</code> , müssen wir beschreiben, was als Resolverfunktion bezeichnet wird. <br><br>  —  ,  GraphQL,   , «».      <code>resolvers</code> ,     <code>Query</code> ,   ,      <code>flavors</code> ,   .        <code>flavors</code> ,     <code>type Query</code> . <br><br><pre> <code class="plaintext hljs">typeDefs: gql`…`, resolvers: { Query: {   flavors: (parent, args) =&gt; {     // ,  args    { id: '1' }     return mongodb.collection('flavors').find(args).toArray()   }, }, … },</code> </pre> <br>  -   .  <code>parent</code> —   ,   ,  <code>args</code>      ,   .      <code>context</code> ,      .       «»  ( —        ,       ). <br><br>     ,    ,   .   GraphQL « »          . , ,      . <br><br>  GraphQL      ,      ,    .    JSON-,  JSON-,  (  GraphQL   ). <br><br>    -   <code>flavors</code>   MongoDB,  <code>args</code> (    )   <code>.find()</code>   ,        ,   . <br><br><h3> <font color="#3AC1EF">▍    </font> </h3><br>     -,   GraphQL,  , ,   ,      <code>nutrition</code> .   ,  ,   <code>Nutrition</code> , ,   ,      ,   <code>flavor</code> .      ,       /  . <br><br>    GraphQL  ,  <code>type Flavor</code>      <code>nutrition</code>   <code>type Nutrition</code> ,          .  ,    ,      <code>flavor</code> . <br><br><pre> <code class="plaintext hljs">typeDefs: gql`   type Nutrition {     flavorId: ID     calories: Int     fat: Int     sodium: Int   }   type Flavor {     […]     nutrition: Nutrition   }   type Query {…}   type Mutation {…} `, resolvers: {   Query: {     flavors: (parent, args) =&gt; {…},   },   Mutation: {…},   Flavor: {     nutrition: (parent) =&gt; {       return mongodb.collection('nutrition').findOne({         flavorId: parent.id,       })     }   }, },</code> </pre> <br>      <code>resolvers</code>  ,   ,      <code>Query</code> , <code>Mutation</code>  <code>Flavor</code> .   ,      <code>typeDefs</code> . <br><br>     <code>Flavors</code> ,  ,   <code>nutrition</code>     -.       ,        <code>Flavor</code> .  ,   : « ,     <code>nutrition</code>     ,  <code>type Flavor</code> ». <br><br>         MongoDB,      ,     <code>parent</code> ,  -. ,     <code>parent</code> ,   ,    ,   <code>flavors</code> . ,      <code>flavor</code> ,    : <br><br><pre> <code class="plaintext hljs">{ flavors {   id   name   nutrition {     calories   } } }</code> </pre> <br>   <code>flavor</code> ,   <code>flavors</code> ,     <code>nutrition</code> ,        <code>parent</code> .     ,  ,  ,    MongoDB,   <code>parent.id</code> ,    <code>id</code>  <code>flavor</code> ,       . <br><br>  <code>parent.id</code>      ,     <code>nutrition</code>   <code>flavorId</code> ,     <code>flavor</code> . <br><br><h3> <font color="#3AC1EF">▍ </font> </h3><br> ,      ,     .   ,          .      <code>type Mutation</code> ,   ,       <code>updateFlavor</code> ,  ,   . <br><br><pre> <code class="plaintext hljs">type Mutation { updateFlavor(id: ID!, name: String, description: String): Flavor }</code> </pre> <br>     : « ,   <code>updateFlavor</code>  <code>id</code>  <code>ID</code> ( , <code>!</code> ,  GraphQL  ,    ), <code>name</code>  <code>String</code>  <code>description</code>  <code>String</code> ».  ,         ,     <code>Flavor</code> (  — ,    <code>id</code> , <code>name</code> , <code>description</code> , , , <code>nutrition</code> ). <br><br><pre> <code class="plaintext hljs">{ typeDefs: gql`…`, resolvers: {   Mutation: {     updateFlavor: (parent, args) =&gt; {       // ,  args    { id: '1', name: 'Movie Theater Clone', description: 'Bring the movie theater taste home!' }       //  .       mongodb.collection('flavors').update(         { id: args.id },         {           $set: {             ...args,           },         },       )       //  flavor  .       return mongodb.collection('flavors').findOne(args.id)     },   }, }, }</code> </pre> <br>  -   <code>updateFlavor</code>    ,      :       ,    ,   — ,      <code>flavor</code> . <br><br>    ,               ,       <code>flavor</code>     .   ? <br><br>   ,          ,        .     ,     <code>flavor</code> ,     . <br><br>      <code>args</code> ?  Ja, das kannst du. ,          ,   ,      100%   ,         .       ,    ,  ,     ,      ,    . <br><br><h2> <font color="#3AC1EF">    GraphQL?</font> </h2><br>  ,      ,    ,     ,   , GraphQL-API. <br><br>        ,     GraphQL      ,      .  ,         .        ,    .  , ,   ,   GraphQL      REST      .  ,   ,           ,     GraphQL. <br><br><h3> <font color="#3AC1EF">▍    ,   </font> </h3><br>     ,       HTTP-,  ,      ,   ,   —  .       GraphQL       ,  ,    ,     ,     (            ). <br><br>        ,  ,     ( —         ),  GraphQL      . <br><br><h3> <font color="#3AC1EF">▍    ,    ,       </font> </h3><br>  ,       ,    « ».      , ,   ,   .        .   GraphQL         . <br><br><h3> <font color="#3AC1EF">▍     ,       </font> </h3><br>          REST API,          :  ,    . ,      -,   iOS  Android,   API  .    ,  , ,   , «   »    . <br><br>    ,   ,   ,   HTTP,              API (, ,   ). <br><br><h3> <font color="#3AC1EF">▍   GraphQL —   ?        REST API    GraphQL?</font> </h3><br>  Nein, natürlich.   . ,  ,   GraphQL     .       GraphQL,     .       ,      ,      ,           .     ,      ,     . <br><br> ,  GraphQL  ,  ,      ,  .    GraphQL    ,      Apollo  Relay,       . <br><br> GraphQL — ,  ,   .   <code>graphql</code> (     <code>express-graphql</code> ,    ) —      .  ,   GraphQL      -  .      ,     -,   ,  ,     ,    . <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>   ,   GraphQL    ,           . GraphQL      ,    , ,  .  , ,       ,        ,       GraphQL. <br><br> ,       : GraphQL   .              GraphQL  . ,     GraphQL,      ,  , ,  ,  ,  ,  . <br><br>  —   ,  GraphQL — ,   ,   .  GraphQL       ,   .    ,  GraphQL —  ,  , ,  .           .  ,       ,      ,   ,     ,      ,      GraphQL. <br><br>  <b>Liebe Leser!</b>        GraphQL —     ,         . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445268/">https://habr.com/ru/post/de445268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445258/index.html">So löschen Sie Ihre Daten sicher von Ihrem Android-Smartphone, bevor Sie sie verkaufen</a></li>
<li><a href="../de445260/index.html">Werden sich Roboter jemals wirklich erkennen? Wissenschaftler bewegen sich in diese Richtung.</a></li>
<li><a href="../de445262/index.html">GeekUniversity eröffnet Rekrutierung in der Big Data-Abteilung für Analytik</a></li>
<li><a href="../de445264/index.html">Preload, Prefetch und andere Tags</a></li>
<li><a href="../de445266/index.html">GeekBrains wird zusammen mit Rostelecom den IoT Hackathon durchführen</a></li>
<li><a href="../de445270/index.html">[Lesezeichen] Bash für Anfänger: 21 nützlicher Befehl</a></li>
<li><a href="../de445272/index.html">JavaScript ist die beste Programmiersprache für Anfänger. So ist es oder nicht?</a></li>
<li><a href="../de445274/index.html">Wenn "Zoë"! == "Zoë" oder warum Sie Unicode-Strings normalisieren müssen</a></li>
<li><a href="../de445276/index.html">Vollständiges UseEffect-Handbuch</a></li>
<li><a href="../de445278/index.html">So erstellen Sie ein Spiel, wenn Sie noch nie Künstler sind</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>