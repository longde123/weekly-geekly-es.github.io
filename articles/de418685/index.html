<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏿 🐙 ☝️ Prozedurale Level-Generierung 😋 🧕🏽 🌵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Arbeit an Programmierung, Grafik und Sound in einigen neuen Spielen ist beendet - es bleiben nur Levels übrig. Einfache und angenehme Arbeit, aber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prozedurale Level-Generierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418685/"><p><img src="https://habrastorage.org/webt/2m/0y/gv/2m0ygvmlc1izxgmo4chumrammxi.png"></p><br><p>  Die Arbeit an Programmierung, Grafik und Sound in <em>einigen neuen Spielen ist beendet</em> - es bleiben nur Levels übrig.  Einfache und angenehme Arbeit, aber aus irgendeinem Grund mit großen Schwierigkeiten verbunden.  Vielleicht die Wirkung von allgemeiner Müdigkeit. </p><br><p>  Als er überlegte, wie er sein Leben vereinfachen könnte, kam ihm die Idee der prozeduralen Generierung in den Sinn.  Natürlich muss es auch geschrieben werden, aber wie in einem bekannten Werk gesagt wurde: "Es ist besser, einen Tag zu verlieren und dann in fünf Minuten zu fliegen." </p><br><p>  <strong>Achtung!</strong>  <strong>Unter dem Schnitt viel Text und "fette" Gifs.</strong> </p><a name="habracut"></a><br><h2 id="vvodnaya">  Einführung </h2><br><p>  Die Ebenen werden weiterhin manuell poliert, sodass keine besonderen Anforderungen an Speicher, Geschwindigkeit oder sogar die Qualität der resultierenden Ebenen bestehen. </p><br><p>  Anfangs hatte ich geplant, dass der Generator nur Räume und Türen wirft und alle weiteren Verfeinerungen (Handlung, Szenerie und Feinde) im manuellen Modus durchgeführt werden.  Aber im Moment kann der Generator noch viel mehr.  Trotzdem bleibt die manuelle Abstimmung bestehen - es ist notwendig, dass die Spieler das Gefühl haben, dass zumindest ein wenig Liebe in die Levels investiert wird. </p><br><p>  Ich habe mir meine Wissensbasis über Spieleentwickler angesehen und in einem separaten Dokument Links zu Artikeln über die prozedurale Generierung geschrieben.  Bei den meisten geht es natürlich darum, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">klassische Labyrinthe</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gelände zu erzeugen</a> (die Ergebnisse sind übrigens sehr beeindruckend), was für einen 3D-Shooter nicht geeignet ist.  Aber einige waren nah an dem, was ich brauchte (mit einem Sternchen notierte ich diejenigen, die mir am besten geeignet erschienen): </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.progamer.ru/dev/procedural-dungeon-generation.htm</a> (*) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/post/333692/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://www.gamasutra.com/blogs/GrahamDavis/20170130/290326/Procedural_Level_Generation_in_Unity_for_MERC_part_1_of_2.php</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://ijdykeman.github.io/ml/2017/10/12/wang-tile-procedural-generation.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/post/332832/</a> (*) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/post/184818/</a> (*) </li></ul><br><p>  Ich habe beschlossen, mit den letzten beiden zu beginnen - sie werden gerade implementiert und liefern gute Ergebnisse. </p><br><h2 id="struktura-generatora">  Generatorstruktur </h2><br><p>  Tatsächlich bin ich nicht sofort zu dieser Struktur gekommen, sondern habe gerade zahlreiche Umgestaltungen und Umschreibungen vorgenommen, aber ich schreibe sofort darüber, damit klar ist, was los ist: </p><br><ol><li>  Generierung der Anfangsgeometrie (zur Auswahl - entweder "BSP" oder Raumaufteilung). </li><li>  Löschen von Müllabschnitten (solche Abschnitte, die im Spiel nicht existieren können). </li><li>  Verbindungen aufbauen. </li><li>  Löschen von Müll-Untergraphen (solche Gruppen von Abschnitten, die miteinander verbunden sind, aber keine Verbindung zu den verbleibenden Abschnitten bestehen). </li><li>  Löschen unnötiger Verbindungen (beim Erstellen eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spanning Tree</a> wird eine Verknüpfung zum <strong>Minimum</strong> Spanning Tree hergestellt, da dort ein Bild vorhanden ist, für den Generator jedoch kein Minimum erforderlich ist). </li><li>  Die Randomisierung von Verbindungen ist die Wiederherstellung einiger entfernter Verbindungen zurück (für eine „menschlichere“ Art von Ebene) sowie die Umwandlung einiger anderer in Passagen zwischen Abschnitten (wodurch mehrere Abschnitte zu einer komplexeren Form zusammengeführt werden). </li><li>  Geheime Raumgeneration. </li><li>  Generierung eines „Szenarios“ (wo befinden sich der Anfangs- und der Endabschnitt und welcher Pfad muss übergeben werden, um vom Anfang zum Finale zu gelangen). </li><li>  Verbindungsoptimierung. </li><li>  Türen und Fenster erstellen. </li><li>  Die Auswahl der in diesem Abschnitt auszuführenden Aktion (Drücken Sie den Schalter, heben Sie den Schlüssel oder suchen Sie die geheime Wand). </li></ol><br><p>  Es gibt noch ungefähr 12 Punkte, aber sie sind noch nicht abgeschlossen (wenn ich fertig bin, werde ich einen separaten Beitrag darüber schreiben). </p><br><h2 id="generaciya-iznachalnoy-geometrii-bsp">  Anfängliche Geometrieerzeugung: "BSP" </h2><br><p><img src="https://habrastorage.org/webt/zn/j4/_k/znj4_kemnzlvr4cfr45tqtzami8.gif"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diese Übersetzung</a> wurde als Grundlage genommen.  Ich bin mir nicht sicher, wie viel in diesem Algorithmus in der Nähe des tatsächlichen BSP passiert, daher schreibe ich "BSP" in Anführungszeichen. </p><br><p>  Der Algorithmus ist recht einfach.  Erstellen Sie zunächst ein Rechteck mit der Größe des gesamten Spielfelds: </p><br><p><img src="https://habrastorage.org/webt/fh/mx/x-/fhmxx-boo4euwsc4dl2g0gfc2nk.png"></p><br><p>  Dann teilen wir es zufällig in zwei Teile - entweder horizontal oder vertikal.  Wo die Trennlinie stattfinden wird, wählen wir auch zufällig aus: </p><br><p><img src="https://habrastorage.org/webt/ml/lo/jm/mllojmhd2qxiga7ma_skqxqoera.png"></p><br><p>  Wir machen das gleiche rekursiv für die neuen Rechtecke: </p><br><p><img src="https://habrastorage.org/webt/ew/sw/wf/ewswwfagu3jcskhcebem5sd-jo8.png"></p><br><p>  Und bis zu einem gewissen Grad immer wieder: </p><br><p><img src="https://habrastorage.org/webt/fl/s-/hd/fls-hd2xm17ghbjbvnwpyhwzd_m.png"></p><br><p>  Dann wählen wir in jedem Rechteck einen „Raum“ aus - ein Rechteck mit der gleichen Größe wie das Original oder kleiner (aber nicht weniger als 3x3 - mehr dazu weiter unten). </p><br><p><img src="https://habrastorage.org/webt/r8/h1/_y/r8h1_yacj5bpuux_xmmxuwzdlo0.png"></p><br><p>  Dann sind die Räume durch Korridore verbunden.  Aber nicht jeder, aber ein wenig knifflig, weil sie in einer "BSP" -ähnlichen Struktur gespeichert sind (siehe den ursprünglichen Algorithmus für weitere Details). </p><br><p><img src="https://habrastorage.org/webt/5t/y6/3e/5ty63ewmz5eey4oaphja4uixjuu.png"><br>  <em>Der Korridor verbindet die lila und weißen Bereiche.</em> </p><br><p>  In dem ursprünglichen Algorithmus haben sowohl Räume als auch Korridore die gleiche Farbe (d. H. Sie sind äquivalent), so dass dort die Korridore einfach über die Räume gezeichnet werden.  In meinem Fall sollten die ursprünglichen Räume erhalten bleiben, damit die Korridore wie "hinter" den Räumen gezeichnet werden. </p><br><p>  Wenn der Raum (in der Abbildung türkis) den Korridor überquert, sollte er ihn in zwei verschiedene Abschnitte unterteilen (daher kann derselbe Korridor in verschiedenen Farben gezeichnet werden): </p><br><p><img src="https://habrastorage.org/webt/5n/wr/51/5nwr510wdeg8x9iw3cgy_eorsau.png"></p><br><p>  Und hier ist das Ergebnis: </p><br><p><img src="https://habrastorage.org/webt/q4/hq/7r/q4hq7rocs2amqbt-guzspzcmbp4.png"></p><br><p>  Dann beginnt die Phase des Markierens von Müllzellen: </p><br><p><img src="https://habrastorage.org/webt/f0/ob/sc/f0obscdf1tabhec9mxv4m-wrj5s.png"></p><br><p>  Wie ich bereits geschrieben habe, kann kein Sektor kleiner als 3x3-Zellen sein.  Dies liegt an der Tatsache, dass der Sektor von Wänden umgeben sein muss (mindestens 1 Zelle auf jeder Seite) und mindestens eine Zelle mit freiem Raum haben muss: </p><br><p><img src="https://habrastorage.org/webt/iy/e8/ne/iye8ne6qltvzxtwrpgrtjgmgeae.png"></p><br><p>  Daher sind alle Zellen gekennzeichnet, die dieser Regel nicht entsprechen.  Aber nimm es einfach und du kannst sie nicht entfernen - so viele Verbindungen verschwinden und das Level ist sehr spärlich. </p><br><p>  Stattdessen wird für jede markierte Zelle nach dem Sektor gesucht, dem sie beitreten kann (unter Beachtung der 3x3-Regel): </p><br><p><img src="https://habrastorage.org/webt/nc/6q/-y/nc6q-yh8jlkx_rhlilpamtzt27s.png"><br>  <em>Wenn die Zelle immer noch keinem Sektor zugeordnet werden kann, wird sie gelöscht (aber in diesem Fall nicht - hier ist alles in Ordnung).</em> </p><br><p>  In der letzten Phase wird dieses schöne Bild vektorisiert und die gezeichneten Sektoren werden zu Polyboxen - solchen Polygonen, bei denen jede Kante entweder streng vertikal oder streng horizontal ist (es gibt wahrscheinlich einen wissenschaftlicheren Namen): </p><br><p><img src="https://habrastorage.org/webt/xx/8x/8v/xx8x8vpyawz-uricpycndaadgfy.png"></p><br><h2 id="generaciya-iznachalnoy-geometrii-planirovka-pomescheniy">  Erste Geometrieerzeugung: Raumaufteilung </h2><br><p><img src="https://habrastorage.org/webt/7w/jh/nb/7wjhnbk6xzc6zmdaqyiufpq7t5m.gif"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein weiterer Artikel</a> wurde als Grundlage genommen.  Dieser Algorithmus ist etwas komplizierter als der vorherige, aber auch keine Raketenwissenschaft. </p><br><p>  Zuerst wird das Spielfeld mit einem bestimmten Stoppwert gefüllt, und dann wird zufällig ein rechteckiger Bereich darauf gelöscht: </p><br><p><img src="https://habrastorage.org/webt/4n/24/py/4n24pyropjvmm0d8gsmzj9znte0.png"></p><br><p>  Die Stufe des Reinigens eines zufälligen Rechtecks ​​wird einige Male (auch zufällig) ausgeführt, und als Ergebnis werden die Außenkonturen des Niveaus erhalten: </p><br><p><img src="https://habrastorage.org/webt/np/4v/fi/np4vfi_iumlrznv8bsy8ba3babk.png"></p><br><p>  Im freien Raum werden die Raumwachstumspunkte zufällig verteilt (die Mindestraumgröße beträgt 3x3): </p><br><p><img src="https://habrastorage.org/webt/2y/wm/3n/2ywm3n3lgak23tcn0dmyshbicne.png"></p><br><p>  Die erste Phase des Raumwachstums beginnt - für jeden Raum wird die größte Seite ausgewählt, die noch wachsen kann, und sie wächst um 1 Zelle (wenn es mehrere Seiten mit derselben Länge gibt - eine zufällige).  Die Räume werden der Reihe nach so verschoben, dass es keine Kreuzungen gibt. </p><br><p><img src="https://habrastorage.org/webt/-b/4r/cd/-b4rcdczwe-_hu8xvha_cko1ihk.gif"></p><br><p>  Dann werden die Räume in Polyboxen umgewandelt: </p><br><p><img src="https://habrastorage.org/webt/pd/j8/qo/pdj8qos36_hf4slo-jlm2eailsw.png"></p><br><p>  Und die zweite Wachstumsphase beginnt - in dieser Phase kann die Seite in mehrere Teile unterteilt werden.  Im Gegensatz zur ersten Stufe wächst nicht eine Zelle nach der anderen, sondern sofort bis zum maximalen Stopp - dies vermeidet die "Leiter" an den Fugen der Räume.  Wenn nach dem Durchgang durch alle Räume noch leere Zellen vorhanden sind, wird der Zyklus wiederholt. </p><br><p>  Das Ergebnis ist ein vollständig gefüllter Raum: </p><br><p><img src="https://habrastorage.org/webt/mi/8j/zf/mi8jzfzhpksr2cz7jzd1_k3gmng.png"></p><br><p>  Dann werden Polyboxen in Form eines Rasters gezeichnet, und (wie im Fall des "BSP" -Generators) beginnt die Phase des Markierens von "Müll" -Zellen: </p><br><p><img src="https://habrastorage.org/webt/ev/na/ru/evnaruhyjwsei7hfbywiiuxyzq4.png"></p><br><p>  Und sie mit bestehenden Sektoren verbinden: </p><br><p><img src="https://habrastorage.org/webt/1h/yv/kf/1hyvkfcnerw5yu30txvbztecfzw.png"><br>  <em>Hier konnten nicht alle Zellen angebracht werden - die zusätzlichen wurden entfernt.</em> </p><br><p>  Das Ergebnis wird wieder in Polyboxen konvertiert: </p><br><p><img src="https://habrastorage.org/webt/ji/l3/yq/jil3yqqnbqpf4cfjyx-sklb_g8w.png"></p><br><h2 id="ochistka-ot-musornyhsekciy">  Reinigung von Müllabschnitten </h2><br><p>  Manchmal entstehen Abschnitte, in denen die 3x3-Regel nicht eingehalten wird: </p><br><p><img src="https://habrastorage.org/webt/6v/zx/2v/6vzx2vnhvhn_kkxvqp1jyzenh6g.png"></p><br><p>  Sie können versuchen, solche Abschnitte "wiederherzustellen", aber ich bin den einfacheren Weg gegangen und habe sie einfach gelöscht: </p><br><p><img src="https://habrastorage.org/webt/gc/5s/4y/gc5s4yzeywvc6pi1kh0apfk90pm.png"></p><br><h2 id="postroenie-soedineniy">  Verbindungen aufbauen </h2><br><p><img src="https://habrastorage.org/webt/af/3m/w2/af3mw25mgkjtqwskriypbpzzaeo.gif"></p><br><p>  Für jeden Abschnitt werden seine Nachbarn durchsucht, und an den Kontaktstellen dieser Abschnitte werden Verbindungen hergestellt.  Auf beiden Seiten werden Verbindungen hergestellt. Wenn Abschnitt A mit Abschnitt B in Kontakt steht, besteht eine Verbindung von A nach B und von B nach A. Das Ergebnis ist ein bidirektionaler Graph. </p><br><h2 id="ochistka-ot-musornyh-podgrafov">  Löschen von Müll-Untergraphen </h2><br><p>  Manchmal erhalten wir als Ergebnis der Reinigung von Müllabschnitten nicht ein Diagramm, sondern mehrere unabhängige, wie in diesem Beispiel: </p><br><p><img src="https://habrastorage.org/webt/yi/s5/5u/yis55urvft0bohq8x0dsurgyyam.png"></p><br><p>  In diesem Fall wird der Untergraph als Hauptgraph ausgewählt, dessen "Fläche" der Abschnitte maximal ist, und der Rest wird gelöscht (die "Fläche" steht in Anführungszeichen, da ich zwar die reale Fläche der Polybox berechnen kann, die Aufgabe jedoch vereinfacht habe und die Fläche des Begrenzungsrahmens betrachte - das ist falsch, aber für einen Generator geeignet). </p><br><h2 id="ochistka-ot-izlishnih-soedineniy">  Überschüssige Verbindungen entfernen </h2><br><p>  Wenn es einen Durchgang von jedem Sektor zu jedem gibt, mit dem er verbunden ist, gibt es zu viele Türen auf der Ebene, und es ist stärker zu spüren, dass er erzeugt wird.  Daher werden in diesem Stadium überschüssige Verbindungen entfernt: </p><br><p><img src="https://habrastorage.org/webt/oa/sh/oy/oashoyuavho98281lo_s4hpc-ks.gif"></p><br><p>  Für mehr Randomisierung generiere ich keinen Spanning Tree in der minimalen Anzahl von Durchgängen, sondern lösche jeweils eine zufällige Kante (wähle sie zufällig aus allen im aktuellen Schritt möglichen aus). </p><br><p>  <em>Obwohl, als ich dies schrieb, die Idee schien, dass es ziemlich zufällig wäre, den anfänglichen Sektor auszuwählen und die Kanten zu entfernen, die bereits effizienter sind.</em> </p><br><h2 id="randomizaciya-soedineniy">  Verbindungs-Randomisierung </h2><br><p><img src="https://habrastorage.org/webt/ok/zl/vk/okzlvk4rclc7x3imkpjnjza3kje.gif"><br>  <em>Im Folgenden werden Illustrationen von einer anderen Generation stammen, weil</em>  <em>im vorherigen gab es einen Fehler im Generator, aufgrund dessen weitere Bilder falsch waren.</em> </p><br><p>  Aber eine Ebene, in der es keine einzige überflüssige Verbindung gibt, sieht auch nicht sehr menschlich aus, so dass ein gewisses Chaos entsteht: </p><br><ol><li>  Einige gelöschte Kanten werden wiederhergestellt. </li><li>  Und manche verwandeln sich in Gänge. </li></ol><br><p>  Ferner verschmelzen die Abschnitte, zwischen denen die Passagen gebildet wurden, zu einem: </p><br><p><img src="https://habrastorage.org/webt/nh/j_/uj/nhj_ujd0n7sqjdnddlvs9uozq5u.gif"><br>  <em>Wenn es Ihnen so vorkam, als ob in dieser Abbildung die im vorherigen Schritt gelöschten Verbindungen wieder auftauchten - es schien Ihnen :).</em>  <em>Als ich den Text las, kam es mir auch so vor, aber nachdem ich mir die vorherige Abbildung genau angesehen habe, wird klar, dass alles in Ordnung ist.</em> </p><br><h2 id="generaciya-sekretnyh-komnat">  Geheime Raumgenerierung </h2><br><p>  Sektoren mit nur einer Verbindung werden in der Grafik ausgewählt: </p><br><p><img src="https://habrastorage.org/webt/xt/ku/qw/xtkuqweqgctwcbcckilick4-es4.png"></p><br><p>  Wenn es mehrere solcher Sektoren gibt, werden sie alle in einem Array zusammengefasst und nach "Bereich" sortiert.  Dann wird dieses Array zufällig abgeschnitten (so dass mindestens ein Element darin verbleibt).  Diese Sektoren werden zu geheimen Räumen: </p><br><p><img src="https://habrastorage.org/webt/pf/w0/yu/pfw0yufvv3orwiw_xohtfii8gqi.png"></p><br><h2 id="generaciya-scenariya">  Skriptgenerierung </h2><br><p><img src="https://habrastorage.org/webt/p2/ql/dn/p2qldn0n-scgjotykszlvsvd05a.gif"></p><br><p>  Zunächst werden die Sektoren mit der minimalen Anzahl freier Verbindungen (dh diejenigen, die näher an der "Kante" des Diagramms liegen) ausgewählt: </p><br><p><img src="https://habrastorage.org/webt/lc/iw/7v/lciw7vahyrhoirla-hyahd7jzhu.png"><br>  <em>In dieser Abbildung wird ein Sektor ausgewählt, aber wenn es mehr gäbe, würde ohnehin einer ausgewählt (zufällig).</em> </p><br><p>  <em>NB.</em>  <em>Während des Korrekturlesens des Artikels konnte ich eine Situation feststellen, in der ein Sektor mit einer minimalen Anzahl freier Verbindungen nicht nur nicht am Rande steht, sondern auch das Zuweisen eines Skripts zu einem unpassierbaren Level führt.</em>  <em>Tatsächlich können Sie jeden Sektor auswählen, aber nur einen. Danach würde das Diagramm nicht mehr in mehrere Untergraphen unterteilt.</em> </p><br><p>  Wählen Sie als Nächstes Sektoren aus, die mit dem aktuellen Sektor verbunden sind und nur eine freie Verbindung haben.  Sie werden mit einiger Wahrscheinlichkeit verwendet, um das Skript fortzusetzen.  Wenn das Diagramm beispielsweise das gleiche wie in der folgenden Abbildung wäre, könnte der durch die Frage angegebene Sektor in die Liste aufgenommen werden. </p><br><p><img src="https://habrastorage.org/webt/6u/b6/vf/6ub6vfbxncsmbug4optzec19gyw.png"><br>  <em>Der geheime Raum ist grau markiert, die Kreuze sind die Verbindungen, die im Originaldiagramm entfernt werden sollten, und der Quellsektor ist ein Plus.</em> </p><br><p>  <em>NB.</em>  <em>Während des Korrekturlesens des Artikels schien es mir, dass die Bedingung für das Vorhandensein nur einer Verbindung zu streng war, genau wie im vorherigen Schritt - damit das Diagramm nach dem Löschen dieses Sektors nicht aufbricht.</em> </p><br><p>  Dann wird die Skriptnummer dieser Liste von Sektoren zugewiesen (nur eine Nummer, in diesem Stadium bedeutet dies nichts Bestimmtes), und die Verbindungen an den Rändern dieser Liste von Sektoren werden von diesem Skript als geschlossen markiert. </p><br><p><img src="https://habrastorage.org/webt/tw/4w/3w/tw4w3wxhybxndd5_94mw-l0e1zc.png"><br>  <em>In diesen Abbildungen haben verschiedene Szenarien unterschiedliche Sektorfüllfarben.</em>  <em>Sie haben nichts mit der Farbe des Sektors zu tun (in den nächsten Schritten wird es korrigiert, aber in diesem Schritt ist es für mich bequemer).</em> </p><br><p>  Als nächstes wird der nächste Sektor ausgewählt, eine Liste erstellt und diese Liste mit einem neuen Szenario markiert: </p><br><p><img src="https://habrastorage.org/webt/qo/01/qw/qo01qww9cg-s2km6vfrjvoqb_vk.png"></p><br><p>  Achten Sie auf die kleinen blauen Punkte in den roten Quadraten - so wird der Szenarioöffner gezeichnet - d. H.  Irgendwo innerhalb des Abschnitts mit der roten Schrift befindet sich ein Schlüssel oder Schalter, der den Durchgang zu Sektoren mit einer blauen Schrift öffnet. </p><br><p>  Dies geht so lange weiter, bis keine freien Sektoren mehr vorhanden sind: </p><br><p><img src="https://habrastorage.org/webt/5f/ok/yn/5fokynxff0gfpspu7-d8paaw7wi.png"></p><br><p>  Dem neuesten Sektor wird kein Skript zugewiesen, sondern nur ein Szenarioeröffner.  Dieser Sektor ist der Sektor, in dem der Spieler das Spiel startet. </p><br><p>  Für dieses Level: </p><br><ul><li>  Der Spieler startet im Startbereich, irgendwo findet er einen „Flaschenöffner“ zum gelben Bereich, geht dorthin. </li><li>  Im gelben Sektor öffnet sich der blaue Sektor, geht dorthin. </li><li>  Im blauen Sektor öffnet sich grün, geht dorthin. </li><li>  Im grünen Bereich öffnet sich lila, geht dorthin. </li><li>  In lila öffnet sich rot. </li><li>  In rot - blau. </li><li>  Wo er den Endpegelschalter findet. </li></ul><br><p>  Schematisch kann dies wie folgt gezeigt werden: </p><br><p><img src="https://habrastorage.org/webt/c7/6o/xd/c76oxdwcgff53io6pv3sfcptpuu.png"></p><br><p>  Ein „Öffner“ kann entweder ein Schlüssel oder ein Schalter sein oder etwas anderes, zum Beispiel eine Aufgabe, alle Feinde in einem Sektor zu zerstören (aber ich plane nicht, dass der Generator oder Motor dies in naher Zukunft unterstützen wird). </p><br><h2 id="optimizaciya-soedineniy">  Verbindungsoptimierung </h2><br><p><img src="https://habrastorage.org/webt/5q/vl/gw/5qvlgwjtnablead4upxcwph7m6k.gif"></p><br><p>  In diesem Schritt wird für jede Verbindung eine Seite ausgewählt (wie Sie sich erinnern, werden die Verbindungen zunächst in beide Richtungen generiert).  Dies ist notwendig, um das Level „manueller“ aussehen zu lassen und die nächsten Schritte zu vereinfachen <em>(aber für einen noch interessanteren Level-Typ plane ich in naher Zukunft den Schritt, einige Verbindungen zu „deoptimieren“)</em> . </p><br><h2 id="sozdanie-dverey-iokon">  Türen und Fenster erstellen </h2><br><p><img src="https://habrastorage.org/webt/xr/je/m5/xrjem5kqzr7ncka2vuf8nsukw2c.gif"></p><br><p>  Für jeden Sektor werden alle seine Verbindungen angezeigt (die nach dem vorherigen Schritt nur in eine Richtung schauen), und Türen und Fenster werden auf jeder angezeigten Verbindung platziert. </p><br><ul><li>  Zunächst wird ein Punkt an der Verbindungsstelle ausgewählt, vorzugsweise näher an der Mitte. </li><li>  Dann wird an dieser Stelle entweder eine Tür oder ein Fenster platziert (und wenn es sich um eine Verbindung zu einem geheimen Raum handelt, dann zu einer geheimen Wand). </li><li>  Wenn eine Tür platziert wird, kann sie 1 bis 3 Zellen groß sein (eine ist eine normale Tür, zwei oder drei sind eine dicke hermetische Tür, die sich nach Drücken eines Schalters öffnet). </li><li>  Ferner ist die Verbindung in zwei Teile unterteilt - den Teil vor dem ausgewählten Punkt und den Teil danach.  Und wenn vorher oder nachher noch Platz vorhanden ist, wird die Funktion rekursiv aufgerufen. </li></ul><br><p>  Um das Level interessanter aussehen zu lassen, besteht bei verschiedenen Schritten eine unterschiedliche Wahrscheinlichkeit, eine Tür oder ein Fenster zu platzieren: </p><br><ol><li>  Im ersten Schritt wird die Tür immer platziert, weil  Was nützt das Verbinden, wenn dort nur Fenster vorhanden sind? </li><li>  Im zweiten Schritt wird mit <strong>einer</strong> höheren Wahrscheinlichkeit (75%) ein Fenster als eine Tür platziert. </li><li>  Wenn es einen dritten Schritt gibt (zum Beispiel ist die Verbindung lang), muss ein Fenster darauf platziert werden. </li><li>  Im Fall des 4. Schritts wird die Tür oder das Fenster gleich wahrscheinlich platziert. </li><li>  Wenn die Verbindung besonders lang ist, kehrt der Generator zum zweiten Schritt zurück. </li></ol><br><h2 id="vybor-deystviya">  Aktionsauswahl </h2><br><p>  Obwohl dies nicht mit der Generierung zusammenhängt, ändert sich die Visualisierung in diesem Schritt - jetzt wird der Sektorrand in der Farbe des Skripts gezeichnet: </p><br><p><img src="https://habrastorage.org/webt/rc/6y/xv/rc6yxvsq6duv-xdujaamzq0fdry.png"><br>  <em>Der Startsektor ist hellgrau, der Endsektor ist blau.</em>  <em>Beachten Sie auch, dass anstelle der Tür im Geheimraum (dunkelgrau links) eine Wand gezeichnet wird - alles ist korrekt, dies ist eine Geheimwand.</em> </p><br><p>  Wählen Sie als Nächstes die Sektoren aus, in denen Sie die Schlüssel platzieren können: </p><br><p><img src="https://habrastorage.org/webt/kl/os/jz/klosjzmyvv_tl2djbz5v6b9sqze.png"></p><br><p>  Sie werden ganz einfach ausgewählt: </p><br><ul><li>  Wenn dies ein geheimer Raum ist, darf sich kein "Öffner" darin befinden, und der Schlüssel kann dort nicht platziert werden. </li><li>  Sie können den Schlüssel auch nicht im endgültigen Sektor platzieren, da er endgültig ist. </li><li>  Der Schlüssel kann auch keine Doppel- und Dreifachtüren öffnen - aufgrund der Merkmale des Motors können sie nur mit dem Schalter geöffnet werden <em>(in der obigen Abbildung sind solche Sektoren nicht vorhanden)</em> . </li></ul><br><p>  Danach wird die Anzahl der Schlüssel auf einer Ebene (von null bis drei) zufällig ausgewählt, und dann werden zufällig aus der verfügbaren Liste von Sektoren diejenigen ausgewählt, in denen Schlüssel vorhanden sein werden. </p><br><p>  In den übrigen Sektoren wird es Schalter geben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418685/">https://habr.com/ru/post/de418685/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418675/index.html">Wie ich zur Droidcon Berlin gegangen bin</a></li>
<li><a href="../de418677/index.html">Die ganze Wahrheit über RTOS. Artikel 6. Andere RTOS-Dienste</a></li>
<li><a href="../de418679/index.html">Wir schreiben eine Komponente mit "Material" -Schaltflächen für Svelte</a></li>
<li><a href="../de418681/index.html">Tag der Freundschaft - 50% Rabatt auf alle JetBrains-IDEs für unsere Freunde</a></li>
<li><a href="../de418683/index.html">Erstellen eines Emulator-Arcade-Automaten. Teil 2</a></li>
<li><a href="../de418687/index.html">3,5 "Umdrehung: Details eines kleinen Auslegers von Disketten mit Dämpfen</a></li>
<li><a href="../de418689/index.html">Erstellen von Komponentenbibliotheken in Figma, Einsparen eines Budgets am Beispiel einer Online-Auktion</a></li>
<li><a href="../de418691/index.html">Rancher: Kubernetes in 5 Minuten auf Bare Metal</a></li>
<li><a href="../de418693/index.html">Warum ist Glück im Gehirn so schwer zu erkennen?</a></li>
<li><a href="../de418695/index.html">Anti-Piraterie-Kriege - Das Imperium schlägt zurück</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>