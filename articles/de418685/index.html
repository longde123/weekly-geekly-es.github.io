<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèø üêô ‚òùÔ∏è Prozedurale Level-Generierung üòã üßïüèΩ üåµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Arbeit an Programmierung, Grafik und Sound in einigen neuen Spielen ist beendet - es bleiben nur Levels √ºbrig. Einfache und angenehme Arbeit, aber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prozedurale Level-Generierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418685/"><p><img src="https://habrastorage.org/webt/2m/0y/gv/2m0ygvmlc1izxgmo4chumrammxi.png"></p><br><p>  Die Arbeit an Programmierung, Grafik und Sound in <em>einigen neuen Spielen ist beendet</em> - es bleiben nur Levels √ºbrig.  Einfache und angenehme Arbeit, aber aus irgendeinem Grund mit gro√üen Schwierigkeiten verbunden.  Vielleicht die Wirkung von allgemeiner M√ºdigkeit. </p><br><p>  Als er √ºberlegte, wie er sein Leben vereinfachen k√∂nnte, kam ihm die Idee der prozeduralen Generierung in den Sinn.  Nat√ºrlich muss es auch geschrieben werden, aber wie in einem bekannten Werk gesagt wurde: "Es ist besser, einen Tag zu verlieren und dann in f√ºnf Minuten zu fliegen." </p><br><p>  <strong>Achtung!</strong>  <strong>Unter dem Schnitt viel Text und "fette" Gifs.</strong> </p><a name="habracut"></a><br><h2 id="vvodnaya">  Einf√ºhrung </h2><br><p>  Die Ebenen werden weiterhin manuell poliert, sodass keine besonderen Anforderungen an Speicher, Geschwindigkeit oder sogar die Qualit√§t der resultierenden Ebenen bestehen. </p><br><p>  Anfangs hatte ich geplant, dass der Generator nur R√§ume und T√ºren wirft und alle weiteren Verfeinerungen (Handlung, Szenerie und Feinde) im manuellen Modus durchgef√ºhrt werden.  Aber im Moment kann der Generator noch viel mehr.  Trotzdem bleibt die manuelle Abstimmung bestehen - es ist notwendig, dass die Spieler das Gef√ºhl haben, dass zumindest ein wenig Liebe in die Levels investiert wird. </p><br><p>  Ich habe mir meine Wissensbasis √ºber Spieleentwickler angesehen und in einem separaten Dokument Links zu Artikeln √ºber die prozedurale Generierung geschrieben.  Bei den meisten geht es nat√ºrlich darum, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">klassische Labyrinthe</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gel√§nde zu erzeugen</a> (die Ergebnisse sind √ºbrigens sehr beeindruckend), was f√ºr einen 3D-Shooter nicht geeignet ist.  Aber einige waren nah an dem, was ich brauchte (mit einem Sternchen notierte ich diejenigen, die mir am besten geeignet erschienen): </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.progamer.ru/dev/procedural-dungeon-generation.htm</a> (*) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/post/333692/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://www.gamasutra.com/blogs/GrahamDavis/20170130/290326/Procedural_Level_Generation_in_Unity_for_MERC_part_1_of_2.php</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://ijdykeman.github.io/ml/2017/10/12/wang-tile-procedural-generation.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/post/332832/</a> (*) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/post/184818/</a> (*) </li></ul><br><p>  Ich habe beschlossen, mit den letzten beiden zu beginnen - sie werden gerade implementiert und liefern gute Ergebnisse. </p><br><h2 id="struktura-generatora">  Generatorstruktur </h2><br><p>  Tats√§chlich bin ich nicht sofort zu dieser Struktur gekommen, sondern habe gerade zahlreiche Umgestaltungen und Umschreibungen vorgenommen, aber ich schreibe sofort dar√ºber, damit klar ist, was los ist: </p><br><ol><li>  Generierung der Anfangsgeometrie (zur Auswahl - entweder "BSP" oder Raumaufteilung). </li><li>  L√∂schen von M√ºllabschnitten (solche Abschnitte, die im Spiel nicht existieren k√∂nnen). </li><li>  Verbindungen aufbauen. </li><li>  L√∂schen von M√ºll-Untergraphen (solche Gruppen von Abschnitten, die miteinander verbunden sind, aber keine Verbindung zu den verbleibenden Abschnitten bestehen). </li><li>  L√∂schen unn√∂tiger Verbindungen (beim Erstellen eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spanning Tree</a> wird eine Verkn√ºpfung zum <strong>Minimum</strong> Spanning Tree hergestellt, da dort ein Bild vorhanden ist, f√ºr den Generator jedoch kein Minimum erforderlich ist). </li><li>  Die Randomisierung von Verbindungen ist die Wiederherstellung einiger entfernter Verbindungen zur√ºck (f√ºr eine ‚Äûmenschlichere‚Äú Art von Ebene) sowie die Umwandlung einiger anderer in Passagen zwischen Abschnitten (wodurch mehrere Abschnitte zu einer komplexeren Form zusammengef√ºhrt werden). </li><li>  Geheime Raumgeneration. </li><li>  Generierung eines ‚ÄûSzenarios‚Äú (wo befinden sich der Anfangs- und der Endabschnitt und welcher Pfad muss √ºbergeben werden, um vom Anfang zum Finale zu gelangen). </li><li>  Verbindungsoptimierung. </li><li>  T√ºren und Fenster erstellen. </li><li>  Die Auswahl der in diesem Abschnitt auszuf√ºhrenden Aktion (Dr√ºcken Sie den Schalter, heben Sie den Schl√ºssel oder suchen Sie die geheime Wand). </li></ol><br><p>  Es gibt noch ungef√§hr 12 Punkte, aber sie sind noch nicht abgeschlossen (wenn ich fertig bin, werde ich einen separaten Beitrag dar√ºber schreiben). </p><br><h2 id="generaciya-iznachalnoy-geometrii-bsp">  Anf√§ngliche Geometrieerzeugung: "BSP" </h2><br><p><img src="https://habrastorage.org/webt/zn/j4/_k/znj4_kemnzlvr4cfr45tqtzami8.gif"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diese √úbersetzung</a> wurde als Grundlage genommen.  Ich bin mir nicht sicher, wie viel in diesem Algorithmus in der N√§he des tats√§chlichen BSP passiert, daher schreibe ich "BSP" in Anf√ºhrungszeichen. </p><br><p>  Der Algorithmus ist recht einfach.  Erstellen Sie zun√§chst ein Rechteck mit der Gr√∂√üe des gesamten Spielfelds: </p><br><p><img src="https://habrastorage.org/webt/fh/mx/x-/fhmxx-boo4euwsc4dl2g0gfc2nk.png"></p><br><p>  Dann teilen wir es zuf√§llig in zwei Teile - entweder horizontal oder vertikal.  Wo die Trennlinie stattfinden wird, w√§hlen wir auch zuf√§llig aus: </p><br><p><img src="https://habrastorage.org/webt/ml/lo/jm/mllojmhd2qxiga7ma_skqxqoera.png"></p><br><p>  Wir machen das gleiche rekursiv f√ºr die neuen Rechtecke: </p><br><p><img src="https://habrastorage.org/webt/ew/sw/wf/ewswwfagu3jcskhcebem5sd-jo8.png"></p><br><p>  Und bis zu einem gewissen Grad immer wieder: </p><br><p><img src="https://habrastorage.org/webt/fl/s-/hd/fls-hd2xm17ghbjbvnwpyhwzd_m.png"></p><br><p>  Dann w√§hlen wir in jedem Rechteck einen ‚ÄûRaum‚Äú aus - ein Rechteck mit der gleichen Gr√∂√üe wie das Original oder kleiner (aber nicht weniger als 3x3 - mehr dazu weiter unten). </p><br><p><img src="https://habrastorage.org/webt/r8/h1/_y/r8h1_yacj5bpuux_xmmxuwzdlo0.png"></p><br><p>  Dann sind die R√§ume durch Korridore verbunden.  Aber nicht jeder, aber ein wenig knifflig, weil sie in einer "BSP" -√§hnlichen Struktur gespeichert sind (siehe den urspr√ºnglichen Algorithmus f√ºr weitere Details). </p><br><p><img src="https://habrastorage.org/webt/5t/y6/3e/5ty63ewmz5eey4oaphja4uixjuu.png"><br>  <em>Der Korridor verbindet die lila und wei√üen Bereiche.</em> </p><br><p>  In dem urspr√ºnglichen Algorithmus haben sowohl R√§ume als auch Korridore die gleiche Farbe (d. H. Sie sind √§quivalent), so dass dort die Korridore einfach √ºber die R√§ume gezeichnet werden.  In meinem Fall sollten die urspr√ºnglichen R√§ume erhalten bleiben, damit die Korridore wie "hinter" den R√§umen gezeichnet werden. </p><br><p>  Wenn der Raum (in der Abbildung t√ºrkis) den Korridor √ºberquert, sollte er ihn in zwei verschiedene Abschnitte unterteilen (daher kann derselbe Korridor in verschiedenen Farben gezeichnet werden): </p><br><p><img src="https://habrastorage.org/webt/5n/wr/51/5nwr510wdeg8x9iw3cgy_eorsau.png"></p><br><p>  Und hier ist das Ergebnis: </p><br><p><img src="https://habrastorage.org/webt/q4/hq/7r/q4hq7rocs2amqbt-guzspzcmbp4.png"></p><br><p>  Dann beginnt die Phase des Markierens von M√ºllzellen: </p><br><p><img src="https://habrastorage.org/webt/f0/ob/sc/f0obscdf1tabhec9mxv4m-wrj5s.png"></p><br><p>  Wie ich bereits geschrieben habe, kann kein Sektor kleiner als 3x3-Zellen sein.  Dies liegt an der Tatsache, dass der Sektor von W√§nden umgeben sein muss (mindestens 1 Zelle auf jeder Seite) und mindestens eine Zelle mit freiem Raum haben muss: </p><br><p><img src="https://habrastorage.org/webt/iy/e8/ne/iye8ne6qltvzxtwrpgrtjgmgeae.png"></p><br><p>  Daher sind alle Zellen gekennzeichnet, die dieser Regel nicht entsprechen.  Aber nimm es einfach und du kannst sie nicht entfernen - so viele Verbindungen verschwinden und das Level ist sehr sp√§rlich. </p><br><p>  Stattdessen wird f√ºr jede markierte Zelle nach dem Sektor gesucht, dem sie beitreten kann (unter Beachtung der 3x3-Regel): </p><br><p><img src="https://habrastorage.org/webt/nc/6q/-y/nc6q-yh8jlkx_rhlilpamtzt27s.png"><br>  <em>Wenn die Zelle immer noch keinem Sektor zugeordnet werden kann, wird sie gel√∂scht (aber in diesem Fall nicht - hier ist alles in Ordnung).</em> </p><br><p>  In der letzten Phase wird dieses sch√∂ne Bild vektorisiert und die gezeichneten Sektoren werden zu Polyboxen - solchen Polygonen, bei denen jede Kante entweder streng vertikal oder streng horizontal ist (es gibt wahrscheinlich einen wissenschaftlicheren Namen): </p><br><p><img src="https://habrastorage.org/webt/xx/8x/8v/xx8x8vpyawz-uricpycndaadgfy.png"></p><br><h2 id="generaciya-iznachalnoy-geometrii-planirovka-pomescheniy">  Erste Geometrieerzeugung: Raumaufteilung </h2><br><p><img src="https://habrastorage.org/webt/7w/jh/nb/7wjhnbk6xzc6zmdaqyiufpq7t5m.gif"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein weiterer Artikel</a> wurde als Grundlage genommen.  Dieser Algorithmus ist etwas komplizierter als der vorherige, aber auch keine Raketenwissenschaft. </p><br><p>  Zuerst wird das Spielfeld mit einem bestimmten Stoppwert gef√ºllt, und dann wird zuf√§llig ein rechteckiger Bereich darauf gel√∂scht: </p><br><p><img src="https://habrastorage.org/webt/4n/24/py/4n24pyropjvmm0d8gsmzj9znte0.png"></p><br><p>  Die Stufe des Reinigens eines zuf√§lligen Rechtecks ‚Äã‚Äãwird einige Male (auch zuf√§llig) ausgef√ºhrt, und als Ergebnis werden die Au√üenkonturen des Niveaus erhalten: </p><br><p><img src="https://habrastorage.org/webt/np/4v/fi/np4vfi_iumlrznv8bsy8ba3babk.png"></p><br><p>  Im freien Raum werden die Raumwachstumspunkte zuf√§llig verteilt (die Mindestraumgr√∂√üe betr√§gt 3x3): </p><br><p><img src="https://habrastorage.org/webt/2y/wm/3n/2ywm3n3lgak23tcn0dmyshbicne.png"></p><br><p>  Die erste Phase des Raumwachstums beginnt - f√ºr jeden Raum wird die gr√∂√üte Seite ausgew√§hlt, die noch wachsen kann, und sie w√§chst um 1 Zelle (wenn es mehrere Seiten mit derselben L√§nge gibt - eine zuf√§llige).  Die R√§ume werden der Reihe nach so verschoben, dass es keine Kreuzungen gibt. </p><br><p><img src="https://habrastorage.org/webt/-b/4r/cd/-b4rcdczwe-_hu8xvha_cko1ihk.gif"></p><br><p>  Dann werden die R√§ume in Polyboxen umgewandelt: </p><br><p><img src="https://habrastorage.org/webt/pd/j8/qo/pdj8qos36_hf4slo-jlm2eailsw.png"></p><br><p>  Und die zweite Wachstumsphase beginnt - in dieser Phase kann die Seite in mehrere Teile unterteilt werden.  Im Gegensatz zur ersten Stufe w√§chst nicht eine Zelle nach der anderen, sondern sofort bis zum maximalen Stopp - dies vermeidet die "Leiter" an den Fugen der R√§ume.  Wenn nach dem Durchgang durch alle R√§ume noch leere Zellen vorhanden sind, wird der Zyklus wiederholt. </p><br><p>  Das Ergebnis ist ein vollst√§ndig gef√ºllter Raum: </p><br><p><img src="https://habrastorage.org/webt/mi/8j/zf/mi8jzfzhpksr2cz7jzd1_k3gmng.png"></p><br><p>  Dann werden Polyboxen in Form eines Rasters gezeichnet, und (wie im Fall des "BSP" -Generators) beginnt die Phase des Markierens von "M√ºll" -Zellen: </p><br><p><img src="https://habrastorage.org/webt/ev/na/ru/evnaruhyjwsei7hfbywiiuxyzq4.png"></p><br><p>  Und sie mit bestehenden Sektoren verbinden: </p><br><p><img src="https://habrastorage.org/webt/1h/yv/kf/1hyvkfcnerw5yu30txvbztecfzw.png"><br>  <em>Hier konnten nicht alle Zellen angebracht werden - die zus√§tzlichen wurden entfernt.</em> </p><br><p>  Das Ergebnis wird wieder in Polyboxen konvertiert: </p><br><p><img src="https://habrastorage.org/webt/ji/l3/yq/jil3yqqnbqpf4cfjyx-sklb_g8w.png"></p><br><h2 id="ochistka-ot-musornyhsekciy">  Reinigung von M√ºllabschnitten </h2><br><p>  Manchmal entstehen Abschnitte, in denen die 3x3-Regel nicht eingehalten wird: </p><br><p><img src="https://habrastorage.org/webt/6v/zx/2v/6vzx2vnhvhn_kkxvqp1jyzenh6g.png"></p><br><p>  Sie k√∂nnen versuchen, solche Abschnitte "wiederherzustellen", aber ich bin den einfacheren Weg gegangen und habe sie einfach gel√∂scht: </p><br><p><img src="https://habrastorage.org/webt/gc/5s/4y/gc5s4yzeywvc6pi1kh0apfk90pm.png"></p><br><h2 id="postroenie-soedineniy">  Verbindungen aufbauen </h2><br><p><img src="https://habrastorage.org/webt/af/3m/w2/af3mw25mgkjtqwskriypbpzzaeo.gif"></p><br><p>  F√ºr jeden Abschnitt werden seine Nachbarn durchsucht, und an den Kontaktstellen dieser Abschnitte werden Verbindungen hergestellt.  Auf beiden Seiten werden Verbindungen hergestellt. Wenn Abschnitt A mit Abschnitt B in Kontakt steht, besteht eine Verbindung von A nach B und von B nach A. Das Ergebnis ist ein bidirektionaler Graph. </p><br><h2 id="ochistka-ot-musornyh-podgrafov">  L√∂schen von M√ºll-Untergraphen </h2><br><p>  Manchmal erhalten wir als Ergebnis der Reinigung von M√ºllabschnitten nicht ein Diagramm, sondern mehrere unabh√§ngige, wie in diesem Beispiel: </p><br><p><img src="https://habrastorage.org/webt/yi/s5/5u/yis55urvft0bohq8x0dsurgyyam.png"></p><br><p>  In diesem Fall wird der Untergraph als Hauptgraph ausgew√§hlt, dessen "Fl√§che" der Abschnitte maximal ist, und der Rest wird gel√∂scht (die "Fl√§che" steht in Anf√ºhrungszeichen, da ich zwar die reale Fl√§che der Polybox berechnen kann, die Aufgabe jedoch vereinfacht habe und die Fl√§che des Begrenzungsrahmens betrachte - das ist falsch, aber f√ºr einen Generator geeignet). </p><br><h2 id="ochistka-ot-izlishnih-soedineniy">  √úbersch√ºssige Verbindungen entfernen </h2><br><p>  Wenn es einen Durchgang von jedem Sektor zu jedem gibt, mit dem er verbunden ist, gibt es zu viele T√ºren auf der Ebene, und es ist st√§rker zu sp√ºren, dass er erzeugt wird.  Daher werden in diesem Stadium √ºbersch√ºssige Verbindungen entfernt: </p><br><p><img src="https://habrastorage.org/webt/oa/sh/oy/oashoyuavho98281lo_s4hpc-ks.gif"></p><br><p>  F√ºr mehr Randomisierung generiere ich keinen Spanning Tree in der minimalen Anzahl von Durchg√§ngen, sondern l√∂sche jeweils eine zuf√§llige Kante (w√§hle sie zuf√§llig aus allen im aktuellen Schritt m√∂glichen aus). </p><br><p>  <em>Obwohl, als ich dies schrieb, die Idee schien, dass es ziemlich zuf√§llig w√§re, den anf√§nglichen Sektor auszuw√§hlen und die Kanten zu entfernen, die bereits effizienter sind.</em> </p><br><h2 id="randomizaciya-soedineniy">  Verbindungs-Randomisierung </h2><br><p><img src="https://habrastorage.org/webt/ok/zl/vk/okzlvk4rclc7x3imkpjnjza3kje.gif"><br>  <em>Im Folgenden werden Illustrationen von einer anderen Generation stammen, weil</em>  <em>im vorherigen gab es einen Fehler im Generator, aufgrund dessen weitere Bilder falsch waren.</em> </p><br><p>  Aber eine Ebene, in der es keine einzige √ºberfl√ºssige Verbindung gibt, sieht auch nicht sehr menschlich aus, so dass ein gewisses Chaos entsteht: </p><br><ol><li>  Einige gel√∂schte Kanten werden wiederhergestellt. </li><li>  Und manche verwandeln sich in G√§nge. </li></ol><br><p>  Ferner verschmelzen die Abschnitte, zwischen denen die Passagen gebildet wurden, zu einem: </p><br><p><img src="https://habrastorage.org/webt/nh/j_/uj/nhj_ujd0n7sqjdnddlvs9uozq5u.gif"><br>  <em>Wenn es Ihnen so vorkam, als ob in dieser Abbildung die im vorherigen Schritt gel√∂schten Verbindungen wieder auftauchten - es schien Ihnen :).</em>  <em>Als ich den Text las, kam es mir auch so vor, aber nachdem ich mir die vorherige Abbildung genau angesehen habe, wird klar, dass alles in Ordnung ist.</em> </p><br><h2 id="generaciya-sekretnyh-komnat">  Geheime Raumgenerierung </h2><br><p>  Sektoren mit nur einer Verbindung werden in der Grafik ausgew√§hlt: </p><br><p><img src="https://habrastorage.org/webt/xt/ku/qw/xtkuqweqgctwcbcckilick4-es4.png"></p><br><p>  Wenn es mehrere solcher Sektoren gibt, werden sie alle in einem Array zusammengefasst und nach "Bereich" sortiert.  Dann wird dieses Array zuf√§llig abgeschnitten (so dass mindestens ein Element darin verbleibt).  Diese Sektoren werden zu geheimen R√§umen: </p><br><p><img src="https://habrastorage.org/webt/pf/w0/yu/pfw0yufvv3orwiw_xohtfii8gqi.png"></p><br><h2 id="generaciya-scenariya">  Skriptgenerierung </h2><br><p><img src="https://habrastorage.org/webt/p2/ql/dn/p2qldn0n-scgjotykszlvsvd05a.gif"></p><br><p>  Zun√§chst werden die Sektoren mit der minimalen Anzahl freier Verbindungen (dh diejenigen, die n√§her an der "Kante" des Diagramms liegen) ausgew√§hlt: </p><br><p><img src="https://habrastorage.org/webt/lc/iw/7v/lciw7vahyrhoirla-hyahd7jzhu.png"><br>  <em>In dieser Abbildung wird ein Sektor ausgew√§hlt, aber wenn es mehr g√§be, w√ºrde ohnehin einer ausgew√§hlt (zuf√§llig).</em> </p><br><p>  <em>NB.</em>  <em>W√§hrend des Korrekturlesens des Artikels konnte ich eine Situation feststellen, in der ein Sektor mit einer minimalen Anzahl freier Verbindungen nicht nur nicht am Rande steht, sondern auch das Zuweisen eines Skripts zu einem unpassierbaren Level f√ºhrt.</em>  <em>Tats√§chlich k√∂nnen Sie jeden Sektor ausw√§hlen, aber nur einen. Danach w√ºrde das Diagramm nicht mehr in mehrere Untergraphen unterteilt.</em> </p><br><p>  W√§hlen Sie als N√§chstes Sektoren aus, die mit dem aktuellen Sektor verbunden sind und nur eine freie Verbindung haben.  Sie werden mit einiger Wahrscheinlichkeit verwendet, um das Skript fortzusetzen.  Wenn das Diagramm beispielsweise das gleiche wie in der folgenden Abbildung w√§re, k√∂nnte der durch die Frage angegebene Sektor in die Liste aufgenommen werden. </p><br><p><img src="https://habrastorage.org/webt/6u/b6/vf/6ub6vfbxncsmbug4optzec19gyw.png"><br>  <em>Der geheime Raum ist grau markiert, die Kreuze sind die Verbindungen, die im Originaldiagramm entfernt werden sollten, und der Quellsektor ist ein Plus.</em> </p><br><p>  <em>NB.</em>  <em>W√§hrend des Korrekturlesens des Artikels schien es mir, dass die Bedingung f√ºr das Vorhandensein nur einer Verbindung zu streng war, genau wie im vorherigen Schritt - damit das Diagramm nach dem L√∂schen dieses Sektors nicht aufbricht.</em> </p><br><p>  Dann wird die Skriptnummer dieser Liste von Sektoren zugewiesen (nur eine Nummer, in diesem Stadium bedeutet dies nichts Bestimmtes), und die Verbindungen an den R√§ndern dieser Liste von Sektoren werden von diesem Skript als geschlossen markiert. </p><br><p><img src="https://habrastorage.org/webt/tw/4w/3w/tw4w3wxhybxndd5_94mw-l0e1zc.png"><br>  <em>In diesen Abbildungen haben verschiedene Szenarien unterschiedliche Sektorf√ºllfarben.</em>  <em>Sie haben nichts mit der Farbe des Sektors zu tun (in den n√§chsten Schritten wird es korrigiert, aber in diesem Schritt ist es f√ºr mich bequemer).</em> </p><br><p>  Als n√§chstes wird der n√§chste Sektor ausgew√§hlt, eine Liste erstellt und diese Liste mit einem neuen Szenario markiert: </p><br><p><img src="https://habrastorage.org/webt/qo/01/qw/qo01qww9cg-s2km6vfrjvoqb_vk.png"></p><br><p>  Achten Sie auf die kleinen blauen Punkte in den roten Quadraten - so wird der Szenario√∂ffner gezeichnet - d. H.  Irgendwo innerhalb des Abschnitts mit der roten Schrift befindet sich ein Schl√ºssel oder Schalter, der den Durchgang zu Sektoren mit einer blauen Schrift √∂ffnet. </p><br><p>  Dies geht so lange weiter, bis keine freien Sektoren mehr vorhanden sind: </p><br><p><img src="https://habrastorage.org/webt/5f/ok/yn/5fokynxff0gfpspu7-d8paaw7wi.png"></p><br><p>  Dem neuesten Sektor wird kein Skript zugewiesen, sondern nur ein Szenarioer√∂ffner.  Dieser Sektor ist der Sektor, in dem der Spieler das Spiel startet. </p><br><p>  F√ºr dieses Level: </p><br><ul><li>  Der Spieler startet im Startbereich, irgendwo findet er einen ‚ÄûFlaschen√∂ffner‚Äú zum gelben Bereich, geht dorthin. </li><li>  Im gelben Sektor √∂ffnet sich der blaue Sektor, geht dorthin. </li><li>  Im blauen Sektor √∂ffnet sich gr√ºn, geht dorthin. </li><li>  Im gr√ºnen Bereich √∂ffnet sich lila, geht dorthin. </li><li>  In lila √∂ffnet sich rot. </li><li>  In rot - blau. </li><li>  Wo er den Endpegelschalter findet. </li></ul><br><p>  Schematisch kann dies wie folgt gezeigt werden: </p><br><p><img src="https://habrastorage.org/webt/c7/6o/xd/c76oxdwcgff53io6pv3sfcptpuu.png"></p><br><p>  Ein ‚Äû√ñffner‚Äú kann entweder ein Schl√ºssel oder ein Schalter sein oder etwas anderes, zum Beispiel eine Aufgabe, alle Feinde in einem Sektor zu zerst√∂ren (aber ich plane nicht, dass der Generator oder Motor dies in naher Zukunft unterst√ºtzen wird). </p><br><h2 id="optimizaciya-soedineniy">  Verbindungsoptimierung </h2><br><p><img src="https://habrastorage.org/webt/5q/vl/gw/5qvlgwjtnablead4upxcwph7m6k.gif"></p><br><p>  In diesem Schritt wird f√ºr jede Verbindung eine Seite ausgew√§hlt (wie Sie sich erinnern, werden die Verbindungen zun√§chst in beide Richtungen generiert).  Dies ist notwendig, um das Level ‚Äûmanueller‚Äú aussehen zu lassen und die n√§chsten Schritte zu vereinfachen <em>(aber f√ºr einen noch interessanteren Level-Typ plane ich in naher Zukunft den Schritt, einige Verbindungen zu ‚Äûdeoptimieren‚Äú)</em> . </p><br><h2 id="sozdanie-dverey-iokon">  T√ºren und Fenster erstellen </h2><br><p><img src="https://habrastorage.org/webt/xr/je/m5/xrjem5kqzr7ncka2vuf8nsukw2c.gif"></p><br><p>  F√ºr jeden Sektor werden alle seine Verbindungen angezeigt (die nach dem vorherigen Schritt nur in eine Richtung schauen), und T√ºren und Fenster werden auf jeder angezeigten Verbindung platziert. </p><br><ul><li>  Zun√§chst wird ein Punkt an der Verbindungsstelle ausgew√§hlt, vorzugsweise n√§her an der Mitte. </li><li>  Dann wird an dieser Stelle entweder eine T√ºr oder ein Fenster platziert (und wenn es sich um eine Verbindung zu einem geheimen Raum handelt, dann zu einer geheimen Wand). </li><li>  Wenn eine T√ºr platziert wird, kann sie 1 bis 3 Zellen gro√ü sein (eine ist eine normale T√ºr, zwei oder drei sind eine dicke hermetische T√ºr, die sich nach Dr√ºcken eines Schalters √∂ffnet). </li><li>  Ferner ist die Verbindung in zwei Teile unterteilt - den Teil vor dem ausgew√§hlten Punkt und den Teil danach.  Und wenn vorher oder nachher noch Platz vorhanden ist, wird die Funktion rekursiv aufgerufen. </li></ul><br><p>  Um das Level interessanter aussehen zu lassen, besteht bei verschiedenen Schritten eine unterschiedliche Wahrscheinlichkeit, eine T√ºr oder ein Fenster zu platzieren: </p><br><ol><li>  Im ersten Schritt wird die T√ºr immer platziert, weil  Was n√ºtzt das Verbinden, wenn dort nur Fenster vorhanden sind? </li><li>  Im zweiten Schritt wird mit <strong>einer</strong> h√∂heren Wahrscheinlichkeit (75%) ein Fenster als eine T√ºr platziert. </li><li>  Wenn es einen dritten Schritt gibt (zum Beispiel ist die Verbindung lang), muss ein Fenster darauf platziert werden. </li><li>  Im Fall des 4. Schritts wird die T√ºr oder das Fenster gleich wahrscheinlich platziert. </li><li>  Wenn die Verbindung besonders lang ist, kehrt der Generator zum zweiten Schritt zur√ºck. </li></ol><br><h2 id="vybor-deystviya">  Aktionsauswahl </h2><br><p>  Obwohl dies nicht mit der Generierung zusammenh√§ngt, √§ndert sich die Visualisierung in diesem Schritt - jetzt wird der Sektorrand in der Farbe des Skripts gezeichnet: </p><br><p><img src="https://habrastorage.org/webt/rc/6y/xv/rc6yxvsq6duv-xdujaamzq0fdry.png"><br>  <em>Der Startsektor ist hellgrau, der Endsektor ist blau.</em>  <em>Beachten Sie auch, dass anstelle der T√ºr im Geheimraum (dunkelgrau links) eine Wand gezeichnet wird - alles ist korrekt, dies ist eine Geheimwand.</em> </p><br><p>  W√§hlen Sie als N√§chstes die Sektoren aus, in denen Sie die Schl√ºssel platzieren k√∂nnen: </p><br><p><img src="https://habrastorage.org/webt/kl/os/jz/klosjzmyvv_tl2djbz5v6b9sqze.png"></p><br><p>  Sie werden ganz einfach ausgew√§hlt: </p><br><ul><li>  Wenn dies ein geheimer Raum ist, darf sich kein "√ñffner" darin befinden, und der Schl√ºssel kann dort nicht platziert werden. </li><li>  Sie k√∂nnen den Schl√ºssel auch nicht im endg√ºltigen Sektor platzieren, da er endg√ºltig ist. </li><li>  Der Schl√ºssel kann auch keine Doppel- und Dreifacht√ºren √∂ffnen - aufgrund der Merkmale des Motors k√∂nnen sie nur mit dem Schalter ge√∂ffnet werden <em>(in der obigen Abbildung sind solche Sektoren nicht vorhanden)</em> . </li></ul><br><p>  Danach wird die Anzahl der Schl√ºssel auf einer Ebene (von null bis drei) zuf√§llig ausgew√§hlt, und dann werden zuf√§llig aus der verf√ºgbaren Liste von Sektoren diejenigen ausgew√§hlt, in denen Schl√ºssel vorhanden sein werden. </p><br><p>  In den √ºbrigen Sektoren wird es Schalter geben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418685/">https://habr.com/ru/post/de418685/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418675/index.html">Wie ich zur Droidcon Berlin gegangen bin</a></li>
<li><a href="../de418677/index.html">Die ganze Wahrheit √ºber RTOS. Artikel 6. Andere RTOS-Dienste</a></li>
<li><a href="../de418679/index.html">Wir schreiben eine Komponente mit "Material" -Schaltfl√§chen f√ºr Svelte</a></li>
<li><a href="../de418681/index.html">Tag der Freundschaft - 50% Rabatt auf alle JetBrains-IDEs f√ºr unsere Freunde</a></li>
<li><a href="../de418683/index.html">Erstellen eines Emulator-Arcade-Automaten. Teil 2</a></li>
<li><a href="../de418687/index.html">3,5 "Umdrehung: Details eines kleinen Auslegers von Disketten mit D√§mpfen</a></li>
<li><a href="../de418689/index.html">Erstellen von Komponentenbibliotheken in Figma, Einsparen eines Budgets am Beispiel einer Online-Auktion</a></li>
<li><a href="../de418691/index.html">Rancher: Kubernetes in 5 Minuten auf Bare Metal</a></li>
<li><a href="../de418693/index.html">Warum ist Gl√ºck im Gehirn so schwer zu erkennen?</a></li>
<li><a href="../de418695/index.html">Anti-Piraterie-Kriege - Das Imperium schl√§gt zur√ºck</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>