<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòø ü§òüèø üë©‚Äçüè≠ Memoization nomeolvides bomba üë®‚Äçüë©‚Äçüëß‚Äçüëß üìû üîå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øHas o√≠do hablar de la memoization ? Por cierto, es una cosa s√∫per simple: solo memorice el resultado que obtuvo de una primera llamada de funci√≥n y √∫...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memoization nomeolvides bomba</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446390/"><p><img src="https://habrastorage.org/webt/ym/ok/d7/ymokd7njz99ry_9knpxx9iaz1ja.jpeg"></p><br><p> ¬øHas o√≠do hablar de la <code>memoization</code> ?  Por cierto, es una cosa s√∫per simple: solo memorice el resultado que obtuvo de una primera llamada de funci√≥n y √∫selo en lugar de llamarlo la segunda vez, no llame cosas reales sin raz√≥n, no pierda su tiempo . </p><br><p>  Saltarse algunas operaciones intensivas es una t√©cnica de optimizaci√≥n muy com√∫n.  Cada vez que no hagas algo, no lo hagas.  Intente usar cach√©: <code>memcache</code> , <code>file cache</code> , <code>local cache</code> , ¬°cualquier cach√©!  Una herramienta imprescindible para los sistemas de back-end y una parte crucial de cualquier sistema de back-end del pasado y el presente. </p><a name="habracut"></a><br><p><img src="https://habrastorage.org/webt/j8/4x/u4/j84xu4vrhrsgqu6fc5qdbahwhig.jpeg"></p><br><h1 id="memoization-vscaching">  Memoization vs Caching </h1><br><blockquote>  La memorizaci√≥n es como el almacenamiento en cach√©.  Solo un poco diferente.  No cach√©, llam√©moslo Kashe. </blockquote><p>  Larga historia corta, pero la memorizaci√≥n no es un cach√©, no un cach√© persistente.  Puede ser en el lado del servidor, pero no puede y no debe ser un cach√© en el lado del cliente.  Se trata m√°s de los recursos disponibles, los patrones de uso y las razones para usarlos. </p><br><h2 id="problem-cache-need-a-cachekey">  Problema: la cach√© necesita una "clave de cach√©" </h2><br><p>  La memoria cach√© almacena y recupera datos utilizando una <code>key</code> <strong>cadena de</strong> cach√©.  Ya es un problema construir una clave √∫nica y utilizable, pero luego hay que serializar y eliminar la serializaci√≥n de datos para almacenarlos nuevamente en un medio basado en cadenas ... en resumen, la cach√© puede no ser tan r√°pida, como podr√≠a pensar.  Cach√© especialmente distribuido. </p><br><h2 id="memoization-does-not-need-any-cachekey">  La memorizaci√≥n no necesita ninguna clave de cach√© </h2><br><p>  Al mismo tiempo, no se necesita ninguna clave para la memorizaci√≥n.  <em>Por</em> lo <em>general, *</em> usa argumentos tal cual, no intenta crear una sola clave a partir de ellos, y no usa alg√∫n objeto compartido disponible globalmente para almacenar resultados, como suele hacer la memoria cach√©. </p><br><blockquote>  ¬°La diferencia entre la memorizaci√≥n y el cach√© est√° en la <strong>interfaz API</strong> ! </blockquote><p>  <em>Por lo general, *</em> no significa siempre.  <a href="">Lodash.memoize</a> , por defecto, usa <code>JSON.stringify</code> para convertir los argumentos pasados ‚Äã‚Äãen un cach√© de cadenas (¬øhay alguna otra forma? ¬°No!).  Solo porque van a usar esta clave para acceder a un objeto interno, que tiene un valor en cach√©.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fast-memoize</a> , "la biblioteca de memorizaci√≥n m√°s r√°pida posible", hace lo mismo.  Ambas bibliotecas con nombre no son bibliotecas de memoria, sino bibliotecas de cach√©. </p><br><blockquote>  Vale la pena mencionar que JSON.stringify podr√≠a ser 10 veces m√°s lento que una funci√≥n, vas a memorizar. </blockquote><p>  Obviamente, la soluci√≥n simple al problema NO es usar una clave de cach√©, y NO acceder a alguna cach√© interna usando esa clave.  Entonces, recuerde los √∫ltimos argumentos con los que fue llamado.  Como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">memoizerific</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reselect</a> do. </p><br><blockquote>  Memoizerific es probablemente la √∫nica biblioteca de almacenamiento en cach√© general que le gustar√≠a usar. </blockquote><br><h1 id="the-cachesize">  El tama√±o de cach√© </h1><br><p>  La segunda gran diferencia entre todas las bibliotecas es sobre el tama√±o del cach√© y la estructura del cach√©. </p><br><p>  ¬øAlguna vez has pensado: por qu√© <code>reselect</code> o <code>memoize-one</code> solo tiene un √∫ltimo resultado?  No para <em>"no usar la clave de cach√© para poder almacenar m√°s de un resultado"</em> , sino porque no <strong>hay razones para almacenar m√°s que un √∫ltimo resultado</strong> . </p><br><p>  ... Se trata m√°s de: </p><br><ul><li>  recursos disponibles: una sola l√≠nea de cach√© es muy amigable con los recursos </li><li>  patrones de uso: recordar algo "en su lugar" es un buen patr√≥n.  "En su lugar" generalmente solo necesita un √∫ltimo resultado. </li><li>  La raz√≥n para usar -modularidad, aislamiento y seguridad de la memoria son buenas razones.  No compartir cach√© con el resto de su aplicaci√≥n es m√°s seguro en t√©rminos de colisiones de cach√©. </li></ul><br><h1 id="a-singleresult">  ¬øUn solo resultado? </h1><br><p>  S√≠, el √∫nico resultado.  Con un resultado memorizado, algunas <strong>cosas cl√°sicas</strong> , como la generaci√≥n memorizada de n√∫meros de Fibonacci ( <em>puede encontrar como ejemplo en cada art√≠culo sobre la memorizaci√≥n</em> ) no ser√≠a <strong>posible</strong> .  Pero, por lo general, est√°s haciendo otra cosa: ¬øqui√©n necesita un fibonacci en Frontend?  En el backend?  Un ejemplo del mundo real est√° bastante lejos de <em>los cuestionarios</em> abstractos de <em>TI</em> . </p><br><p>  Pero a√∫n as√≠, hay dos <strong>GRANDES</strong> problemas sobre un tipo de memoria de valor √∫nico. </p><br><h2 id="problem-1-its-fragile">  Problema 1: es "fr√°gil" </h2><br><p>  Por defecto, todos los argumentos deben coincidir, exactamente "===" igual.  Si un argumento no coincide, el juego ha terminado.  Incluso si esto proviene de la idea de la memorizaci√≥n, puede que no sea algo que desee hoy en d√≠a.  Quiero decir, quieres memorizar tanto como sea posible y con la mayor frecuencia posible. </p><br><blockquote>  Incluso la falta de cach√© es un disparo en la cabeza que borra el cach√©. </blockquote><p>  Hay una peque√±a diferencia entre "hoy en d√≠a" y "ayer": estructuras de datos inmutables, que se utilizan, por ejemplo, en Redux. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getSomeDataFromState = memoize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> compute(state.tasks));</code> </pre> <br><p>  ¬øTe ves bien?  Mirando bien?  Sin embargo, el estado puede cambiar cuando las tareas no lo hicieron, y solo necesita que las tareas coincidan. </p><br><p>  <strong>Los Selectores estructurales</strong> est√°n aqu√≠ para salvar el d√≠a con su guerrero m√°s fuerte, <strong>Reselect</strong> , a su entera disposici√≥n.  Reselect no es solo una biblioteca de memorizaci√≥n, sino que su potencia proviene de <strong>cascadas de</strong> memorizaci√≥n o lentes (que no lo son, pero piense en los selectores como lentes √≥pticos). </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// every time `state` changes, cached value would be rejected const getTasksFromState = createSelector(state =&gt; state.tasks); const getSomeDataFromState = createSelector( // `tasks` "without" `state` getTasksFromState, // &lt;---------- // and this operation would be memoized "more often" tasks =&gt; compute(state.tasks) );</span></span></code> </pre> <br><p>  Como resultado, en el caso de los datos inmutables, siempre debe primero <strong>"enfocarse"</strong> en la pieza de datos que realmente necesita, y luego, realizar c√°lculos, o de lo contrario la memoria cach√© ser√≠a rechazada, y toda la idea detr√°s de la memorizaci√≥n desaparecer√≠a. </p><br><p>  Esto es realmente un gran problema, especialmente para los reci√©n llegados, pero, como La idea detr√°s de las estructuras de datos inmutables, tiene un beneficio significativo, <strong>si algo no cambia, no cambia.</strong>  <strong>Si se cambia algo, probablemente se cambie</strong> .  Eso nos da una comparaci√≥n s√∫per r√°pida, pero con algunos falsos negativos, como en el primer ejemplo. </p><br><blockquote>  La idea es "enfocarse" en los datos de los que depende </blockquote><p>  Hay dos momentos que deber√≠a haber mencionado: </p><br><ul><li>  <code>lodash.memoize</code> y <code>fast-memoize</code> est√°n convirtiendo sus datos en una cadena para usar como clave.  Eso significa que son 1) no r√°pidos 2) no seguros 3) podr√≠an producir falsos positivos: algunos <strong>datos diferentes</strong> podr√≠an tener la <strong>misma representaci√≥n de cadena</strong> .  Esto podr√≠a mejorar la "velocidad de cach√©", pero en realidad es algo MUY MALO. </li><li>  existe un enfoque de Proxy ES6, sobre el seguimiento de todas las variables utilizadas dadas y la verificaci√≥n de solo las claves que importan.  Si bien personalmente me gustar√≠a crear una mir√≠ada de selectores de datos, es posible que no le guste o entienda el proceso, pero que desee tener una memorizaci√≥n adecuada de f√°brica, luego use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">memoize-state</a> . </li></ul><br><h2 id="problem-2--its-one-cacheline">  Problema 2- es "una l√≠nea de cach√©" </h2><br><p>  El tama√±o de cach√© infinito es un asesino.  Cualquier cach√© no controlado es un asesino, siempre que la memoria sea bastante finita.  Entonces, todas las mejores bibliotecas son "one-cache-line-long".  Esa es una caracter√≠stica y una fuerte decisi√≥n de dise√±o.  Acabo de escribir lo correcto que es y, cr√©eme, es algo <strong>realmente correcto</strong> , pero sigue siendo un problema.  Un gran problema </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tasks = getTasks(state); <span class="hljs-comment"><span class="hljs-comment">// let's get some data from state1 (function was defined above) getDataFromTask(tasks[0]); // Yep! equal(getDataFromTask(tasks[0]), getDataFromTask(tasks[0])) // Ok! getDataFromTask(tasks[1]); // a different task? What the heck? // oh! That's another argument? How dare you!? // TLDR -&gt; task[0] in the cache got replaced by task[1] you cannot use getDataFromTask to get data from different tasks</span></span></code> </pre> <br><p>  Una vez que el mismo selector tiene que trabajar con diferentes datos de origen, con m√°s de uno, todo se rompe.  Y es f√°cil encontrarse con el problema: </p><br><ul><li>  Mientras estuvi√©ramos usando selectores para obtener tareas de un estado, podr√≠amos usar los mismos selectores para obtener algo de una tarea.  Intense proviene de la propia API.  Pero no funciona, entonces puede memorizar solo la √∫ltima llamada, pero debe trabajar con m√∫ltiples fuentes de datos. </li><li>  El mismo problema es con m√∫ltiples componentes React: todos son iguales y todos un poco diferentes, obteniendo diferentes tareas, borrando los resultados entre s√≠. </li></ul><br><p>  Hay 3 posibles soluciones: </p><br><ul><li>  en caso de redux, use mapStateToProps factory.  Crear√≠a una memoria por instancia. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selector = createSelector(...); <span class="hljs-comment"><span class="hljs-comment">// ^ you have to define per-instance selectors here // usually that's not possible :) return state =&gt; ({ data: selector(data), // a usual mapStateToProps }); }</span></span></code> </pre> </li><li>  la segunda variante es casi la misma (y tambi√©n para redux): se trata de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">volver a seleccionar</a> .  Es una biblioteca compleja, que podr√≠a salvar el d√≠a al distinguir componentes.  Simplemente podr√≠a entender que la nueva llamada se realiz√≥ para "otro" componente, y podr√≠a mantener la memoria cach√© para el "anterior". </li></ul><br><p><img src="https://habrastorage.org/webt/rd/mz/gq/rdmzgqgrj_mjin5jjmsalnxmljm.png"></p><br><p>  Esta biblioteca lo ayudar√≠a a "mantener" la memoria cach√© de la memoria, pero no a eliminarla.  Especialmente porque est√° implementando 5 (¬°CINCO!) Diferentes estrategias de cach√© para adaptarse a cualquier caso.  Eso es un mal olor.  ¬øQu√© pasa si eliges el equivocado? <br>  Todos los datos que ha memorizado: debe olvidarlos, tarde o temprano.  El punto no es recordar la invocaci√≥n de la √∫ltima funci√≥n; el punto es OLVIDARLO en el momento adecuado.  No demasiado pronto, y arruinar la memorizaci√≥n, y no demasiado tarde. </p><br><blockquote>  ¬øTienes la idea?  Ahora olv√≠dalo!  ¬øY d√≥nde est√° la tercera variante? </blockquote><br><h1 id="let-take-apause">  Deja una pausa </h1><br><p>  Para  Relajarse  Respira hondo.  Y responde una pregunta simple: ¬øCu√°l es el objetivo?  ¬øQu√© tenemos que hacer para alcanzar la meta?  ¬øQu√© salvar√≠a el d√≠a? </p><br><blockquote>  CONSEJO: ¬øD√≥nde est√° ese maldito "cach√©" UBICADO! </blockquote><p><img src="https://habrastorage.org/webt/7m/r1/iz/7mr1izrzb89femvq5h-suxxkfnm.jpeg"></p><br><p>  ¬øD√≥nde est√° ubicado ese "cach√©"?  S√≠, esa es la pregunta correcta.  Gracias por preguntar  Y la respuesta es simple: se encuentra en un cierre.  En un lugar oculto dentro * una funci√≥n memorable.  Por ejemplo, aqu√≠ est√° el c√≥digo <code>memoize-one</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastArgs; <span class="hljs-comment"><span class="hljs-comment">// the last arguments let lastResult;// the last result &lt;--- THIS IS THE CACHE // the memoized function const memoizedCall = function(...newArgs) { if (isEqual(newArgs, lastArgs)) { return lastResult; } lastResult = resultFn.apply(this, newArgs); lastArgs = newArgs; return lastResult; }; return memoizedCall; }</span></span></code> </pre> <br><p>  Recibir√° una <code>memoizedCall</code> , y mantendr√° el √∫ltimo resultado cerca, dentro de su cierre local, al que nadie podr√° acceder, excepto memoizedCall.  Un lugar seguro  "este" es un lugar seguro. </p><br><p>  <code>Reselect</code> hace lo mismo, y la √∫nica forma de crear una "bifurcaci√≥n", con otro cach√©: crear un nuevo cierre de memorizaci√≥n. </p><br><p>  Pero la (otra) pregunta principal: ¬øcu√°ndo (cach√©) se habr√≠a "ido"? </p><br><blockquote>  TLDR: "desaparecer√≠a" con una funci√≥n, cuando Garbage Collector se comiera la instancia de la funci√≥n. </blockquote><p>  Instancia?  Instancia!  Entonces, ¬øqu√© pasa con la memorizaci√≥n por instancia?  Hay un art√≠culo completo al respecto en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n de React</a> </p><br><p>  En resumen: si est√° utilizando React Components basados ‚Äã‚Äãen clases, puede hacer lo siguiente: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> memoize <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"memoize-one"</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ filter = memoize( <span class="hljs-comment"><span class="hljs-comment">// &lt;-- bound to the instance (list, filterText) =&gt; list.filter(...); // ^ that is "per instance" memoization // we are creating "own" memoization function // with the "own" lastResult render() { // Calculate the latest filtered list. // If these arguments haven't changed since the last render, // `memoize-one` will reuse the last return value. const filteredList = this.filter(something, somehow); return &lt;ul&gt;{filteredList.map(item =&gt; ...}&lt;/ul&gt; } }</span></span></code> </pre> <br><p>  Entonces, ¬ød√≥nde se almacena <strong>"lastResult"</strong> ?  Dentro de un √°mbito local de <strong>filtro</strong> memorizado, dentro de esta instancia de clase.  ¬øY cu√°ndo se ir√≠a? </p><br><p>  Esta vez "se ir√≠a" con una instancia de clase.  Una vez que el componente se desmont√≥, desapareci√≥ sin dejar rastro.  Es un verdadero "por instancia", y puede usar <code>this.lastResult</code> para mantener un resultado temporal, con exactamente el mismo efecto de "memorizaci√≥n". </p><br><h2 id="whats-about-reacthooks">  ¬øQu√© hay de reaccionar? </h2><br><p>  Nos estamos acercando.  Los ganchos de Redux tienen algunos comandos sospechosos, que, probablemente, son sobre memorizaci√≥n.  Me gusta: <code>useMemo</code> , <code>useCallback</code> , <code>useRef</code> </p><br><p><img src="https://habrastorage.org/webt/wx/2k/kf/wx2kkfpti6kecbdj4zoohpslkqk.png"></p><br><blockquote>  Pero la pregunta: ¬øD√ìNDE est√° almacenando un valor memorable esta vez? </blockquote><p>  En resumen: lo almacena en "ganchos", dentro de una parte especial de un elemento VDOM conocido como fibra asociada con un elemento actual.  Dentro de una estructura de datos paralela. </p><br><p>  No tan corto: los ganchos est√°n cambiando la forma en que funciona su programa, moviendo su funci√≥n dentro de otra, con algunas variables en un <em>lugar oculto dentro de un cierre principal</em> .  Dichas funciones se conocen como funciones <em>suspendibles</em> o <em>reanudables</em> : corutinas.  En JavaScript, generalmente se los conoce como <code>generators</code> o <code>async functions</code> . </p><br><p>  Pero eso es un poco extremo.  En muy poco tiempo, useMemo est√° almacenando un valor memorable en esto.  Es un poco diferente "esto". </p><br><blockquote>  Si queremos crear una mejor biblioteca de memorizaci√≥n, deber√≠amos encontrar un mejor "esto". </blockquote><p>  Zing! </p><br><h1 id="weakmaps">  WeakMaps! </h1><br><p>  Si!  WeakMaps!  Para almacenar el valor-clave, donde la clave ser√≠a esta, siempre que WeakMap no acepte nada excepto esto, es decir, "objetos". </p><br><p>  Creemos un ejemplo simple: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createHiddenSpot = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); <span class="hljs-comment"><span class="hljs-comment">// a hidden "closure" const set = (key, value) =&gt; (map.set(key, value), value); return (key) =&gt; { return map.get(key) || set(key, fn(key)) } } const weakSelect = createHiddenSpot(selector); weakSelect(todos); // create a new entry weakSelect(todos); // return an existing entry weakSelect(todos[0]); // create a new entry weakSelect(todos[1]); // create a new entry weakSelect(todos[0]); // return an existing entry! weakSelect(todos[1]); // return an existing entry!! weakSelect(todos); // return an existing entry!!!</span></span></code> </pre> <br><p>  Es est√∫pidamente simple y bastante "correcto".  Entonces, ¬øcu√°ndo se ir√≠a? </p><br><ul><li>  olvides d√©bilSeleccione y todo un "mapa" desaparecer√≠a </li><li>  olviden a todos [0] y su entrada d√©bil se habr√≠a ido </li><li>  olv√≠date de todos, ¬°y los datos memorizados desaparecer√≠an! </li></ul><br><blockquote>  Est√° claro cu√°ndo algo "desaparecer√≠a", ¬°solo cuando deber√≠a! </blockquote><p>  M√°gicamente, todos los problemas de reselecci√≥n se han ido.  Problemas con la memorizaci√≥n agresiva, tambi√©n un goner. </p><br><p>  Este enfoque <strong>RECUERDA</strong> los datos hasta que sea hora de <strong>OLVIDAR</strong> .  Es incre√≠ble, pero para recordar mejor algo tienes que poder olvidarlo mejor. </p><br><p>  Lo √∫nico dura: cree una API m√°s robusta para este caso </p><br><h1 id="kashe-is-acache">  Kashe - es un cach√© </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kashe</a> es una biblioteca de memorizaci√≥n basada en WeakMap, que podr√≠a salvar su d√≠a. </p><br><p>  Esta biblioteca expone 4 funciones. </p><br><ul><li>  <code>kashe</code> -para memorizaci√≥n. </li><li>  <code>box</code> : para la memorizaci√≥n prefijada, para <em>aumentar las</em> posibilidades de memorizaci√≥n. </li><li>  <code>inbox</code> - memorizaci√≥n prefijada anidada, para <em>disminuir el</em> cambio de memorizaci√≥n </li><li>  <code>fork</code> - a <em>tenedor</em> (obviamente) la memorizaci√≥n. </li></ul><br><h2 id="kashefn--memoizedfnargs">  kashe (fn) =&gt; memoizedFn (... args) </h2><br><p>  En realidad, es createHiddenSpot de un ejemplo anterior.  Utilizar√° un primer argumento como clave para un WeakMap interno. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selector = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, prop</span></span></span><span class="hljs-function">) =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">result</span></span>: state[prop]}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoized = kashe(selector); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> old = memoized(state, <span class="hljs-string"><span class="hljs-string">'x'</span></span>) memoized(state, <span class="hljs-string"><span class="hljs-string">'x'</span></span>) === old memoized(state, <span class="hljs-string"><span class="hljs-string">'y'</span></span>) === memoized(state, <span class="hljs-string"><span class="hljs-string">'y'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ^^ another argument // but old !== memoized(state, 'x') // 'y' wiped 'x' cache in `state`</span></span></code> </pre> <br><p>  el primer argumento es una clave, si llama a la funci√≥n nuevamente la misma clave, pero diferentes argumentos: la memoria cach√© se reemplazar√≠a, todav√≠a es una larga memoria de l√≠nea de cach√©.  Para que funcione, debe proporcionar diferentes claves para diferentes casos, como hice con un ejemplo d√©bilSelect, para proporcionar diferentes para mantener los resultados.  Volver a seleccionar las cascadas A sigue siendo la cosa. <br>  No todas las funciones son kashe-memorables.  El primer argumento <em>tiene</em> que ser un objeto, una matriz o una funci√≥n.  Deber√≠a ser utilizable como clave para WeakMap. </p><br><h2 id="boxfn--memoizedfn2boxargs">  box (fn) =&gt; memoizedFn2 (box, ... args) </h2><br><p>  Esta es la misma funci√≥n, solo se aplica dos veces.  Una vez para fn, una vez para memoizedFn, agregando una clave principal a los argumentos.  Puede hacer que cualquier funci√≥n sea memorable. </p><br><blockquote>  Es bastante declarativo: ¬°hey, funci√≥n!  Guardar√© los resultados en este cuadro. </blockquote><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// could not be "kashe" memoized const addTwo = (a,b) =&gt; ({ result: a+b }); const bAddTwo = boxed(addTwo); const cacheKey = {}; // any object bAddTwo(cacheKey, 1, 2) === bAddTwo(cacheKey, 1, 2) === { result: 3}</span></span></code> </pre> <br><p>  Si encajona la funci√≥n ya memorizada, aumentar√° las posibilidades de memorizaci√≥n, como la memorizaci√≥n por instancia, puede crear una cascada de memorizaci√≥n. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selectSomethingFromTodo = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, prop</span></span></span><span class="hljs-function">) =&gt;</span></span> ... const selector = kashe(selectSomethingFromTodo); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> boxedSelector = kashe(selector); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render () { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = boxedSelector(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, todos, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.todoId); <span class="hljs-comment"><span class="hljs-comment">// 1. try to find result in `this` // 2. try to find result in `todos` // 3. store in `todos` // 4. store in `this` // if multiple `this`(components) are reading from `todos` - // selector is not working (they are wiping each other) // but data stored in `this` - exists. ... } }</span></span></code> </pre> <br><h2 id="inboxfn--memoizedfn2boxargs">  inbox (fn) =&gt; memoizedFn2 (box, ... args) </h2><br><p>  este es opuesto al cuadro, pero hace casi lo mismo, ordenando el cach√© anidado para almacenar datos en el cuadro provisto.  Desde un punto de vista, reduce la probabilidad de memorizaci√≥n (no hay una cascada de memorizaci√≥n), pero desde otro, elimina las colisiones de cach√© y ayuda a aislar procesos si no interfieren entre s√≠ por alg√∫n motivo. </p><br><blockquote>  Es bastante declarativo, ¬°oye!  ¬°Todos adentro!  Aqu√≠ hay una caja para usar </blockquote><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getAndSet = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task, number</span></span></span><span class="hljs-function">) =&gt;</span></span> task.value + number; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoized = kashe(getAndSet); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inboxed = inbox(getAndSet); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doubleBoxed = inbox(memoized); memoized(task, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ok memoized(task, 2) // previous result wiped inboxed(key1, task, 1) // ok inboxed(key2, task, 2) // ok // inbox also override the cache for any underlaying kashe calls doubleBoxed(key1, task, 1) // ok doubleBoxed(key2, task, 2) // ok</span></span></code> </pre> <br><h2 id="forkkashe-memoized--kashe-memoized">  fork (kashe-memoized) =&gt; kashe-memoized </h2><br><p>  La bifurcaci√≥n es una bifurcaci√≥n real: obtiene cualquier funci√≥n memorizada por Kashe y devuelve la misma, pero con otra entrada de cach√© interna.  ¬øRecuerdas el m√©todo de f√°brica redux mapStateToProps? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// const selector = createSelector(...); // const selector = fork(realSelector); // just fork existing selector. Or box it, or don't do anything // kashe is more "stable" than reselect. return state =&gt; ({ data: selector(data), }); }</span></span></code> </pre> <br><h2 id="reselect">  Reseleccionar </h2><br><p>  Y hay una cosa m√°s que debes saber: Kashe podr√≠a reemplazar la reselecci√≥n.  Literalmente </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createSelector } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'kashe/reselect'</span></span>;</code> </pre> <br><p>  En realidad, es la misma reselecci√≥n, reci√©n creada con kashe como funci√≥n de memorizaci√≥n. </p><br><h1 id="codesandbox">  C√≥digos y caja </h1><br><p>  Aqu√≠ hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">peque√±o ejemplo</a> para jugar.  Tambi√©n puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">verificar</a> dos veces las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pruebas</a> : son compactas y s√≥lidas. <br>  Si desea saber m√°s sobre el almacenamiento en cach√© y la memorizaci√≥n, compruebe c√≥mo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escrib√≠ la biblioteca de memorizaci√≥n m√°s r√°pida hace</a> un a√±o. </p><br><blockquote>  PD: Vale la pena mencionar, que la versi√≥n m√°s simple de este enfoque - d√©bil-memorizar - se utiliza en la emoci√≥n-js por un tiempo.  No tengo quejas  nano-memoize tambi√©n usa WeakMaps para un caso de argumento √∫nico. </blockquote><p>  ¬øEntendido?  Un enfoque m√°s "d√©bil" lo ayudar√≠a a recordar mejor algo y olvidarlo mejor. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/theKashey/kashe</a> </p><br><p>  S√≠, sobre olvidar algo, ¬øpodr√≠as mirar aqu√≠? </p><br><p><img src="https://habrastorage.org/webt/60/d6/9y/60d69ysm9v5hy9dnm1siokafjhu.jpeg"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446390/">https://habr.com/ru/post/446390/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446376/index.html">¬øC√≥mo escribir la direcci√≥n de la casa correctamente?</a></li>
<li><a href="../446378/index.html">El problema de cambiar al horario de invierno y verano para una sola escuela de Skype</a></li>
<li><a href="../446380/index.html">H2 evolution: funciones de ventana, CTE, JSON / XML en una base de datos integrada</a></li>
<li><a href="../446384/index.html">Consejos para desarrollar proyectos muy grandes en Revit</a></li>
<li><a href="../446388/index.html">La industria del petr√≥leo y el gas como ejemplo para los sistemas de nubes perif√©ricas.</a></li>
<li><a href="../446394/index.html">5. Check Point Getting Started R80.20. Gaia y CLI</a></li>
<li><a href="../446396/index.html">Reinicio del contador de semana GPS</a></li>
<li><a href="../446400/index.html">Dmitry Dumik, Chatfuel: sobre Y Combinator, emprendimiento tecnol√≥gico, cambio de comportamiento y conciencia</a></li>
<li><a href="../446402/index.html">Aplicaciones multiling√ºes en angular</a></li>
<li><a href="../446404/index.html">Alternativas modernas a PGP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>