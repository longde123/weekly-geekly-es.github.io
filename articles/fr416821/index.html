<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôéüèø üìä üíö Fonctionnement de JS: communications WebRTC et P2P üë©‚Äç‚öñÔ∏è üëî üë®üèª‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Conseiller la lecture] Les 19 autres parties du cycle  Partie 1: Pr√©sentation du moteur, des m√©canismes d'ex√©cution, de la pile d'appels 
 Partie 2: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fonctionnement de JS: communications WebRTC et P2P</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/416821/"><div class="spoiler">  <b class="spoiler_title">[Conseiller la lecture] Les 19 autres parties du cycle</b> <div class="spoiler_text">  Partie 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pr√©sentation du moteur, des m√©canismes d'ex√©cution, de la pile d'appels</a> <br>  Partie 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä propos des internes V8 et de l'optimisation du code</a> <br>  Partie 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">G√©rer la m√©moire, quatre types de fuites de m√©moire et y faire face</a> <br>  Partie 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boucle d'√©v√©nement, asynchrone et cinq fa√ßons d'am√©liorer votre code avec async / wait</a> <br>  Partie 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WebSocket et HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Que choisir?</a> <br>  Partie 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Caract√©ristiques et port√©e de WebAssembly</a> <br>  Partie 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Travailleurs Web et cinq sc√©narios d'utilisation</a> <br>  Partie 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Travailleurs des services</a> <br>  Partie 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Notifications push Web</a> <br>  Partie 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suivre les changements dans le DOM avec MutationObserver</a> <br>  Partie 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moteurs de rendu de page Web et conseils pour optimiser leurs performances</a> <br>  Partie 12: Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sous-syst√®me r√©seau des navigateurs, optimisant ses performances et sa s√©curit√©</a> <br>  Partie 12: Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sous-syst√®me r√©seau des navigateurs, optimisant ses performances et sa s√©curit√©</a> <br>  Partie 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Animation avec CSS et JavaScript</a> <br>  Partie 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: arborescences de syntaxe abstraite, analyse et optimisation</a> <br>  Partie 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: classes et h√©ritage, transpilation dans Babel et TypeScript</a> <br>  Partie 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: stockage</a> <br>  Partie 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: technologie Shadow DOM et composants Web</a> <br>  Partie 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: m√©canismes de communication WebRTC et P2P</a> <br>  Partie 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: √©l√©ments personnalis√©s</a> </div></div><br>  Aujourd'hui, nous publions une traduction de la partie 18 d'une s√©rie de documents d√©di√©s √† tout ce qui concerne JavaScript.  Nous parlerons ici de la technologie WebRTC, qui vise √† organiser l'√©change de donn√©es direct entre les applications de navigateur en temps r√©el. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/aff/ed1/fee/affed1fee433a9375eefd24a753a89b8.png" alt="image"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Revue</font> </h2><br>  Qu'est-ce que WebRTC?  Pour commencer, il convient de noter que l'abr√©viation RTC signifie Real Time Communication (communication en temps r√©el).  Cela donne √† lui seul beaucoup d'informations sur cette technologie. <br><br>  WebRTC occupe une niche tr√®s importante parmi les m√©canismes de la plate-forme Web.  Auparavant, les technologies P2P (connexions peer-to-peer, point √† point, r√©seaux peer-to-peer, peer-to-peer) utilis√©es par des applications telles que les chats de bureau leur offraient des opportunit√©s que les projets Web n'avaient pas.  WebRTC fait une diff√©rence pour les technologies Web. <br><br>  WebRTC, si nous regardons cette technologie en termes g√©n√©raux, permet aux applications Web de cr√©er des connexions P2P, dont nous discuterons ci-dessous.  De plus, nous couvrirons ici les sujets suivants afin de montrer l'image compl√®te de la structure interne de WebRTC: <br><br><ul><li>  Communications P2P. </li><li>  Pare-feu et technologie NAT Traversal. </li><li>  Signalisation, sessions et protocoles. </li><li>  API WebRTC </li></ul><br><h2>  <font color="#3AC1EF">Communications P2P</font> </h2><br>  Supposons que deux utilisateurs aient lanc√©, chacun dans leur propre navigateur, une application qui vous permet d'organiser un chat vid√©o √† l'aide de WebRTC.  Ils veulent √©tablir une connexion P2P.  Une fois la d√©cision prise, nous avons besoin d'un m√©canisme permettant aux navigateurs des utilisateurs de se retrouver et d'√©tablir une communication en tenant compte des m√©canismes de protection des informations disponibles dans les syst√®mes.  Apr√®s avoir √©tabli une connexion, les utilisateurs pourront √©changer des informations multim√©dias en temps r√©el. <br><br>  L'une des principales difficult√©s associ√©es aux connexions P2P des navigateurs est que les navigateurs doivent d'abord se d√©couvrir, puis √©tablir une connexion r√©seau bas√©e sur des sockets pour assurer un transfert de donn√©es bidirectionnel.  Nous vous sugg√©rons de discuter des difficult√©s li√©es √† l'installation de telles connexions. <br><br>  Lorsqu'une application Web a besoin de donn√©es ou de ressources, elle les t√©l√©charge depuis le serveur et c'est tout.  L'adresse du serveur est connue de l'application.  Si nous parlons, par exemple, de cr√©er un chat P2P, dont le fonctionnement est bas√© sur la connexion directe de navigateurs, les adresses de ces navigateurs ne sont pas connues √† l'avance.  Par cons√©quent, pour √©tablir une connexion P2P, vous devrez faire face √† certains probl√®mes. <br><br><h2>  <font color="#3AC1EF">Pare-feu et protocole NAT Traversal</font> </h2><br>  En r√®gle g√©n√©rale, les ordinateurs IP externes statiques ne sont pas affect√©s √† des ordinateurs ordinaires.  La raison en est que ces ordinateurs sont g√©n√©ralement situ√©s derri√®re des pare-feu et des p√©riph√©riques NAT. <br><br>  NAT est un m√©canisme qui traduit les adresses IP locales internes situ√©es derri√®re un pare-feu en adresses IP globales externes.  La technologie NAT est utilis√©e, d'une part, pour des raisons de s√©curit√©, et d'autre part, en raison des restrictions impos√©es par IPv4 sur le nombre d'adresses IP globales disponibles.  C'est pourquoi les applications Web utilisant WebRTC ne doivent pas se fier au fait que le p√©riph√©rique actuel poss√®de une adresse IP statique globale. <br><br>  Voyons comment fonctionne NAT.  Si vous √™tes sur un r√©seau d'entreprise et connect√© au WiFi, votre ordinateur se verra attribuer une adresse IP qui existe uniquement derri√®re votre appareil NAT.  Supposons qu'il s'agisse de l'adresse IP 172.0.23.4.  Pour le monde ext√©rieur, cependant, votre adresse IP peut ressembler √† 164.53.27.98.  En cons√©quence, le monde ext√©rieur consid√®re vos demandes comme provenant de l'adresse 164.53.27.98, mais gr√¢ce √† NAT, les r√©ponses aux demandes faites par votre ordinateur √† des services externes seront envoy√©es √† votre adresse interne 172.0.23.4.  Cela se produit √† l'aide de tables de traduction.  Veuillez noter qu'en plus de l'adresse IP, un num√©ro de port est √©galement requis pour la mise en r√©seau. <br><br>  √âtant donn√© que NAT est impliqu√© dans le processus d'interaction de votre syst√®me avec le monde ext√©rieur, votre navigateur, afin d'√©tablir une connexion WebRTC, doit conna√Ætre l'adresse IP de l'ordinateur sur lequel le navigateur que vous souhaitez communiquer s'ex√©cute. <br><br>  C'est l√† que les serveurs STUN (Session Traversal Utilities for NAT) et TURN (Traversal Using Relays around NAT) entrent en sc√®ne.  Pour garantir le fonctionnement de la technologie WebRTC, une demande est d'abord faite au serveur STUN pour conna√Ætre votre adresse IP externe.  En fait, nous parlons d'une requ√™te adress√©e √† un serveur distant afin de savoir √† partir de quelle adresse IP le serveur re√ßoit cette requ√™te.  Apr√®s avoir re√ßu une demande similaire, le serveur distant enverra une r√©ponse contenant l'adresse IP visible pour lui. <br><br>  En supposant que ce syst√®me est op√©rationnel et que vous avez re√ßu des informations sur votre adresse IP externe et votre port, vous pouvez alors dire aux autres participants au syst√®me (nous les appellerons pairs) comment vous contacter directement.  Ces homologues peuvent √©galement faire de m√™me en utilisant des serveurs STUN ou TURN et peuvent vous dire quelles adresses leur sont attribu√©es. <br><br><h2>  <font color="#3AC1EF">Signalisation, sessions et protocoles</font> </h2><br>  Le processus de recherche d'informations sur le r√©seau, d√©crit ci-dessus, fait partie d'un grand syst√®me de signalisation qui, dans le cas de WebRTC, est bas√© sur la norme JSEP (JavaScript Session Establishment Protocol).  La signalisation comprend la d√©couverte de ressources r√©seau, la cr√©ation et la gestion de sessions, la s√©curit√© des communications, la coordination des param√®tres des m√©dias, la gestion des erreurs. <br><br>  Pour que la connexion fonctionne, les pairs doivent s'entendre sur les formats de donn√©es qu'ils √©changeront et collecter des informations sur les adresses r√©seau de l'ordinateur sur lequel l'application s'ex√©cute.  Le m√©canisme de signalisation pour partager ces informations critiques ne fait pas partie de l'API WebRTC. <br><br>  La signalisation n'est pas d√©finie par la norme WebRTC, et elle n'est pas impl√©ment√©e dans son API afin d'offrir une flexibilit√© dans les technologies et protocoles utilis√©s.  La signalisation et les serveurs qui la supportent sont √† la charge du d√©veloppeur de l'application WebRTC. <br><br>  En supposant que votre application WebRTC ex√©cut√©e dans le navigateur est capable de d√©terminer l'adresse IP externe du navigateur √† l'aide de STUN, comme d√©crit ci-dessus, l'√©tape suivante consiste √† discuter des param√®tres de session et √† √©tablir une connexion avec un autre navigateur. <br><br>  La discussion initiale des param√®tres de session et l'√©tablissement d'une connexion se fait √† l'aide d'un protocole de signalisation / communication sp√©cialis√© dans les communications multim√©dias.  Ce protocole est, en outre, responsable du respect des r√®gles selon lesquelles la session est g√©r√©e et termin√©e. <br><br>  L'un de ces protocoles est appel√© SIP (Session Initiation Protocol).  Veuillez noter qu'en raison de la flexibilit√© du sous-syst√®me de signalisation WebRTC, SIP n'est pas le seul protocole de signalisation qui peut √™tre utilis√©.  De plus, le protocole de signalisation s√©lectionn√© doit fonctionner avec un protocole de couche d'application appel√© SDP (Session Description Protocol), qui est utilis√© lors de l'utilisation de WebRTC.  Toutes les m√©tadonn√©es li√©es aux donn√©es multim√©dias sont transmises √† l'aide du protocole SDP. <br><br>  Tout homologue (c'est-√†-dire une application utilisant WebRTC) qui essaie de contacter un autre homologue g√©n√®re un ensemble de routes candidates pour le protocole ICE (Interactive Connectivity Establishment).  Les candidats repr√©sentent une combinaison d'adresse IP, de port et de protocole de transport qui peut √™tre utilis√©e.  Veuillez noter qu'un ordinateur peut avoir de nombreuses interfaces r√©seau (filaire, sans fil, etc.), de sorte qu'il peut se voir attribuer plusieurs adresses IP, une pour chaque interface. <br><br>  Voici un diagramme avec MDN illustrant le processus ci-dessus d'√©change de donn√©es. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c33/eb5/3a2/c33eb53a21f48ec8f629ac38fc503d4e.png"></div><br>  <i><font color="#999999">Le processus d'√©change de donn√©es n√©cessaire pour √©tablir une connexion P2P</font></i> <br><br><h2>  <font color="#3AC1EF">√âtablir une connexion</font> </h2><br>  Chaque pair d√©couvre d'abord son adresse IP externe comme d√©crit ci-dessus.  Ensuite, des ¬´canaux¬ª de donn√©es de signalisation sont cr√©√©s dynamiquement, qui servent √† d√©tecter les homologues et √† soutenir l'√©change de donn√©es entre eux, pour discuter des param√®tres de session et de leur installation. <br><br>  Ces ¬´canaux¬ª sont inconnus et inaccessibles au monde ext√©rieur, un identifiant unique est n√©cessaire pour y acc√©der. <br><br>  Veuillez noter qu'en raison de la flexibilit√© de WebRTC et du fait que le processus de signalisation n'est pas d√©fini par la norme, le concept de ¬´canaux¬ª et l'ordre de leur utilisation peuvent varier l√©g√®rement selon les technologies utilis√©es.  En fait, certains protocoles ne n√©cessitent pas de m√©canisme de ¬´canal¬ª pour organiser l'√©change de donn√©es.  Aux fins de ce document, nous supposons que les "canaux" dans la mise en ≈ìuvre du syst√®me sont utilis√©s. <br><br>  Si deux ou plusieurs homologues sont connect√©s au m√™me ¬´canal¬ª, les homologues ont la possibilit√© d'√©changer des donn√©es et de discuter des informations de session.  Ce processus est similaire √† un mod√®le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©diteur-abonn√©</a> .  En g√©n√©ral, l'homologue initiant la connexion envoie une ¬´offre¬ª √† l'aide d'un protocole de signalisation tel que SIP ou SDP.  L'initiateur s'attend √† recevoir une ¬´r√©ponse¬ª du destinataire de la proposition, qui est connect√©e au ¬´canal¬ª consid√©r√©. <br><br>  Une fois la r√©ponse re√ßue, le processus de d√©termination et de discussion des meilleurs candidats ICE recueillis par chaque f√™te a lieu.  Une fois les candidats ICE optimaux s√©lectionn√©s, les param√®tres de donn√©es qui seront √©chang√©s entre homologues et le m√©canisme de routage du r√©seau (adresse IP et port) sont convenus. <br><br>  Ensuite, une session de socket r√©seau active est √©tablie entre pairs.  En outre, chaque homologue cr√©e des flux de donn√©es locaux et des points d'extr√©mit√© des canaux de donn√©es, et la transmission bidirectionnelle des donn√©es multim√©dias commence √† utiliser la technologie appliqu√©e. <br><br>  Si le processus de n√©gociation pour choisir le meilleur candidat ICE √©choue, ce qui se produit parfois en raison de la d√©faillance des pare-feu et des syst√®mes NAT, une option de sauvegarde est utilis√©e, qui consiste √† utiliser, comme relais, un serveur TURN.  Ce processus implique un serveur qui agit comme un interm√©diaire qui relaie les donn√©es √©chang√©es entre pairs.  Veuillez noter que ce sch√©ma n'est pas une v√©ritable connexion P2P dans laquelle les pairs se transmettent directement des donn√©es. <br><br>  Lors de l'utilisation d'une solution de repli utilisant TURN pour l'√©change de donn√©es, chaque pair n'a plus besoin de savoir comment communiquer avec les autres et comment y transf√©rer des donn√©es.  Au lieu de cela, les pairs doivent savoir quel serveur TURN externe doit envoyer des donn√©es multim√©dias en temps r√©el et √† partir de quel serveur ils doivent recevoir pendant la session de communication. <br><br>  Il est important de comprendre qu'il s'agissait d√©sormais d'un moyen de secours pour organiser les communications.  Les serveurs TURN doivent √™tre tr√®s fiables, avoir une large bande passante et une puissance de calcul s√©rieuse, prendre en charge le travail avec des quantit√©s potentiellement importantes de donn√©es.  L'utilisation d'un serveur TURN entra√Æne donc √©videmment des surco√ªts et une augmentation de la complexit√© du syst√®me. <br><br><h2>  <font color="#3AC1EF">API WebRTC</font> </h2><br>  Il existe trois cat√©gories principales d'API qui existent dans WebRTC: <br><br><ul><li>  L'API Media Capture and Streams est responsable de la capture et de la diffusion multim√©dia.  Cette API vous permet de vous connecter √† des p√©riph√©riques d'entr√©e, tels que des microphones et des webcams, et d'en recevoir des flux multim√©dias. </li><li>  API RTCPeerConnection  En utilisant l'API de cette cat√©gorie, il est possible, √† partir d'un point de terminaison de WebRTC, d'envoyer, en temps r√©el, le flux captur√© de donn√©es audio ou vid√©o via Internet √† un autre point de terminaison de WebRTC.  √Ä l'aide de cette API, vous pouvez cr√©er des connexions entre la machine locale et l'homologue distant.  Il fournit des m√©thodes de connexion √† un homologue distant, de gestion de la connexion et de surveillance de son √©tat.  Ses m√©canismes sont utilis√©s pour fermer les connexions inutiles. </li><li>  API RTCDataChannel  Les m√©canismes repr√©sent√©s par cette API permettent le transfert de donn√©es arbitraires.  Chaque canal de donn√©es est associ√© √† une interface RTCPeerConnection. </li></ul><br>  Parlons de ces API. <br><br><h2>  <font color="#3AC1EF">Capture et flux de m√©dias API</font> </h2><br>  L'API Media Capture and Streams, souvent appel√©e API Media Stream ou Stream API, est une API qui prend en charge l'utilisation de flux de donn√©es audio et vid√©o, des m√©thodes pour les utiliser.  En utilisant cette API, vous pouvez d√©finir des restrictions li√©es aux types de donn√©es, ici il existe des rappels pour la r√©ussite et l'√©chec des op√©rations qui sont utilis√©es lors de l'utilisation de m√©canismes asynchrones pour travailler avec des donn√©es, et des √©v√©nements qui sont d√©clench√©s pendant le fonctionnement. <br><br>  La m√©thode <code>getUserMedia()</code> de l'API <code>getUserMedia()</code> demande √† l'utilisateur l'autorisation de travailler avec des p√©riph√©riques d'entr√©e qui produisent des flux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MediaStream</a> avec des pistes audio ou vid√©o contenant les types de m√©dias demand√©s.  Un tel flux peut inclure, par exemple, une piste vid√©o (sa source est une source vid√©o mat√©rielle ou virtuelle, telle qu'une cam√©ra, un enregistreur vid√©o, un service de partage d'√©cran, etc.), une piste audio (des sources audio physiques ou virtuelles peuvent √©galement la former, comme un microphone, un convertisseur analogique-num√©rique, etc.) et √©ventuellement d'autres types de pistes. <br><br>  Cette m√©thode renvoie la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">promesse</a> qui se r√©sout en l'objet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MediaStream</a> .  Si l'utilisateur rejette la demande d'autorisation ou si le m√©dia correspondant n'est pas disponible, la promesse sera r√©solue, respectivement, avec une <code>NotFoundError</code> <code>PermissionDeniedError</code> ou <code>NotFoundError</code> . <br><br>  Vous pouvez acc√©der au singleton <code>MediaDevice</code> via l'objet <code>navigator</code> : <br><br><pre> <code class="hljs php">navigator.mediaDevices.getUserMedia(constraints) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> });</code> </pre> <br>  Notez que lorsque vous appelez la m√©thode <code>getUserMedia()</code> , vous devez lui passer un objet de <code>constraints</code> qui indique √† l'API quel type de flux il doit retourner.  Ici, vous pouvez configurer beaucoup de choses, y compris la cam√©ra que vous souhaitez utiliser (avant ou arri√®re), la fr√©quence d'images, la r√©solution, etc. <br><br>  √Ä partir de la version 25, les navigateurs bas√©s sur Chromium vous permettent de transf√©rer l'audio de <code>getUserMedia()</code> des √©l√©ments audio ou vid√©o (cependant, notez que les √©l√©ments multim√©dias seront d√©sactiv√©s par d√©faut). <br><br>  La m√©thode <code>getUserMedia()</code> peut √©galement √™tre utilis√©e comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">n≈ìud d'entr√©e pour l'API Web Audio</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gotStream</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stream</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.AudioContext = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.AudioContext || <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.webkitAudioContext;   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> audioContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AudioContext();   <span class="hljs-comment"><span class="hljs-comment">//  AudioNode     var mediaStreamSource = audioContext.createMediaStreamSource(stream);   //       ,    ,   //       !   mediaStreamSource.connect(audioContext.destination); } navigator.getUserMedia({audio:true}, gotStream);</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Limitations li√©es √† la protection des informations personnelles</font> </h2><br>  La capture non autoris√©e de donn√©es √† partir d'un microphone ou d'une cam√©ra est une grave interf√©rence avec la vie personnelle de l'utilisateur.  Par cons√©quent, l'utilisation de <code>getUserMedia()</code> pr√©voit la mise en ≈ìuvre d'exigences tr√®s sp√©cifiques pour informer l'utilisateur de ce qui se passe et pour g√©rer les autorisations.  La m√©thode <code>getUserMedia()</code> doit toujours obtenir la permission de l'utilisateur avant d'ouvrir tout p√©riph√©rique d'entr√©e qui collecte des m√©dias, comme une webcam ou un microphone.  Les navigateurs peuvent offrir la possibilit√© de d√©finir une autorisation unique pour un domaine, mais ils sont tenus de demander l'autorisation au moins la premi√®re fois qu'ils acc√®dent aux p√©riph√©riques multim√©dias, et l'utilisateur doit explicitement accorder cette autorisation. <br><br>  De plus, les r√®gles relatives √† la notification √† l'utilisateur de ce qui se passe sont importantes ici.  Les navigateurs doivent afficher un indicateur qui indique l'utilisation d'un microphone ou d'une cam√©ra.  L'affichage d'un tel indicateur ne d√©pend pas de la pr√©sence dans le syst√®me d'indicateurs mat√©riels indiquant le fonctionnement de tels dispositifs.  En outre, les navigateurs doivent afficher un indicateur indiquant que l'autorisation d'utiliser le p√©riph√©rique d'entr√©e a √©t√© accord√©e, m√™me si le p√©riph√©rique n'est pas utilis√© √† un moment donn√© pour enregistrer les donn√©es pertinentes. <br><br><h2>  <font color="#3AC1EF">Interface RTCPeerConnection</font> </h2><br>  L'interface RTCPeerConnection est une connexion WebRTC entre l'ordinateur local et l'homologue distant.  Il fournit des m√©thodes pour se connecter √† un syst√®me distant, pour prendre en charge la connexion et surveiller son √©tat, et pour fermer la connexion une fois qu'elle n'est plus n√©cessaire. <br><br>  Voici un diagramme d'architecture WebRTC illustrant le r√¥le de RTCPeerConnection. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c0/a16/dfe/4c0a16dfe63b400dc7082cd733ffa863.png"></div><br>  <i><font color="#999999">R√¥le RTCPeerConnection</font></i> <br><br>  Du point de vue JavaScript, la principale connaissance qui peut √™tre tir√©e de l'analyse de ce diagramme est que RTCPeerConnection isole le d√©veloppeur Web des m√©canismes complexes situ√©s aux niveaux les plus profonds du syst√®me.  Les codecs et protocoles utilis√©s par WebRTC font un excellent travail afin de permettre l'√©change de donn√©es en temps r√©el, m√™me lors de l'utilisation de r√©seaux non fiables.  Voici quelques-unes des t√¢ches r√©solues par ces m√©canismes: <br><br><ul><li>  Masquage de la perte de paquets. </li><li>  Annulation d'√©cho. </li><li>  Adaptation de la bande passante. </li><li>  Mise en m√©moire tampon dynamique pour √©liminer la gigue. </li><li>  Contr√¥le automatique du volume. </li><li>  R√©duction et suppression du bruit. </li><li>  "Nettoyage" de l'image. </li></ul><br><h2>  <font color="#3AC1EF">API RTCDataChannel</font> </h2><br>  Comme pour les donn√©es audio et vid√©o, WebRTC prend en charge la transmission en temps r√©el d'autres types de donn√©es.  L'API RTCDataChannel vous permet d'organiser un √©change P2P de donn√©es arbitraires. <br><br>  Il existe de nombreux sc√©narios d'utilisation de cette API.  En voici quelques uns: <br><br><ul><li>  Jeux </li><li>  Conversations textuelles en temps r√©el. </li><li>  Transfert de fichiers. </li><li>  Organisation de r√©seaux d√©centralis√©s. </li></ul><br>  Cette API vise √† l'utilisation la plus efficace des capacit√©s de l'API RTCPeerConnection et vous permet d'organiser un syst√®me d'√©change de donn√©es puissant et flexible dans un environnement P2P.  Ses caract√©ristiques sont notamment les suivantes: <br><br><ul><li>  Travail efficace avec des sessions utilisant RTCPeerConnection. </li><li>  Prise en charge de plusieurs canaux de communication utilis√©s simultan√©ment avec hi√©rarchisation. </li><li>  Prise en charge de m√©thodes fiables et peu fiables de remise des messages. </li><li>  Gestion de la s√©curit√© int√©gr√©e (DTLS) et congestion. </li></ul><br>  La syntaxe ici est similaire √† celle utilis√©e lors de l'utilisation de la technologie WebSocket.  La m√©thode <code>send()</code> et l'√©v√©nement <code>message</code> sont appliqu√©s ici: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> peerConnection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webkitRTCPeerConnection(servers,   {<span class="hljs-attr"><span class="hljs-attr">optional</span></span>: [{<span class="hljs-attr"><span class="hljs-attr">RtpDataChannels</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}]} ); peerConnection.ondatachannel = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{   receiveChannel = event.channel;   receiveChannel.onmessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">)</span></span>{       <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">"#receiver"</span></span>).innerHTML = event.data;   }; }; sendChannel = peerConnection.createDataChannel(<span class="hljs-string"><span class="hljs-string">"sendDataChannel"</span></span>, {<span class="hljs-attr"><span class="hljs-attr">reliable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>}); <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">"button#send"</span></span>).onclick = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">"textarea#send"</span></span>).value;   sendChannel.send(data); }</code> </pre> <br><h2>  <font color="#3AC1EF">WebRTC dans le monde r√©el</font> </h2><br>  Dans le monde r√©el, la communication WebRTC n√©cessite des serveurs.  Les syst√®mes ne sont pas trop compliqu√©s; gr√¢ce √† eux, la s√©quence d'actions suivante est mise en ≈ìuvre: <br><br><ul><li>  Les utilisateurs se d√©couvrent et √©changent des informations les uns sur les autres, par exemple des noms. </li><li>  Les applications client (pairs) WebRTC √©changent des informations sur le r√©seau. </li><li>  Les pairs √©changent des informations sur les donn√©es multim√©dias, telles que le format vid√©o et la r√©solution. </li><li>  Les applications client WebRTC √©tablissent une connexion en contournant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les passerelles NAT</a> et les pare-feu. </li></ul><br>  En d'autres termes, WebRTC a besoin de quatre types de fonctions serveur: <br><br><ul><li>  Des moyens pour d√©couvrir les utilisateurs et organiser leur interaction. </li><li>  Signalisation. </li><li>  Bypass NAT et pare-feu. </li><li>  Serveurs relais utilis√©s lorsqu'une connexion P2P ne peut pas √™tre √©tablie. </li></ul><br>  Le protocole <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">STUN</a> et son extension <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TURN</a> sont utilis√©s par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ICE</a> pour permettre √† RTCPeerConnection de fonctionner avec les m√©canismes de contournement NAT et de faire face aux autres difficult√©s rencontr√©es lors de la transmission de donn√©es sur un r√©seau. <br><br>  Comme d√©j√† mentionn√©, ICE est un protocole pour connecter des pairs, comme deux clients de chat vid√©o.  Au tout d√©but de la session de communication, ICE essaie de connecter les pairs directement, avec le moins de retard possible, via UDP.  Au cours de ce processus, les serveurs STUN ont une seule t√¢che: laisser l'homologue derri√®re NAT apprendre son adresse publique et son port.  Jetez un ≈ìil √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette liste de</a> serveurs STUN disponibles (Google a √©galement de tels serveurs). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/935/4e9/1a09354e9eb986043dc153ffb8b82500.png"></div><br>  <i><font color="#999999">Serveurs STUN</font></i> <br><br><h2>  <font color="#3AC1EF">D√©tection des candidats ICE</font> </h2><br>  Si la connexion UDP ne peut pas √™tre √©tablie, ICE essaie d'√©tablir une connexion TCP: d'abord - sur HTTP, puis - sur HTTPS.  Si une connexion directe ne peut pas √™tre √©tablie - en particulier, en raison de l'impossibilit√© de contourner les NAT et les pare-feu d'entreprise, ICE utilise un interm√©diaire (relais) sous la forme d'un serveur TURN.  En d'autres termes, ICE essaiera d'abord d'utiliser STUN avec UDP pour la connexion directe des pairs, et si cela ne fonctionne pas, il utilisera une option de secours avec un locataire sous la forme d'un serveur TURN.  Le terme ¬´recherche de candidats¬ª fait r√©f√©rence au processus de recherche d'interfaces r√©seau et de ports. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80d/c0a/41b/80dc0a41b9c4f59966b325e95c99e9c3.png"></div><br>  <i><font color="#999999">Recherche d'interfaces et de ports r√©seau appropri√©s</font></i> <br><br><h2>  <font color="#3AC1EF">La s√©curit√©</font> </h2><br>  Les applications de communication en temps r√©el ou les plugins associ√©s peuvent entra√Æner des probl√®mes de s√©curit√©.  En particulier, nous parlons de ce qui suit: <br><br><ul><li>  Les donn√©es multim√©dias non chiffr√©es ou d'autres donn√©es peuvent √™tre intercept√©es le long du chemin entre les navigateurs, ou entre un navigateur et un serveur. </li><li>  Une application peut, √† l'insu de l'utilisateur, enregistrer et transmettre des donn√©es vid√©o et audio √† un attaquant. </li><li>  Associ√© √† un plug-in ou une application inoffensif, un virus ou un autre logiciel malveillant peut p√©n√©trer dans l'ordinateur de l'utilisateur. </li></ul><br>  WebRTC dispose de plusieurs m√©canismes con√ßus pour faire face √† ces menaces: <br><br><ul><li>  Les impl√©mentations WebRTC utilisent des protocoles s√©curis√©s comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DTLS</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SRTP</a> . </li><li>  Pour tous les composants des syst√®mes WebRTC, l'utilisation du chiffrement est obligatoire.  Cela s'applique √©galement aux m√©canismes de signalisation. </li><li>  WebRTC n'est pas un plugin.  Les composants WebRTC s'ex√©cutent dans le sandbox du navigateur, et non dans un processus distinct.  Les composants sont mis √† jour lorsque le navigateur est mis √† jour. </li><li>  L'acc√®s √† la cam√©ra et au microphone doit √™tre donn√© explicitement.  Et, lorsqu'une cam√©ra ou un microphone est utilis√©, ce fait est clairement affich√© dans l'interface utilisateur du navigateur. </li></ul><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  WebRTC est une technologie tr√®s int√©ressante et puissante pour les projets qui utilisent le transfert de toutes les donn√©es entre les navigateurs en temps r√©el.  L'auteur du document dit que sa soci√©t√©, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SessionStack</a> , utilise des m√©canismes traditionnels pour √©changer des donn√©es avec les utilisateurs, impliquant l'utilisation de serveurs.  Cependant, s'ils utilisaient WebRTC pour r√©soudre les probl√®mes correspondants, cela permettrait d'organiser l'√©change de donn√©es directement entre les navigateurs, ce qui entra√Ænerait une diminution du retard dans le transfert de donn√©es et r√©duirait la charge sur l'infrastructure de l'entreprise. <br><br>  <b>Chers lecteurs!</b>  Utilisez-vous la technologie WebRTC dans vos projets? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416821/">https://habr.com/ru/post/fr416821/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416809/index.html">Mod√®les de snooker Elo et EloBet</a></li>
<li><a href="../fr416813/index.html">Lorsque 2 x 3 = 2, ou encore une fois sur la virtualisation des donn√©es</a></li>
<li><a href="../fr416815/index.html">Comment nous avons arr√™t√© de passer une semaine √† publier un stand de d√©veloppement</a></li>
<li><a href="../fr416817/index.html">3e place dans la phase de qualification de DataScienceGame 2018</a></li>
<li><a href="../fr416819/index.html">Adieu, microservices: de cent enfants √† probl√®mes √† une superstar</a></li>
<li><a href="../fr416823/index.html">Sang, sueur et pixels: quel est le livre de Jason Schreier</a></li>
<li><a href="../fr416825/index.html">Comment ne PAS √™tre un d√©veloppeur m√©diocre</a></li>
<li><a href="../fr416827/index.html">Conteneurs pour adultes (partie 02): un guide pratique de la terminologie</a></li>
<li><a href="../fr416829/index.html">ABI Model Pattern v0.5.6 Beta</a></li>
<li><a href="../fr416831/index.html">L'acheminement externe du trafic int√©rieur russe sera r√©duit √† 5%</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>