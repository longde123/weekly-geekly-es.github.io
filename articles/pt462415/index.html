<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ì üë©üèª‚Äçüéì ‚è´ Implantar aplicativos Symfony + React na AWS por meio do IC üö• üê¥ üö£üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Boa tarde, neste artigo, mostrarei como implantar o aplicativo Symfony 4 na AWS. H√° um exemplo desse processo na documenta√ß√£o oficial, mas minha vers√£...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implantar aplicativos Symfony + React na AWS por meio do IC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462415/"> Boa tarde, neste artigo, mostrarei como implantar o aplicativo Symfony 4 na AWS.  H√° um exemplo desse processo na documenta√ß√£o oficial, mas minha vers√£o n√£o √© t√£o trivial quanto o download de um arquivo zip com um aplicativo.  No quintal de 2019, no modo docker, a arquitetura de microsservi√ßos e as pr√°ticas de CI / CD est√£o finalmente come√ßando a ser inclu√≠das nas ferramentas n√£o apenas dos engenheiros de DevOps, mas tamb√©m dos desenvolvedores <s>mortais</s> comuns.  Para tornar o artigo mais interessante, adicionei uma frente ao React.JS, para atender √†s necessidades de mais pessoas, se o seu aplicativo n√£o usar o Encore - n√£o importa, indicarei como alterar o arquivo do Docker para voc√™, o suporte ao React.JS o afeta apenas .  Quem estar√° interessado neste tutorial?  Antes de tudo, ele √© voltado para desenvolvedores de PHP que desejam mudar suas pr√°ticas de implanta√ß√£o - para se afastar dos c√¢nones comuns e usar o docker para compactar seu aplicativo e exibir a imagem.  Mas voc√™ pode se aprofundar um pouco mais, e a narra√ß√£o adicional ter√° como objetivo implantar automaticamente o aplicativo no Git por meio da plataforma CI / CD (o CircleCI ser√° usado, mas se voc√™ estiver interessado na configura√ß√£o do Gitlab, escreva nos coment√°rios, anexarei).  De fato, n√£o √© absolutamente importante para o React / PHP se voc√™ possui um aplicativo ou, por exemplo, o .NET Core, essa parte ser√° interessante para os desenvolvedores obterem as habilidades de automa√ß√£o de implanta√ß√£o em geral.  O c√≥digo fonte est√° dispon√≠vel no reposit√≥rio do github, link no final do artigo.  Bem, vamos l√°! <br><a name="habracut"></a><br>  Suponho que voc√™ tenha seu pr√≥prio aplicativo Symfony, mas para fins de demonstra√ß√£o, esbo√ßamos ‚Äúol√°, mundo!‚Äù Contendo os seguintes pacotes: <br><br>  <code>`symfony/webpack-encore-bundle symfony/form symfony/orm-pack symfony/profiler-pack symfony/security-bundle symfony/twig-bundle symfony/validator symfony/phpunit-bridge`</code> √© um conjunto m√≠nimo de cavalheiros.  No momento, a estrutura da pasta deve ser a seguinte: <br><br><img width="350" src="https://habrastorage.org/webt/6m/ck/xi/6mckxiczmqlde3nsjhdpzcbforq.png" alt="imagem"><br><br>  Agora voc√™ precisa configurar sua infraestrutura de nuvem.  N√£o vou me concentrar em registrar e ativar o per√≠odo de avalia√ß√£o da AWS; neste est√°gio, precisamos criar 2 inst√¢ncias de banco de dados - usarei 2 tipos de ambiente: STG (teste) para testar a implementa√ß√£o de novos "recursos" e PROD (produ√ß√£o) como diretamente "combater" servidor  Muitos artigos foram escritos sobre os benef√≠cios do banco de dados de servi√ßo gerenciado. Al√©m disso, buscamos principalmente a conveni√™ncia do desenvolvedor neste guia, portanto, usamos o RDS, em vez de criar nosso pr√≥prio servidor de banco de dados separado.  Como DBMS para este exemplo, eu usei o PostgreSQL, voc√™ √© livre para escolher qualquer um que lhe conv√©m, acessar o servi√ßo RDS e criar 2 inst√¢ncias da capacidade e volume necess√°rios.  Como o arquivo <code>.env</code> est√° dispon√≠vel para n√≥s " <code>.env</code> para uso" no Symfony, n√≥s o usaremos, por exemplo, para o PROD e para o STG criaremos uma c√≥pia do <code>.env.stg</code> e <code>APP_ENV=dev</code> para <code>APP_ENV=stg</code> <code>APP_ENV=dev</code> em <code>APP_ENV=stg</code> em <code>.env.stg</code> e <code>APP_ENV=dev</code> em <code>APP_ENV=prod</code> em <code>.env</code> e tamb√©m insira os par√¢metros de conex√£o com o <code>.env</code> para cada uma das inst√¢ncias criadas. <br><br>  √ìtimo, um come√ßo foi feito!  Como voc√™ sabe, as depend√™ncias do symfony s√£o instaladas atrav√©s do compositer; para instal√°-lo, use o arquivo composer.sh, que colocamos na raiz do projeto: <br><br><div class="spoiler">  <b class="spoiler_title">compositer.sh</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#!/bin/sh EXPECTED_SIGNATURE="$(wget -q -O - https://composer.github.io/installer.sig)" php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');" ACTUAL_SIGNATURE="$(php -r "echo hash_file('sha384', 'composer-setup.php');")" if [ "$EXPECTED_SIGNATURE" != "$ACTUAL_SIGNATURE" ] then &gt;&amp;2 echo 'ERROR: Invalid installer signature' rm composer-setup.php exit 1 fi php composer-setup.php --quiet RESULT=$? rm composer-setup.php exit $RESULT</code> </pre> <br></div></div><br>  Este <a href="">√© um</a> guia de <a href="">instala√ß√£o de software do compositor</a> . <br><br>  Agora, para cada um dos ambientes, crie seu pr√≥prio Dockerfile na raiz do projeto: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerfile.stg (armazenamento tempor√°rio)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">FROM php:7.2.19-apache EXPOSE 80 RUN mv "$PHP_INI_DIR/php.ini-production" "$PHP_INI_DIR/php.ini" &amp;&amp; a2enmod rewrite RUN sed -ri -e 's!memory_limit = 128M!memory_limit = 256M!g' "$PHP_INI_DIR/php.ini" RUN apt-get update &amp;&amp; apt-get install -y \ wget \ curl \ libfreetype6-dev \ libjpeg62-turbo-dev \ libpng-dev \ libzip-dev \ zip \ libpq-dev \ &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \ &amp;&amp; docker-php-ext-configure zip --with-libzip \ &amp;&amp; docker-php-ext-configure pgsql -with-pgsql=/usr/local/pgsql \ &amp;&amp; docker-php-ext-install -j$(nproc) gd \ &amp;&amp; docker-php-ext-install zip \ &amp;&amp; docker-php-ext-install pdo pdo_pgsql pgsql WORKDIR /var/www ENV APACHE_DOCUMENT_ROOT /var/www/public RUN sed -ri -e 's!/var/www/html!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/sites-available/*.conf RUN sed -ri -e 's!/var/www/!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/apache2.conf /etc/apache2/conf-available/*.conf RUN echo "ServerName localhost" &gt;&gt; /etc/apache2/apache2.conf COPY ./composer.sh ./ RUN chmod +x ./composer.sh &amp;&amp; ./composer.sh &amp;&amp; mv composer.phar /usr/local/bin/composer RUN curl -sL https://deb.nodesource.com/setup_10.x | bash - \ &amp;&amp; apt-get install -y nodejs RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \ &amp;&amp; echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list \ &amp;&amp; apt-get update -qq \ &amp;&amp; apt-get install -y yarn COPY ./ ./ COPY ./.env.stg ./.env RUN composer install &amp;&amp; yarn &amp;&amp; yarn run build</code> </pre> <br></div></div><br>  e <br><br><div class="spoiler">  <b class="spoiler_title">Dockerfile (produ√ß√£o)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">FROM php:7.2.19-apache EXPOSE 80 RUN mv "$PHP_INI_DIR/php.ini-production" "$PHP_INI_DIR/php.ini" &amp;&amp; a2enmod rewrite RUN sed -ri -e 's!memory_limit = 128M!memory_limit = 256M!g' "$PHP_INI_DIR/php.ini" RUN apt-get update &amp;&amp; apt-get install -y \ wget \ curl \ libfreetype6-dev \ libjpeg62-turbo-dev \ libpng-dev \ libzip-dev \ zip \ libpq-dev \ &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \ &amp;&amp; docker-php-ext-configure zip --with-libzip \ &amp;&amp; docker-php-ext-configure pgsql -with-pgsql=/usr/local/pgsql \ &amp;&amp; docker-php-ext-install -j$(nproc) gd \ &amp;&amp; docker-php-ext-install zip \ &amp;&amp; docker-php-ext-install pdo pdo_pgsql pgsql WORKDIR /var/www ENV APACHE_DOCUMENT_ROOT /var/www/public RUN sed -ri -e 's!/var/www/html!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/sites-available/*.conf RUN sed -ri -e 's!/var/www/!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/apache2.conf /etc/apache2/conf-available/*.conf RUN echo "ServerName localhost" &gt;&gt; /etc/apache2/apache2.conf COPY ./composer.sh ./ RUN chmod +x ./composer.sh &amp;&amp; ./composer.sh &amp;&amp; mv composer.phar /usr/local/bin/composer RUN curl -sL https://deb.nodesource.com/setup_10.x | bash - \ &amp;&amp; apt-get install -y nodejs RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \ &amp;&amp; echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list \ &amp;&amp; apt-get update -qq \ &amp;&amp; apt-get install -y yarn COPY ./ ./ RUN composer install &amp;&amp; yarn &amp;&amp; yarn run build</code> </pre> <br></div></div><br>  Os arquivos podem ser usados ‚Äã‚Äã"como est√£o", nenhuma macro √© usada para altera√ß√µes.  Vamos percorrer o conte√∫do do Dockerfile para dissipar o toque "m√°gico".  Como "base", usamos a imagem oficial do PHP 7.2.19 com o servidor da Web Apache integrado (voc√™ pode usar qualquer um de sua escolha, configurar um pacote com o Nginx e assim por diante. Neste exemplo, eu uso o acima como o mais, na minha opini√£o, conveniente).  A linha de exposi√ß√£o n√£o √© importante para n√≥s no momento, por si s√≥ n√£o faz nada, mas no futuro ser√° usada pelo ElasticBeanstalk, que precisa ser implantado corretamente.  As constru√ß√µes a seguir usam as configura√ß√µes de produ√ß√£o otimizadas para PHP recomendadas pelo fabricante, ativam o mod_rewrite para Apache e aumentam o tamanho m√°ximo da mem√≥ria para um script PHP de 128 para 256 mb, o que √© necess√°rio para o compositor funcionar corretamente.  Em seguida, instalamos os aplicativos necess√°rios, depend√™ncias e extens√µes PHP e os configuramos imediatamente.  Atribu√≠mos a pasta / var / www ao diret√≥rio de trabalho do nosso aplicativo - o c√≥digo fonte do nosso aplicativo ser√° copiado para ele.  Como o apache, por padr√£o, usa / var / www como um ponto de entrada para seu host, e o arquivo de √≠ndice symfony est√° localizado em / var / www / public, alteramos a raiz do documento apache com a seguinte constru√ß√£o.  Em seguida, instalamos o compositor, nodejs e yarn sequencialmente (se voc√™ n√£o usar encore / react.js em seu aplicativo, n√£o precisar√° dos dois √∫ltimos pontos).  Por fim, copiamos nosso c√≥digo fonte e iniciamos a instala√ß√£o de depend√™ncias atrav√©s do composer for symfony e yarn for react.js.  O significado de um Dockerfile para STG separado est√° na pen√∫ltima instru√ß√£o para docker - copiar .env.stg para .env, portanto, o arquivo .env na imagem STG conter√° os par√¢metros relevantes para esse ambiente.  Voc√™ pode coletar localmente (√© claro, com o docker instalado) a imagem, execut√°-la e garantir que o aplicativo esteja funcionando e que n√£o precise de mais nada para este trabalho: <br><br><pre> <code class="plaintext hljs">docker build -t tmp:stg -f Dockerfile.stg . docker run -p 80:80 tmp:stg</code> </pre> <br>  para STG e <br><br><pre> <code class="plaintext hljs">docker build -t tmp:prod . docker run -p 80:80 tmp:prod</code> </pre> <br>  para PROD. <br>  Podemos usar o EC2, configurar o ELB / ASG etc., ou usar o ElasticBeanstalk, que √© apenas um presente para n√≥s em termos de conveni√™ncia.  V√° para a se√ß√£o ElasticBeanstalk e crie um novo aplicativo com seu nome e descri√ß√£o.  Em seguida, crie 2 ambientes mencionados anteriormente: STG e PROD, crie ambos os ambientes como um ambiente de servidor da Web, especifique ‚ÄúDocker‚Äù como plataforma e deixe o aplicativo de Amostra como o c√≥digo do aplicativo.  A implanta√ß√£o no ElasticBeanstalk √© feita atrav√©s do upload de arquivos ou instru√ß√µes do projeto, geralmente em um arquivo zip.  No nosso caso, o fluxo ser√° assim: coletamos a imagem do docker do nosso aplicativo, carregamos no reposit√≥rio e carregamos a instru√ß√£o em vez do arquivo de origem ou da imagem do docker, o que instrui o ElasticBeanstalk a tirar a imagem do servidor remoto e implant√°-la.  E tudo isso √© autom√°tico. <br><br>  Vamos come√ßar criando um reposit√≥rio para armazenar imagens do docker.  Existem 2 op√ß√µes: <br><br>  1 - seu projeto √© privado, seu c√≥digo √© fechado e o reposit√≥rio, respectivamente, tamb√©m deve ser fechado.  Nesse caso, voc√™ mant√©m seu pr√≥prio registro de imagens em algum lugar ou usa uma nuvem privada.  A AWS possui ECR para esses fins, voc√™ pode criar um reposit√≥rio l√°, mas ningu√©m o obriga a fazer isso. <br><br>  2 - voc√™ tem um projeto de c√≥digo aberto e pode usar o dockerhub. <br><br>  No nosso exemplo, o c√≥digo est√° aberto, mas mostrarei como usar reposit√≥rios fechados, depois de entender esse processo, conectar uma imagem do dockerhub n√£o ser√° dif√≠cil.  A primeira coisa que precisamos √© criar o pr√≥prio reposit√≥rio, depois disso voc√™ obter√° seu URI exclusivo.  A narra√ß√£o adicional ser√° para terceiros (n√£o os reposit√≥rios da AWS ECR e sua integra√ß√£o), pois a ECR escreverei depois disso. <br><br>  Ap√≥s criar o reposit√≥rio, precisamos fazer logon neste servi√ßo e h√° um pequeno truque ... V√° para as configura√ß√µes da janela de encaixe instalada localmente e verifique se voc√™ tem a op√ß√£o de salvar as senhas no armazenamento externo removido (para usu√°rios do macOS: ‚ÄúArmazene com seguran√ßa os logins da janela de encaixe no macOS Keychain "), caso contr√°rio, o arquivo de configura√ß√£o de que precisamos estar√° vazio.  E assim, autorizamos no servi√ßo selecionado a armazenar os registros de suas imagens: <br><br><pre> <code class="plaintext hljs">docker login -u LOGIN -p PASSWORD REGISTRY</code> </pre> <br>  ap√≥s a autentica√ß√£o bem-sucedida, a seguinte constru√ß√£o aparecer√° no arquivo de configura√ß√£o ~ / .docker / config.json: <br><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"REGISTRY"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"auth"</span></span> : <span class="hljs-string"><span class="hljs-string">"BASE64_ENCODED_TOKEN"</span></span> }</code> </pre><br>  Se n√£o aparecer, verifique a configura√ß√£o da janela de encaixe descrita acima novamente. <br><br>  Agora tudo est√° pronto para preparar o arquivo de instru√ß√µes para ElasticBeanstalk - Dockerrun.aws.json, seu c√≥digo ser√° assim: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerrun.aws.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"AWSEBDockerrunVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Authentication"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Bucket"</span></span>: <span class="hljs-string"><span class="hljs-string">"BUCKET_ID"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Key"</span></span>: <span class="hljs-string"><span class="hljs-string">"KEY_PATH"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Image"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"IMAGE_URL"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Update"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Ports"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"ContainerPort"</span></span>: <span class="hljs-string"><span class="hljs-string">"80"</span></span> } ] }</code> </pre><br></div></div><br>  Em geral, a instru√ß√£o √© semelhante a esta: ap√≥s o login usando a chave localizada por KEY_PATH no armazenamento S3 BUCKET_ID, carregue a imagem IMAGE_URL substituindo a salva, inicie-a encaminhando a porta 80 para a mesma porta no cont√™iner.  Agora, sobre as constantes usadas: <br><br>  BUCKET_ID √© a "mochila" criada automaticamente para voc√™ no servi√ßo S3, com a forma elasticbeanstalk-REGION-HASH, √© onde o sistema localiza arquivos de servi√ßo para o ElasticBeanstalk, incluindo arquivos de aplicativos que voc√™ baixa usando o bot√£o "Upload and deploy". <br><br>  KEY_PATH - caminho do arquivo de autoriza√ß√£o para o reposit√≥rio de imagens, eu uso o formato APP_NAME / cr.json, ou seja, na pasta BUCKET_ID sob o nome do meu aplicativo (eu crio, se ainda n√£o o tiver), coloquei o arquivo cr.json que cont√©m o c√≥digo recebido ap√≥s a autoriza√ß√£o no registro Imagens localmente: <br><br><div class="spoiler">  <b class="spoiler_title">BUCKET_ID / APP_NAME / cr.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"REGISTRY"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"auth"</span></span> : <span class="hljs-string"><span class="hljs-string">"BASE64_ENCODED_TOKEN"</span></span> } }</code> </pre> </div></div><br>  IMAGE_URL √© o URI exclusivo do seu registro de imagem + tag da pr√≥pria imagem; tudo deve ficar claro aqui. <br><br>  √â isso, agora podemos fazer o download desse arquivo como uma vers√£o do nosso aplicativo no ElasticBeanstalk, e ele abrir√° a imagem especificada e a implantar√°. <br><br>  Resta automatizar esse processo.  E, para ser absolutamente interessante, implementarei a sequ√™ncia de etapas para o pr√≥ximo fluxo: para todos os commit N√ÉO no ramo principal, a imagem ser√° coletada e implantada no ambiente STG e, se formos empurrados para o mestre, ou melhor, fech√°-lo e preench√™-lo com solicita√ß√£o de mesclagem , o c√≥digo ser√° implantado no PROD.  Assim, obtemos no PROD um assistente atualizado, no qual tudo deve ficar bem, e ramifica√ß√µes para o desenvolvimento e teste de novo c√≥digo no STG.  Para esta implementa√ß√£o, precisamos de instru√ß√µes para o upload de imagens n√£o recentes, copie Dockerrun.aws.json para Dockerrun.aws.stg.json e renomeie Dockerrun.aws.json para Dockerrun.aws.prod.json (apenas por conveni√™ncia). <br><br>  A √∫nica coisa que diferencia o Dockerrun.aws.stg.json do Dockerrun.aws.prod.json √© IMAGE_URL: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerrun.aws.stg.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"AWSEBDockerrunVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Authentication"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Bucket"</span></span>: <span class="hljs-string"><span class="hljs-string">"BUCKET_ID"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Key"</span></span>: <span class="hljs-string"><span class="hljs-string">"KEY_PATH"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Image"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"IMAGE_URL:dev"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Update"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Ports"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"ContainerPort"</span></span>: <span class="hljs-string"><span class="hljs-string">"80"</span></span> } ] }</code> </pre><br></div></div><br>  Como eu disse no come√ßo do artigo, usarei o CircleCI como um CI / CD, que, de acordo com meus sentimentos pessoais, √© mais r√°pido que o GitlabCI se eu usar a vers√£o SaaS gratuita.  O Travis gratuito funcionaria, mas como ele n√£o funciona com reposit√≥rios privados do git, n√£o conduzi uma demonstra√ß√£o espec√≠fica para que n√£o houvesse desapontamento quando essa oportunidade fosse necess√°ria.  Deixarei as configura√ß√µes do projeto no CircleCI para que os leitores estudem por si mesmas, darei as instru√ß√µes necess√°rias para a implanta√ß√£o - na raiz do nosso projeto, criaremos a pasta .circleci, nela config.yml, com o seguinte conte√∫do: <br><br><div class="spoiler">  <b class="spoiler_title">.circleci / config.yml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">version: 2 jobs: build: machine: true steps: - checkout - run: echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:dev -f Dockerfile.stg . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:dev build-master: machine: true steps: - checkout - run: echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:latest . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:latest deploy-stg: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.stg.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli deploy-prod: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.prod.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli workflows: version: 2 build: jobs: - build: filters: branches: ignore: - master - deploy-stg: requires: - build filters: branches: ignore: - master build-deploy: jobs: - build-master: filters: branches: only: - master - deploy-prod: requires: - build-master filters: branches: only: - master</code> </pre></div></div><br>  Eu pintei o fluxo em si um pouco antes, aqui ele √© traduzido em instru√ß√µes yaml para CircleCI, vamos seguir a implementa√ß√£o de etapas espec√≠ficas.  √â importante observar a presen√ßa de vari√°veis ‚Äã‚Äãde ambiente definidas para o IC que ser√£o usadas por ele durante o trabalho: <br><br>  CI_REGISTRY, CI_REGISTRY_USER, CI_REGISTRY_PASSWORD s√£o necess√°rios para acessar o armazenamento de imagens do docker - a mesma coisa que colocamos no cr.json, apenas sem base64 <br><br>  CI_REGISTRY / CI_REGISTRY_ID comp√µem um URL de imagem exclusivo, sem uma tag <br><br>  AWS_ACCESS_KEY_ID e AWS_SECRET_ACCESS_KEY - os nomes falam por si, s√£o cr√©ditos da AWS para o usu√°rio em cujo nome o CircleCI implantar√°.  Acesse o AWS IAM e crie um usu√°rio, adicione-o ao grupo de administradores e forne√ßa apenas acesso program√°tico.  Lembre-se de que o AWS_SECRET_ACCESS_KEY est√° dispon√≠vel para visualiza√ß√£o / c√≥pia apenas uma vez; depois de clicar no link de exibi√ß√£o, voc√™ n√£o o ver√° novamente. <br><br>  Voltar para as etapas de configura√ß√£o do CircleCI.  Qual √© a magia?  O checkout carrega o c√≥digo-fonte da ramifica√ß√£o git no diret√≥rio de trabalho atual; esse processo √© repetido em todos os trabalhos.  No processo de compila√ß√£o, efetuamos logon sequencialmente no reposit√≥rio, coletamos o c√≥digo com base no Dockerfile.stg sob a tag XXX: dev e o enviamos ao reposit√≥rio.  O build-master faz a mesma coisa, usa o Dockerfile ‚Äúregular‚Äù sob a tag XXX: latest for assembly. <br><br>  deploy-stg instala o AWS EB CLI e cria um perfil de autoriza√ß√£o no arquivo ~ / .aws / config, necess√°rio para que o CLI funcione corretamente e inicializa as vari√°veis ‚Äã‚Äãpara o CLI - voc√™ precisar√° especificar a regi√£o que escolher, a plataforma - sempre Docker e o nome do seu aplicativo.  Em seguida, copiamos o conte√∫do de Dockerrun.aws.stg.json para o novo arquivo Dockerrun.aws.json e, usando o ambiente e a regi√£o espec√≠ficos, fornecemos o comando para implantar nosso aplicativo usando o perfil de autoriza√ß√£o criado.  Por padr√£o, como resultado desse comando, todo o c√≥digo da ramifica√ß√£o monitorada terminar√° em um arquivo zip, que ser√° baixado no ElasticBeanstalk e descompactado l√°, mas essa opera√ß√£o √© relativamente cara, por isso criamos um novo arquivo Dockerrun.aws.json, que √© suficiente para implantar o criado por n√≥s imagem remota, e s√≥ precisamos carreg√°-la, de fato.  Para isso, crie um arquivo .ebignore na raiz do projeto: <br><br><div class="spoiler">  <b class="spoiler_title">.ebignore</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">* !Dockerrun.aws.json</code> </pre></div></div><br>  Esse arquivo usa a sintaxe .gitignore e √© .gitignore, mas n√£o para a Git CLI, mas para a AWS EB CLI.  Neste arquivo, digo √† CLI para ignorar todos os arquivos, exceto o Dockerrun.aws.json.  Agora, quando voc√™ executa o trabalho deploy-stg no ElasticBeanstalk, apenas o arquivo que criamos ser√° enviado.  deploy-prod faz o mesmo, apenas copia o conte√∫do do arquivo Dockerrun.aws.prod.json para Dockerrun.aws.json, e o √∫ltimo √© uma indica√ß√£o da sequ√™ncia de trabalho no formato CircleCI (deploy-stg ap√≥s build e deploy-prod ap√≥s build -master) e em quais ramifica√ß√µes os dados est√£o procurando (ignore: - master e somente: - master). <br><br>  Um pouco diferente √© sobre o AWS ECR, como prometi, voltaremos a ele.  Voc√™ n√£o precisa fazer login remotamente no ECR e criar um arquivo cr.json, pois o ElasticBeanstalk ‚Äúconhece um irm√£o pessoalmente‚Äù.  Assim, o Dockerrun.aws.json ter√° uma apar√™ncia diferente - simplesmente n√£o haver√° bloqueio de autentica√ß√£o: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerrun.aws.json (AWS ECR)</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"AWSEBDockerrunVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Image"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"IMAGE_URL"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Update"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Ports"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"ContainerPort"</span></span>: <span class="hljs-string"><span class="hljs-string">"80"</span></span> } ] }</code> </pre><br></div></div><br>  Mas como ent√£o a autentica√ß√£o acontecer√°?  O fato √© que o servi√ßo que acessa o ECR possui um certo conjunto de direitos, que por sua vez se baseiam em certas pol√≠ticas de seguran√ßa.  No nosso caso, quando a implanta√ß√£o √© iniciada via AWS CLI a partir de um servidor de terceiros (do IC), a fun√ß√£o "aws-elasticbeanstalk-ec2-role" √© usada, encontre-a no AWS IAM na se√ß√£o de fun√ß√µes e anexe a pol√≠tica adicional "AmazonEC2ContainerRegistryReadOnly" a ela.  Agora, o download de um reposit√≥rio privado para seu "vizinho" ser√° bem-sucedido sem erros. <br><br>  Mas isso √© exatamente o carregamento da mesma VPC, por meio da CLI, o comando docker login tamb√©m n√£o √© "sem truques": voc√™ precisa obter (apenas obter) cr√©ditos para o login do docker por meio da CLI da AWS, para isso existe um comando <br><br> <code>aws ecr get-login --region REGION --no-include-email</code> <br> <br>  Este comando retornar√° uma linha do logon do docker de formul√°rios ... <br><br> <code>eval $(aws ecr get-login --region EB_REGION --no-include-email)</code> <br> <br>  O comando primeiro receber√° uma cadeia de caracteres para autentica√ß√£o e, em seguida, inicia o processo correspondente.  Em vista dessas regras para o AWS ECR, o arquivo de instru√ß√µes para o CircleCI ter√° a seguinte apar√™ncia: <br><br><div class="spoiler">  <b class="spoiler_title">.circleci / config.yml (para AWS ECR)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">version: 2 jobs: build: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awscli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - setup_remote_docker - run: eval $(aws ecr get-login --region EB_REGION --no-include-email) - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:dev -f Dockerfile.stg . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:dev build-master: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awscli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - setup_remote_docker - run: eval $(aws ecr get-login --region EB_REGION --no-include-email) - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:latest . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:latest deploy-stg: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.stg.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli deploy-prod: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.prod.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli workflows: version: 2 build: jobs: - build: filters: branches: ignore: - master - deploy-stg: requires: - build filters: branches: ignore: - master build-deploy: jobs: - build-master: filters: branches: only: - master - deploy-prod: requires: - build-master filters: branches: only: - master</code> </pre></div></div><br>   docker-in-docker   setup_remote_docker   ,          .   ,       : <br><br><img width="350" src="https://habrastorage.org/webt/7e/cw/sj/7ecwsjkjjmr8myxiuutwkujwnkg.png" alt="imagem"><br><br>   ,     ,     ()      .   ¬´¬ª   .  ( - )  ,      ,         ,                . <br><br>    GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tutorial-aws-symfony-ci</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt462415/">https://habr.com/ru/post/pt462415/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt462401/index.html">Desenvolvedor Deadly Sins</a></li>
<li><a href="../pt462403/index.html">Sele√ß√£o do tamanho do monitor: teoria angular do tamanho, justificativa e compara√ß√£o</a></li>
<li><a href="../pt462407/index.html">Food Design Digest Julho 2019</a></li>
<li><a href="../pt462409/index.html">Biblioteca de gerador de c√≥digo Assembler para microcontroladores AVR. Parte 1</a></li>
<li><a href="../pt462411/index.html">Resolva o Sudoku com o algoritmo X</a></li>
<li><a href="../pt462417/index.html">Peti√ß√£o da Apple</a></li>
<li><a href="../pt462421/index.html">Computador de orienta√ß√£o Apollo - arquitetura e software de sistema. Parte 2</a></li>
<li><a href="../pt462423/index.html">Gerenciamento de Projetos</a></li>
<li><a href="../pt462429/index.html">VueJs + VueRouter + modal. Outra bicicleta</a></li>
<li><a href="../pt462431/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel 309 (29 de julho a 4 de agosto)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>