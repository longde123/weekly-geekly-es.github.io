<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤨 💗 🐫 RPC - eine Gelegenheit, neu in C ++ 14/17 zu testen 🎅🏼 📊 ✍🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einigen Jahren erhielten C ++ - Entwickler den lang erwarteten C ++ 11-Standard, der viele neue Dinge mit sich brachte. Und ich hatte ein Interess...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RPC - eine Gelegenheit, neu in C ++ 14/17 zu testen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421001/"><img src="https://habrastorage.org/webt/r5/fg/-w/r5fg-wsld9ujbwxghq54s-kpaso.jpeg" width="250" height="180" align="left">  Vor einigen Jahren erhielten C ++ - Entwickler den lang erwarteten C ++ 11-Standard, der viele neue Dinge mit sich brachte.  Und ich hatte ein Interesse daran, schnell auf den Einsatz bei alltäglichen Aufgaben umzusteigen.  Gehen Sie zu C ++ 14 und 17, das war nicht.  Es schien, dass es keine Reihe von Funktionen gab, die von Interesse wären.  Im Frühjahr habe ich beschlossen, mir die Innovationen der Sprache anzuschauen und etwas auszuprobieren.  Um mit Innovationen zu experimentieren, musste man sich eine Aufgabe ausdenken.  Ich musste nicht lange nachdenken.  Es wurde beschlossen, Ihren RPC mit benutzerdefinierten Datenstrukturen als Parameter und ohne Verwendung von Makros und Codegenerierung zu schreiben - alles in C ++.  Dies war dank der neuen Funktionen der Sprache möglich. <br><br>  Die Idee, Implementierung, Feedback mit Reddit, Verbesserungen - alles erschien im Frühjahr, Frühsommer.  Am Ende gelang es ihnen, den Posten auf Habr zu beenden. <br><br>  Hast du über deinen eigenen RPC nachgedacht?  Vielleicht hilft Ihnen das Material des Beitrags dabei, das Ziel, die Methoden und Mittel zu bestimmen und sich für das fertige zu entscheiden oder selbst etwas umzusetzen ... <br><a name="habracut"></a><br><h1>  Einführung </h1><br>  RPC (Remote Procedure Call) ist kein neues Thema.  Es gibt viele Implementierungen in verschiedenen Programmiersprachen.  Implementierungen verwenden verschiedene Datenformate und Transportmittel.  All dies kann sich in einigen Punkten widerspiegeln: <br><br><ul><li>  Serialisierung / Deserialisierung </li><li>  Transport </li><li>  Remote-Methodenausführung </li><li>  Ergebnis zurückgeben </li></ul><br>  Die Umsetzung wird durch das gewünschte Ziel bestimmt.  Sie können sich beispielsweise das Ziel setzen, eine hohe Geschwindigkeit beim Aufrufen einer Remote-Methode zu gewährleisten und die Benutzerfreundlichkeit zu beeinträchtigen, oder umgekehrt, um maximalen Komfort beim Schreiben von Code zu bieten und möglicherweise ein wenig an Leistung zu verlieren.  Die Ziele und Werkzeuge sind unterschiedlich ... Ich wollte Komfort und akzeptable Leistung. <br><br><h1>  Implementierung </h1><br>  Im Folgenden finden Sie einige Schritte zur Implementierung von RPC in C ++ 14/17. Der Schwerpunkt liegt auf einigen Sprachinnovationen, die zum Erscheinen dieses Materials geführt haben. <br><br>  Das Material ist für diejenigen gedacht, die aus irgendeinem Grund an ihrem RPC interessiert sind und möglicherweise bis jetzt zusätzliche Informationen benötigen.  In den Kommentaren wäre es interessant, eine Beschreibung der Erfahrungen anderer Entwickler zu sehen, die mit ähnlichen Aufgaben konfrontiert sind. <br><br><h2>  Serialisierung </h2><br>  Bevor Sie anfangen, Code zu schreiben, werde ich eine Aufgabe bilden: <br><br><ul><li>  Alle Methodenparameter und das zurückgegebene Ergebnis werden durch das Tupel übergeben. </li><li>  Aufgerufene Methoden selbst sind nicht erforderlich, um Tupel zu empfangen und zurückzugeben. </li><li>  Das Ergebnis des Packens eines Tupels sollte ein Puffer sein, dessen Format nicht festgelegt ist </li></ul><br>  Das Folgende ist der Code für einen vereinfachten String-Serializer. <br><br><div class="spoiler">  <b class="spoiler_title">string_serializer</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc::type { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> buffer = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;; } <span class="hljs-comment"><span class="hljs-comment">// namespace rpc::type namespace rpc::packer { class string_serializer final { public: template &lt;typename ... T&gt; type::buffer save(std::tuple&lt;T ... &gt; const &amp;tuple) const { auto str = to_string(tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); return {begin(str), end(str)}; } template &lt;typename ... T&gt; void load(type::buffer const &amp;buffer, std::tuple&lt;T ... &gt; &amp;tuple) const { std::string str{begin(buffer), end(buffer)}; from_string(std::move(str), tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); } private: template &lt;typename T, std::size_t ... I&gt; std::string to_string(T const &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::stringstream stream; auto put_item = [&amp;stream] (auto const &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &lt;&lt; std::quoted(i) &lt;&lt; ' '; else stream &lt;&lt; i &lt;&lt; ' '; }; (put_item(std::get&lt;I&gt;(tuple)), ... ); return std::move(stream.str()); } template &lt;typename T, std::size_t ... I&gt; void from_string(std::string str, T &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::istringstream stream{std::move(str)}; auto get_item = [&amp;stream] (auto &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &gt;&gt; std::quoted(i); else stream &gt;&gt; i; }; (get_item(std::get&lt;I&gt;(tuple)), ... ); } }; } // namespace rpc::packer</span></span></code> </pre> </div></div><br>  Und der Hauptfunktionscode, der die Funktionsweise des Serializers demonstriert. <br><br><div class="spoiler">  <b class="spoiler_title">Hauptfunktion</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple args{<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"Test string !!!"</span></span>}, <span class="hljs-number"><span class="hljs-number">3.14</span></span>}; rpc::packer::string_serializer serializer; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pack = serializer.save(args); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Pack data: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{begin(pack), end(pack)} &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(args) params; serializer.load(pack, params); <span class="hljs-comment"><span class="hljs-comment">// For test { auto pack = serializer.save(params); std::cout &lt;&lt; "Deserialized pack: " &lt;&lt; std::string{begin(pack), end(pack)} &lt;&lt; std::endl; } } catch (std::exception const &amp;e) { std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl; return EXIT_FAILURE; } return EXIT_SUCCESS; }</span></span></code> </pre></div></div><br>  <b>Akkreditierte Akzente</b> <br><br>  Zunächst müssen Sie den Puffer bestimmen, mit dem der gesamte Datenaustausch durchgeführt wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc::type { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> buffer = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;; } <span class="hljs-comment"><span class="hljs-comment">// namespace rpc::type</span></span></code> </pre><br>  Der Serializer verfügt über Methoden zum Speichern eines Tupels im Puffer (Speichern) und zum Laden aus dem Puffer (Laden). <br><br>  Die Speichermethode nimmt ein Tupel und gibt einen Puffer zurück. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... T&gt; type::<span class="hljs-function"><span class="hljs-function">buffer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;T ... &gt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;tuple)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> str = to_string(tuple, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_index_sequence&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> ... (T)&gt;{}); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {begin(str), end(str)}; }</code> </pre><br>  Ein Tupel ist eine Vorlage mit einer variablen Anzahl von Parametern.  Solche Muster erschienen in C ++ 11 und funktionierten gut.  Hier müssen Sie irgendwie alle Elemente einer solchen Vorlage durchgehen.  Es kann mehrere Optionen geben.  Ich werde eine der Funktionen von C ++ 14 verwenden - eine Folge von ganzen Zahlen (Indizes).  Der Typ make_index_sequence wurde in der Standardbibliothek angezeigt, mit der die folgende Sequenz abgerufen werden kann: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ints</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">integer_sequence</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">N</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_integer_sequence</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:integer_sequence&lt;T, <span class="hljs-comment"><span class="hljs-comment">/* a sequence 0, 1, 2, ..., N-1 */</span></span> &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> make_index_sequence = make_integer_sequence&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>, N&gt;;</code> </pre><br>  Ein ähnliches kann in C ++ 11 implementiert und dann von Projekt zu Projekt übertragen werden. <br><br>  Eine solche Folge von Indizes ermöglicht es, das Tupel zu "durchlaufen": <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... I&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;tuple, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::index_sequence&lt;I ... &gt;)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> stream; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> put_item = [&amp;stream] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same_v&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(i)&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;) stream &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::quoted(i) &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> stream &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; }; (put_item(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;I&gt;(tuple)), ... ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(stream.str()); }</code> </pre><br>  Die to_string-Methode verwendet mehrere Funktionen der neuesten C ++ - Standards. <br><br>  <b>Akkreditierte Akzente</b> <br><br>  In C ++ 14 wurde es möglich, auto als Parameter für Lambda-Funktionen zu verwenden.  Dies reichte beispielsweise bei der Arbeit mit den Algorithmen der Standardbibliothek oft nicht aus. <br><br>  In C ++ 17 wurde eine <b>Faltung</b> angezeigt, mit der Sie Code schreiben können, z. <br><br><pre> <code class="cpp hljs">(put_item(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;I&gt;(tuple)), ... );</code> </pre><br>  In dem gegebenen Fragment wird die Lambda-Funktion put_item für jedes der Elemente des übertragenen Tupels aufgerufen.  Dies garantiert eine von der Plattform und dem Compiler unabhängige Sequenz.  Ähnliches könnte in C ++ 11 geschrieben werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> … T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unused</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T &amp;&amp; … )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// ... unused(put_item(std::get&lt;I&gt;(tuple)) ... );</span></span></code> </pre><br>  In welcher Reihenfolge die Elemente gespeichert werden, hängt jedoch vom Compiler ab. <br><br>  In der C ++ 17-Standardbibliothek wurden viele Aliase angezeigt, z. B. zerfall_t, wodurch die Datensätze des Formulars reduziert wurden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> decay&lt;T&gt;::type</code> </pre><br>  Der Wunsch, kürzere Konstruktionen zu schreiben, hat einen Platz.  Das Vorlagendesign, bei dem sich einige Typnamen und Vorlagen in einer Zeile befinden, die durch Doppelpunkte und spitze Klammern getrennt sind, sieht gruselig aus.  Wie können Sie einige Ihrer Kollegen erschrecken?  In Zukunft versprechen sie, die Anzahl der Stellen zu reduzieren, an denen Sie Vorlage und Typname schreiben müssen. <br><br>  Der Wunsch nach Prägnanz gab eine weitere interessante Konstruktion der Sprache "if constexpr", die es vermeidet, viele private Spezialisierungen von Vorlagen zu schreiben. <br><br>  Es gibt einen interessanten Punkt.  Vielen wurde beigebracht, dass Switch- und ähnliche Konstrukte hinsichtlich der Skalierbarkeit von Code nicht sehr gut sind.  Es ist vorzuziehen, Laufzeit- / Kompilierungszeit-Polymorphismus und Überladung mit Argumenten zugunsten der „richtigen Wahl“ zu verwenden.  Und dann "if constexpr" ... Die Möglichkeit der Kompaktheit lässt nicht jeden gleichgültig.  Die Möglichkeit der Sprache bedeutet nicht, dass sie verwendet werden muss. <br><br>  Es war notwendig, eine separate Serialisierung für den Zeichenfolgentyp zu schreiben.  Zum bequemen Arbeiten mit Zeichenfolgen, z. B. beim Speichern in einem Stream und Lesen daraus, wurde die Funktion std :: quote angezeigt.  Sie können damit Zeichenfolgen überprüfen und in einem Stream speichern und Daten daraus laden, ohne an das Trennzeichen denken zu müssen. <br><br>  Sie können vorerst mit der Beschreibung der Serialisierung aufhören.  Die Deserialisierung (Last) wird ähnlich implementiert. <br><br><h2>  Transport </h2><br>  Der Transport ist einfach.  Dies ist eine Funktion, die einen Puffer empfängt und zurückgibt. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc::type { <span class="hljs-comment"><span class="hljs-comment">// ... using executor = std::function&lt;buffer (buffer)&gt;; } // namespace rpc::type</span></span></code> </pre><br>  Wenn Sie ein solches Objekt "executor" mit std :: bind, Lambda-Funktionen usw. bilden, können Sie jede Ihrer Transportimplementierungen verwenden.  Einzelheiten zur Durchführung des Verkehrs innerhalb dieser Stelle werden nicht berücksichtigt.  Sie können sich die abgeschlossene RPC-Implementierung ansehen, auf die am Ende verwiesen wird. <br><br><h2>  Kunde </h2><br>  Unten finden Sie einen Test-Client-Code.  Der Client generiert Anforderungen und sendet sie unter Berücksichtigung des ausgewählten Transports an den Server.  Im folgenden Testcode werden alle Clientanforderungen auf der Konsole angezeigt.  Und im nächsten Schritt der Implementierung kommuniziert der Client bereits direkt mit dem Server. <br><br><div class="spoiler">  <b class="spoiler_title">Kunde</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TPacker&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">client</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: client(type::executor executor) : executor_{executor} { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... TArgs&gt; <span class="hljs-function"><span class="hljs-function">result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;func_name, TArgs &amp;&amp; ... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> request = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(func_name, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgs&gt;(args) ... ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pack = packer_.save(request); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> responce = executor_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(pack)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {responce}; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> packer_type = TPacker; packer_type packer_; type::executor executor_; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: result(type::buffer buffer) : buffer_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(buffer)} { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;T&gt;&gt; tuple; packer_.load(buffer_, tuple); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(tuple)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: packer_type packer_; type::buffer buffer_; }; }; } <span class="hljs-comment"><span class="hljs-comment">// namespace rpc</span></span></code> </pre></div></div><br>  Der Client ist als Vorlagenklasse implementiert.  Der Template-Parameter ist ein Serializer.  Bei Bedarf kann die Klasse nicht in der Vorlage 1 wiederholt und ein Objekt an den Konstruktor übergeben werden, das den Serializer implementiert. <br><br>  In der aktuellen Implementierung akzeptiert der Klassenkonstruktor ein ausführendes Objekt.  Der Auftragnehmer verbirgt die Implementierung des Transports unter sich und ermöglicht es an dieser Stelle im Code, nicht über Methoden zum Datenaustausch zwischen Prozessen nachzudenken.  Im Testfall zeigt die Transportimplementierung Anforderungen an die Konsole an. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> executor = [] (rpc::type::buffer buffer) { <span class="hljs-comment"><span class="hljs-comment">// Print request data std::cout &lt;&lt; "Request pack: " &lt;&lt; std::string{begin(buffer), end(buffer)} &lt;&lt; std::endl; return buffer; };</span></span></code> </pre><br>  Der benutzerdefinierte Code hat noch nicht versucht, das Ergebnis der Arbeit des Kunden zu nutzen, da es keinen Ort gibt, an dem er abgerufen werden kann. <br><br>  <b>Client-Aufrufmethode:</b> <br><br><ul><li>  Mit dem Serializer werden der Name der aufgerufenen Methode und ihre Parameter gepackt </li><li>  Die Verwendung des ausführenden Objekts sendet eine Anforderung an den Server und empfängt eine Antwort </li><li>  Übergibt die empfangene Antwort an eine Klasse, die das empfangene Ergebnis abruft </li></ul><br>  Die grundlegende Client-Implementierung ist fertig.  Es bleibt noch etwas übrig.  Dazu später mehr. <br><br><h2>  Server </h2><br>  Bevor ich mich mit den Implementierungsdetails der Serverseite befasse, schlage ich einen kurzen, diagonalen Blick auf das fertige Beispiel der Client-Server-Interaktion vor. <br><br>  Der Einfachheit halber ist die Demonstration alles in einem Prozess.  Die Transportimplementierung ist eine Lambda-Funktion, die einen Puffer zwischen Client und Server übergibt. <br><br><div class="spoiler">  <b class="spoiler_title">Client-Server-Interaktion.</b>  <b class="spoiler_title">Testfall</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdint&gt; #include &lt;cstdlib&gt; #include &lt;functional&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;sstream&gt; #include &lt;string&gt; #include &lt;tuple&gt; #include &lt;vector&gt; #include &lt;utility&gt; namespace rpc::type { using buffer = std::vector&lt;char&gt;; using executor = std::function&lt;buffer (buffer)&gt;; } // namespace rpc::type namespace rpc::detail { template &lt;typename&gt; struct function_meta; template &lt;typename TRes, typename ... TArgs&gt; struct function_meta&lt;std::function&lt;TRes (TArgs ... )&gt;&gt; { using result_type = std::decay_t&lt;TRes&gt;; using args_type = std::tuple&lt;std::decay_t&lt;TArgs&gt; ... &gt;; using request_type = std::tuple&lt;std::string, std::decay_t&lt;TArgs&gt; ... &gt;; }; } // namespace rpc::detail namespace rpc::packer { class string_serializer final { public: template &lt;typename ... T&gt; type::buffer save(std::tuple&lt;T ... &gt; const const &amp;tuple) const { auto str = to_string(tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); return {begin(str), end(str)}; } template &lt;typename ... T&gt; void load(type::buffer const &amp;buffer, std::tuple&lt;T ... &gt; &amp;tuple) const { std::string str{begin(buffer), end(buffer)}; from_string(std::move(str), tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); } private: template &lt;typename T, std::size_t ... I&gt; std::string to_string(T const &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::stringstream stream; auto put_item = [&amp;stream] (auto const &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &lt;&lt; std::quoted(i) &lt;&lt; ' '; else stream &lt;&lt; i &lt;&lt; ' '; }; (put_item(std::get&lt;I&gt;(tuple)), ... ); return std::move(stream.str()); } template &lt;typename T, std::size_t ... I&gt; void from_string(std::string str, T &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::istringstream stream{std::move(str)}; auto get_item = [&amp;stream] (auto &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &gt;&gt; std::quoted(i); else stream &gt;&gt; i; }; (get_item(std::get&lt;I&gt;(tuple)), ... ); } }; } // namespace rpc::packer namespace rpc { template &lt;typename TPacker&gt; class client final { private: class result; public: client(type::executor executor) : executor_{executor} { } template &lt;typename ... TArgs&gt; result call(std::string const &amp;func_name, TArgs &amp;&amp; ... args) { auto request = std::make_tuple(func_name, std::forward&lt;TArgs&gt;(args) ... ); auto pack = packer_.save(request); auto responce = executor_(std::move(pack)); return {responce}; } private: using packer_type = TPacker; packer_type packer_; type::executor executor_; class result final { public: result(type::buffer buffer) : buffer_{std::move(buffer)} { } template &lt;typename T&gt; auto as() const { std::tuple&lt;std::decay_t&lt;T&gt;&gt; tuple; packer_.load(buffer_, tuple); return std::move(std::get&lt;0&gt;(tuple)); } private: packer_type packer_; type::buffer buffer_; }; }; template &lt;typename TPacker&gt; class server final { public: template &lt;typename ... THandler&gt; server(std::pair&lt;char const *, THandler&gt; const &amp; ... handlers) { auto make_executor = [&amp;packer = packer_] (auto const &amp;handler) { auto executor = [&amp;packer, function = std::function{handler}] (type::buffer buffer) { using meta = detail::function_meta&lt;std::decay_t&lt;decltype(function)&gt;&gt;; typename meta::request_type request; packer.load(buffer, request); auto response = std::apply([&amp;function] (std::string const &amp;, auto &amp;&amp; ... args) { return function(std::forward&lt;decltype(args)&gt;(args) ... ); }, std::move(request) ); return packer.save(std::make_tuple(std::move(response))); }; return executor; }; (handlers_.emplace(handlers.first, make_executor(handlers.second)), ... ); } type::buffer execute(type::buffer buffer) { std::tuple&lt;std::string&gt; pack; packer_.load(buffer, pack); auto func_name = std::move(std::get&lt;0&gt;(pack)); auto const iter = handlers_.find(func_name); if (iter == end(handlers_)) throw std::runtime_error{"Function \"" + func_name + "\" not found."}; return iter-&gt;second(std::move(buffer)); } private: using packer_type = TPacker; packer_type packer_; using handlers_type = std::map&lt;std::string, type::executor&gt;; handlers_type handlers_; }; } // namespace rpc int main() { try { using packer_type = rpc::packer::string_serializer; rpc::server&lt;packer_type&gt; server{ std::pair{"hello", [] (std::string const &amp;s) { std::cout &lt;&lt; "Func: \"hello\". Inpur string: " &lt;&lt; s &lt;&lt; std::endl; return "Hello " + s + "!"; }}, std::pair{"to_int", [] (std::string const &amp;s) { std::cout &lt;&lt; "Func: \"to_int\". Inpur string: " &lt;&lt; s &lt;&lt; std::endl; return std::stoi(s); }} }; auto executor = [&amp;server] (rpc::type::buffer buffer) { return server.execute(std::move(buffer)); }; rpc::client&lt;packer_type&gt; client{std::move(executor)}; std::cout &lt;&lt; client.call("hello", std::string{"world"}).as&lt;std::string&gt;() &lt;&lt; std::endl; std::cout &lt;&lt; "Convert to int: " &lt;&lt; client.call("to_int", std::string{"100500"}).as&lt;int&gt;() &lt;&lt; std::endl; } catch (std::exception const &amp;e) { std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl; return EXIT_FAILURE; } return EXIT_SUCCESS; }</span></span></span></span></code> </pre></div></div><br>  In der obigen Implementierung der Serverklasse ist der Konstruktor und die Ausführungsmethode das Interessanteste. <br><br>  <b>Serverklassenkonstruktor</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... THandler&gt; server(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *, THandler&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; ... handlers) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> make_executor = [&amp;packer = packer_] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;handler) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> executor = [&amp;packer, function = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function{handler}] (type::buffer buffer) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> meta = detail::function_meta&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(function)&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> meta::request_type request; packer.load(buffer, request); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> response = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::apply([&amp;function] (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp; ... args) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> function(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(args)&gt;(args) ... ); }, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> packer.save(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(response))); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> executor; }; (handlers_.emplace(handlers.first, make_executor(handlers.second)), ... ); }</code> </pre><br>  Der Konstruktor der Klasse ist Boilerplate.  Es akzeptiert eine Liste von Paaren am Eingang.  Jedes Paar ist ein Methodenname und ein Handler.  Und da der Konstruktor eine Vorlage mit einer variablen Anzahl von Parametern ist, werden beim Erstellen des Serverobjekts alle auf dem Server verfügbaren Handler sofort registriert.  Dadurch können keine zusätzlichen Registrierungsmethoden für die Server-Handler aufgerufen werden.  Dies befreit Sie wiederum davon, darüber nachzudenken, ob das Serverklassenobjekt in einer Multithread-Umgebung verwendet wird und ob eine Synchronisierung erforderlich ist. <br><br>  <b>Ein Fragment des Konstruktors der Serverklasse</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... THandler&gt; server(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *, THandler&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; ... handlers) { <span class="hljs-comment"><span class="hljs-comment">// … (handlers_.emplace(handlers.first, make_executor(handlers.second)), ... ); }</span></span></code> </pre><br>  Fügt viele übergebene heterogene Handler in die Karte der Funktionen desselben Typs ein.  Hierzu wird auch die Faltung verwendet, die es einfach macht, den gesamten Satz übergebener Handler in einer Zeile ohne Schleifen und Algorithmen in die std :: map einzufügen <br><br><pre> <code class="cpp hljs">(handlers_.emplace(handlers.first, make_executor(handlers.second)), ... );</code> </pre><br>  Lambda-Funktionen, die die Verwendung von Auto als Parameter ermöglichen, machten es einfach, denselben Wrapper-Over-Handler-Typ zu implementieren.  Wraps desselben Typs werden in der Karte der auf dem Server verfügbaren Methoden (std :: map) registriert.  Bei der Verarbeitung von Anforderungen wird eine Suche auf einer solchen Karte durchgeführt, und derselbe Handler ruft den gefundenen Handler auf, unabhängig von den empfangenen Parametern und dem zurückgegebenen Ergebnis.  Die in der Standardbibliothek angezeigte Funktion std :: apply ruft die an sie übergebene Funktion mit den als Tupel übergebenen Parametern auf.  Die Funktion std :: apply kann auch in C ++ 11 implementiert werden.  Jetzt ist es sofort einsatzbereit und muss nicht mehr von Projekt zu Projekt übertragen werden. <br><br>  <b>Methode ausführen</b> <br><br><pre> <code class="cpp hljs">type::<span class="hljs-function"><span class="hljs-function">buffer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type::buffer buffer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; pack; packer_.load(buffer, pack); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> func_name = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(pack)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> iter = handlers_.find(func_name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iter == end(handlers_)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error{<span class="hljs-string"><span class="hljs-string">"Function \""</span></span> + func_name + <span class="hljs-string"><span class="hljs-string">"\" not found."</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iter-&gt;second(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(buffer)); }</code> </pre><br>  Ruft den Namen der aufgerufenen Funktion ab, sucht in der Zuordnung der registrierten Handler nach der Methode, ruft den Handler auf und gibt das Ergebnis zurück.  Alles interessant in den Wrappern, die im Konstruktor der Serverklasse vorbereitet wurden.  Jemand hat die Ausnahme vielleicht bemerkt, und vielleicht stellte sich die Frage: "Werden die Ausnahmen irgendwie behandelt?"  Ja, in der vollständigen Implementierung, auf die am Ende Bezug genommen wird, wird Ausnahme-Marshalling bereitgestellt.  Genau dort, um das Material zu vereinfachen, werden keine Ausnahmen zwischen Client und Server übergeben. <br><br>  Schauen Sie sich die Funktion noch einmal an <br><br><div class="spoiler">  <b class="spoiler_title">Haupt</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> packer_type = rpc::packer::string_serializer; rpc::server&lt;packer_type&gt; server{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, [] (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;s) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Func: \"hello\". Inpur string: "</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello "</span></span> + s + <span class="hljs-string"><span class="hljs-string">"!"</span></span>; }}, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair{<span class="hljs-string"><span class="hljs-string">"to_int"</span></span>, [] (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;s) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Func: \"to_int\". Inpur string: "</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::stoi(s); }} }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> executor = [&amp;server] (rpc::type::buffer buffer) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server.execute(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(buffer)); }; rpc::client&lt;packer_type&gt; client{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(executor)}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; client.call(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"world"</span></span>}).as&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Convert to int: "</span></span> &lt;&lt; client.call(<span class="hljs-string"><span class="hljs-string">"to_int"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"100500"</span></span>}).as&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;e) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: "</span></span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXIT_FAILURE; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXIT_SUCCESS; }</code> </pre></div></div><br>  Es implementiert eine vollwertige Client-Server-Interaktion.  Um das Material nicht zu komplizieren, arbeiten Client und Server in einem Prozess.  Wenn Sie die Implementierung von Executor ersetzen, können Sie den erforderlichen Transport verwenden. <br><br>  Im C ++ 17-Standard ist es manchmal möglich, bei der Instanziierung keine Vorlagenparameter anzugeben.  In der obigen Hauptfunktion wird dies beim Registrieren von Server-Handlern (std :: pair ohne Vorlagenparameter) verwendet und vereinfacht den Code. <br><br>  Die grundlegende RPC-Implementierung ist fertig.  Es bleibt die versprochene Möglichkeit hinzuzufügen, benutzerdefinierte Datenstrukturen als Parameter zu übergeben und Ergebnisse zurückzugeben. <br><br><h2>  Benutzerdefinierte Datenstrukturen </h2><br>  Um Daten über die Prozessgrenze hinweg zu übertragen, müssen sie in etwas serialisiert werden.  Sie können beispielsweise alles in einen Standard-Stream ausgeben.  Viel wird sofort unterstützt.  Für benutzerdefinierte Datenstrukturen müssen Sie die Ausgabeoperatoren selbst implementieren.  Jede Struktur benötigt einen eigenen Ausgabeoperator.  Manchmal möchten Sie dies nicht tun.  Um alle Felder der Struktur zu sortieren und jedes Feld an den Stream auszugeben, benötigen Sie eine verallgemeinerte Methode.  Reflexion könnte dabei gut helfen.  Es ist noch nicht in C ++.  Sie können auf die Codegenerierung und die Verwendung einer Mischung aus Makros und Vorlagen zurückgreifen.  Die Idee war jedoch, die Bibliotheksschnittstelle in reinem C ++ zu erstellen. <br><br>  In C ++ gibt es noch keine vollständige Reflexion.  Daher kann die folgende Lösung mit einigen Einschränkungen verwendet werden. <br><br>  Die Lösung basiert auf der Verwendung der neuen C ++ 17-Funktion „Strukturierte Bindungen“.  In Dialogen findet man oft viel Jargon, daher habe ich keine Optionen für den Namen dieser Funktion auf Russisch abgelehnt. <br><br>  Im Folgenden finden Sie eine Lösung, mit der Sie die Felder der übertragenen Datenstruktur in das Tupel übertragen können. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T &amp;&amp;value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;T&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(is_braces_constructible_v&lt;type, dummy_type, dummy_type, dummy_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;[f1, f2, f3] = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(f1, f2, f3); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> (is_braces_constructible_v&lt;type, dummy_type, dummy_type&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;[f1, f2] = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(f1, f2); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> (is_braces_constructible_v&lt;type, dummy_type&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;[f1] = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(f1); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(); } }</code> </pre><br>  Im Internet finden Sie viele ähnliche Lösungen. <br><br>  Vieles, was hier verwendet wurde, wurde oben gesagt, außer für strukturierte Bindungen.  Die Funktion to_tuple akzeptiert einen benutzerdefinierten Typ, bestimmt die Anzahl der Felder und "überträgt" mithilfe strukturierter Bindungen die Strukturfelder an ein Tupel.  Mit „if constexpr“ können Sie den gewünschten Implementierungszweig auswählen.  Da es in C ++ keine Reflexion gibt, kann keine vollständige Lösung erstellt werden, die alle Aspekte des Typs berücksichtigt.  Es gibt Einschränkungen für die verwendeten Typen.  Einer davon - der Typ sollte ohne benutzerdefinierte Konstruktoren sein. <br><br>  To_tuple verwendet is_braces_constructible_v.  Mit diesem Typ können Sie die Möglichkeit bestimmen, die übertragene Struktur mit geschweiften Klammern zu initialisieren und die Anzahl der Felder zu bestimmen. <br><br><div class="spoiler">  <b class="spoiler_title">is_braces_constructible_v</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dummy_type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *&gt;(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... TArgs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">(T{</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TArgs&gt;() ... }), </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::true_type&gt;())</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_braces_constructible</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... &gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">false_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_braces_constructible</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... TArgs&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_braces_constructible_v = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(is_braces_constructible&lt;T, TArgs ... &gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>))&gt;::value;</code> </pre></div></div><br>  Die obige Funktion to_tuple kann Benutzerdatenstrukturen, die nicht mehr als drei Felder enthalten, in Tupel umwandeln.  Um die mögliche Anzahl von "verschobenen" Strukturfeldern zu erhöhen, können Sie entweder die "if constexpr" -Zweige mit einer kleinen Einbeziehung des Geistes kopieren oder nicht die einfachste boost.preprocessor-Bibliothek verwenden.  Wenn Sie die zweite Option auswählen, wird der Code schwer lesbar und ermöglicht die Verwendung von Strukturen mit einer großen Anzahl von Feldern. <br><br><div class="spoiler">  <b class="spoiler_title">Implementierung von to_tuple mit boost.preprocessor</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T &amp;&amp;value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;T&gt;; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NANORPC_TO_TUPLE_LIMIT_FIELDS 64 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// you can try to use BOOST_PP_LIMIT_REPEAT #define NANORPC_TO_TUPLE_DUMMY_TYPE_N(_, n, data) \ BOOST_PP_COMMA_IF(n) data #define NANORPC_TO_TUPLE_PARAM_N(_, n, data) \ BOOST_PP_COMMA_IF(n) data ## n #define NANORPC_TO_TUPLE_ITEM_N(_, n, __) \ if constexpr (is_braces_constructible_v&lt;type, \ BOOST_PP_REPEAT_FROM_TO(0, BOOST_PP_SUB(NANORPC_TO_TUPLE_LIMIT_FIELDS, n), NANORPC_TO_TUPLE_DUMMY_TYPE_N, dummy_type) \ &gt;) { auto &amp;&amp;[ \ BOOST_PP_REPEAT_FROM_TO(0, BOOST_PP_SUB(NANORPC_TO_TUPLE_LIMIT_FIELDS, n), NANORPC_TO_TUPLE_PARAM_N, f) \ ] = value; return std::make_tuple( \ BOOST_PP_REPEAT_FROM_TO(0, BOOST_PP_SUB(NANORPC_TO_TUPLE_LIMIT_FIELDS, n), NANORPC_TO_TUPLE_PARAM_N, f) \ ); } else #define NANORPC_TO_TUPLE_ITEMS(n) \ BOOST_PP_REPEAT_FROM_TO(0, n, NANORPC_TO_TUPLE_ITEM_N, nil) NANORPC_TO_TUPLE_ITEMS(NANORPC_TO_TUPLE_LIMIT_FIELDS) { return std::make_tuple(); } #undef NANORPC_TO_TUPLE_ITEMS #undef NANORPC_TO_TUPLE_ITEM_N #undef NANORPC_TO_TUPLE_PARAM_N #undef NANORPC_TO_TUPLE_DUMMY_TYPE_N #undef NANORPC_TO_TUPLE_LIMIT_FIELDS }</span></span></span></span></code> </pre></div></div><br>  Wenn Sie jemals versucht haben, etwas wie boost.bind für C ++ 03 zu tun, wo Sie viele Implementierungen mit einer anderen Anzahl von Parametern vornehmen mussten, erscheint die Implementierung von to_tuple mit boost.preprocessor nicht seltsam oder kompliziert. <br><br>  Wenn dem Serializer Tupelunterstützung hinzugefügt wird, ermöglicht die Funktion to_tuple die Serialisierung von Benutzerdatenstrukturen.  Und es wird möglich, sie als Parameter zu verraten und Ergebnisse in Ihrem RPC zurückzugeben. <br><br>  Neben benutzerdefinierten Datenstrukturen verfügt C ++ über weitere integrierte Typen, für die keine Ausgabe an den Standarddatenstrom implementiert ist.  Der Wunsch, die Anzahl der überladenen Ausgabeoperatoren im Stream zu reduzieren, führt zu einem verallgemeinerten Code, mit dem eine Methode die meisten C ++ - Container wie std :: list, std :: vector, std :: map verarbeiten kann.  Ohne SFINAE und std :: enable_if_t zu vergessen, können Sie den Serializer weiter erweitern.  In diesem Fall müssen die Eigenschaften von Typen irgendwie indirekt bestimmt werden, ähnlich wie bei der Implementierung von is_braces_constructible_v. <br><br><h1>  Fazit </h1><br>  Außerhalb des Geltungsbereichs der Post blieben Ausnahme-Marshalling, Transport, Serialisierung von STL-Containern und vieles mehr.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Beitrag nicht wesentlich zu komplizieren, wurden nur allgemeine Prinzipien angegeben, auf denen ich meine RPC-Bibliothek aufbauen und den ursprünglichen Aufgabensatz für mich selbst lösen konnte - um neue C ++ 14/17-Funktionen auszuprobieren. Mit der resultierenden Implementierung können Sie Remote-Methoden mit dem weit verbreiteten HTTP / HTTPS und aufrufen enthält ziemlich detaillierte Verwendungsbeispiele. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">NanoRPC-</font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliothekscode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Vielen Dank für Ihre Aufmerksamkeit! <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421001/">https://habr.com/ru/post/de421001/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar486174/index.html">لدي صفر دوران</a></li>
<li><a href="../de420993/index.html">5 einfache Schritte zum Erstellen eines Servers zum Testen von Android-REST-Anforderungen</a></li>
<li><a href="../de420995/index.html">Wir wählen das Passwort für die indische TIN in zwei Sekunden oder warum Brute-Force-Mathematik</a></li>
<li><a href="../de420997/index.html">KDD 2018, vierter Tag, Nobelpreisträger tritt auf</a></li>
<li><a href="../de420999/index.html">Kivy. Xamarin Native reagieren. Drei Frameworks - ein Experiment (Teil 2)</a></li>
<li><a href="../de421005/index.html">REST-versichert: Nützliche Tipps</a></li>
<li><a href="../de421007/index.html">Kassettenrekorder - ein Tool zum Aufzeichnen von Autotests</a></li>
<li><a href="../de421009/index.html">25. und 26. August: Online-Konferenz zum operativen Management</a></li>
<li><a href="../de421011/index.html">Fragen beim Interview, die Sie für dumm halten. Aber nicht wirklich</a></li>
<li><a href="../de421015/index.html">Nachhaltigkeitsumfrage 2018 der nationalen Internet-Segmente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>