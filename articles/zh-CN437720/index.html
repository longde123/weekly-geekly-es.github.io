<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎌 🚱 🎤 Erlang / Elixir的质量解决方案之争 🗝️ 😈 🍽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="@jcutrer 


 今天，我们将讨论事件日志，定量指标以及监视所有这些内容，以提高团队对事件的响应率并减少目标系统的停机时间。 


 Erlang / OTP作为框架和构建分布式系统的思想为我们提供了规范的开发，工具和标准组件实现方法。 假设我们利用了OTP的潜力，并从原型一直生产到生产。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erlang / Elixir的质量解决方案之争</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437720/"><p><img src="https://habrastorage.org/webt/s8/mq/lh/s8mqlhd99fmiu32vwgxnk4x-8yu.jpeg"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@jcutrer</a> </p><br><p> 今天，我们将讨论事件日志，定量指标以及监视所有这些内容，以提高团队对事件的响应率并减少目标系统的停机时间。 </p><br><p>  Erlang / OTP作为框架和构建分布式系统的思想为我们提供了规范的开发，工具和标准组件实现方法。 假设我们利用了OTP的潜力，并从原型一直生产到生产。 我们的Erlang项目在战斗服务器上感觉很棒，代码库在不断发展，出现了新的要求和功能，新人加入了团队，一切似乎都很好。 但是有时会出问题，技术问题再加上人为因素会导致事故。 </p><br><p> 由于不可能为所有可能的故障和问题案例埋下伏笔，或者在经济上不可行，因此有必要通过管理和软件解决方案减少发生故障时的系统停机时间。 </p><a name="habracut"></a><br><p> 在信息系统中，总是有发生各种性质的故障的可能性： </p><br><ul><li> 硬件故障和电源故障 </li><li> 网络故障：配置错误，固件曲线 </li><li> 逻辑错误：从算法编码错误到子系统和系统边界处出现的体系结构问题。 </li><li> 安全问题以及相关的攻击和黑客，包括内部欺诈。 </li></ul><br><p> 我们立即区分责任：例如由zabbix组织的对基础设施的监视将负责计算设备和数据传输网络的运行。 关于安装和配置此类监视的文章很多，我们不再赘述。 </p><br><p> 从开发人员的角度来看，可访问性和质量问题在于早期发现错误和性能问题以及对它们的快速响应的层面。 这需要评估的方法和手段。 因此，让我们尝试导出量化指标，分析在项目开发和运营的不同阶段可以显着提高质量的指标。 </p><br><h3 id="sistemy-sborki"> 组装系统 </h3><br><p> 让我再次提醒您有关工程方法和测试在软件开发中的重要性。  Erlang / OTP同时提供两个测试框架：eunit和通用测试。 </p><br><p> 作为对代码库状态及其动态状态进行初始评估的指标，您可以使用成功和有问题的测试数，它们的执行时间以及测试中代码覆盖率的百分比。 这两个框架均允许将测试结果保存为Junit格式。 <br> 例如，对于rebar3和ct，将以下行添加到rebar.config中： </p><br><pre><code class="erlang hljs">{cover_enabled, true}. {cover_export_enabled, true}. {ct_opts,[ {ct_hooks, [{cth_surefire, [{path, <span class="hljs-string"><span class="hljs-string">"report.xml"</span></span>}]}]} ]}.</code> </pre> <br><p> 成功和失败测试的数量将使您能够构建趋势图： <br><img src="https://habrastorage.org/webt/mw/lc/mw/mwlcmw24mj6f9wz5ctxshc4baf4.png"><br> 看一下，您可以评估团队的动力和测试的回归。 例如，在Jenkins中，可以使用“测试结果分析器插件”来获得该图。 </p><br><p> 如果测试变成红色或开始运行很长时间，那么这些度量标准即使在组装和自动测试阶段也可以最终确定发行版。 </p><br><h3 id="metriki-prilozheniy"> 应用指标 </h3><br><p> 除了操作系统指标外，监视还应包括应用程序指标，例如每秒的视图数，付款数和其他关键指标。 </p><br><p> 在我的项目中，我使用<code>${application}.${metrics_type}.${name}</code>类的模板来命名度量。 通过此命名，您可以获取表单的指标列表 </p><br><pre> <code class="bash hljs">messaging.systime_subs.messages.delivered = 1654 messaging.systime_subs.messages.proxied = 0 messaging.systime_subs.messages.published = 1655 messaging.systime_subs.messages.skipped = 3</code> </pre> <br><p> 也许指标越多，就越容易理解复杂系统中正在发生的事情。 </p><br><h3 id="metriki-erlang-vm">  Erlang VM指标 </h3><br><p> 应该特别注意监视Erlang VM。 让它崩溃的思想很漂亮，正确使用OTP肯定会帮助提升Erlang VM内部应用程序的崩溃部分。 但是不要忘记Erlang VM本身，因为很难删除它，但是有可能。 所有选项均基于资源耗尽。 我们列出了主要的： </p><br><ul><li><p> 原子表溢出。 <br> 原子是标识符，其主要目的是提高代码的可读性。 一旦创建的原子将永久保留在Erlang VM实例的内存中，因为它们不会被垃圾收集器清除。 为什么会这样呢？ 垃圾收集器在每个进程中分别使用该进程中的数据工作，而原子可以分布在许多进程的数据结构中。 <br> 默认情况下，可以创建1,048,576个原子。 在有关杀死Erlang VM的文章中，通常可以找到类似的内容。 </p><br><pre> <code class="erlang hljs">[list_to_atom(integer_to_list(I)) || I &lt;- lists:seq(erlang:system_info(atom_count), erlang:system_info(atom_limit))]</code> </pre> <br><p> 作为这种效果的例证。 似乎在实际系统中无法解决人为的问题，但是在某些情况下...例如，在外部API处理程序中，在解析请求时，使用<code>binary_to_atom/2</code>代替<code>binary_to_existing_atom/2</code>或<code>list_to_atom/1</code>而不是<code>list_to_existing_atom/1</code> 。 <br> 以下参数应用于监视原子状态： </p><br><ol><li>  <code>erlang:memory(atom_used)</code> -用于原子的内存量 </li><li>  <code>erlang:system_info(atom_count)</code> -在系统中创建的原子数。 与<code>erlang:system_info(atom_limit)</code> ，可以计算出原子利用率。 </li></ol><br></li><li><p> 工艺泄漏。 <br> 我想马上说，当process_limit（+ P达到erl）参数erlang vm不会崩溃，但是它进入紧急状态，例如，很可能无法连接到它。 最终，分配给泄漏的进程时，可用内存不足将导致erlang vm崩溃。 </p><br><ol><li>  <code>erlang:system_info(process_count)</code> -当前活动进程的数量。 与<code>erlang:system_info(process_limit)</code> ，可以计算进程利用率。 </li><li>  <code>erlang:memory(processes)</code> -为进程分配的内存 </li><li>  <code>erlang:memory(processes_used)</code> -用于进程的内存。 </li></ol><br></li><li><p> 邮箱进程溢出。 <br> 此类问题的一个典型示例是，发送方进程将消息发送到接收方进程而无需等待确认，而<code>receive</code>方进程中的接收由于丢失或不正确的模式而忽略了所有这些消息。 结果，邮件会累积在邮箱中。 尽管erlang具有在处理程序无法处理处理的情况下降低发送方速度的机制，但是无论如何，在可用内存耗尽后，vm会崩溃。 <br> 要了解邮箱溢出是否存在问题，etop将提供帮助。 </p><br><pre> <code class="bash hljs">$ erl -name etop@host -hidden -s etop -s erlang halt -output text -node dest@host -setcookie some_cookie -tracing off -sort msg_q -interval 1 -lines 25</code> </pre> <br><p><img src="https://habrastorage.org/webt/k3/rc/xu/k3rcxuudnptazhjl0pxql1vmfji.png"><br> 作为连续监控的指标，您可以采用问题处理的数量。 要识别它们，可以使用以下功能： </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">top_msq_q</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">-&gt;</span></span> [{P, RN, L, IC, ST} || P &lt;- processes(), { _, L } &lt;- [ process_info(P, message_queue_len) ], L &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span>, [{_, RN}, {_, IC}, {_, ST}] &lt;- [process_info(P, [registered_name, initial_call, current_stacktrace]) ] ].</code> </pre> <br><p> 另外，可以记录此列表，然后在接收到来自监视的通知时，可以简化问题分析。 </p><br></li><li><p> 二进制泄漏。 <br> 大堆（超过64个字节）的二进制文件的内存在常规堆中分配。 分配的块具有一个参考计数器，该计数器显示可以访问它的进程数。 重置计数器后，将进行清洁。 最简单的系统，但正如他们所说，存在细微差别。 原则上，进程可能会在堆上生成大量垃圾，以致系统没有足够的内存来执行清理。 <br>  <code>erlang:memory(binary)</code>充当监视指标，显示分配给二进制文件的内存。 </p><br></li></ul><br><p> 因此，可以找出导致vm崩溃的原因，但除此之外，最好监视直接或间接影响应用程序正常运行的重要参数： </p><br><ul><li>  ETS： <code>erlang:memory(ets)</code>使用的<code>erlang:memory(ets)</code> 。 </li><li> 编译模块的内存： <code>erlang:memory(code)</code> 。 <br> 如果您的解决方案不使用动态代码编译，则可以排除此选项。 <br> 我还要提到erlydtl。 如果动态编译模板，则编译会创建一个加载到vm内存中的梁。 它还可能导致内存泄漏。 </li><li> 系统内存： <code>erlang:memory(system)</code> 。 显示erlang运行时内存消耗。 </li><li> 消耗的总内存： <code>erlang:memory(total)</code> 。 这是进程和运行时消耗的内存量。 </li><li> 有关减少量的信息： <code>erlang:statistics(reductions)</code> 。 </li><li> 准备执行的进程和端口数： <code>erlang:statistics(run_queue)</code> 。 </li><li>  vm： <code>erlang:statistics(runtime)</code>实例的正常运行时间使您可以了解是否在没有日志分析的情况下进行了重新启动。 </li><li> 网络活动： <code>erlang:statistics(io)</code> 。 </li></ul><br><h3 id="otpravka-metrik-v-zabbix"> 提交指标到zabbix </h3><br><p> 我们将创建一个包含应用程序指标和erlang vm指标的文件，我们将每N秒更新一次。 对于每个erlang节点，指标文件必须包含在其上运行的应用程序的指标以及erlang vm实例的指标。 结果应该是这样的： </p><br><pre> <code class="bash hljs">messaging.systime_subs.messages.delivered = 1654 messaging.systime_subs.messages.proxied = 0 messaging.systime_subs.messages.published = 1655 messaging.systime_subs.messages.skipped = 3 …. erlang.io.input = 2205723664 erlang.io.output = 1665529234 erlang.memory.binary = 1911136 erlang.memory.ets = 1642416 erlang.memory.processes = 23596432 erlang.memory.processes_used = 23598864 erlang.memory.system = 50883752 erlang.memory.total = 74446048 erlang.processes.count = 402 erlang.processes.run_queue = 0 erlang.reductions = 148412771 ....</code> </pre> <br><p> 使用<code>zabbix_sender</code>我们将把这个文件发送到zabbix，在那里图形表示以及创建自动化和通知触发器的功能已经可用。 </p><br><p> 现在，我们已经在监视系统中建立了度量标准，并在其基础上创建了自动化触发器和通知事件，我们有机会通过对所有功能偏离正常状态的危险提前做出反应来避免发生事故。 </p><br><h3 id="centralnyy-sbor-logov"> 集中收集原木 </h3><br><p> 当项目中有1-2台服务器时，您可能仍然可以不使用中央日志收集而生活，但是，一旦出现具有许多服务器，群集和环境的分布式系统，就必须解决收集日志和方便查看日志的问题。 </p><br><p> 要在项目中写入日志，我使用啤酒。 从原型到生产的过程中，项目通常会经历以下收集日志的阶段： </p><br><ul><li> 最简单的日志记录，输出到本地文件，甚至输出到stdout（lager_file_backend） </li><li> 使用syslogd集中收集日志，并将日志自动发送到收集器。 对于这样的方案， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">lager_syslog</a>是合适的。 <br> 该方案的主要缺点是，您需要转到日志收集服务器，找到具有必要日志的文件，并以某种方式过滤事件以查找调试所需的事件。 </li><li> 集中收集日志，并将其存储在存储库中，并能够按记录过滤和搜索。 </li></ul><br><p> 关于可以使用后者的缺点，优点和数量指标，我们将讨论一个具体实现的方式<code>lager_clickhouse</code> ，我将在大多数正在开发的项目中使用它。 关于<code>lager_clickhouse</code>的几句话。 这是用于将事件保存到Clickhouse的大型后端。 目前，这是一个内部项目，但是有计划使其公开。 在开发lager_clickhouse时，我不得不绕过clickhouse的某些功能，例如，使用事件缓冲以避免在clickhouse中频繁发出请求。 通过稳定的操作和良好的性能，付出了不小的努力。 </p><br><p> 保存到资源库的方法的主要缺点是附加实体-Clickhouse，以及需要开发用于将事件保存到其中的代码以及用于分析和搜索事件的用户界面的需求。 另外，对于某些项目，使用tcp发送日志可能至关重要。 </p><br><p> 但是在我看来，利弊胜过所有可能的弊端。 </p><br><ul><li><p> 简便快捷的事件搜索： </p><br><ul><li> 按日期过滤，而无需在包含一系列事件的中央服务器上搜索一个或多个文件。 </li><li> 按环境过滤。 来自不同子系统（通常来自不同集群）的日志被写入一个存储库。 此刻，根据在群集的每个节点上设置的标签发生分离。 </li><li> 按主机名过滤 </li><li> 按发送事件的模块名称过滤 </li><li> 事件过滤 </li><li> 文字搜寻 </li></ul><br><p> 屏幕快照中显示了日志查看界面的示例视图： <br><img src="https://habrastorage.org/webt/tz/6s/qy/tz6sqy5ofprtonxlxkhywfr7gmy.png"></p><br></li><li><p> 自动化能力。 <br> 通过引入日志存储，可以实时接收有关错误数量，严重故障的发生以及系统活动的信息。 通过引入某些限制，我们可以在系统退出功能状态时生成紧急事件，该事件的处理程序将执行自动化操作以消除此状态并将通知发送给负责该功能的团队成员： </p><br><ul><li> 发生严重错误时。 </li><li> 在质量误差的情况下（时间导数的增加快于特定限制）。 </li><li> 一个单独的指标是事件发生的速率，即事件日志中出现了多少个新事件。 您几乎总是可以知道项目每单位时间生成的大约日志量。 如果多次超过，则很可能出了问题。 </li></ul><br></li></ul><br><p>  lua脚本的使用是处理紧急事件的自动化主题的进一步发展。 任何开发人员或管理员都可以编写脚本来处理日志和指标。 脚本带来了灵活性，并允许您创建个性化的自动化脚本和通知。 </p><br><h3 id="itogi"> 总结 </h3><br><p> 要了解系统中发生的过程并调查事件，拥有定量指标和事件日志以及分析它们的便捷工具至关重要。 我们收集的有关该系统的信息越多，就越容易分析其行为并纠正问题，即使在出现问题的阶段也是如此。 如果我们的措施不起作用，我们将随时掌握事件的时间表和详细日志。 </p><br><p> 您如何在Erlang / Elixir上运行解决方案，以及在生产中遇到了哪些有趣的案例？ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN437720/">https://habr.com/ru/post/zh-CN437720/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN437706/index.html">特斯拉的一年</a></li>
<li><a href="../zh-CN437710/index.html">将Linux上的本地用户权限限制到最低限度</a></li>
<li><a href="../zh-CN437712/index.html">太空站Roskomnadzor</a></li>
<li><a href="../zh-CN437714/index.html">我们绘制了180行裸C ++的卡通爆炸图</a></li>
<li><a href="../zh-CN437716/index.html">创建Flutter项目的三种相对诚实的方法</a></li>
<li><a href="../zh-CN437722/index.html">美国停战的宇宙后果</a></li>
<li><a href="../zh-CN437724/index.html">OpenSceneGraph：几何和状态属性的过程动画</a></li>
<li><a href="../zh-CN437726/index.html">用Kotlinx序列化Kotlin.Serialization</a></li>
<li><a href="../zh-CN437730/index.html">我们如何在不添加字节的情况下解决PostgreSQL中的内存问题</a></li>
<li><a href="../zh-CN437732/index.html">MakeX M-One Pro 70 DLP打印机概述</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>