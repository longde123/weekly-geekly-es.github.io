<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòñ üë©üèª‚Äç‚öñÔ∏è üïì Firecore - ein lustiges Spiel auf AVR üõÖ üòº üë®üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich m√∂chte eine weitere abendliche Langzeitkonstruktion teilen, die zeigt, dass Sie Spiele auch auf schwacher Hardware erstellen k√∂nnen. 

 √úber das, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Firecore - ein lustiges Spiel auf AVR</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425407/"><img src="https://habrastorage.org/webt/dv/yz/hr/dvyzhr-e4xxmj6jbln7ngiti5d0.png"><br><br>  Ich m√∂chte eine weitere abendliche Langzeitkonstruktion teilen, die zeigt, dass Sie Spiele auch auf schwacher Hardware erstellen k√∂nnen. <br><br>  √úber das, was Sie tun mussten, wie es entschieden wurde und wie Sie etwas mehr als nur einen anderen Pong-Klon tun k√∂nnen - willkommen bei Cat. <br><br>  Achtung: toller Artikel, Verkehr und mehrere Code-Einf√ºgungen! <br><a name="habracut"></a><br><h3>  Kurz √ºber das Spiel </h3><hr>  Schie√ü auf sie!  - jetzt auf AVR. <br><br>  Tats√§chlich ist dies eine weitere Shmap, daher muss die Hauptfigur <s>Shepard</s> die Galaxie erneut vor einem pl√∂tzlichen Angriff unbekannter Personen retten und sich durch die Sterne und Felder der Asteroiden durch den Weltraum bewegen, um gleichzeitig jedes Sternensystem zu l√∂schen. <br>  Das ganze Spiel ist in C und C ++ geschrieben, ohne die Wire-Bibliothek von Arduino zu verwenden. <br><br>  Das Spiel hat 4 Schiffe zur Auswahl (letzteres ist nach dem Passieren verf√ºgbar), jedes mit seinen eigenen Eigenschaften: <br><ul><li>  Man√∂vrierf√§higkeit; </li><li>  Haltbarkeit; </li><li>  Waffengewalt. </li></ul><br>  Ebenfalls implementiert: <br><ul><li>  2D-Farbgrafiken; </li><li>  Power f√ºr Waffen; </li><li>  Bosse am Ende der Levels; </li><li>  Levels mit Asteroiden (und deren Rotationsanimation); </li><li>  √Ñnderung der Hintergrundfarbe auf Ebenen (und nicht nur im Schwarzraum); </li><li>  die Bewegung von Sternen im Hintergrund mit unterschiedlichen Geschwindigkeiten (f√ºr den Effekt der Tiefe); </li><li>  Scoring und Speichern im EEPROM; </li><li>  die gleichen Ger√§usche (Sch√ºsse, Explosionen usw.); </li><li>  ein Meer identischer Gegner. </li></ul><br><h3>  Plattform </h3><hr>  Die R√ºckkehr des Geistes. <br><br><blockquote>  Ich werde im Voraus klarstellen, dass diese Plattform als die alte Spielekonsole der <s>ersten</s> dritten Generation (80er Jahre, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">shiru8bit</a> ) angesehen werden sollte. <br></blockquote><br>  Au√üerdem sind Hardwaremodifikationen gegen√ºber der Originalhardware verboten, wodurch der Start auf jeder anderen identischen Karte sofort gew√§hrleistet ist. <br>  Dieses Spiel wurde f√ºr das Arduino Esplora-Board geschrieben, aber die √úbertragung auf GBA oder eine andere Plattform wird meiner Meinung nach nicht schwierig sein. <br>  Trotzdem wurde dieses Forum selbst auf dieser Ressource nur ein paar Mal behandelt, und andere Boards waren trotz der ziemlich gro√üen Community von jedem √ºberhaupt nicht erw√§hnenswert: <br><ul><li>  GameBuino META: </li><li>  Pokitto; </li><li>  makerBuino; </li><li>  Arduboy; </li><li>  UzeBox / FuzeBox; </li><li>  und viele andere. </li></ul><br>  Was ist nicht auf Esplora? <br><ul><li>  viel Speicher (ROM 28 KB, RAM 2,5 KB); </li><li>  Leistung (8 Bit CPU bei 16 MHz); </li><li>  DMA </li><li>  Zeichengenerator; </li><li>  zugewiesene Speicherbereiche oder Sonderregister.  Ziel (Palette, Kacheln, Hintergrund usw.); </li><li>  Steuern Sie die Helligkeit des Bildschirms (oh, so viele Effekte im Papierkorb); </li><li>  Adressraum-Extender (Mapper); </li><li>  Debugger ( <s>aber wer braucht es, wenn es einen ganzen Bildschirm gibt!</s> ). </li></ul><br>  Ich werde mit der Tatsache fortfahren, dass es gibt: <br><ul><li>  Hardware-SPI (kann mit F_CPU / 2-Geschwindigkeit ausgef√ºhrt werden); </li><li>  Bildschirm basierend auf ST7735 160x128 1,44 "; </li><li>  eine Prise Timer (nur 4 St√ºck); </li><li>  eine Prise GPIO; </li><li>  eine Handvoll Tasten (5 St√ºck + zweiachsiger Joystick); </li><li>  wenige Sensoren (Beleuchtung, Beschleunigungsmesser, Thermometer); </li><li>  Piezo Summer <s>Irritation</s> Emitter. </li></ul><br>  Anscheinend ist da fast nichts.  Es ist nicht verwunderlich, dass niemand etwas mit ihr machen wollte, au√üer dem Pong-Klon und ein paar drei Spielen f√ºr die ganze Zeit! <br>  M√∂glicherweise √§hnelt das Schreiben unter dem ATmega32u4-Controller (und dergleichen) der Programmierung f√ºr Intel 8051 (das zum Zeitpunkt der Ver√∂ffentlichung fast 40 Jahre alt ist), bei dem Sie eine Vielzahl von Bedingungen beachten und auf verschiedene Tricks und Tricks zur√ºckgreifen m√ºssen. <br><br><h3>  Periphere Verarbeitung </h3><hr>  Eins f√ºr alles! <br><br>  Bei Betrachtung der Schaltung war deutlich zu erkennen, dass alle Peripherieger√§te √ºber den GPIO-Expander (74HC4067D Multiplexer weiter MUX) angeschlossen und mit dem GPIO PF4, PF5, PF6, PF7 oder dem Senior PORTF Nibble geschaltet werden und der MUX-Ausgang auf GPIO - PF1 gelesen wird. <br>  Es ist sehr praktisch, den Eingang zu wechseln, indem Sie dem PORTF-Port einfach Werte per Maske zuweisen und dabei das kleine Knabbern nicht vergessen: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> getAnalogMux(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> chMux) { MUX_PORTX = ((MUX_PORTX &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>) | ((chMux&lt;&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">0xF0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> readADC(); }</code> </pre> <br>  Button-Click-Umfrage: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_MIN_LVL 800 bool readSwitchButton(uint8_t btn) { bool state = true; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(getAnalogMux(btn) &gt; SW_BTN_MIN_LVL) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// low state == pressed state = false; } return state; }</span></span></span></span></code> </pre><br>  Die folgenden Werte gelten f√ºr Port F: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_1_MUX 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_2_MUX 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_3_MUX 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_4_MUX 12</span></span></code> </pre><br>  Indem Sie etwas mehr hinzuf√ºgen: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_A SW_BTN_4_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_B SW_BTN_1_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_X SW_BTN_2_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_Y SW_BTN_3_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> buttonIsPressed(a) readSwitchButton(a)</span></span></code> </pre><br>  Sie k√∂nnen sicher das richtige Kreuz interviewen: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateBtnStates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_A)) btnStates.aBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_B)) btnStates.bBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_X)) btnStates.xBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_Y)) btnStates.yBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  Bitte beachten Sie, dass der vorherige Status nicht zur√ºckgesetzt wird, da Sie sonst das Dr√ºcken der Taste √ºbersehen k√∂nnen (dies dient auch als zus√§tzlicher Schutz gegen Rattern). <br><br><h3>  Sfx </h3><hr>  Ein summendes St√ºck. <br><br>  Was ist, wenn es keinen DAC, keinen Chip von Yamaha und nur ein 1-Bit-PWM-Rechteck f√ºr Sound gibt? <br>  Auf den ersten Blick scheint es nicht so viel zu sein, aber trotzdem wird hier das listige PWM verwendet, um die ‚ÄûPDM-Audio‚Äú -Technik neu zu erstellen, und mit seiner Hilfe k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dies</a> tun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> <br><br>  √Ñhnliches bietet die Bibliothek von Gamebuino. Sie m√ºssen lediglich den Popping-Generator auf ein anderes GPIO und den Timer auf Esplora √ºbertragen (Timer4- und OCR4D-Ausgabe).  F√ºr einen korrekten Betrieb wird Timer1 auch verwendet, um Interrupts zu generieren und das OCR4D-Register mit neuen Daten neu zu laden. <br><br>  Die Gamebuino-Engine verwendet Soundmuster (wie bei Trackermusik), was viel Platz spart. Sie m√ºssen jedoch alle Samples selbst erstellen. Es gibt keine Bibliotheken mit vorgefertigten. <br>  Es ist erw√§hnenswert, dass diese Engine an eine Aktualisierungsperiode von ungef√§hr 1/50 Sek. Oder 20 Frames / Sek. Gebunden ist. <br><br>  Um Klangmuster zu lesen, habe ich nach dem Lesen des Wikis im Audioformat eine einfache GUI auf Qt skizziert.  Der Ton wird nicht auf die gleiche Weise ausgegeben, sondern es wird ein ungef√§hres Konzept f√ºr den Klang des Musters gegeben, und Sie k√∂nnen ihn laden, speichern und bearbeiten. <br><br><h3>  Grafik </h3><hr>  Unsterblicher Pixelart. <br><br>  Das Display codiert Farben in zwei Bytes (RGB565). Da jedoch Bilder in diesem Format viel Platz beanspruchen, wurden sie alle von der Palette indiziert, um Platz zu sparen, was ich bereits mehr als einmal in meinen fr√ºheren Artikeln beschrieben habe. <br>  Im Gegensatz zu Famicom / NES gibt es keine Farbbeschr√§nkungen f√ºr das Bild und es sind mehr Farben in der Palette verf√ºgbar. <br><br>  Jedes Bild im Spiel ist ein Array von Bytes, in denen die folgenden Daten gespeichert sind: <br><ul><li>  Breite, H√∂he; </li><li>  Datenmarkierung starten; </li><li>  W√∂rterbuch (falls vorhanden, aber dazu sp√§ter mehr); </li><li>  Nutzlast; </li><li>  Ende der Datenmarkierung. </li></ul><br>  Zum Beispiel ein solches Bild (10-fach vergr√∂√üert): <br><img src="https://habrastorage.org/webt/zk/rr/es/zkrresh27swmtvck9fagoemando.png"><br><br>  im Code sieht es so aus: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pic_t</span></span> weaponLaserPic1[] PROGMEM = { <span class="hljs-number"><span class="hljs-number">0x0f</span></span>,<span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x32</span></span>,<span class="hljs-number"><span class="hljs-number">0xa2</span></span>,<span class="hljs-number"><span class="hljs-number">0x05</span></span>,<span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x06</span></span>,<span class="hljs-number"><span class="hljs-number">0x22</span></span>,<span class="hljs-number"><span class="hljs-number">0x41</span></span>,<span class="hljs-number"><span class="hljs-number">0xad</span></span>,<span class="hljs-number"><span class="hljs-number">0x03</span></span>,<span class="hljs-number"><span class="hljs-number">0x41</span></span>,<span class="hljs-number"><span class="hljs-number">0x22</span></span>,<span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x06</span></span>,<span class="hljs-number"><span class="hljs-number">0xa2</span></span>,<span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x23</span></span>,<span class="hljs-number"><span class="hljs-number">0xff</span></span>, };</code> </pre><br>  Wo ohne Schiff in diesem Genre?  Nach Hunderten von Testskizzen mit einem Pixelunterschied blieben nur diese Schiffe f√ºr den Spieler √ºbrig: <br><img src="https://habrastorage.org/webt/ao/4y/jm/ao4yjmxt3bl3ydqrjajnmgy4ms8.png"><br>  Es ist bemerkenswert, dass die Schiffe keine Flamme in den Fliesen haben (hier aus Gr√ºnden der Klarheit), es wird separat angewendet, um eine Animation des Abgases vom Motor zu erstellen. <br><br>  Vergessen Sie nicht die Piloten jedes Schiffes: <br><img src="https://habrastorage.org/webt/fk/fj/xf/fkfjxfoscgeu69pabaolb4zt6mo.png"><br><br>  Die Variation der feindlichen Schiffe ist nicht zu gro√ü, aber ich m√∂chte Sie daran erinnern, dass es nicht zu viel Platz gibt. Hier sind drei Schiffe: <br><img src="https://habrastorage.org/webt/w2/-v/o3/w2-vo3itdzkpoptpywwgjn5ytc8.png"><br><br>  Ohne kanonische Boni in Form von Waffenverbesserung und Wiederherstellung der Gesundheit wird der Spieler nicht lange durchhalten: <br><img src="https://habrastorage.org/webt/kw/gw/7d/kwgw7duf5hnztuobgg_pwclk8nm.png"><br><br>  Nat√ºrlich √§ndert sich mit zunehmender Leistung der Kanonen die Art der emittierten Granaten: <br><img src="https://habrastorage.org/webt/yq/dn/67/yqdn67u3cvbmzbn0j46v9iiievy.png"><br><br>  Wie es am Anfang geschrieben wurde, hat das Spiel ein Level mit Asteroiden, es kommt nach jedem zweiten Boss.  Es ist insofern interessant, als es viele sich bewegende und rotierende Objekte unterschiedlicher Gr√∂√üe gibt.  Wenn ein Spieler sie trifft, fallen sie au√üerdem teilweise zusammen und werden kleiner. <br><blockquote>  Hinweis: Gro√üe Asteroiden verdienen mehr Punkte. <br></blockquote><br><img src="https://habrastorage.org/webt/d6/hg/9a/d6hg9atxd8gzj9m9njyhac4i7bq.gif"><br><img src="https://habrastorage.org/webt/ow/pv/yf/owpvyfbgmn45yueagrafne4w2ng.gif"><br><img src="https://habrastorage.org/webt/jc/eh/r_/jcehr_zvccitvi24lcdmxiiewik.gif"><br>  Um diese einfache Animation zu erstellen, reichen 12 kleine Bilder aus: <br><img src="https://habrastorage.org/webt/yr/uz/g3/yruzg3mwjlg3bv_z2pljhzyql68.png"><br>  Sie sind f√ºr jede Gr√∂√üe (gro√ü, mittel und klein) in drei Teile unterteilt. F√ºr jeden Drehwinkel ben√∂tigen Sie 4 weitere gedrehte 0, 90, 180 und 270 Grad.  Im Spiel reicht es aus, den Zeiger auf das Array in einem gleichen Intervall durch das Bild zu ersetzen, wodurch die Illusion einer Rotation entsteht. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotateAsteroid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">asteroid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;asteroid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(RN &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { asteroid.sprite.pPic = getAsteroidPic(asteroid); ++asteroid.angle; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">moveAsteroids</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;asteroid : asteroids) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(asteroid.onUse) { updateSprite(&amp;asteroid.sprite); rotateAsteroid(asteroid); ...</code> </pre><br>  Dies geschieht nur aufgrund fehlender Hardwarefunktionen, und eine Softwareimplementierung wie die Affine-Transformation ben√∂tigt mehr als die Bilder selbst und ist sehr langsam. <br><br><div class="spoiler">  <b class="spoiler_title">Ein St√ºck Satin f√ºr Interessierte.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/el/uf/0l/eluf0lkcjsygvumvmosh_yzreig.png"><br>  Sie k√∂nnen einen Teil der Prototypen und das, was erst im Abspann erscheint, nach dem Bestehen des Spiels bemerken. <br></div></div><br>  Um Platz zu sparen und einen Retro-Effekt hinzuzuf√ºgen, wurden neben einfachen Grafiken auch Kleinbuchstaben und alle Glyphen, die bis zu 30 und nach 127 Byte ASCII waren, aus der Schriftart entfernt. <br><blockquote>  Wichtig! <br>  Vergessen Sie nicht, dass const und constexpr auf AVR √ºberhaupt nicht bedeuten, dass sich die Daten im Programmspeicher befinden. Hierf√ºr m√ºssen Sie zus√§tzlich PROGMEM verwenden. <br>  Dies liegt an der Tatsache, dass der AVR-Kern auf der Harvard-Architektur basiert, sodass spezielle Zugriffscodes f√ºr die CPU erforderlich sind, um auf die Daten zuzugreifen. <br></blockquote><br><h3>  Die Galaxie zusammendr√ºcken </h3><hr>  Der einfachste Weg zu packen ist RLE. <br><br>  Nachdem Sie die gepackten Daten untersucht haben, k√∂nnen Sie feststellen, dass das h√∂chstwertige Bit im Nutzlastbyte im Bereich von 0x00 bis 0x50 nicht verwendet wird.  Auf diese Weise k√∂nnen Sie die Daten und die Startmarkierung f√ºr den Beginn der Wiederholung (0x80) und das n√§chste Byte hinzuf√ºgen, um die Anzahl der Wiederholungen anzugeben. Auf diese Weise k√∂nnen Sie eine Reihe von 257 (+2 aus der Tatsache, dass RLE von zwei Bytes dumm ist) identischer Bytes in nur zwei packen. <br>  Implementierung und Anzeige des Entpackers: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawPico_RLE_P</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pPic)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> repeatColor; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> tmpInd, repeatTimes; alphaReplaceColorId = getAlphaReplaceColorId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpData = getPicSize(pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); tftSetAddrWindow(x, y, x+tmpData.u8Data1, y+tmpData.u8Data2); ++pPic; <span class="hljs-comment"><span class="hljs-comment">// make offset to picture data while((tmpInd = getPicByte(++pPic)) != PIC_DATA_END) { // get color index or repeat times if(tmpInd &amp; RLE_MARK) { // is it color index? tmpInd &amp;= DATA_MARK; // get color index to repeat repeatTimes = getPicByte(++pPic)+1; // zero RLE does not exist! } ++repeatTimes; // get color from colorTable by color index repeatColor = palette_RAM[(tmpInd == ALPHA_COLOR_ID) ? alphaReplaceColorId : tmpInd]; do { pushColorFast(repeatColor); } while(--repeatTimes); } }</span></span></code> </pre><br>  Die Hauptsache ist, das Bild nicht au√üerhalb des Bildschirms anzuzeigen, da es sonst M√ºll ist, da hier keine Randpr√ºfung stattfindet. <br>  Das Testbild wird in ~ 39ms entpackt.  Gleichzeitig werden 3040 Bytes belegt, w√§hrend ohne Komprimierung 11.200 Bytes oder 22.400 Bytes ohne Indizierung ben√∂tigt werden. <br><br>  Testbild (2-fach vergr√∂√üert): <br><img src="https://habrastorage.org/webt/ao/nl/6n/aonl6nxjmfjhbsmp0uc4n6h7w0e.png"><br>  Im Bild oben sehen Sie Interlace, aber auf dem Bildschirm wird es durch Hardware gegl√§ttet, wodurch ein CRT-√§hnlicher Effekt erzeugt und gleichzeitig das Komprimierungsverh√§ltnis erheblich erh√∂ht wird. <br><br><h3>  RLE ist kein Allheilmittel </h3><hr>  Wir werden wegen Deja Vu behandelt. <br><br>  Wie Sie wissen, passt RLE gut zu LZ-√§hnlichen Packern.  WiKi kam mit einer Liste von Komprimierungsmethoden zur Rettung.  Der Ansto√ü war das Video von "GameHut" √ºber die Analyse des unm√∂glichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intro in Sonic 3D Blast.</a> <br>  Nachdem ich viele Packer (LZ77, LZW, LZSS, LZO, RNC usw.) studiert hatte, kam ich zu dem Schluss, dass ihre Auspacker: <br><ul><li>  ben√∂tigen viel RAM f√ºr entpackte Daten (mindestens 64 KB und mehr); </li><li>  sperrig und langsam (einige m√ºssen Huffman-B√§ume f√ºr jede Untereinheit bauen); </li><li>  ein niedriges Komprimierungsverh√§ltnis mit einem kleinen Fenster haben (sehr strenge RAM-Anforderungen); </li><li>  Unklarheiten bei der Lizenzierung haben. </li></ul><br>  Nach Monaten vergeblicher Anpassungen wurde beschlossen, den vorhandenen Packer zu modifizieren. <br>  In Analogie zu LZ-√§hnlichen Packern wurde zur Erzielung einer maximalen Komprimierung der W√∂rterbuchzugriff verwendet, jedoch auf Byte-Ebene - die am h√§ufigsten wiederholten Bytepaare werden im W√∂rterbuch durch einen Bytezeiger ersetzt. <br>  Aber es gibt einen Haken: Wie kann man ein Byte mit ‚Äûwie vielen Wiederholungen‚Äú von einem ‚ÄûW√∂rterbuchmarker‚Äú unterscheiden? <br>  Nach einer langen Sitzung mit einem St√ºck Papier und einem magischen Spiel mit Flederm√§usen erschien Folgendes: <br><blockquote><ul><li>  "W√∂rterbuchmarker" ist ein RLE-Marker (0x80) + Datenbyte (0x50) + Positionsnummer im W√∂rterbuch; </li><li>  Begrenzen Sie das Byte "wie viele Wiederholungen" auf die Gr√∂√üe des W√∂rterbuchmarkers - 1 (0xCF); </li><li>  Das W√∂rterbuch kann den Wert 0xff nicht verwenden (dies gilt f√ºr das Ende der Bildmarkierung). </li></ul><br></blockquote><br>  Wenn wir all dies anwenden, erhalten wir eine feste W√∂rterbuchgr√∂√üe: nicht mehr als 46 Bytepaare und eine RLE-Reduzierung auf 209 Byte.  Nat√ºrlich k√∂nnen nicht alle Bilder so verpackt werden, aber sie werden nicht mehr. <br>  In beiden Algorithmen ist die Struktur des gepackten Bildes wie folgt: <br><ul><li>  1 Byte pro Breite und H√∂he; </li><li>  1 Byte f√ºr die Gr√∂√üe des W√∂rterbuchs, es ist ein Markierungszeiger auf den Anfang der gepackten Daten; </li><li>  von 0 bis 92 Bytes des W√∂rterbuchs; </li><li>  1 bis N Bytes gepackter Daten. </li></ul><br>  Das resultierende Packer-Dienstprogramm auf D (pickoPacker) reicht aus, um einen Ordner mit indizierten * .png-Dateien abzulegen und vom Terminal (oder cmd) aus auszuf√ºhren.  Wenn Sie Hilfe ben√∂tigen, f√ºhren Sie die Option "-h" oder "--help" aus. <br>  Nachdem das Dienstprogramm ausgef√ºhrt wurde, erhalten wir * .h-Dateien, deren Inhalt bequem an die richtige Stelle im Projekt √ºbertragen werden kann (daher gibt es keinen Schutz). <br><br>  Vor dem Auspacken werden der Bildschirm, das W√∂rterbuch und die Anfangsdaten vorbereitet: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawPico_DIC_P</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pPic)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpData = getPicSize(pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); tftSetAddrWindow(x, y, x+tmpData.u8Data1, y+tmpData.u8Data2); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> tmpByte, unfoldPos, dictMarker; alphaReplaceColorId = getAlphaReplaceColorId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pDict = &amp;pPic[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// save dictionary pointer pPic += getPicByte(&amp;pPic[2]); // make offset to picture data do { unfoldPos = dictMarker = 0; do { if((tmpByte = getPicByte(++pPic)) != PIC_DATA_END) { if(tmpByte &lt; DICT_MARK) { buf_packed[unfoldPos] = tmpByte; } else { dictMarker = 1; setPicWData(&amp;buf_packed[unfoldPos]) = getPicWData(pDict, tmpByte); ++unfoldPos; } ++unfoldPos; } else { break; } } while((unfoldPos &lt; MAX_UNFOLD_SIZE) //&amp;&amp; (unfoldPos) &amp;&amp; ((tmpByte &gt; DATA_MARK) || (tmpByte &gt; MAX_DATA_LENGTH))); if(unfoldPos) { buf_packed[unfoldPos] = PIC_DATA_END; // mark end of chunk printBuf_RLE( dictMarker ? unpackBuf_DIC(pDict) : &amp;buf_packed[0] ); // V2V3 decoder } } while(unfoldPos); }</span></span></code> </pre><br>  Ein gelesenes Datenelement kann in ein W√∂rterbuch gepackt werden, daher √ºberpr√ºfen und entpacken wir es: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPackedMark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptr &gt;= DICT_MARK) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*(++ptr) != PIC_DATA_END); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint8_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpackBuf_DIC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pDict)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> swap = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dictMarker = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> getBufferPtr = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a[], <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> b[]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> swap ? &amp;a[<span class="hljs-number"><span class="hljs-number">0</span></span>] : &amp;b[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptrP = getBufferPtr(buf_unpacked, buf_packed); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptrU = getBufferPtr(buf_packed, buf_unpacked); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(dictMarker) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptrP &gt;= DICT_MARK) { setPicWData(ptrU) = getPicWData(pDict, *ptrP); ++ptrU; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *ptrU = *ptrP; } ++ptrU; ++ptrP; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptrP == PIC_DATA_END) { *ptrU = *ptrP; <span class="hljs-comment"><span class="hljs-comment">// mark end of chunk swap = !swap; ptrP = getBufferPtr(buf_unpacked, buf_packed); ptrU = getBufferPtr(buf_packed, buf_unpacked); dictMarker = findPackedMark(ptrP); } } return getBufferPtr(buf_unpacked, buf_packed); }</span></span></code> </pre><br>  Aus dem empfangenen Puffer entpacken wir nun RLE auf vertraute Weise und zeigen es auf dem Bildschirm an: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printBuf_RLE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pData)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> repeatColor; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> repeatTimes, tmpByte; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tmpByte = *pData) != PIC_DATA_END) { <span class="hljs-comment"><span class="hljs-comment">// get color index or repeat times if(tmpByte &amp; RLE_MARK) { // is it RLE byte? tmpByte &amp;= DATA_MARK; // get color index to repeat repeatTimes = *(++pData)+1; // zero RLE does not exist! } ++repeatTimes; ++pData; // get color from colorTable by color index repeatColor = palette_RAM[(tmpByte == ALPHA_COLOR_ID) ? alphaReplaceColorId : tmpByte]; do { pushColorFast(repeatColor); } while(--repeatTimes); } }</span></span></code> </pre><br>  √úberraschenderweise hatte das Ersetzen des Algorithmus keinen wesentlichen Einfluss auf die Auspackzeit und betr√§gt ~ 47 ms.  Das sind fast 8ms.  l√§nger, aber das Testbild ben√∂tigt nur 1650 Bytes! <br><br><h3>  Bis zur letzten Ma√ünahme </h3><hr>  Fast alles geht schneller! <br><br>  Trotz des Vorhandenseins von Hardware-SPI bereitet der AVR-Kern bei der Verwendung gro√üe Kopfschmerzen. <br>  Es ist seit langem bekannt, dass SPI auf AVR nicht nur mit F_CPU / 2-Geschwindigkeit l√§uft, sondern auch ein Datenregister von nur 1 Byte hat (es ist nicht m√∂glich, 2 Bytes gleichzeitig zu laden). <br>  Dar√ºber hinaus funktioniert fast der gesamte SPI-Code auf AVR, den ich getroffen habe, nach diesem Schema: <br><ul><li>  Laden Sie SPDR-Daten herunter </li><li>  Fragen Sie das SPIF-Bit in der SPSR in einer Schleife ab. </li></ul><br>  Wie Sie sehen, riecht die kontinuierliche Datenversorgung, wie sie beim STM32 erfolgt, hier nicht.  Aber auch hier k√∂nnen Sie die Ausgabe beider Entpacker um ~ 3ms beschleunigen! <br><br>  Wenn Sie das Datenblatt √∂ffnen und den Abschnitt ‚ÄûBefehlssatzuhren‚Äú lesen, k√∂nnen Sie die CPU-Kosten f√ºr die √úbertragung eines Bytes √ºber SPI berechnen: <br><ul><li>  1 Zyklus zum Laden des Registers mit neuen Daten; </li><li>  2 Schl√§ge pro Bit (oder 16 Schl√§ge pro Byte); </li><li>  1 Takt pro Taktzeile Magie (etwas sp√§ter √ºber "NOP"); </li><li>  1 Takt zum √úberpr√ºfen des Statusbits in SPSR (oder 2 Takt auf dem Zweig); </li></ul><br>  Insgesamt sollten zur √úbertragung eines Pixels (zwei Bytes) 38 Taktzyklen oder ~ 425600 Taktzyklen f√ºr das Testbild (11.200 Bytes) ausgegeben werden. <br>  Wenn wir wissen, dass F_CPU == 16 MHz ist, erhalten wir <s>0,0000000625</s> 62,5 Nanosekunden pro Taktzyklus ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Process0169</a> ), multipliziert mit den Werten, erhalten wir ~ 26 Millisekunden.  Es stellt sich die Frage: ‚ÄûWoher habe ich fr√ºher geschrieben, dass die Auspackzeit 39 ms betr√§gt?  und 47ms. "?  Alles ist einfach - Entpackerlogik + Interrupt-Handling. <br><br>  Hier ist ein Beispiel f√ºr die Interrupt-Ausgabe: <br><img src="https://habrastorage.org/webt/du/ks/p1/duksp1nkfluio5sgfwyimgo9aik.png"><br>  und ohne Unterbrechung: <br><img src="https://habrastorage.org/webt/v7/hp/xq/v7hpxqzhvsazrct5sbq7dkywq1w.png"><br>  Die Grafiken zeigen, dass die Zeit zwischen dem Einstellen des Adressfensters im VRAM-Bildschirm und dem Beginn der Daten√ºbertragung in der Version ohne Unterbrechungen k√ºrzer ist und es w√§hrend der √úbertragung fast keine L√ºcken zwischen den Bytes gibt (die Grafik ist einheitlich). <br>  Leider k√∂nnen Sie Interrupts nicht f√ºr jede Bildausgabe deaktivieren, da sonst der Sound und der Kern des gesamten Spiels unterbrochen werden (dazu sp√§ter mehr). <br><br>  Es wurde oben √ºber ein bestimmtes "magisches NOP" f√ºr eine Taktleitung geschrieben.  Tatsache ist, dass zur Stabilisierung des CLK und zum Setzen des SPIF-Flags genau 1 Taktzyklus ben√∂tigt wird und zum Zeitpunkt des Lesens dieses Flags bereits gesetzt ist, wodurch vermieden wird, dass der BREQ-Befehl in 2 Balken verzweigt. <br>  Hier ist ein Beispiel ohne NOP: <br><img src="https://habrastorage.org/webt/vp/ia/w5/vpiaw5asga4dqawu3byh03k9gii.png"><br>  und mit ihm: <br><img src="https://habrastorage.org/webt/jg/-q/4b/jg-q4b4ot1sy445kc5rvoyq-ixe.png"><br><br>  Der Unterschied scheint unbedeutend zu sein, nur ein paar Mikrosekunden, aber wenn Sie eine andere Skala nehmen: <br>  Gro√üer NOP: <br><img src="https://habrastorage.org/webt/nf/ds/gi/nfdsgii8xkar_f6jo5fihrpx8ei.png"><br>  und damit zu gro√ü: <br><img src="https://habrastorage.org/webt/8z/d9/e9/8zd9e9l79lnhj9qshrykzxxptmw.png"><br>  dann wird der Unterschied viel deutlicher und erreicht ~ 4,3 ms. <br><br>  Lassen Sie uns nun den folgenden schmutzigen Trick machen: <br><blockquote>  Wir tauschen die Reihenfolge des Ladens und Lesens der Register aus, und Sie k√∂nnen nicht auf jedes zweite Byte des SPIF-Flags warten, sondern es nur √ºberpr√ºfen, bevor Sie das erste Byte des n√§chsten Pixels laden. <br></blockquote><br>  Wir wenden Wissen an und setzen die Funktion "pushColorFast (repeatColor);" ein: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPDR_TX_WAIT(a) asm volatile(a); while((SPSR &amp; (1&lt;&lt;SPIF)) == 0); typedef union { uint16_t val; struct { uint8_t lsb; uint8_t msb; }; } SPDR_t; ... do { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ESPLORA_OPTIMIZE SPDR_t in = {.val = repeatColor}; SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">); SPDR = in.msb; SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"nop"</span></span></span><span class="hljs-meta">); SPDR = in.lsb; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> pushColorFast(repeatColor); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } while(--repeatTimes); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ESPLORA_OPTIMIZE SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// dummy wait to stable SPI #endif }</span></span></span></span></code> </pre><br>  Trotz der Unterbrechung durch den Timer ergibt die Verwendung des obigen Tricks eine Verst√§rkung von fast 6 ms .: <br><img src="https://habrastorage.org/webt/ba/ah/hm/baahhmqnnvjznm1ssuihfi-ryhu.png"><br><br>  So einfach k√∂nnen Sie mit Eisen etwas mehr herausholen und etwas √Ñhnliches ausgeben: <br><img src="https://habrastorage.org/webt/xo/fj/wv/xofjwvtbu_w_4leeunorug-axri.gif"><br><br><h3>  Kolosseumkollisionen </h3><hr>  Der Kampf der Kisten. <br><br>  Zun√§chst sind alle Objekte (Schiffe, Muscheln, Asteroiden, Boni) Strukturen (Sprites) mit den folgenden Parametern: <br><ul><li>  aktuelle X, Y-Koordinaten; </li><li>  neue Koordinaten X, Y; </li><li>  Zeiger auf das Bild. </li></ul><br>  Da das Bild die Breite und H√∂he speichert, m√ºssen diese Parameter nicht dupliziert werden. Dar√ºber hinaus vereinfacht eine solche Organisation die Logik in vielerlei Hinsicht. <br><br>  Die Berechnung selbst wird f√ºr das Banale einfach gemacht - basierend auf dem Schnittpunkt der Rechtecke.  Obwohl es nicht genau genug ist und zuk√ºnftige Konflikte nicht berechnet, ist dies mehr als genug. <br>  Die √úberpr√ºfung erfolgt abwechselnd auf der X- und Y-Achse. Aufgrund dessen reduziert das Fehlen eines Schnittpunkts auf der X-Achse die Berechnung der Kollision. <br><blockquote>  Zun√§chst wird die rechte Seite des ersten Rechtecks ‚Äã‚Äãmit der linken Seite des zweiten Rechtecks ‚Äã‚Äãauf den gemeinsamen Teil der X-Achse √ºberpr√ºft. Bei Erfolg wird eine √§hnliche Pr√ºfung f√ºr die linke Seite der ersten und rechten Seite des zweiten Rechtecks ‚Äã‚Äãdurchgef√ºhrt. <br>  Nach dem erfolgreichen Erkennen von Schnittpunkten entlang der X-Achse wird auf die gleiche Weise eine √úberpr√ºfung f√ºr die Ober- und Unterseite der Rechtecke entlang der Y-Achse durchgef√ºhrt. <br></blockquote><br>  Das obige sieht viel einfacher aus als es scheint: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSpriteCollision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sprite_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pSprOne, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sprite_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pSprTwo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpDataOne = getPicSize(pSprOne-&gt;pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpDataTwo = getPicSize(pSprTwo-&gt;pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ----------- Check X position ----------- */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> objOnePosEndX = (pSprOne-&gt;pos.Old.x + tmpDataOne.u8Data1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(objOnePosEndX &gt;= pSprTwo-&gt;pos.Old.x) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> objTwoPosEndX = (pSprTwo-&gt;pos.Old.x + tmpDataTwo.u8Data1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pSprOne-&gt;pos.Old.x &gt;= objTwoPosEndX) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// nope, different X positions } // ok, objects on same X lines; Go next... } else { return false; // nope, absolutelly different X positions } /* ---------------------------------------- */ /* ----------- Check Y position ----------- */ uint8_t objOnePosEndY = (pSprOne-&gt;pos.Old.y + tmpDataOne.u8Data2); if(objOnePosEndY &gt;= pSprTwo-&gt;pos.Old.y) { uint8_t objTwoPosEndY = (pSprTwo-&gt;pos.Old.y + tmpDataTwo.u8Data2); if(pSprOne-&gt;pos.Old.y &lt;= objTwoPosEndY) { // ok, objects on same Y lines; Go next... // yep, if we are here // then, part of one object collide wthith another object return true; } else { return false; // nope, different Y positions } } else { return false; // nope, absolutelly different Y positions } }</span></span></code> </pre><br>  Es bleibt, dies dem Spiel hinzuzuf√ºgen: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkInVadersCollision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(aliens[<span class="hljs-number"><span class="hljs-number">0</span></span>].weapon.ray) gopher; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(alien.alive) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checkSpriteCollision(&amp;ship.sprite, &amp;alien.sprite)) { gopher.sprite.pos.Old = alien.sprite.pos.Old; rocketEpxlosion(&amp;gopher); <span class="hljs-comment"><span class="hljs-comment">// now make gopher to explode \(^_^)/ removeSprite(&amp;alien.sprite); alien.alive = false; score -= SCORE_PENALTY; if(score &lt; 0) score = 0; } } } }</span></span></code> </pre><br><br><h3>  Bezier-Kurve </h3><hr>  Raumschienen. <br><br>  Wie in jedem anderen Spiel dieses Genres m√ºssen sich feindliche Schiffe entlang von Kurven bewegen. <br>  Es wurde beschlossen, quadratische Kurven als einfachste f√ºr die Steuerung und diese Aufgabe zu implementieren.  Drei Punkte reichen ihnen: der Anfang (P0), der Schluss (P2) und der Imagin√§r (P1).  Die ersten beiden geben den Anfang und das Ende der Linie an, der letzte Punkt beschreibt die Art der Kr√ºmmung. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Toller Artikel √ºber Kurven.</a> <br>  Da es sich um eine Bezier-Parameterkurve handelt, wird au√üerdem ein weiterer Parameter ben√∂tigt - die Anzahl der Zwischenpunkte zwischen Start- und Endpunkt. <br><br>  Insgesamt bekommen wir hier eine solche Struktur: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// 7 bytes position_t P0; position_t P1; position_t P2; uint8_t totalSteps; } bezier_t;</span></span></code> </pre>  Darin ist position_t eine Struktur aus zwei Bytes der Koordinaten X und Y. <br>  Das Finden eines Punktes f√ºr jede Koordinate wird unter Verwendung dieser Formel berechnet (thx Wiki): <br>  B = ((1,0 - t) ^ 2) P0 + 2t (1,0 - t) P1 + (t ^ 2) P2, <br>  t [&gt; = 0 &amp;&amp; &lt;= 1] <br><br>  Die Implementierung wurde lange Zeit ohne Fixpunktmathematik frontal gel√∂st: <br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = ((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)pItemLine-&gt;step)/((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)pLine-&gt;totalSteps); pPos-&gt;x = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P0.x + <span class="hljs-number"><span class="hljs-number">2</span></span>*t*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P1.x + t*t*pLine-&gt;P2.x; pPos-&gt;y = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P0.y + <span class="hljs-number"><span class="hljs-number">2</span></span>*t*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P1.y + t*t*pLine-&gt;P2.y; ...</code> </pre><br>  Dies kann nat√ºrlich nicht verlassen werden.  Schlie√ülich k√∂nnte das Entfernen des Schwimmers nicht nur zu einer Verbesserung der Geschwindigkeit f√ºhren, sondern auch das ROM freigeben, sodass die folgenden Implementierungen gefunden wurden: <br><ul><li>  avrfix; </li><li>  stdfix; </li><li>  libfixmath; </li><li>  fixedptc. </li></ul><br>  Das erste bleibt ein dunkles Pferd, da es eine kompilierte Bibliothek ist und sich nicht mit dem Disassembler anlegen wollte. <br><br>  Der zweite Kandidat aus dem GCC-Bundle hat ebenfalls nicht funktioniert, da der verwendete avr-gcc nicht gepatcht wurde und der Typ "short _Accum" nicht verf√ºgbar blieb. <br><br>  Die dritte Option, trotz der Tatsache, dass es eine gro√üe Anzahl von Matten hat.  Funktionen, hat hartcodierte Bitoperationen f√ºr bestimmte Bits im Format Q16.16, was es unm√∂glich macht, die Werte von Q und I zu steuern. <br><br>  Letzteres kann als vereinfachte Version von "fixedmath" betrachtet werden. Der Hauptvorteil ist jedoch die M√∂glichkeit, nicht nur die Gr√∂√üe der Variablen zu steuern, die standardm√§√üig 32 Bit mit dem Format Q24.8 betr√§gt, sondern auch die Werte von Q und I. <br><br>  Testergebnisse bei verschiedenen Einstellungen: <br><table><tbody><tr><th>  Typ </th><th>  IQ </th><th>  Zus√§tzliche Flags </th><th>  ROM-Byte </th><th>  Tms. * </th></tr><tr><td>  float </td><td>  - - </td><td>  - - </td><td>  4236 </td><td>  35 </td></tr><tr><td>  Fixmath </td><td>  16.16 </td><td>  - - </td><td>  4796 </td><td>  119 </td></tr><tr><td>  Fixmath </td><td>  16.16 </td><td>  FIXMATH_NO_OVERFLOW </td><td>  4664 </td><td>  89 </td></tr><tr><td>  Fixmath </td><td>  16.16 </td><td>  FIXMATH_OPTIMIZE_8BIT </td><td>  5036 </td><td>  92 </td></tr><tr><td>  Fixmath </td><td>  16.16 </td><td>  _NO_OVERFLOW + _8BIT </td><td>  4916 </td><td>  89 </td></tr><tr><td>  fixedptc </td><td>  24.8 </td><td>  FIXEDPT_BITS 32 </td><td>  4420 </td><td>  64 </td></tr><tr><td>  fixedptc </td><td>  9.7 </td><td>  FIXEDPT_BITS 16 </td><td>  3490 </td><td>  31 </td></tr></tbody></table>  * Die Pr√ºfung wurde nach dem Muster "195,175,145,110,170,70,170" und dem Schl√ºssel "-Os" durchgef√ºhrt. <br><br>  Aus der Tabelle ist ersichtlich, dass beide Bibliotheken mehr ROM beanspruchten und sich bei Verwendung von float als schlechter als der kompilierte Code von GCC zeigten. <br>  Es ist auch ersichtlich, dass eine kleine √úberarbeitung des Q9.7-Formats und eine Verringerung der Variablen auf 16 Bit eine Beschleunigung von 4 ms ergab.  und Freigeben des ROM bei ~ 50 Bytes. <br><br>  Der erwartete Effekt war eine Abnahme der Genauigkeit und eine Zunahme der Anzahl der Fehler: <br><img src="https://habrastorage.org/webt/sz/v0/yt/szv0ytpsb0ogl5hkp39blbggvzw.png"><br>  was in diesem Fall unkritisch ist. <br><br><h3>  Ressourcen zuweisen </h3><hr>  Dienstag und Donnerstag arbeiten nur eine Stunde. <br><br>  In den meisten F√§llen werden alle Berechnungen in jedem Frame ausgef√ºhrt, was nicht immer gerechtfertigt ist, da im Frame m√∂glicherweise nicht gen√ºgend Zeit vorhanden ist, um etwas zu berechnen, und Sie mit dem Abwechseln, Z√§hlen von Frames oder √úberspringen von Frames tricksen m√ºssen.  Also ging ich weiter - gab das Personal komplett auf. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem alles in kleine Aufgaben unterteilt wurde, sei es: Berechnen von Kollisionen, Verarbeiten von Ton, Schaltfl√§chen und Anzeigen von Grafiken, reicht es aus, diese in einem bestimmten Intervall auszuf√ºhren, und die Tr√§gheit des Auges und die F√§higkeit, nur einen Teil des Bildschirms zu aktualisieren, werden ihre Aufgabe erf√ºllen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwalten das alles nicht einmal mit dem Betriebssystem, sondern mit der Zustandsmaschine, die ich vor ein paar Jahren erstellt habe, oder, einfacher gesagt, nicht mit dem verdr√§ngten tinySM-Task-Manager. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich werde die Gr√ºnde f√ºr die Verwendung anstelle eines RTOS wiederholen:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> geringere ROM-Anforderungen (~ 250 Byte Kern); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> geringere RAM-Anforderungen (~ 9 Bytes pro Task); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einfaches und verst√§ndliches Arbeitsprinzip; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Determinismus des Verhaltens; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es wird weniger CPU-Zeit verschwendet. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> l√§sst Zugang zu Eisen; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plattformunabh√§ngig; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> geschrieben in C und einfach in C ++ zu verpacken; </font></font></li><li> <s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">brauchte mein eigenes Fahrrad.</font></font></s> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie ich einmal beschrieben habe, sind Aufgaben daf√ºr in einem Array von Zeigern auf Strukturen organisiert, in denen ein Zeiger auf eine Funktion und ihr Aufrufintervall gespeichert sind. </font><font style="vertical-align: inherit;">Diese Gruppierung vereinfacht die Beschreibung des Spiels in separaten Phasen, wodurch Sie auch die Anzahl der Zweige reduzieren und die Aufgaben dynamisch wechseln k√∂nnen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hrend des Startbildschirms werden beispielsweise 7 Aufgaben ausgef√ºhrt, und w√§hrend des Spiels gibt es bereits 20 Aufgaben (alle Aufgaben sind in der Datei gameTasks.c beschrieben). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zun√§chst m√ºssen Sie einige Makros definieren:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> T(a) a##Task #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_N(a) const taskParams_t T(a) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK(a,b) TASK_N(a) PROGMEM = {.pFunc=a, .timeOut=b} #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_P(a) (taskParams_t*)&amp;T(a) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_ARR_N(a) const tasksArr_t a##TasksArr[] #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_ARR(a) TASK_ARR_N(a) PROGMEM #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_END NULL</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Taskdeklaration erstellt tats√§chlich eine Struktur, initialisiert ihre Felder und platziert sie im ROM: </font></font><br><pre> <code class="cpp hljs">TASK(updateBtnStates, <span class="hljs-number"><span class="hljs-number">25</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede solche Struktur belegt 4 Bytes ROM (zwei pro Zeiger und zwei pro Intervall). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein netter Bonus f√ºr Makros ist, dass es nicht funktioniert, mehr als eine eindeutige Struktur f√ºr jede Funktion zu erstellen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die erforderlichen Aufgaben deklariert haben, f√ºgen wir sie dem Array hinzu und legen sie auch im ROM ab:</font></font><br><pre> <code class="cpp hljs">TASK_ARR( game ) = { TASK_P(updateBtnStates), TASK_P(playMusic), TASK_P(drawStars), TASK_P(moveShip), TASK_P(drawShip), TASK_P(checkFireButton), TASK_P(pauseMenu), TASK_P(drawPlayerWeapon), TASK_P(checkShipHealth), TASK_P(drawSomeGUI), TASK_P(checkInVaders), TASK_P(drawInVaders), TASK_P(moveInVaders), TASK_P(checkInVadersRespawn), TASK_P(checkInVadersRay), TASK_P(checkInVadersCollision), TASK_P(dropWeaponGift), TASK_END };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie das USE_DYNAMIC_MEM-Flag f√ºr den statischen Speicher auf 0 setzen, m√ºssen Sie vor allem die Zeiger auf den Task-Speicher im RAM initialisieren und die maximale Anzahl der Zeiger festlegen, die ausgef√ºhrt werden sollen: </font></font><br><pre> <code class="cpp hljs">... tasksContainer_t tasksContainer; taskFunc_t tasksArr[MAX_GAME_TASKS]; ... initTasksArr(&amp;tasksContainer, &amp;tasksArr[<span class="hljs-number"><span class="hljs-number">0</span></span>], MAX_GAME_TASKS); ‚Ä¶</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufgaben f√ºr die Ausf√ºhrung festlegen: </font></font><br><pre> <code class="cpp hljs">... addTasksArray_P(gameTasksArr); ‚Ä¶</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der √úberlaufschutz wird durch das Flag USE_MEM_PANIC gesteuert. Wenn Sie sich √ºber die Anzahl der Aufgaben sicher sind, k√∂nnen Sie ihn deaktivieren, um das ROM zu speichern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es bleibt nur der Handler auszuf√ºhren:</font></font><br><pre> <code class="cpp hljs">... runTasks(); ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Inneren befindet sich eine Endlosschleife, die die Grundlogik enth√§lt. </font><font style="vertical-align: inherit;">Sobald er sich darin befindet, wird der Stapel dank "__attribute__ ((noreturn))" ebenfalls wiederhergestellt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Schleife werden die Elemente des Arrays abwechselnd auf die Notwendigkeit √ºberpr√ºft, die Aufgabe nach Ablauf des Intervalls aufzurufen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Intervallz√§hlung wurde auf der Basis von timer0 als System mit einem Quantum von 1 ms durchgef√ºhrt ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotz der erfolgreichen zeitlichen Verteilung der Aufgaben √ºberlappten sie sich manchmal (Jitter), was zu einem kurzfristigen Verblassen von allem und jedem im Spiel f√ºhrte. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es musste definitiv entschieden werden, aber wie? </font><font style="vertical-align: inherit;">Wie das n√§chste Mal alles profiliert wurde, aber versuchen Sie vorerst, das Osterei in der Quelle zu finden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Ende </font></font></h3><hr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit vielen Tricks (und vielen weiteren, die ich nicht beschrieben habe) stellte sich heraus, dass alles in ein 24-KB-ROM und 1500 Byte RAM passte. </font><font style="vertical-align: inherit;">Wenn Sie Fragen haben, beantworte ich diese gerne.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr diejenigen, die kein Osterei gefunden oder nicht gesucht haben:</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur Seite graben: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invadersMagicRespawn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!alien.alive) { alien.respawnTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nichts Besonderes, oder? </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raaaaazvorachivaem Makro-InvasorenMagicRespawn:</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tftSetTextSize(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { tftSetCP437(RN &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>); tftSetTextColorBG((((RN % <span class="hljs-number"><span class="hljs-number">192</span></span> + <span class="hljs-number"><span class="hljs-number">64</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFC</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>), COLOR_BLACK); tftDrawCharInt(((RN % <span class="hljs-number"><span class="hljs-number">26</span></span>) * <span class="hljs-number"><span class="hljs-number">6</span></span>), ((RN &amp; <span class="hljs-number"><span class="hljs-number">15</span></span>) * <span class="hljs-number"><span class="hljs-number">8</span></span>), (RN % <span class="hljs-number"><span class="hljs-number">255</span></span>)); tftPrintAt_P(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">58</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)creditP0); } } a(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!alien.alive) { alien.respawnTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } }</code> </pre><br>   ¬´(void)¬ª    ,  ¬´action()¬ª          10 ,    ¬´disablePause();¬ª.               ¬´Matrix Falling code¬ª    .       130  ROM. <br></div></div><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zum Erstellen und Ausf√ºhren reicht es aus, den Ordner (oder Link) "esploraAPI" in "/ arduino / library /" abzulegen. </font></font><br><br>  Referenzen: <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Spiel;</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esploraAPI;</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pickoPacker packer;</font></font></a> </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PS Sie k√∂nnen sehen und h√∂ren, wie alles etwas sp√§ter aussieht, wenn ich ein akzeptables Video mache. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425407/">https://habr.com/ru/post/de425407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425395/index.html">10 physikalische Fakten, die Sie in der Schule h√§tten kennen m√ºssen, aber m√∂glicherweise nicht kennen</a></li>
<li><a href="../de425397/index.html">10 Bibliotheken, √ºber die jeder Android-Entwickler Bescheid wissen sollte</a></li>
<li><a href="../de425401/index.html">Bericht des Club of Rome 2018, Kapitel 1.11: Disruptive Technologie und die digitale Revolution</a></li>
<li><a href="../de425403/index.html">Craigslist Creator Finances: Website gegen gef√§lschte Nachrichten, Diskriminierung und Exzesse von Internetgiganten</a></li>
<li><a href="../de425405/index.html">Newtypen der Gro√ümacht</a></li>
<li><a href="../de425409/index.html">DevBoy: einen Signalgenerator machen</a></li>
<li><a href="../de425411/index.html">Scrum ist tot</a></li>
<li><a href="../de425413/index.html">Sind Joons so gut?</a></li>
<li><a href="../de425415/index.html">Perl 5: Wie Makros Fehler versteckten</a></li>
<li><a href="../de425417/index.html">Flash f√ºr alle. Alle Flash-Arrays von QSAN</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>