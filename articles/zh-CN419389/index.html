<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎧 👨‍⚕️ 👩🏾‍🔧 Angular 6和Ivy渲染引擎 📟 🔌 👩🏻‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="同事们下午好。 我们正在考虑是否要更新Jacob Fine和Anton Moiseev所著的“ Angular and TypeScript。专业人士的网站建设 ”。 今年秋天将发布新版本 ，其中包含有关Angular 5和Angular 6的资料。 

 最初，我们考虑发布有关Ivy引擎的资料，这...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angular 6和Ivy渲染引擎</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/419389/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/wl/x_/u9/wlx_u9fwbjqm0in1o-f790lshsg.jpeg" align="left" alt="图片"></a> 同事们下午好。 我们正在考虑是否要更新Jacob Fine和Anton Moiseev所著的“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Angular and TypeScript。专业人士的网站建设</a> ”。 今年秋天<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将发布新版本</a> ，其中包含有关Angular 5和Angular 6的资料。 <br><br> 最初，我们考虑发布有关Ivy引擎的资料，这可能是Angular 6中最有趣的创新，但是后来我们停止了Cedric Exbright的更多概述出版物（原始版本于5月发布）。 <br><br> 在Angular 6中，有很多严肃的创新，而且其中最重要的创新是您无法命名的功能：这是新的渲染引擎Ivy。 由于该引擎仍处于试验阶段，因此我们将在本文结尾处讨论它，并从其他新功能和革命性变化入手。 <br><a name="habracut"></a><br>  <b>摇摇欲坠的提供者</b> <br><br> 现在，有一种新的建议方法，即使用新的providerIn属性在<code>@Injectable()</code>装饰器中直接注册提供程序。 它以<code>'root'</code>作为应用程序中任何模块的值。 使用<code>'root'</code>实现的对象将作为一个单独的对象在应用程序中注册，并且您无需将其添加到root模块的提供程序中。 同样，当使用<code>providedIn: UsersModule</code>实现的对象将注册为<code>UsersModule</code>提供程序，并且不会添加到模块提供程序中。 <br><br><pre> <code class="javascript hljs">@Injectable({ <span class="hljs-attr"><span class="hljs-attr">providedIn</span></span>: <span class="hljs-string"><span class="hljs-string">'root'</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserService</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br> 引入了这种新方法以更好地删除应用程序中的非功能代码（摇树）。 当前，情况是这样的：即使未在应用程序中使用服务，添加到模块提供者的服务也将最终确定为最终集合-允许这样做有点可悲。 如果您使用延迟加载，则可能会立即陷入多个陷阱，或者发现自己陷入了错误输入服务的情况。 <br><br> 应用程序中的这种情况不太可能经常发生（如果您编写服务然后使用它），但是第三方模块有时会提供我们不需要的服务-最终，我们有很多无用的JavaScript。 <br><br> 因此，此功能对库开发人员特别有用，但是现在建议以这种方式注册已实现的对象-这也适用于应用程序开发人员。 现在，在使用服务时，默认情况下，新的CLI甚至还使用了<code>providedIn: 'root'</code>支架。 <br><br> 同样，您现在可以声明一个<code>InjectionToken</code> ，直接在<code>InjectionToken</code>中注册它<code>providedIn</code>并在此处添加一个<code>factory</code> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baseUrl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InjectionToken&lt;string&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'baseUrl'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, { providedIn: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'root'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, factory: (</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'http://localhost:8080/'</span></span> });</code> </pre> <br> 请注意：这也简化了单元测试。 为了进行此类测试，它们用于向测试模块的提供者注册服务。 这是我们之前所做的： <br><br><pre> <code class="javascript hljs">beforeEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> TestBed.configureTestingModule({ <span class="hljs-attr"><span class="hljs-attr">providers</span></span>: [UserService] }));</code> </pre><br> 现在，如果UserService使用<code>providedIn: 'root'</code> ： <br><br><pre> <code class="javascript hljs">beforeEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> TestBed.configureTestingModule({}));</code> </pre> <br> 不必担心：仅在确实需要时，所有在providerIn中注册的<code>providedIn</code>都不会加载到测试中，而是被延迟实例化。 <br><br>  <b>Rxjs 6</b> <br><br>  Angular 6现在在内部使用RxJS 6，因此您需要牢记这一点来更新应用程序。 <br><br> 并且... RxJS 6正在改变导入方法！ <br><br> 在RxJS 5中，您可以编写： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/Observable'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/add/observable/of'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/add/operator/map'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> squares$: Observable&lt;number&gt; = Observable.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n * n);</code> </pre> <br> 在RxJS 5.5中，出现了可传递语句： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/Observable'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/observable/of'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { map } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> squares$: Observable&lt;number&gt; = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n * n) );</code> </pre><br> 在RxJS 6.0中，导入已更改： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { map } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> squares$: Observable&lt;number&gt; = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n * n) );</code> </pre> <br> 因此，有一天您将不得不在整个应用程序中更改导入。 我写“一次”，而不是“现在”，因为RxJS兼容的库是在RxJS中发布的，它允许将RxJS下载到6.0版，即使旧版本仍在整个应用程序或所用的一个库中使用语法。 <br><br>  Angular团队已就此主题编写了<a href="">整个文档</a> ，在迁移到Angular 6.0之前绝对有必要阅读它。 <br><br> 请注意：这是一个非常酷的tslint规则集，称为<code>rxjs-tslint</code> 。 其中只有4条规则，如果将它们添加到项目中，系统将自动迁移所有导入和RxJS代码，这是通过最简单的<code>tslint --fix</code>来完成的！ 毕竟，如果您仍然不知道，在<code>tslint</code>有一个<code>fix</code>选项可以自动修复它发现的所有错误！ 它甚至更容易使用：全局安装<code>rxjs-tslint</code>并运行<code>rxjs-5-to-6-migrate -p src/tsconfig.app.json</code> 。 我在我们的一个项目中尝试了<code>rxjs-tslint</code> ，并且效果很好（至少运行两次以折叠所有导入）。 查看该项目的自述文件以了解更多详细信息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/ReactiveX/rxjs-tslint</a> 。 <br><br> 如果您有兴趣了解有关RxJS 6.0的更多信息，建议您参考Ben Lesch关于ng-conf的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下一份报告</a> 。 <br><br>  <b>i18n</b> <br><br> 与i18n相关的最重要的前景是能够“在运行时生成i18n”，而不必为每个本地点分别构建应用程序。 该功能尚不可用（只有原型），并且需要Ivy引擎才能运行（更多信息请参见下文）。 <br><br> 与i18n相关的另一项更改已经进行并且可以使用。 货币渠道已以最有效的方式进行了优化：现在，它不像以前那样将所有货币舍入到两位数，而是舍入到所需的位数（例如，对于巴林第纳尔，则舍入为3，对于智利比索，则舍入为0）。 <br><br> 如果需要，可以使用新的i18n <code>getNumberOfCurrencyDigits</code>函数以编程方式检索此值。 <br><br> 其他方便的格式化功能（例如<code>formatDate</code> ， <code>formatCurrency</code> ， <code>formatPercent</code>和<code>formatNumber</code>也出现在<code>formatPercent</code> <code>formatNumber</code> 。 <br><br> 足够方便的是，如果您要应用与通道中相同的转换，但是可以从TypeScript代码中执行。 <br><br>  <b>动画制作</b> <br><br> 在Angular 6.0中，除非使用<code>AnimationBuilder</code> ，否则无需polyfill <code>web-animations-js</code>就可以实现<code>AnimationBuilder</code> 。 您的应用程序可以赢得一些宝贵的字节！ 如果浏览器不支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>element.animate</code></a> API，则Angular 6.0会回滚到CSS关键帧的使用。 <br><br>  <b>角度元素</b> <br><br>  Angular Elements是一个项目，允许您将Angular组件包装为Web组件并将其嵌入到不使用Angular的应用程序中。 最初，该项目仅存在于“ Angular Lab”中（也就是说，它仍处于试验阶段）。 在v6中，它排在最前列，并正式包含在框架中。 这是一个重要的话题，值得单独撰写。 <br><br>  <b>ElementRef &lt;T&gt;</b> <br><br> 如果要在模板中使用元素链接，则可以使用<code>@ViewChild</code>或<code>@ViewChildren</code> ，甚至可以直接实现<code>ElementRef</code> 。 这种情况下的缺点是：在Angular 5.0或更低版本中，指定的<code>ElementRef</code>将为<code>nativeElement</code>属性获得<code>any</code>类型。 <br><br> 在Angular 6.0中，可以根据需要输入更严格的ElementRef： <br><br><pre> <code class="javascript hljs">@ViewChild(<span class="hljs-string"><span class="hljs-string">'loginInput'</span></span>) loginInput: ElementRef&lt;HTMLInputElement&gt;; ngAfterViewInit() { <span class="hljs-comment"><span class="hljs-comment">// nativeElement  `HTMLInputElement` this.loginInput.nativeElement.focus(); }</span></span></code> </pre> <br>  <b>什么被认为是不受欢迎的，什么正在根本上改变</b> <br><br> 让我们谈谈进行迁移时需要记住的事项！ <br><br>  <i><b><code>preserveWhitespaces</code> ：默认为<code>false</code></b></i> <br><br> 在“升级过程中可能发生的问题”部分中，我们注意到默认情况下，preserveWhitespaces现在为<code>false</code> 。 此选项出现在Angular 4.4中，如果您想同时期待什么-这是该主题<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的完整文章</a> 。 剧透：一切都可以做，或者可以完全破坏您的模板。 <br><br>  <i><b><code>ngModel</code>和反应形式</b></i> <br><br> 以前，可以使用<code>ngModel</code>和<code>formControl</code>提供相同的表单字段，但是今天，这种做法被认为是不希望的，并且在Angular 7.0中不再受支持。 <br><br> 这里有点混乱，整个机制起作用了，也许不是您所期望的（ <code>ngModel</code>这是您不久之前熟悉的指令，但是<code>formControl</code>指令的输入/输出执行几乎相同但不相同的任务）。 <br><br> 所以现在，如果我们应用代码： <br><br><pre> <code class="javascript hljs">&lt;input [(ngModel)]=<span class="hljs-string"><span class="hljs-string">"user.name"</span></span> [formControl]=<span class="hljs-string"><span class="hljs-string">"nameCtrl"</span></span>&gt;</code> </pre> <br> 然后我们会收到警告。 <br><br> 您可以将应用程序配置为显示<code>always</code> （ <code>once</code> ）， <code>once</code> （一次）或<code>never</code> （永远）的警告。 默认值<code>always</code> 。 <br><br><pre> <code class="javascript hljs">imports: [ ReactiveFormsModule.withConfig({ <span class="hljs-attr"><span class="hljs-attr">warnOnNgModelWithFormControl</span></span>: <span class="hljs-string"><span class="hljs-string">'never'</span></span> }); ]</code> </pre> <br> 为过渡到Angular 7做准备的一种或另一种方式，您需要修改代码以使用面向模板的形式或反应形式。 <br><br>  <b>Ivy项目：Angular中的新（新）渲染引擎</b> <br><br>  ...... 这是Angular的第4个主要版本（2、4、5、6），并且第三次重写了渲染引擎！ <br><br> 切记：Angular将您的模板编译为等效的TypeScript代码。 然后，使用您在JavaScript中编写的TypeScript编译此TypeScript，结果供用户使用。 并且在我们之前已经是Angular中该渲染引擎的第三个版本（第一个版本是Angular 2.0的初始版本，第二个版本是Angular 4.0）。 <br><br> 在此新版本的渲染引擎中，编写模板的方法没有改变，但是，它优化了许多指标，尤其是： <br><br><ul><li> 建立时间 </li><li> 表盘尺寸 </li></ul><br> 所有这一切仍在进行深入试验，新的Ivy渲染引擎通过复选框打开，如果要尝试，必须将其放入编译器选项（在<code>tsconfig.json</code>文件中）。 <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"angularCompilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"enableIvy"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br> 请注意，此机制可能不太可靠，因此请不要在生产中使用它。 也许他仍然没有工作。 但是在不久的将来它将被接受为默认选项，因此您应该尝试一次，看看它是否在您的应用程序中起作用，以及从中受益。 <br><br> 让我们更详细地讨论Ivy与旧的渲染引擎的区别。 <br><br>  <b>旧引擎生成的代码</b> <br><br> 让我们<code>PonyComponent</code>一个小例子：让我们有一个<code>PonyComponent</code>组件，该组件采用<code>PonyModel</code>模型（带有<code>name</code>和<code>color</code>参数）并显示小马的图像（取决于衣服）以及小马名称。 <br><br> 看起来像这样： <br><br><pre> <code class="javascript hljs">@Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">'ns-pony'</span></span>, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">`&lt;div&gt; &lt;ns-image [src]="getPonyImageUrl()"&gt;&lt;/ns-image&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;`</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PonyComponent</span></span></span><span class="hljs-class"> </span></span>{ @Input() ponyModel: PonyModel; getPonyImageUrl() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`images/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.ponyModel.color}</span></span></span><span class="hljs-string">.png`</span></span>; } }</code> </pre> <br>  Angular 4中引入的渲染引擎为每个模板生成了一个名为<code>ngfactory</code>的类。 该类通常包含（简化的代码）： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">View_PonyComponent_0</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewDef(<span class="hljs-number"><span class="hljs-number">0</span></span>, [ elementDef(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"div"</span></span>), elementDef(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ns-image"</span></span>, View_ImageComponent_0), directiveDef(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">49152</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, i2.ImageComponent, { <span class="hljs-attr"><span class="hljs-attr">src</span></span>: [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"src"</span></span>] }), elementDef(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"div"</span></span>), elementDef(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>]) ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">check, view</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component = view.component; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currVal_0 = component.getPonyImageUrl(); check(view, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, currVal_0); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">check, view</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component = view.component; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currVal_1 = component.ponyModel.name; check(view, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, currVal_1); }); }</code> </pre> <br> 很难阅读，但是此代码的主要部分描述如下： <br><br><ul><li> 创建的DOM的结构，其中包含元素的定义（ <code>figure</code> ， <code>img</code> ， <code>figcaption</code> ），它们的属性和文本节点的定义。 视图定义数组中的DOM结构的每个元素都由其自己的索引表示。 </li><li> 变化检测功能； 它们中包含的代码将检查模板中使用的表达式是否得出与以前相同的值。 在此， <code>getPonyImageUrl</code>方法的结果，如果更改了结果，则将更新图像组件的输入值。 小马昵称也是如此：如果更改，包含此昵称的文本节点将被更新。 </li></ul><br>  <b>常春藤生成的代码</b> <br><br> 如果我们使用Angular 6，并且将<code>enableIvy</code>标志设置为<code>true</code> ，则在同一示例中将不会生成单独的<code>ngfactory</code> 。 信息将直接嵌入到组件本身的静态字段中（简化代码）： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PonyComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ngComponentDef = defineComponent({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: PonyComponent, <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: [[<span class="hljs-string"><span class="hljs-string">'ns-pony'</span></span>]], <span class="hljs-attr"><span class="hljs-attr">factory</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PonyComponent(), <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">renderFlag, component</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">renderFlag &amp; RenderFlags.Create</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementStart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'figure'</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementStart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'ns-image'</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementStart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'div'</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">renderFlag &amp; RenderFlags.Update</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">property</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'src'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, component.getPonyImageUrl(</span></span></span><span class="hljs-function">)); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">, interpolate(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">, component.ponyModel.name, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span></span><span class="hljs-function">)); } }, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inputs</span></span></span><span class="hljs-function">: { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ponyModel</span></span></span><span class="hljs-function">: '</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ponyModel</span></span></span><span class="hljs-function">' }, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">directives</span></span></span><span class="hljs-function">: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> [ImageComponent]; }); <span class="hljs-comment"><span class="hljs-comment">// ...   }</span></span></code> </pre> <br> 现在，所有内容都包含在此静态字段中。  <code>template</code>属性包含与熟悉的<code>ngfactory</code>等效的属性，但结构略有不同。 与以前一样， <code>template</code>功能将在进行任何更改时启动，但现在有两种模式： <br><br><ul><li> 创建模式：正在创建组件，它包含需要创建的静态DOM节点 </li><li> 每次更改都会执行其余功能（如有必要，将更新图像源和文本节点）。 </li></ul><br>  <b>这有什么变化？</b> <br><br> 现在，所有装饰器都直接内置到其类中（ <code>@Injectable</code> <code>@Pipe</code> ， <code>@Directive</code>和<code>@Pipe</code> <code>@Directive</code> ），要生成它们，您只需要了解当前的装饰器即可。  Angular团队将此现象称为“局部性原则”：重新编译组件，您无需重新分析应用程序。 <br><br> 生成的代码略有减少，但是更重要的是，可以消除许多依赖关系，从而在应用程序的其中一部分发生更改时加快了重新编译的速度。 此外，对于现代的收集器（例如Webpack），一切都变得更加漂亮：非功能性代码被安全地切断，即框架中那些您不需要的部分。 例如，如果您在应用程序中没有通道，那么它们的解释所需的框架甚至不会包含在最终集中。 <br><br> 我们习惯于使Angular代码繁重。 有时并不可怕，但是经过压缩和压缩后，Hello World重达37 kb。 当Ivy负责生成代码时，非功能代码将被更有效地切断。 现在，压缩后的Hello World压缩为7.3 kb，压缩后仅为2.7 kb，这是一个很大的差异。 压缩后的TodoMVC应用程序-仅12.2 kb。 这是来自Angular团队的数据，其他人无法与我们合作，因为要使Ivy能够按此处所述的方式工作，您仍然需要手动对其进行修补。 <br><br> 有关更多详细信息，请使用ng-conf进行本次<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演讲</a> 。 <br><br>  <b>与现有库的兼容性</b> <br><br> 您可能会感兴趣：如果在项目中使用Ivy，已经以旧格式发布的库会发生什么？ 不用担心：即使没有Ivy进行编译，引擎也会为项目的依赖项提供Ivy兼容版本。 我现在不会公开内部，但是所有细节都必须透明。 <br><br>  <i><b>新功能</b></i> <br><br> 让我们考虑一下使用此显示引擎时我们将拥有哪些新机会。 <br><br>  <i>模板中的私有属性</i> <br><br> 新引擎增加了新功能或潜在的变化。 <br> 这种情况直接与以下事实有关：模板函数嵌入在组件的静态字段中：现在，我们可以在模板中使用组件的私有属性。 以前这是不可能的，因此我们不得不公开模板中使用的组件的所有字段和方法，并且将它们<code>ngfactory</code>为单独的类（ <code>ngfactory</code> ）。 从另一个类访问私有属性时，TypeScript编译将失败。 现在已经过去了：由于模板函数位于静态字段中，因此可以访问组件的私有属性。 <br><br> 我看到了Angular团队成员的评论，尽管现在可以这样做，但不建议在模板中使用私有属性，因为将来可能再次禁止使用……因此，明智的做法是继续仅在模板中使用公共字段！ 无论如何，编写单元测试现在变得更加容易，因为测试可以检查组件的状态，而无需为此生成和检查DOM。 <br><br>  <i>i18n在运行时</i> <br><br> 请注意：新的渲染引擎最终为我们带来了期待已久的机会，并提供了“运行时i18n”。 在撰写本文时，她还没有准备好，但是我们一次看到了几次提交，这是一个好兆头！ <br> 很棒的事情是，如果您已经在使用i18n，则不必更改应用程序。 但是现在，您不需要为计划支持的每个语言环境重建应用程序-只需上载带有每个语言环境翻译的JSON，其余的工作就由Angular来完成！ <br><br>  <i>AoT库</i> <br><br> 当前，在NPM中发布的库必须发布metadata.json文件，并且不能发布其组件的AoT代码。 这是可悲的，因为与这种组装相关的成本被转移到了我们的应用程序中。 使用Ivy，不需要元数据文件，并且库作者现在可以将其AoT代码直接发布到NPM！ <br><br>  <i>改进的堆栈轨道</i> <br><br> 现在，如果您的模板有问题，那么生成的代码应该提供改进的堆栈跟踪-导致一个整洁的错误，指示发生模板的行。 您甚至可以在模板中设置断点，并跟踪Angular中实际发生的情况。 <br><br>  <i><code>NgModule</code>消失吗？</i> <br><br> 这仍然是遥遥无期的前景，但也许将来没有NgModules也可以实现。 这种变化的第一个迹象是可摇树的提供者，并且逻辑上假设Ivy对于准备逐渐放弃NgModule（或至少使其响应速度较慢）的人具有所有必要的基本块。 没错，所有这一切仍在将来，我们会耐心等待。 <br><br> 此版本中不会有很多新功能，但是Ivy对于未来肯定是有趣的。 尝试一下-我想知道您会如何喜欢它！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN419389/">https://habr.com/ru/post/zh-CN419389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN419373/index.html">在实际示例中比较React和Vue</a></li>
<li><a href="../zh-CN419375/index.html">循环miRNA</a></li>
<li><a href="../zh-CN419379/index.html">特斯拉和德意志银行为何拒绝纸质合同</a></li>
<li><a href="../zh-CN419383/index.html">新的WPA2攻击技术，不需要AP上的客户端</a></li>
<li><a href="../zh-CN419385/index.html">心脏手术：我们如何重写DLP系统的主要组成部分</a></li>
<li><a href="../zh-CN419391/index.html">力量，金钱和开源。 讲述社区如何与Apache Ignite合作</a></li>
<li><a href="../zh-CN419393/index.html">在ASP.NET Core中创建一个简单的API网关</a></li>
<li><a href="../zh-CN419395/index.html">Lambda表达式的说明</a></li>
<li><a href="../zh-CN419397/index.html">我们如何为六个国家/地区制作移动应用</a></li>
<li><a href="../zh-CN419399/index.html">OpenAI Five在一场表演赛Dota 2中击败了一群人</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>