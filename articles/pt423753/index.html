<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∫ üî∫ üèâ Mantenha os tokens de autoriza√ß√£o seguros ‚û°Ô∏è üóÑÔ∏è üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√°% username%. Independentemente do t√≥pico do relat√≥rio, sou constantemente perguntado nas confer√™ncias a mesma pergunta - ‚Äúcomo armazenar com segura...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mantenha os tokens de autoriza√ß√£o seguros</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423753/">  Ol√°% username%.  Independentemente do t√≥pico do relat√≥rio, sou constantemente perguntado nas confer√™ncias a mesma pergunta - ‚Äúcomo armazenar com seguran√ßa tokens no dispositivo do usu√°rio?‚Äù.  Normalmente, tento responder, mas o tempo n√£o permite revelar completamente o t√≥pico.  Com este artigo, quero fechar completamente esse problema. <br><a name="habracut"></a><br>  Analisei uma d√∫zia de aplicativos para ver como eles funcionam com tokens.  Todos os aplicativos que analisei processaram dados cr√≠ticos e permitiram definir um c√≥digo PIN para entrada como uma prote√ß√£o adicional.  Vejamos os erros mais comuns: <br><br><ul><li>  Enviar um c√≥digo PIN para a API junto com o RefreshToken para confirmar a autentica√ß√£o e receber novos tokens.  - Ruim, o RefreshToken √© inseguro no armazenamento local, com acesso f√≠sico ao dispositivo ou backup, voc√™ pode extra√≠-lo e o malware pode faz√™-lo. </li><li> Salvando o c√≥digo PIN na mensagem com RefreshToken, depois a verifica√ß√£o local do c√≥digo PIN e enviando o RefreshToken para a API.  - Um pesadelo, o RefreshToken √© inseguro junto com o pino, o que permite que eles sejam extra√≠dos; al√©m disso, outro vetor aparece sugerindo ignorar a autentica√ß√£o local. </li><li>  Criptografia incorreta do RefreshToken com um c√≥digo PIN, que permite restaurar o c√≥digo PIN e o RefreshToken a partir do texto cifrado.  - Um caso especial de erro anterior, explorado um pouco mais complicado.  Mas note que este √© o caminho certo. </li></ul><br>  Depois de analisar os erros comuns, voc√™ pode continuar pensando na l√≥gica do armazenamento seguro de tokens em seu aplicativo.  Vale a pena come√ßar com os ativos b√°sicos associados √† autentica√ß√£o / autoriza√ß√£o durante a opera√ß√£o do aplicativo e apresentar alguns requisitos para eles: <br><br>  <b>Credenciais</b> - (nome de usu√°rio + senha) - s√£o usadas para autenticar o usu√°rio no sistema. <br>  + a senha nunca √© armazenada no dispositivo e deve ser limpa imediatamente da RAM ap√≥s o envio para a API <br>  + n√£o s√£o transmitidos pelo m√©todo GET nos par√¢metros de consulta da solicita√ß√£o HTTP, as solicita√ß√µes POST s√£o usadas <br>  + o cache do teclado est√° desativado para o processamento de senha nos campos de texto <br>  + √°rea de transfer√™ncia est√° desativada para campos de texto que cont√™m uma senha <br>  + a senha n√£o √© divulgada pela interface do usu√°rio (eles usam asteriscos); tamb√©m, a senha n√£o aparece nas capturas de tela <br><br>  <b>AccessToken</b> - usado para confirmar a autoriza√ß√£o do usu√°rio. <br>  + nunca armazenado na mem√≥ria de longo prazo e armazenado apenas na RAM <br>  + n√£o s√£o transmitidos pelo m√©todo GET nos par√¢metros de consulta da solicita√ß√£o HTTP, as solicita√ß√µes POST s√£o usadas <br><br>  <b>RefreshToken</b> - usado para obter um novo pacote configur√°vel AccessToken + RefreshToken. <br>  O + n√£o √© armazenado de nenhuma forma na RAM e deve ser removido imediatamente ap√≥s o recebimento da API e o salvamento na mem√≥ria de longo prazo ou ap√≥s o recebimento da mem√≥ria de longo prazo e o uso <br>  + armazenado apenas na forma criptografada na mem√≥ria de longo prazo <br>  + criptografado com um alfinete usando magia e certas regras (as regras ser√£o descritas abaixo), aquelas se o alfinete n√£o tiver sido definido e n√£o ser√£o salvos <br>  + n√£o s√£o transmitidos pelo m√©todo GET nos par√¢metros de consulta da solicita√ß√£o HTTP, as solicita√ß√µes POST s√£o usadas <br><br>  <b>PIN</b> - (geralmente um n√∫mero de 4 ou 6 d√≠gitos) - usado para criptografar / descriptografar o RefreshToken. <br>  + nunca armazenado em nenhum lugar do dispositivo e deve ser imediatamente removido da RAM ap√≥s o uso <br>  + nunca sai dos limites do aplicativo, eles n√£o s√£o transmitidos a lugar algum <br>  + usado apenas para criptografia / descriptografia RefreshToken <br><br>  <b>OTP</b> √© um c√≥digo √∫nico para 2FA. <br>  O OTP nunca √© armazenado no dispositivo e deve ser imediatamente removido da RAM ap√≥s o envio para a API <br>  + n√£o s√£o transmitidos pelo m√©todo GET nos par√¢metros de consulta da solicita√ß√£o HTTP, as solicita√ß√µes POST s√£o usadas <br>  + cache do teclado desativado para campos de texto que processam OTP <br>  + √°rea de transfer√™ncia desativada para campos de texto que cont√™m OTP <br>  + OTP n√£o entra em capturas de tela <br>  + o aplicativo remove o OTP da tela quando passa para o segundo plano <br><br>  Agora vamos √† <s>m√°gica da</s> criptografia.  O principal requisito √© que, em hip√≥tese alguma, voc√™ permita a implementa√ß√£o de um mecanismo de criptografia RefreshToken, no qual √© poss√≠vel validar o resultado da descriptografia localmente.  Ou seja, se um invasor se apossar do texto cifrado, ele n√£o poder√° pegar a chave.  O √∫nico validador deve ser a API.  Essa √© a √∫nica maneira de limitar as tentativas de sele√ß√£o de teclas e invalidar os tokens no caso de um ataque de for√ßa bruta. <br><br>  Vou dar um bom exemplo, digamos que queremos criptografar o UUID <br><blockquote>  aec27f0f-b8a3-43cb-b076-e075a095abfe </blockquote>  com esse conjunto de acess√≥rios AES / CBC / PKCS5, usando um PIN como chave.  Parece que o algoritmo √© bom, tudo √© baseado em diretrizes, mas h√° um ponto-chave - a chave cont√©m muito pouca entropia.  Vamos ver o que isso leva a: <br><br><ol><li>  Preenchimento - como nosso token ocupa 36 bytes e o AES √© um modo de criptografia de bloco com um bloco de 128 bits, o algoritmo precisa finalizar o token at√© 48 bytes (que √© um m√∫ltiplo de 128 bits).  Em nossa vers√£o, a cauda ser√° adicionada de acordo com o padr√£o PKCS5Padding, ou seja,  o valor de cada byte adicionado √© igual ao n√∫mero de bytes adicionados <br><blockquote>  01 <br>  02 02 <br>  03 03 03 <br>  04 04 04 04 <br>  05 05 05 05 05 <br>  06 06 06 06 06 06 <br>  etc. </blockquote>  Nosso √∫ltimo bloco ser√° mais ou menos assim: <br><blockquote>  ...  61 62 66 65 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 | </blockquote>  E h√° um problema, observando esse preenchimento, podemos filtrar os dados (pelo √∫ltimo bloco inv√°lido) descriptografados pela chave errada e, assim, determinar o RefreshToken v√°lido a partir do heap distorcido. </li><li>  Formato previs√≠vel do token - mesmo se fizermos dele um m√∫ltiplo de 128 bits (por exemplo, remover h√≠fens) para evitar adicionar preenchimento, encontraremos o seguinte problema.  O problema √© que, da mesma pilha distorcida, podemos coletar as linhas e determinar qual delas se enquadra no formato UUID.  O UUID em sua forma textual can√¥nica possui 32 d√≠gitos no formato hexadecimal, separados por um h√≠fen em 5 grupos 8-4-4-4-12 <br>  xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx <br>  onde M √© a vers√£o e N √© a op√ß√£o.  Tudo isso √© suficiente para filtrar os tokens descriptografados com a chave errada, deixando um formato UUID RefreshToken adequado. </li></ol><br>  Dado todo o exposto, voc√™ pode prosseguir para a implementa√ß√£o. Eu escolhi uma op√ß√£o simples para gerar 64 bytes aleat√≥rios e envolv√™-los em base64: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createRefreshToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] refreshToken = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">64</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); secureRandom.nextBytes(refreshToken); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Base64.getUrlEncoder().withoutPadding() .encodeToString(refreshToken); }</code> </pre>  Aqui est√° um exemplo de um token: <br><blockquote>  YmI8rF9pwB1KjJAZKY9JzqsCu3kFz4xt4GkRCzXS9-FS_kbN3-CF9RGiRuuGqwqMo-VxFDhgQNmgjlQFD2GvbA </blockquote>  Agora vamos ver como fica o algoritmo (no Android e iOS, o algoritmo ser√° o mesmo): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String ALGORITHM = <span class="hljs-string"><span class="hljs-string">"AES"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String CIPHER_SUITE = <span class="hljs-string"><span class="hljs-string">"AES/CBC/NoPadding"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> AES_KEY_SIZE = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> AES_BLOCK_SIZE = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encryptToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String token, String pin)</span></span></span><span class="hljs-function"> </span></span>{ decodedToken = decodeToken(token); <span class="hljs-comment"><span class="hljs-comment">//   rawPin = pin.getBytes(); byte[] iv = generate(AES_BLOCK_SIZE); //      CBC byte[] salt = generate(AES_KEY_SIZE); //       byte[] key = kdf.deriveKey(rawPin, salt, AES_KEY_SIZE); //  -    Cipher cipher = Cipher.getInstance(CIPHER_SUITE); //    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, ALGORITHM), new IvParameterSpec(iv)); return cipher.doFinal(token); } public byte[] decodeToken(String token) { byte[] rawToken = token.getBytes(); return Base64.getUrlDecoder().decode(rawToken); } public final byte[] generate(int size) { byte[] random = new byte[size]; (new SecureRandom()).nextBytes(random); return random; }</span></span></code> </pre><br>  Em que linhas vale a pena prestar aten√ß√£o: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String CIPHER_SUITE = <span class="hljs-string"><span class="hljs-string">"AES/CBC/NoPadding"</span></span>;</code> </pre><br>  Sem preenchimento, bem, voc√™ se lembra. <br><br><pre> <code class="java hljs">decodedToken = decodeToken(token); <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br>  Voc√™ n√£o pode simplesmente pegar e criptografar um token na representa√ß√£o base64, pois essa representa√ß√£o tem um determinado formato (bem, voc√™ se lembra). <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] key = kdf.deriveKey(rawPin, salt, AES_KEY_SIZE); <span class="hljs-comment"><span class="hljs-comment">//  -   </span></span></code> </pre><br>  Na sa√≠da, obtemos uma chave de tamanho AES_KEY_SIZE, adequada para o algoritmo AES.  Qualquer fun√ß√£o de deriva√ß√£o de chave recomendada pelo Argon2, SHA-3, Scrypt pode ser usada como kdf em caso de problemas de vida pbkdf2 (ela se assemelha muito bem ao FPGA). <br><br>  O token criptografado final pode ser armazenado com seguran√ßa no dispositivo e n√£o se preocupe se algu√©m puder roub√°-lo, seja um malware ou uma entidade que n√£o seja sobrecarregada por princ√≠pios morais. <br><br>  Mais algumas recomenda√ß√µes: <br><br><ul><li>  Excluir tokens dos backups. </li><li>  No iOS, armazene o token no chaveiro com o atributo kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly. </li><li>  N√£o espalhe os ativos discutidos neste artigo (chave, alfinete, senha, etc.) por todo o aplicativo. </li><li>  Substitua os ativos assim que eles se tornarem desnecess√°rios, n√£o os guarde na mem√≥ria por mais tempo que o necess√°rio. </li><li>  Use SecureRandom no Android e SecRandomCopyBytes no iOS para gerar bytes aleat√≥rios em um contexto criptogr√°fico. </li></ul><br>  Examinamos um certo n√∫mero de armadilhas ao armazenar tokens, que, na minha opini√£o, devem ser conhecidos por todas as pessoas que desenvolvem aplicativos que trabalham com dados cr√≠ticos.  Este t√≥pico, no qual voc√™ pode ficar confuso a qualquer momento, se tiver alguma d√∫vida, pergunte nos coment√°rios.  Coment√°rios sobre o texto tamb√©m s√£o bem-vindos. <br><br>  Refer√™ncias: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CWE-311: Criptografia ausente de dados sens√≠veis</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CWE-327: Uso de um algoritmo criptogr√°fico quebrado ou arriscado</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CWE-327: CWE-338: Uso do gerador de n√∫meros pseudo-aleat√≥rios criptograficamente fracos (PRNG)</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CWE-598: Exposi√ß√£o de informa√ß√µes atrav√©s de cadeias de consulta na solicita√ß√£o GET</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt423753/">https://habr.com/ru/post/pt423753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt423743/index.html">Sob controle: ferramenta de monitoramento de disco do servidor VDS</a></li>
<li><a href="../pt423745/index.html">Usando o Python para analisar habilidades relacionadas relacionadas entre desenvolvedores</a></li>
<li><a href="../pt423747/index.html">Novas ferramentas de desenvolvimento com LEGO Education - da Microsoft, MIT e mais</a></li>
<li><a href="../pt423749/index.html">8 etapas f√°ceis para falhar em um gerente de desenvolvimento iniciante</a></li>
<li><a href="../pt423751/index.html">Java para Playstation 2 - √© poss√≠vel?</a></li>
<li><a href="../pt423759/index.html">Fintech-digest: dados pessoais de cidad√£os da Federa√ß√£o Russa, mercado do Banco Central, um novo servi√ßo da CloudFlare</a></li>
<li><a href="../pt423763/index.html">O que o Uber Cash ensina aos inovadores</a></li>
<li><a href="../pt423765/index.html">Estamos escrevendo um pedido de controle remoto do MPV player da RetroOrangePi</a></li>
<li><a href="../pt423767/index.html">Hackers atacaram a British Airways: 380.000 cart√µes banc√°rios roubados</a></li>
<li><a href="../pt423769/index.html">Conectando o OpenSSL ao Mono</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>