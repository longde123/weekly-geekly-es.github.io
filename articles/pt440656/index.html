<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎄 🌪️ 🧘🏾 Contêiner profissional de aplicativos Node.js. usando o Docker 🥦 Ⓜ️ ⚽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O autor do material, cuja tradução publicamos hoje, é um engenheiro de DevOps. Ele diz que precisa usar o Docker . Em particular, essa plataforma de g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contêiner profissional de aplicativos Node.js. usando o Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/440656/">  O autor do material, cuja tradução publicamos hoje, é um engenheiro de DevOps.  Ele diz que precisa usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Docker</a> .  Em particular, essa plataforma de gerenciamento de contêiner é usada em vários estágios do ciclo de vida dos aplicativos Node.js.  O uso do Docker, uma tecnologia que, recentemente, tem sido extremamente popular, permite otimizar o processo de desenvolvimento e saída dos projetos Node.js. em produção. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/0c1/c88/f14/0c1c88f14934b3bb68342f9c5a18eee6.png" alt="imagem"></a> <br><br>  Agora estamos publicando uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">série de artigos</a> sobre o Docker, projetados para quem deseja aprender esta plataforma para uso em diversas situações.  O mesmo material se concentra principalmente no uso profissional do Docker no desenvolvimento do Node.js. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">O que é uma janela de encaixe?</font> </h2><br>  O Docker é um programa desenvolvido para organizar a virtualização no nível do sistema operacional (contêiner).  No coração dos contêineres estão imagens em camadas.  Simplificando, o Docker é uma ferramenta que permite criar, implantar e executar aplicativos usando contêineres independentes do sistema operacional em que são executados.  O contêiner inclui uma imagem do sistema operacional base necessário para o aplicativo funcionar, a biblioteca da qual esse aplicativo depende e o próprio aplicativo.  Se vários contêineres estiverem em execução no mesmo computador, eles usarão os recursos deste computador juntos.  Os contêineres do Docker podem compactar projetos criados usando uma variedade de tecnologias.  Estamos interessados ​​em projetos baseados em Node.js. <br><br><h2>  <font color="#3AC1EF">Criando um projeto Node.js</font> </h2><br>  Antes de empacotar um projeto Node.js em um contêiner do Docker, precisamos criar esse projeto.  Vamos fazer isso.  Aqui está o arquivo <code>package.json</code> deste projeto: <br><br><pre> <code class="bash hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"node-app"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"The best way to manage your Node app using Docker"</span></span>, <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"index.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node index.js"</span></span> }, <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ankit Jain &lt;ankitjain28may77@gmail.com&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span>, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"express"</span></span>: <span class="hljs-string"><span class="hljs-string">"^4.16.4"</span></span> } }</code> </pre> <br>  Para instalar as dependências do projeto, execute o comando <code>npm install</code> .  No decorrer deste comando, entre outras coisas, o arquivo <code>package-lock.json</code> será criado.  Agora crie o arquivo <code>index.js</code> , que conterá o código do projeto: <br><br><pre> <code class="bash hljs">const express = require(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); const app = express(); app.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, (req, res) =&gt; { res.send(<span class="hljs-string"><span class="hljs-string">'The best way to manage your Node app using Docker\n'</span></span>); }); app.listen(3000); console.log(<span class="hljs-string"><span class="hljs-string">'Running on http://localhost:3000'</span></span>);</code> </pre> <br>  Como você pode ver, aqui descrevemos um servidor simples que retorna algum texto em resposta a solicitações. <br><br><h2>  <font color="#3AC1EF">Criar arquivo de encaixe</font> </h2><br>  Agora que o aplicativo está pronto, vamos falar sobre como empacotá-lo em um contêiner do Docker.  Ou seja, será sobre a parte mais importante de qualquer projeto baseado no Docker, sobre o Dockerfile. <br><br>  Um Dockerfile é um arquivo de texto que contém instruções para criar uma imagem do Docker para um aplicativo.  As instruções neste arquivo, se não entrarmos em detalhes, descrevem a criação de camadas de um sistema de arquivos multinível, que possui tudo o que um aplicativo precisa para funcionar.  A plataforma Docker pode armazenar em cache camadas de imagens que, ao reutilizar camadas que já estão no cache, aceleram o processo de criação de imagens. <br><br>  Na programação orientada a objetos, existe uma classe.  Classes são usadas para criar objetos.  No Docker, as imagens podem ser comparadas com classes e os contêineres podem ser comparados com instâncias de imagens, ou seja, com objetos.  Considere o processo de geração de um Dockerfile, que nos ajudará a descobrir isso. <br><br>  Crie um Dockerfile vazio: <br><br><pre> <code class="bash hljs">touch Dockerfile</code> </pre> <br>  Como vamos criar um contêiner para o aplicativo Node.js., a primeira coisa que precisamos colocar no contêiner será a imagem básica do Nó, que pode ser encontrada no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Docker Hub</a> .  Usaremos a versão LTS do Node.js.  Como resultado, a primeira declaração do nosso Dockerfile será a seguinte: <br><br><pre> <code class="bash hljs">FROM node:8</code> </pre> <br>  Depois disso, crie um diretório para o nosso código.  Ao mesmo tempo, graças à instrução <code>ARG</code> usada aqui, podemos, se necessário, especificar o nome do diretório do <code>/app</code> que não seja <code>/app</code> durante a montagem do contêiner.  Detalhes sobre este manual podem ser encontrados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   ARG APP_DIR=app RUN mkdir -p ${APP_DIR} WORKDIR ${APP_DIR}</span></span></code> </pre> <br>  Como usamos a imagem do Node, as plataformas Node.js e npm já estarão instaladas nela.  Usando o que já está na imagem, você pode organizar a instalação das dependências do projeto.  Usando o sinalizador <code>NODE_ENV</code> (ou se a <code>NODE_ENV</code> ambiente <code>NODE_ENV</code> definida como <code>production</code> ), o npm não instalará os módulos listados na seção <code>devDependencies</code> do arquivo <code>devDependencies</code> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   COPY package*.json ./ RUN npm install #     # RUN npm install --production</span></span></code> </pre> <br>  Aqui estamos copiando o arquivo <code>package*.json</code> para a imagem, em vez de, por exemplo, copiar todos os arquivos do projeto.  Fazemos exatamente isso porque as instruções Dockerfile <code>RUN</code> , <code>COPY</code> e <code>ADD</code> criam camadas de imagem adicionais, para que você possa usar os recursos de armazenamento em cache das camadas da plataforma Docker.  Com essa abordagem, na próxima vez que coletarmos uma imagem semelhante, o Docker descobrirá se é possível reutilizar as camadas de imagem que já estão no cache e, nesse caso, aproveitará o que já existe, em vez de criar novas. camadas.  Isso permite que você economize bastante tempo ao montar camadas no decorrer do trabalho em grandes projetos, que incluem muitos módulos npm. <br><br>  Agora copie os arquivos do projeto para o diretório de trabalho atual.  Aqui não usaremos a instrução <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ADD</a> , mas a instrução <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">COPY</a> .  De fato, na maioria dos casos, recomenda-se dar preferência à instrução <code>COPY</code> . <br><br>  A instrução <code>ADD</code> , em comparação com <code>COPY</code> , possui alguns recursos que, no entanto, nem sempre são necessários.  Por exemplo, estamos falando de opções para descompactar arquivos .tar e baixar arquivos por URL. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    COPY . .</span></span></code> </pre> <br>  Os contêineres do Docker são ambientes isolados.  Isso significa que, quando iniciarmos o aplicativo no contêiner, não poderemos interagir com ele diretamente sem abrir a porta em que esse aplicativo escuta.  Para informar ao Docker que existe um aplicativo em um determinado contêiner que escuta em uma determinada porta, você pode usar a instrução <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">EXPOSE</a> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   ,      EXPOSE 3000</span></span></code> </pre> <br>  Até o momento, nós, usando o Dockerfile, descrevemos a imagem que o aplicativo conterá e tudo o que ele precisa para iniciar com êxito.  Agora adicione a instrução ao arquivo que permite iniciar o aplicativo.  Esta é uma instrução <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CMD</a> .  Permite especificar um determinado comando com parâmetros que serão executados quando o contêiner iniciar e, se necessário, poderão ser substituídos pelas ferramentas de linha de comando. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   CMD ["npm", "start"]</span></span></code> </pre> <br>  Veja como será o Dockerfile finalizado: <br><br><pre> <code class="bash hljs">FROM node:8 <span class="hljs-comment"><span class="hljs-comment">#   ARG APP_DIR=app RUN mkdir -p ${APP_DIR} WORKDIR ${APP_DIR} #   COPY package*.json ./ RUN npm install #     # RUN npm install --production #    COPY . . #   ,      EXPOSE 3000 #   CMD ["npm", "start"]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Montagem da imagem</font> </h2><br>  Preparamos um arquivo Dockerfile que contém instruções para criar a imagem, com base no qual um contêiner com um aplicativo em execução será criado.  Monte a imagem executando um comando no seguinte formato: <br><br><pre> <code class="bash hljs">docker build --build-arg &lt;build arguments&gt; -t &lt;user-name&gt;/&lt;image-name&gt;:&lt;tag-name&gt; /path/to/Dockerfile</code> </pre> <br>  No nosso caso, ficará assim: <br><br><pre> <code class="bash hljs">docker build --build-arg APP_DIR=var/app -t ankitjain28may/node-app:V1 .</code> </pre> <br>  O Dockerfile possui uma instrução <code>ARG</code> que descreve o argumento <code>APP_DIR</code> .  Aqui nós definimos o seu significado.  Se isso não for feito, o valor atribuído a ele será atribuído no arquivo, ou seja - <code>app</code> . <br><br>  Depois de montar a imagem, verifique se o Docker a vê.  Para fazer isso, execute o seguinte comando: <br><br><pre> <code class="bash hljs">docker images</code> </pre> <br>  Em resposta a este comando, aproximadamente o seguinte deve ser produzido. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/c22/3e0/51dc223e0030bb0275c3d61fa01562e5.png"></div><br>  <i><font color="#999999">Imagens do Docker</font></i> <br><br><h2>  <font color="#3AC1EF">Lançamento de imagem</font> </h2><br>  Depois de montar a imagem do Docker, podemos executá-la, ou seja, criar uma instância dela, representada por um contêiner em funcionamento.  Para fazer isso, use um comando deste tipo: <br><br><pre> <code class="bash hljs">docker run -p &lt;External-port:exposed-port&gt; -d --name &lt;name of the container&gt; &lt;user-name&gt;/&lt;image-name&gt;:&lt;tag-name&gt;</code> </pre> <br>  No nosso caso, ficará assim: <br><br><pre> <code class="bash hljs">docker run -p 8000:3000 -d --name node-app ankitjain28may/node-app:V1</code> </pre> <br>  Pediremos ao sistema informações sobre contêineres em funcionamento usando este comando: <br><br><pre> <code class="bash hljs">docker ps</code> </pre> <br>  Em resposta a isso, o sistema deve produzir aproximadamente o seguinte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87f/bc0/fcf/87fbc0fcf1bdeecef051e2874d48d91e.png"></div><br>  <i><font color="#999999">Docker Containers</font></i> <br><br>  Até agora, tudo está indo como esperado, embora ainda não tenhamos tentado acessar o aplicativo em execução no contêiner.  Ou seja, nosso contêiner, chamado <code>node-app</code> , escuta na porta <code>8000</code> .  Para tentar acessá-lo, você pode abrir um navegador e acessá-lo em <code>localhost:8000</code> .  Além disso, para verificar a integridade do contêiner, você pode usar o seguinte comando: <br><br><pre> <code class="bash hljs">curl -i localhost:8000</code> </pre> <br>  Se o contêiner realmente funcionar, algo como o mostrado na figura a seguir será retornado em resposta a este comando. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea4/407/9ba/ea44079bab09d56c402af3c58eb6a638.png"></div><br>  <i><font color="#999999">Resultado da verificação de integridade do contêiner</font></i> <br><br>  Com base na mesma imagem, por exemplo, com base no recém-criado, é possível criar muitos contêineres.  Além disso, você pode enviar nossa imagem para o registro do Docker Hub, que permitirá que outros desenvolvedores carreguem nossa imagem e iniciem os contêineres apropriados em casa.  Essa abordagem simplifica o trabalho com projetos. <br><br><h2>  <font color="#3AC1EF">Recomendações</font> </h2><br>  Aqui estão algumas sugestões que vale a pena considerar para aproveitar o poder do Docker e criar imagens o mais compactas possível. <br><br><h3>  <font color="#3AC1EF">▍1</font>  <font color="#3AC1EF">Sempre crie um arquivo .dockerignore</font> </h3><br>  Na pasta do projeto que você planeja colocar no contêiner, sempre é necessário criar um arquivo <code>.dockerignore</code> .  Ele permite que você ignore arquivos e pastas que não são necessários ao criar a imagem.  Com essa abordagem, podemos reduzir o chamado contexto de construção, o que nos permitirá montar rapidamente a imagem e reduzir seu tamanho.  Este arquivo suporta modelos de nome de arquivo, pois é semelhante a um arquivo <code>.gitignore</code> .  Recomenda-se adicionar um comando ao <code>.dockerignore</code> devido ao qual o Docker ignorará a pasta <code>/.git</code> , pois essa pasta geralmente contém materiais grandes (principalmente durante o desenvolvimento de um projeto) e a adição à imagem leva a um aumento no tamanho.  Além disso, copiar esta pasta para uma imagem não faz muito sentido. <br><br><h3>  <font color="#3AC1EF">§ 2</font>  <font color="#3AC1EF">Use o processo de montagem de imagens em vários estágios</font> </h3><br>  Considere o exemplo quando coletamos um projeto para uma determinada organização.  Este projeto usa muitos pacotes npm, e cada um desses pacotes pode instalar pacotes adicionais dos quais depende.  A realização de todas essas operações leva a um tempo adicional gasto no processo de montagem da imagem (embora isso, graças aos recursos de cache do Docker, não seja tão importante).  Pior, a imagem resultante que contém as dependências de um determinado projeto é bastante grande.  Aqui, se estamos falando de projetos front-end, podemos lembrar que esses projetos geralmente são processados ​​usando empacotadores como o webpack, o que torna possível compactar convenientemente tudo o que um aplicativo precisa em um pacote de vendas.  Como resultado, os arquivos do pacote npm para esse projeto são desnecessários.  E isso significa que podemos nos livrar desses arquivos depois de criar o projeto usando o mesmo webpack. <br><br>  Armado com essa idéia, tente fazer o seguinte: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   COPY package*.json ./ RUN npm install --production # - COPY . . RUN npm run build:production #    npm- RUN rm -rf node_modules</span></span></code> </pre> <br>  Essa abordagem, no entanto, não nos convém.  Como já dissemos, as instruções <code>RUN</code> , <code>ADD</code> e <code>COPY</code> criam camadas armazenadas em cache pelo Docker, portanto, precisamos encontrar uma maneira de lidar com a instalação de dependências, criar o projeto e excluir arquivos desnecessários com um único comando.  Por exemplo, pode ser assim: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      COPY . . #  ,      RUN npm install --production &amp;&amp; npm run build:production &amp;&amp; rm -rf node_module</span></span></code> </pre> <br>  Neste exemplo, há apenas uma instrução <code>RUN</code> que instala as dependências, <code>node_modules</code> projeto e exclui a pasta <code>node_modules</code> .  Isso leva ao fato de que o tamanho da imagem não será tão grande quanto o tamanho da imagem que inclui a pasta <code>node_modules</code> .  Usamos os arquivos desta pasta apenas durante o processo de compilação do projeto e, em seguida, excluí-lo.  É verdade que essa abordagem é ruim, pois leva muito tempo para instalar dependências do npm.  Você pode eliminar essa desvantagem usando a tecnologia de montagem de imagens em vários estágios. <br><br>  Imagine que estamos trabalhando em um projeto de front-end com muitas dependências e usamos o webpack para compilar esse projeto.  Com essa abordagem, podemos, com o objetivo de reduzir o tamanho da imagem, tirar proveito dos recursos do Docker para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">montagem de imagens</a> em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vários estágios</a> . <br><br><pre> <code class="bash hljs">FROM node:8 As build <span class="hljs-comment"><span class="hljs-comment">#  RUN mkdir /app &amp;&amp; mkdir /src WORKDIR /src #   COPY package*.json ./ RUN npm install #     # RUN npm install --production #       COPY . . RUN npm run build:production #    ,     FROM node:alpine #      build   app COPY --from=build ./src/build/* /app/ ENTRYPOINT ["/app"] CMD ["--help"]</span></span></code> </pre> <br>  Com essa abordagem, a imagem resultante é muito menor que a imagem anterior e também usamos o <code>node:alpine</code> imagem <code>node:alpine</code> , que é muito pequena.  E aqui está uma comparação de um par de imagens, durante as quais fica claro que a imagem do <code>node:alpine</code> é muito menor que a imagem do <code>node:8</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/565/c80/c3b/565c80c3bb0498e0ebcdf53022bdab6e.png"></div><br>  <i><font color="#999999">Comparando Imagens do Repositório Nó</font></i> <br><br><h3>  <font color="#3AC1EF">▍3</font>  <font color="#3AC1EF">Usar cache do Docker</font> </h3><br>  Esforce-se para usar os recursos de cache do Docker para criar suas imagens.  Já prestamos atenção a esse recurso ao trabalhar com um arquivo que foi acessado pelo nome <code>package*.json</code> .  Isso reduz o tempo de criação da imagem.  Mas essa oportunidade não deve ser usada precipitadamente. <br><br>  Suponha que descrevamos no Dockerfile a instalação de pacotes em uma imagem criada a partir da imagem base do <code>Ubuntu:16.04</code> : <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update &amp;&amp; apt-get install -y \   curl \   package-1 \   .   .</code> </pre> <br>  Quando o sistema processa esse arquivo, se houver muitos pacotes instalados, as operações de atualização e instalação levarão muito tempo.  Para melhorar a situação, decidimos aproveitar os recursos de cache de camada do Docker e reescrever o Dockerfile da seguinte maneira: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update RUN apt-get install -y \   curl \   package-1 \   .   .</code> </pre> <br>  Agora, ao montar a imagem pela primeira vez, tudo corre como deveria, pois o cache ainda não foi formado.  Imagine agora que precisamos instalar outro pacote, o <code>package-2</code> .  Para fazer isso, reescrevemos o arquivo: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update RUN apt-get install -y \   curl \   package-1 \   package-2 \   .   .</code> </pre> <br>  Como resultado desse comando, o <code>package-2</code> não será instalado ou atualizado.  Porque  O fato é que, ao executar a instrução <code>RUN apt-get update</code> , o Docker não vê nenhuma diferença entre essa instrução e a instrução executada anteriormente, como resultado, obtém dados do cache.  E esses dados já estão desatualizados.  Ao processar a instrução <code>RUN apt-get install</code> sistema a executa, pois não se parece com uma instrução semelhante no Dockerfile anterior, mas durante a instalação, podem ocorrer erros ou a versão antiga dos pacotes será instalada.  Como resultado, verifica-se que os comandos de <code>update</code> e <code>install</code> devem ser executados na mesma instrução <code>RUN</code> , como é feito no primeiro exemplo.  O armazenamento em cache é um ótimo recurso, mas o uso imprudente desse recurso pode levar a problemas. <br><br><h3>  <font color="#3AC1EF">▍4</font>  <font color="#3AC1EF">Minimize o número de camadas de imagem</font> </h3><br>  Recomenda-se, sempre que possível, minimizar o número de camadas da imagem, pois cada camada é o sistema de arquivos da imagem do Docker, o que significa que quanto menores as camadas da imagem, mais compacta será.  Ao usar o processo de várias etapas de montagem da imagem, é obtida uma redução no número de camadas na imagem e uma redução no tamanho da imagem. <br><br><h2>  <font color="#3AC1EF">Sumário</font> </h2><br>  Neste artigo, examinamos o processo de empacotamento de aplicativos Node.js em contêineres do Docker e de trabalho com esses contêineres.  Além disso, fizemos algumas recomendações que, a propósito, podem ser usadas não apenas ao criar contêineres para projetos Node.js. <br><br>  <b>Caros leitores!</b>  Se você usa o Docker profissionalmente ao trabalhar com projetos Node.js., compartilhe recomendações sobre o uso efetivo deste sistema com iniciantes. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt440656/">https://habr.com/ru/post/pt440656/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt440646/index.html">Frontend Weekly Digest (11-17 fev 2019)</a></li>
<li><a href="../pt440648/index.html">Visão geral da legislação russa no campo da acessibilidade da web</a></li>
<li><a href="../pt440650/index.html">Como funciona a consciência: conclusões do livro de Alexander Nevzorov</a></li>
<li><a href="../pt440652/index.html">Vídeo computado em 755 megapixels: plenópticos ontem, hoje e amanhã</a></li>
<li><a href="../pt440654/index.html">Aprendendo Python: módulo argparse</a></li>
<li><a href="../pt440658/index.html">Explorando o Docker, parte 4: reduzindo o tamanho das imagens e acelerando sua montagem</a></li>
<li><a href="../pt440660/index.html">Docker de aprendizagem, parte 5: comandos</a></li>
<li><a href="../pt440662/index.html">Tutorial Reagir Parte 18: A sexta fase do trabalho em um aplicativo TODO</a></li>
<li><a href="../pt440666/index.html">Classificação de desenhos manuscritos. Relatório em Yandex</a></li>
<li><a href="../pt440670/index.html">O Banco Central publicou recomendações sobre a proteção criptográfica do EBS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>