<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÑ üå™Ô∏è üßòüèæ Cont√™iner profissional de aplicativos Node.js. usando o Docker ü•¶ ‚ìÇÔ∏è ‚öΩÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O autor do material, cuja tradu√ß√£o publicamos hoje, √© um engenheiro de DevOps. Ele diz que precisa usar o Docker . Em particular, essa plataforma de g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cont√™iner profissional de aplicativos Node.js. usando o Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/440656/">  O autor do material, cuja tradu√ß√£o publicamos hoje, √© um engenheiro de DevOps.  Ele diz que precisa usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Docker</a> .  Em particular, essa plataforma de gerenciamento de cont√™iner √© usada em v√°rios est√°gios do ciclo de vida dos aplicativos Node.js.  O uso do Docker, uma tecnologia que, recentemente, tem sido extremamente popular, permite otimizar o processo de desenvolvimento e sa√≠da dos projetos Node.js. em produ√ß√£o. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/0c1/c88/f14/0c1c88f14934b3bb68342f9c5a18eee6.png" alt="imagem"></a> <br><br>  Agora estamos publicando uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">s√©rie de artigos</a> sobre o Docker, projetados para quem deseja aprender esta plataforma para uso em diversas situa√ß√µes.  O mesmo material se concentra principalmente no uso profissional do Docker no desenvolvimento do Node.js. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">O que √© uma janela de encaixe?</font> </h2><br>  O Docker √© um programa desenvolvido para organizar a virtualiza√ß√£o no n√≠vel do sistema operacional (cont√™iner).  No cora√ß√£o dos cont√™ineres est√£o imagens em camadas.  Simplificando, o Docker √© uma ferramenta que permite criar, implantar e executar aplicativos usando cont√™ineres independentes do sistema operacional em que s√£o executados.  O cont√™iner inclui uma imagem do sistema operacional base necess√°rio para o aplicativo funcionar, a biblioteca da qual esse aplicativo depende e o pr√≥prio aplicativo.  Se v√°rios cont√™ineres estiverem em execu√ß√£o no mesmo computador, eles usar√£o os recursos deste computador juntos.  Os cont√™ineres do Docker podem compactar projetos criados usando uma variedade de tecnologias.  Estamos interessados ‚Äã‚Äãem projetos baseados em Node.js. <br><br><h2>  <font color="#3AC1EF">Criando um projeto Node.js</font> </h2><br>  Antes de empacotar um projeto Node.js em um cont√™iner do Docker, precisamos criar esse projeto.  Vamos fazer isso.  Aqui est√° o arquivo <code>package.json</code> deste projeto: <br><br><pre> <code class="bash hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"node-app"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"The best way to manage your Node app using Docker"</span></span>, <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"index.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node index.js"</span></span> }, <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ankit Jain &lt;ankitjain28may77@gmail.com&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span>, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"express"</span></span>: <span class="hljs-string"><span class="hljs-string">"^4.16.4"</span></span> } }</code> </pre> <br>  Para instalar as depend√™ncias do projeto, execute o comando <code>npm install</code> .  No decorrer deste comando, entre outras coisas, o arquivo <code>package-lock.json</code> ser√° criado.  Agora crie o arquivo <code>index.js</code> , que conter√° o c√≥digo do projeto: <br><br><pre> <code class="bash hljs">const express = require(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); const app = express(); app.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, (req, res) =&gt; { res.send(<span class="hljs-string"><span class="hljs-string">'The best way to manage your Node app using Docker\n'</span></span>); }); app.listen(3000); console.log(<span class="hljs-string"><span class="hljs-string">'Running on http://localhost:3000'</span></span>);</code> </pre> <br>  Como voc√™ pode ver, aqui descrevemos um servidor simples que retorna algum texto em resposta a solicita√ß√µes. <br><br><h2>  <font color="#3AC1EF">Criar arquivo de encaixe</font> </h2><br>  Agora que o aplicativo est√° pronto, vamos falar sobre como empacot√°-lo em um cont√™iner do Docker.  Ou seja, ser√° sobre a parte mais importante de qualquer projeto baseado no Docker, sobre o Dockerfile. <br><br>  Um Dockerfile √© um arquivo de texto que cont√©m instru√ß√µes para criar uma imagem do Docker para um aplicativo.  As instru√ß√µes neste arquivo, se n√£o entrarmos em detalhes, descrevem a cria√ß√£o de camadas de um sistema de arquivos multin√≠vel, que possui tudo o que um aplicativo precisa para funcionar.  A plataforma Docker pode armazenar em cache camadas de imagens que, ao reutilizar camadas que j√° est√£o no cache, aceleram o processo de cria√ß√£o de imagens. <br><br>  Na programa√ß√£o orientada a objetos, existe uma classe.  Classes s√£o usadas para criar objetos.  No Docker, as imagens podem ser comparadas com classes e os cont√™ineres podem ser comparados com inst√¢ncias de imagens, ou seja, com objetos.  Considere o processo de gera√ß√£o de um Dockerfile, que nos ajudar√° a descobrir isso. <br><br>  Crie um Dockerfile vazio: <br><br><pre> <code class="bash hljs">touch Dockerfile</code> </pre> <br>  Como vamos criar um cont√™iner para o aplicativo Node.js., a primeira coisa que precisamos colocar no cont√™iner ser√° a imagem b√°sica do N√≥, que pode ser encontrada no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Docker Hub</a> .  Usaremos a vers√£o LTS do Node.js.  Como resultado, a primeira declara√ß√£o do nosso Dockerfile ser√° a seguinte: <br><br><pre> <code class="bash hljs">FROM node:8</code> </pre> <br>  Depois disso, crie um diret√≥rio para o nosso c√≥digo.  Ao mesmo tempo, gra√ßas √† instru√ß√£o <code>ARG</code> usada aqui, podemos, se necess√°rio, especificar o nome do diret√≥rio do <code>/app</code> que n√£o seja <code>/app</code> durante a montagem do cont√™iner.  Detalhes sobre este manual podem ser encontrados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   ARG APP_DIR=app RUN mkdir -p ${APP_DIR} WORKDIR ${APP_DIR}</span></span></code> </pre> <br>  Como usamos a imagem do Node, as plataformas Node.js e npm j√° estar√£o instaladas nela.  Usando o que j√° est√° na imagem, voc√™ pode organizar a instala√ß√£o das depend√™ncias do projeto.  Usando o sinalizador <code>NODE_ENV</code> (ou se a <code>NODE_ENV</code> ambiente <code>NODE_ENV</code> definida como <code>production</code> ), o npm n√£o instalar√° os m√≥dulos listados na se√ß√£o <code>devDependencies</code> do arquivo <code>devDependencies</code> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   COPY package*.json ./ RUN npm install #     # RUN npm install --production</span></span></code> </pre> <br>  Aqui estamos copiando o arquivo <code>package*.json</code> para a imagem, em vez de, por exemplo, copiar todos os arquivos do projeto.  Fazemos exatamente isso porque as instru√ß√µes Dockerfile <code>RUN</code> , <code>COPY</code> e <code>ADD</code> criam camadas de imagem adicionais, para que voc√™ possa usar os recursos de armazenamento em cache das camadas da plataforma Docker.  Com essa abordagem, na pr√≥xima vez que coletarmos uma imagem semelhante, o Docker descobrir√° se √© poss√≠vel reutilizar as camadas de imagem que j√° est√£o no cache e, nesse caso, aproveitar√° o que j√° existe, em vez de criar novas. camadas.  Isso permite que voc√™ economize bastante tempo ao montar camadas no decorrer do trabalho em grandes projetos, que incluem muitos m√≥dulos npm. <br><br>  Agora copie os arquivos do projeto para o diret√≥rio de trabalho atual.  Aqui n√£o usaremos a instru√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ADD</a> , mas a instru√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">COPY</a> .  De fato, na maioria dos casos, recomenda-se dar prefer√™ncia √† instru√ß√£o <code>COPY</code> . <br><br>  A instru√ß√£o <code>ADD</code> , em compara√ß√£o com <code>COPY</code> , possui alguns recursos que, no entanto, nem sempre s√£o necess√°rios.  Por exemplo, estamos falando de op√ß√µes para descompactar arquivos .tar e baixar arquivos por URL. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    COPY . .</span></span></code> </pre> <br>  Os cont√™ineres do Docker s√£o ambientes isolados.  Isso significa que, quando iniciarmos o aplicativo no cont√™iner, n√£o poderemos interagir com ele diretamente sem abrir a porta em que esse aplicativo escuta.  Para informar ao Docker que existe um aplicativo em um determinado cont√™iner que escuta em uma determinada porta, voc√™ pode usar a instru√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">EXPOSE</a> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   ,      EXPOSE 3000</span></span></code> </pre> <br>  At√© o momento, n√≥s, usando o Dockerfile, descrevemos a imagem que o aplicativo conter√° e tudo o que ele precisa para iniciar com √™xito.  Agora adicione a instru√ß√£o ao arquivo que permite iniciar o aplicativo.  Esta √© uma instru√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CMD</a> .  Permite especificar um determinado comando com par√¢metros que ser√£o executados quando o cont√™iner iniciar e, se necess√°rio, poder√£o ser substitu√≠dos pelas ferramentas de linha de comando. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   CMD ["npm", "start"]</span></span></code> </pre> <br>  Veja como ser√° o Dockerfile finalizado: <br><br><pre> <code class="bash hljs">FROM node:8 <span class="hljs-comment"><span class="hljs-comment">#   ARG APP_DIR=app RUN mkdir -p ${APP_DIR} WORKDIR ${APP_DIR} #   COPY package*.json ./ RUN npm install #     # RUN npm install --production #    COPY . . #   ,      EXPOSE 3000 #   CMD ["npm", "start"]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Montagem da imagem</font> </h2><br>  Preparamos um arquivo Dockerfile que cont√©m instru√ß√µes para criar a imagem, com base no qual um cont√™iner com um aplicativo em execu√ß√£o ser√° criado.  Monte a imagem executando um comando no seguinte formato: <br><br><pre> <code class="bash hljs">docker build --build-arg &lt;build arguments&gt; -t &lt;user-name&gt;/&lt;image-name&gt;:&lt;tag-name&gt; /path/to/Dockerfile</code> </pre> <br>  No nosso caso, ficar√° assim: <br><br><pre> <code class="bash hljs">docker build --build-arg APP_DIR=var/app -t ankitjain28may/node-app:V1 .</code> </pre> <br>  O Dockerfile possui uma instru√ß√£o <code>ARG</code> que descreve o argumento <code>APP_DIR</code> .  Aqui n√≥s definimos o seu significado.  Se isso n√£o for feito, o valor atribu√≠do a ele ser√° atribu√≠do no arquivo, ou seja - <code>app</code> . <br><br>  Depois de montar a imagem, verifique se o Docker a v√™.  Para fazer isso, execute o seguinte comando: <br><br><pre> <code class="bash hljs">docker images</code> </pre> <br>  Em resposta a este comando, aproximadamente o seguinte deve ser produzido. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/c22/3e0/51dc223e0030bb0275c3d61fa01562e5.png"></div><br>  <i><font color="#999999">Imagens do Docker</font></i> <br><br><h2>  <font color="#3AC1EF">Lan√ßamento de imagem</font> </h2><br>  Depois de montar a imagem do Docker, podemos execut√°-la, ou seja, criar uma inst√¢ncia dela, representada por um cont√™iner em funcionamento.  Para fazer isso, use um comando deste tipo: <br><br><pre> <code class="bash hljs">docker run -p &lt;External-port:exposed-port&gt; -d --name &lt;name of the container&gt; &lt;user-name&gt;/&lt;image-name&gt;:&lt;tag-name&gt;</code> </pre> <br>  No nosso caso, ficar√° assim: <br><br><pre> <code class="bash hljs">docker run -p 8000:3000 -d --name node-app ankitjain28may/node-app:V1</code> </pre> <br>  Pediremos ao sistema informa√ß√µes sobre cont√™ineres em funcionamento usando este comando: <br><br><pre> <code class="bash hljs">docker ps</code> </pre> <br>  Em resposta a isso, o sistema deve produzir aproximadamente o seguinte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87f/bc0/fcf/87fbc0fcf1bdeecef051e2874d48d91e.png"></div><br>  <i><font color="#999999">Docker Containers</font></i> <br><br>  At√© agora, tudo est√° indo como esperado, embora ainda n√£o tenhamos tentado acessar o aplicativo em execu√ß√£o no cont√™iner.  Ou seja, nosso cont√™iner, chamado <code>node-app</code> , escuta na porta <code>8000</code> .  Para tentar acess√°-lo, voc√™ pode abrir um navegador e acess√°-lo em <code>localhost:8000</code> .  Al√©m disso, para verificar a integridade do cont√™iner, voc√™ pode usar o seguinte comando: <br><br><pre> <code class="bash hljs">curl -i localhost:8000</code> </pre> <br>  Se o cont√™iner realmente funcionar, algo como o mostrado na figura a seguir ser√° retornado em resposta a este comando. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea4/407/9ba/ea44079bab09d56c402af3c58eb6a638.png"></div><br>  <i><font color="#999999">Resultado da verifica√ß√£o de integridade do cont√™iner</font></i> <br><br>  Com base na mesma imagem, por exemplo, com base no rec√©m-criado, √© poss√≠vel criar muitos cont√™ineres.  Al√©m disso, voc√™ pode enviar nossa imagem para o registro do Docker Hub, que permitir√° que outros desenvolvedores carreguem nossa imagem e iniciem os cont√™ineres apropriados em casa.  Essa abordagem simplifica o trabalho com projetos. <br><br><h2>  <font color="#3AC1EF">Recomenda√ß√µes</font> </h2><br>  Aqui est√£o algumas sugest√µes que vale a pena considerar para aproveitar o poder do Docker e criar imagens o mais compactas poss√≠vel. <br><br><h3>  <font color="#3AC1EF">‚ñç1</font>  <font color="#3AC1EF">Sempre crie um arquivo .dockerignore</font> </h3><br>  Na pasta do projeto que voc√™ planeja colocar no cont√™iner, sempre √© necess√°rio criar um arquivo <code>.dockerignore</code> .  Ele permite que voc√™ ignore arquivos e pastas que n√£o s√£o necess√°rios ao criar a imagem.  Com essa abordagem, podemos reduzir o chamado contexto de constru√ß√£o, o que nos permitir√° montar rapidamente a imagem e reduzir seu tamanho.  Este arquivo suporta modelos de nome de arquivo, pois √© semelhante a um arquivo <code>.gitignore</code> .  Recomenda-se adicionar um comando ao <code>.dockerignore</code> devido ao qual o Docker ignorar√° a pasta <code>/.git</code> , pois essa pasta geralmente cont√©m materiais grandes (principalmente durante o desenvolvimento de um projeto) e a adi√ß√£o √† imagem leva a um aumento no tamanho.  Al√©m disso, copiar esta pasta para uma imagem n√£o faz muito sentido. <br><br><h3>  <font color="#3AC1EF">¬ß 2</font>  <font color="#3AC1EF">Use o processo de montagem de imagens em v√°rios est√°gios</font> </h3><br>  Considere o exemplo quando coletamos um projeto para uma determinada organiza√ß√£o.  Este projeto usa muitos pacotes npm, e cada um desses pacotes pode instalar pacotes adicionais dos quais depende.  A realiza√ß√£o de todas essas opera√ß√µes leva a um tempo adicional gasto no processo de montagem da imagem (embora isso, gra√ßas aos recursos de cache do Docker, n√£o seja t√£o importante).  Pior, a imagem resultante que cont√©m as depend√™ncias de um determinado projeto √© bastante grande.  Aqui, se estamos falando de projetos front-end, podemos lembrar que esses projetos geralmente s√£o processados ‚Äã‚Äãusando empacotadores como o webpack, o que torna poss√≠vel compactar convenientemente tudo o que um aplicativo precisa em um pacote de vendas.  Como resultado, os arquivos do pacote npm para esse projeto s√£o desnecess√°rios.  E isso significa que podemos nos livrar desses arquivos depois de criar o projeto usando o mesmo webpack. <br><br>  Armado com essa id√©ia, tente fazer o seguinte: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   COPY package*.json ./ RUN npm install --production # - COPY . . RUN npm run build:production #    npm- RUN rm -rf node_modules</span></span></code> </pre> <br>  Essa abordagem, no entanto, n√£o nos conv√©m.  Como j√° dissemos, as instru√ß√µes <code>RUN</code> , <code>ADD</code> e <code>COPY</code> criam camadas armazenadas em cache pelo Docker, portanto, precisamos encontrar uma maneira de lidar com a instala√ß√£o de depend√™ncias, criar o projeto e excluir arquivos desnecess√°rios com um √∫nico comando.  Por exemplo, pode ser assim: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      COPY . . #  ,      RUN npm install --production &amp;&amp; npm run build:production &amp;&amp; rm -rf node_module</span></span></code> </pre> <br>  Neste exemplo, h√° apenas uma instru√ß√£o <code>RUN</code> que instala as depend√™ncias, <code>node_modules</code> projeto e exclui a pasta <code>node_modules</code> .  Isso leva ao fato de que o tamanho da imagem n√£o ser√° t√£o grande quanto o tamanho da imagem que inclui a pasta <code>node_modules</code> .  Usamos os arquivos desta pasta apenas durante o processo de compila√ß√£o do projeto e, em seguida, exclu√≠-lo.  √â verdade que essa abordagem √© ruim, pois leva muito tempo para instalar depend√™ncias do npm.  Voc√™ pode eliminar essa desvantagem usando a tecnologia de montagem de imagens em v√°rios est√°gios. <br><br>  Imagine que estamos trabalhando em um projeto de front-end com muitas depend√™ncias e usamos o webpack para compilar esse projeto.  Com essa abordagem, podemos, com o objetivo de reduzir o tamanho da imagem, tirar proveito dos recursos do Docker para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">montagem de imagens</a> em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">v√°rios est√°gios</a> . <br><br><pre> <code class="bash hljs">FROM node:8 As build <span class="hljs-comment"><span class="hljs-comment">#  RUN mkdir /app &amp;&amp; mkdir /src WORKDIR /src #   COPY package*.json ./ RUN npm install #     # RUN npm install --production #       COPY . . RUN npm run build:production #    ,     FROM node:alpine #      build   app COPY --from=build ./src/build/* /app/ ENTRYPOINT ["/app"] CMD ["--help"]</span></span></code> </pre> <br>  Com essa abordagem, a imagem resultante √© muito menor que a imagem anterior e tamb√©m usamos o <code>node:alpine</code> imagem <code>node:alpine</code> , que √© muito pequena.  E aqui est√° uma compara√ß√£o de um par de imagens, durante as quais fica claro que a imagem do <code>node:alpine</code> √© muito menor que a imagem do <code>node:8</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/565/c80/c3b/565c80c3bb0498e0ebcdf53022bdab6e.png"></div><br>  <i><font color="#999999">Comparando Imagens do Reposit√≥rio N√≥</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç3</font>  <font color="#3AC1EF">Usar cache do Docker</font> </h3><br>  Esforce-se para usar os recursos de cache do Docker para criar suas imagens.  J√° prestamos aten√ß√£o a esse recurso ao trabalhar com um arquivo que foi acessado pelo nome <code>package*.json</code> .  Isso reduz o tempo de cria√ß√£o da imagem.  Mas essa oportunidade n√£o deve ser usada precipitadamente. <br><br>  Suponha que descrevamos no Dockerfile a instala√ß√£o de pacotes em uma imagem criada a partir da imagem base do <code>Ubuntu:16.04</code> : <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update &amp;&amp; apt-get install -y \   curl \   package-1 \   .   .</code> </pre> <br>  Quando o sistema processa esse arquivo, se houver muitos pacotes instalados, as opera√ß√µes de atualiza√ß√£o e instala√ß√£o levar√£o muito tempo.  Para melhorar a situa√ß√£o, decidimos aproveitar os recursos de cache de camada do Docker e reescrever o Dockerfile da seguinte maneira: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update RUN apt-get install -y \   curl \   package-1 \   .   .</code> </pre> <br>  Agora, ao montar a imagem pela primeira vez, tudo corre como deveria, pois o cache ainda n√£o foi formado.  Imagine agora que precisamos instalar outro pacote, o <code>package-2</code> .  Para fazer isso, reescrevemos o arquivo: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update RUN apt-get install -y \   curl \   package-1 \   package-2 \   .   .</code> </pre> <br>  Como resultado desse comando, o <code>package-2</code> n√£o ser√° instalado ou atualizado.  Porque  O fato √© que, ao executar a instru√ß√£o <code>RUN apt-get update</code> , o Docker n√£o v√™ nenhuma diferen√ßa entre essa instru√ß√£o e a instru√ß√£o executada anteriormente, como resultado, obt√©m dados do cache.  E esses dados j√° est√£o desatualizados.  Ao processar a instru√ß√£o <code>RUN apt-get install</code> sistema a executa, pois n√£o se parece com uma instru√ß√£o semelhante no Dockerfile anterior, mas durante a instala√ß√£o, podem ocorrer erros ou a vers√£o antiga dos pacotes ser√° instalada.  Como resultado, verifica-se que os comandos de <code>update</code> e <code>install</code> devem ser executados na mesma instru√ß√£o <code>RUN</code> , como √© feito no primeiro exemplo.  O armazenamento em cache √© um √≥timo recurso, mas o uso imprudente desse recurso pode levar a problemas. <br><br><h3>  <font color="#3AC1EF">‚ñç4</font>  <font color="#3AC1EF">Minimize o n√∫mero de camadas de imagem</font> </h3><br>  Recomenda-se, sempre que poss√≠vel, minimizar o n√∫mero de camadas da imagem, pois cada camada √© o sistema de arquivos da imagem do Docker, o que significa que quanto menores as camadas da imagem, mais compacta ser√°.  Ao usar o processo de v√°rias etapas de montagem da imagem, √© obtida uma redu√ß√£o no n√∫mero de camadas na imagem e uma redu√ß√£o no tamanho da imagem. <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  Neste artigo, examinamos o processo de empacotamento de aplicativos Node.js em cont√™ineres do Docker e de trabalho com esses cont√™ineres.  Al√©m disso, fizemos algumas recomenda√ß√µes que, a prop√≥sito, podem ser usadas n√£o apenas ao criar cont√™ineres para projetos Node.js. <br><br>  <b>Caros leitores!</b>  Se voc√™ usa o Docker profissionalmente ao trabalhar com projetos Node.js., compartilhe recomenda√ß√µes sobre o uso efetivo deste sistema com iniciantes. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt440656/">https://habr.com/ru/post/pt440656/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt440646/index.html">Frontend Weekly Digest (11-17 fev 2019)</a></li>
<li><a href="../pt440648/index.html">Vis√£o geral da legisla√ß√£o russa no campo da acessibilidade da web</a></li>
<li><a href="../pt440650/index.html">Como funciona a consci√™ncia: conclus√µes do livro de Alexander Nevzorov</a></li>
<li><a href="../pt440652/index.html">V√≠deo computado em 755 megapixels: plen√≥pticos ontem, hoje e amanh√£</a></li>
<li><a href="../pt440654/index.html">Aprendendo Python: m√≥dulo argparse</a></li>
<li><a href="../pt440658/index.html">Explorando o Docker, parte 4: reduzindo o tamanho das imagens e acelerando sua montagem</a></li>
<li><a href="../pt440660/index.html">Docker de aprendizagem, parte 5: comandos</a></li>
<li><a href="../pt440662/index.html">Tutorial Reagir Parte 18: A sexta fase do trabalho em um aplicativo TODO</a></li>
<li><a href="../pt440666/index.html">Classifica√ß√£o de desenhos manuscritos. Relat√≥rio em Yandex</a></li>
<li><a href="../pt440670/index.html">O Banco Central publicou recomenda√ß√µes sobre a prote√ß√£o criptogr√°fica do EBS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>