<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👧‍👦 🍺 🚟 储层采样算法 😨 👨🏿‍✈️ 🌳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="储罐采样（英文简称“水库采样”）是一种简单有效的算法，可以预先从现有的大尺寸和/或未知尺寸的矢量中随机采样一定数量的元素。 我在Habré上未找到有关此算法的任何文章，因此决定自己编写。 

 所以，我们在说什么。 从向量中选择一个随机元素是一项基本任务： 



// C++ std::rando...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>储层采样算法</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/431652/"> 储罐采样（英文简称“水库采样”）是一种简单有效的算法，可以预先从现有的大尺寸和/或未知尺寸的矢量中随机采样一定数量的元素。 我在Habré上未找到有关此算法的任何文章，因此决定自己编写。 <br><br> 所以，我们在说什么。 从向量中选择一个随机元素是一项基本任务： <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// C++ std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution&lt;&gt; dis(0, vect.size() — 1); auto result = vect[dis(gen)];</span></span></code> </pre> <br>  “从大小为N的向量返回K个随机元素”的任务已经很棘手。 在这里，您可能已经犯了一个错误-例如，采用K个第一个元素（这违反了随机性的要求）或采用概率K / N采取每个元素（这违反了精确采用K个元素的要求）。 另外，可以实施形式上正确但极其无效的解决方案“将所有元素随机混合并先取K”。 如果我们添加以下条件：N是一个非常大的数字（我们没有足够的内存来保存所有N个元素），并且/或者事先未知，那么一切都会变得更加有趣。 例如，假设我们有某种外部服务可以一次向我们发送元素。 我们不知道其中有多少个元素，也无法全部保存，但是我们希望从任何时候收到的元素中随机选择K个元素。 <br><br> 储层采样算法使我们能够在O（N）步和O（K）内存中解决此问题。 在这种情况下，不需要预先知道N，并且将清楚地观察到精确地对K个元素进行随机采样的条件。 <br><a name="habracut"></a><br><h3> 让我们从一个简化的任务开始。 </h3><br> 令K = 1，即 我们只需要从所有传入元素中选择一个元素-但是每个传入元素都具有相同的被选择概率。 该算法建议自己： <br><br>  <b>步骤1</b> ：将内存分配到一个元素。 我们将第一个到达的元素保存在其中。 <br><br><img src="https://habrastorage.org/webt/po/q1/1h/poq11hywgfdu3n2y2_s-sdgpyds.png"><br><br> 到目前为止，一切都很好-只有一个元素出现了，现在应该选择100％的可能性-可以。 <br><br>  <b>步骤2</b> ：将第二个输入元素以1/2的概率重写为所选元素。 <br><br><img src="https://habrastorage.org/webt/hs/xf/7j/hsxf7jfqwem7j9hacgvlatwex-4.png"><br><br> 在这里，一切都很好：到目前为止，我们只有两个要素。 第一个仍以1/2的概率被选中，第二个以1/2的概率被重写。 <br><br>  <b>步骤3</b> ：将第三个概率为1/3的传入元素重写为所选元素。 <br><br><img src="https://habrastorage.org/webt/jy/hu/qw/jyhuqwvwlwaobwvo2_sn2r-sfbe.png"><br><br> 第三个元素一切都很好-选择它的机会恰好是1/3。 但是，我们是否以任何方式违反了先前因素的平等机会？ 不行 在此步骤中所选项目不会被覆盖的概率为1-1/3 = 2/3。 并且由于在第2步中我们保证要选择的每个元素的机会均等，因此在第3步之后可以选择每个元素的机会为2/3 * 1/2 = 1/3。 与第三个元素完全一样的机会。 <br><br>  <b>步骤N</b> ：以1 / N的概率，将元素编号N重写为所选择的元素编号。 之前到达的每个物品都有相同的1 / N机会被选中。 <br><br><img src="https://habrastorage.org/webt/dp/vz/xq/dpvzxqmpcdsrirqywjjasuosqy4.png"><br><br> 但这是一个简化的任务，K = 1。 <br><br><h3> 对于K&gt; 1，算法将如何变化？ </h3><br>  <b>步骤1</b> ：我们在K个元素上分配内存。 我们在其中写下第一个K元素到达。 <br><br><img src="https://habrastorage.org/webt/lp/nm/ga/lpnmgafmptirkhhjebrtsbfjwdc.png"><br><br> 从K个到达的元素中提取K个元素的唯一方法是将它们全部都带走:) <br><br>  <b>步骤N</b> ：（对于每个N&gt; K）：生成一个从1到N的随机数X。如果X&gt; K，则我们丢弃该元素并继续进行下一个操作。 如果X &lt;= K，则用数字X重写元素。由于X的值将在1到N的范围内均匀随机，因此在X &lt;= K的条件下，X的值将在1到K的范围内均匀随机。因此，我们确保了均匀性选择可擦写项目。 <br><br><img src="https://habrastorage.org/webt/i3/xv/u8/i3xvu8afqadw40t5kh5nrq_rcvw.png"><br><br> 如您所见，每个下一个出现的元素被选择的机会越来越少。 尽管如此，它始终将精确地为K / N（对于之前到达的每个元素）。 <br><br> 该算法的优点是我们可以随时停止，向用户显示当前向量K-它将是从到达的元素序列中诚实选择的随机元素的向量。 也许这将适合用户，或者他可能希望继续处理输入值-我们可以随时执行此操作。 如开头所述，在这种情况下，我们使用的内存永远不会超过O（K）。 <br><br> 哦，是的，我完全忘记了， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std :: sample</a>函数完全完成了上面描述的工作，最终包含在标准C ++ 17库中。 该标准不要求它仅使用储层采样，而是要按O（N）个步骤工作-很好，标准库中其实现的开发人员不太可能会选择使用比O（K）内存更多的算法（而且失败的也更少） -结果需要存储在某处）。 <br><br><h3> 相关资料 </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Facebook开发人员报告</a>了如何使用内部代码库在搜索引擎中使用油藏采样（从第34分钟开始）。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">维基百科文章</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std :: cppreference上的样本</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN431652/">https://habr.com/ru/post/zh-CN431652/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN431642/index.html">养蜂人与微控制器或错误的好处</a></li>
<li><a href="../zh-CN431644/index.html">与TM的直线。 v4.0</a></li>
<li><a href="../zh-CN431646/index.html">DataGrip 2018.3：支持Cassandra，从对象生成SQL文件，对自动完成功能进行了许多改进等</a></li>
<li><a href="../zh-CN431648/index.html">NB-IoT：它如何工作？ 第二部分</a></li>
<li><a href="../zh-CN431650/index.html">学习潜伏期：排队论</a></li>
<li><a href="../zh-CN431654/index.html">编程语言趋势2019</a></li>
<li><a href="../zh-CN431656/index.html">CraSSh：使用CSS计算打破所有现代浏览器</a></li>
<li><a href="../zh-CN431660/index.html">使用ECS的游戏功能：向射手添加急救箱</a></li>
<li><a href="../zh-CN431664/index.html">天线相位中心（FCA）及其在Ansys HFSS中的搜索</a></li>
<li><a href="../zh-CN431666/index.html">人工智能。 知识产权。 危险性</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>