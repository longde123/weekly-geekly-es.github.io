<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì∫ üç¥ üíÜüèΩ Aprenda o OpenGL. Li√ß√£o 7.1 - Depurando üíæ ü§≤üèΩ ‚õπüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A programa√ß√£o gr√°fica n√£o √© apenas uma fonte de divers√£o, mas tamb√©m de frustra√ß√£o quando algo n√£o √© exibido como pretendido, ou nada √© exibido na tel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprenda o OpenGL. Li√ß√£o 7.1 - Depurando</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462897/"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="imagem" align="left" width="300">  A programa√ß√£o gr√°fica n√£o √© apenas uma fonte de divers√£o, mas tamb√©m de frustra√ß√£o quando algo n√£o √© exibido como pretendido, ou nada √© exibido na tela.  Vendo que a maior parte do que fazemos est√° relacionada √† manipula√ß√£o de pixels, pode ser dif√≠cil descobrir a causa do erro quando algo n√£o funciona como deveria.  Depurar esse tipo de erro √© mais dif√≠cil do que erros na CPU.  N√£o temos um console no qual podemos produzir o texto, n√£o podemos colocar um ponto de interrup√ß√£o no sombreador e n√£o podemos apenas verificar e verificar o status do programa na GPU. </p><br><p>  Neste tutorial, apresentaremos alguns dos m√©todos e t√©cnicas de depura√ß√£o para o seu programa OpenGL.  Depurar no OpenGL n√£o √© t√£o dif√≠cil, e aprender alguns truques definitivamente valer√° a pena. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Conte√∫do</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Parte 1. Introdu√ß√£o</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cria√ß√£o de janela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ol√° janela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ol√° tri√¢ngulo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shaders</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Texturas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Transforma√ß√µes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sistemas de coordenadas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Camera</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 2. Ilumina√ß√£o b√°sica</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">No√ß√µes b√°sicas de ilumina√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Materiais</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapas de textura</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fontes de luz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V√°rias fontes de ilumina√ß√£o</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 3. Baixe modelos 3D</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classe de pol√≠gono de malha</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classe do modelo 3D</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 4. Recursos avan√ßados do OpenGL</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste de profundidade</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste de est√™ncil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mistura de cores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Faces de recorte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Buffer de quadros</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cart√µes c√∫bicos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Manipula√ß√£o avan√ßada de dados</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GLSL avan√ßado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shader geom√©trico</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Instanciamento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Suaviza√ß√£o</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 5. Ilumina√ß√£o Avan√ßada</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ilumina√ß√£o avan√ßada.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Blinn Fong Model</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Corre√ß√£o gama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cart√µes de sombra</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapas de sombra omnidirecionais</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeamento normal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeamento de paralaxe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Renderiza√ß√£o adiada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SSAO</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 6. PBR</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teoria</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fontes de luz anal√≠tica</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Irradia√ß√£o difusa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exposi√ß√£o especular</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 7. Pr√°tica</b> <div class="spoiler_text"><ol><li>  <b>Depura√ß√£o</b> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Renderiza√ß√£o de texto</a> </li></ol></div></div></div></div><br><h1 id="glgeterror">  glGetError () </h1><br><p> Quando voc√™ usa o OpenGL incorretamente (por exemplo, quando configura um buffer e esquece de vincul√°-lo), o OpenGL notar√° e criar√° um ou mais sinalizadores de erro personalizados nos bastidores.  Podemos rastrear esses erros chamando a fun√ß√£o <code>glGetError()</code> , que simplesmente verifica os sinalizadores de erro definidos e retorna o valor do erro se ocorrerem erros. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GLenum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glGetError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><p>  Esta fun√ß√£o retorna um sinalizador de erro ou nenhum erro.  Lista de valores de retorno: </p><br><div class="scrollable-table"><table><thead><tr><th>  Flag </th><th>  C√≥digo </th><th>  Descri√ß√£o do produto </th></tr></thead><tbody><tr><td> <code>GL_NO_ERROR</code> </td> <td>  0 0 </td><td>  Nenhum erro gerado desde a √∫ltima chamada glGetError </td></tr><tr><td> <code>GL_INVALID_ENUM</code> </td> <td>  1280 </td><td>  Definir quando um par√¢metro de enumera√ß√£o √© inv√°lido </td></tr><tr><td> <code>GL_INVALID_VALUE</code> </td> <td>  1281 </td><td>  Definir quando o valor √© inv√°lido </td></tr><tr><td> <code>GL_INVALID_OPERATION</code> </td> <td>  1282 </td><td>  Definir quando um comando com par√¢metros especificados √© inv√°lido </td></tr><tr><td> <code>GL_STACK_OVERFLOW</code> </td> <td>  1283 </td><td>  √â estabelecido quando a opera√ß√£o de enviar dados para a pilha (envio) causa um estouro de pilha. </td></tr><tr><td> <code>GL_STACK_UNDERFLOW</code> </td> <td>  1284 </td><td>  √â estabelecido quando a opera√ß√£o de popping de dados da pilha (pop) ocorre no menor ponto da pilha. </td></tr><tr><td> <code>GL_OUT_OF_MEMORY</code> </td> <td>  1285 </td><td>  Define quando uma opera√ß√£o de aloca√ß√£o de mem√≥ria n√£o pode alocar mem√≥ria suficiente. </td></tr><tr><td> <code>GL_INVALID_FRAMEBUFFER_OPERATION</code> </td> <td>  1286 </td><td>  Definir ao ler / gravar em / de um buffer de quadro que n√£o foi conclu√≠do </td></tr></tbody></table></div><br><p>  Dentro da documenta√ß√£o para fun√ß√µes OpenGL, voc√™ pode encontrar c√≥digos de erro gerados por fun√ß√µes usadas incorretamente.  Por exemplo, se voc√™ olhar para a documenta√ß√£o da fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>glBindTexture()</code></a> , poder√° encontrar os c√≥digos de erro gerados por essa fun√ß√£o na se√ß√£o Erros. <br>  Quando o sinalizador de erro √© definido, nenhum outro sinalizador de erro ser√° gerado.  Al√©m disso, quando <code>glGetError</code> √© chamado, a fun√ß√£o apaga todos os sinalizadores de erro (ou apenas um em um sistema distribu√≠do, veja abaixo).  Isso significa que, se voc√™ chamar <code>glGetError</code> uma vez ap√≥s cada quadro e receber um erro, isso n√£o significa que esse √© o √∫nico erro e voc√™ ainda n√£o sabe onde ocorreu esse erro. </p><br><blockquote>  Observe que, quando o OpenGL trabalha de maneira distribu√≠da, como geralmente ocorre em sistemas com X11, outros erros podem ser gerados enquanto eles t√™m c√≥digos diferentes.  Chamar <code>glGetError</code> simplesmente libera apenas um dos sinalizadores de c√≥digo de erro em vez de todos.  Por esse motivo, eles recomendam chamar essa fun√ß√£o em um loop. </blockquote><br><pre> <code class="cpp hljs">glBindTexture(GL_TEXTURE_2D, tex); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; glGetError() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  0 ( ) glTexImage2D(GL_TEXTURE_3D, 0, GL_RGB, 512, 512, 0, GL_RGB, GL_UNSIGNED_BYTE, data); std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  1280 ( ) glGenTextures(-5, textures); std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  1281 (  std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  0 ( )</span></span></code> </pre> <br><p>  Um recurso distintivo do <code>glGetError</code> √© que torna relativamente f√°cil determinar onde qualquer erro pode ocorrer e verificar se o OpenGL est√° sendo usado corretamente.  Digamos que voc√™ n√£o desenhe nada e n√£o saiba qual √© o motivo: o buffer de quadro foi configurado incorretamente?  Esqueceu de definir a textura?  Ao chamar <code>glGetError</code> em <code>glGetError</code> lugar, voc√™ pode descobrir rapidamente onde ocorre o primeiro erro. <br>  Por padr√£o, <code>glGetError</code> relata apenas o n√∫mero do erro, o que n√£o √© f√°cil de entender at√© que voc√™ memorize os n√∫meros de c√≥digo.  Geralmente, faz sentido escrever uma pequena fun√ß√£o para ajudar a imprimir uma sequ√™ncia de erros junto com o local de onde a fun√ß√£o √© chamada. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GLenum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glCheckError_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> line)</span></span></span><span class="hljs-function"> </span></span>{ GLenum errorCode; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((errorCode = glGetError()) != GL_NO_ERROR) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> error; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (errorCode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_ENUM: error = <span class="hljs-string"><span class="hljs-string">"INVALID_ENUM"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_VALUE: error = <span class="hljs-string"><span class="hljs-string">"INVALID_VALUE"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_OPERATION: error = <span class="hljs-string"><span class="hljs-string">"INVALID_OPERATION"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_STACK_OVERFLOW: error = <span class="hljs-string"><span class="hljs-string">"STACK_OVERFLOW"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_STACK_UNDERFLOW: error = <span class="hljs-string"><span class="hljs-string">"STACK_UNDERFLOW"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_OUT_OF_MEMORY: error = <span class="hljs-string"><span class="hljs-string">"OUT_OF_MEMORY"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_FRAMEBUFFER_OPERATION: error = <span class="hljs-string"><span class="hljs-string">"INVALID_FRAMEBUFFER_OPERATION"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; error &lt;&lt; <span class="hljs-string"><span class="hljs-string">" | "</span></span> &lt;&lt; file &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ("</span></span> &lt;&lt; line &lt;&lt; <span class="hljs-string"><span class="hljs-string">")"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorCode; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> glCheckError() glCheckError_(__FILE__, __LINE__)</span></span></code> </pre> <br><p>  Se voc√™ decidir fazer mais chamadas para <code>glCheckError</code> , ser√° √∫til saber onde ocorreu o erro. </p><br><pre> <code class="cpp hljs">glBindBuffer(GL_VERTEX_ARRAY, vbo); glCheckError();</code> </pre> <br><p>  Conclus√£o: </p><br><p><img src="https://habrastorage.org/webt/3h/yo/dn/3hyodngllw6-koljhvkkee3_lzi.png"><br>  Uma coisa importante permanece: h√° um bug de longa data no GLEW: <code>glewInit()</code> sempre define o sinalizador <code>GL_INVALID_ENUM</code> .  Para corrigir isso, basta chamar <code>glGetError</code> ap√≥s <code>glewInit</code> para limpar o sinalizador: </p><br><pre> <code class="cpp hljs">glewInit(); glGetError();</code> </pre> <br><p>  <code>glGetError</code> n√£o ajuda muito, pois as informa√ß√µes retornadas s√£o relativamente simples, mas geralmente ajudam a detectar erros de digita√ß√£o ou a localizar o local onde ocorreu o erro.  Esta √© uma ferramenta de depura√ß√£o simples, mas eficaz. </p><br><h1 id="otladochnyy-vyvod">  Sa√≠da de depura√ß√£o </h1><br><p>  A ferramenta √© menos conhecida, mas mais √∫til que o <code>glCheckError</code> , a extens√£o "debug output" do OpenGL, inclu√≠da no Perfil Principal do OpenGL 4.3.  Com esta extens√£o, o OpenGL enviar√° uma mensagem de erro ao usu√°rio com os detalhes do erro.  Essa extens√£o n√£o apenas fornece mais informa√ß√µes, mas tamb√©m permite detectar erros onde eles ocorrem usando o depurador. </p><br><blockquote>  A sa√≠da de depura√ß√£o est√° inclu√≠da no OpenGL a partir da vers√£o 4.3, o que significa que voc√™ encontrar√° essa funcionalidade em qualquer m√°quina que suporte o OpenGL 4.3 e superior.  Se esta vers√£o n√£o estiver dispon√≠vel, voc√™ poder√° verificar as extens√µes <code>ARB_debug_output</code> e <code>AMD_debug_output</code> .  Tamb√©m h√° informa√ß√µes n√£o verificadas de que a sa√≠da de depura√ß√£o n√£o √© suportada no OS X (o autor do original e o tradutor n√£o testaram, informe o autor do original ou a mim em mensagens privadas atrav√©s do mecanismo de corre√ß√£o de erros, se voc√™ encontrar confirma√ß√£o ou refuta√ß√£o desse fato; <strong>UPD:</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Jeka178RUS</a> verificou isso fato: fora da caixa, a sa√≠da de depura√ß√£o n√£o funciona, ele n√£o verificou as extens√µes). </blockquote><p>  Para come√ßar a usar a sa√≠da de depura√ß√£o, precisamos solicitar o contexto de depura√ß√£o do OpenGL durante o processo de inicializa√ß√£o.  Esse processo √© diferente em diferentes sistemas de janelas, mas aqui discutiremos apenas o GLFW, mas no final do artigo na se√ß√£o "Materiais adicionais" voc√™ pode encontrar informa√ß√µes sobre outros sistemas de janelas. </p><br><h4 id="otladochnyy-vyvod-v-glfw">  Sa√≠da de depura√ß√£o no GLFW </h4><br><p>  Solicitar contextos de depura√ß√£o no GLFW √© surpreendentemente simples: tudo o que voc√™ precisa fazer √© dar ao GLFW uma dica de que queremos um contexto que suporte a sa√≠da de depura√ß√£o.  Precisamos fazer isso antes de chamar <code>glfwCreateWindow</code> : </p><br><pre> <code class="cpp hljs">glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);</code> </pre> <br><p>  Assim que inicializamos o GLFW, devemos ter um contexto de depura√ß√£o se usarmos o OpenGL 4.3 ou superior; caso contr√°rio, precisamos tentar a sorte e esperar que o sistema ainda possa criar um contexto de depura√ß√£o.  Em caso de falha, precisamos solicitar a sa√≠da de depura√ß√£o por meio do mecanismo de extens√£o OpenGL. </p><br><blockquote>  O contexto de depura√ß√£o do OpenGL pode ser mais lento que o normal, portanto, voc√™ deve remover ou comentar esta linha enquanto trabalha em otimiza√ß√µes ou antes do lan√ßamento. </blockquote><p>  Para verificar o resultado da inicializa√ß√£o do contexto de depura√ß√£o, basta executar o seguinte c√≥digo: </p><br><pre> <code class="cpp hljs">GLint flags; glGetIntegerv(GL_CONTEXT_FLAGS, &amp;flags); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flags &amp; GL_CONTEXT_FLAG_DEBUG_BIT) { <span class="hljs-comment"><span class="hljs-comment">//  } else { //   }</span></span></code> </pre> <br><p>  Como funciona a sa√≠da de depura√ß√£o?  Passamos uma fun√ß√£o de retorno de chamada para um manipulador de mensagens no OpenGL (semelhante aos retornos de chamada no GLFW) e nessa fun√ß√£o podemos processar os dados do OpenGL como desejamos, enviando mensagens de erro √∫teis para o console.  O prot√≥tipo desta fun√ß√£o: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glDebugOutput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GLchar *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *userParam)</span></span></span></span>;</code> </pre> <br><p>  Observe que em alguns sistemas operacionais o tipo do √∫ltimo par√¢metro pode ser <code>const void*</code> . <br>  Dado o grande conjunto de dados que possu√≠mos, podemos criar uma ferramenta √∫til de impress√£o de erros, como mostrado abaixo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glDebugOutput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GLchar *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *userParam)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ignore non-significant error/warning codes if(id == 131169 || id == 131185 || id == 131218 || id == 131204) return; std::cout &lt;&lt; "---------------" &lt;&lt; std::endl; std::cout &lt;&lt; "Debug message (" &lt;&lt; id &lt;&lt; "): " &lt;&lt; message &lt;&lt; std::endl; switch (source) { case GL_DEBUG_SOURCE_API: std::cout &lt;&lt; "Source: API"; break; case GL_DEBUG_SOURCE_WINDOW_SYSTEM: std::cout &lt;&lt; "Source: Window System"; break; case GL_DEBUG_SOURCE_SHADER_COMPILER: std::cout &lt;&lt; "Source: Shader Compiler"; break; case GL_DEBUG_SOURCE_THIRD_PARTY: std::cout &lt;&lt; "Source: Third Party"; break; case GL_DEBUG_SOURCE_APPLICATION: std::cout &lt;&lt; "Source: Application"; break; case GL_DEBUG_SOURCE_OTHER: std::cout &lt;&lt; "Source: Other"; break; } std::cout &lt;&lt; std::endl; switch (type) { case GL_DEBUG_TYPE_ERROR: std::cout &lt;&lt; "Type: Error"; break; case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: std::cout &lt;&lt; "Type: Deprecated Behaviour"; break; case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: std::cout &lt;&lt; "Type: Undefined Behaviour"; break; case GL_DEBUG_TYPE_PORTABILITY: std::cout &lt;&lt; "Type: Portability"; break; case GL_DEBUG_TYPE_PERFORMANCE: std::cout &lt;&lt; "Type: Performance"; break; case GL_DEBUG_TYPE_MARKER: std::cout &lt;&lt; "Type: Marker"; break; case GL_DEBUG_TYPE_PUSH_GROUP: std::cout &lt;&lt; "Type: Push Group"; break; case GL_DEBUG_TYPE_POP_GROUP: std::cout &lt;&lt; "Type: Pop Group"; break; case GL_DEBUG_TYPE_OTHER: std::cout &lt;&lt; "Type: Other"; break; } std::cout &lt;&lt; std::endl; switch (severity) { case GL_DEBUG_SEVERITY_HIGH: std::cout &lt;&lt; "Severity: high"; break; case GL_DEBUG_SEVERITY_MEDIUM: std::cout &lt;&lt; "Severity: medium"; break; case GL_DEBUG_SEVERITY_LOW: std::cout &lt;&lt; "Severity: low"; break; case GL_DEBUG_SEVERITY_NOTIFICATION: std::cout &lt;&lt; "Severity: notification"; break; } std::cout &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; }</span></span></code> </pre> <br><p>  Quando a extens√£o detecta um erro do OpenGL, ela chama essa fun√ß√£o e podemos imprimir uma quantidade enorme de informa√ß√µes de erro.  Observe que ignoramos alguns erros, pois eles s√£o in√∫teis (por exemplo, 131185 nos drivers da NVidia indica que o buffer foi criado com sucesso). <br>  Agora que temos o retorno de chamada desejado, √© hora de inicializar a sa√≠da de depura√ß√£o: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flags &amp; GL_CONTEXT_FLAG_DEBUG_BIT) { glEnable(GL_DEBUG_OUTPUT); glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS); glDebugMessageCallback(glDebugOutput, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_TRUE); }</code> </pre> <br><p>  Ent√£o, dizemos ao OpenGL que queremos ativar a sa√≠da de depura√ß√£o.  A chamada para <code>glEnable(GL_DEBUG_SYNCRHONOUS)</code> informa ao OpenGL que queremos uma mensagem de erro quando isso aconteceu. </p><br><h4 id="filtraciya-otladochnogo-vyvoda">  Filtragem de sa√≠da de depura√ß√£o </h4><br><p>  Com a fun√ß√£o <code>glDebugMessageControl</code> voc√™ pode selecionar os tipos de erros que deseja receber.  No nosso caso, temos todos os tipos de erros.  Se desej√°ssemos apenas os erros da API do OpenGL, como Erro e o n√≠vel de signific√¢ncia Alto, escrever√≠amos o seguinte c√≥digo: </p><br><pre> <code class="cpp hljs">glDebugMessageControl(GL_DEBUG_SOURCE_API, GL_DEBUG_TYPE_ERROR, GL_DEBUG_SEVERITY_HIGH, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_TRUE);</code> </pre> <br><p>  Com esse contexto de configura√ß√£o e depura√ß√£o, todo comando incorreto do OpenGL envia muitas informa√ß√µes √∫teis: </p><br><p><img src="https://habrastorage.org/webt/4r/su/ir/4rsuirzossc_jpcoldwi-t4s0ny.png"></p><br><h4 id="nahodim-istochnik-oshibki-cherez-stek-vyzovov">  Encontre a origem do erro atrav√©s da pilha de chamadas </h4><br><p>  Outro truque com a sa√≠da de depura√ß√£o √© que voc√™ pode estabelecer com relativa facilidade o local exato do erro no seu c√≥digo.  Ao definir um ponto de interrup√ß√£o na fun√ß√£o <code>DebugOutput</code> no tipo de erro desejado (ou no in√≠cio da fun√ß√£o, se voc√™ deseja capturar todos os erros), o depurador detectar√° o erro e voc√™ poder√° navegar na pilha de chamadas para descobrir onde ocorreu o erro: </p><br><p><img src="https://habrastorage.org/webt/fw/sm/0s/fwsm0sr9tzjyl36kg0maj_rthz0.png"><br>  Isso requer alguma interven√ß√£o manual, mas se voc√™ souber aproximadamente o que est√° procurando, √© incrivelmente √∫til determinar rapidamente qual chamada est√° causando o erro. </p><br><h4 id="svoi-oshibki">  Erros pr√≥prios </h4><br><p>  Juntamente com os erros de leitura, podemos envi√°-los ao sistema de sa√≠da de depura√ß√£o usando <code>glDebugMessageInsert</code> : </p><br><pre> <code class="cpp hljs">glDebugMessageInsert(GL_DEBUG_SOURCE_APPLICATION, GL_DEBUG_TYPE_ERROR, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_DEBUG_SEVERITY_MEDIUM, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-string"><span class="hljs-string">"error message here"</span></span>);</code> </pre> <br><p>  Isso √© muito √∫til se voc√™ estiver se conectando a outro aplicativo ou c√≥digo OpenGL que usa um contexto de depura√ß√£o.  Outros desenvolvedores poder√£o descobrir rapidamente qualquer erro relatado que ocorra no seu c√≥digo OpenGL personalizado. <br>  Em geral, a sa√≠da de depura√ß√£o (se dispon√≠vel) √© muito √∫til para detectar erros rapidamente e definitivamente vale o esfor√ßo gasto no ajuste, pois economiza um tempo de desenvolvimento significativo.  Voc√™ pode encontrar uma c√≥pia do c√≥digo fonte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> usando <code>glGetError</code> e sa√≠da de depura√ß√£o.  Existem erros, tente corrigi-los. </p><br><h1 id="otladochnyy-vyvod-sheydera">  Sa√≠da de depura√ß√£o do shader </h1><br><p>  Quando se trata de GLSL, n√£o temos acesso a fun√ß√µes como <code>glGetError</code> ou a capacidade de percorrer o c√≥digo em etapas no depurador.  Quando voc√™ encontra uma tela preta ou uma exibi√ß√£o completamente incorreta, pode ser muito dif√≠cil entender o que acontece se o problema estiver no sombreador.  Sim, erros de compila√ß√£o relatam erros de sintaxe, mas capturar erros sem√¢nticos √© essa m√∫sica. <br>  Um dos m√©todos mais usados ‚Äã‚Äãpara descobrir o que h√° de errado com um sombreador √© enviar todas as vari√°veis ‚Äã‚Äãrelevantes no programa de sombreador diretamente para o canal de sa√≠da do sombreador de fragmento.  Ao enviar vari√°veis ‚Äã‚Äãde sombreador diretamente para o canal de sa√≠da com cores, podemos encontrar informa√ß√µes interessantes verificando a imagem na sa√≠da.  Por exemplo, precisamos descobrir se as normais est√£o corretas para o modelo.  Podemos envi√°-los (transformados ou n√£o) do v√©rtice para o sombreador de fragmentos, onde derivamos os normais mais ou menos assim: <br>  (note lane: por que n√£o h√° destaque de sintaxe para GLSL?) </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec3 Normal; [...] void main() { [...] FragColor.rgb = Normal; FragColor.a = 1.0f; }</span></span></code> </pre> <br><p>  Ao enviar uma vari√°vel que n√£o seja de cor para o canal de sa√≠da com a cor como est√° agora, podemos verificar rapidamente o valor da vari√°vel.  Se, por exemplo, o resultado for uma tela preta, √© evidente que as normais s√£o transferidas incorretamente para os shaders e, quando exibidas, √© relativamente f√°cil verificar se est√£o corretas: </p><br><p><img src="https://habrastorage.org/webt/ga/5c/eq/ga5ceqfkwfcszqm75y6szggge-e.png"></p><br><p>  A partir dos resultados visuais, podemos ver que os normais est√£o corretos, pois o lado direito do traje √© predominantemente vermelho (o que significa que os normais aparecem aproximadamente na dire√ß√£o do eixo x de enx√°g√ºe) e tamb√©m a frente do traje √© colorida na dire√ß√£o do eixo z positivo (azul). </p><br><p>  Essa abordagem pode ser estendida a qualquer vari√°vel que voc√™ deseja testar.  Toda vez que voc√™ ficar preso e presumir que o erro est√° nos shaders, tente desenhar algumas vari√°veis ‚Äã‚Äãou resultados intermedi√°rios e descubra em qual parte do algoritmo h√° um erro. </p><br><h1 id="opengl-glsl-reference-compiler">  Compilador de refer√™ncia OpenGL GLSL </h1><br><p>  Cada driver de v√≠deo tem suas pr√≥prias peculiaridades.  Por exemplo, os drivers da NVIDIA suavizam levemente os requisitos da especifica√ß√£o, e os drivers da AMD atendem melhor √†s especifica√ß√µes (o que √© melhor, eu acho).  O problema √© que os shaders executados em uma m√°quina podem n√£o ganhar dinheiro com outra por causa das diferen√ßas nos drivers. </p><br><p>  Por v√°rios anos de experi√™ncia, voc√™ pode aprender todas as diferen√ßas entre diferentes GPUs, mas se quiser ter certeza de que seus sombreadores funcionar√£o em todos os lugares, poder√° verificar seu c√≥digo com a especifica√ß√£o oficial usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">compilador de refer√™ncia GLSL</a> .  Voc√™ pode fazer o download do chamado <em>validador GLSL lang</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fonte</a> ). </p><br><p>  Com este programa, voc√™ pode testar seus shaders passando-os como o primeiro argumento para o programa.  Lembre-se de que o programa determina o tipo de sombreador por extens√£o: </p><br><ul><li>  <code>.vert</code> : vertex shader </li><li>  <code>.frag</code> : fragment shader </li><li>  <code>.geom</code> : shader geom√©trico </li><li>  <code>.tesc</code> : shader de controle de mosaico </li><li>  <code>.tese</code> : sombreador de computa√ß√£o em mosaico </li><li>  <code>.comp</code> : sombreador de computa√ß√£o </li></ul><br><p>  A execu√ß√£o do programa √© f√°cil: </p><br><pre> <code class="bash hljs">glslangValidator shader.vert</code> </pre> <br><p>  Observe que, se n√£o houver erros, o programa n√£o produzir√° nada.  Em um shader de v√©rtice quebrado, a sa√≠da ser√° semelhante a: </p><br><p><img src="https://habrastorage.org/webt/-l/x-/yi/-lx-yijcoqk4ehnnc5xentnjl5m.png"></p><br><p>  O programa n√£o mostrar√° as diferen√ßas entre os compiladores GLSL da AMD, NVidia ou Intel, e nem sequer pode relatar todos os erros no shader, mas pelo menos verifica os shaders quanto √† conformidade com os padr√µes. </p><br><h1 id="vyvod-bufera-kadra">  Sa√≠da do buffer de quadro </h1><br><p>  Outro m√©todo para o seu kit de ferramentas √© exibir o conte√∫do do buffer de quadros em uma parte espec√≠fica da tela.  Provavelmente, voc√™ costuma usar buffers de quadros e, como toda a m√°gica acontece nos bastidores, pode ser dif√≠cil determinar o que est√° acontecendo.  A sa√≠da do conte√∫do do buffer de quadros √© um truque √∫til para verificar se as coisas est√£o corretas. </p><br><blockquote>  Observe que o conte√∫do do buffer de quadros, conforme explicado aqui, funciona com texturas, n√£o com objetos nos buffers de desenho </blockquote><p>  Usando um sombreador simples que desenha uma √∫nica textura, podemos escrever uma pequena fun√ß√£o que desenha rapidamente qualquer textura no canto superior direito da tela: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// vertex shader #version 330 core layout (location = 0) in vec2 position; layout (location = 1) in vec2 texCoords; out vec2 TexCoords; void main() { gl_Position = vec4(position, 0.0f, 1.0f); TexCoords = texCoords; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//fragment shader #version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D fboAttachment; void main() { FragColor = texture(fboAttachment, TexCoords); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//main.cpp void DisplayFramebufferTexture(GLuint textureID) { if(!notInitialized) { // initialize shader and vao w/ NDC vertex coordinates at top-right of the screen [...] } glActiveTexture(GL_TEXTURE0); glUseProgram(shaderDisplayFBOOutput); glBindTexture(GL_TEXTURE_2D, textureID); glBindVertexArray(vaoDebugTexturedRect); glDrawArrays(GL_TRIANGLES, 0, 6); glBindVertexArray(0); glUseProgram(0); } int main() { [...] while (!glfwWindowShouldClose(window)) { [...] DisplayFramebufferTexture(fboAttachment0); glfwSwapBuffers(window); } }</span></span></code> </pre> <br><p>  Isso fornecer√° uma pequena janela no canto da tela para depurar a sa√≠da do buffer do quadro.  √â √∫til, por exemplo, quando voc√™ tenta verificar a corre√ß√£o dos normais: </p><br><p><img src="https://habrastorage.org/webt/zi/uw/ap/ziuwapmnertjaocm6cexhv8q5c8.png"></p><br><p>  Voc√™ tamb√©m pode expandir esta fun√ß√£o para renderizar mais de 1 textura.  Essa √© uma maneira r√°pida de obter feedback cont√≠nuo de qualquer coisa nos buffers de quadro. </p><br><h1 id="vneshnie-programmy-otladchiki">  Programas de depurador externo </h1><br><p>  Quando tudo mais falha, h√° mais um truque: usar programas de terceiros.  Eles est√£o embutidos no driver OpenGL e podem interceptar todas as chamadas OpenGL para fornecer muitos dados interessantes sobre o seu aplicativo.  Esses aplicativos podem criar um perfil do uso das fun√ß√µes do OpenGL, procurar gargalos e monitorar buffers de quadro, texturas e mem√≥ria.  Ao trabalhar com c√≥digo (grande), essas ferramentas podem se tornar inestim√°veis. </p><br><p>  Eu listei v√°rias ferramentas populares.  Experimente cada um e escolha o que melhor lhe convier. </p><br><h4 id="renderdoc">  Renderderoc </h4><br><p>  O RenderDoc √© uma boa ferramenta de depura√ß√£o separada (totalmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aberta</a> ).  Para iniciar a captura, selecione o arquivo execut√°vel e o diret√≥rio de trabalho.  Seu aplicativo funciona normalmente e, quando voc√™ deseja assistir a um √∫nico quadro, permite que o RenderDoc capture v√°rios quadros do seu aplicativo.  Entre os quadros capturados, √© poss√≠vel visualizar o status do pipeline, todos os comandos do OpenGL, armazenamento em buffer e texturas usadas. </p><br><p><img src="https://habrastorage.org/webt/oe/wj/zn/oewjznqytsjpfi6jbordzvph_ym.png"></p><br><h4 id="codexl">  Codexl </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A</a> ferramenta de depura√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CodeXL</a> - GPU, funciona como um aplicativo e plug-in aut√¥nomo para o Visual Studio.  CodeXL Fornece muitas informa√ß√µes e √© √≥timo para criar perfis de aplicativos gr√°ficos.  O CodeXL tamb√©m roda em placas gr√°ficas da NVidia e Intel, mas sem o suporte √† depura√ß√£o OpenCL. </p><br><p><img src="https://habrastorage.org/webt/zk/ap/jw/zkapjwplwxnqm5z65qchaxdjd34.png"></p><br><p>  N√£o usei muito o CodeXL, porque o RenderDoc parecia mais f√°cil para mim, mas inclu√≠ o CodeXL nesta lista porque ela parece uma ferramenta bastante confi√°vel e √© desenvolvida principalmente por um dos maiores fabricantes de GPUs. </p><br><h4 id="nvidia-nsight">  NVIDIA Nsight </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Nsight</a> √© uma ferramenta popular de depura√ß√£o da GPU <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NUIDIA</a> .  N√£o √© apenas um plug-in para o Visual Studio e Eclipse, mas tamb√©m um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aplicativo separado</a> .  O plugin Nsight √© uma coisa muito √∫til para desenvolvedores gr√°ficos, pois coleta muitas estat√≠sticas em tempo real sobre o uso da GPU e o estado quadro a quadro da GPU. </p><br><p>  No momento em que voc√™ iniciar seu aplicativo atrav√©s do Visual Studio ou Eclipse usando os comandos debug ou a cria√ß√£o de perfil do Nsight, ele ser√° iniciado dentro do pr√≥prio aplicativo.  Uma coisa boa no Nsight: renderizar um sistema de GUI (GUI, interface gr√°fica do usu√°rio) sobre um aplicativo em execu√ß√£o que voc√™ pode usar para coletar todos os tipos de informa√ß√µes sobre seu aplicativo em tempo real ou an√°lise quadro a quadro. </p><br><p><img src="https://habrastorage.org/webt/rx/1m/al/rx1malqwzriz6lhd8oxquerturu.png"></p><br><p>  O Nsight √© uma ferramenta muito √∫til, que, na minha opini√£o, ultrapassa as ferramentas acima, mas tem uma s√©ria desvantagem: funciona <em>apenas</em> nas placas gr√°ficas NVIDIA.  Se voc√™ estiver usando placas gr√°ficas NVIDIA e Visual Studio, vale a pena tentar o Nsight. </p><br><p>  ,         ( , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VOGL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">APItrace</a> ),   ,          .      ,     ,    ()          (  ,     ). </p><br><h1 id="dopolnitelnye-materialy">   </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">    ?</a> ‚Äî           Reto Koradi. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=http://web.archive.org/web/20150225171555/"> </a> ‚Äî            Vallentin Source. </li></ul><br><p> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Temos um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">telegrama conf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para coordena√ß√£o de transfer√™ncias. </font><font style="vertical-align: inherit;">Se voc√™ tem um desejo s√©rio de ajudar com a tradu√ß√£o, √© bem-vindo!</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt462897/">https://habr.com/ru/post/pt462897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt462885/index.html">Rede IPoE tolerante a falhas em m√£os</a></li>
<li><a href="../pt462887/index.html">A experi√™ncia de personalizar uma loja online usando o exemplo de uma recomenda√ß√£o din√¢mica</a></li>
<li><a href="../pt462889/index.html">Hist√≥ria da continua√ß√£o: Compilador de Pascal para Windows a partir do zero</a></li>
<li><a href="../pt462893/index.html">Reconhecimento facial nas cidades: seguran√ßa versus privacidade</a></li>
<li><a href="../pt462895/index.html">Resolvendo um trabalho com pwnable.kr 17 - memcpy. Alinhamento de dados</a></li>
<li><a href="../pt462903/index.html">Como projetamos e implementamos a nova rede na Huawei no escrit√≥rio de Moscou, parte 3: f√°brica de servidores</a></li>
<li><a href="../pt462905/index.html">Escrevendo um bot de telegrama em python usando a biblioteca de telebot parte 2</a></li>
<li><a href="../pt462907/index.html">ngFanatic semanalmente</a></li>
<li><a href="../pt462909/index.html">Os frutos da evolu√ß√£o do ASIC: sobre fabricantes, mineradores de SHA-256 e as esquisitices do hashrate astron√¥mico</a></li>
<li><a href="../pt462911/index.html">Um ano ao volante de um carro el√©trico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>