<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ½â€ğŸ¤â€ğŸ‘©ğŸ¼ ğŸ‘¼ğŸ¿ ğŸ‘ŒğŸ» Jenis Referensi .NET vs Jenis Nilai. Bagian 1 ğŸŒ± ğŸ¤›ğŸ¼ ğŸ¹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pertama, mari kita bicara tentang Jenis Referensi dan Jenis Nilai. Saya pikir orang tidak benar-benar memahami perbedaan dan manfaat keduanya. Mereka ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jenis Referensi .NET vs Jenis Nilai. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/439486/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a>  Pertama, mari kita bicara tentang Jenis Referensi dan Jenis Nilai.  Saya pikir orang tidak benar-benar memahami perbedaan dan manfaat keduanya.  Mereka biasanya mengatakan tipe referensi menyimpan konten di heap dan tipe nilai menyimpan konten di stack, yang salah. </p><br><p>  Mari kita bahas perbedaan nyata: </p><br><ul><li>  <em>Tipe nilai</em> : nilainya adalah <strong>seluruh struktur</strong> .  Nilai tipe referensi adalah <strong>referensi</strong> ke objek.  - Struktur dalam memori: tipe nilai hanya berisi data yang Anda indikasikan.  Jenis referensi juga mengandung dua bidang sistem.  Yang pertama menyimpan 'SyncBlockIndex', yang kedua menyimpan informasi tentang jenis, termasuk informasi tentang Tabel Metode Virtual (VMT). </li><li>  Tipe referensi dapat memiliki metode yang diganti ketika diwariskan.  Jenis nilai tidak dapat diwarisi. </li><li>  Anda harus mengalokasikan ruang pada tumpukan untuk contoh tipe referensi.  Jenis nilai <em>dapat</em> dialokasikan pada tumpukan, atau itu menjadi bagian dari jenis referensi.  Ini cukup meningkatkan kinerja beberapa algoritma. </li></ul><br><p>  Namun, ada fitur umum: </p><br><ul><li>  Kedua subclass dapat mewarisi tipe objek dan menjadi perwakilannya. </li></ul><br><p>  Mari kita perhatikan lebih dekat setiap fitur. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Bab ini diterjemahkan dari bahasa Rusia bersama oleh penulis dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerjemah profesional</a> .  Anda dapat membantu kami dengan terjemahan dari bahasa Rusia atau Inggris ke bahasa lain, terutama ke bahasa Cina atau Jerman. <br><br>  Juga, jika Anda ingin berterima kasih kepada kami, cara terbaik yang dapat Anda lakukan adalah memberi kami bintang di github atau untuk repositori garpu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/z0/iq/m6/z0iqm6nihoilvykxs3el7zujlrk.jpeg"></a> </p><a name="habracut"></a><br><p>  Mari kita perhatikan lebih dekat setiap fitur. </p><br><h2 id="copying">  Menyalin </h2><br><p>  Perbedaan utama antara kedua jenis adalah sebagai berikut: </p><br><ul><li>  Setiap variabel, kelas atau bidang struktur atau parameter metode yang mengambil tipe referensi menyimpan <strong>referensi</strong> ke nilai; </li><li>  Tetapi setiap variabel, kelas atau bidang struktur atau parameter metode yang mengambil tipe nilai menyimpan nilai dengan tepat, yaitu seluruh struktur. </li></ul><br><p>  Ini berarti bahwa menetapkan atau meneruskan parameter ke suatu metode akan menyalin nilainya.  Bahkan jika Anda mengubah salinannya, dokumen asli akan tetap sama.  Namun, jika Anda mengubah bidang jenis referensi, ini akan "mempengaruhi" semua bagian dengan referensi ke turunan jenis.  Mari kita lihat <br>  contoh: </p><br><pre><code class="cs hljs">DateTime dt = DateTime.Now; <span class="hljs-comment"><span class="hljs-comment">// Here, we allocate space for DateTime variable when calling a method, // but it will contain zeros. Next, let's copy all // values of the Now property to dt variable DateTime dt2 = dt; // Here, we copy the value once again object obj = new object(); // Here, we create an object by allocating memory on the Small Object Heap, // and put a pointer to the object in obj variable object obj2 = obj; // Here, we copy a reference to this object. Finally, // we have one object and two references.</span></span></code> </pre> <br><p>  Tampaknya properti ini menghasilkan konstruksi kode ambigu seperti <br>  perubahan kode dalam koleksi: </p><br><pre> <code class="plaintext hljs">// Let's declare a structure struct ValueHolder { public int Data; } // Let's create an array of such structures and initialize the Data field = 5 var array = new [] { new ValueHolder { Data = 5 } }; // Let's use an index to get the structure and put 4 in the Data field array[0].Data = 4; // Let's check the value Console.WriteLine(array[0].Data);</code> </pre> <br><p>  Ada trik kecil dalam kode ini.  Sepertinya kita mendapatkan instance struktur terlebih dahulu, dan kemudian menetapkan nilai baru ke bidang Data dari salinan.  Ini berarti kita harus mendapatkan <code>5</code> lagi ketika memeriksa nilainya.  Namun, ini tidak terjadi.  MSIL memiliki instruksi terpisah untuk mengatur nilai bidang dalam struktur array, yang meningkatkan kinerja.  Kode akan berfungsi sebagaimana dimaksud: program akan melakukannya <br>  output <code>4</code> ke konsol. </p><br><p>  Mari kita lihat apa yang akan terjadi jika kita mengubah kode ini: </p><br><pre> <code class="plaintext hljs">// Let's declare a structure struct ValueHolder { public int Data; } // Let's create a list of such structures and initialize the Data field = 5 var list = new List&lt;ValueHolder&gt; { new ValueHolder { Data = 5 } }; // Let's use an index to get the structure and put 4 in the Data field list[0].Data = 4; // Let's check the value Console.WriteLine(list[0].Data);</code> </pre> <br><p>  Kompilasi kode ini akan gagal, karena ketika Anda menulis <code>list[0].Data = 4</code> Anda mendapatkan salinan struktur terlebih dahulu.  Bahkan, Anda memanggil metode instance dari tipe <code>List&lt;T&gt;</code> yang mendasari akses oleh indeks.  Dibutuhkan salinan struktur dari array internal ( <code>List&lt;T&gt;</code> menyimpan data dalam array) dan mengembalikan salinan ini kepada Anda dari metode akses menggunakan indeks.  Selanjutnya, Anda mencoba untuk memodifikasi salinan, yang tidak digunakan lebih jauh.  Kode ini tidak ada gunanya.  Kompiler melarang perilaku seperti itu, mengetahui bahwa orang menyalahgunakan tipe nilai.  Kita harus menulis ulang contoh ini dengan cara berikut: </p><br><pre> <code class="plaintext hljs">// Let's declare a structure struct ValueHolder { public int Data; } // Let's create a list of such structures and initialize the Data field = 5 var list = new List&lt;ValueHolder&gt; { new ValueHolder { Data = 5 } }; // Let's use an index to get the structure and put 4 in the Data field. Then, let's save it again. var copy = list[0]; copy.Data = 4; list[0] = copy; // Let's check the value Console.WriteLine(list[0].Data);</code> </pre> <br><p>  Kode ini benar meskipun tampak berlebihan.  Program akan melakukannya <br>  output <code>4</code> ke konsol. </p><br><p>  Contoh berikutnya menunjukkan apa yang saya maksud dengan â€œnilai struktur adalah <br>  seluruh struktur â€ </p><br><pre> <code class="plaintext hljs">// Variant 1 struct PersonInfo { public int Height; public int Width; public int HairColor; } int x = 5; PersonInfo person; int y = 6; // Variant 2 int x = 5; int Height; int Width; int HairColor; int y = 6;</code> </pre> <br><p>  Kedua contoh serupa dalam hal lokasi data dalam memori, karena nilai struktur adalah seluruh struktur.  Ini mengalokasikan memori untuk dirinya sendiri di mana ia berada. </p><br><pre> <code class="plaintext hljs">// Variant 1 struct PersonInfo { public int Height; public int Width; public int HairColor; } class Employee { public int x; public PersonInfo person; public int y; } // Variant 2 class Employee { public int x; public int Height; public int Width; public int HairColor; public int y; }</code> </pre> <br><p>  Contoh-contoh ini juga serupa dalam hal lokasi elemen dalam memori karena struktur mengambil tempat yang ditentukan di antara bidang kelas.  Saya tidak mengatakan mereka sangat mirip karena Anda dapat mengoperasikan bidang struktur menggunakan metode struktur. </p><br><p>  Tentu saja, ini bukan jenis referensi.  Sebuah instance itu sendiri adalah pada Small Object Heap (SOH) yang tidak terjangkau atau Large Object Heap (LOH).  Bidang kelas hanya berisi nilai pointer ke instance: angka 32 atau 64-bit. </p><br><p>  Mari kita lihat contoh terakhir untuk menutup masalah ini. </p><br><pre> <code class="plaintext hljs">// Variant 1 struct PersonInfo { public int Height; public int Width; public int HairColor; } void Method(int x, PersonInfo person, int y); // Variant 2 void Method(int x, int HairColor, int Width, int Height, int y);</code> </pre> <br><p>  Dalam hal memori kedua varian kode akan bekerja dengan cara yang sama, tetapi tidak dalam hal arsitektur.  Ini bukan hanya penggantian sejumlah variabel argumen.  Urutan berubah karena parameter metode dideklarasikan satu demi satu.  Mereka diletakkan di tumpukan dengan cara yang sama. </p><br><p>  Namun, tumpukan tumbuh dari alamat yang lebih tinggi ke yang lebih rendah.  Itu berarti urutan mendorong sepotong demi sepotong struktur akan berbeda dari mendorongnya secara keseluruhan. </p><br><h2 id="overridable-methods-and-inheritance">  Metode dan warisan yang dapat ditimpa </h2><br><p>  Perbedaan besar berikutnya antara kedua jenis adalah kurangnya virtual <br>  metode tabel dalam struktur.  Ini berarti: </p><br><ol><li>  Anda tidak bisa mendeskripsikan dan menimpa metode virtual dalam struktur. </li><li>  Suatu struktur tidak dapat mewarisi yang lain.  Satu-satunya cara untuk meniru warisan adalah dengan meletakkan struktur tipe dasar di bidang pertama.  Bidang-bidang struktur "warisan" akan pergi setelah bidang struktur "dasar" dan itu akan membuat warisan logis.  Bidang kedua struktur akan bertepatan berdasarkan offset. </li><li>  Anda dapat meneruskan struktur ke kode yang tidak dikelola.  Namun, Anda akan kehilangan informasi tentang metode.  Ini karena struktur hanyalah ruang dalam memori, diisi dengan data tanpa informasi tentang suatu jenis.  Anda dapat meneruskannya ke metode yang tidak dikelola, misalnya, ditulis dalam C ++, tanpa perubahan. </li></ol><br><p>  Kurangnya tabel metode virtual mengurangi bagian tertentu dari "sihir" warisan dari struktur tetapi memberi mereka keuntungan lain.  Yang pertama adalah kita dapat melewatkan instance dari struktur seperti itu ke lingkungan eksternal (di luar .NET Framework).  Ingat, ini hanya kenangan <br>  jangkauan!  Kami juga dapat mengambil rentang memori dari kode yang tidak dikelola dan melemparkan tipe ke struktur kami untuk membuat bidangnya lebih mudah diakses.  Anda tidak dapat melakukan ini dengan kelas karena mereka memiliki dua bidang yang tidak dapat diakses.  Ini adalah SyncBlockIndex dan alamat tabel metode virtual.  Jika kedua bidang lolos ke kode yang tidak dikelola, itu akan berbahaya.  Menggunakan tabel metode virtual seseorang dapat mengakses jenis apa pun dan mengubahnya untuk menyerang aplikasi. </p><br><p>  Mari kita tunjukkan itu hanya rentang memori tanpa logika tambahan. </p><br><pre> <code class="plaintext hljs">unsafe void Main() { int secret = 666; HeightHolder hh; hh.Height = 5; WidthHolder wh; unsafe { // This cast wouldn't work if structures had the information about a type. // The CLR would check a hierarchy before casting a type and if it didn't find WidthHolder, // it would output an InvalidCastException exception. But since a structure is a memory range, // you can interpret it as any kind of structure. wh = *(WidthHolder*)&amp;hh; } Console.WriteLine("Width: " + wh.Width); Console.WriteLine("Secret:" + wh.Secret); } struct WidthHolder { public int Width; public int Secret; } struct HeightHolder { public int Height; }</code> </pre> <br><p>  Di sini, kami melakukan operasi yang tidak mungkin dilakukan dalam pengetikan yang kuat.  Kami melemparkan satu jenis ke jenis lain yang tidak kompatibel yang berisi satu bidang tambahan.  Kami memperkenalkan variabel tambahan di dalam metode Utama.  Secara teori, nilainya rahasia.  Namun, kode contoh akan menampilkan nilai variabel, tidak ditemukan dalam struktur di dalam metode <code>Main()</code> .  Anda mungkin menganggapnya sebagai pelanggaran keamanan, tetapi berbagai hal tidak begitu sederhana.  Anda tidak dapat menghilangkan kode yang tidak dikelola dalam suatu program.  Alasan utamanya adalah struktur tumpukan benang.  Seseorang dapat menggunakannya untuk mengakses kode yang tidak dikelola dan bermain dengan variabel lokal.  Anda dapat mempertahankan kode Anda dari serangan ini dengan mengacak ukuran bingkai tumpukan.  Atau, Anda dapat menghapus informasi tentang register <code>EBP</code> untuk mempersulit pengembalian frame stack.  Namun, ini tidak masalah bagi kami sekarang.  Yang kami minati dalam contoh ini adalah sebagai berikut.  Variabel "rahasia" berjalan <strong>sebelum</strong> definisi variabel jam dan <strong>setelahnya</strong> dalam struktur WidthHolder (di tempat yang berbeda, sebenarnya).  Jadi mengapa kita dengan mudah mendapatkan nilainya?  Jawabannya adalah tumpukan itu tumbuh dari kanan ke kiri.  Variabel yang dideklarasikan pertama akan memiliki alamat yang jauh lebih tinggi, dan yang dinyatakan kemudian akan memiliki alamat yang lebih rendah. </p><br><h2 id="the-behavior-when-calling-instance-methods">  Perilaku saat memanggil metode instance </h2><br><p>  Kedua tipe data memiliki fitur lain yang tidak jelas untuk dilihat dan dapat menjelaskan struktur kedua tipe tersebut.  Ini berkaitan dengan memanggil metode instance. </p><br><pre> <code class="plaintext hljs">// The example with a reference type class FooClass { private int x; public void ChangeTo(int val) { x = val; } } // The example with a value type struct FooStruct { private int x; public void ChangeTo(int val) { x = val; } } FooClass klass = new FooClass(); FooStruct strukt = new FooStruct(); klass.ChangeTo(10); strukt.ChangeTo(10);</code> </pre> <br><p>  Secara logis, kita dapat memutuskan bahwa metode ini memiliki satu tubuh yang dikompilasi.  Dengan kata lain, tidak ada instance dari tipe yang memiliki seperangkat metode yang dikompilasi sendiri, mirip dengan set instance lainnya.  Namun, metode yang dipanggil tahu instance miliknya sebagai referensi ke instance tipe adalah parameter pertama.  Kita dapat menulis ulang contoh kita dan itu akan sama dengan apa yang kita katakan sebelumnya.  Saya tidak menggunakan contoh dengan metode virtual dengan sengaja, karena mereka memiliki prosedur lain. </p><br><pre> <code class="plaintext hljs">// An example with a reference type class FooClass { public int x; } // An example with a value type struct FooStruct { public int x; } public void ChangeTo(FooClass klass, int val) { klass.x = val; } public void ChangeTo(ref FooStruct strukt, int val) { strukt.x = val; } FooClass klass = new FooClass(); FooStruct strukt = new FooStruct(); ChangeTo(klass, 10); ChangeTo(ref strukt, 10);</code> </pre> <br><p>  Saya harus menjelaskan penggunaan kata kunci ref.  Jika saya tidak menggunakannya, saya akan mendapatkan <strong>salinan</strong> struktur sebagai parameter metode, bukan yang asli.  Lalu saya akan mengubahnya, tetapi yang asli akan tetap sama.  Saya harus mengembalikan salinan yang diubah dari metode ke penelepon (penyalinan lain), dan penelepon akan menyimpan nilai ini kembali dalam variabel (satu lagi penyalinan).  Sebagai gantinya, metode instance mendapat pointer dan menggunakannya untuk langsung mengubah yang asli.  Menggunakan pointer tidak mempengaruhi kinerja karena operasi tingkat prosesor menggunakan pointer.  Ref adalah bagian dari dunia C #, tidak ada lagi. </p><br><h2 id="the-capability-to-point-to-the-position-of-elements">  Kemampuan untuk menunjuk ke posisi elemen. </h2><br><p>  Baik struktur dan kelas memiliki kemampuan lain untuk menunjuk ke offset bidang tertentu sehubungan dengan awal struktur dalam memori.  Ini melayani beberapa tujuan: </p><br><ul><li>  untuk bekerja dengan API eksternal di dunia yang tidak dikelola tanpa harus memasukkan bidang yang tidak digunakan sebelum yang diperlukan; </li><li>  untuk menginstruksikan kompiler untuk menemukan bidang tepat di awal jenis ( <code>[FieldOffset(0)]</code> ).  Ini akan membuat pekerjaan dengan tipe ini lebih cepat.  Jika ini adalah bidang yang sering digunakan, kita dapat meningkatkan kinerja aplikasi.  Namun, ini hanya berlaku untuk tipe nilai.  Dalam tipe referensi, bidang dengan offset nol berisi alamat tabel metode virtual, yang membutuhkan 1 kata mesin.  Bahkan jika Anda menangani bidang pertama dari sebuah kelas, ia akan menggunakan pengalamatan yang kompleks (alamat + offset).  Ini karena bidang kelas yang paling sering digunakan adalah alamat tabel metode virtual.  Tabel diperlukan untuk memanggil semua metode virtual; </li><li>  untuk menunjuk ke beberapa bidang menggunakan satu alamat.  Dalam hal ini, nilai yang sama ditafsirkan sebagai tipe data yang berbeda.  Dalam C ++ tipe data ini disebut gabungan; </li><li>  jangan repot-repot mendeklarasikan apa pun: kompiler akan mengalokasikan bidang secara optimal.  Dengan demikian, urutan akhir bidang mungkin berbeda. </li></ul><br><p>  <strong>Komentar umum</strong> </p><br><ul><li>  <strong>Otomatis</strong> : lingkungan run-time secara otomatis memilih lokasi dan pengepakan untuk semua bidang kelas atau struktur.  Struktur yang ditentukan yang ditandai oleh anggota enumerasi ini tidak dapat masuk ke kode yang tidak dikelola.  Upaya untuk melakukannya akan menghasilkan pengecualian; </li><li>  <strong>Eksplisit</strong> : seorang programmer secara eksplisit mengontrol lokasi yang tepat dari setiap bidang jenis dengan FieldOffsetAttribute; </li><li>  <strong>Berurutan</strong> : anggota tipe datang dalam urutan berurutan, didefinisikan selama desain tipe.  Nilai StructLayoutAttribute.Pack dari langkah pengemasan menunjukkan lokasi mereka. </li></ul><br><p>  <strong>Menggunakan FieldOffset untuk melewati bidang struktur yang tidak digunakan</strong> </p><br><p>  Struktur yang berasal dari dunia yang tidak dikelola dapat berisi bidang yang dicadangkan.  Orang dapat menggunakannya di versi perpustakaan yang akan datang.  Di C / C ++ kami mengisi celah ini dengan menambahkan bidang, mis. Reserved1, reserved2, ... Namun, dalam. NET kami hanya mengimbangi ke awal bidang dengan menggunakan atribut FieldOffsetAttribute dan <code>[StructLayout(LayoutKind.Explicit)]</code> . </p><br><pre> <code class="plaintext hljs">[StructLayout(LayoutKind.Explicit)] public struct SYSTEM_INFO { [FieldOffset(0)] public ulong OemId; // 92 bytes reserved [FieldOffset(100)] public ulong PageSize; [FieldOffset(108)] public ulong ActiveProcessorMask; [FieldOffset(116)] public ulong NumberOfProcessors; [FieldOffset(124)] public ulong ProcessorType; }</code> </pre> <br><p>  Sebuah celah ditempati tetapi ruang yang tidak digunakan.  Struktur akan memiliki ukuran yang sama dengan 132 dan bukan 40 byte seperti yang terlihat dari awal. </p><br><p>  <strong>Serikat pekerja</strong> </p><br><p>  Menggunakan FieldOffsetAttribute Anda bisa meniru tipe C / C ++ yang disebut union.  Hal ini memungkinkan untuk mengakses data yang sama dengan entitas <br>  berbagai jenis.  Mari kita lihat contohnya: </p><br><pre> <code class="plaintext hljs">// If we read the RGBA.Value, we will get an Int32 value accumulating all // other fields. // However, if we try to read the RGBA.R, RGBA.G, RGBA.B, RGBA.Alpha, we // will get separate components of Int32. [StructLayout(LayoutKind.Explicit)] public struct RGBA { [FieldOffset(0)] public uint Value; [FieldOffset(0)] public byte R; [FieldOffset(1)] public byte G; [FieldOffset(2)] public byte B; [FieldOffset(3)] public byte Alpha; }</code> </pre> <br><p>  Anda mungkin mengatakan perilaku seperti itu hanya mungkin untuk tipe nilai.  Namun, Anda dapat mensimulasikannya untuk jenis referensi, menggunakan satu alamat untuk tumpang tindih dua jenis referensi atau satu jenis referensi dan satu jenis nilai: </p><br><pre> <code class="plaintext hljs">class Program { public static void Main() { Union x = new Union(); x.Reference.Value = "Hello!"; Console.WriteLine(x.Value.Value); } [StructLayout(LayoutKind.Explicit)] public class Union { public Union() { Value = new Holder&lt;IntPtr&gt;(); Reference = new Holder&lt;object&gt;(); } [FieldOffset(0)] public Holder&lt;IntPtr&gt; Value; [FieldOffset(0)] public Holder&lt;object&gt; Reference; } public class Holder&lt;T&gt; { public T Value; } }</code> </pre> <br><p>  Saya menggunakan tipe generik untuk tumpang tindih dengan sengaja.  Kalau dulu saya biasa <br>  tumpang tindih, tipe ini akan menyebabkan TypeLoadException ketika dimuat dalam domain aplikasi.  Ini mungkin terlihat seperti pelanggaran keamanan secara teori (terutama, ketika berbicara tentang <strong>plug-in</strong> aplikasi), tetapi jika kita mencoba menjalankan kode ini menggunakan domain yang dilindungi, kita akan mendapatkan <code>TypeLoadException</code> sama. </p><br><h2 id="the-difference-in-allocation">  Perbedaan dalam alokasi </h2><br><p>  Fitur lain yang membedakan kedua jenis adalah alokasi memori untuk objek atau struktur.  CLR harus memutuskan beberapa hal sebelum mengalokasikan memori untuk suatu objek.  Berapa ukuran suatu objek?  Apakah kurang lebih 85K?  Jika kurang, maka apakah ada cukup ruang kosong pada SOH untuk mengalokasikan objek ini?  Jika lebih, CLR mengaktifkan Pengumpul Sampah.  Ini melewati grafik objek, memadatkan objek dengan memindahkannya ke ruang kosong.  Jika masih tidak ada ruang pada SOH, alokasi halaman memori virtual tambahan akan dimulai.  Hanya saat itulah sebuah objek mendapat ruang yang dialokasikan, dibersihkan dari sampah.  Setelah itu, CLR menjabarkan SyncBlockIndex dan VirtualMethodsTable.  Akhirnya, referensi ke suatu objek kembali ke pengguna. </p><br><p>  Jika objek yang dialokasikan lebih besar dari 85K, ia pergi ke Large Objects Heap (LOH).  Ini adalah kasus string dan array besar.  Di sini, kita harus menemukan ruang yang paling cocok dalam memori dari daftar rentang yang tidak dihuni atau mengalokasikan yang baru.  Ini tidak cepat, tetapi kita akan berurusan dengan benda-benda sebesar itu dengan hati-hati.  Juga, kita tidak akan membicarakannya di sini. </p><br><p>  Ada beberapa skenario yang mungkin untuk RefTypes: </p><br><ul><li>  RefType &lt;85K, ada ruang di SOH: alokasi memori cepat; </li><li>  RefType &lt;85K, ruang pada SOH hampir habis: alokasi memori sangat lambat; </li><li>  RefType&gt; 85K, alokasi memori lambat. </li></ul><br><p>  Operasi seperti itu jarang terjadi dan tidak dapat bersaing dengan ValTip.  Algoritma alokasi memori untuk tipe nilai tidak ada.  Alokasi memori untuk tipe nilai tidak dikenai biaya.  Satu-satunya hal yang terjadi ketika mengalokasikan memori untuk jenis ini adalah mengatur bidang ke nol.  Mari kita lihat mengapa ini terjadi: 1. Ketika seseorang mendeklarasikan variabel dalam tubuh metode, waktu alokasi memori untuk suatu struktur mendekati nol.  Itu karena waktu alokasi untuk variabel lokal tidak tergantung pada jumlah mereka;  2. Jika ValTip dialokasikan sebagai bidang, Reftip akan menambah ukuran bidang.  Tipe nilai dialokasikan sepenuhnya, menjadi bagiannya;  3. Seperti dalam hal penyalinan, jika ValTip dilewatkan sebagai parameter metode, akan muncul perbedaan, tergantung pada ukuran dan lokasi parameter. </p><br><p>  Namun, itu tidak memakan waktu lebih lama daripada menyalin satu variabel ke variabel lain. </p><br><h2 id="the-choice-between-a-class-or-a-structure">  Pilihan antara kelas atau struktur </h2><br><p>  Mari kita bahas kelebihan dan kekurangan dari kedua jenis dan memutuskan skenario penggunaannya.  Prinsip klasik mengatakan kita harus memilih tipe nilai jika tidak lebih besar dari 16 byte, tetap tidak berubah selama masa pakaiannya dan tidak diwariskan.  Namun, memilih jenis yang tepat berarti meninjaunya dari perspektif yang berbeda berdasarkan skenario penggunaan masa depan.  Saya mengusulkan tiga kelompok kriteria: </p><br><ul><li>  berdasarkan arsitektur sistem tipe, di mana tipe Anda akan berinteraksi; </li><li>  berdasarkan pendekatan Anda sebagai pemrogram sistem untuk memilih tipe dengan kinerja optimal; </li><li>  ketika tidak ada pilihan lain. </li></ul><br><p>  Setiap fitur yang dirancang harus mencerminkan tujuannya.  Ini tidak hanya berurusan dengan nama atau antarmuka interaksi (metode, properti).  Orang dapat menggunakan pertimbangan arsitektur untuk memilih antara nilai dan jenis referensi.  Mari kita pikirkan mengapa struktur dan bukan kelas dapat dipilih dari sudut pandang sistem tipe sistem. </p><br><ol><li><p>  Jika tipe yang Anda rancang bersifat agnostik terhadap kondisinya, ini berarti kondisinya mencerminkan suatu proses atau nilai sesuatu.  Dengan kata lain, turunan tipe konstan dan tidak dapat diubah secara alami.  Kita dapat membuat instance tipe lain berdasarkan konstanta ini dengan menunjukkan beberapa offset.  Atau, kita dapat membuat instance baru dengan menunjukkan propertinya.  Namun, kita tidak boleh mengubahnya.  Saya tidak bermaksud bahwa struktur adalah tipe yang tidak dapat diubah.  Anda dapat mengubah nilai bidangnya.  Selain itu, Anda bisa meneruskan referensi ke struktur ke metode menggunakan parameter ref dan Anda akan mendapatkan bidang yang diubah setelah keluar dari metode.  Yang saya bicarakan di sini adalah pengertian arsitektur.  Saya akan memberikan beberapa contoh. </p><br><ul><li>  DateTime adalah struktur yang merangkum konsep momen dalam waktu.  Ini menyimpan data ini sebagai uint tetapi memberikan akses ke karakteristik yang terpisah dari suatu saat: tahun, bulan, hari, jam, menit, detik, milidetik dan bahkan kutu prosesor.  Namun, itu tidak dapat diubah, berdasarkan pada apa yang merangkumnya.  Kami tidak dapat mengubah momen dalam waktu.  Aku tidak bisa hidup pada menit berikutnya seolah itu adalah ulang tahun terbaikku di masa kecil.  Jadi, jika kita memilih tipe data, kita bisa memilih kelas dengan antarmuka hanya baca, yang menghasilkan contoh baru untuk setiap perubahan properti.  Atau, kita dapat memilih struktur, yang bisa tetapi tidak boleh mengubah bidang instansinya: <em>nilainya</em> adalah deskripsi saat dalam waktu, seperti angka.  Anda tidak dapat mengakses struktur angka dan mengubahnya.  Jika Anda ingin mendapatkan momen lain dalam waktu, yang berbeda satu hari dari aslinya, Anda hanya akan mendapatkan contoh baru dari suatu struktur. </li><li>  <code>KeyValuePair&lt;TKey, TValue&gt;</code> adalah struktur yang merangkum konsep pasangan kunci - nilai yang terhubung.  Struktur ini hanya untuk menampilkan konten kamus selama enumerasi.  Dari sudut pandang arsitektur kunci dan nilai adalah konsep yang tidak dapat dipisahkan dalam <code>Dictionary&lt;T&gt;</code> .  Namun, di dalam kita memiliki struktur yang kompleks, di mana kunci terletak terpisah dari suatu nilai.  Untuk pengguna, pasangan kunci-nilai adalah konsep yang tidak dapat dipisahkan dalam hal antarmuka dan arti dari struktur data.  Ini adalah seluruh <em>nilai</em> itu sendiri.  Jika seseorang memberikan nilai lain untuk kunci, seluruh pasangan akan berubah.  Dengan demikian, mereka mewakili satu kesatuan.  Ini membuat struktur varian ideal dalam kasus ini. </li></ul><br></li><li><p>  Jika tipe yang Anda rancang adalah bagian yang tidak terpisahkan dari tipe eksternal tetapi merupakan bagian yang tidak terpisahkan secara struktural.  Itu berarti tidak benar untuk mengatakan tipe eksternal mengacu pada turunan dari tipe yang dienkapsulasi.  Namun, benar untuk mengatakan bahwa tipe enkapsulasi adalah bagian dari eksternal bersama dengan semua propertinya.  Ini berguna ketika mendesain struktur yang merupakan bagian dari struktur lain. </p><br><ul><li>  Misalnya, jika kita mengambil struktur header file, maka tidak pantas untuk meneruskan referensi dari satu file ke yang lain, misalnya beberapa file header.txt.  Ini akan sesuai ketika memasukkan dokumen ke dokumen lain, bukan dengan menyematkan file tetapi menggunakan referensi dalam sistem file.  Contoh yang baik adalah file pintasan di OS Windows.  Namun, jika kita berbicara tentang tajuk file (misalnya tajuk file JPEG yang berisi metadata tentang ukuran gambar, metode kompresi, parameter fotografi, koordinat GPS dan lainnya), maka kita harus menggunakan struktur untuk merancang jenis parsing header.  Jika Anda menggambarkan semua header dalam struktur, Anda akan mendapatkan posisi bidang yang sama di memori seperti di file.  Dengan menggunakan transformasi <code>*(Header *)readedBuffer</code> sederhana yang tidak aman tanpa deserialisasi, Anda akan mendapatkan struktur data yang terisi penuh. </li></ul><br></li></ol><br><ol><li>  Tidak ada contoh yang menunjukkan warisan perilaku.  Mereka menunjukkan bahwa tidak perlu mewarisi perilaku entitas ini.  Mereka mandiri.  Namun, jika kita mempertimbangkan efektivitas kode, kita akan melihat pilihan dari sisi lain: </li><li>  Jika kita perlu mengambil beberapa data terstruktur dari kode yang tidak dikelola, kita harus memilih struktur.  Kami juga dapat meneruskan struktur data ke metode yang tidak aman.  Tipe referensi sama sekali tidak cocok untuk ini. </li><li>  Struktur adalah pilihan Anda jika suatu tipe melewati data dalam pemanggilan metode (sebagai nilai yang dikembalikan atau sebagai parameter metode) dan tidak perlu merujuk ke nilai yang sama dari tempat yang berbeda.  Contoh sempurna adalah tupel.  Jika suatu metode mengembalikan beberapa nilai menggunakan tuple, itu akan mengembalikan ValueTuple, yang dinyatakan sebagai struktur.  Metode ini tidak akan mengalokasikan ruang pada heap, tetapi akan menggunakan tumpukan utas, di mana alokasi memori tidak ada biaya. </li><li>  Jika Anda mendesain sistem yang menciptakan lalu lintas besar instance yang memiliki ukuran kecil dan masa pakai, menggunakan tipe referensi akan mengarah ke kumpulan objek atau, jika tanpa kumpulan objek, ke akumulasi sampah yang tidak terkendali di heap.  Beberapa objek akan berubah menjadi generasi yang lebih tua, menambah beban pada GC.  Menggunakan tipe nilai di tempat-tempat seperti itu (jika memungkinkan) akan memberikan peningkatan kinerja karena tidak ada yang lolos ke SOH.  Ini akan mengurangi beban pada GC dan algoritme akan bekerja lebih cepat; </li></ol><br><p>  Mendasarkan pada apa yang saya katakan, berikut adalah beberapa saran untuk menggunakan struktur: </p><br><ol><li>  Saat memilih koleksi Anda harus menghindari array besar menyimpan struktur besar.  Ini termasuk struktur data berdasarkan array.  Ini dapat menyebabkan transisi ke Tumpukan Objek Besar dan fragmentasi.  Adalah salah untuk berpikir bahwa jika struktur kita memiliki 4 bidang tipe byte, itu akan mengambil 4 byte.  Kita harus memahami bahwa dalam sistem 32-bit setiap bidang struktur disejajarkan pada batas 4 byte (setiap bidang alamat harus dibagi persis dengan 4) dan dalam sistem 64-bit - pada batas 8 byte.  Ukuran array harus bergantung pada ukuran struktur dan platform, menjalankan program.  Dalam contoh kita dengan 4 byte - 85K / (dari 4 hingga 8 byte per bidang * jumlah bidang = 4) minus ukuran header array sama dengan sekitar 2 600 elemen per array tergantung pada platform (ini harus dibulatkan ke bawah )  Itu tidak terlalu banyak.  Mungkin kelihatannya kita bisa dengan mudah mencapai konstanta ajaib 20.000 elemen </li><li>  Kadang-kadang Anda menggunakan struktur ukuran besar sebagai sumber data dan menempatkannya sebagai bidang dalam kelas, sambil memiliki satu salinan direplikasi untuk menghasilkan ribuan contoh.  Lalu Anda perluas setiap instance kelas untuk ukuran struktur.  Ini akan menyebabkan pembengkakan generasi nol dan transisi ke generasi satu dan bahkan dua.  Jika instance kelas memiliki masa hidup pendek dan Anda berpikir GC akan mengumpulkannya pada generasi nol - selama 1 ms, Anda akan kecewa.  Mereka sudah dalam generasi satu dan bahkan dua.  Ini membuat perbedaan.  Jika GC mengumpulkan generasi nol selama 1 ms, generasi satu dan dua dikumpulkan dengan sangat lambat yang akan menyebabkan penurunan efisiensi; </li><li>  Untuk alasan yang sama Anda harus menghindari melewati struktur besar melalui serangkaian pemanggilan metode.  Jika semua elemen saling memanggil satu sama lain, panggilan ini akan mengambil lebih banyak ruang di stack dan membuat aplikasi Anda mati oleh StackOverflowException.  Alasan selanjutnya adalah kinerja.  Semakin banyak salinan, semakin lambat semuanya berfungsi. </li></ol><br><p>  Itu sebabnya pemilihan tipe data bukanlah proses yang jelas.  Seringkali, ini bisa merujuk pada optimasi prematur, yang tidak dianjurkan.  Namun, jika Anda tahu situasi Anda termasuk dalam prinsip-prinsip yang disebutkan di atas, Anda dapat dengan mudah memilih tipe nilai. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Bab ini diterjemahkan dari bahasa Rusia bersama oleh penulis dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerjemah profesional</a> .  Anda dapat membantu kami dengan terjemahan dari bahasa Rusia atau Inggris ke bahasa lain, terutama ke bahasa Cina atau Jerman. <br><br>  Juga, jika Anda ingin berterima kasih kepada kami, cara terbaik yang dapat Anda lakukan adalah memberi kami bintang di github atau untuk repositori garpu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439486/">https://habr.com/ru/post/id439486/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439476/index.html">Bahasa gaul Cockney: sejarah modern dan status sosial</a></li>
<li><a href="../id439478/index.html">Menghibur C #. Lima contoh rehat kopi</a></li>
<li><a href="../id439480/index.html">Beri jalan, atau Mengapa CRM Anda (dan CRM) melambat?</a></li>
<li><a href="../id439482/index.html">devleads - (un) motivasi finansial</a></li>
<li><a href="../id439484/index.html">Mendapatkan data enum dalam perspektif Automapper</a></li>
<li><a href="../id439488/index.html">Rekaman Video Meetup QA</a></li>
<li><a href="../id439490/index.html">Jenis Referensi .NET vs Jenis Nilai. Bagian 2</a></li>
<li><a href="../id439492/index.html">10 Tips untuk Menjadi Pemimpin Teknologi yang Baik</a></li>
<li><a href="../id439496/index.html">Cara penagihan dilakukan di sana: ketika pelanggan dan pengembang berbicara bahasa yang berbeda</a></li>
<li><a href="../id439498/index.html">Pada perangkat keras mana untuk menganalisis sejumlah besar informasi?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>