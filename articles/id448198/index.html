<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¾â€âœˆï¸ ğŸ˜ ğŸ¥„ Amankan transfer data antara dua aplikasi ğŸ§£ ğŸ§‘ğŸ» ğŸ•µğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya, hari ini saya ingin memberi tahu Anda tentang beberapa opsi untuk mentransfer data antara dua aplikasi Android dan mempertimbangkannya ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Amankan transfer data antara dua aplikasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/448198/">  Halo semuanya, hari ini saya ingin memberi tahu Anda tentang beberapa opsi untuk mentransfer data antara dua aplikasi Android dan mempertimbangkannya dari sudut pandang keamanan.  Saya memutuskan untuk menulis artikel ini karena dua alasan.  Pertama, saya sering mulai menemui kurangnya pemahaman tentang pengembang mekanisme untuk bekerja dengan komponen aplikasi android.  Yang kedua - saya berhenti memahami apa yang menjadi pilihan mekanisme ini atau itu berdasarkan ketika mengimplementasikan fitur dan ingin menyampaikan bagaimana seharusnya terlihat pada minimum. <a name="habracut"></a><br><br><h6>  Tantangan </h6><br>  Kami memiliki 2 aplikasi yang mengakses API yang sama.  Klien dapat mengakses API dengan token akses (sessionId).  Anda harus menerapkan transisi yang mulus dari satu aplikasi ke aplikasi lainnya.  Untuk melakukan ini, Anda harus mencari-cari di antara mereka, misalnya, biarkan sessionId. <br><br><h6>  Opsi # 1: QUERY DEEPLINK </h6><br>  Opsi yang paling jelas adalah mentransfer token ke Query DeepLink.  Akan terlihat seperti ini: <br> <code>slave://main?sessionId=686A885A4FB644053C584B9BE2A70C7D</code> <br>  Dalam hal ini, penerima akan dapat mengekstrak sessionId dan menggunakannya tanpa meminta izin dari pengguna.  Dari sisi pengembang, sepertinya tugas telah selesai, tapi mari kita gali lebih dalam. <br><br><h4>  Pembajakan deeplink </h4><br>  Karena aplikasi apa pun dapat mendaftarkan skema tinkoff: //, OS dapat membuka aplikasi yang salah.  Hal ini dimungkinkan karena kenyataan bahwa tidak ada pendaftaran dan pembatasan penggunaan skema.  Aplikasi jahat dapat mendaftarkan skema tinkoff: // dan mencegat permintaan ke aplikasi Tinkoff dan mulai sendiri.  Dalam hal ini, sessionId akan jatuh ke tangan yang salah dan akun Anda akan dikompromikan.  Selain itu, DeepLink Hijacking memungkinkan Anda untuk melakukan phishing, misalnya, menampilkan bidang untuk memasukkan nama pengguna dan kata sandi. <br><br>  Secara konseptual, prosesnya terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/jr/ql/kk/jrqlkkybrv_js21icrnk5hjeqme.png" alt="gambar"><br><br>  Ada 2 solusi untuk masalah ini.  Pertama, teknologi AppLinks tidak lagi memungkinkan pengembang untuk menyesuaikan skema, sebaliknya, http / https digunakan.  Dalam hal ini, OS mengambil tautan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">slave.com/profile</a> dan menghubungi host slave.com untuk verifikasi.  Yang kedua - URL Intent - alih-alih memanggil slave: //, intent: // disebut, di mana pengidentifikasi unik aplikasi yang akan diluncurkan dilewatkan.  Ini terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">intent://main/#Intent;scheme=slave;package=com.example.slave.client.android;end"</code> </pre> <br>  Dalam hal ini, tidak mungkin untuk mencegat peluncuran aplikasi, karena paket spesifik ditentukan.  Namun, masalahnya tetap bahwa pengguna dapat menginstal aplikasi dari sumber pihak ketiga dengan packageId yang sama dengan budak Anda.  Dalam hal ini, jika Anda tidak memiliki aplikasi budak yang sah, aplikasi jahat akan menginstal dan menerima token Anda. <br><br><h4>  Fiksasi sesi </h4><br>  Ini adalah serangan di mana penyerang memaksa klien untuk membuat sesi dengan perangkat lunak target menggunakan sessionId yang disediakan oleh penyerang.  Segera setelah pengguna mengautentikasi, penyerang akan dapat menggunakan pengidentifikasi yang sudah diistimewakan ini untuk tujuannya sendiri.  Serangan mengeksploitasi fakta bahwa perangkat lunak target menggunakan sessionId yang sama setelah eskalasi hak istimewa. <br><br><img src="https://habrastorage.org/webt/pm/s2/_1/pms2_1zmdejnjxlb_duw2zjqzau.png"><br>  Bagaimana tampilannya dalam kasus kami: <br><br><ol><li>  penyerang mendapat sesi anonim dari aplikasi </li><li>  melemparkan surat dengan indah kepada korban atas nama bank, di mana ia diundang untuk pergi ke rekening pribadinya </li><li>  saat mengklik tautan, kita menuju ke DeepLink dengan slave sesi penyerang: // main? sessionId = 686A885A4FB644053C584B9BE2A70C7D </li><li>  aplikasi seluler mengambil sesi, memahami bahwa itu tidak memiliki hak yang cukup dan meminta pengguna untuk mengotentikasi </li><li>  pengguna melewatinya, sesi telah meningkatkan hak </li><li>  pengguna dalam aplikasi, penyerang dengan sesi istimewa, untung </li></ol><br>  Adalah benar untuk memperbaikinya pada API, mengeluarkan sessionId lain setelah eskalasi hak istimewa, tetapi kami sedang menulis aplikasi seluler.  Dan cara kami adalah menolak untuk mentransfer token dari master ke slave.  Plus, ini akan memberi kita perlindungan mendalam dan jika ada yang rusak pada API dan token tidak akan berubah ketika hak istimewa ditingkatkan, maka serangan akan tetap mustahil. <br><br><h4>  Kebocoran pihak ke-3 </h4><br>  Minus lain dari opsi ini.  Banyak orang menggunakan layanan pihak ketiga untuk DeepLink karena kemudahan menghasilkan tautan, analitik, dan hal-hal keren lainnya.  Dalam hal ini, Anda cukup memberikan token Anda kepada perusahaan pihak ketiga. <br><br><h6>  Opsi # 2: PENYEDIA KONTEN </h6><br>  Bagaimana kita akan melakukannya?  Kami mendefinisikan penyedia konten utama dan membuat budak pergi ke penyedia konten ini untuk token. <br><br><img src="https://habrastorage.org/webt/lq/am/ip/lqamiplsbcmfslxdcb_u1whnv7a.png"><br><br>  Dengan demikian, kami menyingkirkan risiko mentransfer token ke aplikasi yang salah dalam kasus Pembajakan DeepLink dan membuat serangan Fiksasi Sesi tidak mungkin.  Tetapi kami memiliki masalah lain - dalam versi saat ini, secara umum, aplikasi apa pun dapat meminta token kapan saja, bahkan jika kami tidak memulai peluncurannya. <br><br><h4>  Tingkat perlindungan </h4><br>  Dalam kebanyakan kasus, Anda perlu memverifikasi bahwa budak ditandatangani dengan kunci yang sama dengan master, yaitu, mereka milik penulis yang sama.  Untuk kasus ini, manajer paket memiliki metode checkSignatures yang memeriksa tanda tangan aplikasi.  Untuk menggunakan fungsi ini, Anda perlu menambahkan izin dengan protectionLevel = "signature" di Penyedia Konten di manifes aplikasi: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">permission</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.example.contentprovider.access"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:protectionLevel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"signature"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">provider</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:readPermission</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.example.contentprovider.access"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Skema ini hampir tidak akan berubah dari angka sebelumnya, hanya jaminan yang akan muncul bahwa hanya aplikasi dengan tanda tangan dari penulis yang sama yang akan mendapatkan akses ke token. <br><br><h4>  Kondisi Balap Izin </h4><br>  Ada satu fitur yang sangat tidak menyenangkan bahwa nama izin tidak unik, yang dapat digunakan oleh aplikasi jahat dan mendaftarkan izin dengan nama kami dan protectionLevel = "normal" di hadapan kami.  Dalam hal ini, ketika menginstal aplikasi kita, izin sudah ada pada OS dan itu tidak akan ditimpa.  Akibatnya, penyedia konten kami akan tetap tidak terlindungi dan dengan akses resmi dari aplikasi apa pun. <br><br><h4>  Tanda tangan yang berbeda </h4><br>  Sayangnya, aplikasi tidak selalu ditandatangani dengan kunci yang sama, misalnya, beberapa aplikasi dibeli, atau "secara historis", tetapi transisi yang mulus masih diperlukan.  Dalam hal ini, kami mengambil verifikasi tanda tangan pada diri kami. <br>  Bagaimana ini bisa diterapkan: <br>  Penyedia Konten memiliki metode getCallingPackage (), di mana kita bisa mendapatkan packageId dari aplikasi yang telah diterapkan untuk data, dan dengan packageId kita bisa mendapatkan daftar tanda tangan dan memeriksanya dengan yang ada di dalamnya. <br><br><pre> <code class="java hljs">String pkg = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getCallingPackage(); PackageInfo pkgInfo = pkgmgr.getPackageInfo(pkg, GET_SIGNATURES); Signatures[] signatures = pkgInfo.signatures; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Signature sig: signatures) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sig.equals(TRUSTED_SIGNATURE)) { <span class="hljs-comment"><span class="hljs-comment">// trusted signature found, trust the application } }</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/zh/nx/p4/zhnxp4g2s8znhxf1ushb3ooo7fo.png"><br><br>  Tampaknya kami melakukan semuanya dengan sempurna, tetapi tidak. <br><br><h4>  Kerentanan id palsu </h4><br>  Masalahnya adalah bahwa ketika Android menciptakan rantai kepercayaan, proses verifikasi hanya membandingkan subjek, dan tidak memverifikasi tanda tangan di bidang penanda tangan sertifikat.  Akibatnya, seorang penyerang dapat membangun rantai kepercayaan tanpa tanda tangan yang sebenarnya. <br><br>  Karena kesalahan ini, rantai sertifikat yang salah dihasilkan, yang mungkin termasuk sertifikat yang sah yang tertanam di APK, tetapi tidak benar-benar digunakan untuk menandatangani aplikasi.  Pada akhirnya, saya akan meninggalkan tautan ke komit yang memperbaiki kerentanan ini.  Masalahnya diperbaiki di Android 4.4, jadi kami hanya bisa menaikkan Level API ke 19. <br><br><h6>  Kesimpulan </h6><br>  Hari ini kami memeriksa bagaimana fitur harus dianalisis selama pengembangan. <br>  Kami juga memeriksa opsi untuk mentransfer rahasia antara dua aplikasi, di mana kami menganalisis masalah dari setiap opsi dan menemukan cara untuk menghindarinya. <br><br>  Semua aplikasi aman! <br><br><h6>  Referensi </h6><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komit</a> memperbaiki kerentanan id palsu </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Presentasi</a> kerentanan id palsu </li><li>  CWE: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fiksasi Sesi</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448198/">https://habr.com/ru/post/id448198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448188/index.html">Kapsul waktu: HP iPaq h1940 "di luar kotak." Apa itu PDA untuk dari tahun 2000-an</a></li>
<li><a href="../id448190/index.html">Editor logika visual untuk Unity3d. Bagian 1</a></li>
<li><a href="../id448192/index.html">Mengapa kita perlu dalam produksi AR dan VR</a></li>
<li><a href="../id448194/index.html">Calon pengalaman dalam merekrut pengembang perangkat lunak. Bagian 2</a></li>
<li><a href="../id448196/index.html">Masa depan (atau hadiah rahasia) mesin plasma atau bagaimana mencapai 27 max swing di atmosfer</a></li>
<li><a href="../id448202/index.html">Kami mengontrol generator atau perang melawan ADC di STM32F030</a></li>
<li><a href="../id448204/index.html">Pulau Bohemian</a></li>
<li><a href="../id448206/index.html">Pengembangan modular atau jalan ke sana, bukan kembali</a></li>
<li><a href="../id448208/index.html">20, 100, 3, 19 - Informasi dalam angka</a></li>
<li><a href="../id448210/index.html">Meriam untuk satelit, blaster dan kapal tenaga surya: proyek yang aneh dan paradoks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>