<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ûüèª üö† ü•Ñ Correio: migra√ß√£o do Dropbox para o gRPC üë©üèº‚Äçüè´ üë¥üèª üé¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota do tradutor 
 A maioria dos produtos de software modernos n√£o √© monol√≠tica, mas consiste em muitas partes que interagem entre si. Nessa situa√ß√£o,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Correio: migra√ß√£o do Dropbox para o gRPC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/438474/"><img src="https://habrastorage.org/webt/eu/p8/y-/eup8y-m8hpxc9w2qhvo1qofrmog.jpeg"><br><br><h1>  Nota do tradutor </h1><br>  A maioria dos produtos de software modernos n√£o √© monol√≠tica, mas consiste em muitas partes que interagem entre si.  Nessa situa√ß√£o, √© necess√°rio que a comunica√ß√£o das partes em intera√ß√£o do sistema ocorra em um idioma (apesar do fato de que essas partes podem ser escritas em diferentes linguagens de programa√ß√£o e executadas em m√°quinas diferentes).  Simplificar a solu√ß√£o para esse problema ajuda o gRPC - framework de c√≥digo aberto do Google, lan√ßado em 2015.  Ele resolve imediatamente v√°rios problemas, permitindo: <br><br><ul><li>  use a linguagem Buffers de Protocolo para descrever a intera√ß√£o de servi√ßos; <br></li><li>  gerar c√≥digo de programa com base no protocolo descrito para 11 idiomas diferentes para a parte do cliente e a parte do servidor; <br></li><li>  implementar autoriza√ß√£o entre componentes em intera√ß√£o; <br></li><li>  use a intera√ß√£o s√≠ncrona e ass√≠ncrona. <br></li></ul><br>  O gRPC me pareceu uma estrutura bastante interessante, e eu estava interessado em aprender sobre a experi√™ncia real do Dropbox na constru√ß√£o de um sistema baseado nele.  O artigo possui muitos detalhes relacionados ao uso da criptografia, criando um sistema confi√°vel, observ√°vel e produtivo, o processo de migra√ß√£o da solu√ß√£o RPC antiga para a nova. <br><br><div class="spoiler">  <b class="spoiler_title">Isen√ß√£o de responsabilidade</b> <div class="spoiler_text">  O artigo original n√£o cont√©m uma descri√ß√£o do gRPC e alguns pontos podem n√£o lhe parecer claros.  Se voc√™ n√£o estiver familiarizado com o gRPC ou outras estruturas semelhantes (por exemplo, Apache Thrift), recomendo que voc√™ se familiarize primeiro com as id√©ias principais (ser√° suficiente ler dois pequenos artigos no site oficial: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúO que √© gRPC?‚Äù</a> E <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúgRPC Concepts‚Äù</a> ). <br><br>  Agradecemos a Aleksey Ivanov, tamb√©m conhecido como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">SaveTheRbtz,</a> por escrever o artigo original e ajudar na tradu√ß√£o de lugares dif√≠ceis. <br></div></div><a name="habracut"></a><br>  O Dropbox gerencia muitos servi√ßos escritos em diferentes idiomas e atende a milh√µes de solicita√ß√µes por segundo.  No centro de nossa arquitetura orientada a servi√ßos est√° o Courier, uma estrutura RPC baseada em gPC.  No processo de desenvolvimento, aprendemos muito sobre extensibilidade do gRPC, otimiza√ß√£o de desempenho e transi√ß√£o do sistema RPC anterior. <br><br>  <i>Nota: a postagem cont√©m trechos de c√≥digo para Python e Go.</i>  <i>Tamb√©m usamos Rust e Java.</i> <br><br><h1>  Caminho para o gRPC </h1><br>  O Courier n√£o √© o primeiro framework RPC do Dropbox.  Mesmo antes de come√ßarmos a dividir o sistema monol√≠tico Python em servi√ßos separados, precis√°vamos de uma base confi√°vel para a troca de dados entre servi√ßos - especialmente porque a escolha de uma estrutura teria consequ√™ncias a longo prazo. <br><br>  Antes disso, o Dropbox experimentou diferentes estruturas de RPC.  Primeiro, t√≠nhamos um protocolo individual para serializa√ß√£o e desserializa√ß√£o manual.  Alguns servi√ßos, como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">log baseado</a> em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Scribe</a> , usavam o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Apache Thrift</a> .  Ao mesmo tempo, nossa estrutura principal de RPC era um protocolo HTTP / 1.1 com mensagens serializadas usando o Protobuf. <br><br>  Criando uma estrutura, escolhemos entre v√°rias op√ß√µes.  Poder√≠amos introduzir o Swagger (agora conhecido como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OpenAPI</a> ) na antiga estrutura RPC, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">introduzir um novo padr√£o</a> ou criar uma estrutura baseada em Thrift ou gRPC.  O principal argumento a favor do gRPC foi a possibilidade de usar protobufs pr√©-existentes.  Al√©m disso, HTTP / 2 multiplex e transfer√™ncia de dados bidirecional foram √∫teis para nossas tarefas. <br><br>  <i>Nota: se fbthrift existisse naquele momento, provavelmente examinar√≠amos melhor as solu√ß√µes Thrift.</i> <br><br><h1>  O que o Courier traz para o gRPC </h1><br>  Courier n√£o √© um protocolo RPC;  √© um meio de integrar o gRPC em uma infraestrutura existente.  A estrutura deveria ser compat√≠vel com nossas ferramentas de autentica√ß√£o, autoriza√ß√£o e descoberta de servi√ßos, bem como coleta, registro e rastreamento de estat√≠sticas.  Ent√£o criamos o Courier. <br><br>  <i>Embora em alguns casos usemos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bandaid</a> como um proxy gRPC, a maioria dos nossos servi√ßos se comunica diretamente entre si para minimizar o impacto do RPC na lat√™ncia.</i> <br><br>  Era importante para n√≥s reduzir a quantidade de c√≥digo de rotina que precisa ser gravado.  Como o Courier serve como uma estrutura geral para o desenvolvimento de servi√ßos, ele cont√©m recursos que todos precisam.  A maioria deles √© ativada por padr√£o e pode ser controlada por argumentos de linha de comando, e alguns s√£o marcados com uma caixa de sele√ß√£o. <br><br><h2>  Seguran√ßa: identidade de servi√ßo e autentica√ß√£o m√∫tua TLS </h2><br>  O Courier implementa nosso mecanismo de identifica√ß√£o de servi√ßo padr√£o.  Cada servidor e cliente recebe um certificado TLS individual emitido por nossa pr√≥pria autoridade de certifica√ß√£o.  O identificador pessoal codificado por certificado, usado para autentica√ß√£o m√∫tua - o servidor verifica o cliente, o cliente verifica o servidor. <br><br>  No TLS, onde controlamos os dois lados da conex√£o, introduzimos restri√ß√µes estritas.  Todos os RPCs internos exigem criptografia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PFS</a> .  A vers√£o exigida do TLS √© 1.2 e superior.  Tamb√©m limitamos o n√∫mero de algoritmos sim√©tricos e assim√©tricos, preferindo <i>ECDHE-ECDSA-AES128-GCM-SHA256</i> . <br><br>  Ap√≥s passar pela identifica√ß√£o e descriptografia da solicita√ß√£o, o servidor verifica se o cliente tem as permiss√µes necess√°rias.  As listas de controle de acesso (ACLs) e os limites de velocidade podem ser configurados para servi√ßos em geral e para m√©todos individuais.  Seus par√¢metros tamb√©m podem ser alterados atrav√©s do nosso sistema de arquivos distribu√≠dos (AFS).  Gra√ßas a isso, os propriet√°rios do servi√ßo podem diminuir a carga em segundos, sem nem mesmo reiniciar os processos.  O Courier se encarregar√° de assinar as notifica√ß√µes e atualizar a configura√ß√£o. <br><br>  <i>O servi√ßo de identidade √© um identificador global para ACLs, limites de velocidade, estat√≠sticas, etc. Al√©m disso, √© criptograficamente seguro.</i> <br><br>  Aqui est√° um exemplo da configura√ß√£o da ACL e do limite de velocidade usado em nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">servi√ßo de reconhecimento de padr√£o √≥ptico</a> : <br><br><pre><code class="plaintext hljs">limits:  dropbox_engine_ocr:    # All RPC methods.    default:      max_concurrency: 32      queue_timeout_ms: 1000      rate_acls:        # OCR clients are unlimited.        ocr: -1        # Nobody else gets to talk to us.        authenticated: 0        unauthenticated: 0</code> </pre> <br><img src="https://habrastorage.org/webt/ll/as/l_/llasl_0osxrxbboxrbjqaalb8ti.png"><br><br>  <i>Estamos considerando a possibilidade de mudar para o formato SVID (documento criptograficamente verificado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SPIFFE</a> ), que ajudar√° a combinar nossa estrutura com muitos projetos de c√≥digo aberto.</i> <br><br><h2>  Observabilidade: estat√≠sticas e rastreamento </h2><br>  Com apenas um identificador, voc√™ pode encontrar facilmente logs, estat√≠sticas, arquivos de rastreamento e outros dados sobre o Courier. <br><br><img src="https://habrastorage.org/webt/t_/25/3o/t_253ogfq1bizretdswvdrb_7g0.png"><br><br>  Durante a gera√ß√£o do c√≥digo, a cole√ß√£o de estat√≠sticas √© adicionada para cada servi√ßo e cada m√©todo no lado do cliente e no lado do servidor.  As estat√≠sticas do servidor s√£o divididas pelo ID do cliente.  Na configura√ß√£o padr√£o, voc√™ receber√° dados detalhados sobre a carga, erros e tempo de atraso de cada servi√ßo usando o Courier. <br><br><img src="https://habrastorage.org/webt/g1/6g/_1/g16g_1z72oxaxwwvasrjhznfltk.png"><br><br>  As estat√≠sticas do correio incluem dados sobre disponibilidade e lat√™ncia no lado do cliente, bem como sobre o n√∫mero de solicita√ß√µes e o tamanho da fila no lado do servidor.  Existem outros gr√°ficos √∫teis, em particular histogramas de tempo de resposta para cada m√©todo e o tempo de handshakes TLS para cada cliente. <br><br>  <i>Uma das vantagens de nossa gera√ß√£o de c√≥digo √© a possibilidade de inicializa√ß√£o est√°tica de estruturas de dados, como histogramas e gr√°ficos de rastreamento.</i>  <i>Isso minimiza o impacto no desempenho.</i> <br><br><img src="https://habrastorage.org/webt/p7/6-/fv/p76-fvobtszsgtu2g2tlmwfwlyk.png"><br><br>  O sistema RPC antigo distribuiu apenas <i>request_id</i> pela API.  Isso tornou poss√≠vel combinar dados dos logs de diferentes servi√ßos.  Na Courier, introduzimos uma API baseada em um subconjunto das especifica√ß√µes do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OpenTracing</a> .  Criamos nossas pr√≥prias bibliotecas no lado do cliente e, no lado do servidor, implementamos uma solu√ß√£o baseada em Cassandra e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jaeger</a> . <br><br><img src="https://habrastorage.org/webt/dk/hv/iq/dkhviqgdiem3itipi7x87tri_i8.png"><br><br>  O rastreamento permite gerar diagramas de depend√™ncia de um servi√ßo em tempo de execu√ß√£o.  Isso ajuda os engenheiros a ver todas as depend√™ncias transitivas de um servi√ßo espec√≠fico.  Al√©m disso, a fun√ß√£o √© √∫til para rastrear depend√™ncias indesejadas ap√≥s a implanta√ß√£o. <br><br><h2>  Confiabilidade: prazos e desconex√£o </h2><br>  O Courier fornece um local central para implementar fun√ß√µes comuns do cliente (por exemplo, tempos limite) em diferentes idiomas.  Gradualmente, adicionamos v√°rios recursos, geralmente baseados nos resultados de uma an√°lise "p√≥stuma" de problemas emergentes. <br><br><h3>  Prazos </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cada solicita√ß√£o de gRPC tem um prazo</a> indicando o tempo limite do cliente.  Como os stubs Courier distribuem automaticamente os metadados conhecidos, o prazo final da solicita√ß√£o √© at√© transferido para fora da API.  Dentro do processo, os prazos recebem uma exibi√ß√£o nativa.  Por exemplo, no Go, eles s√£o representados pelo resultado de <i>context.Context</i> do m√©todo <i>WithDeadline</i> . <br><br>  De fato, conseguimos consertar classes inteiras de problemas de confiabilidade for√ßando os engenheiros a estabelecer prazos na defini√ß√£o dos servi√ßos apropriados. <br><br>  Essa abordagem vai al√©m do RPC.  Por exemplo, nosso ORM MySQL serializa um contexto RPC junto com um prazo em um coment√°rio de consulta SQL.  Nosso proxy SQL pode analisar coment√°rios e "matar" consultas quando o prazo ocorre.  E como b√¥nus ao depurar chamadas de banco de dados, temos uma liga√ß√£o de consulta SQL a uma consulta RPC espec√≠fica. <br><br><h3>  Desconectar </h3><br>  Outro problema comum que os clientes do sistema RPC anterior enfrentavam era a implementa√ß√£o do algoritmo de atraso e flutua√ß√µes exponenciais individuais, mediante solicita√ß√£o repetida. <br><br>  Tentamos encontrar uma solu√ß√£o inteligente para o problema de desconex√£o no Courier, come√ßando com a implementa√ß√£o do buffer LIFO (√∫ltimo a entrar, primeiro a sair) entre o servi√ßo e o conjunto de tarefas. <br><br><img src="https://habrastorage.org/webt/th/sr/t0/thsrt0kbgxgnexrr9figp9ymg_a.png"><br><br>  Em caso de sobrecarga, o LIFO ser√° desconectado automaticamente.  A fila, que √© importante, √© limitada n√£o apenas pelo tamanho, mas tamb√©m <b>pelo tempo</b> (a solicita√ß√£o pode passar na fila apenas um determinado tempo). <br><br>  <i>Menos LIFO - alterando a ordem dos pedidos de processamento.</i>  <i>Se voc√™ deseja manter o pedido original, use o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CoDel</a> .</i>  <i>Tamb√©m existe a possibilidade de desconectar, e a ordem dos pedidos de processamento permanecer√° a mesma.</i> <br><br><img src="https://habrastorage.org/webt/7g/w_/ud/7gw_udkbrsesseak2xrxaucw7fi.png"><br><br><h2>  Introspec√ß√£o: pontos de extremidade de depura√ß√£o </h2><br>  Embora os pontos de extremidade de depura√ß√£o n√£o fa√ßam parte diretamente do Courier, eles s√£o amplamente usados ‚Äã‚Äãno Dropbox e s√£o √∫teis demais para n√£o serem mencionados. <br><br>  <i>Por motivos de seguran√ßa, voc√™ pode abri-los em uma porta separada ou em um soquete Unix (para controlar o acesso usando permiss√µes de arquivo).</i>  <i>Voc√™ tamb√©m deve considerar a autentica√ß√£o TLS m√∫tua, com a qual os desenvolvedores ter√£o que fornecer seus certificados para acesso aos pontos de extremidade (principalmente n√£o somente leitura).</i> <br><br><h3>  Execu√ß√£o </h3><br>  A capacidade de analisar o status de um servi√ßo durante sua opera√ß√£o √© muito √∫til para depura√ß√£o.  Por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://golang.org/pkg/net/">perfis din√¢micos de mem√≥ria e CPU podem ser acessados ‚Äã‚Äãatrav√©s de pontos de extremidade HTTP ou gRPC</a> . <br><br>  <i>Planejamos usar essa oportunidade no procedimento de verifica√ß√£o de can√°rio - para automatizar a busca pela diferen√ßa entre as vers√µes antiga e nova do c√≥digo.</i> <br><br>  Os pontos de extremidade tornam poss√≠vel modificar o estado de um servi√ßo em tempo de execu√ß√£o.  Em particular, os servi√ßos baseados em Golang podem configurar dinamicamente o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GCPercent</a> . <br><br><h3>  A biblioteca </h3><br>  A exporta√ß√£o autom√°tica de dados espec√≠ficos da biblioteca como um terminal RPC pode ser √∫til para desenvolvedores de bibliotecas.  Por exemplo, a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">malloc pode despejar estat√≠sticas internas em um despejo</a> .  Outro exemplo: um ponto de extremidade de depura√ß√£o pode alterar o n√≠vel de log de servi√ßo em tempo real. <br><br><h3>  Rpc </h3><br>  Obviamente, a solu√ß√£o de problemas em protocolos criptografados e codificados n√£o √© f√°cil.  Portanto, a introdu√ß√£o de tantas ferramentas quanto poss√≠vel no n√≠vel de RPC √© uma boa id√©ia.  Um exemplo dessa API introspectiva <a href="">√© a solu√ß√£o Channelz</a> . <br><br><h3>  N√≠vel de aplica√ß√£o </h3><br>  Ser capaz de aprender as op√ß√µes no n√≠vel do aplicativo tamb√©m pode ser √∫til.  Um bom exemplo √© um terminal com informa√ß√µes gerais sobre o aplicativo (com um hash de arquivos de origem ou montagem, uma linha de comando etc.).  Ele pode ser usado por um sistema de orquestra√ß√£o para verificar a integridade ao implantar um servi√ßo. <br><br><h1>  Otimiza√ß√£o de desempenho </h1><br>  Ao expandir nossa estrutura de gRPC para a escala necess√°ria, encontramos v√°rios gargalos espec√≠ficos ao Dropbox. <br><br><h3>  Consumo de recursos do TLS Handshakes </h3><br>  Em servi√ßos que atendem a muitos relacionamentos, como resultado de handshakes TLS, a carga combinada da CPU pode ser bastante s√©ria (especialmente ao reiniciar um servi√ßo popular). <br><br>  Para melhorar o desempenho ao assinar, substitu√≠mos os pares de chaves RSA-2048 pelo ECDSA P-256.  Aqui est√£o exemplos de seu desempenho (nota: com o RSA, a verifica√ß√£o de assinatura √© mais r√°pida). <br><br>  <b>RSA:</b> <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'RSA 2048' Did ... RSA 2048 signing operations in ..............  (1527.9 ops/sec) Did ... RSA 2048 verify (same key) operations in .... (37066.4 ops/sec) Did ... RSA 2048 verify (fresh key) operations in ... (25887.6 ops/sec)</code> </pre> <br>  <b>ECDSA:</b> <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'ECDSA P-256' Did ... ECDSA P-256 signing operations in ... (40410.9 ops/sec) Did ... ECDSA P-256 verify operations in .... (17037.5 ops/sec)</code> </pre><br>  Como a verifica√ß√£o com o RSA-2048 √© cerca de tr√™s vezes mais r√°pida que com o ECDSA P-256, voc√™ pode escolher o RSA para certificados raiz e finais para aumentar a velocidade da opera√ß√£o.  Mas, do ponto de vista da seguran√ßa, nem tudo √© t√£o simples: voc√™ criar√° cadeias de v√°rias primitivas criptogr√°ficas e, portanto, o n√≠vel dos par√¢metros de seguran√ßa resultantes ser√° o mais baixo.  E se voc√™ deseja melhorar o desempenho, n√£o recomendamos o uso de certificados da vers√£o RSA-4096 (e superior) como certificados raiz e final. <br><br>  Tamb√©m descobrimos que a escolha de uma biblioteca TLS (e sinalizadores de compila√ß√£o) tem um impacto significativo no desempenho e na seguran√ßa.  Compare, por exemplo, o LibreSSL desenvolvido no macOS X Mojave com o OpenSSL auto-escrito no mesmo hardware. <br><br>  <b>LibreSSL 2.6.4:</b> <br><br><pre> <code class="plaintext hljs">~ openssl speed rsa2048 LibreSSL 2.6.4 ...                 sign verify sign/s verify/s rsa 2048 bits 0.032491s 0.001505s     30.8 664.3</code> </pre> <br>  <b>OpenSSL 1.1.1a:</b> <br><br><pre> <code class="plaintext hljs"> ~ openssl speed rsa2048 OpenSSL 1.1.1a  20 Nov 2018 ...                 sign verify sign/s verify/s rsa 2048 bits 0.000992s 0.000029s   1208.0 34454.8</code> </pre> <br>  No entanto, a maneira mais r√°pida de criar um handshake TLS √© n√£o cri√°-lo!  Inclu√≠mos suporte para o rein√≠cio da sess√£o no gRPC-core e no gRPC-python, reduzindo assim a carga na CPU durante a implanta√ß√£o. <br><br><h3>  A criptografia √© barata </h3><br>  Muitos acreditam erroneamente que a criptografia √© cara.  De fato, mesmo os computadores modernos mais simples executam criptografia sim√©trica quase instantaneamente.  Um processador padr√£o √© capaz de criptografar e autenticar dados a uma velocidade de 40 Gb / s por n√∫cleo: <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'AES' Did ... AES-128-GCM (8192 bytes) seal operations in ... 4534.4 MB/s</code> </pre> <br>  No entanto, ainda tivemos que configurar o gRPC para nossos blocos de mem√≥ria, operando a uma velocidade de 50 Gb / s.  Descobrimos que, se a velocidade de criptografia √© aproximadamente igual √† velocidade da c√≥pia, √© importante minimizar o n√∫mero de opera√ß√µes com <i>mem√≥ria incorreta.</i>  Al√©m disso, fizemos algumas altera√ß√µes no pr√≥prio gRPC. <br><br>  <i>Protocolos autenticados e criptografados evitaram muitos problemas desagrad√°veis ‚Äã‚Äã(por exemplo, corrup√ß√£o de dados pelo processador, DMA ou na rede).</i>  <i>Mesmo se voc√™ n√£o usar o gRPC, recomendamos o uso do TLS para contatos internos.</i> <br><br><h2>  Canais de dados de alta lat√™ncia (BDP) </h2><br>  Nota do tradutor: a legenda original usava o termo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">produto de atraso de largura de banda</a> , que n√£o possui uma tradu√ß√£o estabelecida para o russo. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A rede de backbone do Dropbox inclui muitos data centers</a> .  √Äs vezes, os n√≥s localizados em diferentes regi√µes precisam se comunicar via RPC, por exemplo, para replica√ß√£o.  Ao usar o TCP, o kernel do sistema √© respons√°vel por limitar a quantidade de dados transmitidos em uma conex√£o espec√≠fica (em / <i>proc / sys / net / ipv4 / tcp_ {r, w} mem</i> ), embora o gRPC baseado no HTTP / 2 tenha sua pr√≥pria ferramenta controle de fluxo.  O limite superior do BDP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no grpc-go √© estritamente limitado a 16 MB</a> , o que pode desencadear um gargalo. <br><br><h2>  net.Server Golang ou grpc.Server </h2><br>  Inicialmente, em nosso c√≥digo Go, suportamos HTTP / 1.1 e gRPC com um √∫nico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://golang.org/pkg/net/">net.Server</a> .  A solu√ß√£o fazia sentido em termos de manuten√ß√£o do c√≥digo do programa, mas n√£o funcionava perfeitamente.  Distribuir HTTP / 1.1 e gRPC entre servidores e migrar o gRPC para grpc.Server melhorou significativamente a largura de banda do Courier e o uso de mem√≥ria. <br><br><h2>  golang / protobuf ou gogo / protobuf </h2><br>  Mudar para o gRPC pode aumentar o custo de empacotamento e descompacta√ß√£o.  Para o c√≥digo Go, conseguimos reduzir significativamente a carga da CPU nos servidores Courier, mudando para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gogo / protobuf</a> . <br><br>  <i>Como sempre, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">transi√ß√£o para o gogo / protobuf foi acompanhada de algumas preocupa√ß√µes</a> , mas se voc√™ limitar razoavelmente a funcionalidade, n√£o haver√° problemas.</i> <br><br><h1>  Detalhes da implementa√ß√£o </h1><br>  Nesta se√ß√£o, abordaremos mais profundamente o dispositivo Courier, consideraremos esquemas de protobuf e exemplos de stubs de v√°rios idiomas.  Todos os exemplos s√£o retirados do servi√ßo de Teste, que usamos durante o teste de integra√ß√£o do Courier. <br><br><h2>  Descri√ß√£o do Servi√ßo </h2><br>  Veja um trecho da defini√ß√£o de servi√ßo de Teste: <br><br><pre> <code class="plaintext hljs">service Test {   option (rpc_core.service_default_deadline_ms) = 1000;   rpc UnaryUnary(TestRequest) returns (TestResponse) {       option (rpc_core.method_default_deadline_ms) = 5000;   }   rpc UnaryStream(TestRequest) returns (stream TestResponse) {       option (rpc_core.method_no_deadline) = true;   }   ... }</code> </pre> <br>  Como mencionado acima, √© necess√°rio um prazo para todos os m√©todos Courier.  Usando a op√ß√£o a seguir, voc√™ pode definir o prazo para todo o servi√ßo: <br><br><pre> <code class="plaintext hljs">option (rpc_core.service_default_deadline_ms) = 1000;</code> </pre> <br>  Ao mesmo tempo, cada m√©todo pode ser definido com seu pr√≥prio prazo, cancelando o prazo de todo o servi√ßo (se houver): <br><br><pre> <code class="plaintext hljs">option (rpc_core.method_default_deadline_ms) = 5000;</code> </pre> <br>  Em casos raros, quando o prazo n√£o faz sentido (por exemplo, ao rastrear um recurso), o desenvolvedor pode desativ√°-lo: <br><br><pre> <code class="plaintext hljs">option (rpc_core.method_no_deadline) = true;</code> </pre> <br>  Al√©m disso, a descri√ß√£o do servi√ßo deve conter documenta√ß√£o detalhada da API, possivelmente com exemplos de uso. <br><br><h2>  Gera√ß√£o Stub </h2><br>  Para fornecer maior flexibilidade, o Courier gera seus pr√≥prios stubs sem depender da funcionalidade do interceptador fornecida pelo gRPC (com exce√ß√£o do Java, no qual a API do interceptador tem energia suficiente).  Vamos comparar nossos stubs com os stubs Golang padr√£o. <br><br>  √â assim que os stubs padr√£o do servidor gRPC se parecem: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_UnaryUnary_Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(srv </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, ctx context.Context, dec </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interceptor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grpc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryServerInterceptor</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> {       in := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(TestRequest)       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := dec(in); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err       }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> interceptor == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srv.(TestServer).UnaryUnary(ctx, in)       }       info := &amp;grpc.UnaryServerInfo{               Server: srv,               FullMethod: <span class="hljs-string"><span class="hljs-string">"/test.Test/UnaryUnary"</span></span>,       }       handler := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srv.(TestServer).UnaryUnary(ctx, req.(*TestRequest))       }       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interceptor(ctx, in, info, handler) }</code> </pre> <br>  Todo o processamento ocorre dentro: decodifica√ß√£o do protobuf, iniciando interceptores (consulte a vari√°vel <code>interceptor</code> no c√≥digo), iniciando o manipulador UnaryUnary. <br><br>  Agora, d√™ uma olhada nos stubs Courier: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_UnaryUnary_dbxHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       srv </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{},       ctx context.Context,       dec </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">,       </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interceptor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grpc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryServerInterceptor</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{},       error)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> processor.PanicHandler()       impl := srv.(*dbxTestServerImpl)       metadata := impl.testUnaryUnaryMetadata       ctx = metadata.SetupContext(ctx)       clientId = client_info.ClientId(ctx)       stats := metadata.StatsMap.GetOrCreatePerClientStats(clientId)       stats.TotalCount.Inc()       req := &amp;processor.UnaryUnaryRequest{               Srv: srv,               Ctx: ctx,               Dec: dec,               Interceptor: interceptor,               RpcStats: stats,               Metadata: metadata,               FullMethodPath: <span class="hljs-string"><span class="hljs-string">"/test.Test/UnaryUnary"</span></span>,               Req: &amp;test.TestRequest{},               Handler: impl._UnaryUnary_internalHandler,               ClientId: clientId,               EnqueueTime: time.Now(),       }       metadata.WorkPool.Process(req).Wait()       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> req.Resp, req.Err }</code> </pre> <br>  H√° um pouco de c√≥digo aqui, ent√£o vamos analis√°-lo. <br><br>  Primeiro, adiamos a chamada para o manipulador de p√¢nico, respons√°vel por coletar erros automaticamente.  Isso nos permitir√° coletar todas as exce√ß√µes n√£o capturadas no reposit√≥rio central para posterior agrega√ß√£o e gera√ß√£o de relat√≥rios: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> processor.PanicHandler()</code> </pre><br>  Outra raz√£o pela qual executamos nosso pr√≥prio manipulador de p√¢nico √© garantir que o aplicativo falhe se ocorrer um erro.  O manipulador HTTP golang / net padr√£o, nesse caso, ignorar√° o problema e continuar√° a atender novas solicita√ß√µes (mesmo danificadas e inconsistentes). <br><br>  Em seguida, transmitimos o contexto, redefinindo os valores com base nos metadados da solicita√ß√£o recebida: <br><br><pre> <code class="go hljs">ctx = metadata.SetupContext(ctx) clientId = client_info.ClientId(ctx)</code> </pre> <br>  Tamb√©m criamos (e armazenamos em cache para aumentar a efici√™ncia) as estat√≠sticas do cliente do lado do servidor para agrega√ß√£o mais detalhada: <br><br><pre> <code class="go hljs">stats := metadata.StatsMap.GetOrCreatePerClientStats(clientId)</code> </pre><br>  Essa linha cria estat√≠sticas para cada cliente (ou seja, um identificador TLS) durante a execu√ß√£o.  Tamb√©m temos estat√≠sticas sobre todos os m√©todos para cada servi√ßo.  Como o gerador de stub tem acesso a todos os m√©todos durante a gera√ß√£o do c√≥digo, podemos cri√°-los estaticamente de antem√£o, evitando a lentid√£o do programa. <br><br>  Depois disso, criamos uma estrutura de solicita√ß√£o, transferimos para o conjunto de tarefas e aguardamos a execu√ß√£o: <br><br><pre> <code class="go hljs">req := &amp;processor.UnaryUnaryRequest{       Srv:        srv,       Ctx:        ctx,       Dec:        dec,       Interceptor:    interceptor,       RpcStats:       stats,       Metadata:       metadata,       ... } metadata.WorkPool.Process(req).Wait()</code> </pre> <br>  Observe que, neste ponto, n√£o decodificamos o protobuf nem lan√ßamos o interceptador.  Antes disso, o pool de acesso, a prioriza√ß√£o e a limita√ß√£o do n√∫mero de solicita√ß√µes executadas devem passar pelo pool de tarefas. <br><br>  <i>Observe que a biblioteca gRPC suporta a interface TAP, que permite interceptar solicita√ß√µes a uma velocidade tremenda.</i>  <i>A interface fornece a infraestrutura para a constru√ß√£o de limitadores de velocidade efetivos com consumo m√≠nimo de recursos.</i> <br><br><h2>  C√≥digos de erro espec√≠ficos para diferentes aplica√ß√µes </h2><br>  Nosso gerador de stub tamb√©m permite que os desenvolvedores atribuam c√≥digos de erro espec√≠ficos de aplicativos usando op√ß√µes especiais: <br><br><pre> <code class="plaintext hljs">enum ErrorCode { option (rpc_core.rpc_error) = true; UNKNOWN = 0; NOT_FOUND = 1 [(rpc_core.grpc_code)="NOT_FOUND"]; ALREADY_EXISTS = 2 [(rpc_core.grpc_code)="ALREADY_EXISTS"]; ... STALE_READ = 7 [(rpc_core.grpc_code)="UNAVAILABLE"]; SHUTTING_DOWN = 8 [(rpc_core.grpc_code)="CANCELLED"]; }</code> </pre> <br>  Os erros de gRPC e de aplicativo se propagam dentro do servi√ßo e, na borda da API, todos os erros s√£o substitu√≠dos por DESCONHECIDO.  Gra√ßas a isso, podemos evitar a transfer√™ncia do problema para outros servi√ßos, o que pode resultar em uma altera√ß√£o na sem√¢ntica. <br><br><h2>  Altera√ß√µes no Python </h2><br>  Os stubs do Python adicionam um par√¢metro de contexto expl√≠cito a todos os manipuladores do Courier: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dropbox.context <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Context <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dropbox.proto.test.service_pb2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> (       TestRequest,       TestResponse, ) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing_extensions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Protocol <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCourierClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Protocol)</span></span></span><span class="hljs-class">:</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryUnary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(           self,           ctx, # type: Context           request, # type: TestRequest           )</span></span></span><span class="hljs-function">:</span></span>       <span class="hljs-comment"><span class="hljs-comment"># type: (...) -&gt; TestResponse       ...</span></span></code> </pre> <br>  No come√ßo, parecia estranho, mas com o tempo, os desenvolvedores se acostumaram ao <i>ctx</i> expl√≠cito, como costumavam fazer. <br><br>  Observe que nossos stubs s√£o totalmente digitados para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mypy</a> , que √© compensado durante a refatora√ß√£o importante.  Al√©m disso, a integra√ß√£o com alguns IDEs (por exemplo, PyCharm) √© simplificada. <br><br>  Continuando a seguir a tend√™ncia para a digita√ß√£o est√°tica, adicionamos anota√ß√µes mypy aos pr√≥prios protocolos: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestMessage</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Message)</span></span></span><span class="hljs-class">:</span></span>   field: int   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,       field : Optional[int] = ...,       )</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> ...   @staticmethod   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: bytes)</span></span></span><span class="hljs-function"> -&gt; TestMessage:</span></span> ...</code> </pre> <br>  Essas anota√ß√µes evitar√£o muitos erros comuns, como atribuir um valor <i>Nenhum a um</i> campo do tipo <i>string</i> , por exemplo <i>.</i> <br><br>  Este c√≥digo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">est√° dispon√≠vel aqui</a> . <br><br><h1>  Processo de migra√ß√£o </h1><br>  Criar uma nova pilha RPC n√£o √© uma tarefa f√°cil, mas n√£o fica nem ao lado do processo de uma transi√ß√£o completa para ela, se voc√™ observar do ponto de vista da complexidade operacional.  Portanto, tentamos facilitar ao m√°ximo a mudan√ßa dos desenvolvedores do RPC antigo para o Courier.  Como a migra√ß√£o geralmente √© acompanhada de erros, decidimos implement√°-la em etapas. <br><br><h2>  Etapa 0: congelar o RPC antigo </h2><br>  Antes de tudo, congelamos o antigo RPC para n√£o atirar em um alvo em movimento.  Isso tamb√©m levou as pessoas a mudarem para o Courier, porque todos os novos recursos, como rastreamento, estavam dispon√≠veis apenas nos servi√ßos do Courier. <br><br><h2>  Etapa 1: interface comum para RPC e Courier antigos </h2><br>  Come√ßamos definindo uma interface comum para o antigo RPC e Courier.  Nossa gera√ß√£o de c√≥digo deveria garantir que ambas as vers√µes dos stubs correspondessem a esta interface: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TestServer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> {  UnaryUnary(     ctx context.Context,     req *test.TestRequest) (     *test.TestResponse,     error)  ... }</code> </pre><br><h2>  Etapa 2: migrar para a nova interface </h2><br>  Depois disso, come√ßamos a mudar cada servi√ßo para uma nova interface, enquanto continuamos usando o RPC antigo.  Freq√ºentemente, as altera√ß√µes de c√≥digo eram uma grande diferen√ßa, afetando todos os m√©todos do servi√ßo e seus clientes.  Como esse est√°gio √© o mais problem√°tico, quer√≠amos eliminar completamente o risco alterando apenas uma coisa de cada vez. <br><br>  <i>Servi√ßos simples com um pequeno n√∫mero de m√©todos e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">direito de cometer erros</a> podem ser migrados simultaneamente, sem prestar aten√ß√£o aos nossos avisos.</i> <br><br><h2>  Etapa 3: migrar clientes para o RPC Courier </h2><br>  Durante o processo de migra√ß√£o, come√ßamos a lan√ßar simultaneamente servidores antigos e novos em portas diferentes da mesma m√°quina.  A mudan√ßa da implementa√ß√£o de RPC do lado do cliente foi feita alterando uma linha: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> -   self.client = LegacyRPCClient(<span class="hljs-string"><span class="hljs-string">'myservice'</span></span>) +   self.client = CourierRPCClient(<span class="hljs-string"><span class="hljs-string">'myservice'</span></span>)</code> </pre> <br>  Observe que, com este modelo, voc√™ pode transferir um cliente por vez, come√ßando com aqueles com um n√≠vel mais baixo de SLA. <br><br><h2>  Etapa 4: limpeza </h2><br>       ,   ,   RPC    (               ).       ‚Äî   . <br><br><h1>  Conclus√µes </h1><br> , Courier ‚Äî  RPC-,   ,      Dropbox. <br><br>     ,    Courier: <br><br><ol><li>  ‚Äî  .           . <br></li><li>      ‚Äî    ,     . <br></li><li>     ,  .     Codegen. <br></li><li>    . ,    ,   .  , :       . <br></li><li>  RPC-       ‚Äî  ,     . .           . <br></li></ol><br><h1>   </h1><br> Courier,   gRPC  ,    ,      ,      . <br><br>         gRPC  Python   ,     C++  Python  Rust          .         ALTS   TLS-    (,     ). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438474/">https://habr.com/ru/post/pt438474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438464/index.html">SciPy, algoritmos de gr√°ficos</a></li>
<li><a href="../pt438466/index.html">Muleta para um laser chin√™s</a></li>
<li><a href="../pt438468/index.html">Col√¥nia. Cap√≠tulo 23: Test Drive</a></li>
<li><a href="../pt438470/index.html">Vendas mundiais em dezembro e 2018: 2 milh√µes de ve√≠culos el√©tricos plug-in vendidos</a></li>
<li><a href="../pt438472/index.html">Ambiente arquitet√¥nico modular sofisticado no UE4</a></li>
<li><a href="../pt438476/index.html">Para a quest√£o dos amortecedores (anel)</a></li>
<li><a href="../pt438478/index.html">GitLab 11.7 lan√ßado com lan√ßamentos, √©picos aninhados em v√°rios n√≠veis e o registro de pacotes NPM</a></li>
<li><a href="../pt438480/index.html">Coloque da maneira certa: 7 lugares ideais para colocar conte√∫do de v√≠deo</a></li>
<li><a href="../pt438482/index.html">Reputa√ß√£o, trabalho e emigra√ß√£o: como usar as ferramentas de promo√ß√£o da empresa para resolver problemas pessoais</a></li>
<li><a href="../pt438486/index.html">Cart√£o de mem√≥ria impenetr√°vel - afogue, congele e atire na Kingston microSD High Endurance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>