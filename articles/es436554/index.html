<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïî üï∞Ô∏è üë®‚Äçüöí Transfiera 30,000 l√≠neas de c√≥digo de Flow a TypeScript ü§® üíê üöù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente trasladamos 30,000 l√≠neas de c√≥digo JavaScript de nuestro sistema MemSQL Studio de Flow a TypeScript. En este art√≠culo explicar√© por qu√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Transfiera 30,000 l√≠neas de c√≥digo de Flow a TypeScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436554/">  Recientemente trasladamos 30,000 l√≠neas de c√≥digo JavaScript de nuestro sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MemSQL Studio</a> de Flow a TypeScript.  En este art√≠culo explicar√© por qu√© portamos el c√≥digo base, c√≥mo sucedi√≥ y qu√© sucedi√≥. <br><br>  <i>Descargo de responsabilidad: mi objetivo no es criticar a Flow en absoluto.</i>  <i>Admiro el proyecto y creo que hay suficiente espacio en la comunidad de JavaScript para ambas opciones de verificaci√≥n de tipos.</i>  <i>Al final, todos elegir√°n lo que m√°s le convenga.</i>  <i>Sinceramente espero que el art√≠culo ayude en esta elecci√≥n.</i> <br><br>  Primero, te pondr√© al d√≠a.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MemSQL somos</a> grandes admiradores de la escritura JavaScript est√°tica y fuerte para evitar problemas comunes con la escritura din√°mica y d√©bil. <br><a name="habracut"></a><br>  Discurso sobre problemas comunes: <br><br><ol><li>  Errores de tipo en tiempo de ejecuci√≥n debido al hecho de que las diferentes partes del c√≥digo no coinciden con los tipos impl√≠citos. </li><li>  Se dedica demasiado tiempo a escribir pruebas para cosas tan triviales como verificar par√°metros de tipo (verificar en tiempo de ejecuci√≥n tambi√©n aumenta el tama√±o del paquete). </li><li> Hay una falta de integraci√≥n editor / IDE, porque sin tipeo est√°tico es mucho m√°s dif√≠cil implementar la funci√≥n Jump to Definition, la refactorizaci√≥n mec√°nica y otras funciones. </li><li>  No hay forma de escribir c√≥digo alrededor de modelos de datos, es decir, primero dise√±ar tipos de datos y luego el c√≥digo b√°sicamente "se escribe". </li></ol><br>  Estos son solo algunos de los beneficios del tipeo est√°tico, que se detallan en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo reciente sobre Flow</a> . <br><br>  A principios de 2016, implementamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tcomb</a> para implementar alg√∫n tipo de seguridad en el tiempo de ejecuci√≥n de uno de nuestros proyectos internos de JavaScript (descargo de responsabilidad: no particip√© en este proyecto).  Aunque la verificaci√≥n en tiempo de ejecuci√≥n a veces es √∫til, ni siquiera proporciona todos los beneficios de la escritura est√°tica (la combinaci√≥n de escritura est√°tica y verificaci√≥n de tipos en tiempo de ejecuci√≥n puede ser adecuada para ciertos casos, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">io-ts le</a> permite hacer esto con tcomb y TypeScript, aunque nunca lo intent√© )  Entendiendo esto, decidimos implementar Flow para otro proyecto que comenzamos en 2016.  En ese momento, Flow parec√≠a una gran opci√≥n: <br><br><ul><li>  Apoyo de Facebook, que ha hecho un trabajo incre√≠ble desarrollando React y haciendo crecer la comunidad (tambi√©n desarrollaron React <i>with</i> Flow). </li><li>  Aproximadamente el mismo ecosistema de desarrollo de JavaScript.  Daba miedo abandonar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Babel</a> por tsc (compilador TypeScript) porque hab√≠amos perdido la flexibilidad de cambiar a otro tipo de verificaci√≥n (obviamente, la situaci√≥n ha cambiado desde entonces). </li><li>  No es necesario tipificar toda la base de c√≥digo (quer√≠amos tener una idea de JavaScript est√°ticamente tipado antes de incluirlo todo), pero solo una parte de los archivos.  Tenga en cuenta que tanto Flow como TypeScript ahora lo permiten. </li><li>  TypeScript (en ese momento) carec√≠a de algunas de las funciones b√°sicas que ahora est√°n disponibles, estos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">son tipos de b√∫squeda</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">par√°metros predeterminados para tipos gen√©ricos</a> , etc. </li></ul><br>  Cuando comenzamos a trabajar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MemSQL Studio</a> a fines de 2017, √≠bamos a cubrir los tipos de la aplicaci√≥n completa (est√° completamente escrita en JavaScript: tanto el frontend como el backend se ejecutan en el navegador).  Tomamos Flow como una herramienta que hemos utilizado con √©xito en el pasado. <br><br>  Pero me llam√≥ la atenci√≥n <a href="">Babel 7 con soporte TypeScript</a> .  Esta versi√≥n significaba que cambiar a TypeScript ya no requer√≠a una transici√≥n a todo el ecosistema de TypeScript, y pod√≠a seguir usando Babel para JavaScript.  M√°s importante a√∫n, podr√≠amos <b>usar TypeScript solo para la verificaci√≥n de tipos</b> , y no como un "lenguaje" completo. <br><br>  Personalmente, creo que separar la verificaci√≥n de tipos del generador de c√≥digo es una forma m√°s elegante de escribir est√°tica (y fuerte) en JavaScript, porque: <br><br><ol><li>  Compartimos los problemas de c√≥digo y mecanograf√≠a.  Esto reduce las paradas de verificaci√≥n de tipos y acelera el desarrollo: si por alguna raz√≥n la verificaci√≥n de tipos es lenta, el c√≥digo se generar√° correctamente (si usa tsc con Babel, puede configurarlo para que haga lo mismo). </li><li>  Babel tiene excelentes complementos y caracter√≠sticas que el generador TypeScript no tiene.  Por ejemplo, Babel le permite especificar navegadores compatibles y emitir√° autom√°ticamente c√≥digo para ellos.  Esta es una funci√≥n muy compleja y no tiene sentido apoyarla en dos proyectos diferentes al mismo tiempo. </li><li>  Me gusta JavaScript como lenguaje de programaci√≥n (excepto por la falta de tipeo est√°tico), y no tengo idea de cu√°nto existir√° TypeScript, aunque creo en muchos a√±os de ECMAScript.  Por lo tanto, prefiero escribir y "pensar" en JavaScript (tenga en cuenta que digo "use Flow" o "use TypeScript" en lugar de "escribir en Flow" o "TypeScript", porque siempre los represento con herramientas, no con lenguajes de programaci√≥n). </li></ol><br>  Por supuesto, este enfoque tiene algunas desventajas: <br><br><ol><li>  El compilador de TypeScript te√≥ricamente puede realizar optimizaciones basadas en tipos, pero aqu√≠ perdemos esa oportunidad. </li><li>  La configuraci√≥n del proyecto es un poco m√°s complicada con un aumento en el n√∫mero de herramientas y dependencias.  Creo que este es un argumento relativamente d√©bil: un mont√≥n de Babel y Flow nunca nos han defraudado. </li></ol><br><h1>  TypeScript como alternativa a Flow </h1><br>  Not√© un creciente inter√©s en TypeScript en la comunidad JavaScript: tanto en l√≠nea como entre los desarrolladores que lo rodean.  Por lo tanto, tan pronto como descubr√≠ que Babel 7 es compatible con TypeScript, inmediatamente comenc√© a estudiar posibles opciones de transici√≥n.  Adem√°s, encontramos algunas de las desventajas de Flow: <br><br><ol><li>  Menor calidad de integraci√≥n editor / IDE (en comparaci√≥n con TypeScript).  Nuclide, el IDE propio de Facebook con la mejor integraci√≥n, ya est√° desactualizado. </li><li>  Una comunidad m√°s peque√±a, lo que significa menos definiciones de tipo para diferentes bibliotecas, y son de menor calidad (actualmente el repositorio DefinitelyTyped tiene 19 682 estrellas GitHub, y el repositorio de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tipo flujo</a> tiene solo 3070). </li><li>  Falta de un plan de desarrollo p√∫blico y poca interacci√≥n entre el equipo de Flow en Facebook y la comunidad.  Puede leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este comentario</a> de un empleado de Facebook para comprender la situaci√≥n. </li><li>  Alto consumo de memoria y fugas frecuentes: para algunos de nuestros desarrolladores, Flow a veces ocupaba casi 10 GB de RAM. </li></ol><br>  Por supuesto, debe estudiar c√≥mo TypeScript nos conviene.  Esta es una pregunta muy compleja: el estudio del tema incluy√≥ una lectura exhaustiva de la documentaci√≥n, lo que ayud√≥ a comprender que para cada funci√≥n de Flow hay un TypeScript equivalente.  Luego explor√© el plan de desarrollo p√∫blico de TypeScript, y realmente me gustaron las caracter√≠sticas que est√°n planificadas para el futuro (por ejemplo, derivaci√≥n parcial de los argumentos de tipo que usamos en Flow). <br><br><h1>  Transfiera m√°s de 30 mil l√≠neas de c√≥digo de Flow a TypeScript </h1><br>  Para empezar, debe actualizar Babel de 6 a 7. Esta tarea simple tom√≥ 16 horas-hombre, ya que decidimos actualizar Webpack 3 a 4. Al mismo tiempo. Algunas dependencias obsoletas en nuestro c√≥digo complicaron la tarea.  La gran mayor√≠a de los proyectos de JavaScript no tendr√°n tales problemas. <br><br>  Despu√©s de eso, reemplazamos el preset de Babel Flow con el nuevo preset de TypeScript, y luego, por primera vez, lanzamos el compilador de TypeScript en todas nuestras fuentes escritas usando Flow.  El resultado son <b>8245 errores de sintaxis</b> (tsc CLI no muestra errores reales para el proyecto hasta que se hayan corregido todos los errores de sintaxis). <br><br>  Al principio, este n√∫mero nos asust√≥ (muy), pero r√°pidamente nos dimos cuenta de que la mayor√≠a de los errores se deb√≠an a que TypeScript no admit√≠a archivos .js.  Despu√©s de estudiar el tema, aprend√≠ que los archivos TypeScript deber√≠an terminar con .ts o .tsx (si tienen JSX).  Esto me parece un claro inconveniente.  Para no pensar en la presencia / ausencia de JSX, simplemente cambi√© el nombre de todos los archivos a .tsx. <br><br>  Quedan unos 4.000 errores de sintaxis.  La mayor√≠a de ellos est√°n relacionados con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tipo de importaci√≥n</a> , que con TypeScript se puede reemplazar simplemente con importaci√≥n, as√≠ como con la diferencia en la designaci√≥n de objetos ( <code>{||}</code> lugar de <code>{}</code> ).  Aplicando r√°pidamente un par de expresiones regulares, dejamos 414 errores de sintaxis.  Todo lo dem√°s ten√≠a que repararse manualmente: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El tipo existencial</a> , que usamos para derivar parcialmente los argumentos de un tipo gen√©rico, debe reemplazarse por argumentos expl√≠citos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desconocidos</a> para indicar a TypeScript que algunos argumentos no son importantes. </li><li>  Las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">teclas de</a> tipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">$</a> y otros tipos de flujo avanzados tienen una sintaxis diferente en TypeScript (por ejemplo, <code>$Shape‚Äú‚Äù</code> corresponde a <code>Partial‚Äú‚Äù</code> en TypeScript). </li></ul><br>  Despu√©s de corregir todos los errores de sintaxis, tsc finalmente dijo cu√°ntos errores de tipo real en nuestra base de c√≥digo son solo alrededor de 1300. Ahora tuvimos que sentarnos y decidir si continuar o no.  Despu√©s de todo, si la migraci√≥n lleva semanas, es mejor permanecer en Flow.  Sin embargo, decidimos que la transferencia de c√≥digo requerir√≠a menos de una semana de trabajo por parte de un ingeniero, lo cual es bastante aceptable. <br><br>  Tenga en cuenta que durante la migraci√≥n tuve que detener todo el trabajo en esta base de c√≥digo.  Sin embargo, en paralelo puede comenzar nuevos proyectos, pero debe tener en cuenta potencialmente cientos de errores de tipo en el c√≥digo existente, lo que no es f√°cil. <br><br><h1>  ¬øQu√© tipo de errores? </h1><br>  TypeScript y Flow procesan el c√≥digo JavaScript de muchas maneras.  Entonces, Flow es m√°s estricto en relaci√≥n con algunas cosas y TypeScript, en relaci√≥n con otras.  Una comparaci√≥n profunda de los dos sistemas ser√° muy larga, as√≠ que solo mire algunos ejemplos. <br><br>  Nota: todos los enlaces al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">entorno limitado de TypeScript</a> asumen par√°metros "estrictos".  Desafortunadamente, cuando comparte un enlace, estas opciones no se almacenan en la URL.  Por lo tanto, deben configurarse manualmente despu√©s de abrir cualquier enlace al sandbox de este art√≠culo. <br><br><h3>  invariant.js </h3><br>  La funci√≥n <code>invariant</code> result√≥ ser muy com√∫n en nuestro c√≥digo fuente.  Solo para citar la documentaci√≥n: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> invariant = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'invariant'</span></span>); invariant(someTruthyVal, <span class="hljs-string"><span class="hljs-string">'This will not throw'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// No errors invariant(someFalseyVal, 'This will throw an error with this message'); // Error raised: Invariant Violation: This will throw an error with this message</span></span></code> </pre> <br>  La idea es clara: una funci√≥n simple que arroja un error en alguna condici√≥n.  Veamos c√≥mo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementarlo y usarlo</a> en Flow: <br><br><pre> <code class="javascript hljs">type Maybe&lt;T&gt; = T | <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invariant</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">condition: boolean, message: string</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!condition) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(message); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x: Maybe&lt;number&gt;, c: number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { invariant(x !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-string"><span class="hljs-string">"When c is positive, x should never be undefined"</span></span>); (x + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// works because x has been refined to "number" } }</span></span></code> </pre> <br>  Ahora <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cargue el mismo fragmento en TypeScript</a> .  Como puede ver en el enlace, TypeScript da un error, ya que no puede entender que <code>x</code> garantice que <code>x</code> no permanecer√° <code>undefined</code> despu√©s de la √∫ltima l√≠nea.  Este es realmente un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problema bien conocido</a> : TypeScript (por ahora) no sabe c√≥mo hacer esta inferencia a trav√©s de una funci√≥n.  Sin embargo, esta es una plantilla muy com√∫n en nuestra base de c√≥digo, por lo que tuve que reemplazar manualmente cada instancia invariante (m√°s de 150 piezas) con otro c√≥digo que inmediatamente produce un error: <br><br><pre> <code class="javascript hljs">type Maybe&lt;T&gt; = T | <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x: Maybe&lt;number&gt;, c: number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"When c is positive, x should never be undefined"</span></span>); } (x + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// works because x has been refined to "number" } }</span></span></code> </pre> <br>  Realmente no se compara con <code>invariant</code> , pero no es un tema tan importante. <br><br><h3>  $ ExpectError vs @ ts-ignore </h3><br>  Flow tiene una funci√≥n muy interesante, similar a <code>@ts-ignore</code> , excepto que arroja un error si la siguiente l√≠nea <b>no</b> es un error.  Esto es muy √∫til para escribir ‚Äúpruebas de tipo‚Äù que aseguran que la verificaci√≥n de tipo (ya sea TypeScript o Flow) encuentre ciertos errores de tipo. <br><br>  Desafortunadamente, TypeScript no tiene esa funci√≥n, por lo que nuestras pruebas han perdido algo de valor.  Espero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementar esta funci√≥n en TypeScript</a> . <br><br><h3>  Errores de tipo gen√©rico e inferencia de tipo </h3><br>  A menudo, TypeScript permite un c√≥digo m√°s expl√≠cito que Flow, como en este ejemplo: <br><br><pre> <code class="javascript hljs">type Leaf = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: string; port: number; type: <span class="hljs-string"><span class="hljs-string">"LEAF"</span></span>; }; type Aggregator = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: string; port: number; type: <span class="hljs-string"><span class="hljs-string">"AGGREGATOR"</span></span>; } type MemsqlNode = Leaf | Aggregator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">leaves: Array&lt;Leaf&gt;, aggregators: Array&lt;Aggregator&gt;</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Array</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MemsqlNode</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// The next line errors because you cannot concat aggregators to leaves. return leaves.concat(aggregators); }</span></span></code> </pre> <br>  El flujo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">infiere el tipo leaves.concat (agregadores) como Array &lt;Leaf |</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aggregator&gt;</a> , que luego se puede <code>Array&lt;MemsqlNode&gt;</code> en <code>Array&lt;MemsqlNode&gt;</code> .  Creo que este es un buen ejemplo en el que Flow puede ser un poco m√°s inteligente y TypeScript necesita un poco de ayuda: en este caso podemos aplicar una aserci√≥n de tipo, pero esto es peligroso y debe hacerse con mucho cuidado. <br><br>  Aunque no tengo evidencia formal, creo que Flow es muy superior a TypeScript en inferencia de tipos.  Realmente espero que TypeScript alcance el nivel de flujo, ya que el lenguaje se est√° desarrollando muy activamente, y se han realizado muchas mejoras recientes en esta √°rea.  En muchos lugares de nuestro c√≥digo, TypeScript tuvo que ayudar un poco a trav√©s de anotaciones o aserciones de tipo, aunque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">evitamos lo √∫ltimo</a> tanto como sea posible).  Consideremos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un ejemplo m√°s</a> (tuvimos m√°s de 200 errores de este tipo): <br><br><pre> <code class="javascript hljs">type Player = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string; age: number; position: <span class="hljs-string"><span class="hljs-string">"STRIKER"</span></span> | <span class="hljs-string"><span class="hljs-string">"GOALKEEPER"</span></span>, }; type F = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;Player&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f1: F = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"David Gomes"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-attr"><span class="hljs-attr">position</span></span>: <span class="hljs-string"><span class="hljs-string">"GOALKEEPER"</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Cristiano Ronaldo"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">33</span></span>, <span class="hljs-attr"><span class="hljs-attr">position</span></span>: <span class="hljs-string"><span class="hljs-string">"STRIKER"</span></span>, } ]); };</code> </pre> <br>  TypeScript no le permitir√° escribir esto porque no le permitir√° declarar <code>{ name: "David Gomes", age: 23, type: "GOALKEEPER" }</code> como un objeto de tipo <code>Player</code> (vea el sandbox para el error exacto).  Este es otro caso en el que encuentro que TypeScript no es lo suficientemente inteligente (al menos en comparaci√≥n con Flow, que comprende este c√≥digo). <br><br>  Hay varias opciones para arreglar esto: <br><br><ul><li>  Declare que <code>"STRIKER"</code> es <code>"STRIKER"</code> para que TypeScript comprenda que la cadena es una enumeraci√≥n v√°lida de tipo <code>"STRIKER" | "GOALKEEPER"</code>  <code>"STRIKER" | "GOALKEEPER"</code> . </li><li>  Declarar todos los objetos como <code>Player</code> . </li><li>  O lo que considero la mejor soluci√≥n: solo ayude a TypeScript sin usar ninguna declaraci√≥n de tipo escribiendo <code>Promise.all&lt;Player&gt;(...)</code> . </li></ul><br>  Aqu√≠ hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">otro ejemplo</a> (TypeScript) donde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Flow es nuevamente mejor en la inferencia de tipos</a> : <br><br><pre> <code class="javascript hljs">type Connection = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: number }; declare <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Connection</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resolve(getConnection()); }) } resolveConnection().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">conn</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// TypeScript errors in the next line because it does not understand // that conn is of type Connection. We have to manually annotate // resolveConnection as Promise&lt;Connection&gt;. (conn.id); });</span></span></code> </pre> <br>  Un ejemplo muy peque√±o pero interesante: Flow considera que <code>Array&lt;T&gt;.pop()</code> tipo <code>T</code> , y TypeScript lo considera <code>T | void</code>  <code>T | void</code>  Un punto a favor de TypeScript, porque te obliga a verificar la existencia de un elemento (si la matriz est√° vac√≠a, entonces <code>Array.pop</code> devuelve <code>undefined</code> ).  Hay varios otros peque√±os ejemplos como este donde TypeScript es superior a Flow. <br><br><h3>  Definiciones de TypeScript para dependencias de terceros </h3><br>  Por supuesto, al escribir cualquier aplicaci√≥n de JavaScript, tendr√° al menos algunas dependencias.  Deben estar escritos, de lo contrario perder√° la mayor√≠a de las posibilidades de an√°lisis de tipo est√°tico (como se describe al principio del art√≠culo). <br><br>  Las bibliotecas de npm pueden venir con definiciones de tipo Flow o TypeScript, con o sin ambas.  Muy a menudo, las bibliotecas (peque√±as) no se suministran con una u otra, por lo que debe escribir sus propias definiciones de tipo o pedirlas prestadas a la comunidad.  Tanto Flow como TypeScript admiten repositorios de definici√≥n est√°ndar para paquetes JavaScript de terceros: estos son de tipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">flujo</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DefinitelyTyped</a> . <br><br>  Debo decir que DefinitelyTyped nos gust√≥ mucho m√°s.  Con flow-typed, tuve que usar la herramienta CLI para introducir definiciones de tipo para varias dependencias en el proyecto.  DefinitelyTyped combina esta funci√≥n con la herramienta npm CLI enviando <code>@types/package-name</code> al repositorio de paquetes npm.  Esto es muy bueno y simplific√≥ enormemente la entrada de definiciones de tipos para nuestras dependencias (broma, reacci√≥n, lodash, reacci√≥n-reducci√≥n, estas son solo algunas). <br><br>  Adem√°s, la pas√© muy bien llenando la base de datos DefinitelyTyped (no creo que las definiciones de tipo sean equivalentes al portar c√≥digo de Flow a TypeScript).  Ya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">he</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enviado</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algunas</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solicitudes de extracci√≥n</a> , y no hubo problemas en ning√∫n lado.  Simplemente clone el repositorio, edite definiciones de tipo, agregue pruebas y env√≠e una solicitud de extracci√≥n.  El bot DefinitelyTyped GitHub marca a los autores de las definiciones que edit√≥.  Si ninguno de ellos proporciona comentarios dentro de los 7 d√≠as, la solicitud de extracci√≥n se env√≠a para su consideraci√≥n al responsable del mantenimiento.  Despu√©s de fusionarse con la rama principal, se env√≠a una nueva versi√≥n del paquete de dependencia a npm.  Por ejemplo, cuando actualic√© por primera vez el paquete @ types / redux-form, la versi√≥n 7.4.14 se envi√≥ autom√°ticamente a npm.  as√≠ que simplemente actualice el archivo package.json para obtener nuevas definiciones de tipo.  Si no puede esperar la adopci√≥n de la solicitud de extracci√≥n, siempre puede cambiar las definiciones de los tipos que se utilizan en su proyecto, como se describe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en uno de los art√≠culos anteriores</a> . <br><br>  En general, la calidad de las definiciones de tipo en DefinitelyTyped es mucho mejor debido a la comunidad TypeScript m√°s grande y pr√≥spera.  De hecho, despu√©s de que el proyecto se transfiri√≥ a TypeScript <b>, nuestra cobertura de tipos aument√≥ de 88% a 96%</b> , principalmente debido a mejores definiciones de tipos de dependencia de terceros, con menos tipos. <br><br><h1>  Linting y pruebas </h1><br><ol><li>  Cambiamos de eslint a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tslint</a> (con eslint para TypeScript, parec√≠a m√°s dif√≠cil comenzar). </li><li>  Las pruebas de TypeScript usan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ts-jest</a> .  Algunas de las pruebas se escriben, mientras que otras no (si se escriben durante demasiado tiempo, las guardamos como archivos .js). </li></ol><br><h1>  ¬øQu√© pas√≥ despu√©s de corregir todos los errores de escritura? </h1><br>  Despu√©s de 40 horas-hombre de trabajo, llegamos al √∫ltimo error de escritura, posponi√©ndolo por un tiempo usando <code>@ts-ignore</code> . <br><br>  Despu√©s de revisar los comentarios de revisi√≥n de c√≥digo y corregir un par de errores (desafortunadamente, tuve que cambiar un poco el c√≥digo de tiempo de ejecuci√≥n para corregir la l√≥gica que TypeScript no pod√≠a entender) la solicitud de extracci√≥n desapareci√≥, y desde entonces hemos estado usando TypeScript.  (Y s√≠, arreglamos el √∫ltimo <code>@ts-ignore</code> en la pr√≥xima solicitud de extracci√≥n). <br><br>  Adem√°s de la integraci√≥n con el editor, trabajar con TypeScript es muy similar a trabajar con Flow.  El rendimiento del servidor de flujo es ligeramente mayor, pero este no es un gran problema, ya que generan errores para el archivo actual con la misma rapidez.  La √∫nica diferencia de rendimiento es que TypeScript informa un nuevo error despu√©s de guardar el archivo un poco m√°s tarde (por 0.5-1 s).  El tiempo de inicio del servidor es aproximadamente el mismo (aproximadamente 2 minutos), pero no es tan importante.  Hasta ahora, no hemos tenido ning√∫n problema con el consumo de memoria.  Parece que tsc usa constantemente alrededor de 600 MB. <br><br>  Puede parecer que la funci√≥n de inferencia de tipo le da a Flow una gran ventaja, pero hay dos razones por las que realmente no importa: <br><br><ol><li>  Convertimos la base del c√≥digo de flujo a TypeScript.  Obviamente, encontramos solo ese c√≥digo que Flow puede expresar, pero TypeScript no.  Si la migraci√≥n hubiera ocurrido en la direcci√≥n opuesta, estoy seguro de que habr√≠a cosas que TypeScript mejor muestra / expresa. </li><li>  La inferencia de tipos es importante para ayudar a escribir c√≥digo m√°s conciso.  Pero de todos modos, otras cosas son m√°s importantes, como una comunidad fuerte y la disponibilidad de definiciones de tipo, porque la inferencia de tipo d√©bil se puede solucionar al pasar un poco m√°s de tiempo escribiendo. </li></ol><br><h3>  Estad√≠sticas de c√≥digo </h3><br><pre> <code class="bash hljs">$ npm run <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>-coverage <span class="hljs-comment"><span class="hljs-comment"># https://github.com/plantain-00/type-coverage 43330 / 45047 96.19% $ cloc # ignoring tests and dependencies -------------------------------------------------------------------------------- Language files blank comment code -------------------------------------------------------------------------------- TypeScript 330 5179 1405 31463</span></span></code> </pre> <br><h1>  Que sigue </h1><br>  No hemos terminado de mejorar el an√°lisis de tipo est√°tico.  MemSQL tiene otros proyectos que eventualmente cambiar√°n de Flow a TypeScript (y algunos proyectos de JavaScript que comenzar√°n a usar TypeScript), y queremos que nuestra configuraci√≥n de TypeScript sea m√°s rigurosa.  Actualmente tenemos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habilitada la</a> opci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">strictlyNullChecks</a> , pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">noImplicitAny</a> todav√≠a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">est√°</a> deshabilitado.  Tambi√©n eliminaremos un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">par de declaraciones de tipo peligroso</a> del c√≥digo. <br><br>  Me alegra compartir contigo todo lo que aprend√≠ durante mis aventuras escribiendo JavaScript.  Si est√° interesado en un tema espec√≠fico, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">h√°gamelo saber</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436554/">https://habr.com/ru/post/es436554/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436544/index.html">Marketplace responder√° por todo</a></li>
<li><a href="../es436546/index.html">Desarrollo de un equipo para consultar datos de la base de datos - parte 3</a></li>
<li><a href="../es436548/index.html">Programa de educaci√≥n en realidad virtual</a></li>
<li><a href="../es436550/index.html">Gracias al robot, los cient√≠ficos aprendieron c√≥mo camin√≥ uno de los primeros habitantes del sushi.</a></li>
<li><a href="../es436552/index.html">Obituario a la muerte de Chromecast Audio o por qu√© Google mat√≥ unidades negras</a></li>
<li><a href="../es436556/index.html">Empleos en una empresa alemana: ¬øc√≥mo presentar una solicitud y no obtener un rechazo?</a></li>
<li><a href="../es436558/index.html">Feliz 18 cumplea√±os, Wikipedia; celebrando la mayor√≠a de edad de un buen proyecto</a></li>
<li><a href="../es436560/index.html">Protocolos criptogr√°ficos para votaci√≥n electr√≥nica.</a></li>
<li><a href="../es436564/index.html">C√≥mo funciona ProGuard</a></li>
<li><a href="../es436568/index.html">Plataforma de video propia o c√≥mo tomar muchos recursos inform√°ticos. Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>