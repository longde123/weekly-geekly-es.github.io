<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüëß üéê ü§™ Detectores e descritores de pontos singulares FAST, BREVE, ORB üìâ ü§∞üèæ üëäüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo abordar√° alguns algoritmos de pesquisa e descri√ß√µes de pontos de imagem espec√≠ficos. Aqui, este t√≥pico j√° foi levantado e mais de uma vez ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Detectores e descritores de pontos singulares FAST, BREVE, ORB</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414459/">  Este artigo abordar√° alguns algoritmos de pesquisa e descri√ß√µes de pontos de imagem espec√≠ficos.  Aqui, este t√≥pico j√° foi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">levantado</a> e mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de uma vez</a> .  Considerarei que as defini√ß√µes b√°sicas j√° s√£o familiares para o leitor, examinaremos detalhadamente os algoritmos heur√≠sticos FAST, FAST-9, FAST-ER, BREVE, rRIVE, ORB e discutiremos as id√©ias cintilantes subjacentes a eles.  Em parte, esta ser√° uma tradu√ß√£o livre da ess√™ncia de v√°rios artigos [1,2,3,4,5]; haver√° algum c√≥digo para "try". <br><br><img src="https://pp.userapi.com/c846418/v846418322/73b6d/09CAYMQuFMs.jpg" alt="imagem"><br><a name="habracut"></a><br><h1>  Algoritmo R√ÅPIDO </h1><br>  O FAST, proposto pela primeira vez em 2005 em [1], foi um dos primeiros m√©todos heur√≠sticos para encontrar pontos singulares, que ganharam grande popularidade devido √† sua efici√™ncia computacional.  Para tomar uma decis√£o sobre considerar um determinado ponto C como especial ou n√£o, esse m√©todo considera o brilho dos pixels em um c√≠rculo centrado no ponto C e no raio 3: <br><br><img src="https://pp.userapi.com/c848536/v848536622/5559/qPxNkhmqJSU.jpg" alt="imagem"><br><br>  Comparando o brilho dos pixels do c√≠rculo com o brilho do centro C, para cada um obtemos tr√™s resultados poss√≠veis (mais claro, mais escuro, ao que parece): <br><br><math> </math> $ inline $ \ begin {array} {l} {I_p}&gt; {I_C} + t \\ {I_p} &lt;{I_C} -t \\ {I_C} -t &lt;{I_p} &lt;{I_C} + t \ end {array} $ inline $ <br><br>  Aqui estou o brilho dos pixels, t √© um limite de brilho predeterminado. <br>  Um ponto √© marcado como especial se houver n = 12 pixels em uma linha mais escura ou 12 pixels mais claros que o centro. <br><br>  Como a pr√°tica demonstrou, em m√©dia, para tomar uma decis√£o, foi necess√°rio verificar cerca de 9 pontos.  Para acelerar o processo, os autores sugeriram primeiro verificar apenas quatro pixels com n√∫meros: 1, 5, 9, 13. Se entre eles houver 3 pixels mais claro ou mais escuro, ser√° realizada uma verifica√ß√£o completa em 16 pontos; caso contr√°rio, o ponto ser√° imediatamente marcado como " n√£o √© especial.  Isso reduz bastante o tempo de trabalho; para tomar uma decis√£o em m√©dia, basta pesquisar apenas cerca de 4 pontos de um c√≠rculo. <br><br>  Um pouco de c√≥digo ing√™nuo est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> <br>  Par√¢metros vari√°veis ‚Äã‚Äã(descritos no c√≥digo): raio do c√≠rculo (assume valores 1,2,3), par√¢metro n (no original, n = 12), par√¢metro t.  O c√≥digo abre o arquivo in.bmp, processa a imagem e salva em out.bmp.  As imagens s√£o comuns de 24 bits. <br><br><h1>  Construindo uma √°rvore de decis√£o, √Årvore FAST, FAST-9 </h1><br>  Em 2006, em [2], foi poss√≠vel desenvolver uma id√©ia original usando aprendizado de m√°quina e √°rvores de decis√£o. <br><br>  O FAST original tem as seguintes desvantagens: <br><br><ul><li>  V√°rios pixels adjacentes podem ser marcados como pontos especiais.  Precisamos de alguma medida da "for√ßa" de um recurso.  Uma das primeiras medidas propostas √© o valor m√°ximo de t no qual o ponto ainda √© tomado como especial. </li><li>  Um teste r√°pido de 4 pontos n√£o √© generalizado para n menor que 12. Portanto, por exemplo, visualmente os melhores resultados do m√©todo s√£o alcan√ßados com n = 9, e n√£o 12. </li><li>  Eu tamb√©m gostaria de acelerar o algoritmo! </li></ul><br>  Em vez de usar uma cascata de dois testes de 4 e 16 pontos, prop√µe-se fazer tudo de uma s√≥ vez na √°rvore de decis√£o.  De maneira semelhante ao m√©todo original, compararemos o brilho do ponto central com os pontos do c√≠rculo, mas nesta ordem para tomar a decis√£o o mais r√°pido poss√≠vel.  E acontece que voc√™ pode tomar uma decis√£o para apenas ~ 2 (!!!) compara√ß√µes, em m√©dia. <br><br>  O pr√≥prio sal √© como encontrar a ordem certa para comparar pontos.  Encontre usando o aprendizado de m√°quina.  Suponha que algu√©m notou para n√≥s na imagem muitos pontos especiais.  N√≥s os usaremos como um conjunto de exemplos de treinamento, e a id√©ia √© escolher com <u>entusiasmo</u> aquele que fornecer√° a maior quantidade de informa√ß√µes nesta etapa, como o pr√≥ximo ponto.  Por exemplo, suponha que inicialmente em nossa amostra houvesse 5 pontos singulares e 5 pontos n√£o singulares.  Na forma de um tablet como este: <br><br><img src="https://pp.userapi.com/c848536/v848536622/5596/A83hqZFlbWY.jpg" alt="imagem"><br><br>  Agora escolhemos um dos pixels p do c√≠rculo e, para todos os pontos singulares, comparamos o pixel central com o selecionado.  Dependendo do brilho do pixel selecionado pr√≥ximo a cada ponto espec√≠fico, a tabela pode ter o seguinte resultado: <br><br><img src="https://pp.userapi.com/c848536/v848536622/559d/A1CIWhE_LV8.jpg" alt="imagem"><br><br>  A id√©ia √© escolher um ponto p para que os n√∫meros nas colunas da tabela sejam os mais diferentes poss√≠veis.  E se agora, para um novo ponto desconhecido, obtivermos o resultado da compara√ß√£o ‚ÄúMais leve‚Äù, j√° podemos dizer imediatamente que o ponto ‚Äún√£o √© especial‚Äù (consulte a tabela).  O processo continua recursivamente at√© que os pontos de apenas uma das classes caiam em cada grupo depois de se dividirem em "mais escuros".  Acontece uma √°rvore da seguinte forma: <br><br><img src="https://pp.userapi.com/c848536/v848536622/55a4/W7idq5TQQZ4.jpg" alt="imagem"><br><br>  O valor bin√°rio est√° nas folhas da √°rvore (vermelho √© especial, verde n√£o √© especial) e nos outros v√©rtices da √°rvore est√° o n√∫mero do ponto que precisa ser analisado.  Mais especificamente, no artigo original, eles prop√µem a escolha do n√∫mero do ponto alterando a entropia.  A entropia do conjunto de pontos √© calculada: <br><br><p><math> </math> $$ display $$ H = \ left ({c + \ overline c} \ right) {\ log _2} \ left ({c + \ overline c} \ right) - c {\ log _2} c - \ overline c {\ log _2} \ overline c $$ display $$ </p><br><br>  c √© o n√∫mero de pontos singulares, <math> </math> $ inline $ {\ bar c} $ inline $   √â o n√∫mero de pontos n√£o singulares do conjunto <br><br>  Altera√ß√£o na entropia ap√≥s o ponto de processamento p: <br><br><p><math> </math> exibi√ß√£o $$ $$ \ Delta H = H - {H_ {dark}} - {H_ {equal}} - {H_ {brilhante}} $$ exibi√ß√£o $$ </p><br><br>  Consequentemente, um ponto √© selecionado para o qual a altera√ß√£o na entropia ser√° m√°xima.  O processo de divis√£o para quando a entropia √© zero, o que significa que todos os pontos s√£o singulares ou vice-versa - nem todos s√£o especiais.  Com uma implementa√ß√£o de software, depois de tudo isso, a √°rvore de decis√£o encontrada √© convertida em um conjunto de constru√ß√µes do tipo "if-else". <br><br>  O √∫ltimo passo do algoritmo √© a opera√ß√£o de suprimir valores n√£o m√°ximos para obter um de v√°rios pontos adjacentes.  Os desenvolvedores sugerem o uso da medida original com base na soma das diferen√ßas absolutas entre o ponto central e os pontos do c√≠rculo nesta forma: <br><br><p><math> </math> $$ display $$ V = \ max \ left ({\ sum \ limits_ {x \ in {S_ {bright}}} {\ left | {{I_x} - {I_p}} \ right | - t, \ sum \ limites_ {x \ in {S_ {escuro}}} {\ left | {{I_p} - {I_x}} \ right | - t}}} \ right) $$ display $$ </p><br><br>  Aqui <math> </math> $ inline $ {S_ {bright}} $ inline $   e <math> </math> $ inline $ {S_ {dark}} $ inline $   respectivamente, grupos de pixels s√£o mais claros e mais escuros, t √© o valor do brilho limite, <math> </math> $ inline $ {I_p} $ inline $   - brilho do pixel central, <math> </math> $ inline $ {{I_x}} $ inline $   - brilho do pixel no c√≠rculo.  Voc√™ pode tentar o algoritmo com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seguinte c√≥digo</a> .  O c√≥digo √© retirado do OpenCV e liberado de todas as depend√™ncias, basta execut√°-lo. <br><br><h1>  Otimizando a √°rvore de decis√£o - FAST-ER </h1><br>  O FAST-ER [3] √© um algoritmo dos mesmos autores que o anterior, um detector r√°pido √© constru√≠do de forma semelhante, a sequ√™ncia √≥tima de pontos tamb√©m √© pesquisada para compara√ß√£o, uma √°rvore de decis√£o tamb√©m √© constru√≠da, mas usando um m√©todo diferente - o m√©todo de otimiza√ß√£o. <br><br>  J√° entendemos que um detector pode ser representado como uma √°rvore de decis√£o.  Se tiv√©ssemos algum crit√©rio para comparar o desempenho de diferentes √°rvores, podemos maximizar esse crit√©rio classificando atrav√©s de diferentes variantes de √°rvores.  E, como tal crit√©rio, prop√µe-se o uso de "Repetibilidade". <br><br>  A repetibilidade mostra qu√£o bem os pontos singulares de uma cena s√£o detectados de diferentes √¢ngulos.  Para um par de imagens, um ponto √© chamado de "√∫til" se for encontrado em um quadro e, teoricamente, pode ser encontrado em outro, ou seja,  N√£o bloqueie os elementos da cena.  E o ponto √© chamado de "repetido" (repetido), se tamb√©m for encontrado no segundo quadro.  Como a √≥tica da c√¢mera n√£o √© ideal, o ponto no segundo quadro pode n√£o estar no pixel calculado, mas em algum lugar pr√≥ximo nas proximidades.  Os desenvolvedores tiveram um bairro de 5 pixels.  Definimos repetibilidade como a raz√£o entre o n√∫mero de pontos repetidos e o n√∫mero de pontos √∫teis: <br><br><p><math> </math> $$ display $$ R = \ frac {{{N_ {repetido}}}}} {{{N_ {√ötil}}}} $$ display $$ </p><br><br>  Para encontrar o melhor detector, √© usado um m√©todo de simula√ß√£o de recozimento.  J√° existe um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">excelente artigo</a> sobre Habr√© sobre ele.  Resumidamente, a ess√™ncia do m√©todo √© a seguinte: <br><br><ul><li>  Alguma solu√ß√£o inicial para o problema √© selecionada (no nosso caso, isso √© algum tipo de √°rvore de detectores). </li><li>  A repetibilidade √© considerada. </li><li>  A √°rvore √© modificada aleatoriamente. </li><li>  Se a vers√£o modificada √© melhor pelo crit√©rio de repetibilidade, a modifica√ß√£o √© aceita e, se for pior, pode ser aceita ou n√£o, com alguma probabilidade, que depende de um n√∫mero real chamado ‚Äútemperatura‚Äù.  √Ä medida que o n√∫mero de itera√ß√µes aumenta, a temperatura cai para zero. </li></ul><br>  Al√©m disso, a constru√ß√£o do detector agora envolve n√£o 16 pontos do c√≠rculo, como antes, mas 47, mas o significado n√£o muda: <br><br><img src="https://pp.userapi.com/c824411/v824411841/1607f1/5szVOBYHeck.jpg" alt="imagem"><br><br>  De acordo com o m√©todo de recozimento simulado, definimos tr√™s fun√ß√µes: <br><br>  ‚Ä¢ Fun√ß√£o de custo k.  No nosso caso, usamos a repetibilidade como valor.  Mas h√° um problema.  Imagine que todos os pontos em cada uma das duas imagens sejam detectados como singulares.  Acontece que a repetibilidade √© 100% - absurdo.  Por outro lado, mesmo que tenhamos encontrado um ponto espec√≠fico em duas figuras, e esses pontos coincidam - a repetibilidade tamb√©m √© de 100%, mas isso tamb√©m n√£o nos interessa.  E, portanto, os autores propuseram us√°-lo como crit√©rio de qualidade: <br><br><p><math> </math> $$ display $$ k = \ left ({1 + {{\ left ({\ frac {{{w_r}}} {R}} \ right)} ^ 2}} \ right) \ left ({1 + \ frac {1} {N} \ sum \ limits_ {i = 1} {{{\ left ({\ frac {{{d_i}}}} {{{w_n}}}} √† direita)} ^ 2}}} \ direita) \ esquerda ({1 + {{\ left ({\ frac {s} {{{w_s}}}} direita)} ^ 2}} \ right) $$ display $$ </p><br><br>  r √© a repetibilidade <math> </math> $ inline $ {{d_i}} $ inline $   √â o n√∫mero de √¢ngulos detectados no quadro i, N √© o n√∫mero de quadros e s √© o tamanho da √°rvore (n√∫mero de v√©rtices).  W s√£o par√¢metros de m√©todo personalizado.] <br><br>  ‚Ä¢ Fun√ß√£o de mudan√ßa de temperatura ao longo do tempo: <br><br><p><math> </math> exibi√ß√£o $$ $$ T \ esquerda (I \ direita) = \ beta \ exp \ left ({- \ frac {{\ alpha I}} {{{I _ {\ max}}}} \ right) exibi√ß√£o em $$ $$ </p><br><br>  onde <math> </math> $ inline $ \ alpha, \ beta $ inline $   S√£o os coeficientes, Imax √© o n√∫mero de itera√ß√µes. <br><br>  ‚Ä¢ Uma fun√ß√£o que gera uma nova solu√ß√£o.  O algoritmo faz modifica√ß√µes aleat√≥rias na √°rvore.  Primeiro, selecione algum v√©rtice.  Se o v√©rtice selecionado √© uma folha de uma √°rvore, com igual probabilidade, fazemos o seguinte: <br><br><ol><li>  Substitua o v√©rtice por uma sub√°rvore aleat√≥ria com profundidade 1 </li><li>  Alterar a classe desta planilha (pontos singular-n√£o singulares) </li></ol><br>  Se N√ÉO for uma planilha: <br><br><ol><li>  Substitua o n√∫mero do ponto testado por um n√∫mero aleat√≥rio de 0 a 47 </li><li>  Substituir v√©rtice por uma planilha por uma classe aleat√≥ria </li><li>  Troque duas sub√°rvores deste v√©rtice </li></ol><br>  A probabilidade P de aceitar a altera√ß√£o na itera√ß√£o I √©: <br><math> </math> $ inline $ P = \ exp \ left ({\ frac {{k \ left ({i - 1} \ right) - k \ left (i \ right)}} {T}} \ right) $ inline $ <br>  k √© a fun√ß√£o de custo, T √© a temperatura, i √© o n√∫mero da itera√ß√£o. <br><br>  Essas modifica√ß√µes na √°rvore permitem o crescimento da √°rvore e sua redu√ß√£o.  O m√©todo √© aleat√≥rio, n√£o garante que a melhor √°rvore seja obtida.  Execute o m√©todo v√°rias vezes, escolhendo a melhor solu√ß√£o.  No artigo original, por exemplo, eles s√£o executados 100 vezes por 100.000 itera√ß√µes cada, o que leva 200 horas de tempo do processador.  Como mostram os resultados, o resultado √© melhor que o Tree FAST, especialmente em fotos com ru√≠do. <br><br><h1>  BREVE descritor </h1><br>  Depois que os pontos singulares s√£o encontrados, seus descritores s√£o calculados, ou seja,  conjuntos de caracter√≠sticas que caracterizam a vizinhan√ßa de cada ponto singular.  BREVE [4] √© um descritor heur√≠stico r√°pido, constru√≠do a partir de 256 compara√ß√µes bin√°rias entre o brilho dos pixels em uma imagem <u>borrada</u> .  O teste bin√°rio entre os pontos x e y √© definido da seguinte forma: <br><br><p><math> </math> exibi√ß√£o $$ $$ \ tau \ left ({P, x, y} \ right): = \ left \ {{\ begin {array} {* {20} {c}} {1: p \ left (x \ direita) &lt;p \ esquerda (y \ direita)} \\ {0: p \ esquerda (x \ direita) \ ge p \ esquerda (y \ direita)} \ final {matriz}} \ direita. $$ display $$ </p><br><br><img src="https://pp.userapi.com/c824411/v824411841/160801/dMWJxyV422c.jpg" alt="imagem"><br><br>  No artigo original, v√°rios m√©todos para escolher pontos para compara√ß√µes bin√°rias foram considerados.  Como se viu, uma das melhores maneiras √© selecionar pontos aleatoriamente usando uma distribui√ß√£o gaussiana em torno de um pixel central.  Essa sequ√™ncia aleat√≥ria de pontos √© selecionada uma vez e n√£o muda mais.  O tamanho da vizinhan√ßa considerada do ponto √© 31x31 pixels e a abertura de desfoque √© 5. <br><br>  O descritor bin√°rio resultante √© resistente a mudan√ßas na ilumina√ß√£o, distor√ß√£o de perspectiva, √© rapidamente calculado e comparado, mas √© muito inst√°vel √† rota√ß√£o no plano da imagem. <br><br><h1>  ORB - r√°pido e eficiente </h1><br>  O desenvolvimento de todas essas id√©ias foi o algoritmo ORB (Oriented FAST and Rotated BRIEF) [5], no qual foi feita uma tentativa de melhorar o desempenho do BRIEF durante a rota√ß√£o da imagem.  Prop√µe-se primeiro calcular a orienta√ß√£o do ponto singular e, em seguida, realizar compara√ß√µes bin√°rias de acordo com essa orienta√ß√£o.  O algoritmo funciona assim: <br><br>  1) Os pontos de recurso s√£o detectados usando a r√°pida √°rvore FAST na imagem original e em v√°rias imagens da pir√¢mide de miniaturas. <br><br>  2) Para os pontos detectados, a medida de Harris √© calculada, os candidatos com um valor baixo da medida de Harris s√£o descartados. <br><br>  3) O √¢ngulo de orienta√ß√£o do ponto singular √© calculado.  Para isso, os momentos de brilho da vizinhan√ßa do ponto singular s√£o calculados primeiro: <br><br><math> </math> $ inline $ {m_ {pq}} = \ sum \ limits_ {x, y} {{x ^ p} {y ^ q} Eu \ esquerda ({x, y} \ right)} $ inline $ <br>  coordenadas x, y - pixel, I - brilho.  E ent√£o o √¢ngulo de orienta√ß√£o do ponto singular: <br><math> </math> $ inline $ \ theta = {\ rm {atan2}} \ left ({{m_ {01}}, {m_ {10}}} \ right) $ inline $ <br><br>  Tudo isso, os autores chamaram de "orienta√ß√£o centr√≥ide".  Como resultado, obtemos uma certa dire√ß√£o para a vizinhan√ßa do ponto singular. <br><br>  4) Tendo o √¢ngulo de orienta√ß√£o do ponto singular, a sequ√™ncia de pontos para compara√ß√µes bin√°rias no descritor BRIEF gira de acordo com esse √¢ngulo, por exemplo: <br><br><img src="https://pp.userapi.com/c824411/v824411841/160813/y5R3uZYvsfQ.jpg" alt="imagem"><br><br>  Mais formalmente, as novas posi√ß√µes para os pontos de teste bin√°rios s√£o calculadas da seguinte maneira: <br><br><p><math> </math> $$ display $$ \ left ({\ begin {array} {* {20} {c}} {{x_i} '} \\ {{y_i}'} \ end {array}} \ right) = R \ left (\ theta \ right) \ cdot \ left ({\ begin {array} {* {20} {c}} {{x_i}} \\ {{y_i}} \ end {array}} \ right) exibi√ß√£o em $$ $$ </p><br><br>  5) Com base nos pontos recebidos, o descritor bin√°rio BRIEF √© calculado <br><br>  E isso √© ... n√£o tudo!  H√° outro detalhe interessante no ORB que requer explica√ß√µes separadas.  O fato √© que, no momento em que "giramos" todos os pontos singulares para um √¢ngulo zero, a escolha aleat√≥ria de compara√ß√µes bin√°rias no descritor deixa de ser aleat√≥ria.  Isso leva ao fato de que, em primeiro lugar, algumas compara√ß√µes bin√°rias se tornam dependentes umas das outras e, em segundo lugar, sua m√©dia n√£o √© mais igual a 0,5 (1 √© mais leve, 0 √© mais escuro quando a escolha foi aleat√≥ria e, em seguida, a m√©dia foi 0,5) e tudo isso reduz significativamente a capacidade do descritor de distinguir pontos singulares entre si. <br><br>  Solu√ß√£o - voc√™ precisa selecionar os testes bin√°rios ‚Äúcorretos‚Äù no processo de aprendizado. Essa id√©ia d√° o mesmo sabor que o treinamento em √°rvore para o algoritmo FAST-9.  Suponha que j√° tenhamos v√°rios pontos singulares.  Considere todas as op√ß√µes poss√≠veis para testes bin√°rios.  Se a vizinhan√ßa for 31 x 31 e o teste bin√°rio for um par de subconjuntos 5 x 5 (devido ao desfoque), existem v√°rias op√ß√µes para escolher N = (31-5) ^ 2.  O algoritmo de pesquisa para testes "bons" √© o seguinte: <br><br><ol><li>  Calculamos o resultado de todos os testes para todos os pontos singulares </li><li>  Organize todo o conjunto de testes de acordo com a dist√¢ncia da m√©dia de 0,5 </li><li>  Crie uma lista que conter√° os testes "bons" selecionados, vamos chamar a lista R. </li><li>  Adicione a R o primeiro teste do conjunto classificado </li><li>  N√≥s fazemos o pr√≥ximo teste e o comparamos com todos os testes em R. Se a correla√ß√£o for maior que o limite, descartamos o novo teste, caso contr√°rio, o adicionamos. </li><li>  Repita a etapa 5 at√© digitar o n√∫mero necess√°rio de testes. </li></ol><br>  Acontece que os testes s√£o selecionados de modo que, por um lado, o valor m√©dio desses testes seja o mais pr√≥ximo poss√≠vel de 0,5, por outro, para que a correla√ß√£o entre os diferentes testes seja m√≠nima.  E √© disso que precisamos.  Compare como foi e como se tornou: <br><br><img src="https://pp.userapi.com/c824411/v824411841/160829/ozQhEUvtdBs.jpg" alt="imagem"><br><br>  Felizmente, o algoritmo ORB √© implementado na biblioteca OpenCV na classe cv :: ORB.  Estou usando a vers√£o 2.4.13.  O construtor da classe aceita os seguintes par√¢metros: <br><br>  nfeatures - n√∫mero m√°ximo de pontos singulares <br>  scaleFactor - multiplicador para a pir√¢mide de imagens, mais de um.  O valor 2 implementa a pir√¢mide cl√°ssica. <br>  nlevels - o n√∫mero de n√≠veis na pir√¢mide de imagens. <br>  edgeThreshold - o n√∫mero de pixels na borda da imagem em que pontos singulares n√£o s√£o detectados. <br>  firstLevel - deixe zero. <br>  WTA_K - o n√∫mero de pontos necess√°rios para um elemento do descritor.  Se for igual a 2, o brilho de dois pixels selecionados aleatoriamente √© comparado.  √â isso que √© necess√°rio. <br>  scoreType - se 0, harris √© usado como uma medida caracter√≠stica, caso contr√°rio - a medida FAST (com base na soma dos m√≥dulos das diferen√ßas de brilho nos pontos do c√≠rculo).  A medida FAST √© um pouco menos est√°vel, mas mais r√°pida. <br>  patchSize - o tamanho da vizinhan√ßa na qual os pixels aleat√≥rios s√£o selecionados para compara√ß√£o.  O c√≥digo pesquisa e compara os pontos singulares em duas figuras, "templ.bmp" e "img.bmp" <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre><code class="cpp hljs">cv::Mat img_object=cv::imread(<span class="hljs-string"><span class="hljs-string">"templ.bmp"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;cv::KeyPoint&gt; keypoints_object, keypoints_scene; cv::Mat descriptors_object, descriptors_scene; cv::<span class="hljs-function"><span class="hljs-function">ORB </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">orb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">500</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">31</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">31</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//    orb.detect(img_object, keypoints_object); orb.compute(img_object, keypoints_object, descriptors_object); //    cv::Mat img = cv::imread("img.bmp", 1); cv::Mat img_scene = cv::Mat(img.size(), CV_8UC1); orb.detect(img, keypoints_scene); orb.compute(img, keypoints_scene, descriptors_scene); cv::imshow("desrs", descriptors_scene); cvWaitKey(); int test[10]; for (int q = 0; q&lt;10 ; q++) test[q]=descriptors_scene.data[q]; //-- matching descriptor vectors using FLANN matcher cv::BFMatcher matcher; std::vector&lt;cv::DMatch&gt; matches; cv::Mat img_matches; if(!descriptors_object.empty() &amp;&amp; !descriptors_scene.empty()) { matcher.match (descriptors_object, descriptors_scene, matches); double max_dist = 0; double min_dist = 100; // calculation of max and min idstance between keypoints for( int i = 0; i &lt; descriptors_object.rows; i++) { double dist = matches[i].distance; if( dist &lt; min_dist ) min_dist = dist; if( dist &gt; max_dist ) max_dist = dist; } //-- Draw only good matches (ie whose distance is less than 3*min_dist) std::vector&lt; cv::DMatch &gt;good_matches; for( int i = 0; i &lt; descriptors_object.rows; i++ ) if( matches[i].distance &lt; (max_dist/1.6) ) good_matches.push_back(matches[i]); cv::drawMatches(img_object, keypoints_object, img_scene, keypoints_scene, good_matches, img_matches, cv::Scalar::all(-1), cv::Scalar::all(-1), std::vector&lt;char&gt;(), cv::DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS); } cv::imshow("match result", img_matches ); cv::waitKey(); return 0;</span></span></code> </pre> <br></div></div><br>  Se algu√©m ajudou a entender a ess√™ncia dos algoritmos, n√£o √© em v√£o.  Para todo o Habr. <br><br>  Refer√™ncias: <br><br>  1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pontos e linhas de fus√£o para rastreamento de alto desempenho</a> <br>  2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aprendizado de m√°quina para detec√ß√£o de canto em alta velocidade</a> <br>  3. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mais r√°pido e melhor: uma abordagem de aprendizado de m√°quina para detec√ß√£o de cantos</a> <br>  4. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RESUMO: Recursos elementares independentes robustos bin√°rios</a> <br>  5. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ORB: uma alternativa eficiente para SIFT ou SURF</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414459/">https://habr.com/ru/post/pt414459/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414447/index.html">Tipos de todos os tempos</a></li>
<li><a href="../pt414449/index.html">Como fazer amigos de todos os operadores do est√°dio e n√£o seme√°-lo com centenas de antenas</a></li>
<li><a href="../pt414451/index.html">"Calend√°rio do testador" para junho. O testador deve pegar o erro, ler Caner e organizar a mudan√ßa.</a></li>
<li><a href="../pt414453/index.html">Implementar o Path Finder para agentes de IA com o NavMesh</a></li>
<li><a href="../pt414455/index.html">Algoritmo de gera√ß√£o de paleta de cores</a></li>
<li><a href="../pt414463/index.html">A pr√≥pria IA aprendeu a construir um cubo de Rubik</a></li>
<li><a href="../pt414465/index.html">Meta Crush Saga: jogo em tempo de compila√ß√£o</a></li>
<li><a href="../pt414467/index.html">Artigos da Confer√™ncia Minsk C ++ CoreHard Spring 2018</a></li>
<li><a href="../pt414469/index.html">Semana 22 de seguran√ßa: bloqueios inteligentes de dois segundos</a></li>
<li><a href="../pt414471/index.html">11 c√≠rculos do inferno para quem n√£o tem experi√™ncia em um novo emprego</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>