<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚Äçüßëüèº ‚ÜñÔ∏è ‚òÄÔ∏è Exploraci√≥n del sombreador de arena del juego Journey. ü§ì ü§±üèΩ ü§ò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Entre los muchos juegos independientes lanzados en los √∫ltimos 10 a√±os, uno de mis favoritos es definitivamente Journey . Gracias a su est√©tica impres...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exploraci√≥n del sombreador de arena del juego Journey.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476448/">  Entre los muchos juegos independientes lanzados en los √∫ltimos 10 a√±os, uno de mis favoritos es definitivamente <em>Journey</em> .  Gracias a su est√©tica impresionante y hermosa banda sonora, <em>Journey se</em> ha convertido en un ejemplo de excelencia en casi todos los aspectos del desarrollo. <br><br>  Soy un desarrollador de juegos y artista t√©cnico, por lo que me intrig√≥ mucho la forma en que se renderiz√≥ la arena.  No solo es hermoso, sino que tambi√©n est√° directamente relacionado con el juego b√°sico y el juego en su conjunto.  <em>Journey</em> est√° literalmente construido de arena, y sin un efecto tan sorprendente, el juego en s√≠ mismo simplemente no podr√≠a existir. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63f/be0/2a8/63fbe02a87ccac8101001a43d953776f.jpg"></div><br>  En este art√≠culo, dividido en dos publicaciones, rendir√© homenaje al legado de <em>Journey</em> al ense√±arle c√≥mo recrear exactamente la misma representaci√≥n de arena usando sombreadores.  Independientemente de si se necesitan dunas de arena en su juego, esta serie de tutoriales le permitir√° aprender c√≥mo recrear una est√©tica espec√≠fica en su propio juego.  Si desea recrear el hermoso sombreador de arena utilizado en <em>Journey</em> , primero debe comprender c√≥mo se construy√≥.  Y aunque parece extremadamente complejo, en realidad consiste en varios efectos relativamente simples.  Este enfoque para escribir sombreadores es necesario para convertirse en un artista t√©cnico exitoso.  Por lo tanto, espero que hagas este <em>viaje</em> conmigo, en el que no solo exploremos la creaci√≥n de sombreadores, sino que tambi√©n aprendamos a combinar la est√©tica y el juego. <br><a name="habracut"></a><br><h1>  An√°lisis de arena en Journey </h1><br>  Este art√≠culo, como muchos otros intentos de recrear el renderizado de arena de <em>Journey</em> , se basa en un informe de GDC que el ingeniero l√≠der de la compa√±√≠a John Edwards titul√≥ " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">Renderizado de arena en Journey</a> ".  En esta charla, John Edwards habla sobre todas las capas de efectos a√±adidos a las dunas de arena de <em>Journey</em> para lograr el aspecto correcto. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wt2yYnBRD3U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  El informe es muy √∫til, pero en el contexto de este tutorial, muchas de las limitaciones y decisiones tomadas por John Edwards no son importantes.  Intentaremos recrear los sombreadores de arena, que recuerdan al sombreador <em>Journey</em> , principalmente por referencias visuales. <br><br>  Comencemos con una simple malla 3D de una duna perfectamente lisa.  La credibilidad de la reproducci√≥n de arena depende de dos aspectos: iluminaci√≥n y grano.  Un <strong>modelo de iluminaci√≥n</strong> modificado proporciona una forma interesante de reflejar la luz de la arena.  En el contexto de la codificaci√≥n del sombreador, el modelo de iluminaci√≥n determina las sombras y los reflejos en funci√≥n de las propiedades del modelo y las condiciones de iluminaci√≥n de la escena. <br><br>  Sin embargo, todo esto no es suficiente para crear la ilusi√≥n de realismo.  El problema es que la arena simplemente no se puede modelar con superficies planas.  Se debe considerar el grano de arena.  Es por eso que hay dos efectos separados que funcionan directamente con lo <strong>normal a la superficie</strong> , que se pueden usar para simular peque√±as part√≠culas de arena en la superficie de la duna. <br><br>  El siguiente diagrama muestra todos los efectos que aprenderemos en este tutorial.  Desde un punto de vista t√©cnico, los c√°lculos normales se realizan antes de procesar la iluminaci√≥n.  Para facilitar el estudio, los efectos se describir√°n en un orden diferente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/373/0b9/8a1/3730b98a1670ef00cf68efb0af0cc08b.png"></div><br><h6>  Color difuso </h6><br>  El efecto de sombreador de arena m√°s simple es su <strong>color difuso</strong> , que describe aproximadamente el componente <em>opaco</em> de la apariencia general.  El color difuso se calcula en funci√≥n del color <em>real</em> del objeto y las condiciones de iluminaci√≥n.  Una esfera pintada de blanco no ser√° perfectamente blanca en todas partes, porque el color difuso depende de la luz que incide sobre ella.  Los colores difusos se calculan utilizando un modelo matem√°tico que se aproxima al reflejo de la luz de una superficie.  Gracias a un informe de John Edwards con el GDC, sabemos exactamente la ecuaci√≥n utilizada, que √©l llama <strong>reflectancia de contraste difuso</strong> ;  Se basa en el conocido modelo de <strong>reflexiones</strong> de <strong>Lambert</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/509/4c1/65b/5094c165b5f2e1ba10696fec1641482c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br>  <i>Antes y despu√©s de aplicar la ecuaci√≥n.</i> <br><br><h6>  Arena normal </h6><br>  La geometr√≠a original es completamente lisa.  Para compensar esto, la <strong>superficie normal del</strong> modelo se cambia utilizando una t√©cnica llamada <strong>mapeo de relieve</strong> .  Le permite usar una textura para simular geometr√≠as m√°s complejas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br><h6>  Iluminaci√≥n de borde </h6><br>  Cada nivel de <em>viaje</em> utiliza una paleta de colores limitada.  Debido a esto, es bastante dif√≠cil entender d√≥nde termina una duna y d√≥nde comienza otra.  Para aumentar la legibilidad, se utiliza la t√©cnica de resaltado peque√±o de lo que es visible solo a lo largo del borde de la duna.  Se llama <strong>iluminaci√≥n de llanta</strong> , y hay muchas formas de implementarla.  Para este tutorial, eleg√≠ un m√©todo basado <strong>en</strong> reflexiones de <strong>Fresnel</strong> que modela reflexiones sobre superficies pulidas en los llamados <em>√°ngulos de incidencia</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/285/818/8642858189235ff1d796378992523ceb.png"></div><br><h6>  Espejo reflejo del oc√©ano </h6><br>  Uno de los aspectos m√°s divertidos <em>del</em> juego de <em>Journey</em> es la capacidad de "surfear" las dunas de arena.  Esta es probablemente la raz√≥n por la que esa compa√±√≠a del juego quer√≠a que la arena se sintiera m√°s como un l√≠quido que como un s√≥lido.  Para esto, se utiliz√≥ una fuerte reflexi√≥n, que a menudo se puede encontrar en sombreadores de agua.  John Edwards llama a este efecto <strong>oc√©ano especular</strong> , y en el tutorial lo implementamos usando la <strong>reflexi√≥n Blinn-Fong</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/285/818/8642858189235ff1d796378992523ceb.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/d17/d2f/716d17d2f4d0d0796e51bee059ce39c2.png"></div><br><h6>  Reflejo de deslumbramiento </h6><br>  Agregar un componente especular oce√°nico al sombreador de arena le da un aspecto m√°s fluido.  Sin embargo, todav√≠a no permite que se transmita uno de los aspectos visuales m√°s importantes de la arena: los reflejos que ocurren al azar.  En las dunas reales, este efecto ocurre porque cada grano de arena refleja la luz en su direcci√≥n y muy a menudo uno de estos rayos reflejados ingresa a nuestro ojo.  Tal <strong>reflejo de brillo</strong> (reflejo de reflejos) ocurre incluso en lugares donde la luz solar directa no cae;  complementa el oc√©ano especular y mejora el sentido de credibilidad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/d17/d2f/716d17d2f4d0d0796e51bee059ce39c2.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/f3c/33c/539f3c33c6c12f5206540ff62ecf4102.png"></div><br><h6>  Olas de arena </h6><br>  Cambiar las normales nos permiti√≥ simular el efecto de peque√±os granos de arena que cubren la superficie de la duna.  En las dunas del mundo real, a menudo aparecen olas causadas por el viento.  Su forma var√≠a seg√∫n la pendiente y la posici√≥n de cada duna en relaci√≥n con la direcci√≥n del viento.  Potencialmente, tales patrones se pueden crear a trav√©s de una textura rugosa, pero en este caso ser√° imposible cambiar la forma de las dunas en tiempo real.  La soluci√≥n propuesta por John Edwards es similar a una t√©cnica llamada <strong>sombreado triplanar</strong> : utiliza cuatro texturas diferentes, mezcladas seg√∫n la posici√≥n y la pendiente de cada duna. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/f3c/33c/539f3c33c6c12f5206540ff62ecf4102.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/828/9b4/997/8289b49971bbe0046845f71284790124.png"></div><br><h1>  Journey Sand Shader Anatomy </h1><br>  Unity tiene muchas plantillas de sombreadores para comenzar.  Como estamos interesados ‚Äã‚Äãen materiales que puedan recibir iluminaci√≥n y proyectar sombras, debemos comenzar con el <strong>sombreador de</strong> superficie (sombreador de superficie). <br><br>  Todos <strong>los sombreadores de superficie</strong> se realizan en dos etapas.  Primero, se llama <strong>una funci√≥n de superficie</strong> que recolecta las propiedades de la superficie que necesita ser renderizada, por ejemplo, su <em>albedo</em> , <em>rugosidad</em> , <em>propiedades del metal</em> , <em>transparencia</em> y <em>direcci√≥n normal</em> .  Luego, todas estas propiedades se transfieren a <strong>la funci√≥n de iluminaci√≥n</strong> , que tiene en cuenta la influencia de las fuentes de luz externas y calcula el sombreado y la iluminaci√≥n. <br><br><h2>  Funci√≥n de superficie </h2><br>  Comencemos con lo que se convierte en el n√∫cleo de nuestra funci√≥n de superficie, llamada en el c√≥digo de <code>surf</code> continuaci√≥n.  Las √∫nicas propiedades que necesitamos establecer son el <em>color de la arena</em> y lo <strong>normal a la superficie</strong> .  La normalidad de un modelo 3D es un vector que indica la posici√≥n de la superficie.  La funci√≥n de iluminaci√≥n utiliza vectores normales para calcular c√≥mo se reflejar√° la luz.  Por lo general, se calculan durante la importaci√≥n de la malla.  Sin embargo, se pueden modificar para simular una geometr√≠a m√°s compleja.  Es aqu√≠ donde la <strong>arena normal</strong> y <strong>los</strong> efectos <strong>normales de las</strong> <strong>olas de</strong> <strong>arena</strong> distorsionan la norma de arena para simular su aspereza. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; float3 N = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); N = RipplesNormal(N); N = SandNormal (N); o.Normal = N; }</code> </pre> <br>  Al escribir normales en <code>o.Normal</code> deben expresarse en <strong>espacio tangente</strong> .  Esto significa que el vector se selecciona en relaci√≥n con la superficie del modelo 3D.  Es decir, <code>float3(0, 0, 1)</code> realidad significa que no se realizan cambios en el modelo 3D normal. <br><br>  Ambas funciones, <code>RipplesNormal</code> y <code>SandNormal</code> reciben el vector normal y lo modifican.  M√°s adelante veremos c√≥mo se puede hacer esto. <br><br><h2>  Funci√≥n de iluminaci√≥n </h2><br>  Es en la funci√≥n de iluminaci√≥n que se implementan todos los dem√°s efectos.  El siguiente c√≥digo muestra c√≥mo se calcula cada componente individual en funciones separadas (color difuso, iluminaci√≥n de borde, especular oce√°nico y reflejo de brillo).  Entonces se combinan todos. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Journey fullforwardshadows float4 LightingJourney (SurfaceOutput s, fixed3 viewDir, UnityGI gi) { float3 diffuseColor = DiffuseColor (); float3 rimColor = RimLighting (); float3 oceanColor = OceanSpecular (); float3 glitterColor = GlitterSpecular (); float3 specularColor = saturate(max(rimColor, oceanColor)); float3 color = diffuseColor + specularColor + glitterColor; return float4(color * s.Albedo, 1); }</span></span></code> </pre> <br>  El m√©todo de combinar componentes es bastante arbitrario y nos permite cambiarlo para estudiar posibilidades art√≠sticas. <br><br>  T√≠picamente, los reflejos especulares se acumulan sobre el color difuso.  Dado que aqu√≠ no tenemos uno, sino tres reflejos especulares ( <em>luz del borde</em> , <em>especular oce√°nico</em> y <em>especular brillante</em> ), debemos ser m√°s cuidadosos para no hacer que la arena parpadee <em>demasiado</em> .  Dado que la luz de borde y el especular oce√°nico son parte del mismo efecto, podemos elegir solo el valor m√°ximo de ellos.  El brillo especular se agrega por separado porque este componente crea arena parpadeante. <br><br><h2>  Parte 2. Color difuso </h2><br>  En la segunda parte de la publicaci√≥n, nos centraremos en el modelo de iluminaci√≥n utilizado en el juego y en eso.  C√≥mo recrearlo en Unity. <br><br>  En la parte anterior, sentamos las bases para lo que gradualmente se convertir√° en nuestra versi√≥n del sombreador de arena Journey.  Como se mencion√≥ anteriormente, <strong>la funci√≥n de iluminaci√≥n se</strong> usa en <strong>sombreadores de superficie</strong> para calcular el efecto de la iluminaci√≥n, de modo que aparezcan sombras y luces en la superficie.  Descubrimos que Journey tiene varios efectos que entran en esta categor√≠a.  Comenzaremos con el efecto m√°s b√°sico (y m√°s simple) que se encuentra en el n√∫cleo de este sombreador: su <strong>iluminaci√≥n</strong> difusa ( <strong>iluminaci√≥n</strong> difusa / difusa). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78f/166/71c/78f16671c754f05e619ce034fad81926.png"></div><br>  Por ahora, omitimos todos los dem√°s efectos y componentes, centr√°ndonos en <strong>iluminar la arena</strong> . <br><br>  La funci√≥n de iluminaci√≥n que <code>DiffuseColor</code> en la parte anterior de la publicaci√≥n llamada <code>LightingJourney</code> simplemente delega el c√°lculo del color difuso de la arena a una funci√≥n llamada <code>DiffuseColor</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LightingJourney</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SurfaceOutput s, fixed3 viewDir, UnityGI gi)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Lighting properties float3 L = gi.light.dir; float3 N = s.Normal; // Lighting calculation float3 diffuseColor = DiffuseColor(N, L); // Final color return float4(diffuseColor, 1); }</span></span></code> </pre> <br>  Debido al hecho de que cada efecto es aut√≥nomo y se almacena en su propia funci√≥n, nuestro c√≥digo ser√° m√°s modular y limpio. <br><br><h2>  Reflexi√≥n Lambert </h2><br>  Antes de crear una iluminaci√≥n difusa "como en Journey", es bueno ver c√≥mo se ve la funci√≥n de iluminaci√≥n difusa "b√°sica".  La t√©cnica de sombreado m√°s simple para materiales mate se llama <strong>reflectancia lambertiana</strong> .  Este modelo se aproxima a la apariencia de la mayor√≠a de las superficies no brillantes y no met√°licas.  Lleva el nombre del cient√≠fico enciclop√©dico suizo <strong>Johann Heinrich Lambert</strong> , quien propuso su concepto en 1760. <br><br>  El concepto de reflexi√≥n de Lambert se basa en una idea simple: el <em>brillo de una superficie depende de la cantidad de luz que incide sobre ella</em> .  Geom√©tricamente, esto se puede mostrar en el siguiente diagrama, donde la esfera est√° iluminada por una fuente de luz remota.  Aunque las √°reas rojas y verdes de la esfera reciben la misma cantidad de iluminaci√≥n, sus √°reas de superficie son significativamente diferentes.  Si la luz en la regi√≥n roja se distribuye en un √°rea m√°s grande, esto significa que cada unidad del cuadrado rojo recibe menos luz que la verde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cf/d48/495/2cfd484953877a47fe5ba564b399ea35.png"></div><br>  Te√≥ricamente, la reflexi√≥n de Lambert depende del √°ngulo relativo entre la <em>superficie</em> y la <em>luz incidente</em> .  Desde un punto de vista matem√°tico, decimos que esta es una funci√≥n de lo <strong>normal a la superficie</strong> y la <strong>direcci√≥n de la iluminaci√≥n</strong> .  Estas cantidades se expresan usando dos vectores de longitud unitaria (llamados <strong>vectores unitarios</strong> ) <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.057ex" viewBox="0 -780.1 888.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhhHKN3nxtMJUGrn-GNjOCFpwc2ZFQ#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> N </script>  y <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.057ex" viewBox="0 -780.1 681.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhhHKN3nxtMJUGrn-GNjOCFpwc2ZFQ#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> L </script>  .  Los vectores individuales son una forma est√°ndar de especificar <em>direcciones</em> en el contexto de la codificaci√≥n de sombreadores. <br><br><div class="spoiler">  <b class="spoiler_title">El valor de N y L</b> <div class="spoiler_text">  <strong>Normal</strong> a la superficie <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.074ex" viewBox="0 -772.3 888.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhhHKN3nxtMJUGrn-GNjOCFpwc2ZFQ#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> N </script>  Es un vector unitario dirigido <em>lejos de</em> la superficie misma. <br><br>  Por analog√≠a, podemos suponer que la <strong>direcci√≥n de la iluminaci√≥n</strong> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.074ex" viewBox="0 -772.3 681.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhhHKN3nxtMJUGrn-GNjOCFpwc2ZFQ#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> L </script>  apunta <em>desde la</em> fuente de luz y sigue en la direcci√≥n en que se mueve la luz.  Pero esto no es as√≠: la direcci√≥n de la iluminaci√≥n es un solo vector que apunta <em>en la direcci√≥n de la</em> direcci√≥n de donde vino la luz. <br><br>  Esto puede ser confuso, especialmente si eres nuevo en la creaci√≥n de sombreadores.  Sin embargo, gracias a dicha notaci√≥n, las ecuaciones se vuelven m√°s simples. </div></div><br><div class="spoiler">  <b class="spoiler_title">Reflexi√≥n de Lambert en la Unidad</b> <div class="spoiler_text">  Antes del <strong>sombreador est√°ndar</strong> Unity 5, el reflejo de Lambert era el modelo est√°ndar para sombrear superficies iluminadas. <br><br>  Todav√≠a puede acceder a √©l en el Inspector de materiales: en el <em>sombreador Legacy,</em> se llama <em>Diffuse</em> . <br><br>  Si escribe su propio sombreador de superficie, la reflexi√≥n de Lambert est√° disponible como una funci√≥n de iluminaci√≥n llamada <code>Lambert</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Lambert fullforwardshadows</span></span></code> </pre> <br>  Su implementaci√≥n se puede encontrar en la funci√≥n <code>LightingLambert</code> definida en el archivo <code>CGIncludes\Lighting.cginc</code> . </div></div><br><div class="spoiler">  <b class="spoiler_title">Reflexi√≥n y clima de Lambert</b> <div class="spoiler_text">  La reflexi√≥n de Lambert es un modelo bastante antiguo, pero proporciona una comprensi√≥n de conceptos complejos como el sombreado de la superficie.  Tambi√©n se puede usar para explicar muchos otros fen√≥menos.  Por ejemplo, el mismo diagrama explica por qu√© hace m√°s fr√≠o en los polos del planeta que en el ecuador. </div></div><br>  Despu√©s de mirar m√°s de cerca, podemos ver que la superficie recibe la m√°xima cantidad de iluminaci√≥n cuando su normalidad es paralela a la direcci√≥n de la iluminaci√≥n.  Y viceversa: no hay luz si dos vectores unitarios son perpendiculares entre s√≠. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e1/d06/6c6/0e1d066c6ff998abda8ca5c7607e4c4e.png"></div><br>  Obviamente, el √°ngulo entre <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.057ex" viewBox="0 -780.1 888.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhhHKN3nxtMJUGrn-GNjOCFpwc2ZFQ#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> N </script>  y <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.057ex" viewBox="0 -780.1 681.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhhHKN3nxtMJUGrn-GNjOCFpwc2ZFQ#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> L </script>  cr√≠tico para la reflexi√≥n seg√∫n Lambert.  Adem√°s, el brillo es m√°ximo e igual a <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mn" id="MJXp-Span-14">100</span><span class="MJXp-mi" id="MJXp-Span-15">%</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7"> 100 \% </script>  cuando el √°ngulo es <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-16"><span class="MJXp-mn" id="MJXp-Span-17">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> 0 </script>  y m√≠nimo ( <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-18"><span class="MJXp-mn" id="MJXp-Span-19">0</span><span class="MJXp-mi" id="MJXp-Span-20">%</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> 0 \% </script>  ) cuando el √°ngulo tiende a <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-21"><span class="MJXp-msubsup" id="MJXp-Span-22"><span class="MJXp-mn" id="MJXp-Span-23" style="margin-right: 0.05em;">90</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-24" style="vertical-align: 0.5em;"><span class="MJXp-mtext" id="MJXp-Span-25">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-26">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29">c</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> 90 ^ {\ circ} </script>  .  Si est√° familiarizado con <em>el √°lgebra vectorial</em> , podr√≠a entender que una cantidad que representa el reflejo de Lambert <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">I</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> I </script>  es igual a <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-32"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33">N</span><span class="MJXp-mtext" id="MJXp-Span-34">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> N \ cdot L </script>  donde esta el operador <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-40"><span class="MJXp-mtext" id="MJXp-Span-41">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-42">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-44">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> \ cdot </script>  llamado un <strong>producto escalar</strong> . <br><br>  (1) <p><math> </math> $$ display $$ \ begin {ecation *} I = N \ cdot L \ end {ecation *} $$ display $$ </p><br>  El producto escalar es una medida de la "coincidencia" de dos vectores entre s√≠, y var√≠a en el intervalo de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-52"><span class="MJXp-mo" id="MJXp-Span-53" style="margin-left: 0em; margin-right: 0.111em;">+</span><span class="MJXp-mn" id="MJXp-Span-54">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> + 1 </script>  (para dos vectores id√©nticos) a <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-55"><span class="MJXp-mo" id="MJXp-Span-56" style="margin-left: 0em; margin-right: 0.111em;">‚àí</span><span class="MJXp-mn" id="MJXp-Span-57">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> -1 </script>  (para dos vectores opuestos).  Un producto escalar es la base del sombreado, que examin√© en detalle en el tutorial de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Modelos de iluminaci√≥n y renderizado basados ‚Äã‚Äãf√≠sicamente</a> . <br><br><h3>  Implementaci√≥n </h3><br>  Y a <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-58"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> N </script>  y para <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> L </script>  Puede acceder f√°cilmente a las funciones de iluminaci√≥n del sombreador de superficie a trav√©s de <code>s.Normal</code> y <code>gi.light.dirin</code> .  Por simplicidad, los cambiaremos de nombre en el c√≥digo del sombreador a <code>N</code> y <code>L</code> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate( dot(N, L) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NdotL; }</code> </pre> <br>  <code>saturate</code> funci√≥n de <code>saturate</code> limita el valor de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-62"><span class="MJXp-mn" id="MJXp-Span-63">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> 0 </script>  antes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-64"><span class="MJXp-mn" id="MJXp-Span-65">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> 1 </script>  .  Sin embargo, dado que el producto escalar est√° en el rango de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-66"><span class="MJXp-mo" id="MJXp-Span-67" style="margin-left: 0em; margin-right: 0.111em;">‚àí</span><span class="MJXp-mn" id="MJXp-Span-68">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> -1 </script>  antes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-69"><span class="MJXp-mo" id="MJXp-Span-70" style="margin-left: 0em; margin-right: 0.111em;">+</span><span class="MJXp-mn" id="MJXp-Span-71">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> + 1 </script>  , necesitaremos trabajar solo con sus valores negativos.  Es por eso que la reflexi√≥n de Lambert a menudo se implementa de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(N, L) );</code> </pre> <br><h2>  Contraste reflejo de la luz ambiental </h2><br>  Aunque el reflejo de Lambert sombrea bien la mayor√≠a de los materiales, no es ni f√≠sicamente exacto ni fotorrealista.  En juegos antiguos, los sombreadores Lambert se usaban ampliamente.  Los juegos que usan esta t√©cnica a menudo <em>parecen</em> viejos porque pueden reproducir inadvertidamente la est√©tica de los juegos antiguos.  Si no se esfuerza por esto, entonces debe evitarse la reflexi√≥n de Lambert y utilizar tecnolog√≠a m√°s moderna. <br><br>  Uno de estos modelos es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">el Modelo de reflexi√≥n de Oren-Nayyar</a> , que se describi√≥ originalmente en el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">Generalizaci√≥n del modelo de reflectancia de Lambert</a> , publicado en 1994 por Michael Oren y Sri C. Nayyar.  El modelo Oren-Nayyar es una generalizaci√≥n del reflejo de Lambert y est√° especialmente dise√±ado para superficies rugosas.  Inicialmente, los desarrolladores de Journey quer√≠an usar la reflexi√≥n de Oren-Nayyar como base para su sombreador de arena.  Sin embargo, esta idea fue abandonada debido a los altos costos inform√°ticos. <br><br>  En su informe de 2013, el artista t√©cnico John Edwards explica que el modelo de reflexi√≥n creado para la arena Journey se bas√≥ en una serie de prueba y error. Los desarrolladores intentaron no recrear la representaci√≥n fotorrealista del desierto, sino dar vida a una est√©tica concreta, inmediatamente reconocible. <br><br>  Seg√∫n √©l, el modelo de sombreado resultante corresponde a esta ecuaci√≥n: <br><br>  (2) <p><math> </math> $$ display $$ \ begin {ecation *} I = 4 * \ left (\ left (N \ odot \ left [1, 0.3, 1 \ right] \ right) \ cdot L \ right) \ end {ecuaci√≥n *} $$ display $$ </p><br>  donde <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-95"><span class="MJXp-mtext" id="MJXp-Span-96">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-100">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-24"> \ odot </script>  - <strong>elemento</strong> - <strong>producto sabio de</strong> dos vectores. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ Ny *= <span class="hljs-number"><span class="hljs-number">0.3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate(<span class="hljs-number"><span class="hljs-number">4</span></span> * dot(N, L)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NdotL; }</code> </pre> <br>  Modelo de reflexi√≥n (2) John Edwards llama <strong>contraste difuso</strong> , por lo que utilizaremos este nombre a lo largo del tutorial. <br><br>  La siguiente animaci√≥n muestra la diferencia en el sombreado de Lambert (izquierda) y el contraste difuso de Journey (derecha). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/q-hQiDA71Yg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><div class="spoiler">  <b class="spoiler_title">¬øCu√°l es el significado de 4 y 0.3?</b> <div class="spoiler_text">  Aunque el contraste difuso no fue dise√±ado para ser f√≠sicamente preciso, a√∫n podemos tratar de entender lo que hace. <br><br>  En esencia, todav√≠a usa la reflexi√≥n de Lambert.  La primera diferencia obvia es que el resultado general se multiplica por <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-101"><span class="MJXp-mn" id="MJXp-Span-102">4</span></span></span><script type="math/tex" id="MathJax-Element-25"> 4 </script>  .  Esto significa que todos los p√≠xeles que normalmente se recibieron <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-103"><span class="MJXp-mn" id="MJXp-Span-104">25</span><span class="MJXp-mi" id="MJXp-Span-105">%</span></span></span><script type="math/tex" id="MathJax-Element-26"> 25 \% </script>  la iluminaci√≥n ahora brillar√° como si recibiera <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-106"><span class="MJXp-mn" id="MJXp-Span-107">100</span><span class="MJXp-mi" id="MJXp-Span-108">%</span></span></span><script type="math/tex" id="MathJax-Element-27"> 100 \% </script>  iluminaci√≥n  Multiplicando todo por <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-109"><span class="MJXp-mn" id="MJXp-Span-110">4</span></span></span><script type="math/tex" id="MathJax-Element-28"> 4 </script>  El sombreado d√©bil seg√∫n Lambert se vuelve mucho m√°s fuerte, y la regi√≥n de transici√≥n entre la oscuridad y la luz es m√°s peque√±a.  En este caso, la sombra se vuelve m√°s n√≠tida. <br><br>  Efecto de la multiplicaci√≥n del componente <code>y</code> en la direcci√≥n normal <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-111"><span class="MJXp-mn" id="MJXp-Span-112">0.3</span></span></span><script type="math/tex" id="MathJax-Element-29"> 0.3 </script>  explicar es mucho m√°s dif√≠cil.  A medida que cambian los componentes del vector, cambia la direcci√≥n general en la que apunta.  Reduciendo el componente <code>y</code> a todo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-113"><span class="MJXp-mn" id="MJXp-Span-114">30</span><span class="MJXp-mi" id="MJXp-Span-115">%</span></span></span><script type="math/tex" id="MathJax-Element-30"> 30 \% </script>  desde su valor original, el reflejo del contraste difuso hace que las sombras se vuelvan m√°s verticales. <br><br>  Nota: un producto escalar mide directamente el √°ngulo entre dos vectores solo si ambos tienen longitud <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-116"><span class="MJXp-mn" id="MJXp-Span-117">1</span></span></span><script type="math/tex" id="MathJax-Element-31"> 1 </script>  .  El cambio realizado reduce la longitud normal <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-118"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119">N</span></span></span><script type="math/tex" id="MathJax-Element-32"> N </script>  que ya no es un vector unitario. </div></div><br><h2>  De tonos de gris a color. </h2><br>  Todas las animaciones que se muestran arriba tienen sombras de gris, porque muestran los valores de su modelo de reflexi√≥n, variando en el intervalo de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-120"><span class="MJXp-mn" id="MJXp-Span-121">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-33-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-33"> 0 </script>  antes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-122"><span class="MJXp-mn" id="MJXp-Span-123">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-34-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-34"> 1 </script>  ". Podemos agregar colores f√°cilmente usando <code>NdotL</code> como el coeficiente de interpolaci√≥n entre dos colores: uno para arena completamente sombreada y otro para arena completamente iluminada. <br><br><pre> <code class="cpp hljs">float3 _TerrainColor; float3 _ShadowColor; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ Ny *= <span class="hljs-number"><span class="hljs-number">0.3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate(<span class="hljs-number"><span class="hljs-number">4</span></span> * dot(N, L)); float3 color = lerp(_ShadowColor, _TerrainColor, NdotL); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color; }</code> </pre> <br><h2>  Parte 3. Arena normal </h2><br>  En la tercera parte, nos centraremos en crear mapas normales que conviertan modelos 3D suaves en dunas de arena. <br><br>  En la parte anterior del tutorial, implementamos la iluminaci√≥n difusa de la arena Journey.  Cuando se usa solo este efecto, las dunas del desierto parecer√°n bastante planas y aburridas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cb/dd6/9a8/8cbdd69a8a92614469132400c0979c79.png"></div><br>  Uno de los efectos m√°s intrigantes de Journey es la granulosidad de la arena.  Al observar cualquier captura de pantalla, nos parece que las dunas no son lisas y homog√©neas, sino que se crean a partir de millones de granos microsc√≥picos de arena. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e93/307/efc/e93307efce359d4830f5894dde30c9e6.jpg"></div><br>  Este efecto se puede lograr utilizando una t√©cnica llamada <strong>mapeo de relieve</strong> , que permite que la luz rebote en una superficie plana como si fuera m√°s compleja.  Vea c√≥mo este efecto cambia la apariencia del renderizado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br>  Se pueden ver peque√±as diferencias al aumentar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/3d5/b3f/ea73d5b3fb56c941c9b61f022dcb8699.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f8/efa/5c4/2f8efa5c4926a0de947b8ff91e114498.png"></div><br><h2>  Nos ocupamos de los mapas normales. </h2><br>  La arena consiste en innumerables granos de arena, cada uno de los cuales tiene su propia forma y composici√≥n (ver m√°s abajo).  Cada part√≠cula individual refleja la iluminaci√≥n en una direcci√≥n potencialmente aleatoria.  Una forma de realizar este efecto es crear un modelo 3D que contenga todos estos granos microsc√≥picos de arena.  Pero debido a la incre√≠ble cantidad de pol√≠gonos requeridos, este enfoque no es factible. <br><br>  Pero hay otra soluci√≥n que a menudo se usa para simular una geometr√≠a m√°s compleja en comparaci√≥n con un modelo 3D real.  Cada v√©rtice o cara del modelo 3D est√° asociado con un par√°metro llamado su <strong>direcci√≥n normal</strong> .  Este es un vector de longitud unitaria utilizado para calcular la reflexi√≥n de la luz en la superficie de un modelo 3D.  Es decir, para simular arena, debe simular esta distribuci√≥n aparentemente aleatoria de granos de arena y, por lo tanto, c√≥mo afectan las normales de la superficie. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/bc4/cc3/413bc4cc3466b827a1a1d86559d54054.jpg"></div><br>  Esto se puede hacer de innumerables maneras.  Lo m√°s simple es crear una textura que cambie la direcci√≥n de las normales originales del modelo de duna. <br><br>  <strong>Normal a la superficie</strong> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-124"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-125">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-35-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-35"> N </script>  en el caso general, se calcula por la geometr√≠a del modelo 3D.  Sin embargo, puede modificarlo usando el <strong>mapa normal</strong> .  Los mapas normales son texturas que le permiten simular geometr√≠as m√°s complejas cambiando la orientaci√≥n local de las normales a la superficie.  Esta t√©cnica a menudo se llama <strong>mapeo de relieve</strong> . <br><br>  Cambiar las normales es una tarea bastante simple que se puede realizar en la funci√≥n de <strong>navegaci√≥n del sombreador de superficie</strong> .  Esta funci√≥n toma dos par√°metros, uno de los cuales es una <code>struct</code> llamada <code>SurfaceOutput</code> .  Contiene todas las propiedades necesarias para representar una parte de un modelo 3D, desde su color ( <code>o.Albedo</code> ) hasta la transparencia ( <code>o.Alpha</code> ).  Otro par√°metro que contiene es la direcci√≥n normal ( <code>o.Normal</code> ), que puede reescribirse para cambiar la forma en que la luz se refleja en el modelo. <br><br>  De acuerdo con la documentaci√≥n de Unity sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">Surface Shaders</a> , todas las normales escritas en la estructura <code>o.Normal</code> deben expresarse en <strong>espacio tangente</strong> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SurfaceOutput</span></span></span><span class="hljs-class"> {</span></span> fixed3 Albedo; <span class="hljs-comment"><span class="hljs-comment">// diffuse color fixed3 Normal; // tangent space normal, if written fixed3 Emission; half Specular; // specular power in 0..1 range fixed Gloss; // specular intensity fixed Alpha; // alpha for transparencies };</span></span></code> </pre> <br>  Por lo tanto, podemos informar que los vectores unitarios deben expresarse en el sistema de coordenadas relativo a la malla normal.  Por ejemplo, al escribir en <code>o.Normal</code> valores de <code>float3(0, 0, 1)</code> normal permanecer√°n sin cambios. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; o.Normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Esto se debe a que el vector <code>float3(0, 0, 1)</code> es en realidad un vector normal expresado en relaci√≥n con la geometr√≠a del modelo 3D. <br><br>  Entonces, para cambiar la normalidad a la superficie en el <strong>sombreador de superficie</strong> , solo necesitamos escribir un nuevo vector en <strong>la funci√≥n de superficie</strong> en <code>o.Normal</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; o.Normal = ... <span class="hljs-comment"><span class="hljs-comment">// change the normal here }</span></span></code> </pre> <br>  En el resto de la publicaci√≥n, crearemos la aproximaci√≥n inicial, que complicaremos en la sexta parte del tutorial. <br><br><h2>  Arena normal </h2><br>  La parte m√°s problem√°tica es comprender <em>c√≥mo los</em> granos de arena cambian de forma normal a la superficie.  Aunque individualmente cada grano de arena puede dispersar la luz en cualquier direcci√≥n, en general, sucede algo m√°s.  Cualquier enfoque f√≠sicamente preciso debe estudiar la distribuci√≥n de los vectores normales en la superficie de la arena y modelarla matem√°ticamente.  Tales modelos realmente existen, pero la soluci√≥n presentada en nuestro tutorial es mucho m√°s simple y al mismo tiempo es muy efectiva. <br><br>  En cada punto del modelo, <strong>se</strong> muestrea un <strong>vector unitario aleatorio a</strong> partir de la textura.  Entonces, lo normal a la superficie se inclina una cierta cantidad hacia este vector.  Con la creaci√≥n correcta de una textura aleatoria y la selecci√≥n de una cantidad apropiada de mezcla, podemos cambiar la normalidad a la superficie de tal manera que creemos una sensaci√≥n de grano, sin perder la curvatura general de las dunas. <br><br>  Los valores aleatorios se pueden muestrear usando una textura llena de colores aleatorios.  Los componentes R, G y B de cada p√≠xel se usan como componentes X, Y y Z del vector normal.  Los componentes de color est√°n en el rango <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-126"><span class="MJXp-mtext" id="MJXp-Span-127">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-128">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-129">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131">t</span><span class="MJXp-mo" id="MJXp-Span-132" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mn" id="MJXp-Span-133">0</span><span class="MJXp-mo" id="MJXp-Span-134" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-135">1</span><span class="MJXp-mtext" id="MJXp-Span-136">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-137">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-138">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-139">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-140">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-141">t</span><span class="MJXp-mo" id="MJXp-Span-142" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-36-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-36"> \ left [0, 1 \ right] </script>  , por lo que deben convertirse en intervalo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-143"><span class="MJXp-mtext" id="MJXp-Span-144">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-145">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-146">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-147">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-148">t</span><span class="MJXp-mo" id="MJXp-Span-149" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mo" id="MJXp-Span-150" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mn" id="MJXp-Span-151">1</span><span class="MJXp-mo" id="MJXp-Span-152" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-153" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-154">1</span><span class="MJXp-mtext" id="MJXp-Span-155">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-156">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-157">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-158">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-159">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-160">t</span><span class="MJXp-mo" id="MJXp-Span-161" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-37-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-37"> \ left [-1, + 1 \ right] </script>  .  Luego, el vector resultante se normaliza para que su longitud sea igual a <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-162"><span class="MJXp-mn" id="MJXp-Span-163">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-38-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-38"> 1 </script>  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d2/c95/03d/0d2c9503d98fd2463e7e3682743736bd.png"></div><br><div class="spoiler">  <b class="spoiler_title">Crea texturas aleatorias</b> <div class="spoiler_text">  Hay muchas formas de generar texturas aleatorias.  Para obtener el efecto deseado, lo m√°s importante es la distribuci√≥n general de vectores aleatorios que se pueden muestrear a partir de la textura. <br><br>  En la imagen de arriba, cada p√≠xel es completamente aleatorio.  No existe una direcci√≥n general (color) que prevalezca en la textura, porque cada valor tiene la misma probabilidad que todos los dem√°s.  Esta textura nos da un tipo de arena que dispersa la luz en todas las direcciones. <br><br>  Durante una charla de GDC, John Edwards dej√≥ en claro que la textura aleatoria utilizada para la arena en Journey se gener√≥ a partir de una distribuci√≥n gaussiana.  Esto asegura que la direcci√≥n predominante coincida con la normal a la superficie. </div></div><br><div class="spoiler">  <b class="spoiler_title">¬øLos vectores aleatorios necesitan ser normalizados?</b> <div class="spoiler_text">  La imagen que utilic√© para muestrear vectores aleatorios se gener√≥ mediante un proceso completamente aleatorio.  No solo cada p√≠xel se genera individualmente: los componentes R, G y B de un p√≠xel tambi√©n son independientes entre s√≠.  Es decir, en el caso general, no se garantizar√° que los vectores muestreados a partir de esta textura tengan una longitud igual a <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-164"><span class="MJXp-mn" id="MJXp-Span-165">1</span></span></span><script type="math/tex" id="MathJax-Element-39"> 1 </script>  . <br><br>  Por supuesto, puede generar una textura en la que cada p√≠xel al convertir de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-166"><span class="MJXp-mtext" id="MJXp-Span-167">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-168">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-169">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-170">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-171">t</span><span class="MJXp-mo" id="MJXp-Span-172" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mn" id="MJXp-Span-173">0</span><span class="MJXp-mo" id="MJXp-Span-174" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-175">1</span><span class="MJXp-mtext" id="MJXp-Span-176">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-177">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-178">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-179">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-180">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-181">t</span><span class="MJXp-mo" id="MJXp-Span-182" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><script type="math/tex" id="MathJax-Element-40"> \ left [0, 1 \ right] </script>  en <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-183"><span class="MJXp-mtext" id="MJXp-Span-184">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-185">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-186">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-187">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-188">t</span><span class="MJXp-mo" id="MJXp-Span-189" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mo" id="MJXp-Span-190" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mn" id="MJXp-Span-191">1</span><span class="MJXp-mo" id="MJXp-Span-192" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-193" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-194">1</span><span class="MJXp-mtext" id="MJXp-Span-195">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-196">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-197">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-198">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-199">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-200">t</span><span class="MJXp-mo" id="MJXp-Span-201" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><script type="math/tex" id="MathJax-Element-41"> \ left [-1, + 1 \ right] </script>  y de hecho tendr√° que tener una longitud <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-202"><span class="MJXp-mn" id="MJXp-Span-203">1</span></span></span><script type="math/tex" id="MathJax-Element-42"> 1 </script>  .  Sin embargo, aqu√≠ surgen dos problemas. <br><br> ,             . -,    <em> </em>   mip-,             . <br><br>   ,    . </div></div><br><h2>  Implementaci√≥n </h2><br>         ¬´ ¬ª,        <strong> </strong> <code>surf</code> .  ,    ,   ,      Journey   .  ( <em> </em> )      ,   ( <em> </em> )    . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; float3 N = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); N = RipplesNormal(N); <span class="hljs-comment"><span class="hljs-comment">// Covered in Journey Sand Shader #6 N = SandNormal (N); // Covered in this article o.Normal = N; }</span></span></code> </pre> <br>         (bump mapping),   ,        (    <code>uv_SandTex</code> ). <br><br>       ,        ,   . ,     <strong>UV-</strong> ,  ,     .    3D-     UV-,      UV    . <br><br><pre> <code class="cpp hljs">N = WavesNormal(IN.uv_SandTex.xy, N); N = SandNormal (IN.uv_SandTex.xy, N);</code> </pre> <br>         ( <code>IN.worldPos</code> )  . <br><br>   -    <code>SandNormal</code>   .      ,            (    )    . <br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, uv).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); return S; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title">    ?</b> <div class="spoiler_text">    UV- 3D-      ,   .      ,       . <br><br>   ,  Unity   .   ,        <code>_SandText_ST</code> . Unity       (  ) <code>_SandTex</code> . <br><br>  <code>_SandText_ST</code>    :     .        ,          <em>Tiling</em>  <em>Offset</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f29/a84/059/f29a84059ab970f412217f09c87fcf6f.png"></div><br>       ,     <code>TRANSFORM_TEX</code> : <br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; float4 _SandTex_ST; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, TRANSFORM_TEX(uv, _SandTex)).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); return S; }</span></span></code> </pre> </div></div><br><h2>   </h2><br>     ,      .   :        ,      .   ,      ,      ,     ‚Äî     . <br><br>       .     ,   ,      .     , -      . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/620/9cb/acb/6209cbacb616db15bee5f95e314779c8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/476/f0a/f25/476f0af2535dc2d552ce4b01a1d7751a.png"></div><br>     .    .  ,   ,    <em></em>    ,   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/929/dfb/7e6/929dfb7e6d4712b7c69a403d0733c25b.png" width="239" height="240"></div><br>      <strong>slerp</strong> ,    <strong>spherical linear interpolation</strong> (  ). <em>Slerp</em>     ,   lerp,    ‚Äî         ,       . <br><br>  ,   slerp  .   ,      ,   . <br><br><div class="spoiler"> <b class="spoiler_title">   slerp</b> <div class="spoiler_text">    , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-204"><span class="MJXp-msubsup" id="MJXp-Span-205"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-206" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-207" style="vertical-align: -0.4em;">0</span></span></span></span><script type="math/tex" id="MathJax-Element-43">p_0</script>  y <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-208"><span class="MJXp-msubsup" id="MJXp-Span-209"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-210" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-211" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex" id="MathJax-Element-44">p_1</script>   ,       .  Entonces <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-212"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-213">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-214">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-215">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-216">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-217">p</span></span></span><script type="math/tex" id="MathJax-Element-45">slerp</script>    : <br><br> (1) <p><math> <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-218"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-219">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-220">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-221">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-222">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-223">p</span><span class="MJXp-mrow" id="MJXp-Span-224"><span class="MJXp-mo" id="MJXp-Span-225" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">(</span></span><span class="MJXp-msubsup" id="MJXp-Span-226"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-227" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-228" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-229" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-230"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-231" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-232" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-233" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-234">t</span><span class="MJXp-mo" id="MJXp-Span-235" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">)</span></span></span><span class="MJXp-mo" id="MJXp-Span-236" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mfrac" id="MJXp-Span-237" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-238">sin</span><span class="MJXp-mo" id="MJXp-Span-239" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-240"><span class="MJXp-mo" id="MJXp-Span-241" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mrow" id="MJXp-Span-242"><span class="MJXp-mo" id="MJXp-Span-243" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-244">1</span><span class="MJXp-mo" id="MJXp-Span-245" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-246">t</span><span class="MJXp-mo" id="MJXp-Span-247" style="margin-left: 0em; margin-right: 0em;">)</span></span><span class="MJXp-mi" id="MJXp-Span-248">Œ©</span><span class="MJXp-mo" id="MJXp-Span-249" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-250">sin</span><span class="MJXp-mo" id="MJXp-Span-251" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-252"><span class="MJXp-mo" id="MJXp-Span-253" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi" id="MJXp-Span-254">Œ©</span><span class="MJXp-mo" id="MJXp-Span-255" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-256"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-257" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-258" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-259" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mfrac" id="MJXp-Span-260" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-261">sin</span><span class="MJXp-mo" id="MJXp-Span-262" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-263"><span class="MJXp-mo" id="MJXp-Span-264" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-265">t</span><span class="MJXp-mi" id="MJXp-Span-266">Œ©</span><span class="MJXp-mo" id="MJXp-Span-267" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-268">sin</span><span class="MJXp-mo" id="MJXp-Span-269" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-270"><span class="MJXp-mo" id="MJXp-Span-271" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi" id="MJXp-Span-272">Œ©</span><span class="MJXp-mo" id="MJXp-Span-273" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-274"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-275" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-276" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-46">\begin{equation*} slerp\left(p_0, p_1, t\right) = \frac{\sin\left[\left(1-t\right)\Omega\right]}{\sin\left(\Omega\right)}p_0 + \frac{\sin\left(t\Omega\right)}{\sin\left(\Omega\right)} p_1 \end{equation*}</script> </math></p><br>  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-277"><span class="MJXp-mi" id="MJXp-Span-278">Œ©</span></span></span><script type="math/tex" id="MathJax-Element-47">\Omega</script> ‚Äî     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-279"><span class="MJXp-msubsup" id="MJXp-Span-280"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-281" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-282" style="vertical-align: -0.4em;">0</span></span></span></span><script type="math/tex" id="MathJax-Element-48">p_0</script>  y <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-283"><span class="MJXp-msubsup" id="MJXp-Span-284"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-285" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-286" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex" id="MathJax-Element-49">p_1</script> ,       : <br><br> (2) <p><math> <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-287"><span class="MJXp-mi" id="MJXp-Span-288">Œ©</span><span class="MJXp-mo" id="MJXp-Span-289" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-290">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-291">o</span><span class="MJXp-msubsup" id="MJXp-Span-292"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-293" style="margin-right: 0.05em;">s</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-294" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-295">‚àí</span><span class="MJXp-mn" id="MJXp-Span-296">1</span></span></span><span class="MJXp-mrow" id="MJXp-Span-297"><span class="MJXp-mo" id="MJXp-Span-298" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">(</span></span><span class="MJXp-msubsup" id="MJXp-Span-299"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-300" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-301" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-302" style="margin-left: 0.267em; margin-right: 0.267em;">‚ãÖ</span><span class="MJXp-msubsup" id="MJXp-Span-303"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-304" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-305" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-306" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">)</span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-50">\begin{equation*} \Omega=cos^{-1} \left(p_0 \cdot p_1 \right) \end{equation*}</script> </math></p><br></div></div><br>  ,      <strong> </strong> ,       : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eef/5e1/42f/eef5e142f1c8c05cac9b3d4f18d8e097.png" width="239" height="240"></div><br>  Lerp           .   ,    ,   ,    <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-307"><span class="MJXp-mn" id="MJXp-Span-308">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-51-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-51">1</script>  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-309"><span class="MJXp-mn" id="MJXp-Span-310">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-52-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-52">0</script>  . <br><br>   ,    lerp      ,      ,  slerp: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nlerp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 n1, float3 n2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> normalize(lerp(n1, n2, t)); }</code> </pre> <br>  ,  <strong>nlerp</strong> ,    slerp.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer"> </a> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">The Witness</a> .       ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">Understanding Slerp. Then Not Using It</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer"> </a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">Math Magician ‚Äì Lerp, Slerp, and Nlerp</a> . <br><br>  nlerp          ,   <code>_SandTex</code> : <br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _SandStrength; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, uv).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); // Rotates N towards Ns based on _SandStrength float3 Ns = nlerp(N, S, _SandStrength); return Ns; }</span></span></code> </pre> <br>   : <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rddUAStRjZ8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Que sigue </h2><br>       ,      . <br><br><h3>  Agradecimientos </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">Journey</a>  <strong>Thatgamecompany</strong>   <strong>Sony Computer Entertainment</strong> .    PC ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">Epic Store</a> )  PS4 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">PS Store</a> ). <br><br> 3D-       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">Jiadi Deng</a> . <br><br> 3D-  Journey    ( )  FacePunch. <br><br><h2>  Unity </h2><br>      ,    Unity    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">Patreon</a> .     ,    3D-. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/476448/">https://habr.com/ru/post/476448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../476434/index.html">Escribimos controladores USB para dispositivos abandonados.</a></li>
<li><a href="../476436/index.html">Informes de la primera reuni√≥n en Rusia de desarrolladores de robots sobre Robot Operating System</a></li>
<li><a href="../476442/index.html">Dar algo de espacio o un microcontrolador como un medidor de frecuencia</a></li>
<li><a href="../476444/index.html">Desmitificaci√≥n de los principios de la computaci√≥n cu√°ntica.</a></li>
<li><a href="../476446/index.html">Complementos de Jira: algunos ejemplos de la invenci√≥n exitosa de la bicicleta</a></li>
<li><a href="../476450/index.html">Descripci√≥n general de cPanel: una consola basada en web para administrar sitios y hosting</a></li>
<li><a href="../476452/index.html">Almacenamiento de valor clave o c√≥mo nuestras aplicaciones se han vuelto m√°s convenientes</a></li>
<li><a href="../476454/index.html">Se acerca el 5G: qu√© empresas garantizar√°n la introducci√≥n de nuevas tecnolog√≠as en 2020</a></li>
<li><a href="../476456/index.html">El sistema de cr√©dito social chino no es, en primer lugar, un sistema de evaluaci√≥n ciudadana, sino un API masivo</a></li>
<li><a href="../476460/index.html">El primer formato de archivo de √©xito en Internet no era MP3, sino MIDI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>