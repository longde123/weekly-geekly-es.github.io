<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úäüèΩ üßôüèæ ‚öõÔ∏è MIRO est une plate-forme de robot int√©rieure ouverte. Partie 5 - Composant logiciel: ARDUINO (AVR), on grimpe "sous le capot" üë©üèª‚Äçüî¨ üå≠ üë©üèæ‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cette fois, nous allons approfondir un peu la mise en ≈ìuvre de certaines m√©thodes de biblioth√®que cl√©s pour ARDUINO (AVR), qui sont responsables du d√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIRO est une plate-forme de robot int√©rieure ouverte. Partie 5 - Composant logiciel: ARDUINO (AVR), on grimpe "sous le capot"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477118/"><img src="https://habrastorage.org/webt/m-/j7/gm/m-j7gmvwywlwzlopp5x-27y_jta.png" alt="image"><br><br>  Cette fois, nous allons approfondir un peu la mise en ≈ìuvre de certaines m√©thodes de biblioth√®que cl√©s pour ARDUINO (AVR), qui sont responsables du d√©placement du robot MIRO.  Cette partie sera int√©ressante pour tous ceux qui se demandent comment contr√¥ler la vitesse lin√©aire et angulaire du robot sur l'ARDUINO, √©quip√© de moteurs avec les encodeurs les plus simples. <br><a name="habracut"></a><br>  Table des mati√®res: <a href="https://habr.com/ru/post/472380/">Partie 1</a> , <a href="https://habr.com/ru/post/472802/">Partie 2</a> , <a href="https://habr.com/ru/post/473368/">Partie 3</a> , <a href="https://habr.com/ru/post/475512/">Partie 4</a> , <a href="https://habr.com/ru/post/477118/">Partie 5</a> . <br><br>  Les m√©thodes responsables de la conduite avec odom√©trie sont toujours p√©nibles pour expliquer comment, quoi et pourquoi.  La premi√®re chose que vous devez savoir sur le contr√¥le du mouvement du robot est le fait simple et √©vident que les moteurs collecteurs du robot ne tournent jamais √† la m√™me vitesse sans r√©glage suppl√©mentaire.  Embrayage diff√©rent, diff√©rentes caract√©ristiques de sortie des canaux de commande, moteurs √©lectriques l√©g√®rement diff√©rents et lubrification dans la bo√Æte de vitesses. <br><br>  Le deuxi√®me fait que vous devez comprendre et conna√Ætre est la pr√©sence d'inertie dans le moteur, m√™me avec un rapport de transmission suffisamment important.  C'est-√†-dire  lors de la suppression de la tension aux bornes du moteur, la roue, m√™me non charg√©e, fait un mouvement de quelques degr√©s de plus.  L'amplitude de cette rotation suppl√©mentaire d√©pend de la force de charge sur la roue, de la vitesse de rotation avant de rel√¢cher la tension et des m√™mes facteurs invisibles comme le type et la quantit√© de lubrifiant dans la bo√Æte de vitesses. <br><br>  Ces faits d√©terminent la mise en ≈ìuvre d'un ensemble de m√©thodes li√©es au d√©placement d'un ch√¢ssis √©quip√© de capteurs odom√®tre (dans le cas de MIRO, codeurs num√©riques pour chaque roue). <br><br>  Comme nous l'avons d√©couvert dans la quatri√®me partie, la classe <b>Ch√¢ssis</b> existe dans le mod√®le logiciel, qui met en ≈ìuvre le contr√¥le de rotation des moteurs de ch√¢ssis individuels.  Je veux souligner - non pas le contr√¥le du mouvement du ch√¢ssis, du chariot, mais le contr√¥le des moteurs du chariot.  Le contr√¥le direct du chariot est impl√©ment√© dans les classes <b>Robot</b> et <b>Miro</b> . <br><br>  Commen√ßons par le haut.  Ci-dessous, une m√©thode de la classe <b>Miro</b> qui impl√©mente le mouvement d'un robot sur une certaine distance ( <b>dist</b> , m√®tres) avec des <b>vitesses</b> lin√©aires ( <b>lin_speed</b> , m / s) et angulaires ( <b>ang_speed</b> , deg / s) donn√©es.  <b>Nous</b> ne <b>pr√™tons</b> pas encore attention au param√®tre <b>en_break</b> . <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Miro::moveDist(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lin_speed, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ang_speed, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> en_break) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _wheelSetAngSpeed[WHEEL_COUNT]; _wheelSetAngSpeed[LEFT] = MIRO_PI2ANG * (lin_speed - (ROBOT_DIAMETER * ang_speed / (<span class="hljs-number"><span class="hljs-number">2</span></span> * MIRO_PI2ANG))) / WHEEL_RADIUS; _wheelSetAngSpeed[RIGHT] = MIRO_PI2ANG * (lin_speed + (ROBOT_DIAMETER * ang_speed / (<span class="hljs-number"><span class="hljs-number">2</span></span> * MIRO_PI2ANG))) / WHEEL_RADIUS; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _wheelSetAng[WHEEL_COUNT]; _wheelSetAng[RIGHT] = _wheelSetAngSpeed[RIGHT] * dist / lin_speed; _wheelSetAng[LEFT] = _wheelSetAngSpeed[LEFT] * dist / lin_speed; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;chassis.wheelRotateAng(_wheelSetAngSpeed, _wheelSetAng, en_break); }</code> </pre> <br>  Dans cette m√©thode, les vitesses angulaires REQUISES pour les moteurs gauche et droit sont d'abord calcul√©es.  Selon des formules assez √©videntes, ce qui n'est pas un probl√®me √† d√©duire.  Il suffit de garder √† l'esprit que la vitesse lin√©aire dans la m√©thode est sp√©cifi√©e en m√®tres par seconde, et la vitesse angulaire en degr√©s par seconde (pas en radians).  Par cons√©quent, nous pr√©-calculons la constante <b>MIRO_PI2ANG = 57,29 = 180 / pi.</b>  <b>ROBOT_DIAMETER</b> - distance entre les roues gauche et droite du robot (en m√®tres), <b>WHEEL_RADIUS</b> - rayon de roue (√©galement en m√®tres).  Toutes les constantes num√©riques pour de tels cas sont contenues dans le fichier defs.h et les param√®tres personnalis√©s du robot et du ch√¢ssis se trouvent dans le fichier config.h. <br><br>  Apr√®s cela, l'angle est calcul√© par lequel chaque roue doit √™tre tourn√©e de sorte que le robot parcourt la distance <b>dist</b> (√©galement en m√®tres). <br><br>  Ainsi, √† ce stade, nous obtenons √† quelle vitesse et √† quel angle vous devez faire tourner chaque roue du ch√¢ssis du robot.  Et puis la m√©thode <b>wheelRotateAng ()</b> de l'objet <b>ch√¢ssis</b> est appel√©e. <br><br>  La m√©thode <b>wheelRotateAng (float * speed, float * ang, bool en_break)</b> est utilis√©e pour faire tourner les roues du robot avec les vitesses angulaires sp√©cifi√©es par le tableau <b>speed []</b> (en m / s) selon les angles sp√©cifi√©s par le tableau <b>ang []</b> (en degr√©s).  Le dernier param√®tre <b>en_break</b> (d√©j√† rencontr√© par nous plus t√¥t) d√©finit l'exigence d'un arr√™t dur des roues apr√®s avoir effectu√© un virage en leur appliquant une tension inverse √† court terme.  Cela est n√©cessaire pour supprimer l'inertie du robot, l'emp√™chant de se d√©placer au-del√† de la distance requise d√©j√† apr√®s avoir supprim√© la tension de commande des moteurs.  Pour une satisfaction compl√®te, bien s√ªr, il existe la m√©thode <b>wheelRotateAngRad ()</b> , similaire √† <b>wheelRotateAng (),</b> √† la diff√©rence <b>pr√®s</b> qu'elle prend les valeurs des angles de rotation et des vitesses angulaires en radians et radians par seconde comme param√®tres. <br><br>  L'algorithme de la m√©thode <b>wheelRotateAng ()</b> est le suivant. <br><br>  1. Tout d'abord, la correspondance des valeurs de <b>vitesse []</b> et <b>ang [] avec</b> certaines conditions aux limites est v√©rifi√©e.  √âvidemment, le ch√¢ssis pr√©sente des limitations physiques √† la fois sur la vitesse angulaire maximale de rotation des roues, et sur la vitesse minimale (vitesse minimale d'√©loignement).  De plus, les angles en <b>ang []</b> ne peuvent pas √™tre inf√©rieurs √† l'angle de rotation fixe minimum, d√©termin√© par la pr√©cision des codeurs. <br><br>  2. Ensuite, le sens de rotation de chaque roue est calcul√©.  De toute √©vidence √† travers le signe du produit <b>ang [i] * vitesse [i]</b> ; <br><br>  3. La ¬´distance de rotation¬ª <b>Dw [i]</b> pour chaque roue est calcul√©e - le nombre d'√©chantillons d'encodeur qui doivent √™tre effectu√©s pour tourner de l' <b>ang</b> donn√© <b>[i]</b> . <br>  Cette valeur est d√©termin√©e par la formule: <br><br>  <b>Dw [i] = ang [i] * WHEEL_SEGMENTS / 360</b> , <br>  o√π <b>WHEEL_SEGMENTS</b> est le nombre de segments de la roue codeuse (r√©volution compl√®te). <br><br>  4. La valeur de tension sur le pilote de moteur est enregistr√©e. <br><br><div class="spoiler">  <b class="spoiler_title">√Ä propos de la tension sur les moteurs</b> <div class="spoiler_text">  * <i>PWM est utilis√© pour contr√¥ler la rotation des moteurs, par cons√©quent, afin de conna√Ætre la tension fournie √† chaque moteur, il est n√©cessaire de conna√Ætre la tension d'alimentation du pilote de moteur.</i>  <i>Dans le robot MIRO, le pilote est connect√© directement au circuit d'alimentation de la batterie.</i>  <i>Fonction float getVoltage ();</i>  <i>renvoie la tension d'un diviseur de tension avec un facteur VOLTAGE_DIVIDER.</i>  <i>Tension de r√©f√©rence ADC: 5V.</i>  <i>√Ä l'heure actuelle, la valeur de VOLTAGE_DIVIDER dans le robot est de 2 et la tension d'une batterie (1S) de la batterie est fournie √† l'entr√©e ADC (PIN_VBAT).</i>  <i>Ce n'est pas tout √† fait correct du fait que les batteries peuvent se d√©charger de diff√©rentes mani√®res et perdre l'√©quilibre, mais, comme la pratique l'a montr√©, avec une charge constante d'une batterie avec √©quilibrage, la solution fonctionne tout √† fait.</i>  <i>√Ä l'avenir, nous pr√©voyons de faire un diviseur normal avec deux bo√Ætes de batterie.</i> <br></div></div><br>  5. Selon le tableau d'√©talonnage de chaque roue, la valeur initiale du signal PWM est d√©termin√©e, ce qui garantit la rotation de la roue √† la vitesse requise <b>[i]</b> .  De quel type de tableau d'√©talonnage et d'o√π provient-il - nous analyserons plus avant. <br><br>  6. La rotation des moteurs d√©marre en fonction des valeurs calcul√©es de vitesse et de sens de rotation.  Dans le texte de l'impl√©mentation de la classe, la m√©thode priv√©e <b>_wheel_rotate_sync () en</b> est responsable. <br><br>  Nous allons encore plus loin.  La m√©thode <b>_wheel_rotate_sync ()</b> fonctionne selon l'algorithme suivant: <br><br>  1. Dans une boucle infinie, une v√©rification est effectu√©e pour obtenir le compteur des r√©ponses du codeur de la distance de rotation <b>Dw [i]</b> pour chaque roue.  Si l'un des compteurs <b>Dw [i]</b> est atteint, toutes les roues s'arr√™tent et sortent du cycle puis quittent la fonction (√©tape 5).  Cela se fait pour les raisons suivantes.  En raison de la discr√©tion de mesurer l'angle de rotation, c'est une situation tr√®s courante lorsque la distance calcul√©e <b>Dw [i] d'</b> une roue est obtenue en arrondissant une valeur non enti√®re √† un petit c√¥t√© et <b>Dw [j] de la</b> deuxi√®me roue √† une plus grande.  Cela conduit au fait qu'apr√®s l'arr√™t d'une des roues, la deuxi√®me roue continue de tourner.  Pour un ch√¢ssis avec un entra√Ænement diff√©rentiel (et pour beaucoup d'autres), cela conduit √† un ¬´virage¬ª impr√©vu du robot √† la fin de la t√¢che.  Par cons√©quent, dans le cas de l'organisation du mouvement spatial de l'ensemble du ch√¢ssis, il est n√©cessaire d'arr√™ter tous les moteurs √† la fois. <br><br>  2. Si <b>Dw [i] n'est</b> pas atteint, alors dans la boucle le fait de la prochaine op√©ration de l'encodeur est v√©rifi√© (la variable <b>_syncloop [w]</b> , mise √† jour √† partir de l'interruption de l'encodeur et r√©initialis√©e dans cette boucle infinie).  Lorsque la prochaine intersection se produit, le programme calcule le module de la vitesse angulaire actuelle de chaque roue (deg / s), selon la formule √©vidente: <br><br>  <b>W [i] = (360 * tau [i]) / WHEEL_SEGMENTS</b> , <br>  o√π: <br>  <b>tau [i]</b> - la valeur moyenne du temps entre les deux derni√®res r√©ponses des encodeurs.  La ¬´profondeur¬ª du filtre de moyenne est d√©termin√©e par <b>MEAN_DEPTH</b> et <b>vaut</b> 8 par d√©faut. <br><br>  3. Sur la base des vitesses de roue calcul√©es, les erreurs absolues sont calcul√©es comme les diff√©rences entre les vitesses angulaires d√©finies et r√©elles. <br><br>  4. Sur la base des erreurs calcul√©es, l'action de contr√¥le (valeur du signal PWM) est corrig√©e pour chaque moteur. <br><br>  5. Apr√®s avoir atteint <b>Dw [i]</b> , dans le cas d'un <b>en_break</b> actif, une tension inverse √† court terme est appliqu√©e aux moteurs.  La dur√©e de cet effet est d√©termin√©e √† partir du tableau d'√©talonnage (voir ci-dessous) et varie g√©n√©ralement de 15 √† 40 ms. <br><br>  6. Il y a une lib√©ration compl√®te des contraintes des moteurs et quittez <b>_wheel_rotate_sync ()</b> . <br><br>  J'ai d√©j√† mentionn√© deux fois un certain tableau d'√©talonnage.  Ainsi, dans la biblioth√®que, il y a une table sp√©ciale de valeurs stock√©es dans l'EEPROM de la m√©moire du robot et contenant des enregistrements de trois valeurs li√©es: <br><br>  1. Tension aux bornes du moteur.  Il est calcul√© en convertissant la valeur du signal PWM en tension r√©elle.  Pour cela, √† l'√©tape 4 de la m√©thode <b>wheelRotateAng ()</b> , la tension r√©elle sur le pilote du moteur est enregistr√©e. <br><br>  2. La vitesse angulaire de rotation de la roue (sans charge) correspondant √† une tension donn√©e. <br><br>  3. La dur√©e du signal d'arr√™t dur correspondant √† cette vitesse angulaire. <br>  Par d√©faut, la taille de la table d'√©talonnage est de 10 enregistrements (d√©termin√©e par la constante <b>WHEEL_TABLE_SIZE</b> dans le fichier <b>config.h</b> ) - 10 triplets de valeurs "tension - vitesse angulaire - dur√©e du signal d'arr√™t". <br><br>  Pour d√©terminer les valeurs des entr√©es 2 et 3 dans ce tableau, une m√©thode sp√©ciale est utilis√©e - <b>wheelCalibrate (roue d'octets)</b> . <br><br>  Examinons-y un peu.  Cette m√©thode met en ≈ìuvre une s√©quence d'actions pour d√©terminer les valeurs manquantes dans le tableau d'√©talonnage moteur / roue, ainsi que pour conna√Ætre la vitesse angulaire minimale de d√©marrage et la vitesse angulaire maximale de la roue. <br><br>  Pour effectuer l'√©talonnage, le robot est mont√© sur un support; toute la rotation des roues pendant l'√©talonnage est effectu√©e sans charge. <br><br>  1. Vous devez d'abord d√©terminer la vitesse de d√©marrage minimale.  Cela se fait tr√®s simplement.  Dans un cycle, la commande PWM est envoy√©e au moteur, √† partir de 0, avec un incr√©ment de 1. √Ä chaque √©tape, le programme attend un certain temps, d√©termin√© par la constante <b>WHEEL_TIME_MAX</b> ( <b>d√©lai</b> normal <b>()</b> ).  Une fois le temps d'attente √©coul√©, il v√©rifie si le d√©marrage est termin√© (en modifiant la valeur du compteur du codeur).  Si le retrait est termin√©, la vitesse angulaire de rotation de la roue est calcul√©e.  Pour plus de certitude, la valeur de 10 est ajout√©e √† la valeur du PWM correspondant √† cette vitesse de d√©marrage, ce qui donne la premi√®re paire de valeurs ¬´tension sur le moteur¬ª - ¬´vitesse angulaire¬ª. <br><br>  2. Une fois la vitesse de d√©marrage trouv√©e, le pas PWM est calcul√© pour remplir uniform√©ment la table d'√©talonnage. <br><br>  3. Dans le cycle, pour chaque nouvelle valeur PWM, la roue tourne de 2 tours complets et la vitesse angulaire est mesur√©e selon un algorithme similaire √† la m√©thode <b>_wheel_rotate_sync ()</b> .  Dans le m√™me cycle, √©galement par approximation successive, la valeur optimale de la dur√©e du signal d'arr√™t dur est mesur√©e.  Dans un premier temps, une certaine valeur √©videmment grande est prise.  Et puis il est test√© en mode "turn-stop".  Comme valeur optimale, la valeur maximale de la dur√©e du signal d'arr√™t est s√©lectionn√©e, √† laquelle la ¬´distance de virage¬ª d√©finie n'est pas d√©pass√©e.  En d'autres termes, une telle valeur de la dur√©e du signal, lors de l'alimentation du moteur d'une part, l'inertie est supprim√©e, et d'autre part, il n'y a pas de mouvement inverse √† court terme (qui est fix√© par le m√™me codeur). <br><br>  4. Une fois l'√©talonnage termin√©, la tension de commande du moteur √©talonn√© cesse d'√™tre appliqu√©e et le tableau d'√©talonnage de cette roue est enregistr√© dans l'EEPROM. <br><br>  J'ai omis toutes sortes de trivialit√©s de mise en ≈ìuvre et j'ai essay√© de dire l'essentiel.  Vous pouvez remarquer que les <b>m√©thodes wheelRotateAng ()</b> et <b>wheelRotateAngRad ()</b> sont des fonctions de blocage.  C'est le prix pour la pr√©cision du mouvement et une int√©gration assez simple dans les esquisses de l'utilisateur.  Il serait possible de cr√©er un petit gestionnaire de t√¢ches avec un calendrier fixe, mais cela obligerait l'utilisateur √† int√©grer ses fonctionnalit√©s strictement dans le quota de temps allou√©. <br><br>  Et pour une application non bloquante, l'API a une fonction <b>wheelRotate (float * speed)</b> .  Il, comme on peut le voir dans la liste des param√®tres, effectue simplement la rotation des roues avec les vitesses d√©finies.  Et la vitesse de rotation est ajust√©e dans la m√©thode <b>Sync ()</b> du ch√¢ssis du robot, qui est appel√©e dans la m√©thode <b>Sync ()</b> de l'objet de classe Miro du m√™me nom.  Et selon les exigences de la structure de l'esquisse de l'utilisateur, cette m√©thode devrait √™tre appel√©e √† chaque it√©ration de la <b>boucle loop ()</b> principale <b>de l'</b> esquisse ARDUINO. <br><br>  √Ä l'√©tape 4, dans la description de la m√©thode <b>_wheel_rotate_sync ()</b> , j'ai mentionn√© la "correction de contr√¥le" du moteur.  Comment avez-vous devin√©)?  Il s'agit du contr√¥leur PID).  Eh bien, plus pr√©cis√©ment contr√¥leur PD.  Comme vous le savez (en fait - pas toujours), la meilleure fa√ßon de d√©terminer les coefficients du r√©gulateur est la s√©lection).  Il existe une d√©finition dans le fichier de configuration config.h: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEBUG_WHEEL_PID</span></span></code> </pre><br>  Si vous la d√©commentez, lorsque vous appelez la m√©thode <b>moveDist ()</b> de la classe Miro, le graphique invers√© suivant de l'erreur relative dans le contr√¥le de la vitesse angulaire de l'une des roues du robot (√† gauche) s'affiche dans la console du robot. <br><br> <a href=""><img src="https://habrastorage.org/webt/_v/4i/hr/_v4ihrxfnzpq-fvnofq_3kjkcz0.png"></a> <br><br>  √áa ne ressemble √† rien)?  Down est le temps (chaque barre est une √©tape du cycle de contr√¥le), et la valeur d'erreur est enregistr√©e √† droite (avec le signe conserv√©).  Voici deux paires de graphiques sur la m√™me √©chelle avec des coefficients diff√©rents du contr√¥leur PD.  Les "bosses" ne sont que les "vagues" de d√©passement.  Les nombres sur les barres horizontales sont une erreur relative (avec conservation du signe).  Visualisation simple du r√©gulateur, aidant √† ajuster manuellement les coefficients.  Au fil du temps, j'esp√®re faire une configuration automatique, mais pour l'instant. <br><br>  Voici un tel adok :-) <br><br>  Enfin, regardons un exemple.  Directement √† partir de la biblioth√®que API_Miro_moveDist: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Miro.h&gt; using namespace miro; byte PWM_pins[2] = { 5, 6 }; byte DIR_pins[2] = { 4, 7 }; byte ENCODER_pins[2] = { 2, 3 }; Miro robot(PWM_pins, DIR_pins, ENCODER_pins); int laps = 0; void setup() { Serial.begin(115200); } void loop() { for (unsigned char i = 0; i &lt; 4; i++) { robot.moveDist(robot.getOptLinSpeed(), 0, 1, true); delay(500); robot.rotateAng(0.5*robot.getOptAngSpeed(), -90, true); delay(500); } Serial.print("Laps: "); Serial.println(laps); laps++; }</span></span></span></span></code> </pre><br>  D'apr√®s le texte du programme, tout doit √™tre clair.  Comment √ßa marche - dans la vid√©o. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Bd96kgY2YsY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Carreaux 600 x 600 mm et intervalles de carreaux 5 mm.  En th√©orie, le robot devrait faire le tour d'un carr√© d'un c√¥t√© de 1 m√®tre.  Bien s√ªr, la trajectoire ¬´s'envole¬ª.  Mais pour √™tre honn√™te, il convient de dire que dans la version du robot que j'ai laiss√©e pour les tests, il existe des moteurs assez rotatifs qui sont difficiles √† obtenir pour rouler lentement.  Mais √† grande vitesse et en glissement, il y a un endroit o√π √™tre, et l'inertie n'est pas facile √† g√©rer.  Les moteurs avec un rapport d'engrenage plus √©lev√© (comme m√™me dans nos robots MIRO, n'√©taient tout simplement pas √† port√©e de main pendant le test) devraient se comporter un peu mieux. <br><br>  S'il y a des moments incompr√©hensibles - je suis heureux de clarifier, discuter et am√©liorer.  Les commentaires sont g√©n√©ralement int√©ressants. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477118/">https://habr.com/ru/post/fr477118/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477098/index.html">Nous traitons la transmission vid√©o en r√©solution 4K √† 60 Hz via un hub USB-C</a></li>
<li><a href="../fr477100/index.html">Marathon technique Microsoft Dynamics 365</a></li>
<li><a href="../fr477104/index.html">IntelliSense assist√© par IA pour la base de code de votre √©quipe</a></li>
<li><a href="../fr477110/index.html">Planification divertissante</a></li>
<li><a href="../fr477114/index.html">Impl√©mentation de l'interpr√©teur MSH</a></li>
<li><a href="../fr477120/index.html">Logiciel de surveillance de la glyc√©mie en continu pour Windows</a></li>
<li><a href="../fr477122/index.html">Le cerveau de l'entreprise. 3e partie</a></li>
<li><a href="../fr477124/index.html">Bitcoin dans une cage?</a></li>
<li><a href="../fr477126/index.html">Admin en 5 minutes. Frontend - react-admin, backend - Flask-RESTful</a></li>
<li><a href="../fr477128/index.html">D√©tective Habra le week-end</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>