<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍊 ⚕️ 🚫 Première rencontre avec Home Assistant ✋🏻 🈶 💜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Home Assistant est une application open source populaire pour organiser une maison intelligente. La première expérience de l’auteur avec le Home Assis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Première rencontre avec Home Assistant</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471822/"><img width="25%" align="right" src="https://habrastorage.org/webt/sj/wt/mu/sjwtmujve5xdbroiyxjiebxbc5o.png"><br>  Home Assistant est une application open source populaire pour organiser une maison intelligente.  La première expérience de l’auteur avec le Home Assistant est basée sur une tentative d’y intégrer un cuiseur à riz intelligent.  L'auteur tentera de décrire les principaux composants et fonctionnalités de cette application, qu'il a eu la chance de connaître pas à pas.  L'article est en quelque sorte une revue, en quelque sorte un guide pour ceux qui veulent commencer leur connaissance de Home Assistant. <br><a name="habracut"></a><br>  Pour ceux qui ont peu de temps libre, je vous conseille de sauter le dicton - le premier chapitre - et de passer directement au second.  Vous devez seulement savoir que nous travaillerons avec un cuiseur à riz chinois intelligent de Xiaomi. <br><br><h3>  Cuiseur à riz intelligent </h3>  Un cuiseur à riz est évidemment un cuiseur à riz.  Wiki nous montre des bateaux à vapeur en céramique du British Museum datant de 1250 av.  En 1945, Mitsubishi est devenue la première entreprise japonaise de cuiseurs à riz électriques faits maison.  Notre modèle - Rice Cooker de Xiaomi - peut non seulement cuisiner du riz.  «C'est un excellent appareil pour faire non seulement du riz, mais d'autres types de plats.  Il peut préparer des soupes, des pâtisseries et bien plus encore », indique la publicité.  Mais le plus important est la présence d'un module Wi-Fi, d'un logiciel avec des capacités d'automatisation et de plus de 200 recettes installées par logiciel.  "Le chemin vers une maison intelligente par l'estomac est juste", pensa l'auteur, et décida. <br><br>  Xiaomi Rice Cooker, comme il sied à un appareil numérique, est très attrayant à l'extérieur, plaît avec sa forme ronde et son minimalisme général.  Pour le configurer et l'utiliser, le constructeur propose l'application Mi Home.  Après avoir enregistré un compte Mi, le programme recherche facilement un nouvel appareil et vous l'enregistrez sur votre réseau local.  L'interface d'application n'est pas la pire, fournit des outils d'automatisation de base et peut recevoir des notifications des appareils.  Cependant, il existe des inconvénients importants.  Tout le monde ne peut pas être content d'envoyer des informations au développeur sur chaque clic de l'utilisateur.  Et une expression désagréable se retrouve souvent aujourd'hui de couleur nationale.  Au lieu de plus de 200 recettes, seulement quatre sont traduites et disponibles en langues étrangères.  Le reste est exclusivement réservé au peuple chinois.  Lorsque votre cuiseur à riz «intelligent» n'est pas en mesure de remplir toutes les fonctions culinaires promises, alors, vous voyez, cela devient triste.  Après avoir erré pendant un certain temps sur Internet, un triste auteur est tombé sur le prochain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet</a> intéressant (avantages éternels pour l'auteur).  Ce qui s'est avéré être dédié au développement d'un module pour un certain Home Assistant. <br><br><h3>  Assistant à domicile </h3>  Tout d'abord, quelques informations générales.  Comme on nous le dit sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la page d'accueil de HA</a> , «il s'agit d'un logiciel open source pour la domotique intelligente qui se concentre sur la gestion locale et la confidentialité.  Développé par le travail d'une communauté ouverte de passionnés, il est idéal pour travailler sur un Raspberry Pi ou un serveur local. »  Le projet a plus de cinq ans, il utilise python et une licence Apache 2.0.  La version finale au moment de la rédaction de ces lignes est 0.99.3. <br><br>  HA utilise des modules distincts (intégrations ou composants) pour gérer les périphériques.  En créer un est assez simple.  Sur le site, vous trouverez un catalogue des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">principaux</a> modules (approuvés et soutenus par la communauté).  Parmi leur nombre total (1485 pièces), il en existe de très divers, les noms amazon, google, xiaomi, et même une fois yandex figurent dans le catalogue. <br>  Essayons d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">installer</a> HA dans un environnement virtuel sur un bureau Linux.  Nous aurons besoin de python3 et du gestionnaire de paquets pip. <br><pre><code class="bash hljs">python3 -m venv homeassistant <span class="hljs-comment"><span class="hljs-comment">#    cd homeassistant source bin/activate #    python3 -m pip install homeassistant #  Home Assistant hass --open-ui #  Home Assistant</span></span></code> </pre> <br>  Après cela, l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interface graphique</a> HA deviendra disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http: // localhost: 8123</a> .  Lors de votre première connexion, vous devrez créer un compte utilisateur.  L'interface Web HA est assez volumineuse.  Quelques éléments importants qui méritent d'être mentionnés au tout début sont l'onglet Configuration → Général, où vous pouvez facilement recharger les fichiers de configuration ou le serveur lui-même.  Ainsi que la page Info dans la liste des outils Développeurs, où vous pouvez voir les journaux d'erreurs. <br><br>  HA stocke toutes les données utilisateur nécessaires, dans le cas de Linux, dans le dossier de paramètres «~ / .homeassistant».  Les fichiers de configuration sont écrits au format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">YAML</a> , et le principal est «configuration.yaml».  Il combine les données des modules, l'automatisation, etc.  La fonction d'importation vous permet de diviser les paramètres en fichiers séparés organisés logiquement.  Les modules sont stockés dans des sous-dossiers «composants» (intégrés) et «custom_components». <br><br>  Cette connaissance devrait nous suffire pour installer un nouveau module.  Copiez le dossier «xiaomi_cooker» de notre référentiel dans nos «~ / .homeassistant / custom_components».  Selon la description, ajoutez les paramètres du module au fichier «configuration.yaml»: <br><div class="spoiler">  <b class="spoiler_title">configuration.yaml</b> <div class="spoiler_text"><pre> <code class="bash hljs">xiaomi_cooker: <span class="hljs-comment"><span class="hljs-comment">#   name: 'Akari' #   host: 192.168.1.10 # IP   token: '4921def609273302248d040a24243a25' #   Xiaomi model: chunmi.cooker.normal2 #  </span></span></code> </pre> <br></div></div><br>  C'est fait.  Après le redémarrage HA, une nouvelle entrée de module apparaîtra dans la section Général → Intégrations de l'interface Web. <br><br>  Tout module est un certain ensemble d'objets (entités) et de services (services, essentiellement - fonctions).  Les objets stockent diverses données reçues des appareils.  Par exemple, sensor.xiaomi_cooker_temperature est la température du cuiseur à riz, sun.sun est la position du soleil.  Les données d'un objet sont exprimées par une valeur de base - état (état) et un ensemble arbitraire d'attributs supplémentaires (attributs).  Les services sont utilisés pour transférer des commandes et des valeurs vers des appareils.  Par exemple, xiaomi_cooker.start - la commande pour démarrer le fonctionnement du cuiseur à riz, ou homeassistant.check_config - initialisation de la recherche d'erreurs dans les fichiers de paramètres HA.  La liste des outils de développement de l'interface Web contient la section Services, où vous pouvez afficher la liste des services à votre disposition et jouer avec leurs appels.  À proximité se trouve la section États, où, en conséquence, vous pouvez afficher et modifier les valeurs des objets.  Il convient de noter que les modifications des valeurs des objets dans la section États sont unilatérales.  C'est-à-dire  si, par exemple, vous modifiez l'état de l'objet lights.state ici de off à on, cela n'affectera pas l'état réel de l'appareil, et la prochaine fois que les données de l'appareil seront mises à jour, la valeur de l'objet sera remplacée par réelle. <br><br><h3>  Automatisation </h3>  Le principal outil de gestion d'une maison intelligente est l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">automatisation</a> .  Vous pouvez les ajouter et les modifier à l'aide de l'interface graphique dans la section Général → Automatisation ou directement dans le fichier «automations.yaml».  L'automatisation a pour fonction principale d'appeler des services lorsque certaines conditions sont remplies.  Outils de base pour définir les conditions d'appel de la valeur des objets, incl.  données de temps.  Il existe des solutions légèrement plus spécifiques, comme les événements.  À titre d'exemple d'automatisation simple, nous donnerons un code qui met à jour les données de l'auteur sur une période de 15 minutes: <br><div class="spoiler">  <b class="spoiler_title">automations.yaml</b> <div class="spoiler_text"><pre> <code class="bash hljs"> - id: <span class="hljs-string"><span class="hljs-string">'1565889970818'</span></span> <span class="hljs-comment"><span class="hljs-comment"># ID  alias: Umpiro decharging #  trigger: #   - platform: time_pattern #   -  minutes: /15 #   (   –    15 ) condition: [] #    action: #    - data: # ,     entity_id: sensor.umpiro_charge #  (: ) service: homeassistant.update_entity #   </span></span></code> </pre> <br></div></div><br>  Il convient de noter que jusqu'à présent, toutes les automatisations disponibles (par exemple, ci-dessus) ne peuvent pas être configurées sans éditer le code yaml via l'interface graphique, mais les développeurs disent qu'ils travaillent activement pour éliminer cet inconvénient. <br><br><h3>  Templating </h3>  Après l'automatisation, il est temps de parler de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modèles</a> (modèles).  Divers éléments de paramètres dans les fichiers yaml vous permettent d'utiliser des insertions dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le langage de script jinja2</a> .  Beaucoup de ces éléments sont unis par le nom commun «Templates», comme service_template ou trigger_template.  En utilisant des modèles, nous avons accès aux valeurs des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">objets dans HA</a> et la possibilité d'utiliser ces données dans des expressions mathématiques et logiques complexes, ce qui élargit considérablement notre potentiel.  Par exemple, prenons un code un peu plus compliqué de sensor.umpiro_charge écrit dans "configuration.yaml".  Il s'agit de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">template_sensor</a> , c'est-à-dire «un capteur qui forme des données en fonction des valeurs d'autres objets».  Notre capteur sera un peu l'analogue d'une batterie déchargée progressivement: <br><div class="spoiler">  <b class="spoiler_title">configuration.yaml</b> <div class="spoiler_text"><pre> <code class="bash hljs">sensor: <span class="hljs-comment"><span class="hljs-comment">#   platform: template #   -  sensors: #   #   – sensor.umpiro_charge umpiro_charge: #      UI () unit_of_measurement: '%' # ,    value_template: &gt;- #    –   'int' # +     {% if states('sensor.umpiro_charge')|int('unknown') is number %} #       #         {% set value = (states('sensor.umpiro_charge')|int - (as_timestamp(now()) - as_timestamp(states.sensor.umpiro_charge.last_updated))/60/15)|round %} #       {{ [[0, value]|max, 100]|min }} {% else %} # ,  HA   #      {{ 'unknown' }} {% endif %} # ID  ,     #      entity_id: [] friendly_name: 'Charge' #   #      UI () device_class: battery</span></span></code> </pre><br></div></div><br>  Nous avons laissé entity_id vide car nous avons déjà ajouté une automatisation qui provoquera indépendamment la mise à jour des données d'objet. <br><br><h3>  Scripts Python </h3>  À leur tour, les scripts python sont un outil simple pour créer de nouveaux services.  Après avoir ajouté la ligne: «script python:» à «configuration.yaml», tous les fichiers avec l'extension «.py» que nous avons placés dans le dossier «~ / .homeassistant / python_scripts» deviendront disponibles en tant que services avec les noms «python_scripts. &lt; nom_fichier&gt; ».  Leur code est exécuté dans un environnement prédéfini, où les données et les variables hass nous donnent accès aux arguments de l'appel de service, ainsi qu'aux objets et services HA.  A titre d'exemple, nous donnons le code du fichier "charge_set.py" pour le service "python_scripts.charge_set".  Sa fonction sera de régler la charge de notre batterie: <br><div class="spoiler">  <b class="spoiler_title">python_scripts / charge_set.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     name = data.get('name', 'sensor.umpiro_charge') #     new_state = data.get('charge', '100') #    attributes = hass.states.get(name).attributes #    hass.states.set(name, new_state, attributes)</span></span></code> </pre> <br></div></div><br><br><h3>  Créer l'intégration </h3>  Tout ce que nous avons fait à l'aide de modèles et de scripts Python, il serait peut-être plus facile de le faire en écrivant un module séparé.  Comme déjà mentionné, les modules non officiels sont stockés dans le dossier «custom_components».  À l'avenir, nous aurons besoin d'un objet qui stocke des informations sur la recette actuelle de notre cuiseur à riz et d'un service qui vous permet de modifier ces données.  Sur la base d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple de la documentation,</a> nous allons créer un nouveau module pour cela, «overmind».  La première étape est le fichier custom_components / overmind / __ init__.py: <br><div class="spoiler">  <b class="spoiler_title">custom_components / overmind / __ init__.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     DOMAIN = 'overmind' #       () DEFAULT_RECIPE = { "title": "Habr post", "description": "Post an article on habr.com", "profile": "471822" } #    def setup(hass, config): #    hass.states.set('overmind.current_recipe', 'on', DEFAULT_RECIPE) #       def handle_set(call): #    recipe = call.data.get('recipe', DEFAULT_RECIPE) #   -    hass.states.set('overmind.current_recipe', 'set', recipe) #   hass.services.register(DOMAIN, 'recipe_set', handle_set) return True</span></span></code> </pre> <br></div></div><br>  Après cela, nous rapporterons le nouveau module au fichier de configuration «configuration.yaml», en y ajoutant une ligne avec le nom du module: «overmind:».  Le problème est résolu. <br><br><h3>  Lovelace ui </h3>  Il s'agit du nom du HA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">frontal</a> utilisé.  Cette interface graphique, par laquelle un utilisateur ordinaire est invité à contrôler une maison intelligente, est la première page de l'interface Web HA.  L'interface LUI est formée de cartes de différents types, qui peuvent refléter les valeurs des objets, servir à appeler des fonctions et d'autres tâches.  Les cartes peuvent être distribuées sur des pages (vue), par analogie avec les signets du navigateur.  La configuration est organisée de manière pratique via la même interface graphique, mais est également accessible via le code yaml, pour lequel il existe également un éditeur de texte intégré.  Je vous recommande de consulter la page <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://demo.home-assistant.io/</a> , où il existe plusieurs exemples différents de paramètres LUI, et où vous pouvez facilement les voir, cliquer et les modifier. <br><br><img src="https://habrastorage.org/webt/64/bd/zf/64bdzfwclc_3sqnoek13735wgqq.png"><br>  <i><font color="grey">Exemple de configuration de l'interface graphique</font></i> <br><br>  Parlant des lacunes de l'interface, malheureusement, les développeurs eux-mêmes admettent que le projet essaie de s'asseoir simultanément sur les chaises du bureau et du smartphone.  LUI, par défaut, aime déterminer indépendamment l'emplacement et la taille des cartes, ce qui peut parfois transformer une page qui semble normale sur le moniteur en un gâchis sur l'écran du smartphone, et vice versa.  Il existe des outils simples pour rationaliser l'interface, mais d'après mon expérience, ils ne sont pas toujours efficaces. <br><br>  Je pense que cela n'a pas beaucoup de sens de décrire la création d'une interface à l'aide d'outils graphiques, je vais donc donner quelques exemples sous la forme du code yaml que j'ai utilisé.  Après avoir créé une page séparée (vue) pour notre cuiseur à riz, nous essaierons de la remplir avec les éléments les plus nécessaires afin qu'elle ne provoque pas de rejet lors de l'utilisation de l'écran du smartphone. <br><br>  Ici, nous allons essayer ces outils de commande d'interface très simples, ce sont la pile horizontale et la pile verticale.  Tout d'abord, créez une pile verticale à partir de cartes de types bouton-entité et capteur.  Le premier servira à lancer notre cuiseur à riz, le second - pour afficher la température: <br><div class="spoiler">  <b class="spoiler_title">pile verticale</b> <div class="spoiler_text"><pre> <code class="bash hljs">cards: <span class="hljs-comment"><span class="hljs-comment">#    - type: entity-button #      entity: sensor.xiaomi_cooker_state # ,     icon: 'mdi:selection' #     icon_height: 100px #   name: Offline #    show_icon: true # show_name: true # tap_action: #    action: call-service #  –   service: script.turn_on #  –   service_data: #    entity_id: script.order_cooker_start #  –   hold_action: #    action: none # - type: sensor #      entity: sensor.xiaomi_cooker_temperature # ,     name: Temper #   type: vertical-stack #   –  </span></span></code> </pre> <br></div></div><br>  L'assistant d'accueil comprend une archive d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">icônes de conception</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">matériaux</a> qui, par le biais de noms appropriés (par exemple, mdi: sélection), peuvent être utilisées dans les éléments de paramètres.  Le script (dans ce cas, pas python-, mais yaml-), que nous appelions le service, est un autre outil HA pratique. <br><br>  Combinez maintenant la pile verticale ci-dessus avec la carte portrait de la nôtre dans la pile maintenant horizontale.  Tout sera aussi simple: <br><div class="spoiler">  <b class="spoiler_title">pile horizontale</b> <div class="spoiler_text"><pre> <code class="bash hljs">ards: <span class="hljs-comment"><span class="hljs-comment">#    - type: picture #   image: /local/akari_r.jpg #    - #         type: horizontal-stack #   –  </span></span></code> </pre> <br></div></div><br>  Ici, vous devez marquer la ligne «image:».  Tous les fichiers que nous mettons dans le dossier '~ / .homeassistant / www' deviennent disponibles sur le lien <a href="">http: // localhost / local / filename</a> . <br><br>  L'étape suivante consiste à travailler un peu sur le bouton d'appel de service que nous avons créé.  Ce serait pratique pour nous si cela fonctionnait comme un interrupteur à bascule, c'est-à-dire  marche / arrêt, et non la façon dont cela se fait maintenant.  Ceci peut être réalisé grâce à l'utilisation d'une carte de type conditionnelle, dont l'affichage sur l'écran peut être ajusté en définissant certaines conditions.  Voici le code de la carte, qui est le bouton pour éteindre le cuiseur à riz et n'est visible que si le cuiseur à riz est en train de préparer le plat: <br><div class="spoiler">  <b class="spoiler_title">conditionnel</b> <div class="spoiler_text"><pre> <code class="bash hljs">card: <span class="hljs-comment"><span class="hljs-comment">#    entity: sensor.xiaomi_cooker_state # icon: 'mdi:star-box-outline' # icon_height: 100px # name: Running # tap_action: # action: call-service # service: xiaomi_cooker.stop # type: entity-button # conditions: #   # ,    entity: sensor.xiaomi_cooker_mode #  ,     state: Running type: conditional #  </span></span></code> </pre> <br></div></div><br>  En réécrivant le code du bouton d'alimentation précédemment créé de la même manière, et en le combinant avec cela, nous obtenons un bouton qui fonctionne à la fois en marche et en arrêt. <br><br>  Nous complétons notre intérêt avec une autre carte - avec le temps jusqu'à la fin de la cuisson (similaire à la carte de température), et un de plus avec les détails de la recette (personnalisée: carte de recette) affichée.  En conséquence, nous obtenons quelque chose comme ceci: <br><div style="text-align:center;"><img width="50%" src="https://habrastorage.org/webt/k6/kv/zq/k6kvzqqugn8sizjtsemxyufquo8.jpeg"></div><br><h3>  Cartes personnalisées </h3>  Home Assistant, en plus de la richesse de l'ensemble de types de cartes intégrés, offre bien entendu la possibilité de créer le vôtre.  Ces cartes sont appelées cartes personnalisées et javascript est utilisé pour les créer.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici</a> deux exemples de code simples.  Il est facile de trouver des cartes prêtes à l'emploi créées par divers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">passionnés sur le</a> réseau, et si vous voulez vous expérimenter, il sera utile de découvrir qu'il existe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modules js</a> spéciaux créés pour simplifier le travail d'écriture de nouveaux.  Mon expérience avec javascript continue de vouloir moins, donc, à titre d'exemple, je ne donnerai qu'une petite partie du code de la carte utilisé pour sélectionner et afficher la recette actuelle. <br><div class="spoiler">  <b class="spoiler_title">www / recette-card.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     lit-element LitElement, html, css } from "https://unpkg.com/lit-element@latest/lit-element.js?module"; //      class RecipeCard extends LitElement { //     HA static get properties() { return { hass: {}, config: {} }; } //    callServiceEx() { this.hass.callService('persistent_notification', 'create', {message: 'example'}); } //  html-  render() { //    ,     const entityId = this.config.entity; //    const state = this.hass.states[entityId]; //    const titleStr = state ? state.attributes.title : 'unavailable'; const descrStr = state ? state.attributes.description : 'unavailable'; //    return html` &lt;ha-card&gt; &lt;div class="flex" style="margin-top:16px;"&gt; &lt;div class="icon"&gt; &lt;ha-icon icon="mdi:bowl"&gt;&lt;/ha-icon&gt; &lt;/div&gt; &lt;div class="header"&gt; &lt;span class="name"&gt;Recipe&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="flex info" style="margin-bottom:16px;"&gt; &lt;span class="recipe-title"&gt;${titleStr}&lt;/span&gt; &lt;span class="recipe-descr"&gt;${descrStr}&lt;/span&gt; &lt;/div&gt; &lt;/ha-card&gt; `; } //     customElements.define('recipe-card', RecipeCard);</span></span></code> </pre> <br></div></div><br><br>  Pour utiliser la nouvelle carte, vous devrez ajouter le code suivant au début du fichier de paramètres LUI: <br><div class="spoiler">  <b class="spoiler_title">carte de recette</b> <div class="spoiler_text"><pre> <code class="bash hljs">resources: <span class="hljs-comment"><span class="hljs-comment">#    - type: module #   –  url: /local/recipe-card.js #  </span></span></code> </pre><br>  et parmi la liste des cartes: <br><pre> <code class="bash hljs"> - <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: <span class="hljs-string"><span class="hljs-string">'custom:recipe-card'</span></span> <span class="hljs-comment"><span class="hljs-comment">#   entity: overmind.current_recipe # ,    </span></span></code> </pre><br><br></div></div><br><h3>  Notifications </h3>  Une partie nécessaire d'une maison intelligente envoie des messages à l'utilisateur.  Dans HA, ces messages sont appelés notifications et il existe deux types de base de notifications.  Le premier est les notifications persistantes.  Pour les envoyer, le service intégré "persistent_notification.create" est utilisé.  Une liste de ces messages est disponible via l'icône en forme de cloche dans l'interface graphique, ils utilisent un balisage de démarque et sont essentiellement assez simples. <br><br>  Un autre outil, plus intéressant, est le module de notification intégré qui, grâce à l'installation de modules supplémentaires, vous permet d'envoyer des messages à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plates-formes tierces</a> .  À titre d'exemple, considérons un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">module pour télégramme</a> . <br><br>  Pour utiliser le module, tout d'abord, nous devrons créer un bot dans le télégramme lui-même.  Lors de la configuration, nous avons besoin du chat_id de notre utilisateur et de l'API du token bot.  Comment obtenir ces données - décrites en détail sur le lien ci-dessus, nous supposons que nous sommes prêts.  Passer directement à l'installation du module, tout d'abord, comme nous l'avons déjà fait, copiez son code source dans le dossier des composants, puis ajoutez ses paramètres dans le fichier «configuration.yaml»: <br><div class="spoiler">  <b class="spoiler_title">configuration.yaml</b> <div class="spoiler_text"><pre> <code class="bash hljs">telegram_bot: <span class="hljs-comment"><span class="hljs-comment">#   telegram platform: polling #   api_key: XXXXXXXXXXXXX # API Token   allowed_chat_ids: XXXXXXX # chat_id   proxy_url: socks5://XXXXXXXXXXXXX #     proxy_params: username: umpiro password: umpiro_password</span></span></code> </pre> <br>  ainsi que les paramètres du module de notification: <br><pre> <code class="bash hljs">notify: <span class="hljs-comment"><span class="hljs-comment">#   notify name: notify_send #   (   –  notify.notify_send) platform: telegram #   chat_id: XXXXXXX # chat_id  </span></span></code> </pre> <br></div></div><br><br>  Le module télégramme nous permet d'envoyer des messages, des photos ou des vidéos.  A titre d'exemple, nous allons créer une automatisation pour envoyer un message avec une photo, nous informant de la fin de la cuisson. <br><div class="spoiler">  <b class="spoiler_title">automations.yaml</b> <div class="spoiler_text"><pre> <code class="bash hljs"> - id: <span class="hljs-string"><span class="hljs-string">'1571074941908'</span></span> <span class="hljs-comment"><span class="hljs-comment"># ID  alias: EOC #   trigger: #    # ,   - entity_id: sensor.xiaomi_cooker_mode from: Running #    #   –    platform: state to: Waiting #    condition: [] #   action: #    - service: notify.notify_send #  –   data: # ,     title: End of Cooking #  message: "EOC" #  data: #    photo: #   -  #   - file: /home/umpiro/.homeassistant/www/cat.jpg #   caption: “EOC”</span></span></code> </pre> <br></div></div><br><br><h3>  Postface </h3>  Home Assistant peut intéresser ceux qui veulent essayer d'organiser la gestion locale d'une maison intelligente.  Il s'agit d'un projet large, intéressant, ouvertement et activement développé, grâce aux efforts de la communauté.  La variété des outils Home Assistant ne peut que se réjouir (je n'ai pas eu le temps d'en mentionner quelques-uns importants).  Comme inconvénient, on peut mentionner la complexité relative et le caractère incomplet de la documentation. <br>  PS <br>  Récemment, le 10 octobre, il y a eu, je ne sais pas si cela peut s'appeler une release, la transition du projet de la version 0.99 à la version 0.100. <br>  Citation des notes de publication: <br><blockquote>  Bienvenue dans les notes de version d'une autre merveilleuse version!  Non, nous n'allons pas pour 1.0, nous faisons 0.100!  Nous pensons que nous ne sommes pas encore prêts avec nos objectifs pour 1.0, mais nous progressons chaque jour.  Pour un aperçu de ce à quoi nous pensons, consultez notre blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mode simple dans Home Assistant 1.0.</a> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471822/">https://habr.com/ru/post/fr471822/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471810/index.html">Comparer les outils d'audit des modifications dans Active Directory: Quest Change Auditor et Netwrix Auditor</a></li>
<li><a href="../fr471812/index.html">Bibliothèque gratuite de Wolfram Engine pour les développeurs de logiciels</a></li>
<li><a href="../fr471814/index.html">WolframClientForPython | Nouvelle bibliothèque client Wolfram Language pour Python</a></li>
<li><a href="../fr471816/index.html">Comment signer des applications pour macOS Catalina 10.15</a></li>
<li><a href="../fr471820/index.html">Escrocs au téléphone. Troisième étape, dans laquelle j'obtiens la documentation que ma cellule bancaire a été créée</a></li>
<li><a href="../fr471824/index.html">Appareil photo à disquette: 8 faits intéressants sur le Sony Mavica MVC-FD85 (nombreuses photos)</a></li>
<li><a href="../fr471836/index.html">Visualisation automatisée du code python. Quatrième partie: Support de documentation</a></li>
<li><a href="../fr471838/index.html">Amour mathématique</a></li>
<li><a href="../fr471840/index.html">Pourquoi aller aux interviews</a></li>
<li><a href="../fr471844/index.html">5 raisons de visiter EPAM INSIDER au Kazakhstan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>