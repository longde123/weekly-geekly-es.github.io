<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥤 👩🏽‍✈️ 🤰🏼 Pesquisa de mercado de trabalho MongoDB e TI 🕴🏻 👩🏽‍🔬 😭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Você já analisou vagas? 

 Eles fizeram a pergunta: em quais tecnologias a demanda do mercado de trabalho é mais atual? Há um mês? Um ano atrás? 

 Co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pesquisa de mercado de trabalho MongoDB e TI</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422627/">  Você já analisou vagas? <br><br>  Eles fizeram a pergunta: em quais tecnologias a demanda do mercado de trabalho é mais atual?  Há um mês?  Um ano atrás? <br><br>  Com que frequência as novas vagas de emprego Java são abertas em uma área específica da sua cidade e com que intensidade elas fecham? <br><br>  Neste artigo, mostrarei como você pode alcançar o resultado desejado e criar um sistema de relatórios sobre um tópico de nosso interesse.  Vamos lá! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z0/f8/y8/z0f8y8sbxdtwpnhis-xvvclfodc.gif"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">(Fonte da imagem)</a> <br><a name="habracut"></a><br><h3>  A escolha recaiu sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Headhunter.ru</a> </h3><br>  Provavelmente muitos de vocês estão familiarizados e até usaram um recurso como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Headhunter.ru</a> .  Milhares de novas vagas em vários campos são postadas neste site diariamente.  O HeadHunter também possui uma API que permite ao desenvolvedor interagir com os dados desse recurso. <br><br><h3>  Toolkit </h3><br>  Usando um exemplo simples, consideramos a construção do processo de obtenção de dados para o sistema de relatórios, baseado no trabalho com o site da API Headhunter.ru.  Como um armazenamento intermediário de informações, usaremos o SQLite DBMS incorporado, os dados processados ​​serão armazenados no banco de dados NoSQL do MongoDB, o Python 3.4 como idioma principal. <br><br><div class="spoiler">  <b class="spoiler_title">API HH</b> <div class="spoiler_text">  Os recursos da API do HeadHunter são bastante amplos e bem descritos na documentação oficial do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHib</a> .  Antes de tudo, essa é a capacidade de enviar solicitações anônimas que não exigem autorização para receber informações sobre tarefas no formato JSON.  Recentemente, vários métodos foram pagos (métodos do empregador), mas eles não serão considerados nesta tarefa. <br></div></div><br><blockquote>  Cada vaga permanece no site por 30 dias, após o que, se não for renovada, será arquivada.  Se a vaga foi arquivada antes da expiração de 30 dias, foi <b>encerrada pelo</b> empregador. <br><br>  A API do HeadHunter (doravante denominada API do HH) permite que você receba uma variedade de vagas publicadas para qualquer data nos últimos 30 dias, que usaremos - coletaremos <b>diariamente as</b> vagas publicadas para cada dia. <br></blockquote><h2>  Implementação </h2><br><ul><li>  Conectar banco de dados SQLite <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sqlite3 conn_db = sqlite3.connect(<span class="hljs-string"><span class="hljs-string">'hr.db'</span></span>, timeout=<span class="hljs-number"><span class="hljs-number">10</span></span>) c = conn_db.cursor()</code> </pre> </li><li>  Tabela para armazenar alterações no status do trabalho <br>  Por conveniência, salvaremos o histórico da alteração do status da vaga (disponibilidade por data) em uma tabela especial do banco de dados SQLite.  Graças à tabela <b>vacancy_history,</b> estaremos cientes da disponibilidade de vagas no site em qualquer data do upload, ou seja,  em que datas ela estava ativa. <br><br><pre> <code class="python hljs">c.execute(<span class="hljs-string"><span class="hljs-string">''' create table if not exists vacancy_history ( id_vacancy integer, date_load text, date_from text, date_to text )'''</span></span>)</code> </pre> </li><li>  Filtragem de vagas <br>  Há uma restrição de que uma solicitação não pode retornar mais de 2000 coleções e, como pode haver muito mais vagas publicadas no site em um dia, colocaremos um filtro no corpo da solicitação, por exemplo: vagas apenas em São Petersburgo (área = 2) , por especialização em TI (especialização = 1) <br><br><pre> <code class="python hljs">path = (<span class="hljs-string"><span class="hljs-string">"/vacancies?area=2&amp;specialization=1&amp;page={}&amp;per_page={}&amp;date_from={}&amp;date_to={}"</span></span>.format(page, per_page, date_from, date_to))</code> </pre> </li><li>  Condições de seleção adicionais <br>  O mercado de trabalho está crescendo rapidamente e, mesmo levando em consideração o filtro, o número de vagas pode exceder 2000, portanto, definiremos um limite adicional na forma de um lançamento separado para cada dia: vagas na primeira metade do dia e vagas na segunda metade do dia <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_vacancy_history</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... count_days = <span class="hljs-number"><span class="hljs-number">30</span></span> hours = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> count_days &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> hours &lt; <span class="hljs-number"><span class="hljs-number">24</span></span>: date_from = (cur_date.replace(hour=hours, minute=<span class="hljs-number"><span class="hljs-number">0</span></span>, second=<span class="hljs-number"><span class="hljs-number">0</span></span>) - td(days=count_days)).strftime(<span class="hljs-string"><span class="hljs-string">'%Y-%m-%dT%H:%M:%S'</span></span>) date_to = (cur_date.replace(hour=hours + <span class="hljs-number"><span class="hljs-number">11</span></span>, minute=<span class="hljs-number"><span class="hljs-number">59</span></span>, second=<span class="hljs-number"><span class="hljs-number">59</span></span>) - td(days=count_days)).strftime(<span class="hljs-string"><span class="hljs-string">'%Y-%m-%dT%H:%M:%S'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> count == per_page: path = (<span class="hljs-string"><span class="hljs-string">"/vacancies?area=2&amp;specialization=1&amp;page={} &amp;per_page={}&amp;date_from={}&amp;date_to={}"</span></span> .format(page, per_page, date_from, date_to)) conn.request(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, path, headers=headers) response = conn.getresponse() vacancies = response.read() conn.close() count = len(json.loads(vacancies)[<span class="hljs-string"><span class="hljs-string">'items'</span></span>]) ... <span class="hljs-comment"><span class="hljs-comment">#     try: c.executemany('INSERT INTO vacancy_history VALUES (?,?,?,?)', collection_for_ins) except sqlite3.DatabaseError as err: print("Error: ", err) else: conn_db.commit() if collection_for_ins: page = page + 1 total = total + count #   del(collection_for_ins[:]) hours = hours + 12 count_days = count_days - 1 hours = 0</span></span></code> </pre><br></li></ul><br><div class="spoiler">  <b class="spoiler_title">Primeiro caso de uso</b> <div class="spoiler_text">  Suponha que tenhamos a tarefa de identificar vagas que foram fechadas por um determinado intervalo de tempo, por exemplo, para julho de 2018.  Isso é resolvido da seguinte maneira: o resultado de uma consulta SQL simples para a tabela vacancy_history retornará os dados que precisamos, que podem ser passados ​​para o DataFrame para análises adicionais: <br><br><pre> <code class="python hljs"> c.execute(<span class="hljs-string"><span class="hljs-string">""" select a.id_vacancy, date(a.date_load) as date_last_load, date(a.date_from) as date_publish, ifnull(a.date_next, date(a.date_load, '+1 day')) as date_close from ( select vh1.id_vacancy, vh1.date_load, vh1.date_from, min(vh2.date_load) as date_next from vacancy_history vh1 left join vacancy_history vh2 on vh1.id_vacancy = vh2.id_vacancy and vh1.date_load &lt; vh2.date_load where date(vh1.date_load) between :date_in and :date_out group by vh1.id_vacancy, vh1.date_load, vh1.date_from ) as a where a.date_next is null """</span></span>, {<span class="hljs-string"><span class="hljs-string">"date_in"</span></span> : date_in, <span class="hljs-string"><span class="hljs-string">"date_out"</span></span> : date_out}) date_in = dt.datetime(<span class="hljs-number"><span class="hljs-number">2018</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) date_out = dt.datetime(<span class="hljs-number"><span class="hljs-number">2018</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>) closed_vacancies = get_closed_by_period(date_in, date_out) df = pd.DataFrame(closed_vacancies, columns = [<span class="hljs-string"><span class="hljs-string">'id_vacancy'</span></span>, <span class="hljs-string"><span class="hljs-string">'date_last_load'</span></span>, <span class="hljs-string"><span class="hljs-string">'date_publish'</span></span>, <span class="hljs-string"><span class="hljs-string">'date_close'</span></span>]) df.head()</code> </pre> <br>  Nós obtemos o resultado deste tipo: <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  id_vacancy </th><th>  date_last_load </th><th>  date_publish </th><th>  date_close </th></tr><tr><td>  0 0 </td><td>  18126697 </td><td>  09/07/2018 </td><td>  09/07/2018 </td><td>  10/07/2018 </td></tr><tr><td>  1 </td><td>  18155121 </td><td>  09/07/2018 </td><td>  19/06/2018 </td><td>  10/07/2018 </td></tr><tr><td>  2 </td><td>  18881605 </td><td>  09/07/2018 </td><td>  02/07/2018 </td><td>  10/07/2018 </td></tr><tr><td>  3 </td><td>  19620783 </td><td>  09/07/2018 </td><td>  27/06/2018 </td><td>  10/07/2018 </td></tr><tr><td>  4 </td><td>  19696188 </td><td>  09/07/2018 </td><td>  15/06/2018 </td><td>  10/07/2018 </td></tr></tbody></table></div>  Se quisermos analisar usando ferramentas do Excel ou ferramentas de BI de terceiros, podemos fazer upload da tabela vacancy_history em um arquivo csv para análise posterior: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       CSV data = c.execute('select * from vacancy_history') with open('vacancy_history.csv','w', newline='') as out_csv_file: csv_out = csv.writer(out_csv_file) csv_out.writerow(d[0] for d in data.description) csv_out.writerows(data.fetchall()) conn_db.close()</span></span></code> </pre> </div></div><br><h3>  Artilharia pesada </h3><br>  Mas e se precisarmos fazer uma análise de dados mais complexa?  Aqui, o banco de dados NoSQL orientado a documentos do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MongoDB</a> é resgatado, o que permite armazenar dados no formato JSON. <br><br><ul><li>  Uma demonstração do meu banco de dados MongoDB é implantada no serviço de nuvem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mLab</a> , que permite criar um banco de dados de até 500 MB gratuitamente, o que é suficiente para analisar a tarefa atual.  O banco de dados hr_db possui uma coleção Vacancy, à qual iremos estabelecer uma conexão: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    Mongo from pymongo import MongoClient from pymongo import ASCENDING from pymongo import errors client = MongoClient('mongodb://&lt;db_user&gt;:&lt;dbpassword&gt;@ds115219.mlab.com:15219/hr_db') db = client.hr_db VacancyMongo = db.Vacancy</span></span></code> </pre> </li><li>  Vale ressaltar que o nível salarial nem sempre é indicado em rublos; portanto, para análise é necessário trazer todos os valores para o equivalente em rublos.  Para fazer isso, criamos uma coleção de dicionários usando a API HH, que contém informações sobre a taxa de câmbio da data atual: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   def get_dictionaries(): conn = http.client.HTTPSConnection("api.hh.ru") conn.request("GET", "https://api.hh.ru/dictionaries", headers=headers) response = conn.getresponse() if response.status != 200: conn.close() conn = http.client.HTTPSConnection("api.hh.ru") conn.request("GET", "https://api.hh.ru/dictionaries", headers=headers) response = conn.getresponse() dictionaries = response.read() dictionaries_json = json.loads(dictionaries) return dictionaries_json</span></span></code> </pre> </li><li>  Preenchendo o dicionário com moedas com as taxas de câmbio atuais: <br><br><pre> <code class="python hljs">hh_dictionary = get_dictionaries() currencies = hh_dictionary[<span class="hljs-string"><span class="hljs-string">'currency'</span></span>] currency_rates = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> currency <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> currencies: currency_rates[currency[<span class="hljs-string"><span class="hljs-string">'code'</span></span>]] = currency[<span class="hljs-string"><span class="hljs-string">'rate'</span></span>]</code> </pre><br></li></ul><blockquote>  As ações acima mencionadas para a coleta de vagas são lançadas diariamente, portanto, não é necessário visualizar todas as vagas a cada vez e receber informações detalhadas sobre cada uma delas.  Aceitaremos apenas os que foram recebidos nos últimos <b>cinco</b> dias. </blockquote><ul><li>  Obtendo uma matriz de vagas nos últimos 5 dias em um banco de dados SQLite: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_list_of_vacancies_sql</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> conn_db = sqlite3.connect(<span class="hljs-string"><span class="hljs-string">'hr.db'</span></span>, timeout=<span class="hljs-number"><span class="hljs-number">10</span></span>) conn_db.row_factory = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> cursor, row: row[<span class="hljs-number"><span class="hljs-number">0</span></span>] c = conn_db.cursor() items = c.execute(<span class="hljs-string"><span class="hljs-string">""" select distinct id_vacancy from vacancy_history where date(date_load) &gt;= date('now', '-5 day') """</span></span>).fetchall() conn_db.close() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items</code> </pre> </li><li>  Obtendo uma variedade de tarefas nos últimos cinco dias do MongoDB: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_list_of_vacancies_nosql</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> date_load = (dt.datetime.now() - td(days=<span class="hljs-number"><span class="hljs-number">5</span></span>)).strftime(<span class="hljs-string"><span class="hljs-string">'%Y-%m-%d'</span></span>) vacancies_from_mongo = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> VacancyMongo.find({<span class="hljs-string"><span class="hljs-string">"date_load"</span></span> : {<span class="hljs-string"><span class="hljs-string">"$gte"</span></span> : date_load}}, {<span class="hljs-string"><span class="hljs-string">"id"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"_id"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>}): vacancies_from_mongo.append(int(item[<span class="hljs-string"><span class="hljs-string">'id'</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vacancies_from_mongo</code> </pre></li><li>  Resta encontrar a diferença entre as duas matrizes, para as vagas que não estão no MongoDB, obtenha informações detalhadas e grave-as no banco de dados: <br><br><pre> <code class="python hljs">sql_list = get_list_of_vacancies_sql() mongo_list = get_list_of_vacancies_nosql() vac_for_pro = [] s = set(mongo_list) vac_for_pro = [x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sql_list <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s] vac_id_chunks = [vac_for_pro[x: x + <span class="hljs-number"><span class="hljs-number">500</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(vac_for_pro), <span class="hljs-number"><span class="hljs-number">500</span></span>)]</code> </pre></li><li>  Portanto, temos uma matriz com novas vagas que ainda não estão disponíveis no MongoDB. Para cada uma delas, receberemos informações detalhadas usando uma solicitação na API HH. Antes de processá-las diretamente no MongoDB, processaremos cada documento: <br><ol><li>  Trazemos a quantidade de salários para o equivalente ao rublo; </li><li>  Adicione uma graduação de nível de especialista a cada vaga (Junior / Middle / Senior etc) </li></ol><br>  Tudo isso é implementado na função vacancies_processing: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> nltk.stem.snowball <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SnowballStemmer stemmer = SnowballStemmer(<span class="hljs-string"><span class="hljs-string">"russian"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vacancies_processing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vacancies_list)</span></span></span><span class="hljs-function">:</span></span> cur_date = dt.datetime.now().strftime(<span class="hljs-string"><span class="hljs-string">'%Y-%m-%d'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> vacancy_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vacancies_list: conn = http.client.HTTPSConnection(<span class="hljs-string"><span class="hljs-string">"api.hh.ru"</span></span>) conn.request(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"/vacancies/{}"</span></span>.format(vacancy_id), headers=headers) response = conn.getresponse() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> response.status != <span class="hljs-number"><span class="hljs-number">404</span></span>: vacancy_txt = response.read() conn.close() vacancy = json.loads(vacancy_txt) <span class="hljs-comment"><span class="hljs-comment"># salary salary = None if 'salary' in vacancy: if vacancy['salary'] != None: ... max_salary = 500000 if salary is not None: salary = int(salary) if salary &gt;= max_salary: salary = max_salary # grade grade = None if 'name' in vacancy: p_grade = '' title = re.sub(u'[^a-z-]+', ' ', vacancy['name'].lower(), re.UNICODE) words = re.split(r'\s{1,}', title.strip()) for title_word in words: title_word = stemmer.stem(title_word) if len(title_word.strip()) &gt; 1: p_grade = p_grade + " " + title_word.strip() if re.search('()|(princip)', p_grade): grade = 'principal' elif re.search('()|(senior)|([f|F]ull)', p_grade): grade = 'senior' ... else: grade = 'not specify' vacancy['salary_processed'] = salary vacancy['date_load'] = cur_date vacancy['grade'] = grade vacancy.pop('branded_description', None) try: post_id = VacancyMongo.insert_one(vacancy) except errors.DuplicateKeyError: print ('Cant insert the duplicate vacancy_id:', vacancy['id'])</span></span></code> </pre></li><li>  Obtendo informações detalhadas acessando a API HH, pré-processamento recebido <br>  O MongoDB realiza os dados e os insere em vários fluxos, com 500 vagas em cada um: <br><br><pre> <code class="python hljs">t_num = <span class="hljs-number"><span class="hljs-number">1</span></span> threads = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> vac_id_chunk <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vac_id_chunks: print(<span class="hljs-string"><span class="hljs-string">'starting'</span></span>, t_num) t_num = t_num + <span class="hljs-number"><span class="hljs-number">1</span></span> t = threading.Thread(target=vacancies_processing, kwargs={<span class="hljs-string"><span class="hljs-string">'vacancies_list'</span></span>: vac_id_chunk}) threads.append(t) t.start() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> threads: t.join()</code> </pre> <br></li></ul><br>  A coleção preenchida no MongoDB é mais ou menos assim: <br><br> <a href=""><img src="https://habrastorage.org/webt/er/vq/sy/ervqsyhywfqykkbh2stmqgumc9q.jpeg"></a> <br><br><h2>  Mais alguns exemplos </h2><br>  Tendo o banco de dados coletado à nossa disposição, podemos executar várias amostras analíticas.  Então, mostrarei as 10 vagas mais bem pagas de desenvolvedores de Python em São Petersburgo: <br><br><pre> <code class="python hljs">cursor_mongo = VacancyMongo.find({<span class="hljs-string"><span class="hljs-string">"name"</span></span> : {<span class="hljs-string"><span class="hljs-string">"$regex"</span></span> : <span class="hljs-string"><span class="hljs-string">".*[pP]ython*"</span></span>}}) df_mongo = pd.DataFrame(list(cursor_mongo)) <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> df_mongo[<span class="hljs-string"><span class="hljs-string">'_id'</span></span>] pd.concat([df_mongo.drop([<span class="hljs-string"><span class="hljs-string">'employer'</span></span>], axis=<span class="hljs-number"><span class="hljs-number">1</span></span>), df_mongo[<span class="hljs-string"><span class="hljs-string">'employer'</span></span>].apply(pd.Series)[<span class="hljs-string"><span class="hljs-string">'name'</span></span>]], axis=<span class="hljs-number"><span class="hljs-number">1</span></span>)[[<span class="hljs-string"><span class="hljs-string">'grade'</span></span>, <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'salary_processed'</span></span> ]].sort_values(<span class="hljs-string"><span class="hljs-string">'salary_processed'</span></span>, ascending=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>)[:<span class="hljs-number"><span class="hljs-number">10</span></span>]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Os 10 trabalhos mais bem pagos de Python</b> <div class="spoiler_text"><table border="1"><thead><tr><th>  nota </th><th>  nome </th><th>  nome </th><th>  salário_processo </th></tr></thead><tbody><tr><td>  sénior </td><td>  Arquiteto / Líder da equipe da Web (Python / Django / React) </td><td>  Investex ltd </td><td>  293901.0 </td></tr><tr><td>  sénior </td><td>  Desenvolvedor Python sênior no Montenegro </td><td>  Betmaster </td><td>  277141.0 </td></tr><tr><td>  sénior </td><td>  Desenvolvedor Python sênior no Montenegro </td><td>  Betmaster </td><td>  275289.0 </td></tr><tr><td>  meio </td><td>  Desenvolvedor Web de back-end (Python) </td><td>  Soshace </td><td>  250000,0 </td></tr><tr><td>  meio </td><td>  Desenvolvedor Web de back-end (Python) </td><td>  Soshace </td><td>  250000,0 </td></tr><tr><td>  sénior </td><td>  Engenheiro Python líder para uma startup suíça </td><td>  Assaia International AG </td><td>  250000,0 </td></tr><tr><td>  meio </td><td>  Desenvolvedor Web de back-end (Python) </td><td>  Soshace </td><td>  250000,0 </td></tr><tr><td>  meio </td><td>  Desenvolvedor Web de back-end (Python) </td><td>  Soshace </td><td>  250000,0 </td></tr><tr><td>  sénior </td><td>  Equipe Python </td><td>  Digitalhr </td><td>  230000.0 </td></tr><tr><td>  sénior </td><td>  Desenvolvedor Líder (Python, PHP, Javascript) </td><td>  IK GROUP </td><td>  220231.0 </td></tr></tbody></table></div><br></div><br><br>  Agora vamos descobrir qual estação de metrô tem a maior concentração de postagens vagas para desenvolvedores Java.  Usando uma expressão regular, filtrei pelo título da tarefa "Java" e também selecionei apenas as tarefas em que o endereço está especificado: <br><br><pre> <code class="python hljs">cursor_mongo = VacancyMongo.find({<span class="hljs-string"><span class="hljs-string">"name"</span></span> : {<span class="hljs-string"><span class="hljs-string">"$regex"</span></span> : <span class="hljs-string"><span class="hljs-string">".*[jJ]ava[^sS]"</span></span>}, <span class="hljs-string"><span class="hljs-string">"address"</span></span> : {<span class="hljs-string"><span class="hljs-string">"$ne"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>}}) df_mongo = pd.DataFrame(list(cursor_mongo)) df_mongo[<span class="hljs-string"><span class="hljs-string">'metro'</span></span>] = df_mongo.apply(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[<span class="hljs-string"><span class="hljs-string">'address'</span></span>][<span class="hljs-string"><span class="hljs-string">'metro'</span></span>][<span class="hljs-string"><span class="hljs-string">'station_name'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x[<span class="hljs-string"><span class="hljs-string">'address'</span></span>][<span class="hljs-string"><span class="hljs-string">'metro'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, axis = <span class="hljs-number"><span class="hljs-number">1</span></span>) df_mongo.groupby(<span class="hljs-string"><span class="hljs-string">'metro'</span></span>)[<span class="hljs-string"><span class="hljs-string">'_id'</span></span>] \ .count() \ .reset_index(name=<span class="hljs-string"><span class="hljs-string">'count'</span></span>) \ .sort_values([<span class="hljs-string"><span class="hljs-string">'count'</span></span>], ascending=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) \ [:<span class="hljs-number"><span class="hljs-number">10</span></span>]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Empregos para desenvolvedores Java em estações de metrô</b> <div class="spoiler_text"><table border="1"><thead><tr><th>  metro </th><th>  contar </th></tr></thead><tbody><tr><td>  Vasileostrovskaya </td><td>  87 </td></tr><tr><td>  Petrogradskaya </td><td>  68 </td></tr><tr><td>  Vyborg </td><td>  46. </td></tr><tr><td>  Praça Lenin </td><td>  45 </td></tr><tr><td>  Gorkovskaya </td><td>  45 </td></tr><tr><td>  Chkalovskaya </td><td>  43 </td></tr><tr><td>  Narva </td><td>  32. </td></tr><tr><td>  Praça da Revolta </td><td>  29 </td></tr><tr><td>  Vila Velha </td><td>  29 </td></tr><tr><td>  Elizarovskaya </td><td>  27 </td></tr></tbody></table></div><br></div><br><h2>  Sumário </h2><br>  Portanto, os recursos analíticos do sistema desenvolvido são realmente amplos e podem ser usados ​​para planejar uma startup ou abrir uma nova direção de atividade. <br><br>  Observo que, até o momento, apenas a funcionalidade básica do sistema é apresentada; no futuro, ele está planejado para se desenvolver na direção da análise por coordenadas geográficas e prever a aparência de vagas em uma área específica da cidade. <br><br>  O código fonte completo deste artigo pode ser encontrado no link para o meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . <br><br>  <b>PS Os</b> comentários ao artigo são bem-vindos, terei prazer em responder a todas as suas perguntas e descobrir sua opinião.  Obrigada </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt422627/">https://habr.com/ru/post/pt422627/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt422613/index.html">O cibergrupo do PowerPool dominou a vulnerabilidade de dia zero na chamada de procedimento local avançado</a></li>
<li><a href="../pt422615/index.html">Toda a verdade sobre o RTOS. Artigo 9. Agendador: implementação</a></li>
<li><a href="../pt422617/index.html">Toda a verdade sobre o RTOS. Artigo 8. Núcleo SE: Projeto Interno e Implantação</a></li>
<li><a href="../pt422623/index.html">Como proteger C</a></li>
<li><a href="../pt422625/index.html">Conversamos com Troy Miles - o programador do "Neuromancer"</a></li>
<li><a href="../pt422629/index.html">Pare de alimentar os madeireiros! Dê mais modificadores! Campos finais estáticos preguiçosos. Esboço de recurso de rascunho</a></li>
<li><a href="../pt422631/index.html">Terminais QIWI. Como tirar o máximo proveito das tecnologias simples</a></li>
<li><a href="../pt422633/index.html">Como automatizamos o monitoramento do trabalho dos funcionários da rede federal de postos de gasolina</a></li>
<li><a href="../pt422635/index.html">Você ainda não disse a palavra "olá" e já sabemos quem você é</a></li>
<li><a href="../pt422637/index.html">Presente de Geek: Proteção Automática de Alkash</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>