<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎿 🥀 💦 Um exemplo de cálculo da reação do sinal usando a transformada de Fourier no MATLAB 🔜 🚐 👩🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ao resolver os problemas de transmissão de dados através de linhas representadas por características de frequência, são aplicadas as transformadas de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Um exemplo de cálculo da reação do sinal usando a transformada de Fourier no MATLAB</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416497/">  Ao resolver os problemas de transmissão de dados através de linhas representadas por características de frequência, são aplicadas as transformadas de Fourier - a transferência de sinais do domínio do tempo para o domínio da frequência e vice-versa.  O ambiente MATLAB possui um conjunto completo de funções para resolver esses problemas.  Neste trabalho, é analisado um exemplo de cálculo no MATLAB da reação de um sinal transmitido através de uma linha cuja característica é medida em frequências que não coincidem com a frequência de transferência de dados.  Espero que este exemplo facilite a compreensão dos recursos da tecnologia de conversão de sinal no ambiente MATLAB. <br><br><h3>  Condição da tarefa </h3><br>  É necessário determinar a alteração na forma do sinal digital binário que passa através do filtro e da linha de sinal.  O sinal é definido pela amplitude e taxa de transmissão.  O filtro de segunda ordem, normalizado para a frequência de transferência de dados, é definido por constantes de tempo.  A função de transferência da linha de sinal é representada pela resposta de frequência medida em forma complexa. <br><br>  O ambiente usado para calcular e exibir dados é o MATLAB R2015a. <br>  As seguintes relações publicadas no site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.StatEye.org</a> para a versão do método StatEye 3.0 GUI [1, 2, 3] foram tomadas como exemplo dos dados iniciais. <br><br>  Taxa de dados bps = 10,3125 Gbit / s.  As constantes de tempo do filtro normalizado de segunda ordem são as mesmas, e recíproco é ¾ da frequência de transmissão de dados.  A linha de sinal é representada por uma resposta de frequência.  A característica foi medida no canal f = 0,006495: 0,0012475: 20 GHz.  O número especificado de pontos de amostragem da transformação de Fourier: points = 2 ^ 13. <br><a name="habracut"></a><br>  A Figura 1 mostra os resultados da transferência de dados, sequência e processamento de dados discutidos neste documento.  A transição do domínio do tempo para o domínio da frequência e vice-versa é realizada usando o algoritmo Fast Fourier Transform (FFT). <br><img src="https://habrastorage.org/webt/ex/c8/fw/exc8fwf3_bfcnnczjnoo_qdj43q.png" alt="imagem"><br>  <i>Figura 1. Canal de dados.</i>  <i>Sinal de entrada iSignal.Tx, sinal de saída do filtro iSignal.Filter_out, linha de sinal de saída iSignal.Rx.</i>  <i>As características mostradas no diagrama são discutidas abaixo.</i> <br><br><h3>  Sequência de cálculo </h3><br>  Neste trabalho, os principais cálculos são realizados no domínio da frequência.  Para isso, o sinal original do domínio do tempo foi transferido para o domínio da frequência usando a transformada de Fourier, multiplicando as características espectrais do sinal, o filtro e a linha de sinal, foi encontrado o sinal de saída do caminho, que é transferido do domínio da frequência para o domínio do tempo pela transformação inversa de Fourier. <br><br>  A taxa de transferência de dados é duas vezes maior que a frequência na qual os dados são transmitidos.  A frequência máxima da linha de sinal medida max (canal.f) = 20 GHz.  Nessa frequência, os dados podem ser transmitidos a uma velocidade de 40 Gbit / s (como 2 * max (canal.f)). <br><br>  A taxa máxima de transferência de dados, que não excede a taxa máxima de transmissão na linha de sinal de 40 Gbit / s e uma taxa de transmissão múltipla de bps = 10,3125 Gbit / s, é fmax = 30,9375 Gbit / s, a multiplicidade N = 3 (N = fmax / bps).  Além disso, fmax é usado como frequência limitadora para calcular a resposta do sinal usando a transformada de Fourier. <br><br><h3>  Conversão do sinal de entrada no domínio da frequência </h3><br>  Discriminação de tempo para a construção do sinal de entrada (bit de dados) no domínio do tempo Ts = 1 / fmax;  Ts = 3,232e-11 s.  Normalizada em relação à duração do sinal, a escala de tempo consiste em 2 ^ 13 pontos (pontos), a escala inclui a seguinte matriz de pontos tempo = bps / Ts. * (1: pontos).  Um sinal único discreto a uma taxa de transmissão de bps = 10,3125 Gbit / se quantização com um período Ts = 1 / fmax consiste em três pontos na faixa de 10 a 11 unidades de tempo normalizado.  Um sinal de amplitude da unidade pode ser construído em qualquer outro lugar na linha do tempo, mas é melhor recuar das bordas para ver completamente o plano de fundo e o processo de transição do sinal de saída.  Um sinal de pulso (bit de dados) construído usando os seguintes comandos do MATLAB é mostrado na Figura 2. <br><br><pre><code class="matlab hljs">iSignal.Tx(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">size</span></span>(time,<span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>; t0 = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(time&lt;=<span class="hljs-number"><span class="hljs-number">10</span></span>)); t1 = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(time&lt;<span class="hljs-number"><span class="hljs-number">11</span></span>)); iSignal.Tx(t0:t1) = <span class="hljs-number"><span class="hljs-number">1.0</span></span>;</code> </pre> <br><img src="https://habrastorage.org/webt/qf/df/ec/qfdfec6aehsjzwgjgenqazdh82y.png" alt="imagem"><br>  <i>Figura 2. Sinal de pulso de entrada iSignal.Tx, bit de dados.</i> <br><br>  A conversão do sinal iSignal.Tx no domínio da frequência é realizada pelas seguintes funções FFT. <br><br><pre> <code class="matlab hljs">iSignal.shiftedPSD = fft(iSignal.Tx); iSignal.PSD = fftshift(iSignal.shiftedPSD);</code> </pre> <br>  A função de transformação de Fourier fft constrói um espectro simétrico do sinal nas regiões de frequências positivas e negativas, cuja frequência máxima está no centro do espectro (veja a Figura 3).  A função fftshift restaura o espectro deslocando para o centro a frequência do sinal zero, como mostra a Figura 4. <br><br>  A resolução da frequência do espectro é fs = fmax / pontos;  As frequências de espectro variam de -fmax / 2 a fmax / 2-fs e são iguais a f = -fmax / 2: fs: fmax / 2-fs; <br><br><img src="https://habrastorage.org/webt/ho/8s/sb/ho8ssbopxofj9awqb5rudr9i4ks.png" alt="imagem"><br>  <i>Figura 3. Resposta em amplitude do espectro alterado do sinal iSignal.Tx obtido usando a FFT.</i> <br><br><img src="https://habrastorage.org/webt/gr/hn/lc/grhnlcgd4yp6lhei-wwiqw_ui0c.png" alt="imagem"><br>  <i>Figura 4. Resposta em amplitude do espectro reconstruído do sinal iSignal.Tx mostrado na Figura 3. 2 ^ 13 amostras são apresentadas.</i>  <i>A contagem média em 4097 corresponde à frequência zero.</i>  <i>As frequências negativas estão localizadas no lado esquerdo (de 1 a 4096 pontos) e a região de frequências positivas no lado direito (de 4098 a 8192 pontos).</i> <br><br><h3>  Função de transferência do filtro passa-baixas normalizado </h3><br>  Neste exemplo, a função de transferência do filtro de segunda ordem tem a forma <br><br><img src="https://habrastorage.org/webt/bz/ov/pt/bzovptea80xq-lyjjgayndllj98.png" alt="imagem"><br>  onde T1 e T2 são constantes de tempo do filtro.  As frequências 1 / T1 são iguais e 1 / T2 são definidas em relação à frequência na qual os dados são transmitidos: 1 / T1 = 1 / T2 = 0,75 * bps (bps = 10,3125 Gbit / s). <br><br>  Largura de banda de filtro normalizada <br><br><pre> <code class="matlab hljs">f_nrm =fmax/bps/points.*(-points/<span class="hljs-number"><span class="hljs-number">2</span></span>:points/<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>).</code> </pre> <br>  Operador <br><br><pre> <code class="matlab hljs">s = f_nrm .* <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>;</code> </pre> <br>  A característica de fase de amplitude do filtro normalizado para frequências positivas e negativas normalizadas em relação à frequência de transmissão de sinal é mostrada na Figura 5. A característica de frequência de amplitude logarítmica do filtro é mostrada na Figura 6. <br><br><img src="https://habrastorage.org/webt/ct/32/rj/ct32rjkglsoalv2s9lq9sdc41xy.png" alt="imagem"><br>  <i>Figura 5. A característica da fase de amplitude de um filtro normalizado</i> <br><br><img src="https://habrastorage.org/webt/fa/zp/x5/fazpx5t-iptrisubkndxs-aizes.png" alt="imagem"><br>  <i>Figura 6. Resposta de frequência logarítmica em fase de amplitude de um filtro normalizado.</i>  <i>A linha tracejada azul mostra a posição da frequência do filtro com um valor de 0,75 da frequência na qual os dados estão sendo transmitidos.</i>  <i>Nesta frequência (1 / T1 = 1 / T2), o coeficiente de transmissão do filtro de segunda ordem é de -6 decibéis.</i>  <i>A linha tracejada vermelha indica a frequência da unidade na qual os dados estão sendo transmitidos.</i> <br><br><h3>  Conversão dos resultados da medição da linha de sinal no tipo de função de transferência </h3><br>  A característica de fase de amplitude medida da linha de sinal inclui 1599 amostras na banda de até 20 GHz com um passo fixo de 12,475 MHz.  Ele contém os seguintes valores de frequência: channel.f = 0.006495: 0.0012475: 20 GHz.  Inicialmente, a linha de sinal era representada por uma característica de quatro terminais.  Essa característica foi transformada e é usada no exemplo como uma função complexa unidimensional. <br><br>  As frequências características da linha de sinal obtidas como resultado da medição não coincidem com as frequências do espectro do sinal de entrada que são múltiplos da frequência de transmissão de dados.  Além disso, o espectro da linha de sinal contém apenas frequências positivas e não contém frequências na região zero.  O espectro do sinal de entrada contém frequências positiva, zero e negativa. <br>  Para converter as características da linha de sinal em uma função de transferência - uma característica cujas frequências coincidem com as frequências do espectro do sinal de entrada, são executados os seguintes passos. <br><br>  1. O cálculo da amplitude das características da linha na frequência zero extrapolando-a.  Para isso, a partir dos dez pontos da característica de amplitude mais próximos da frequência zero, são encontrados os coeficientes de um polinômio linear que se aproximam da característica de amplitude: <br><br><pre> <code class="matlab hljs">[a] = polyfit(channel.f(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>), channel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  O segundo coeficiente polinomial encontrado é igual à amplitude da característica na frequência zero: <br><br><pre> <code class="matlab hljs">channel.dc = a(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  2. A resposta de fase na frequência zero é igual a zero. <br><br><pre> <code class="matlab hljs">channel.dcPhase = <span class="hljs-number"><span class="hljs-number">0.00</span></span>;</code> </pre> <br>  3. O recálculo das características do canal de amplitude.abs e do canal de fase.phase da linha de sinal com valores na frequência zero é realizado na frequência do espectro do sinal de entrada (f = -fmax / 2: fmax / pontos: fmax / 2-fmax / pontos) com extrapolação do área de zero e frequências negativas: <br><br><pre> <code class="matlab hljs">ichannel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span> = interp1([<span class="hljs-number"><span class="hljs-number">0</span></span> channel.f], [channel.dc channel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(f), <span class="hljs-string"><span class="hljs-string">'linear'</span></span>, <span class="hljs-string"><span class="hljs-string">'extrap'</span></span>); ichannel.phase = interp1([<span class="hljs-number"><span class="hljs-number">0</span></span> channel.f], [channel.dcPhase <span class="hljs-built_in"><span class="hljs-built_in">unwrap</span></span>(channel.phase)], <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(f), <span class="hljs-string"><span class="hljs-string">'linear'</span></span>, <span class="hljs-string"><span class="hljs-string">'extrap'</span></span>); ichannel.s = ichannel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span> .* <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(+<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>.*ichannel.phase); ichannel.tf = <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(ichannel.s) + <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">imag</span></span>(ichannel.s) .* <span class="hljs-built_in"><span class="hljs-built_in">sign</span></span>(f);</code> </pre> <br>  A função de transferência obtida - a resposta de frequência em fase de amplitude do canal na região de baixa frequência é mostrada na Figura 7. As características de frequência de amplitude da linha de sinal medida e a função de transferência calculada em todas as faixas de frequência são mostradas na Figura 8. As mesmas características no espaço de fase são mostradas na Figura 9. <br><br><img src="https://habrastorage.org/webt/u0/wm/sl/u0wmslmlvtgejybmkwlmg-qwxcg.png" alt="imagem"><br>  <i>Figura 7. A função de transferência da linha de sinal na região de baixa frequência.</i>  <i>Pontos vermelhos e azuis indicam amplitude discreta e características de fase, respectivamente.</i>  <i>A resposta de amplitude é mostrada em decibéis, a fase em radianos.</i>  <i>A linha rosa marca a frequência mais baixa da característica medida da linha de sinal.</i>  <i>O coeficiente de transmissão na frequência zero é 0,992.</i> <br><br><img src="https://habrastorage.org/webt/4o/q5/yd/4oq5ydmnjdijeopyumfiir0nlia.png" alt="imagem"><br>  <i>Figura 8. Resposta em frequência da linha de sinal.</i>  <i>Pontos azuis indicam os dados complexos da linha medida.</i>  <i>A dependência simétrica calculada do ganho da linha de sinal nas frequências do espectro do sinal de entrada é destacada em vermelho.</i>  <i>Na região de frequência zero, essa característica é mostrada na Figura 7.</i> <br><br><img src="https://habrastorage.org/webt/nx/zp/xo/nxzpxosf_rti2d2-zdny6p-qbrw.png" alt="imagem"><br>  <i>Figura 9. Características de frequência da fase de amplitude da linha de dados medida e seu espectro normalizado.</i> <br><br><h3>  Cálculo da resposta do sinal </h3><br>  A resposta (resposta ao efeito de entrada) no domínio da frequência é obtida multiplicando o espectro do sinal pelo produto das funções de transferência dos elementos que relacionam a reação ao sinal de entrada.  No nosso caso, o sinal passa pelo filtro e pela linha de sinal. <br>  O ifft de transformação inversa de Fourier é usado para transferir o sinal do domínio da frequência para o domínio do tempo. <br><br>  A saída do filtro no domínio de tempo iSignal.Filter_out é calculada como <br><br><pre> <code class="matlab hljs">TransFunction.PSD = iSignal.PSD .* Filter.PSD_Tx; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Filter_out = <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(ifft(TransFunction.shiftedPSD));</code> </pre> <br>  O sinal de saída da linha iSignal.Rx é igual ao produto do espectro do sinal de entrada e das funções de transferência do filtro e da linha de sinal com a subsequente transferência do sinal recebido do domínio da frequência para o domínio do tempo. <br><br><pre> <code class="matlab hljs">TransFunction.PSD = TransFunction.PSD .* ichannel.tf; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Rx = <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(ifft(TransFunction.shiftedPSD));</code> </pre> <br>  A resposta do filtro ao pulso ideal de entrada e a resposta do canal são mostradas na Figura 10. <br><br><img src="https://habrastorage.org/webt/ta/fh/0b/tafh0btf_ayq9wcxrowembxxbdk.png" alt="imagem"><br>  <i>Figura 10. Saída do filtro (gráfico vermelho) e saída da linha de dados (gráfico verde).</i>  <i>Sinal de entrada do filtro - um único pulso é mostrado na Figura 2. A entrada da linha de sinal é o sinal de saída do filtro.</i> <br><br><h3>  Aplicação.  Código m usado MATLAB </h3><br><div class="spoiler">  <b class="spoiler_title">Listagem</b> <div class="spoiler_text"><pre> <code class="matlab hljs">clear all <span class="hljs-comment"><span class="hljs-comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Ini data %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% bps = 1.03125e+10; FilterParam = [0.75 0.75]; points = 2^13; load('channel'); N = floor(max(channel.f)*2/bps); fmax = N*bps; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Signal %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % normalise all the scales for the bit rate time = bps/fmax .* (1:points); iSignal.Tx(1:size(time,2)) = 0; t0 = max(find(time&lt;=10)); t1 = max(find(time&lt;11)); iSignal.Tx(t0:t1) = 1.0; figure plot(time(1:t1+10), iSignal.Tx(1:t1+10),'b'); hold on plot(time(1:t1+10), iSignal.Tx(1:t1+10),'xb'); grid on xlabel('Normalised Time, tick Ts = 1/fmax'); ylabel('Normalised Amplitude'); title(['Pulse, data bit']); iSignal.shiftedPSD = fft(iSignal.Tx); figure plot(abs(iSignal.shiftedPSD),'c'); grid on xlabel('points, num'); ylabel('Amplitude'); title(['abs(fft(iSignal.Tx))']); iSignal.PSD = fftshift(iSignal.shiftedPSD); figure plot(abs(iSignal.PSD),'r'); grid on xlabel('points, num'); ylabel('Amplitude'); title(['abs(fftshift(fft(iSignal.Tx)))']); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Filter %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% f_nrm =fmax/bps/points.*(-points/2:points/2-1); s = f_nrm .* j; Filter_PSD = 1 ./(1 + s/FilterParam(1)) ./ (1 + s/FilterParam(2)); figure [AX,H1,H2] = plotyy (f_nrm, abs(Filter_PSD), f_nrm, phase(Filter_PSD)); hold(AX(1)); hold(AX(2)); set(H1,'LineWidth',2); grid(AX(2),'on'); xlabel('Normalised Frequency (Hz)'); set(get(AX(1),'Ylabel'),'String','Gain'); set(get(AX(2),'Ylabel'),'String','Phase, rad'); title(['Twopole filter [' sprintf(' %3.2f ', FilterParam) '] normalised to baud rate frequency']); figure plot_handles_Filter = plot(f_nrm(points/2 + 1:points), 20*log10(abs(Filter_PSD(points/2 + 1:points))), 'r', 'linewidth', 2); hold on stem_handles_br = stem(1, 20*log10(abs(Filter_PSD(max(find(f_nrm &lt; 1))))), '-.ro'); hold on stem_handles_c = stem(FilterParam, [20*log10(abs(Filter_PSD(max(find(f_nrm &lt; FilterParam(1)))))) 20*log10(abs(Filter_PSD(max(find(f_nrm &lt; FilterParam(2))))))], '-.bo'); grid legend_handles = [plot_handles_Filter, stem_handles_br(1), stem_handles_c(1)]; legend(legend_handles, 'transfer function', 'filter attenuation at normalised baud rate', 'filter attenuation at normalised cutoff frequency', 3); xlabel('Normalised Frequency (Hz)'); ylabel('Magnitude (dB)'); title(['Twopole filter [' sprintf(' %3.2f ', FilterParam) '] normalised to baud rate frequency']); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Channel %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % create negative frequencies, convert data to complex value, taking care about negative frequency channel.abs = abs(channel.s); channel.phase = angle(channel.s); %channel.s = channel.abs .* exp(+j.*channel.phase); [a] = polyfit(channel.f(1:10), channel.abs(1:10), 1); channel.dc = a(2); channel.dcPhase = 0.00; fs = fmax/points; % frequency step f = -fmax/2:fs:fmax/2-fs; % frequency matrix % create new data structure with linearly interpolated data ichannel.abs = interp1([0 channel.f], [channel.dc channel.abs], abs(f), 'linear', 'extrap'); ichannel.phase = interp1([0 channel.f], [channel.dcPhase unwrap(channel.phase)], abs(f), 'linear', 'extrap'); % correct for negative frequencies ichannel.s = ichannel.abs .* exp(+j.*ichannel.phase); ichannel.tf = real(ichannel.s) + j*imag(ichannel.s) .* sign(f); figure disp_points = 2*round(channel.f(1)/fs); stem_handles_br = stem(channel.f(1), angle(ichannel.tf(max(find(f &lt; channel.f(1))))), '-.mo'); hold on plot_abs = plot(f(points/2-disp_points:points/2+disp_points), 20*log10(abs(ichannel.tf(points/2-disp_points:points/2+disp_points))), '.r', 'linewidth', 3); hold on plot_phase = plot(f(points/2-disp_points:points/2+disp_points), angle(ichannel.tf(points/2-disp_points:points/2+disp_points)), '.b', 'linewidth', 3); grid legend_handles = [plot_abs, plot_phase, stem_handles_br(1)]; legend(legend_handles, 'absolute value (dB)', 'phase (rad)', 'min data freq', 3); xlabel('Relative Frequency (Hz)'); ylabel('Magnitude'); title(sprintf('dc extrapolation. dc trans function=%4.3f, dc phase=%4.3f rad', abs(ichannel.tf(points/2+1)), angle(ichannel.tf(points/2+1)))); figure plot(channel.f, 20*log10(channel.abs), '.r', 'linewidth', 3); hold on plot(f, 20*log10(ichannel.abs), 'g'); grid on legend('Measured Data', 'Interpolated Data', 3); xlabel('Frequency (Hz)'); ylabel('Magnitude (dB)'); title(['Chnnel interpolated Data : ']); figure plot3(channel.f, real(channel.s), imag(channel.s),'r'); hold on plot3(f, real(ichannel.tf), imag(ichannel.tf),'g'); grid on legend('Measured Data', 'Interpolated Data'); xlabel('Frequency in Hz'); ylabel('Re(fwd transfer)'); zlabel('Im(fwd transfer)'); title(['Chnnel interpolated Data : ']); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Response %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % filter Output TransFunction.PSD = iSignal.PSD .* Filter_PSD; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Filter_out = real(ifft(TransFunction.shiftedPSD)); % pass through channel TransFunction.PSD = TransFunction.PSD .* ichannel.tf; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Rx = real(ifft(TransFunction.shiftedPSD)); figure plot(time, iSignal.Filter_out,'r'); hold on [max_Tx, time_maxTx] = max(iSignal.Filter_out); [min_Tx, time_minTx] = min(iSignal.Filter_out); [max_Rx, time_maxRx] = max(iSignal.Rx); dtime_p5= round((time_maxRx - time_maxTx)*time(1) -1); plot(time - dtime_p5, iSignal.Rx,'g'); hold on plot(time, iSignal.Filter_out,'rx'); axis([(time_maxTx*time(1) - 3) (time_maxTx*time(1) + 5) (min_Tx-0.15) (max_Tx+0.1)]) grid on legend('Filter out','Rx', 2); xlabel('Normalised Time'); ylabel('Normalised Amplitude'); title(sprintf('Transmit pulse (Tx) max= %4.3f; Response (Rx) max (h0)= %4.3f', max(iSignal.Filter_out), max(iSignal.Rx)));</span></span></code> </pre><br></div></div><br><h3>  Lista bibliográfica </h3><br>  1. IEEE802.3ap.  Resultados da simulação NRZ de 10.3125Gbps usando "StatEye" e "Modelo de sinal para interferência" em componentes de canal em cascata.  Shannon Sawyer e Charles Moore / Agilent Technologies.  24 janeiro de 2005 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.ieee802.org/3/ap/public/jan05/sawyer_01_0105.pdf</a> <br><br>  2. O que é StatEye.  Força-Tarefa IEEE 803.3ap.  16 de setembro de 2004 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.ieee802.org/3/ap/public/signal_adhoc/ghiasi_01_0904.pdf</a> <br><br>  3. Acordo Stat Eye / IBM.  Steve Anderson.  Xilinx, Inc.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.ieee802.org/3/ap/public/nov04/anderson_01_1104.pdf</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416497/">https://habr.com/ru/post/pt416497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416487/index.html">Radio Astron faz 7 anos</a></li>
<li><a href="../pt416489/index.html">Vida Extraterrestre: Corrigindo a Equação de Drake e o Grande Filtro</a></li>
<li><a href="../pt416491/index.html">Activiti - Mecanismo de processo de negócios</a></li>
<li><a href="../pt416493/index.html">Lançamento SIIG MiniSys S286</a></li>
<li><a href="../pt416495/index.html">SamsPcbGuide Parte 6: Rastreando linhas de sinal. Modelos de perda e diafonia</a></li>
<li><a href="../pt416501/index.html">Escreva-me um servidor GraphQL em C #</a></li>
<li><a href="../pt416505/index.html">Escrevemos uma máquina virtual de pilha no Rust'e</a></li>
<li><a href="../pt416507/index.html">Como verificar a confiabilidade do data center: 3 pontos principais que você precisa prestar atenção</a></li>
<li><a href="../pt416511/index.html">Os erros mais comuns em seu código React que você (possivelmente) comete</a></li>
<li><a href="../pt416513/index.html">O resumo de materiais interessantes para o desenvolvedor móvel # 260 (2 a 8 de julho)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>