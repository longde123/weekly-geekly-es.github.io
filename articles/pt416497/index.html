<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¿ ğŸ¥€ ğŸ’¦ Um exemplo de cÃ¡lculo da reaÃ§Ã£o do sinal usando a transformada de Fourier no MATLAB ğŸ”œ ğŸš ğŸ‘©ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ao resolver os problemas de transmissÃ£o de dados atravÃ©s de linhas representadas por caracterÃ­sticas de frequÃªncia, sÃ£o aplicadas as transformadas de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Um exemplo de cÃ¡lculo da reaÃ§Ã£o do sinal usando a transformada de Fourier no MATLAB</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416497/">  Ao resolver os problemas de transmissÃ£o de dados atravÃ©s de linhas representadas por caracterÃ­sticas de frequÃªncia, sÃ£o aplicadas as transformadas de Fourier - a transferÃªncia de sinais do domÃ­nio do tempo para o domÃ­nio da frequÃªncia e vice-versa.  O ambiente MATLAB possui um conjunto completo de funÃ§Ãµes para resolver esses problemas.  Neste trabalho, Ã© analisado um exemplo de cÃ¡lculo no MATLAB da reaÃ§Ã£o de um sinal transmitido atravÃ©s de uma linha cuja caracterÃ­stica Ã© medida em frequÃªncias que nÃ£o coincidem com a frequÃªncia de transferÃªncia de dados.  Espero que este exemplo facilite a compreensÃ£o dos recursos da tecnologia de conversÃ£o de sinal no ambiente MATLAB. <br><br><h3>  CondiÃ§Ã£o da tarefa </h3><br>  Ã‰ necessÃ¡rio determinar a alteraÃ§Ã£o na forma do sinal digital binÃ¡rio que passa atravÃ©s do filtro e da linha de sinal.  O sinal Ã© definido pela amplitude e taxa de transmissÃ£o.  O filtro de segunda ordem, normalizado para a frequÃªncia de transferÃªncia de dados, Ã© definido por constantes de tempo.  A funÃ§Ã£o de transferÃªncia da linha de sinal Ã© representada pela resposta de frequÃªncia medida em forma complexa. <br><br>  O ambiente usado para calcular e exibir dados Ã© o MATLAB R2015a. <br>  As seguintes relaÃ§Ãµes publicadas no site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.StatEye.org</a> para a versÃ£o do mÃ©todo StatEye 3.0 GUI [1, 2, 3] foram tomadas como exemplo dos dados iniciais. <br><br>  Taxa de dados bps = 10,3125 Gbit / s.  As constantes de tempo do filtro normalizado de segunda ordem sÃ£o as mesmas, e recÃ­proco Ã© Â¾ da frequÃªncia de transmissÃ£o de dados.  A linha de sinal Ã© representada por uma resposta de frequÃªncia.  A caracterÃ­stica foi medida no canal f = 0,006495: 0,0012475: 20 GHz.  O nÃºmero especificado de pontos de amostragem da transformaÃ§Ã£o de Fourier: points = 2 ^ 13. <br><a name="habracut"></a><br>  A Figura 1 mostra os resultados da transferÃªncia de dados, sequÃªncia e processamento de dados discutidos neste documento.  A transiÃ§Ã£o do domÃ­nio do tempo para o domÃ­nio da frequÃªncia e vice-versa Ã© realizada usando o algoritmo Fast Fourier Transform (FFT). <br><img src="https://habrastorage.org/webt/ex/c8/fw/exc8fwf3_bfcnnczjnoo_qdj43q.png" alt="imagem"><br>  <i>Figura 1. Canal de dados.</i>  <i>Sinal de entrada iSignal.Tx, sinal de saÃ­da do filtro iSignal.Filter_out, linha de sinal de saÃ­da iSignal.Rx.</i>  <i>As caracterÃ­sticas mostradas no diagrama sÃ£o discutidas abaixo.</i> <br><br><h3>  SequÃªncia de cÃ¡lculo </h3><br>  Neste trabalho, os principais cÃ¡lculos sÃ£o realizados no domÃ­nio da frequÃªncia.  Para isso, o sinal original do domÃ­nio do tempo foi transferido para o domÃ­nio da frequÃªncia usando a transformada de Fourier, multiplicando as caracterÃ­sticas espectrais do sinal, o filtro e a linha de sinal, foi encontrado o sinal de saÃ­da do caminho, que Ã© transferido do domÃ­nio da frequÃªncia para o domÃ­nio do tempo pela transformaÃ§Ã£o inversa de Fourier. <br><br>  A taxa de transferÃªncia de dados Ã© duas vezes maior que a frequÃªncia na qual os dados sÃ£o transmitidos.  A frequÃªncia mÃ¡xima da linha de sinal medida max (canal.f) = 20 GHz.  Nessa frequÃªncia, os dados podem ser transmitidos a uma velocidade de 40 Gbit / s (como 2 * max (canal.f)). <br><br>  A taxa mÃ¡xima de transferÃªncia de dados, que nÃ£o excede a taxa mÃ¡xima de transmissÃ£o na linha de sinal de 40 Gbit / s e uma taxa de transmissÃ£o mÃºltipla de bps = 10,3125 Gbit / s, Ã© fmax = 30,9375 Gbit / s, a multiplicidade N = 3 (N = fmax / bps).  AlÃ©m disso, fmax Ã© usado como frequÃªncia limitadora para calcular a resposta do sinal usando a transformada de Fourier. <br><br><h3>  ConversÃ£o do sinal de entrada no domÃ­nio da frequÃªncia </h3><br>  DiscriminaÃ§Ã£o de tempo para a construÃ§Ã£o do sinal de entrada (bit de dados) no domÃ­nio do tempo Ts = 1 / fmax;  Ts = 3,232e-11 s.  Normalizada em relaÃ§Ã£o Ã  duraÃ§Ã£o do sinal, a escala de tempo consiste em 2 ^ 13 pontos (pontos), a escala inclui a seguinte matriz de pontos tempo = bps / Ts. * (1: pontos).  Um sinal Ãºnico discreto a uma taxa de transmissÃ£o de bps = 10,3125 Gbit / se quantizaÃ§Ã£o com um perÃ­odo Ts = 1 / fmax consiste em trÃªs pontos na faixa de 10 a 11 unidades de tempo normalizado.  Um sinal de amplitude da unidade pode ser construÃ­do em qualquer outro lugar na linha do tempo, mas Ã© melhor recuar das bordas para ver completamente o plano de fundo e o processo de transiÃ§Ã£o do sinal de saÃ­da.  Um sinal de pulso (bit de dados) construÃ­do usando os seguintes comandos do MATLAB Ã© mostrado na Figura 2. <br><br><pre><code class="matlab hljs">iSignal.Tx(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">size</span></span>(time,<span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>; t0 = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(time&lt;=<span class="hljs-number"><span class="hljs-number">10</span></span>)); t1 = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(time&lt;<span class="hljs-number"><span class="hljs-number">11</span></span>)); iSignal.Tx(t0:t1) = <span class="hljs-number"><span class="hljs-number">1.0</span></span>;</code> </pre> <br><img src="https://habrastorage.org/webt/qf/df/ec/qfdfec6aehsjzwgjgenqazdh82y.png" alt="imagem"><br>  <i>Figura 2. Sinal de pulso de entrada iSignal.Tx, bit de dados.</i> <br><br>  A conversÃ£o do sinal iSignal.Tx no domÃ­nio da frequÃªncia Ã© realizada pelas seguintes funÃ§Ãµes FFT. <br><br><pre> <code class="matlab hljs">iSignal.shiftedPSD = fft(iSignal.Tx); iSignal.PSD = fftshift(iSignal.shiftedPSD);</code> </pre> <br>  A funÃ§Ã£o de transformaÃ§Ã£o de Fourier fft constrÃ³i um espectro simÃ©trico do sinal nas regiÃµes de frequÃªncias positivas e negativas, cuja frequÃªncia mÃ¡xima estÃ¡ no centro do espectro (veja a Figura 3).  A funÃ§Ã£o fftshift restaura o espectro deslocando para o centro a frequÃªncia do sinal zero, como mostra a Figura 4. <br><br>  A resoluÃ§Ã£o da frequÃªncia do espectro Ã© fs = fmax / pontos;  As frequÃªncias de espectro variam de -fmax / 2 a fmax / 2-fs e sÃ£o iguais a f = -fmax / 2: fs: fmax / 2-fs; <br><br><img src="https://habrastorage.org/webt/ho/8s/sb/ho8ssbopxofj9awqb5rudr9i4ks.png" alt="imagem"><br>  <i>Figura 3. Resposta em amplitude do espectro alterado do sinal iSignal.Tx obtido usando a FFT.</i> <br><br><img src="https://habrastorage.org/webt/gr/hn/lc/grhnlcgd4yp6lhei-wwiqw_ui0c.png" alt="imagem"><br>  <i>Figura 4. Resposta em amplitude do espectro reconstruÃ­do do sinal iSignal.Tx mostrado na Figura 3. 2 ^ 13 amostras sÃ£o apresentadas.</i>  <i>A contagem mÃ©dia em 4097 corresponde Ã  frequÃªncia zero.</i>  <i>As frequÃªncias negativas estÃ£o localizadas no lado esquerdo (de 1 a 4096 pontos) e a regiÃ£o de frequÃªncias positivas no lado direito (de 4098 a 8192 pontos).</i> <br><br><h3>  FunÃ§Ã£o de transferÃªncia do filtro passa-baixas normalizado </h3><br>  Neste exemplo, a funÃ§Ã£o de transferÃªncia do filtro de segunda ordem tem a forma <br><br><img src="https://habrastorage.org/webt/bz/ov/pt/bzovptea80xq-lyjjgayndllj98.png" alt="imagem"><br>  onde T1 e T2 sÃ£o constantes de tempo do filtro.  As frequÃªncias 1 / T1 sÃ£o iguais e 1 / T2 sÃ£o definidas em relaÃ§Ã£o Ã  frequÃªncia na qual os dados sÃ£o transmitidos: 1 / T1 = 1 / T2 = 0,75 * bps (bps = 10,3125 Gbit / s). <br><br>  Largura de banda de filtro normalizada <br><br><pre> <code class="matlab hljs">f_nrm =fmax/bps/points.*(-points/<span class="hljs-number"><span class="hljs-number">2</span></span>:points/<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>).</code> </pre> <br>  Operador <br><br><pre> <code class="matlab hljs">s = f_nrm .* <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>;</code> </pre> <br>  A caracterÃ­stica de fase de amplitude do filtro normalizado para frequÃªncias positivas e negativas normalizadas em relaÃ§Ã£o Ã  frequÃªncia de transmissÃ£o de sinal Ã© mostrada na Figura 5. A caracterÃ­stica de frequÃªncia de amplitude logarÃ­tmica do filtro Ã© mostrada na Figura 6. <br><br><img src="https://habrastorage.org/webt/ct/32/rj/ct32rjkglsoalv2s9lq9sdc41xy.png" alt="imagem"><br>  <i>Figura 5. A caracterÃ­stica da fase de amplitude de um filtro normalizado</i> <br><br><img src="https://habrastorage.org/webt/fa/zp/x5/fazpx5t-iptrisubkndxs-aizes.png" alt="imagem"><br>  <i>Figura 6. Resposta de frequÃªncia logarÃ­tmica em fase de amplitude de um filtro normalizado.</i>  <i>A linha tracejada azul mostra a posiÃ§Ã£o da frequÃªncia do filtro com um valor de 0,75 da frequÃªncia na qual os dados estÃ£o sendo transmitidos.</i>  <i>Nesta frequÃªncia (1 / T1 = 1 / T2), o coeficiente de transmissÃ£o do filtro de segunda ordem Ã© de -6 decibÃ©is.</i>  <i>A linha tracejada vermelha indica a frequÃªncia da unidade na qual os dados estÃ£o sendo transmitidos.</i> <br><br><h3>  ConversÃ£o dos resultados da mediÃ§Ã£o da linha de sinal no tipo de funÃ§Ã£o de transferÃªncia </h3><br>  A caracterÃ­stica de fase de amplitude medida da linha de sinal inclui 1599 amostras na banda de atÃ© 20 GHz com um passo fixo de 12,475 MHz.  Ele contÃ©m os seguintes valores de frequÃªncia: channel.f = 0.006495: 0.0012475: 20 GHz.  Inicialmente, a linha de sinal era representada por uma caracterÃ­stica de quatro terminais.  Essa caracterÃ­stica foi transformada e Ã© usada no exemplo como uma funÃ§Ã£o complexa unidimensional. <br><br>  As frequÃªncias caracterÃ­sticas da linha de sinal obtidas como resultado da mediÃ§Ã£o nÃ£o coincidem com as frequÃªncias do espectro do sinal de entrada que sÃ£o mÃºltiplos da frequÃªncia de transmissÃ£o de dados.  AlÃ©m disso, o espectro da linha de sinal contÃ©m apenas frequÃªncias positivas e nÃ£o contÃ©m frequÃªncias na regiÃ£o zero.  O espectro do sinal de entrada contÃ©m frequÃªncias positiva, zero e negativa. <br>  Para converter as caracterÃ­sticas da linha de sinal em uma funÃ§Ã£o de transferÃªncia - uma caracterÃ­stica cujas frequÃªncias coincidem com as frequÃªncias do espectro do sinal de entrada, sÃ£o executados os seguintes passos. <br><br>  1. O cÃ¡lculo da amplitude das caracterÃ­sticas da linha na frequÃªncia zero extrapolando-a.  Para isso, a partir dos dez pontos da caracterÃ­stica de amplitude mais prÃ³ximos da frequÃªncia zero, sÃ£o encontrados os coeficientes de um polinÃ´mio linear que se aproximam da caracterÃ­stica de amplitude: <br><br><pre> <code class="matlab hljs">[a] = polyfit(channel.f(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>), channel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  O segundo coeficiente polinomial encontrado Ã© igual Ã  amplitude da caracterÃ­stica na frequÃªncia zero: <br><br><pre> <code class="matlab hljs">channel.dc = a(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  2. A resposta de fase na frequÃªncia zero Ã© igual a zero. <br><br><pre> <code class="matlab hljs">channel.dcPhase = <span class="hljs-number"><span class="hljs-number">0.00</span></span>;</code> </pre> <br>  3. O recÃ¡lculo das caracterÃ­sticas do canal de amplitude.abs e do canal de fase.phase da linha de sinal com valores na frequÃªncia zero Ã© realizado na frequÃªncia do espectro do sinal de entrada (f = -fmax / 2: fmax / pontos: fmax / 2-fmax / pontos) com extrapolaÃ§Ã£o do Ã¡rea de zero e frequÃªncias negativas: <br><br><pre> <code class="matlab hljs">ichannel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span> = interp1([<span class="hljs-number"><span class="hljs-number">0</span></span> channel.f], [channel.dc channel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(f), <span class="hljs-string"><span class="hljs-string">'linear'</span></span>, <span class="hljs-string"><span class="hljs-string">'extrap'</span></span>); ichannel.phase = interp1([<span class="hljs-number"><span class="hljs-number">0</span></span> channel.f], [channel.dcPhase <span class="hljs-built_in"><span class="hljs-built_in">unwrap</span></span>(channel.phase)], <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(f), <span class="hljs-string"><span class="hljs-string">'linear'</span></span>, <span class="hljs-string"><span class="hljs-string">'extrap'</span></span>); ichannel.s = ichannel.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span> .* <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(+<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>.*ichannel.phase); ichannel.tf = <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(ichannel.s) + <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">imag</span></span>(ichannel.s) .* <span class="hljs-built_in"><span class="hljs-built_in">sign</span></span>(f);</code> </pre> <br>  A funÃ§Ã£o de transferÃªncia obtida - a resposta de frequÃªncia em fase de amplitude do canal na regiÃ£o de baixa frequÃªncia Ã© mostrada na Figura 7. As caracterÃ­sticas de frequÃªncia de amplitude da linha de sinal medida e a funÃ§Ã£o de transferÃªncia calculada em todas as faixas de frequÃªncia sÃ£o mostradas na Figura 8. As mesmas caracterÃ­sticas no espaÃ§o de fase sÃ£o mostradas na Figura 9. <br><br><img src="https://habrastorage.org/webt/u0/wm/sl/u0wmslmlvtgejybmkwlmg-qwxcg.png" alt="imagem"><br>  <i>Figura 7. A funÃ§Ã£o de transferÃªncia da linha de sinal na regiÃ£o de baixa frequÃªncia.</i>  <i>Pontos vermelhos e azuis indicam amplitude discreta e caracterÃ­sticas de fase, respectivamente.</i>  <i>A resposta de amplitude Ã© mostrada em decibÃ©is, a fase em radianos.</i>  <i>A linha rosa marca a frequÃªncia mais baixa da caracterÃ­stica medida da linha de sinal.</i>  <i>O coeficiente de transmissÃ£o na frequÃªncia zero Ã© 0,992.</i> <br><br><img src="https://habrastorage.org/webt/4o/q5/yd/4oq5ydmnjdijeopyumfiir0nlia.png" alt="imagem"><br>  <i>Figura 8. Resposta em frequÃªncia da linha de sinal.</i>  <i>Pontos azuis indicam os dados complexos da linha medida.</i>  <i>A dependÃªncia simÃ©trica calculada do ganho da linha de sinal nas frequÃªncias do espectro do sinal de entrada Ã© destacada em vermelho.</i>  <i>Na regiÃ£o de frequÃªncia zero, essa caracterÃ­stica Ã© mostrada na Figura 7.</i> <br><br><img src="https://habrastorage.org/webt/nx/zp/xo/nxzpxosf_rti2d2-zdny6p-qbrw.png" alt="imagem"><br>  <i>Figura 9. CaracterÃ­sticas de frequÃªncia da fase de amplitude da linha de dados medida e seu espectro normalizado.</i> <br><br><h3>  CÃ¡lculo da resposta do sinal </h3><br>  A resposta (resposta ao efeito de entrada) no domÃ­nio da frequÃªncia Ã© obtida multiplicando o espectro do sinal pelo produto das funÃ§Ãµes de transferÃªncia dos elementos que relacionam a reaÃ§Ã£o ao sinal de entrada.  No nosso caso, o sinal passa pelo filtro e pela linha de sinal. <br>  O ifft de transformaÃ§Ã£o inversa de Fourier Ã© usado para transferir o sinal do domÃ­nio da frequÃªncia para o domÃ­nio do tempo. <br><br>  A saÃ­da do filtro no domÃ­nio de tempo iSignal.Filter_out Ã© calculada como <br><br><pre> <code class="matlab hljs">TransFunction.PSD = iSignal.PSD .* Filter.PSD_Tx; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Filter_out = <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(ifft(TransFunction.shiftedPSD));</code> </pre> <br>  O sinal de saÃ­da da linha iSignal.Rx Ã© igual ao produto do espectro do sinal de entrada e das funÃ§Ãµes de transferÃªncia do filtro e da linha de sinal com a subsequente transferÃªncia do sinal recebido do domÃ­nio da frequÃªncia para o domÃ­nio do tempo. <br><br><pre> <code class="matlab hljs">TransFunction.PSD = TransFunction.PSD .* ichannel.tf; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Rx = <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(ifft(TransFunction.shiftedPSD));</code> </pre> <br>  A resposta do filtro ao pulso ideal de entrada e a resposta do canal sÃ£o mostradas na Figura 10. <br><br><img src="https://habrastorage.org/webt/ta/fh/0b/tafh0btf_ayq9wcxrowembxxbdk.png" alt="imagem"><br>  <i>Figura 10. SaÃ­da do filtro (grÃ¡fico vermelho) e saÃ­da da linha de dados (grÃ¡fico verde).</i>  <i>Sinal de entrada do filtro - um Ãºnico pulso Ã© mostrado na Figura 2. A entrada da linha de sinal Ã© o sinal de saÃ­da do filtro.</i> <br><br><h3>  AplicaÃ§Ã£o.  CÃ³digo m usado MATLAB </h3><br><div class="spoiler">  <b class="spoiler_title">Listagem</b> <div class="spoiler_text"><pre> <code class="matlab hljs">clear all <span class="hljs-comment"><span class="hljs-comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Ini data %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% bps = 1.03125e+10; FilterParam = [0.75 0.75]; points = 2^13; load('channel'); N = floor(max(channel.f)*2/bps); fmax = N*bps; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Signal %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % normalise all the scales for the bit rate time = bps/fmax .* (1:points); iSignal.Tx(1:size(time,2)) = 0; t0 = max(find(time&lt;=10)); t1 = max(find(time&lt;11)); iSignal.Tx(t0:t1) = 1.0; figure plot(time(1:t1+10), iSignal.Tx(1:t1+10),'b'); hold on plot(time(1:t1+10), iSignal.Tx(1:t1+10),'xb'); grid on xlabel('Normalised Time, tick Ts = 1/fmax'); ylabel('Normalised Amplitude'); title(['Pulse, data bit']); iSignal.shiftedPSD = fft(iSignal.Tx); figure plot(abs(iSignal.shiftedPSD),'c'); grid on xlabel('points, num'); ylabel('Amplitude'); title(['abs(fft(iSignal.Tx))']); iSignal.PSD = fftshift(iSignal.shiftedPSD); figure plot(abs(iSignal.PSD),'r'); grid on xlabel('points, num'); ylabel('Amplitude'); title(['abs(fftshift(fft(iSignal.Tx)))']); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Filter %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% f_nrm =fmax/bps/points.*(-points/2:points/2-1); s = f_nrm .* j; Filter_PSD = 1 ./(1 + s/FilterParam(1)) ./ (1 + s/FilterParam(2)); figure [AX,H1,H2] = plotyy (f_nrm, abs(Filter_PSD), f_nrm, phase(Filter_PSD)); hold(AX(1)); hold(AX(2)); set(H1,'LineWidth',2); grid(AX(2),'on'); xlabel('Normalised Frequency (Hz)'); set(get(AX(1),'Ylabel'),'String','Gain'); set(get(AX(2),'Ylabel'),'String','Phase, rad'); title(['Twopole filter [' sprintf(' %3.2f ', FilterParam) '] normalised to baud rate frequency']); figure plot_handles_Filter = plot(f_nrm(points/2 + 1:points), 20*log10(abs(Filter_PSD(points/2 + 1:points))), 'r', 'linewidth', 2); hold on stem_handles_br = stem(1, 20*log10(abs(Filter_PSD(max(find(f_nrm &lt; 1))))), '-.ro'); hold on stem_handles_c = stem(FilterParam, [20*log10(abs(Filter_PSD(max(find(f_nrm &lt; FilterParam(1)))))) 20*log10(abs(Filter_PSD(max(find(f_nrm &lt; FilterParam(2))))))], '-.bo'); grid legend_handles = [plot_handles_Filter, stem_handles_br(1), stem_handles_c(1)]; legend(legend_handles, 'transfer function', 'filter attenuation at normalised baud rate', 'filter attenuation at normalised cutoff frequency', 3); xlabel('Normalised Frequency (Hz)'); ylabel('Magnitude (dB)'); title(['Twopole filter [' sprintf(' %3.2f ', FilterParam) '] normalised to baud rate frequency']); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Channel %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % create negative frequencies, convert data to complex value, taking care about negative frequency channel.abs = abs(channel.s); channel.phase = angle(channel.s); %channel.s = channel.abs .* exp(+j.*channel.phase); [a] = polyfit(channel.f(1:10), channel.abs(1:10), 1); channel.dc = a(2); channel.dcPhase = 0.00; fs = fmax/points; % frequency step f = -fmax/2:fs:fmax/2-fs; % frequency matrix % create new data structure with linearly interpolated data ichannel.abs = interp1([0 channel.f], [channel.dc channel.abs], abs(f), 'linear', 'extrap'); ichannel.phase = interp1([0 channel.f], [channel.dcPhase unwrap(channel.phase)], abs(f), 'linear', 'extrap'); % correct for negative frequencies ichannel.s = ichannel.abs .* exp(+j.*ichannel.phase); ichannel.tf = real(ichannel.s) + j*imag(ichannel.s) .* sign(f); figure disp_points = 2*round(channel.f(1)/fs); stem_handles_br = stem(channel.f(1), angle(ichannel.tf(max(find(f &lt; channel.f(1))))), '-.mo'); hold on plot_abs = plot(f(points/2-disp_points:points/2+disp_points), 20*log10(abs(ichannel.tf(points/2-disp_points:points/2+disp_points))), '.r', 'linewidth', 3); hold on plot_phase = plot(f(points/2-disp_points:points/2+disp_points), angle(ichannel.tf(points/2-disp_points:points/2+disp_points)), '.b', 'linewidth', 3); grid legend_handles = [plot_abs, plot_phase, stem_handles_br(1)]; legend(legend_handles, 'absolute value (dB)', 'phase (rad)', 'min data freq', 3); xlabel('Relative Frequency (Hz)'); ylabel('Magnitude'); title(sprintf('dc extrapolation. dc trans function=%4.3f, dc phase=%4.3f rad', abs(ichannel.tf(points/2+1)), angle(ichannel.tf(points/2+1)))); figure plot(channel.f, 20*log10(channel.abs), '.r', 'linewidth', 3); hold on plot(f, 20*log10(ichannel.abs), 'g'); grid on legend('Measured Data', 'Interpolated Data', 3); xlabel('Frequency (Hz)'); ylabel('Magnitude (dB)'); title(['Chnnel interpolated Data : ']); figure plot3(channel.f, real(channel.s), imag(channel.s),'r'); hold on plot3(f, real(ichannel.tf), imag(ichannel.tf),'g'); grid on legend('Measured Data', 'Interpolated Data'); xlabel('Frequency in Hz'); ylabel('Re(fwd transfer)'); zlabel('Im(fwd transfer)'); title(['Chnnel interpolated Data : ']); %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Response %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % filter Output TransFunction.PSD = iSignal.PSD .* Filter_PSD; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Filter_out = real(ifft(TransFunction.shiftedPSD)); % pass through channel TransFunction.PSD = TransFunction.PSD .* ichannel.tf; TransFunction.shiftedPSD = ifftshift(TransFunction.PSD); iSignal.Rx = real(ifft(TransFunction.shiftedPSD)); figure plot(time, iSignal.Filter_out,'r'); hold on [max_Tx, time_maxTx] = max(iSignal.Filter_out); [min_Tx, time_minTx] = min(iSignal.Filter_out); [max_Rx, time_maxRx] = max(iSignal.Rx); dtime_p5= round((time_maxRx - time_maxTx)*time(1) -1); plot(time - dtime_p5, iSignal.Rx,'g'); hold on plot(time, iSignal.Filter_out,'rx'); axis([(time_maxTx*time(1) - 3) (time_maxTx*time(1) + 5) (min_Tx-0.15) (max_Tx+0.1)]) grid on legend('Filter out','Rx', 2); xlabel('Normalised Time'); ylabel('Normalised Amplitude'); title(sprintf('Transmit pulse (Tx) max= %4.3f; Response (Rx) max (h0)= %4.3f', max(iSignal.Filter_out), max(iSignal.Rx)));</span></span></code> </pre><br></div></div><br><h3>  Lista bibliogrÃ¡fica </h3><br>  1. IEEE802.3ap.  Resultados da simulaÃ§Ã£o NRZ de 10.3125Gbps usando "StatEye" e "Modelo de sinal para interferÃªncia" em componentes de canal em cascata.  Shannon Sawyer e Charles Moore / Agilent Technologies.  24 janeiro de 2005 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.ieee802.org/3/ap/public/jan05/sawyer_01_0105.pdf</a> <br><br>  2. O que Ã© StatEye.  ForÃ§a-Tarefa IEEE 803.3ap.  16 de setembro de 2004 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.ieee802.org/3/ap/public/signal_adhoc/ghiasi_01_0904.pdf</a> <br><br>  3. Acordo Stat Eye / IBM.  Steve Anderson.  Xilinx, Inc.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.ieee802.org/3/ap/public/nov04/anderson_01_1104.pdf</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416497/">https://habr.com/ru/post/pt416497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416487/index.html">Radio Astron faz 7 anos</a></li>
<li><a href="../pt416489/index.html">Vida Extraterrestre: Corrigindo a EquaÃ§Ã£o de Drake e o Grande Filtro</a></li>
<li><a href="../pt416491/index.html">Activiti - Mecanismo de processo de negÃ³cios</a></li>
<li><a href="../pt416493/index.html">LanÃ§amento SIIG MiniSys S286</a></li>
<li><a href="../pt416495/index.html">SamsPcbGuide Parte 6: Rastreando linhas de sinal. Modelos de perda e diafonia</a></li>
<li><a href="../pt416501/index.html">Escreva-me um servidor GraphQL em C #</a></li>
<li><a href="../pt416505/index.html">Escrevemos uma mÃ¡quina virtual de pilha no Rust'e</a></li>
<li><a href="../pt416507/index.html">Como verificar a confiabilidade do data center: 3 pontos principais que vocÃª precisa prestar atenÃ§Ã£o</a></li>
<li><a href="../pt416511/index.html">Os erros mais comuns em seu cÃ³digo React que vocÃª (possivelmente) comete</a></li>
<li><a href="../pt416513/index.html">O resumo de materiais interessantes para o desenvolvedor mÃ³vel # 260 (2 a 8 de julho)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>