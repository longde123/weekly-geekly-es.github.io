<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤üèª üë©üèª‚Äçüé® üö¥üèª ld -z kode terpisah ‚ÜñÔ∏è üí¶ üàπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini akan fokus pada fitur keamanan kecil yang ditambahkan di GNU ld ke rilis 2.30 pada Desember 2018. Di Rusia, peningkatan ini disebutkan di ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ld -z kode terpisah</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/433108/"><p><img src="https://habrastorage.org/webt/mz/nr/5c/mznr5cswg58pumrqbt60sjacvg4.png"></p><br><p>  Artikel ini akan fokus pada fitur keamanan kecil yang ditambahkan di GNU ld ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rilis 2.30</a> pada Desember 2018.  Di Rusia, peningkatan ini disebutkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opennet</a> dengan anotasi berikut: </p><br><blockquote>  Mode "-z kode terpisah", yang meningkatkan keamanan file yang dapat dieksekusi dengan biaya peningkatan kecil dalam ukuran dan konsumsi memori </blockquote><p>  Mari kita cari tahu.  Untuk menjelaskan masalah keamanan seperti apa yang kita bicarakan dan solusinya, mari kita mulai dengan fitur umum dari eksploitasi kerentanan biner. </p><a name="habracut"></a><br><h1 id="problemy-perehvata-potoka-upravleniya-v-eksploytah">  Mengeksploitasi masalah aliran kontrol </h1><br><p>  Seorang penyerang dapat mentransfer data ke program dan memanipulasi dengan cara ini dengan bantuan berbagai kerentanan: menulis dengan indeks di luar batas array, menyalin string yang tidak aman, menggunakan objek setelah rilis.  Kesalahan seperti itu khas untuk kode program C dan C ++ dan dapat menyebabkan kerusakan memori dengan data input tertentu untuk program tersebut. </p><br><div class="spoiler">  <b class="spoiler_title">Kerentanan korupsi memori</b> <div class="spoiler_text"><p> CWE-20: Validasi Input Tidak Benar <br>  CWE-118: Akses Sumber Daya Terindeks yang Salah ('Rentang Kesalahan') <br>  CWE-119: Pembatasan Operasi yang Tidak Tepat dalam Batas-Batas Penyangga Memori <br>  CWE-120: Buffer Copy tanpa Memeriksa Ukuran Input ('Classic Buffer Overflow') <br>  CWE-121: Overflow Buffer Berbasis Stack <br>  CWE-122: Buffer Overflow berbasis Heap <br>  CWE-123: Kondisi Tulis-apa-di mana <br>  CWE-124: Buffer Underwrite ('Buffer Underflow') <br>  CWE-125: Baca di luar batas <br>  CWE-126: Buffer Over-read <br>  CWE-127: Buffer Under-read <br>  CWE-128: Kesalahan Kelalaian <br>  CWE-129: Validasi Indeks Array yang Tidak Tepat <br>  CWE-130: Penanganan yang Tidak Benar Panjang Parameter Parameter <br>  CWE-131: Perhitungan Ukuran Buffer yang Salah <br>  CWE-134: Penggunaan String Format yang Dikontrol Secara Eksternal <br>  CWE-135: Perhitungan Panjang String Multi-Byte yang Salah <br>  CWE-170: Pemutusan Null Tidak Tepat <br>  CWE-190: Integer Overflow atau Wraparound <br>  CWE-415: Gratis Ganda <br>  CWE-416: Gunakan Setelah Gratis <br>  CWE-476: NULL Pointer Dereference <br>  CWE-787: Out-of-bounds Tulis <br>  CWE-824: Akses Pointer Tidak diinisialisasi <br>  ... </p></div></div><br><p>  Elemen exploit klasik dari kerentanan seperti korupsi memori adalah menimpa pointer di memori.  Pointer kemudian akan digunakan oleh program untuk mentransfer kontrol ke kode lain: untuk memanggil metode kelas atau fungsi dari modul lain, untuk kembali dari suatu fungsi.  Dan karena pointer ditimpa, kontrol akan dicegat oleh penyerang - yaitu, kode yang disiapkan olehnya akan dieksekusi.  Jika Anda tertarik dengan variasi dan detail teknik ini, kami sarankan membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumen</a> . </p><br><p>  Momen umum dari operasi eksploitasi semacam ini diketahui, dan di sini untuk penyerang, penghalang telah lama ditempatkan: </p><br><ol><li>  Memeriksa integritas pointer sebelum melewati kontrol: stack cookies, control flow guard, otentikasi pointer </li><li>  Pengacakan alamat segmen dengan kode dan data: pengacakan tata letak ruang alamat </li><li>  Mencegah kode dari mengeksekusi segmen kode luar: perlindungan ruang yang dapat dieksekusi </li></ol><br><p>  Selanjutnya, kita akan fokus melindungi tipe yang terakhir. </p><br><h1 id="executable-space-protection">  perlindungan ruang yang dapat dieksekusi </h1><br><p>  Memori program heterogen dan dibagi menjadi beberapa segmen dengan hak berbeda: membaca, menulis, dan mengeksekusi.  Ini dipastikan oleh kemampuan prosesor untuk menandai halaman memori dengan bendera akses di tabel halaman.  Gagasan perlindungan didasarkan pada pemisahan kode dan data yang ketat: data yang diterima dari penyerang dalam proses pemrosesan harus ditempatkan di segmen yang tidak <strong>dapat dieksekusi</strong> (stack, heap), dan kode program itu sendiri - dalam segmen yang <strong>tidak dapat diubah yang</strong> terpisah.  Dengan demikian, ini harus menghilangkan kemampuan penyerang untuk menempatkan dan mengeksekusi kode asing dalam memori. </p><br><p>  Untuk menghindari larangan eksekusi kode di segmen data, teknik penggunaan kembali kode digunakan.  Yaitu, penyerang mentransfer kontrol ke fragmen kode (selanjutnya disebut sebagai gadget) yang terletak di halaman yang dapat dieksekusi.  Teknik-teknik semacam ini memiliki berbagai kesulitan, dengan urutan yang meningkat: </p><br><ul><li>  mentransfer kontrol ke fungsi yang melakukan apa yang cukup untuk penyerang: ke fungsi system () dengan argumen yang terkontrol untuk menjalankan perintah shell arbitrary (ret2libc) </li><li> mentransfer kontrol ke fungsi atau rangkaian gadget yang akan menonaktifkan perlindungan atau membuat bagian dari memori dapat dieksekusi (misalnya, memanggil <code>mprotect()</code> ), diikuti dengan pelaksanaan kode arbitrer </li><li>  pelaksanaan semua tindakan yang diinginkan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://web.archive.org/web/20170325014927/">rantai panjang gadget</a> </li></ul><br><p>  Dengan demikian, penyerang dihadapkan dengan tugas menggunakan kembali kode yang ada dalam satu volume atau yang lain.  Jika ini adalah sesuatu yang lebih rumit daripada kembali ke fungsi tunggal, maka <em>rantai gadget</em> akan diperlukan.  Untuk mencari gadget berdasarkan segmen yang dapat dieksekusi, ada alat: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ropper</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ropgadget</a> . </p><br><h2 id="dyra-read_implies_exec">  Lubang READ_IMPLIES_EXEC </h2><br><p>  Namun, kadang-kadang area memori dengan data dapat dieksekusi, dan prinsip-prinsip kode dan pemisahan data yang dijelaskan di atas jelas dilanggar.  Dalam kasus seperti itu, penyerang terhindar dari kesulitan menemukan gadget atau fungsi untuk menggunakan kembali kode.  Temuan yang menarik dari jenis ini adalah stack yang dapat dieksekusi dan semua segmen data pada "firewall industri" yang sama. </p><br><p>  Listing <code>/proc/$pid/maps</code> : </p><br><pre> <code class="plaintext hljs">00008000-00009000 r-xp 00000000 08:01 10 /var/flash/dmt/nx_test/a.out 00010000-00011000 rwxp 00000000 08:01 10 /var/flash/dmt/nx_test/a.out 00011000-00032000 rwxp 00000000 00:00 0 [heap] 40000000-4001f000 r-xp 00000000 1f:02 429 /lib/ld-linux.so.2 4001f000-40022000 rwxp 00000000 00:00 0 40027000-40028000 r-xp 0001f000 1f:02 429 /lib/ld-linux.so.2 40028000-40029000 rwxp 00020000 1f:02 429 /lib/ld-linux.so.2 4002c000-40172000 r-xp 00000000 1f:02 430 /lib/libc.so.6 40172000-40179000 ---p 00146000 1f:02 430 /lib/libc.so.6 40179000-4017b000 r-xp 00145000 1f:02 430 /lib/libc.so.6 4017b000-4017c000 rwxp 00147000 1f:02 430 /lib/libc.so.6 4017c000-40b80000 rwxp 00000000 00:00 0 be8c2000-be8d7000 rwxp 00000000 00:00 0 [stack]</code> </pre> <br><p>  Di sini Anda melihat kartu memori dari proses utilitas tes.  Peta terdiri dari area memori - baris tabel.  Pertama, perhatikan kolom kanan - ini menjelaskan isi area (segmen kode, data perpustakaan fungsi atau program itu sendiri) atau tipenya (heap, stack).  Di sebelah kiri, secara berurutan, adalah rentang alamat yang ditempati setiap area memori dan, lebih jauh, bendera hak akses: r (baca), w (tulis), x (eksekusi).  Bendera ini menentukan perilaku sistem ketika mencoba membaca, menulis, dan mengeksekusi memori di alamat ini.  Jika mode akses yang ditunjuk dilanggar, pengecualian dilemparkan. </p><br><p>  Perhatikan bahwa hampir semua memori di dalam proses dapat dieksekusi: stack, heap, dan semua segmen data.  Ini masalah.  Jelas, kehadiran halaman rwx memori akan membuat hidup lebih mudah bagi penyerang, karena ia akan dapat dengan bebas mengeksekusi kodenya dalam proses semacam itu di setiap tempat di mana kodenya dapatkan ketika mentransfer data (paket, file) ke program seperti itu untuk diproses. </p><br><p>  Mengapa situasi seperti itu muncul pada perangkat modern yang mendukung larangan eksekusi kode pada halaman data dengan perangkat keras, apakah keamanan jaringan perusahaan dan industri bergantung pada perangkat, dan masalah yang terdengar serta solusinya telah dikenal sejak lama? </p><br><p>  Gambar ini ditentukan oleh perilaku kernel selama inisialisasi proses (mengalokasikan stack, heap, memuat ELF utama, dll.) Dan selama pelaksanaan panggilan proses nuklir.  Atribut kunci yang memengaruhi ini adalah bendera kepribadian <code>READ_IMPLIES_EXEC</code> .  Efek dari flag ini adalah semua memori yang dapat dibaca juga dapat dieksekusi.  Bendera dapat diatur ke proses Anda karena beberapa alasan: </p><br><ol><li>  Legacy dapat secara eksplisit diminta oleh flag perangkat lunak di header ELF untuk menerapkan mekanisme yang sangat menarik: loncatan pada tumpukan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3</a> )! </li><li>  Itu bisa diwarisi oleh proses anak dari orang tua. </li><li>  Itu dapat diinstal oleh kernel secara independen untuk semua proses!  Pertama, jika arsitektur tidak mendukung memori yang tidak dapat dieksekusi.  Kedua, untuk berjaga-jaga, untuk mendukung beberapa <a href="">kruk kuno</a> lainnya.  Kode ini ada di kernel 2.6.32 (ARM), yang memiliki umur yang sangat panjang.  Ini hanya kasus kami. </li></ol><br><h1 id="prostranstvo-dlya-poiska-gadzhetov-v-obraze-elf">  Ruang untuk menemukan gadget dalam gambar ELF </h1><br><p>  Fungsi pustaka dan program yang dapat dieksekusi dalam format ELF.  Kompiler gcc menerjemahkan konstruksi bahasa ke dalam kode mesin dan meletakkannya di satu bagian, dan data yang kode ini beroperasi di bagian lain.  Ada banyak bagian dan mereka dikelompokkan oleh ld linker ke dalam segmen-segmen.  Dengan demikian, ELF berisi gambar program yang memiliki dua representasi: tabel bagian dan tabel segmen. </p><br><pre> <code class="plaintext hljs">$ readelf -l /bin/ls Elf file type is EXEC (Executable file) Entry point 0x804bee9 There are 9 program headers, starting at offset 52 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x08048034 0x08048034 0x00120 0x00120 RE 0x4 INTERP 0x000154 0x08048154 0x08048154 0x00013 0x00013 R 0x1 [Requesting program interpreter: /lib/ld-linux.so.2] LOAD 0x000000 0x08048000 0x08048000 0x1e40c 0x1e40c RE 0x1000 LOAD 0x01ef00 0x08067f00 0x08067f00 0x00444 0x01078 RW 0x1000 DYNAMIC 0x01ef0c 0x08067f0c 0x08067f0c 0x000f0 0x000f0 RW 0x4 NOTE 0x000168 0x08048168 0x08048168 0x00044 0x00044 R 0x4 GNU_EH_FRAME 0x018b74 0x08060b74 0x08060b74 0x00814 0x00814 R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 GNU_RELRO 0x01ef00 0x08067f00 0x08067f00 0x00100 0x00100 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame 03 .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss 04 .dynamic 05 .note.ABI-tag .note.gnu.build-id 06 .eh_frame_hdr 07 08 .init_array .fini_array .jcr .dynamic .got</code> </pre> <br><p>  Di sini Anda melihat pemetaan bagian ke segmen dalam gambar ELF. </p><br><p>  Tabel <strong>bagian</strong> digunakan oleh utilitas untuk menganalisis program dan perpustakaan, tetapi tidak digunakan oleh loader untuk memproyeksikan ELF ke dalam memori proses.  Tabel bagian menjelaskan struktur ELF lebih detail daripada tabel segmen.  Beberapa bagian dapat berada dalam satu segmen. </p><br><p>  Gambar ELF dalam memori dibuat oleh loader ELF berdasarkan pada isi tabel <strong>segmen</strong> .  Tabel <strong>partisi</strong> tidak lagi digunakan untuk memuat ELF ke dalam memori. </p><br><div class="spoiler">  <b class="spoiler_title">Tetapi ada pengecualian untuk aturan ini.</b> <div class="spoiler_text"><p>  Misalnya, di alam, ada tambalan pengembang Debian untuk loader ELF ld.so untuk arsitektur ARM, yang mencari bagian ".ARM.attributes" khusus seperti <a href="">SHT_ARM_ATTRIBUTES</a> dan biner dengan tabel bagian yang digergaji dalam sistem tersebut tidak dimuat ... </p></div></div><br><p>  Segmen ELF memiliki bendera yang menentukan izin apa yang dimiliki segmen tersebut dalam memori.  Secara tradisional, sebagian besar perangkat lunak untuk GNU / Linux diatur sedemikian rupa sehingga dua segmen <code>PT_LOAD</code> (loadable dalam memori) dinyatakan dalam tabel segmen - seperti dalam daftar di atas: </p><br><ol><li><p>  Segmen dengan bendera <code>RE</code> </p><br><p>  1.1.  Kode <strong>eksekusi</strong> ELF: bagian <code>.init</code> , <code>.text</code> , <code>.fini</code> </p><br><p>  1.2.  Data yang tidak dapat <strong>diubah</strong> dalam ELF: <code>.symtab</code> , <code>.rodata</code> </p><br></li><li><p>  Segmen Bendera <code>RW</code> </p><br><p>  2.1.  Data <strong>variabel</strong> dalam ELF: bagian <code>.plt</code> , <code>.got</code> , <code>.bss</code> , <code>.bss</code> </p><br></li></ol><br><p>  Jika Anda memperhatikan komposisi segmen pertama dan flag aksesnya, menjadi jelas bahwa tata letak seperti itu memperluas ruang untuk mencari gadget untuk teknik penggunaan kembali kode.  Dalam ELF besar seperti libcrypto, tabel layanan dan <strong>data</strong> abadi lainnya dapat menempati hingga 40% dari segmen yang <strong>dapat dieksekusi</strong> .  Kehadiran sesuatu yang mirip dengan potongan kode dalam data ini dikonfirmasi oleh upaya untuk membongkar file biner tersebut dengan sejumlah besar data dalam segmen yang dapat dieksekusi tanpa tabel bagian dan simbol.  Setiap urutan byte dalam segmen yang dapat dieksekusi tunggal ini dapat dianggap berguna untuk fragmen serang kode mesin dan loncatan - menjadi urutan byte ini dengan setidaknya sepotong garis pesan debugging dari program, bagian dari nama fungsi dalam tabel simbol atau jumlah konstan algoritma kriptografi ... </p><br><div class="spoiler">  <b class="spoiler_title">Header Eksekusi PE</b> <div class="spoiler_text"><p>  Header dan tabel yang dapat dieksekusi pada awal segmen pertama dari gambar ELF menyerupai situasi dengan Windows sekitar 15 tahun yang lalu.  Ada sejumlah virus yang menginfeksi file, menulis kode mereka di header PE mereka, yang juga dapat dieksekusi di sana.  Saya berhasil menggali sampel seperti itu di arsip: </p><br><p><img src="https://habrastorage.org/webt/gy/kt/7t/gykt7t5znycwstjaek_cdoo_xvm.png" alt="Virus.Win32.Haless.1127"></p><br><p>  Seperti yang Anda lihat, tubuh virus diperas tepat setelah tabel bagian di area header PE.  Dalam proyeksi file ke memori virtual, biasanya ada sekitar 3KB ruang kosong di sini.  Setelah tubuh virus ada ruang kosong dan kemudian bagian pertama dimulai dengan kode program. </p><br><p>  Namun, untuk Linux ada banyak karya yang lebih menarik dari adegan VX: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembalasan</a> . </p></div></div><br><h1 id="reshenie">  Solusi </h1><br><ul><li>  Masalah yang dijelaskan di atas sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lama</a> diketahui. </li><li>  Tetap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">12 Januari 2018</a> : kunci `ld -z kode-terpisah:" Buat kode terpisah "header segmen PT_LOAD dalam objek ditambahkan. Ini menentukan segmen memori yang harus berisi hanya instruksi dan harus sepenuhnya memisahkan halaman dari data lain. Jangan membuat segmen kode "PT_LOAD" terpisah jika kode noseparate digunakan. ").  Fitur ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dirilis</a> pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rilis 2.30</a> . </li><li>  Selanjutnya, fitur ini dimasukkan secara default di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rilis</a> berikutnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.31</a> . </li><li>  Hadir dalam paket <code>binutils</code> baru, misalnya, di repositori Ubuntu 18.10.  Banyak paket telah dikumpulkan dengan fitur baru ini, yang ditemui dan didokumentasikan oleh peneliti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ElfMaster</a> </li></ul><br><p>  Sebagai hasil dari perubahan pada algoritma tata letak, gambar ELF baru diperoleh: </p><br><pre> <code class="plaintext hljs">$ readelf -l ls Elf file type is DYN (Shared object file) Entry point 0x41aa There are 11 program headers, starting at offset 52 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x00000034 0x00000034 0x00160 0x00160 R 0x4 INTERP 0x000194 0x00000194 0x00000194 0x00013 0x00013 R 0x1 [Requesting program interpreter: /lib/ld-linux.so.2] LOAD 0x000000 0x00000000 0x00000000 0x01e6c 0x01e6c R 0x1000 LOAD 0x002000 0x00002000 0x00002000 0x14bd8 0x14bd8 RE 0x1000 LOAD 0x017000 0x00017000 0x00017000 0x0bf80 0x0bf80 R 0x1000 LOAD 0x0237f8 0x000247f8 0x000247f8 0x0096c 0x01afc RW 0x1000 DYNAMIC 0x023cec 0x00024cec 0x00024cec 0x00100 0x00100 RW 0x4 NOTE 0x0001a8 0x000001a8 0x000001a8 0x00044 0x00044 R 0x4 GNU_EH_FRAME 0x01c3f8 0x0001c3f8 0x0001c3f8 0x0092c 0x0092c R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 GNU_RELRO 0x0237f8 0x000247f8 0x000247f8 0x00808 0x00808 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt 03 .init .plt .plt.got .text .fini 04 .rodata .eh_frame_hdr .eh_frame 05 .init_array .fini_array .data.rel.ro .dynamic .got .data .bss 06 .dynamic 07 .note.ABI-tag .note.gnu.build-id 08 .eh_frame_hdr 09 10 .init_array .fini_array .data.rel.ro .dynamic .got</code> </pre> <br><p>  Batas antara kode dan data sekarang lebih akurat.  Segmen yang hanya dapat dieksekusi benar-benar hanya berisi bagian kode: .init, .plt, .plt.got, .text, .fini. </p><br><div class="spoiler">  <b class="spoiler_title">Apa sebenarnya yang telah diubah di dalam ld?</b> <div class="spoiler_text"><p>  Seperti yang Anda ketahui, struktur file output ELF dijelaskan oleh <a href="">skrip linker</a> .  Anda dapat melihat skrip default seperti ini: </p><br><pre> <code class="plaintext hljs">$ ld --verbose GNU ld (GNU Binutils for Ubuntu) 2.26.1 * * * using internal linker script: ================================================== /* Script for -z combreloc: combine and sort reloc sections */ /* Copyright (C) 2014-2015 Free Software Foundation, Inc. * * *</code> </pre> <br><p>  Banyak skrip lain untuk berbagai platform dan kombinasi opsi terdapat di direktori <code>ldscripts</code> .  Script baru telah dibuat untuk opsi <code>separate-code</code> . </p><br><pre> <code class="plaintext hljs">$ diff elf_x86_64.x elf_x86_64.xe 1c1 &lt; /* Default linker script, for normal executables */ --- &gt; /* Script for -z separate-code: generate normal executables with separate code segment */ 46a47 &gt; . = ALIGN(CONSTANT (MAXPAGESIZE)); 70a72,75 &gt; . = ALIGN(CONSTANT (MAXPAGESIZE)); &gt; /* Adjust the address for the rodata segment. We want to adjust up to &gt; the same address within the page on the next page up. */ &gt; . = SEGMENT_START("rodata-segment", ALIGN(CONSTANT (MAXPAGESIZE)) + (. &amp; (CONSTANT (MAXPAGESIZE) - 1)));</code> </pre> <br><p>  Di sini Anda dapat melihat bahwa direktif telah ditambahkan untuk mendeklarasikan segmen baru dengan bagian read-only mengikuti segmen kode. </p><br><p>  Namun, selain skrip, perubahan dilakukan pada sumber tautan.  Yaitu, dalam fungsi <code>_bfd_elf_map_sections_to_segments</code> - lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komit</a> .  Sekarang, ketika memilih segmen untuk bagian, segmen baru akan ditambahkan ketika bagian berbeda dengan bendera <code>SEC_CODE</code> dari bagian sebelumnya. </p></div></div><br><h1 id="vyvod">  Kesimpulan </h1><br><p>  Seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> , kami menyarankan agar pengembang tidak lupa menggunakan bendera keamanan yang dibangun di kompiler dan tautan saat mengembangkan perangkat lunak.  Perubahan kecil seperti itu bisa sangat menyulitkan kehidupan penyerang, dan membuat hidup Anda jauh lebih tenang. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433108/">https://habr.com/ru/post/id433108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433098/index.html">Kisah DDR3, SPD dan produsen Cina asli</a></li>
<li><a href="../id433100/index.html">Bekerja dengan database dari suatu aplikasi</a></li>
<li><a href="../id433102/index.html">Mengapa para ilmuwan percaya bahwa Planet Kesembilan tidak ada</a></li>
<li><a href="../id433104/index.html">Tantangan Foobar: tes rahasia Google untuk pengembang</a></li>
<li><a href="../id433106/index.html">SpaceX dan NASA menegaskan kembali niat mereka untuk meluncurkan peluncuran debut kapal Crew Dragon pada Januari 2019</a></li>
<li><a href="../id433112/index.html">Menghibur JavaScript: Hari Salju</a></li>
<li><a href="../id433114/index.html">Sertifikasi PMP: Persiapan ujian gaya komuter</a></li>
<li><a href="../id433116/index.html">Penyembur api, Sinterklas dengan tank, bigfoot, Baba Yaga di Endurica (dan, mungkin, jetpack) - semuanya untuk anak-anak di tahun baru</a></li>
<li><a href="../id433118/index.html">Pengujian benchmark dan analisis cepat dari algoritma permutasi</a></li>
<li><a href="../id433122/index.html">React-Hot-Loader v4.6</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>