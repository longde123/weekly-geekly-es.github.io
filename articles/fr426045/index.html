<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòè üë©üèº‚Äç‚öïÔ∏è ‚òùüèΩ Exceptions sp√©ciales dans .NET et comment les pr√©parer ü•® üßëüèæ‚Äçü§ù‚Äçüßëüèº üõèÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les diff√©rentes exceptions dans .NET ont leurs propres caract√©ristiques, et il peut √™tre tr√®s utile de les conna√Ætre. Comment tromper le CLR? Comment ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exceptions sp√©ciales dans .NET et comment les pr√©parer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/426045/">  Les diff√©rentes exceptions dans .NET ont leurs propres caract√©ristiques, et il peut √™tre tr√®s utile de les conna√Ætre.  Comment tromper le CLR?  Comment rester en vie lors de l'ex√©cution en interceptant une StackOverflowException?  Quelles exceptions il semble impossible de saisir, mais si vous le voulez vraiment, pouvez-vous? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f1/314/78d/4f131478de33b4a6acd0ed25a0e53987.png"><br><br>  Sous la coupe, la transcription du rapport d'Eugene ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">epeshk</a> ) Peshkov de notre conf√©rence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DotNext 2018 Piter</a> , o√π il a parl√© de ces et d'autres caract√©ristiques des exceptions. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WLSrYgMWif4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Salut  Je m'appelle Eugene.  Je travaille pour SKB Kontur et d√©veloppe un syst√®me d'h√©bergement et d√©ploie des applications pour Windows.  L'essentiel est que nous avons de nombreuses √©quipes de produits qui √©crivent leurs propres services et les h√©bergent chez nous.  Nous leur fournissons une solution facile et simple √† une vari√©t√© de t√¢ches d'infrastructure.  Par exemple, pour surveiller la consommation des ressources syst√®me ou terminer les r√©pliques du service. <br><br>  Parfois, il s'av√®re que les applications h√©berg√©es sur notre syst√®me s'effondrent.  Nous avons vu de nombreuses fa√ßons comment une application peut se bloquer lors de l'ex√©cution.  L'une de ces m√©thodes consiste √† lever une exception inattendue et enchanteresse. <br><br>  Aujourd'hui, je vais parler des fonctionnalit√©s des exceptions dans .NET.  Nous avons rencontr√© certaines de ces caract√©ristiques en production, et certaines au cours d'exp√©riences. <br><br><h2>  Plan </h2><br><ol><li>  Comportement des exceptions .NET <br></li><li>  Gestion des exceptions et hacks Windows <br></li></ol><br>  Tout ce qui suit est vrai pour Windows.  Tous les exemples ont √©t√© test√©s sur la derni√®re version du framework .NET 4.7.1 complet.  Il y aura √©galement quelques r√©f√©rences √† .NET Core. <br><br><h2>  Violation d'acc√®s </h2><br>  Cette exception se produit lors d'op√©rations de m√©moire incorrectes.  Par exemple, si une application tente d'acc√©der √† une zone m√©moire √† laquelle elle n'a pas acc√®s.  L'exception est de bas niveau et g√©n√©ralement, si cela se produit, un d√©bogage tr√®s long sera n√©cessaire. <br><br>  Essayons d'obtenir cette exception en utilisant C #.  Pour ce faire, nous √©crivons l'octet 42 √† l'adresse 1000 (nous supposons que 1000 est une adresse assez al√©atoire et notre application n'y a probablement pas acc√®s). <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Marshal.WriteByte((IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AccessViolationException) { ... }</code> </pre> <br>  WriteByte fait exactement ce dont nous avons besoin: il √©crit un octet √† l'adresse donn√©e.  Nous nous attendons √† ce que cet appel l√®ve une AccessViolationException.  Ce code l√®vera en effet cette exception, il pourra le g√©rer et l'application continuera √† fonctionner.  Maintenant, changeons un peu le code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] {<span class="hljs-number"><span class="hljs-number">42</span></span>}; Marshal.Copy(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, bytes.Length); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AccessViolationException) { ... }</code> </pre><br>  Si au lieu de WriteByte vous utilisez la m√©thode Copy et copiez l'octet 42 √† l'adresse 1000, puis en utilisant try-catch, AccessViolation ne peut pas √™tre intercept√©.  Dans le m√™me temps, un message s'affiche sur la console indiquant que l'application a √©t√© arr√™t√©e en raison d'une exception AccessViolationException non g√©r√©e. <br><br><pre> <code class="cs hljs">Marshal.Copy(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, bytes.Length); Marshal.WriteByte((IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre><br>  Il s'av√®re que nous avons deux lignes de code, tandis que la premi√®re plante toute l'application avec AccessViolation, et la seconde l√®ve une exception trait√©e du m√™me type.  Pour comprendre pourquoi cela se produit, nous verrons comment ces m√©thodes sont organis√©es de l'int√©rieur. <br><br>  Commen√ßons par la m√©thode Copy. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Copy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">)</span></span> { Marshal.CopyToNative((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>) source, startIndex, destination, length); } [MethodImpl(MethodImplOptions.InternalCall)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyToNative</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex, IntPtr destination, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  La seule chose que la m√©thode Copy fait est d'appeler la m√©thode CopyToNative, impl√©ment√©e dans .NET.  Si notre application plante toujours et qu'une exception se produit quelque part, cela ne peut se produire qu'√† l'int√©rieur de CopyToNative.  D'ici, nous pouvons faire la premi√®re observation: si le code .NET appel√© le code natif et AccessViolation se sont produits √† l'int√©rieur, le code .NET ne peut pas g√©rer cette exception pour une raison quelconque. <br><br>  Nous allons maintenant comprendre pourquoi il √©tait possible de traiter AccessViolation √† l'aide de la m√©thode WriteByte.  Regardons le code de cette m√©thode: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteByte</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { *(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*) ptr = val; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NullReferenceException) {     <span class="hljs-comment"><span class="hljs-comment">// this method is documented to throw AccessViolationException on any AV throw new AccessViolationException(); } }</span></span></code> </pre><br>  Cette m√©thode est enti√®rement impl√©ment√©e dans le code manag√©.  Il utilise un pointeur C # pour √©crire des donn√©es √† l'adresse souhait√©e et intercepte √©galement une exception NullReferenceException.  Si le NRE est intercept√©, une AccessViolationException est lev√©e.  Il est donc n√©cessaire en raison de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sp√©cification</a> .  Dans ce cas, toutes les exceptions lev√©es par la construction throw sont g√©r√©es.  Par cons√©quent, si une exception NullReferenceException se produit pendant l'ex√©cution de code dans WriteByte, nous pouvons intercepter AccessViolation.  Un NRE pourrait-il se produire, dans notre cas, lors de l'acc√®s √† l'adresse 1000 plut√¥t qu'√† l'adresse z√©ro? <br><br>  Nous r√©√©crivons le code √† l'aide de pointeurs C # directement, et voyons que lors de l'acc√®s √† une adresse non nulle, une NullReferenceException est en fait lev√©e: <br><br><pre> <code class="cs hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*) <span class="hljs-number"><span class="hljs-number">1000</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre><br>  Pour comprendre pourquoi cela se produit, nous devons nous rappeler comment fonctionne la m√©moire du processus.  Dans la m√©moire de processus, toutes les adresses sont virtuelles.  Cela signifie que l'application dispose d'un grand espace d'adressage et que seules certaines pages de celle-ci sont affich√©es dans la m√©moire physique r√©elle.  Mais il y a une particularit√©: les 64 premiers Ko d'adresses ne sont jamais mapp√©s √† la m√©moire physique et ne sont pas donn√©s √† l'application.  Rantime .NET le sait et l'utilise.  Si AccessViolation s'est produite dans le code manag√©, le runtime v√©rifie √† quelle adresse en m√©moire l'acc√®s a √©t√© g√©n√©r√© et g√©n√®re une exception appropri√©e.  Pour les adresses de 0 √† 2 ^ 16 - NullReference, pour tous les autres - AccessViolation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/775/3d4/38f/7753d438fc8a977ac0bb54e431d81c6f.png"><br><br>  Voyons pourquoi la NullReference est lev√©e non seulement lors de l'acc√®s √† l'adresse z√©ro.  Imaginez que vous acc√©dez √† un champ d'un objet d'un type de r√©f√©rence, et la r√©f√©rence √† cet objet est nulle: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/127/a27/867/127a27867ef7a568a242797758855b44.png"><br><br>  Dans cette situation, nous nous attendons √† obtenir une exception NullReferenceException.  L'acc√®s au champ de l'objet se fait √† un d√©calage par rapport √† l'adresse de cet objet.  Il s'av√®re que nous allons nous tourner vers une adresse suffisamment proche de z√©ro (rappelez-vous que le lien vers notre objet d'origine est z√©ro).  Avec ce comportement d'ex√©cution, nous obtenons l'exception attendue sans v√©rification suppl√©mentaire de l'adresse de l'objet lui-m√™me. <br><br>  Mais que se passe-t-il si nous nous tournons vers le champ d'un objet et que cet objet lui-m√™me occupe plus de 64 Ko? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/356/897/143/356897143b1275403569dc9f9a71471a.png"><br><br>  Pouvons-nous obtenir AccessViolation dans ce cas?  Faisons une exp√©rience.  Cr√©ons un tr√®s grand objet et nous nous r√©f√©rons √† ses champs.  Un champ au d√©but de l'objet, le second √† la fin: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08d/619/95a/08d61995a01630f94f31f759890af4a8.png"><br><br>  Les deux m√©thodes l√®veront une exception NullReferenceException.  Aucune exception AccessViolationException ne se produira. <br>  Regardons les instructions qui seront g√©n√©r√©es pour ces m√©thodes.  Dans le deuxi√®me cas, le compilateur JIT a ajout√© une instruction cmp suppl√©mentaire qui acc√®de √† l'adresse de l'objet lui-m√™me, appelant ainsi AccessViolation avec une adresse nulle, qui sera convertie par le runtime en NullReferenceException. <br><br>  Il convient de noter que pour cette exp√©rience, il ne suffit pas d'utiliser un tableau comme un grand objet.  Pourquoi?  Laissez cette question au lecteur, √©crivez des id√©es dans les commentaires :) <br><br>  R√©sumons les exp√©riences avec AccessViolation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ffa/86b/0a8/ffa86b0a85f29a16936c92845f5d3e1e.png"><br><br>  AccessViolationException se comporte diff√©remment selon l'endroit o√π l'exception s'est produite (en code manag√© ou en natif).  De plus, si une exception s'est produite dans le code manag√©, l'adresse de l'objet sera v√©rifi√©e. <br><br>  La question est: pouvons-nous g√©rer une AccessViolationException qui s'est produite dans du code natif ou dans du code manag√©, mais qui n'a pas √©t√© convertie en NullReference et qui n'a pas √©t√© lev√©e √† l'aide de throw?  Il s'agit parfois d'une fonctionnalit√© utile, en particulier lorsque vous travaillez avec du code non s√©curis√©.  La r√©ponse √† cette question d√©pend de la version de .NET. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/67a/785/318/67a785318bc8b5f084a3b23fa36e766b.png"><br><br>  Dans .NET 1.0, il n'y avait aucune exception AccessViolationException.  Tous les liens ont √©t√© consid√©r√©s comme valides ou nuls.  Au moment de .NET 2.0, il est devenu clair que sans travail direct avec la m√©moire - aucun moyen, et AccessViolation est apparu, alors qu'il √©tait traitable.  Dans la version 4.0 et sup√©rieure, il restait toujours r√©alisable, mais le traitement n'est pas si simple.  Pour intercepter cette exception, vous devez maintenant marquer la m√©thode dans laquelle se trouve le bloc catch avec l'attribut HandleProcessCorruptedStateException.  Apparemment, les d√©veloppeurs l'ont fait parce qu'ils pensaient que AccessViolationException n'√©tait pas l'exception qui devrait √™tre intercept√©e dans une application standard. <br>  De plus, pour des raisons de compatibilit√© descendante, il est possible d'utiliser les param√®tres d'ex√©cution: <br><br><ul><li>  legacyNullReferenceExceptionPolicy renvoie un comportement .NET 1.0 - tous les AV se transforment en NRE <br></li><li>  legacyCorruptedStateExceptionsPolicy renvoie un comportement .NET 2.0 - tous les AV sont intercept√©s <br></li></ul><br>  Dans .NET, Core AccessViolation n'est pas du tout g√©r√©. <br><br>  Dans notre production, il y avait une telle situation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad7/0f1/6d3/ad70f16d3438d1e8ab80e43ba29d5412.png"><br><br>  Une application construite sous .NET 4.7.1 a utilis√© une biblioth√®que de code partag√©e construite sous .NET 3.5.  Il y avait un assistant dans cette biblioth√®que pour ex√©cuter une action p√©riodique: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (isRunning) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { action(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { log.Error(e); } WaitForNextExecution(... ); }</code> </pre><br>  Nous avons transmis l'action de notre application √† cet assistant.  Il se trouve qu'il s'est √©cras√© avec AccessViolation.  En cons√©quence, notre application a constamment connect√© AccessViolation, au lieu de se bloquer parce que  le code dans la biblioth√®que sous 3.5 pourrait l'attraper.  Il convient de noter que l'interception ne d√©pend pas de la version du runtime sur lequel l'application s'ex√©cute, mais du TargetFramework, sous lequel l'application a √©t√© cr√©√©e, et de ses d√©pendances. <br><br>  Pour r√©sumer.  Le traitement AccessVilolation d√©pend de son origine - en code natif ou g√©r√© - ainsi que des param√®tres TargetFramework et d'ex√©cution. <br><br><h2>  Abandon du fil </h2><br>  Parfois, dans le code, vous devez arr√™ter l'ex√©cution de l'un des threads.  Pour ce faire, vous pouvez utiliser le thread.Abort (); <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ... Thread.ResetAbort(); } }); ... thread.Abort();</code> </pre><br>  Lorsque la m√©thode Abort est appel√©e dans un thread arr√™t√©, une ThreadAbortException est lev√©e.  Analysons ses caract√©ristiques.  Par exemple, un code comme celui-ci: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ‚Ä¶ } }); ... thread.Abort();</code> </pre><br>  Absolument √©quivalent √† ceci: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }); ... thread.Abort();</code> </pre><br>  Si vous devez toujours traiter ThreadAbort et effectuer d'autres actions dans le thread arr√™t√©, vous pouvez utiliser la m√©thode Thread.ResetAbort ();  Il arr√™te le processus d'arr√™t du flux et l'exception cesse de lancer plus haut dans la pile.  Il est important de comprendre que la m√©thode thread.Abort () elle-m√™me ne garantit rien - le code dans le thread arr√™t√© peut l'emp√™cher de s'arr√™ter. <br><br>  Une autre caract√©ristique de thread.Abort () est qu'il ne pourra pas interrompre le code s'il est dans le catch et enfin les blocs. <br><br>  Dans le code du framework, vous pouvez souvent trouver des m√©thodes o√π le bloc try est vide et toute la logique est enfin √† l'int√©rieur.  Cela est fait juste pour emp√™cher ce code d'√™tre lev√© par une ThreadAbortException. <br><br>  En outre, un appel √† la m√©thode thread.Abort () attend qu'une exception ThreadAbortException soit lev√©e.  Combinez ces deux faits et obtenez que la m√©thode thread.Abort () puisse bloquer le thread appelant. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { }       <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { } <span class="hljs-comment"><span class="hljs-comment">// &lt;-- No ThreadAbortException in catch       finally { // &lt;-- No ThreadAbortException in finally           Thread.Sleep(- 1); } }); thread.Start(); ... thread.Abort(); // Never returns</span></span></code> </pre><br>  En r√©alit√©, cela peut √™tre rencontr√© lors de l'utilisation de l'utilisation.  Elle est d√©ploy√©e dans try / finally, √† l'int√©rieur de la m√©thode finalement, la m√©thode Dispose est appel√©e.  Il peut √™tre arbitrairement complexe, contenir des gestionnaires d'√©v√©nements, utiliser des verrous.  Et si thread.Abort a √©t√© appel√© au moment de l'ex√©cution, Dispose - thread.Abort () l'attendra.  Nous obtenons donc un verrou presque √† partir de z√©ro. <br><br>  Dans .NET Core, la m√©thode thread.Abort () l√®ve une exception PlatformNotSupportedException.  Et je pense que c'est tr√®s bien, car cela me motive √† utiliser non pas thread.Abort (), mais des m√©thodes non invasives pour arr√™ter l'ex√©cution de code, par exemple en utilisant le CancellationToken. <br><br><h2>  HORS M√âMOIRE </h2><br>  Cette exception peut √™tre obtenue si la m√©moire de la machine est inf√©rieure √† celle requise.  Ou quand nous avons rencontr√© les limites d'un processus 32 bits.  Mais vous pouvez l'obtenir m√™me si l'ordinateur a beaucoup de m√©moire libre et que le processus est de 64 bits. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr4gb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue/<span class="hljs-number"><span class="hljs-number">2</span></span>];</code> </pre><br>  Le code ci-dessus lancera OutOfMemory.  Le fait est que, par d√©faut, les objets sup√©rieurs √† 2 Go ne sont pas autoris√©s.  Cela peut √™tre r√©solu en d√©finissant gcAllowVeryLargeObjects dans App.config.  Dans ce cas, une baie de 4 Go est cr√©√©e. <br><br>  Essayons maintenant de cr√©er un tableau encore plus. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> largeArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue];</code> </pre><br>  Maintenant, m√™me gcAllowVeryLargeObjects n'aidera pas.  Cela est d√ª au fait que .NET a une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">limite sur l'index maximum dans un tableau</a> .  Cette restriction est inf√©rieure √† int.MaxValue. <br><br>  Index de tableau max: <br><br><ul><li>  tableaux d'octets - 0x7FFFFFC7 <br></li><li>  autres tableaux - 0X7F <b>E</b> FFFFF <br></li></ul><br>  Dans ce cas, une OutOfMemoryException se produira, bien qu'en fait nous ayons rencontr√© une restriction de type de donn√©es, pas un manque de m√©moire. <br><br>  Parfois, OutOfMemory est explicitement jet√© par le code manag√© √† l'int√©rieur du framework .NET: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/efd/c84/d98/efdc84d98a7786e39c9c5931ac523d13.png"><br>  Il s'agit d'une impl√©mentation de la m√©thode string.Concat.  Si la longueur de la cha√Æne de r√©sultat est sup√©rieure √† int.MaxValue, une OutOfMemoryException est imm√©diatement lev√©e. <br><br>  Passons √† la situation o√π OutOfMemory appara√Æt dans le cas o√π la m√©moire est r√©ellement √©puis√©e. <br><br><pre> <code class="cs hljs">LimitMemory(<span class="hljs-number"><span class="hljs-number">64.</span></span>Mb()); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>)   list.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (OutOfMemoryException e) { Console.WriteLine(e); }</code> </pre><br>  Tout d'abord, nous limitons la m√©moire de notre processus √† 64 Mo.  Ensuite, √† l'int√©rieur de la boucle, s√©lectionnez de nouveaux tableaux d'octets, enregistrez-les sur une feuille afin que le GC ne les collecte pas et essayez d'attraper OutOfMemory. <br><br>  Dans ce cas, tout peut arriver: <br><br><ul><li>  Exception g√©r√©e <br></li><li>  Le processus va tomber <br></li><li>  Allons en prise, mais l'exception se bloque √† nouveau <br></li><li>  Entrons dans la capture, mais StackOverflow plantera <br></li></ul><br>  Dans ce cas, le programme sera totalement non d√©terministe.  Analysons toutes les options: <br><br><ol><li>  Une exception peut √™tre g√©r√©e.  Dans .NET, rien ne vous emp√™che de g√©rer une OutOfMemoryException. <br></li><li>  Le processus peut tomber.  N'oubliez pas que nous avons une application g√©r√©e.  Cela signifie qu'√† l'int√©rieur, il est ex√©cut√© non seulement notre code, mais aussi le code d'ex√©cution.  Par exemple, GC.  Ainsi, une situation peut se produire lorsque le runtime veut allouer de la m√©moire pour lui-m√™me, mais ne peut pas le faire, alors nous ne pourrons pas intercepter l'exception. <br></li><li>  Entrons dans le pi√®ge, mais l'exception se bloque √† nouveau.  √Ä l'int√©rieur de catch, nous faisons √©galement le travail o√π nous avons besoin de m√©moire (nous imprimons une exception sur la console), ce qui peut provoquer une nouvelle exception. <br></li><li>  Entrons dans la capture, mais StackOverflow plantera.  StackOverflow lui-m√™me se produit lorsque la m√©thode WriteLine est appel√©e, mais il n'y a pas de d√©bordement de pile ici, mais une situation diff√©rente se produit.  Analysons-le plus en d√©tail. <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/6e3/d32/752/6e3d32752ba10fd39d1f4a5e2e6648a7.png"><br><br>  Dans la m√©moire virtuelle, les pages peuvent non seulement √™tre mapp√©es √† la m√©moire physique, mais peuvent √©galement √™tre r√©serv√©es.  Si la page est r√©serv√©e, l'application a alors indiqu√© qu'elle allait l'utiliser.  Si la page est d√©j√† mapp√©e √† la m√©moire r√©elle ou √† l'√©change, elle est alors appel√©e ¬´valid√©e¬ª (valid√©e).  La pile utilise cette capacit√© pour diviser la m√©moire en r√©serv√©e et valid√©e.  Cela ressemble √† ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b17/9e4/41f/b179e441f0c00f18e2a5fdf12b3093a9.png"><br><br>  Il s'av√®re que nous appelons la m√©thode WriteLine, qui prend une certaine place sur la pile.  Il s'av√®re que toute la m√©moire valid√©e est d√©j√† termin√©e, ce qui signifie que le syst√®me d'exploitation devrait √† ce moment prendre une autre page r√©serv√©e sur la pile et la mapper √† la m√©moire physique r√©elle, qui est d√©j√† remplie de tableaux d'octets.  Cela conduit √† l'exception de StackOverflow. <br><br>  Le code suivant vous permettra de valider imm√©diatement toute la m√©moire dans la pile au d√©but du flux. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; F(), <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>).Start();</code> </pre><br>  Vous pouvez √©galement utiliser le param√®tre d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ex√©cution</a> disableCommitThreadStack.  Il doit √™tre d√©sactiv√© pour que la pile de threads soit valid√©e √† l'avance.  Il est √† noter que le comportement par d√©faut d√©crit dans la documentation et observ√© en r√©alit√© est diff√©rent. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46e/0e6/dbd/46e0e6dbd47906fb1d0ddf74ac927383.png"><br><br><h2>  D√©bordement de pile </h2><br>  Examinons de plus pr√®s StackOverflowException.  Regardons deux exemples de code.  Dans l'un d'eux, nous ex√©cutons une r√©cursion infinie, ce qui conduit √† un d√©bordement de pile, dans le second, nous lan√ßons simplement cette exception avec throw. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { InfiniteRecursion(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { ... }</code> </pre><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StackOverflowException(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { ... }</code> </pre><br>  Puisque toutes les exceptions lev√©es avec throw sont g√©r√©es, dans le deuxi√®me cas, nous intercepterons l'exception.  Et avec le premier cas, tout est plus int√©ressant.  Tournez-vous vers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MSDN</a> : <br><br><blockquote>  "Vous ne pouvez pas intercepter les exceptions de d√©passement de pile, car le code de gestion des exceptions peut n√©cessiter la pile." <br>  MSDN </blockquote><br>  Il indique ici que nous ne pourrons pas intercepter une StackOverflowException, car l'interception elle-m√™me peut n√©cessiter un espace de pile suppl√©mentaire qui est d√©j√† termin√©. <br><br>  Afin de nous prot√©ger contre cette exception, nous pouvons proc√©der comme suit.  Tout d'abord, vous pouvez limiter la profondeur de la r√©cursivit√©.  Deuxi√®mement, vous pouvez utiliser les m√©thodes de la classe RuntimeHelpers: <br><br><blockquote>  RuntimeHelpers.EnsureSufficientExecutionStack (); <br><br><ul><li>  "Garantit que l'espace de pile restant est suffisamment grand pour ex√©cuter la fonction .NET Framework moyenne."  - MSDN <br></li><li>  InsufficientExecutionStackException <br></li><li>  512 Ko - x86, AnyCPU, 2 Mo - x64 (moiti√© de la taille de la pile) <br></li><li>  64/128 Ko - .NET Core <br></li><li>  V√©rifier uniquement l'espace d'adressage de la pile <br></li></ul><br></blockquote><br>  La documentation de cette m√©thode indique qu'elle v√©rifie qu'il y a suffisamment d'espace sur la pile pour ex√©cuter la fonction .NET <i>moyenne</i> .  Mais quelle est la fonction <i>moyenne</i> ?  En fait, dans le .NET Framework, cette m√©thode v√©rifie qu'au moins la moiti√© de sa taille est libre sur la pile.  Dans .NET Core, il v√©rifie la disponibilit√© de 64 Ko. <br><br>  Un analogue est √©galement apparu dans .NET Core: RuntimeHelpers.TryEnsureSufficientExecutionStack () qui renvoie un bool√©en, plut√¥t que de lever une exception. <br><br>  C # 7.2 a introduit la possibilit√© d'utiliser Span et stackallock ensemble sans utiliser de code dangereux.  Peut-√™tre √† cause de cela, stackalloc sera utilis√© plus souvent dans le code et il sera utile d'avoir un moyen de se prot√©ger de StackOverflow lors de son utilisation, en choisissant o√π allouer de la m√©moire.  En tant que telle m√©thode, une m√©thode est propos√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qui v√©rifie la possibilit√© d'allocation sur la pile</a> et la construction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trystackalloc</a> . <br><br><pre> <code class="cs hljs">Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; span; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CanAllocateOnStack(size)) span = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> span = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size];</code> </pre><br>  Retour √† la documentation de StackOverflow sur MSDN <br><br><blockquote>  Au lieu de cela, lorsqu'un d√©bordement de pile se produit dans une <b>application normale</b> , le Common Language Runtime (CLR) met fin au processus. ¬ª <br>  MSDN <br></blockquote><br>  S'il y a une application ¬´normale¬ª qui tombe pendant StackOverflow, alors il y a des applications non normales qui ne tombent pas?  Pour r√©pondre √† cette question, vous devrez descendre d'un niveau du niveau de l'application g√©r√©e au niveau CLR. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/186/516/64d/18651664dd1c1d1346e5377f0e0b3995.png"><br><br><blockquote>  "Une application qui <b>h√©berge le CLR</b> peut modifier le comportement par d√©faut et sp√©cifier que le CLR <b>d√©charge le domaine d'application</b> o√π l'exception se produit, mais laisse le processus se poursuivre."  - MSDN <br>  StackOverflowException -&gt; AppDomainUnloadedException <br></blockquote><br>  Une application qui h√©berge le CLR peut red√©finir le comportement du d√©bordement de pile afin qu'au lieu de terminer l'int√©gralit√© du processus, le domaine d'application soit d√©charg√©, dans le flux duquel ce d√©bordement s'est produit.  Nous pouvons donc transformer une StackOverflowException en AppDomainUnloadedException. <br><br>  Lorsqu'une application g√©r√©e est lanc√©e, le runtime .NET d√©marre automatiquement.  Mais vous pouvez aller dans l'autre sens.  Par exemple, √©crivez une application non manag√©e (en C ++ ou dans un autre langage) qui utilisera une API sp√©ciale afin d'augmenter le CLR et de lancer notre application.  Une application qui ex√©cute le CLR en interne sera appel√©e h√¥te CLR.  En l'√©crivant, nous pouvons configurer beaucoup de choses en runtime.  Par exemple, remplacez le gestionnaire de m√©moire et le gestionnaire de threads.  En production, nous utilisons l'h√¥te CLR pour √©viter d'√©changer des pages de m√©moire. <br><br>  Le code suivant configure l'h√¥te CLR afin que AppDomain (C ++) soit d√©charg√© pendant StackOverflow: <br><br><pre> <code class="cpp hljs">ICLRPolicyManager *policyMgr; pCLRControl-&gt;GetCLRManager(IID_ICLRPolicyManager, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**) (&amp;policyMgr)); policyMgr-&gt;SetActionOnFailure(FAIL_StackOverflow, eRudeUnloadAppDomain);</code> </pre><br>  Est-ce un bon moyen d'√©chapper √† StackOverflow?  Probablement pas tr√®s.  Tout d'abord, nous avons d√ª √©crire du code C ++, ce que nous ne voudrions pas faire.  Deuxi√®mement, nous devons changer notre code C # afin que la fonction qui peut lever une StackOverflowException soit ex√©cut√©e dans un AppDomain distinct et dans un thread s√©par√©.  Notre code se transformera imm√©diatement en de telles nouilles: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; InfiniteRecursion()); thread.Start(); thread.Join(); }); AppDomain.Unload(appDomain); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AppDomainUnloadedException) { }</code> </pre><br>  Afin d'appeler la m√©thode InfiniteRecursion, nous avons √©crit un tas de lignes.  Troisi√®mement, nous avons commenc√© √† utiliser AppDomain.  Et cela garantit presque un tas de nouveaux probl√®mes.  Y compris avec des exceptions.  Prenons un exemple: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain( <span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomException()); System.Runtime.Serialization.SerializationException: Type <span class="hljs-string"><span class="hljs-string">'CustomException'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> not marked <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> serializable. at System.AppDomain.DoCallBack(CrossAppDomainDelegate callBackDelegate)</code> </pre><br>  √âtant donn√© que notre exception n'est pas marqu√©e comme s√©rialisable, notre code tombera avec une exception SerializationException.  Et pour r√©soudre ce probl√®me, il ne nous suffit pas de marquer notre exception avec l'attribut Serializable, nous devons toujours impl√©menter un constructeur suppl√©mentaire pour la s√©rialisation. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext ctx</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">info, context</span></span></span><span class="hljs-function">)</span></span>{} } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomException());</code> </pre><br>  Tout cela n'est pas tr√®s beau, alors nous allons plus loin - au niveau du syst√®me d'exploitation et des hacks, qui ne devraient pas √™tre utilis√©s en production. <br><br><h2>  Seh / veh </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/2c5/7a2/aff/2c57a2aff0542b2a02ad8ab34d097412.png"><br><br>  Notez que tandis que les exceptions g√©r√©es volaient entre Managed et le CLR, les exceptions SEH volent entre le CLR et Windows. <br><br>  SEH - Gestion structur√©e des exceptions <br><br><ul><li>  Moteur de gestion des exceptions Windows <br></li><li>  Gestion uniforme des exceptions logicielles et mat√©rielles <br></li><li>  Exceptions C # impl√©ment√©es au-dessus de SEH <br></li></ul><br>  SEH est un m√©canisme de gestion des exceptions dans Windows, il vous permet de g√©rer de mani√®re uniforme toutes les exceptions provenant, par exemple, du niveau du processeur ou associ√©es √† la logique de l'application elle-m√™me. <br><br>  Rantime .NET conna√Æt les exceptions SEH et peut les convertir en exceptions g√©r√©es: <br><br><ul><li>  EXCEPTION_STACK_OVERFLOW -&gt; Crash <br></li><li>  EXCEPTION_ACCESS_VIOLATION -&gt; AccessViolationException <br></li><li>  EXCEPTION_ACCESS_VIOLATION -&gt; NullReferenceException <br></li><li>  EXCEPTION_INT_DIVIDE_BY_ZERO -&gt; DivideByZeroException <br></li><li>  Exceptions SEH inconnues -&gt; SEHException <br></li></ul><br>  Nous pouvons interagir avec SEH via WinApi. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExceptionCode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExceptionFlags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nNumberOfArguments,IntPtr lpArguments</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// DivideByZeroException RaiseException(0xc0000094, 0, 0, IntPtr.Zero); // Stack overflow RaiseException(0xc00000fd, 0, 0, IntPtr.Zero);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En fait, la construction throw fonctionne √©galement via SEH. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> -&gt; RaiseException(<span class="hljs-number"><span class="hljs-number">0xe0434f4d</span></span>, ...)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il convient de noter ici que le code d'exception CLR est toujours le m√™me, donc quel que soit le type d'exception que nous lan√ßons, il sera toujours trait√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VEH est une gestion d'exceptions vectorielles, une extension de SEH, mais fonctionnant au niveau du processus, et non au niveau d'un seul thread. </font><font style="vertical-align: inherit;">Si SEH est s√©mantiquement similaire √† try-catch, alors VEH est s√©mantiquement similaire √† un gestionnaire d'interruption. </font><font style="vertical-align: inherit;">Nous d√©finissons simplement notre gestionnaire et pouvons recevoir des informations sur toutes les exceptions qui se produisent dans notre processus. </font><font style="vertical-align: inherit;">Une caract√©ristique int√©ressante de VEH est qu'elle vous permet de modifier l'exception SEH avant qu'elle ne parvienne au gestionnaire.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b8/79d/848/7b879d848390b9e3d1b9156b00b8e2bf.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons mettre notre propre gestionnaire vectoriel entre le syst√®me d'exploitation et le runtime, qui g√©rera les exceptions SEH et, lorsqu'il rencontrera EXCEPTION_STACK_OVERFLOW, le changera afin que le runtime .NET ne plante pas le processus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez interagir avec VEH via WinApi:</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">, SetLastError = true)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddVectoredExceptionHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr FirstHandler,  VECTORED_EXCEPTION_HANDLER VectoredHandler</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> VEH : <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> { EXCEPTION_CONTINUE_SEARCH = <span class="hljs-number"><span class="hljs-number">0</span></span>, EXCEPTION_EXECUTE_HANDLER = <span class="hljs-number"><span class="hljs-number">1</span></span>, EXCEPTION_CONTINUE_EXECUTION = <span class="hljs-number"><span class="hljs-number">-1</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EXCEPTION_POINTERS { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EXCEPTION_RECORD* ExceptionRecord; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IntPtr Context; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EXCEPTION_RECORD { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> ExceptionCode; ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le contexte contient des informations sur l'√©tat de tous les registres de processeur au moment de l'exception. </font><font style="vertical-align: inherit;">Nous serons int√©ress√©s par EXCEPTION_RECORD et le champ ExceptionCode qu'il contient. </font><font style="vertical-align: inherit;">Nous pouvons le remplacer par notre propre code d'exception, dont le CLR ne sait rien. </font><font style="vertical-align: inherit;">Le gestionnaire de vecteurs ressemble √† ceci:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.ExceptionRecord == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_CONTINUE_SEARCH; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> record = e. ExceptionRecord; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record-&gt;ExceptionCode != ExceptionStackOverflow) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_CONTINUE_SEARCH; record-&gt;ExceptionCode = <span class="hljs-number"><span class="hljs-number">0x01234567</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_EXECUTE_HANDLER; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous allons maintenant cr√©er un wrapper qui installe un gestionnaire vectoriel sous la forme de la m√©thode HandleSO, qui accepte un d√©l√©gu√© qui pourrait potentiellement tomber d'une StackOverflowException (pour plus de clart√©, le code ne g√®re pas les erreurs de fonction WinApi et supprime le gestionnaire vectoriel). </font></font><br><br><pre> <code class="cs hljs">HandleSO(() =&gt; InfiniteRecursion()) ; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T HandleSO&lt;T&gt;(Func&lt;T&gt; action) { Kernel32. AddVectoredExceptionHandler(IntPtr.Zero, Handler); Kernel32.SetThreadStackGuarantee(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> size); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) when ((<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>) Marshal. GetExceptionCode() == <span class="hljs-number"><span class="hljs-number">0x01234567</span></span>) {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(T); } HandleSO(() =&gt; InfiniteRecursion());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä l'int√©rieur, la m√©thode SetThreadStackGuarantee est √©galement utilis√©e. </font><font style="vertical-align: inherit;">Cette m√©thode r√©serve un espace de pile pour le traitement StackOverflow. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De cette fa√ßon, nous pouvons survivre √† l'invocation d'une m√©thode √† r√©cursion infinie. </font><font style="vertical-align: inherit;">Notre flux continuera de fonctionner comme si rien ne s'√©tait pass√©, comme si aucun d√©bordement ne s'√©tait produit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais que se passe-t-il si vous appelez HandleSO deux fois dans le m√™me thread?</font></font><br><br><pre> <code class="cs hljs">HandleSO(() =&gt; InfiniteRecursion()); HandleSO(() =&gt; InfiniteRecursion());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et il y aura une exception AccessViolationException. Retour au p√©riph√©rique de pile. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/639/e93/c8d/639e93c8d187dc31fc37a2ac7247f193.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le syst√®me d'exploitation peut d√©tecter les d√©bordements de pile. Tout en haut de la pile se trouve une page sp√©ciale marqu√©e du drapeau de page Garde. Lors du premier acc√®s √† cette page, une autre exception se produira - STATUS_GUARD_PAGE_VIOLATION, et l'indicateur de page de garde sera supprim√© de la page. Si vous interceptez simplement ce d√©bordement, cette page ne sera plus sur la pile - au prochain d√©bordement, le syst√®me d'exploitation ne pourra pas le comprendre et le pointeur de pile ira au-del√† de la m√©moire allou√©e √† la pile. Par cons√©quent, une exception AccessViolationException se produira. Vous devez donc restaurer les indicateurs de page apr√®s le traitement de StackOverflow - la fa√ßon la plus simple de le faire est d'utiliser la m√©thode _resetstkoflw de la biblioth√®que d'ex√©cution C (msvcrt.dll).</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"msvcrt.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _resetstkoflw();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De la m√™me mani√®re, vous pouvez intercepter une AccessViolationException dans .NET Core sous Windows, ce qui provoque le blocage du processus. </font><font style="vertical-align: inherit;">Dans ce cas, vous devez prendre en compte l'ordre dans lequel les gestionnaires vectoriels sont appel√©s et d√©finir votre gestionnaire au d√©but de la cha√Æne, car .NET Core utilise √©galement VEH lors du traitement d'AccessViolation. </font><font style="vertical-align: inherit;">Le premier param√®tre de la fonction AddVectoredExceptionHandler est responsable de l'ordre dans lequel les gestionnaires sont appel√©s:</font></font><br><br><pre> <code class="cs hljs">Kernel32.AddVectoredExceptionHandler(FirstHandler: (IntPtr) <span class="hljs-number"><span class="hljs-number">1</span></span>, handler);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apr√®s avoir √©tudi√© des questions pratiques, nous r√©sumons les r√©sultats g√©n√©raux: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les exceptions ne sont pas aussi simples qu'elles le paraissent; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Toutes les exceptions ne sont pas g√©r√©es de la m√™me mani√®re; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La gestion des exceptions se produit √† diff√©rents niveaux d'abstraction; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous pouvez intervenir dans le processus de gestion des exceptions et faire fonctionner le runtime .NET diff√©remment de celui initialement pr√©vu. </font></font><br></li></ul><br><h2>  Les r√©f√©rences </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©f√©rentiel avec des exemples du rapport</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dotnext 2016 Moscou - Adam Sitnik - Exceptions exceptionnelles dans .NET</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNetBook: Exceptions</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Inside Out Partie 8 - G√©rer l'exception de d√©passement de pile en C # avec VEH</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une autre fa√ßon d'intercepter StackOverflow.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les 22 et 23 novembre, Eugene prononcera une </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allocution</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† </font><b><font style="vertical-align: inherit;">DotNext 2018 Moscou</font></b><font style="vertical-align: inherit;"> avec un rapport </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"System Metrics: </font></font></a><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">Collecting </font></b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">Pitfalls"</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jeffrey Richter, Greg Young, Pavel Yosifovich et d'autres conf√©renciers tout aussi int√©ressants viendront √† Moscou. </font><font style="vertical-align: inherit;">Les sujets des rapports peuvent √™tre consult√©s </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et acheter des billets </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Rejoignez-nous maintenant!</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426045/">https://habr.com/ru/post/fr426045/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426029/index.html">Vous abandonnez et souhaitez quitter la t√¢che? Voici √† quoi ressemble une formation de d√©veloppeur efficace</a></li>
<li><a href="../fr426031/index.html">S'inqui√©ter de capturer le monde avec l'intelligence artificielle peut √™tre bas√© sur des hypoth√®ses non scientifiques</a></li>
<li><a href="../fr426033/index.html">Les titans des maths s'affrontent sur la preuve √©pique de l'hypoth√®se abc</a></li>
<li><a href="../fr426039/index.html">Lancement d'urgence "Soyouz MS-10" (√©quipage sauv√©, retransmis)</a></li>
<li><a href="../fr426041/index.html">Solution symbolique d'√©quations et de syst√®mes diff√©rentiels lin√©aires par la m√©thode de transformation de Laplace utilisant SymPy</a></li>
<li><a href="../fr426047/index.html">10 grands livres pour d√©butants en anglais</a></li>
<li><a href="../fr426051/index.html">Am√©liorer les comp√©tences de d√©bogage de logiciels - quelques conseils</a></li>
<li><a href="../fr426053/index.html">Am√©lioration de la mise en cache des gestionnaires d'√©v√©nements et des performances des applications React</a></li>
<li><a href="../fr426055/index.html">TensorFlow.js et clmtrackr.js: suivre la direction du regard de l'utilisateur dans le navigateur</a></li>
<li><a href="../fr426059/index.html">Meetup Tutu PHP # 2: Vid√©o des discours</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>