<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✊🏿 ◾️ 💅🏼 Memecah dasar-dasar C #: mengalokasikan memori untuk tipe referensi pada stack 🌸 🤶🏼 ⚗️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini akan menunjukkan kepada Anda dasar-dasar tipe internal, seperti tentu saja contoh di mana memori untuk tipe referensi akan dialokasikan se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memecah dasar-dasar C #: mengalokasikan memori untuk tipe referensi pada stack</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448338/">  Artikel ini akan menunjukkan kepada Anda dasar-dasar tipe internal, seperti tentu saja contoh di mana memori untuk tipe referensi akan dialokasikan sepenuhnya pada stack (ini karena saya seorang programmer full-stack). <br><br><img src="https://habrastorage.org/webt/xn/xh/rl/xnxhrlrmdifxe8o2pwopy-y-xhw.jpeg"><br><br><h3>  Penafian </h3><br>  Artikel ini tidak mengandung bahan yang harus digunakan dalam proyek nyata.  Ini hanyalah perpanjangan dari batas-batas di mana bahasa pemrograman dirasakan. <br><br>  Sebelum melanjutkan cerita, saya sangat menyarankan Anda untuk membaca posting pertama tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StructLayout</a> , karena ada contoh yang akan digunakan dalam artikel ini (Namun, seperti biasa). <br><a name="habracut"></a><br><h3>  Prasejarah </h3><br>  Mulai menulis kode untuk artikel ini, saya ingin melakukan sesuatu yang menarik menggunakan bahasa assembly.  Saya ingin entah bagaimana mematahkan model eksekusi standar dan mendapatkan hasil yang benar-benar tidak biasa.  Dan mengingat seberapa sering orang mengatakan bahwa tipe referensi berbeda dari tipe nilai karena yang pertama terletak di heap dan yang kedua ada di tumpukan, saya memutuskan untuk menggunakan assembler untuk menunjukkan bahwa tipe referensi dapat hidup di tumpukan.  Namun, saya mulai mengalami berbagai masalah, misalnya, mengembalikan alamat dan presentasinya sebagai tautan terkelola (saya masih mengerjakannya).  Jadi saya mulai menipu dan melakukan sesuatu yang tidak berfungsi dalam bahasa assembly, di C #.  Dan pada akhirnya, tidak ada assembler sama sekali. <br>  Baca juga rekomendasi - jika Anda terbiasa dengan tata letak jenis referensi, saya sarankan melewatkan teori tentang mereka (hanya dasar-dasar yang akan diberikan, tidak ada yang menarik). <br><br><h3>  Sedikit tentang tipe internal (untuk kerangka lama, sekarang beberapa offset diubah, tetapi skema keseluruhannya sama) </h3><br>  Saya ingin mengingatkan bahwa pembagian memori menjadi tumpukan dan tumpukan terjadi di tingkat .NET, dan pembagian ini murni logis;  secara fisik tidak ada perbedaan antara area memori di bawah tumpukan dan tumpukan.  Perbedaan produktivitas disediakan hanya oleh algoritma yang berbeda untuk bekerja dengan kedua bidang ini. <br><br>  Lalu, bagaimana cara mengalokasikan memori pada stack?  Untuk memulainya, mari kita memahami bagaimana tipe referensi misterius ini diatur dan apa yang dimilikinya, tipe nilai itu tidak memiliki. <br><br>  Jadi, perhatikan contoh paling sederhana dengan karyawan kelas. <br><br><div class="spoiler">  <b class="spoiler_title">Kode Karyawan</b> <div class="spoiler_text"><pre><code class="plaintext hljs">public class Employee { private int _id; private string _name; public virtual void Work() { Console.WriteLine(“Zzzz...”); } public void TakeVacation(int days) { Console.WriteLine(“Zzzz...”); } public static void SetCompanyPolicy(CompanyPolicy policy) { Console.WriteLine("Zzzz..."); } }</code> </pre> <br></div></div><br>  Dan mari kita lihat bagaimana disajikan dalam memori. <br>  Kelas ini dipertimbangkan pada contoh sistem 32-bit. <br><br><img src="https://habrastorage.org/webt/vr/p9/pz/vrp9pzrp7gclrthnistslmvxnfg.png"><br><br>  Dengan demikian, selain memori untuk bidang, kami memiliki dua bidang tersembunyi lagi - indeks blok sinkronisasi (judul kata header objek pada gambar) dan alamat tabel metode. <br><br>  Bidang pertama (indeks blok sinkronisasi) tidak terlalu menarik bagi kami.  Ketika menempatkan jenis saya memutuskan untuk melewati itu.  Saya melakukan ini karena dua alasan: <br><br><ol><li>  Saya sangat malas (saya tidak mengatakan bahwa alasannya masuk akal) </li><li>  Untuk operasi dasar objek, bidang ini tidak diperlukan. </li></ol><br>  Tetapi karena kita sudah mulai berbicara, saya pikir benar untuk mengatakan beberapa kata tentang bidang ini.  Ini digunakan untuk berbagai tujuan (kode hash, sinkronisasi).  Sebaliknya, bidang itu sendiri hanyalah indeks dari salah satu blok sinkronisasi yang terkait dengan objek yang diberikan.  Blok sendiri terletak di tabel blok sinkronisasi (sesuatu seperti array global).  Membuat blok semacam itu adalah operasi yang agak besar, jadi itu tidak dibuat jika tidak diperlukan.  Selain itu, ketika menggunakan kunci tipis, pengenal utas yang menerima kunci (bukan indeks) akan ditulis di sana. <br><br>  Bidang kedua jauh lebih penting bagi kami.  Berkat tabel metode jenis, alat yang ampuh seperti polimorfisme dimungkinkan (yang, omong-omong, struktur, tumpukan raja, tidak miliki). <br>  Misalkan kelas Karyawan juga mengimplementasikan tiga antarmuka: IComparable, IDisposable, dan ICloneable. <br><br>  Maka tabel metode akan terlihat seperti ini. <br><br><img src="https://habrastorage.org/webt/x3/e9/wn/x3e9wne2jnil20fke6-gj2ovdv4.png"><br><br>  Gambarnya sangat keren, semuanya ditampilkan dan semuanya jelas.  Singkatnya, metode virtual tidak dipanggil langsung berdasarkan alamat, tetapi oleh offset dalam tabel metode.  Dalam hierarki, metode virtual yang sama akan ditempatkan pada offset yang sama dalam tabel metode.  Yaitu, pada kelas dasar kita memanggil metode dengan offset, tidak mengetahui jenis tabel metode yang akan digunakan, tetapi mengetahui bahwa offset ini akan menjadi metode yang paling relevan untuk jenis runtime. <br><br>  Juga perlu diingat bahwa referensi objek menunjuk hanya ke pointer tabel metode. <br><br><h3>  Contoh yang ditunggu-tunggu </h3><br>  Mari kita mulai dengan kelas yang akan membantu kita dalam tujuan kita.  Menggunakan StructLayout (saya benar-benar mencoba tanpa itu, tetapi tidak berhasil), saya menulis pemetaan sederhana - pointer ke jenis yang dikelola dan kembali.  Mendapatkan pointer dari tautan terkelola cukup mudah, tetapi transformasi terbalik menyebabkan saya kesulitan dan, tanpa berpikir dua kali, saya menerapkan atribut favorit saya.  Untuk menyimpan kode dalam satu kunci, dibuat dalam 2 arah dalam satu cara. <br><br><div class="spoiler">  <b class="spoiler_title">Kode pembuat peta</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// Provides the signatures we need public class PointerCasterFacade { public virtual unsafe T GetManagedReferenceByPointer&lt;T&gt;(int* pointer) =&gt; default(T); public virtual unsafe int* GetPointerByManagedReference&lt;T&gt;(T managedReference) =&gt; (int*)0; } // Provides the logic we need public class PointerCasterUnderground { public virtual T GetManagedReferenceByPointer&lt;T&gt;(T reference) =&gt; reference; public virtual unsafe int* GetPointerByManagedReference&lt;T&gt;(int* pointer) =&gt; pointer; } [StructLayout(LayoutKind.Explicit)] public class PointerCaster { public PointerCaster() { pointerCaster= new PointerCasterUnderground(); } [FieldOffset(0)] private PointerCasterUnderground pointerCaster; [FieldOffset(0)] public PointerCasterFacade Caster; }</code> </pre><br></div></div><br><br>  Pertama, kita menulis metode yang membawa pointer ke beberapa memori (tidak harus di stack, by the way) dan mengkonfigurasi tipe. <br><br>  Untuk kesederhanaan menemukan alamat tabel metode, saya membuat tipe di heap.  Saya yakin bahwa tabel metode dapat ditemukan dengan cara lain, tetapi saya tidak menetapkan diri saya tujuan mengoptimalkan kode ini, itu lebih menarik bagi saya untuk membuatnya dimengerti.  Selanjutnya, menggunakan konverter yang dijelaskan sebelumnya, kami memperoleh pointer ke tipe yang dibuat. <br><br>  Pointer ini menunjuk tepat ke tabel metode.  Oleh karena itu, cukup dengan hanya memperoleh konten dari memori yang ditunjuknya.  Ini akan menjadi alamat tabel metode. <br>  Dan karena pointer yang diberikan kepada kita adalah semacam referensi objek, kita juga harus menulis alamat tabel metode tepat di mana ia menunjuk. <br><br>  Sebenarnya itu saja.  Tiba-tiba, bukan?  Sekarang tipe kita sudah siap.  Pinocchio, yang mengalokasikan memori kepada kami, akan mengurus inisialisasi ladang sendiri. <br><br>  Tetap hanya menggunakan ultra-mega caster kami untuk mengubah pointer menjadi tautan terkelola. <br><pre> <code class="plaintext hljs">public class StackInitializer { public static unsafe T InitializeOnStack&lt;T&gt;(int* pointer) where T : new() { T r = new T(); var caster = new PointerCaster().Caster; int* ptr = caster.GetPointerByManagedReference(r); pointer[0] = ptr[0]; T reference = caster.GetManagedReferenceByPointer&lt;T&gt;(pointer); return reference; } }</code> </pre><br>  Sekarang kita memiliki tautan pada tumpukan yang menunjuk ke tumpukan yang sama, di mana menurut semua hukum jenis referensi (well, hampir) terletak sebuah objek yang dibangun dari tanah hitam dan tongkat.  Polimorfisme tersedia. <br><br>  Harus dipahami bahwa jika Anda melewati tautan ini di luar metode, maka setelah kembali dari itu, kami akan mendapatkan sesuatu yang tidak jelas.  Tentang panggilan metode virtual dan ucapan tidak bisa, pengecualian akan terjadi.  Metode normal dipanggil langsung, kode hanya akan memiliki alamat untuk metode nyata, sehingga mereka akan berfungsi.  Dan di tempat ladang akan ... dan tidak ada yang tahu apa yang akan ada di sana. <br><br>  Karena tidak mungkin menggunakan metode terpisah untuk inisialisasi pada stack (karena frame stack akan ditimpa setelah kembali dari metode), metode yang ingin menerapkan jenis pada stack harus mengalokasikan memori.  Sebenarnya, ada beberapa cara untuk melakukannya.  Tapi yang paling cocok untuk kita adalah <b>stackalloc</b> .  Hanya kata kunci yang sempurna untuk keperluan kita.  Sayangnya, ini membawa kode yang <i>tidak aman</i> .  Sebelum itu, ada ide untuk menggunakan Span untuk tujuan ini dan untuk melakukannya tanpa kode yang tidak aman.  Dalam kode yang tidak aman tidak ada yang buruk, tetapi seperti di mana-mana, itu bukan peluru perak dan memiliki area aplikasi sendiri. <br><br>  Kemudian, setelah menerima pointer ke memori pada stack saat ini, kami meneruskan pointer ini ke metode yang membentuk tipe di bagian.  Itu semua yang mendengarkan - dilakukan dengan baik. <br><br><pre> <code class="plaintext hljs">unsafe class Program { public static void Main() { int* pointer = stackalloc int[2]; var a = StackInitializer.InitializeOnStack&lt;StackReferenceType&gt;(pointer); a.StubMethod(); Console.WriteLine(a.Field); Console.WriteLine(a); Console.Read(); } }</code> </pre><br>  Anda seharusnya tidak menggunakannya dalam proyek nyata, metode mengalokasikan memori pada stack menggunakan T () baru, yang pada gilirannya menggunakan refleksi untuk membuat tipe pada heap!  Jadi metode ini akan lebih lambat dari biasanya penciptaan jenis kali, di 40-50.  Apalagi itu bukan lintas platform. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat menemukan seluruh proyek. <br><br>  Sumber: dalam panduan teoretis, contoh-contoh dari buku Sasha Goldstein - Pro .NET Performace digunakan </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448338/">https://habr.com/ru/post/id448338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448328/index.html">Di Moskow akan ditampilkan printer yang mencetak organ dan jaringan</a></li>
<li><a href="../id448330/index.html">Angka Acak dan Jaringan Terdesentralisasi: Aplikasi Praktis</a></li>
<li><a href="../id448332/index.html">Memulai Penganut IT: Tunjukkan Kekuatan Anda di Karang</a></li>
<li><a href="../id448334/index.html">Ketika produktivitas seseorang membangkitkan minat</a></li>
<li><a href="../id448336/index.html">Seminar "Awan hibrid - pro dan kontra: apa yang harus dipersiapkan untuk bisnis dan TI" - 25 April, Moskow</a></li>
<li><a href="../id448340/index.html">Pembuatan game 35MM. Post Apocalypse di Rusia</a></li>
<li><a href="../id448342/index.html">MyDrops - TWS murah dengan suara yang bagus dan Bluetooth yang andal</a></li>
<li><a href="../id448346/index.html">Dari GNU ke Doom: TechTrain 2019 Diumumkan</a></li>
<li><a href="../id448350/index.html">Implementasi kamus dengan Python</a></li>
<li><a href="../id448352/index.html">Boring Company akan menggali terowongan di Las Vegas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>