<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•† üë©üèª‚Äçüîß ü•å LLVM IR e Go üíÇüèº üò≥ üöµüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, veremos como criar um programa Go, como um compilador ou analisador est√°tico, que interaja com a estrutura de compila√ß√£o do LLVM usando ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>LLVM IR e Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459704/">  Neste artigo, veremos como criar um programa Go, como um compilador ou analisador est√°tico, que interaja com a estrutura de compila√ß√£o do LLVM usando a linguagem de montagem do LLVM IR. <br><br>  <b>TL; DR</b> , escrevemos uma biblioteca para interagir com o LLVM IR no Go puro, consulte os links para o c√≥digo e um exemplo de projeto. <br><a name="habracut"></a><br><h3>  Um exemplo simples de LLVM IR </h3><br>  (Aqueles que voc√™ conhece o LLVM IR podem pular para a pr√≥xima se√ß√£o). <br><br>  LLVM IR √© a representa√ß√£o intermedi√°ria de baixo n√≠vel usada pela estrutura de compila√ß√£o do LLVM.  Voc√™ pode pensar no LLVM IR como um montador independente de plataforma com um n√∫mero infinito de registros locais. <br><br>  Ao projetar um compilador, h√° uma enorme vantagem em compilar o idioma de origem em uma representa√ß√£o intermedi√°ria (IR, representa√ß√£o intermedi√°ria) em vez de compil√°-lo na arquitetura de destino (por exemplo, x86). <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text">  A id√©ia de usar uma linguagem intermedi√°ria nos compiladores √© generalizada.  O GCC usa o GIMPLE, o Roslyn usa o CIL, o LLVM usa o LLVM IR. <br></div></div><br>  Como muitas t√©cnicas de otimiza√ß√£o s√£o comuns (por exemplo, remo√ß√£o de c√≥digo n√£o utilizado, distribui√ß√£o de constantes), essas passagens de otimiza√ß√£o podem ser realizadas diretamente no n√≠vel de IR e usadas por todas as plataformas de destino. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text">  O uso de uma linguagem intermedi√°ria (IR) reduz o n√∫mero de combina√ß√µes necess√°rias para n idiomas de origem e m arquiteturas de destino (back-end) de n * m para n + m. <br></div></div><br>  Assim, os compiladores geralmente consistem em tr√™s partes: frontend, middleland e backend, cada um deles executa sua pr√≥pria tarefa, aceitando entrada e / ou fornecendo sa√≠da IR. <br><br><ul><li>  Frontend: compila o idioma de origem no IR </li><li>  Middleland: otimiza RI </li><li>  Back-end: compila RI em c√≥digo de m√°quina </li></ul><br><img src="https://habrastorage.org/webt/i_/pc/q6/i_pcq6eyhimm7drjixdnwrkog60.png"><br><br><h4>  Programa de amostra do assembler LLVM IR </h4><br>  Para ter uma ideia da apar√™ncia do assembler de LLVM IR, considere o seguinte programa. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-number"><span class="hljs-number">2</span></span>*b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); }</code> </pre> <br>  Usamos Clang e compilamos o c√≥digo C acima no assembler LLVM IR. <br><br><div class="spoiler">  <b class="spoiler_title">Clang</b> <div class="spoiler_text">  clang -S -emit-llvm -o foo.ll foo.c. <br></div></div><br><pre> <code class="cpp hljs">define i32 @f(i32 %a, i32 %b) { ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">0</span></span> %<span class="hljs-number"><span class="hljs-number">1</span></span> = mul i32 <span class="hljs-number"><span class="hljs-number">2</span></span>, %b %<span class="hljs-number"><span class="hljs-number">2</span></span> = add i32 %a, %<span class="hljs-number"><span class="hljs-number">1</span></span> ret i32 %<span class="hljs-number"><span class="hljs-number">2</span></span> } define i32 @main() { ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">0</span></span> %<span class="hljs-number"><span class="hljs-number">1</span></span> = call i32 @f(i32 <span class="hljs-number"><span class="hljs-number">10</span></span>, i32 <span class="hljs-number"><span class="hljs-number">20</span></span>) ret i32 %<span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  Observando o c√≥digo do assembler de LLVM IR acima, podemos observar alguns recursos dignos de nota de LLVM IR, a saber: <br><br>  O IR LLVM √© estaticamente tipado (ou seja, n√∫meros inteiros de 32 bits s√£o cruzados pelo tipo i32). <br><br>  Vari√°veis ‚Äã‚Äãlocais t√™m escopo dentro da fun√ß√£o (ou seja,% 1 em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">main</a> √© diferente de% 1 em @f). <br><br>  Sem nome (registros tempor√°rios) recebem identificadores locais (por exemplo,% 1,% 2), em ordem crescente, em cada uma das fun√ß√µes.  Cada fun√ß√£o pode usar um n√∫mero infinito de registros (n√£o limitado a 32 registros de uso geral).  Identificadores globais (por exemplo, @f) e identificadores locais (por exemplo,% a,% 1) s√£o diferenciados por um prefixo (@ e%, respectivamente). <br><br>  A maioria dos comandos faz o que voc√™ espera, assim o mul faz a multiplica√ß√£o, adiciona adi√ß√£o, etc. <br><br>  Os coment√°rios come√ßam com, como √© habitual nas linguagens assembly. <br><br><h4>  Estrutura do montador de LLMV IR </h4><br>  O conte√∫do do arquivo de montagem do LLVM IR √© um m√≥dulo.  O m√≥dulo cont√©m declara√ß√µes de alto n√≠vel, como vari√°veis ‚Äã‚Äãe fun√ß√µes globais. <br><br>  Uma declara√ß√£o de fun√ß√£o n√£o cont√©m blocos base, uma defini√ß√£o de fun√ß√£o cont√©m um ou mais blocos b√°sicos (isto √©, um corpo de fun√ß√£o). <br><br>  Um exemplo mais detalhado do m√≥dulo LLVM IR √© dado abaixo.  incluindo a defini√ß√£o da vari√°vel global @foo e a defini√ß√£o da fun√ß√£o @f que cont√©m tr√™s blocos base (% de entrada,% de bloco_1 e% de bloco_2). <br><br><pre> <code class="cpp hljs">;  ,  <span class="hljs-number"><span class="hljs-number">32</span></span>-  <span class="hljs-number"><span class="hljs-number">21</span></span> @foo = global i32 <span class="hljs-number"><span class="hljs-number">21</span></span> ; f  <span class="hljs-number"><span class="hljs-number">42</span></span>,   cond ,  <span class="hljs-number"><span class="hljs-number">0</span></span>    define i32 @f(i1 %cond) { ;       ,     ;      entry: ;     br    block_1,  %cond ; ,   block_2   . br i1 %cond, label %block_1, label %block_2 ;     ,    ,     block_1: %tmp = load i32, i32* @foo %result = mul i32 %tmp, <span class="hljs-number"><span class="hljs-number">2</span></span> ret i32 %result ;     ,     ,     block_2: ret i32 <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><h4>  Unidade base </h4><br>  Uma unidade base √© uma sequ√™ncia de comandos que n√£o s√£o comandos de transi√ß√£o (comandos de finaliza√ß√£o).  A id√©ia principal da unidade base √© que, se um comando da unidade base for executado, todos os outros comandos da unidade base ser√£o executados.  Isso simplifica a an√°lise do fluxo de execu√ß√£o. <br><br><h4>  A equipe </h4><br>  Um comando que n√£o √© um comando de salto geralmente executa c√°lculos ou acesso √† mem√≥ria (por exemplo, adicionar, carregar), mas n√£o altera o fluxo de controle do programa. <br><br><h4>  Equipe de rescis√£o </h4><br>  O comando de t√©rmino est√° localizado no final de cada unidade base e determina onde a transi√ß√£o ser√° feita no final da unidade base.  Por exemplo, o comando ret finalizador retorna o fluxo de controle da fun√ß√£o de chamada e br executa a transi√ß√£o, condicional ou incondicional. <br><br><h4>  Formul√°rio SSA </h4><br>  Uma propriedade muito importante do LLVM IR √© que ele √© escrito no formul√°rio SSA (Static Single Assignment), o que significa essencialmente que cada registro √© atribu√≠do apenas uma vez.  Esta propriedade simplifica a an√°lise est√°tica do fluxo de dados. <br><br>  Para processar vari√°veis ‚Äã‚Äãatribu√≠das mais de uma vez no c√≥digo fonte original, o comando phi √© usado no LLVM IR.  O comando phi essencialmente retorna um valor √∫nico de um conjunto de valores de entrada, dependendo do caminho de execu√ß√£o em que este comando foi alcan√ßado.  Cada valor de entrada √©, portanto, associado a um bloco de entrada anterior. <br><br>  Como exemplo, considere a seguinte fun√ß√£o LLVM IR: <br><br><pre> <code class="cpp hljs">define i32 @f(i32 %a) { ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> i32 %a, label %<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> [ i32 <span class="hljs-number"><span class="hljs-number">42</span></span>, label %case1 ] case1: %x<span class="hljs-number"><span class="hljs-number">.1</span></span> = mul i32 %a, <span class="hljs-number"><span class="hljs-number">2</span></span> br label %ret <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: %x<span class="hljs-number"><span class="hljs-number">.2</span></span> = mul i32 %a, <span class="hljs-number"><span class="hljs-number">3</span></span> br label %ret ret: %x<span class="hljs-number"><span class="hljs-number">.0</span></span> = phi i32 [ %x<span class="hljs-number"><span class="hljs-number">.2</span></span>, %<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> ], [ %x<span class="hljs-number"><span class="hljs-number">.1</span></span>, %case1 ] ret i32 %x<span class="hljs-number"><span class="hljs-number">.0</span></span> }</code> </pre> <br>  O comando phi (tamb√©m chamado de n√≥ phi) no exemplo acima simula v√°rias atribui√ß√µes usando um conjunto de poss√≠veis valores de entrada, um para cada caminho poss√≠vel no encadeamento de execu√ß√£o, levando √† atribui√ß√£o de vari√°veis.  Por exemplo, um dos caminhos correspondentes no fluxo de dados √© o seguinte: <br><br><img src="https://habrastorage.org/webt/ng/zd/h3/ngzdh3seqkmiww9rsn9as7czeg4.png"><br><br>  Em geral, ao desenvolver um compilador que converte o c√≥digo-fonte em LLVM IR, todas as vari√°veis ‚Äã‚Äãde c√≥digo-fonte local podem ser convertidas para o formato SSA, com exce√ß√£o das vari√°veis ‚Äã‚Äãpara as quais seu endere√ßo √© utilizado. <br><br>  Para simplificar a implementa√ß√£o do front-end do LLVM, recomenda-se modelar vari√°veis ‚Äã‚Äãlocais no idioma de origem como vari√°veis ‚Äã‚Äãalocadas na mem√≥ria (usando alloca), simulando atribui√ß√µes a vari√°veis ‚Äã‚Äãlocais como grava√ß√µes na mem√≥ria e usando uma vari√°vel local como leituras da mem√≥ria.  O motivo √© que pode ser uma tarefa n√£o trivial traduzir diretamente o idioma de origem para o LLVM IR no formato SSA.  Desde que o acesso √† mem√≥ria siga certos padr√µes, podemos confiar no passo de otimiza√ß√£o do mem2reg como parte do LLVM para converter vari√°veis ‚Äã‚Äãlocais alocadas na mem√≥ria em registradores no formato SSA (usando n√≥s phi, quando necess√°rio). <br><br><h3>  Biblioteca LLVM IR no Go puro </h3><br>  Existem duas bibliotecas principais para trabalhar com o LLVM IR no Go: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://godoc.org/llvm.org/llvm/bindings/go/llvm</a> : liga√ß√µes oficiais do LLVM para o idioma Go. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/llir/llvm</a> : uma biblioteca Go limpa para interagir com o LLVM IR. <br><br>  As liga√ß√µes oficiais do LLVM para a linguagem Go usam o Cgo para fornecer acesso √†s APIs ricas e poderosas da estrutura do compilador LLVM, enquanto o projeto llir / llvm √© inteiramente escrito em Go e usa o LLVM IR para interagir com a estrutura LLVM. <br><br>  Este artigo se concentra no llir / llvm, mas pode ser generalizado para trabalhar com outras bibliotecas. <br><br><h4>  Por que escrever uma nova biblioteca? </h4><br>  A principal motiva√ß√£o para o desenvolvimento de uma biblioteca Go limpa para interagir com o LLVM IR foi tornar os compiladores de escrita e as ferramentas de an√°lise est√°tica, baseados na estrutura de compila√ß√£o do LLVM IR, uma tarefa mais divertida.  Tamb√©m foi influenciado pelo fato de que o tempo de compila√ß√£o de um projeto baseado em liga√ß√µes oficiais do LLVM com o Go pode ser significativo (gra√ßas a @aykevl, o autor do TinyGo, agora √© poss√≠vel acelerar a compila√ß√£o devido √† vincula√ß√£o din√¢mica, em oposi√ß√£o √† vers√£o padr√£o do LLVM 4). <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text">  O projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/aykevl/go-llvm</a> fornece binders Go para o LLVM instalado no sistema. <br></div></div><br>  Outra grande motiva√ß√£o foi tentar desenvolver a API Go a partir do zero.  A principal diferen√ßa entre as APIs de liga√ß√£o do LLVM para Go e llir / llvm √© como os valores do LLVM s√£o modelados.  Nos ligantes LLVM para Go, os valores LLVM s√£o modelados como um tipo estrutural concreto, que, em ess√™ncia, cont√©m todos os m√©todos poss√≠veis para todos os valores LLVM poss√≠veis.  Minha experi√™ncia pessoal usando essa API sugere que √© dif√≠cil saber qual subconjunto de m√©todos pode chamar um determinado valor.  Por exemplo, para obter um opcode de instru√ß√£o, chame o m√©todo InstructionOpcode, que √© intuitivo.  No entanto, se voc√™ chamar o m√©todo Opcode, que √© projetado para obter o c√≥digo de opera√ß√£o de uma express√£o constante, voc√™ receber√° um erro de tempo de execu√ß√£o: ‚Äúargumento cast () de tipo incompat√≠vel!‚Äù  (convers√£o de argumento para tipo incompat√≠vel). <br><br>  A biblioteca llir / llvm foi projetada para verificar os tipos em tempo de compila√ß√£o e garantir que eles sejam usados ‚Äã‚Äãcorretamente com o sistema de tipos Go.  Os valores LLVM em llir / llvm s√£o modelados como tipos de interface.  Essa abordagem disponibiliza apenas um conjunto m√≠nimo de m√©todos, compartilhado por todos os valores e, se voc√™ deseja acessar m√©todos ou campos espec√≠ficos, use a altern√¢ncia de tipos (conforme mostrado no exemplo abaixo). <br><br><h4>  Exemplo de uso </h4><br>  Agora, vamos ver alguns exemplos de usos espec√≠ficos.  vamos ter uma biblioteca, mas o que devemos fazer com o RLVM RI? <br><br>  Primeiro, podemos analisar o IR LLVM gerado por outra ferramenta, como Clang e o otimizador LLVM opt (consulte a amostra de entrada abaixo). <br><br>  Em segundo lugar, podemos querer processar o IR LLVM e executar nossa pr√≥pria an√°lise, fazer nossas pr√≥prias otimiza√ß√µes, implementar um int√©rprete ou um compilador JIT (veja o exemplo de an√°lise abaixo). <br><br>  Em terceiro lugar, podemos querer gerar um IR LLVM, que ser√° uma entrada para outros instrumentos.  Essa abordagem pode ser escolhida se estivermos desenvolvendo um frontend para uma nova linguagem de programa√ß√£o (veja o c√≥digo de sa√≠da de exemplo abaixo). <br><br>  C√≥digo de entrada de amostra - an√°lise LLVM IR <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       LLVM IR,    //     package main import ( "fmt" "github.com/llir/llvm/asm" ) func main() { //    LLVM IR. m, err := asm.ParseFile("foo.ll") if err != nil { panic(err) } // ,    LLVM IR. // Print LLVM IR module. fmt.Println(m) }</span></span></code> </pre> <br>  Exemplo de an√°lise - Processando LLVM IR <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      LLVM IR     //  Graphviz DOT package main import ( "bytes" "fmt" "io/ioutil" "github.com/llir/llvm/asm" "github.com/llir/llvm/ir" ) func main() { //    LLVM IR. m, err := asm.ParseFile("foo.ll") if err != nil { panic(err) } //    . callgraph := genCallgraph(m) //      Graphviz DOT. if err := ioutil.WriteFile("callgraph.dot", callgraph, 0644); err != nil { panic(err) } } // genCallgraph      Graphviz DOT    LLVM IR func genCallgraph(m *ir.Module) []byte { buf := &amp;bytes.Buffer{} buf.WriteString("digraph {\n") //      for _, f := range m.Funcs { //   caller := f.Ident() fmt.Fprintf(buf, "\t%q\n", caller) //       for _, block := range f.Blocks { //   ,       . for _, inst := range block.Insts { //  .   call. switch inst := inst.(type) { case *ir.InstCall: callee := inst.Callee.Ident() //        . fmt.Fprintf(buf, "\t%q -&gt; %q\n", caller, callee) } } //     switch term := block.Term.(type) { case *ir.TermRet: //  - _ = term } } } buf.WriteString("}") return buf.Bytes() }</span></span></code> </pre> <br>  C√≥digo de Sa√≠da de Amostra - Gera√ß√£o LLVM IR <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     LLVM IR,    C, //    . // // int abs(int x); // // int seed = 0; // // // ref: https://en.wikipedia.org/wiki/Linear_congruential_generator // // a = 0x15A4E35 // // c = 1 // int rand(void) { // seed = seed*0x15A4E35 + 1; // return abs(seed); // } package main import ( "fmt" "github.com/llir/llvm/ir" "github.com/llir/llvm/ir/constant" "github.com/llir/llvm/ir/types" ) func main() { //      i32 := types.I32 zero := constant.NewInt(i32, 0) a := constant.NewInt(i32, 0x15A4E35) //  PRNG. c := constant.NewInt(i32, 1) //  PRNG. //    LLVM IR. m := ir.NewModule() //         . // // int abs(int x); abs := m.NewFunc("abs", i32, ir.NewParam("x", i32)) //         . // // int seed = 0; seed := m.NewGlobalDef("seed", zero) //        . // // int rand(void) { ... } rand := m.NewFunc("rand", i32) //           `rand`. entry := rand.NewBlock("") //         . tmp1 := entry.NewLoad(seed) tmp2 := entry.NewMul(tmp1, a) tmp3 := entry.NewAdd(tmp2, c) entry.NewStore(tmp3, seed) tmp4 := entry.NewCall(abs, tmp3) entry.NewRet(tmp4) //   LLVM IR  . fmt.Println(m) }</span></span></code> </pre> <br><h3>  Conclus√£o </h3><br>  O desenvolvimento e a implementa√ß√£o do llir / llvm foram realizados e liderados por uma comunidade de colaboradores que n√£o apenas escreveram c√≥digo, mas tamb√©m lideraram discuss√µes, sess√µes de programa√ß√£o emparelhadas, depuraram, criaram perfis e mostraram curiosidade no processo de aprendizagem. <br><br>  Uma das partes mais dif√≠ceis do projeto llir / llvm foi a constru√ß√£o de uma gram√°tica EBNF para LLVM IR, cobrindo toda a linguagem IR LLVM at√© a vers√£o LLVM 7.0.  A dificuldade aqui n√£o est√° no processo em si, mas no fato de que n√£o h√° gram√°tica publicada oficialmente cobrindo todo o idioma.  Algumas comunidades de c√≥digo aberto tentaram definir uma gram√°tica formal para o assembler do LLVM, mas elas abrangem, at√© onde sabemos, apenas subconjuntos do idioma. <br><br>  A gram√°tica LLVM IR abre caminho para projetos interessantes.  Por exemplo, a gera√ß√£o de assembler LLVM IR sintaticamente v√°lido pode ser usada para v√°rias ferramentas e bibliotecas usando o LLVM IR, uma abordagem semelhante √© usada no GoSmith.  Isso pode ser usado para valida√ß√£o cruzada de projetos LLVM implementados em outros idiomas, bem como para verificar vulnerabilidades e bugs de implementa√ß√£o. <br><br>  O futuro √© maravilhoso, hackers felizes! <br><br><h3>  Refer√™ncias </h3><br>  1. Um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cap√≠tulo</a> muito bem escrito sobre LLVM, escrito por Chris Lattner, autor do projeto inicial do LLVM, no livro "Arquitetura de aplicativos de c√≥digo aberto". <br><br>  2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O tutorial Implementar uma linguagem com LLVM</a> - geralmente tamb√©m chamado de Guia de Linguagem Kaleidoscope - descreve em detalhes como implementar uma linguagem de programa√ß√£o simples compilada no LLVM IR.  O artigo descreve todos os principais est√°gios da cria√ß√£o de um front-end, incluindo um analisador lexical, um analisador e gera√ß√£o de c√≥digo. <br><br>  3. Para quem estiver interessado em escrever um compilador da linguagem de entrada no LLVM IR, √© recomendado o livro " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeando Constru√ß√µes de Alto N√≠vel para o LLVM IR</a> ". <br><br>  Um bom conjunto de slides √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LLVM, em Grande Detalhe</a> , que descreve os conceitos importantes do LLVM IR, fornece uma introdu√ß√£o √† API do LLVM C ++ e descreve algumas passagens de otimiza√ß√£o do LLVM muito √∫teis. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">As liga√ß√µes oficiais do Go para LLVM</a> s√£o adequadas para muitos projetos, elas representam a API C do LLVM, poderosa e est√°vel. <br><br>  Uma boa adi√ß√£o ao post √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma introdu√ß√£o ao LLVM no Go.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459704/">https://habr.com/ru/post/pt459704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459688/index.html">Urbanismo na China: menos descolados, mais ci√™ncia e TI</a></li>
<li><a href="../pt459692/index.html">Como descobrimos modifica√ß√µes de materiais que contradizem os princ√≠pios qu√≠micos estabelecidos</a></li>
<li><a href="../pt459694/index.html">Museum DataArt. Descompacte e inicie o Radio 86RK</a></li>
<li><a href="../pt459696/index.html">Restaura√ß√£o de fotos com base em IA</a></li>
<li><a href="../pt459698/index.html">Como for√ßar o Oracle BI 12c a criar quantas vari√°veis ‚Äã‚Äãde sess√£o o programador precisa?</a></li>
<li><a href="../pt459706/index.html">5 raz√µes pelas quais voc√™ deve esquecer o Redux nos aplicativos React</a></li>
<li><a href="../pt459708/index.html">Design de Interface do Jogo. Brent Fox Sobre o que √© o livro?</a></li>
<li><a href="../pt459710/index.html">Sobreviva a uma colis√£o frontal e por que a amn√©sia n√£o √© o que voc√™ pensa</a></li>
<li><a href="../pt459712/index.html">Mommy Hackers em um trabalho oficial: O que os Pentesters fazem</a></li>
<li><a href="../pt459714/index.html">M√°quina virtual no ESP8266 para executar jogos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>