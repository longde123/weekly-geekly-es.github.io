<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍⚖️ 🖕🏾 🥛 Gestenverwaltung: Umgang mit visuellen Overlays. Teil 2 🧜🏿 👲🏻 🐅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In Erwartung des Beginns eines Fortgeschrittenenkurses in Android-Entwicklung werden wir Ihnen weiterhin eine Reihe nützlicher Übersetzungen zur Verfü...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gestenverwaltung: Umgang mit visuellen Overlays. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/480778/">  <i>In Erwartung des Beginns eines <a href="https://otus.pw/Fyj5/">Fortgeschrittenenkurses in Android-Entwicklung werden wir</a> Ihnen weiterhin eine Reihe nützlicher Übersetzungen zur Verfügung stellen.</i> <br><br><img src="https://habrastorage.org/webt/wz/36/ho/wz36hosdk7_ecw_qv5lcjuhnwng.png"><br><hr><br><br>  Sie lesen den zweiten Artikel in einer Reihe zum Gestenmanagement.  Den ersten Teil finden Sie <a href="https://habr.com/ru/company/otus/blog/479948/">hier</a> . <br><br>  Im ersten Teil der Serie haben wir gelernt, wie Sie Ihre Anwendung „von Rand zu Rand“ auf dem Bildschirm positionieren.  Leider kann diese Art der Anzeige dazu führen, dass sich einige Ihrer Ansichten über die Grenzen des Bereichs der Systemanzeigen hinaus befinden und somit für den Benutzer nicht sichtbar sind.  In diesem Artikel erfahren Sie, wie Sie eine <code>view</code> so hinzufügen, dass der Betrieb der Systemanzeigen nicht gestört wird. <br><br>  In diesem Artikel werde ich auf so etwas wie ein "UI-System" verweisen.  Dies ist der Name einer beliebigen Systemschnittstelle auf dem Bildschirm, unabhängig davon, ob es sich um eine Navigationsleiste oder eine Statusleiste handelt.  Es enthält auch eine Benachrichtigungsleiste. <a name="habracut"></a><br><br><h3>  Einsätze </h3><br>  Der Begriff <i>Insets bereitet</i> Android-Entwicklern in der Regel Angst, da zu Zeiten von Android Lollipop immer versucht wurde, den Arbeitsbereich der Statusleiste zu nutzen.  Diese alte Frage zu <i><a href="https://stackoverflow.com/questions/26440879/how-do-i-use-drawerlayout-to-display-over-the-actionbar-toolbar-and-under-the-st">StackOverflow</a></i> hat beispielsweise eine sehr große Anzahl von Ansichten. <br><br>  <i>Einschübe</i> zeigen, welche Komponenten des Bildschirms mit der Systemschnittstelle kreuzen, z. B. eine Navigationsleiste oder eine Statusleiste.  Schnittmenge kann einfach bedeuten, dass Sie über Ihren Inhalten angezeigt werden. Hier können Sie jedoch auch Informationen zu Systemgesten abrufen.  Mit dem Einschub können Sie versuchen, Konflikte zu lösen, indem Sie beispielsweise die <code>view</code> von den Rändern weg verschieben. <br><br>  In Android <i>werden</i> <a href="https://developer.android.com/reference/android/view/WindowInsets.html">Einfügungen</a> durch die <a href="https://developer.android.com/reference/android/view/WindowInsets.html">WindowInsets-</a> Klasse und in AndroidX durch die <a href="https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.html">WindowInsetsCompat-</a> Klasse dargestellt.  Beginnend mit Android Q haben wir 5 Arten von <i>Einfügungen</i> , die wir beim Erstellen von Anwendungsbildschirmen verwenden können.  Welche Art von <code>inset</code> verwenden ist, hängt von der jeweiligen Situation ab. Schauen wir uns also jeden Typ einzeln an und sehen Sie. <br><br><h4>  Systemfenstereinsatz </h4><br>  <b>Methode</b> : <a href="https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.html">getSystemWindowInsets ()</a> <br><br>  <i>Der Systemfenstereinsatz</i> ist heute der gebräuchlichste <code>inset</code> .  Sie sind in API 1 in verschiedenen Formen vorhanden und werden in der <code>view</code> angezeigt, wenn die Systembenutzeroberfläche über Ihrer Anwendung (entlang der z-Achse) angezeigt wird.  Häufige Beispiele sind die Statusleiste und die Navigationsleiste sowie manchmal die Bildschirmtastatur (IME). <br><br>  Schauen wir uns ein Beispiel an, in dem Sie <i>Systemfenster-Einfügungen verwenden müssen</i> .  Wir haben bereits einen <a href="https://developer.android.com/reference/com/google/android/material/floatingactionbutton/FloatingActionButton.html">FloatingActionButton (FAB)</a> in der unteren Ecke des Bildschirms mit einem Einzug von <i>16 dpi</i> (gemäß den <a href="https://material.io/design/components/buttons-floating-action-button.html">Richtlinien</a> ). <br><br><img src="https://habrastorage.org/webt/kz/dv/jq/kzdvjqprbl9toq9fnprb640fu78.png"><br>  <i>FAB in einer Google I / O-App, bevor es in Edge-to-Edge konvertiert wird</i> <br><br>  Nachdem wir die Schritte 1 und 2 des <a href="https://habr.com/ru/company/otus/blog/479948/">vorherigen Artikels ausgeführt haben</a> , befinden sich unsere <code>view</code> hinter der Navigationsleiste: <br><br><img src="https://habrastorage.org/webt/7b/uo/e5/7buoe52fpht0hevkaacy1lu6hr8.png"><br>  <i>FAB in der Google I / O-App nach dem Strecken auf Vollbild</i> <br><br>  Jetzt sehen Sie, dass sich Ihr Konferenzplan hinter der Navigationsleiste befindet, und genau das ist unser Ziel - ein noch intensiveres Erlebnis.  Ausführlichere Informationen zum Arbeiten mit Listen / Gittern erhalten Sie später. <br><br>  Kehren wir zum Beispiel zurück.  Jetzt sehen Sie, dass das FAB ausgeblendet ist, was wiederum bedeutet, dass der Benutzer nicht darauf klicken kann.  Diesen Darstellungskonflikt wollen wir vermeiden.  Das Beispiel sieht bei Verwendung der Tastennavigation (wie im Bild) klarer aus, da sich das Bedienfeld höher befindet.  Bei der Gesten-Navigation mit dynamischer Farbanpassung funktioniert dies. Beachten Sie jedoch, dass das System jederzeit auf ein durchscheinendes <i>Scrim</i> umschalten kann, was die Interaktionserfahrung stören kann. <br><blockquote>  Jetzt ist ein guter Moment, um Ihnen mitzuteilen, wie wichtig es ist, Ihre Anwendung in allen Navigationsmodi zu testen. </blockquote><br>  Wie gehen wir mit diesem visuellen Konflikt um?  An diesem Punkt kommen <i>Systemfenstereinsätze</i> ins Spiel.  Dort erfahren Sie, wo sich die Systemanzeigen in Ihrer <i>Ansichtshierarchie</i> befinden. Mit diesen Werten können Sie die <i>Ansicht</i> weiter von den Systemanzeigen entfernen. <br><br>  Im obigen Beispiel befindet sich das FAB rechts unten, sodass wir die Werte von <code>systemWindowInsets.bottom</code> und <code>systemWindowInsets.right</code> , um den Einzug der <code>view</code> auf jeder Seite zu vergrößern und sie weiter von der Navigationsleiste zu entfernen. <br><br>  Sobald wir dies tun, erhalten wir Folgendes: <br><br><img src="https://habrastorage.org/webt/wb/-6/fi/wb-6fi3lg82h8kty_pcxjs-ralc.png"><br>  <i>Wir werden später darüber sprechen, wie dies implementiert wird.</i> <br><br>  TL  DR: <i>Systemfenster-Einschübe eignen sich</i> am besten zum Verschieben / Einrücken interaktiver <code>views</code> , die nicht von Systemfenstern verdeckt werden sollten. <br><br><h4>  Abgreifbare Elementeinsätze </h4><br>  <b>Methode</b> : <a href="https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.html">getTappableElementInsets ()</a> <br><br>  Weiter unten in der Liste finden Sie <i>tippbare Elementeinfügungen</i> , die gerade in Android Q <i>angezeigt wurden</i> . Sie sind den obigen <i>Einfügungen</i> im <i>Systemfenster</i> sehr ähnlich, reagieren jedoch auf die unterschiedliche Sichtbarkeit der Navigationsleiste. <br><br>  TL; DR: wie bei <code>tappable element insets</code> : Sie können sie im Allgemeinen ignorieren und <code>system window insets</code> .  Sie können zum <i>Abschnitt</i> mit den <i>Gesteneinsätzen weiter</i> unten <i>springen</i> oder mit dem Lesen fortfahren. <br><br>  <i>Abgriffbare Element-Insets</i> definieren die minimalen <i>Insets</i> , die in einer interaktiven (abgriffbaren) Ansicht angewendet werden müssen.  "Minimal" bedeutet in diesem Fall, dass der angewendete Wert immer noch zu einem Konflikt mit den Systemanzeigen führen kann.  Dies unterscheidet sie von <i>Systemfenster-Einfügungen</i> , die immer darauf abzielen, Konflikte mit Systemanzeigen zu vermeiden. <br><br>  Lassen Sie uns unser Beispiel mit einem <i>FloatingActionButton verwenden</i> , um den Unterschied in den Werten zu zeigen: <br><br><img src="https://habrastorage.org/webt/rw/ok/fh/rwokfh5ofi64r0jwwbv7hd3en90.png"><br>  <i>Die Ränder der Navigationsleiste werden in Pink angezeigt.</i>  <i>Grün - FAB-Ränder mit einem bestimmten Einzug am unteren Rand.</i> <br><br><img src="https://habrastorage.org/webt/z5/vx/tx/z5vxtxygddrxxu6k10tvlnzdkne.png"><br><br>  Denken Sie daran, dass Sie niemals Werte aus der obigen Tabelle fest codieren können, da die Größe der Navigationsleiste geändert werden kann.  Verwenden Sie <i>Einfügungen,</i> um Konflikte <i>zu</i> vermeiden. <br><br>  Möglicherweise haben wir festgestellt, dass sich <code>tappable element insets</code> und <code>system gesture insets</code> verhalten, wenn sich das Gerät im Schaltflächennavigationsmodus befindet.  Ein wesentlicher Unterschied wird sichtbar, wenn das Gerät die Gestensteuerung verwendet und die dynamische Farbanpassung aktiviert ist.  In diesem Fall ist die Navigationsleiste transparent, was bedeutet, dass es theoretisch möglich ist, interaktive <code>views</code> darin anzuordnen, sodass der Einzug von unten 0 ist. <br><br>  Obwohl <code>insets</code> keine Ahnung haben, wo sich Ansichten befinden sollen, können Sie mit <i>tappbaren Element-Insets</i> theoretisch etwas Ähnliches erhalten: <br><br><img src="https://habrastorage.org/webt/oj/h9/62/ojh962kej2pja7px0ofjlhuthqk.png"><br><br>  Es hat nicht perfekt geklappt, da sich die <code>view</code> sehr nahe an der Navigationsleiste befindet, was für den Benutzer nicht sehr praktisch ist. <br><br>  In der Praxis werden fast alle Anwendungsfälle für <i>tippbare Elementeinsätze</i> besser mit <i>Systemfenstereinsätzen</i> behandelt. <br><br><h4>  Gesteneinsätze </h4><br>  <b>Methoden</b> : <a href="https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.html">getSystemGestureInsets ()</a> und <a href="https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.html">getMandatorySystemGestureInsets ()</a> <br><br>  Die nächste Art von <code>insets</code> , die wir betrachten werden, sind <code>gesture insets</code> , die in der Version von Android Q hinzugefügt wurden. Ich erinnere mich, dass Android Q einen neuen Gestensteuerungsmodus einführt, mit dem der Benutzer das Gerät mit zwei Berührungsgesten steuern kann, die wie folgt ausgeführt werden können: <br><br><ol><li>  Wischen Sie horizontal von einem der Ränder der Anzeige.  Dies löst die Rückgabeaktion aus. </li><li>  Wischen Sie vom unteren Rand des Displays nach oben.  Auf diese Weise kann der Benutzer zu seinem Startbildschirm oder zu den zuletzt verwendeten Anwendungen wechseln. </li></ol><br><img src="https://habrastorage.org/webt/j_/qb/0i/j_qb0illtic47y4wir_fhns1-q0.gif"><br>  <i>Gesten-Demonstration in Android Q</i> <br><br>  <i>Eingefügte Systemgesten geben</i> Bereiche des Fensters wieder, in denen Systemgesten Vorrang vor Berührungsgesten in Ihrer Anwendung haben.  Möglicherweise haben Sie bemerkt, dass ich oben zwei Methoden angegeben habe.  Dies liegt an der Tatsache, dass es tatsächlich zwei Arten von <i>Systemgesteneinfügungen gibt</i> : Eine speichert alle Bereiche von Gesten und die zweite eine Teilmenge, die die obligatorischen <i>Systemgesteneinfügungen</i> enthält. <br><br><h4>  Systemgesten-Einfügungen </h4><br>  Für den Anfang haben wir <i>Systemgesten-Einfügungen</i> .  Sie enthalten alle Bereiche auf dem Bildschirm, in denen Systemgesten Vorrang vor den Gesten Ihrer Anwendung haben.  In Android Q bedeutet dies, dass <i>Einschübe wie</i> folgt aussehen, <i>dh</i> Einrückungen vom unteren Rand enthalten, damit eine Geste zum Startbildschirm zurückkehrt, Einrückungen links und rechts für eine Zurück-Geste: <br><br><pre> <code class="kotlin hljs"> <span class="hljs-number"><span class="hljs-number">0</span></span> +--------------+ | | | System | <span class="hljs-number"><span class="hljs-number">40</span></span> | Gesture | <span class="hljs-number"><span class="hljs-number">40</span></span> | Insets | | | +--------------+ <span class="hljs-number"><span class="hljs-number">60</span></span></code> </pre><br>  Wann werden sich <i>Systemgesten als</i> nützlich erweisen?  Diese <code>insets</code> geben an, wo Systemgesten Vorrang haben. Sie können sie also verwenden, um Ansichten, die eine Wischgeste erfordern, proaktiv zu verschieben. <br><br>  Beispiele sind ein <a href="https://material.io/design/components/sheets-bottom.html">Bildschirm</a> , der <a href="https://material.io/design/components/sheets-bottom.html">sich von unten erstreckt</a> , Wischbewegungen in Spielen und Karussells (wie <a href="https://developer.android.com/reference/androidx/viewpager2/widget/ViewPager2.html">ViewPager</a> ).  Im Allgemeinen können Sie diese <code>insets</code> , um sich von den Bildschirmrändern aus zu bewegen bzw. einzurücken. <br><br><h4>  Obligatorische Systemgesteneinfügungen </h4><br>  Obligatorische <i>Systemgesteneinfügungen</i> sind eine Teilmenge der <i>Systemgesteneinfügungen</i> und enthalten nur Bereiche, die nicht aus der Anwendung entfernt werden können (z. B. den Namen).  Wir haben im Thema des nächsten Artikels ein wenig nach vorne geschaut, in dem wir uns mit dem Umgang mit Gesten-Konflikten befassen. Um den aktuellen Artikel zu verstehen, müssen Sie jedoch wissen, dass Anwendungen System-Gesten aus einigen Bereichen des Bildschirms entfernen können. <br><br>  Obligatorische <i>Systemgesteneinfügungen kennzeichnen</i> Bereiche des Bildschirms, in denen Systemgesten immer Vorrang haben und obligatorisch sind.  Unter Android Q ist der einzige obligatorische Bereich im Moment der Gestenbereich des Startbildschirms am unteren Bildschirmrand.  Dies ist erforderlich, damit der Benutzer die Anwendung immer beenden kann. <br>  Wenn Sie sich das Beispiel von <i>Gesteneinsätzen</i> auf einem Android Q-Gerät ansehen, sehen Sie Folgendes: <br><br><pre> <code class="kotlin hljs"> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> +--------------+ +--------------+ | | | Mandatory | | System | | System | <span class="hljs-number"><span class="hljs-number">40</span></span> | Gesture | <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> | Gesture | <span class="hljs-number"><span class="hljs-number">0</span></span> | Insets | | Insets | | | | | +--------------+ +--------------+ <span class="hljs-number"><span class="hljs-number">60</span></span> <span class="hljs-number"><span class="hljs-number">60</span></span></code> </pre> <br>  Es ist zu sehen, dass die <i>Systemgesteneinfügungen</i> Einrückungen links, rechts und unten enthalten, während die erforderlichen Einrückungen nur Einrückungen von unten enthalten, sodass die Rückkehrgeste zum Startbildschirm normal funktioniert.  Weitere Informationen zum Löschen von Gestenbereichen finden Sie im nächsten Artikel. <br><br><h4>  Stabile Einsätze </h4><br>  <b>Methode</b> : <a href="https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.html">getStableInsets ()</a> <br><br>  <i>Stabile Einfügungen</i> sind die letzten Arten von <i>Einfügungen,</i> die auf Android verfügbar sind.  Sie sind nicht besonders wichtig für die Verwaltung von Gesten, aber ich entschied, dass es sich lohnt, darüber zu sprechen. <br><br>  <i>Stabile Einfügungen</i> beziehen sich auf <i>Systemfenstereinfügungen</i> , zeigen jedoch an, wo die Systemschnittstelle über Ihrer Anwendung angezeigt werden kann und nicht, wo sie im Prinzip angezeigt wird.  <i>Stabile Einschübe</i> werden hauptsächlich verwendet, wenn die Systemschnittstelle so konfiguriert ist, dass ihre Sichtbarkeit ein- oder ausgeschaltet werden kann, z. B. mithilfe von <a href="https://developer.android.com/training/system-ui/immersive">Lean-Back-</a> oder <a href="https://developer.android.com/training/system-ui/immersive">Immersive-</a> Modi (z. B. Spiele, Anzeigen von Fotos und Video-Playern). <br><br><h4>  Umgang mit Insets </h4><br>  Ich hoffe, Sie haben ein besseres Verständnis für die verschiedenen Arten von <i>Einfügungen.</i> Lassen Sie uns nun sehen, wie Sie sie in Ihren Anwendungen verwenden können. <br><br>  Die Hauptmethode für den Zugriff auf <i>WindowInsets</i> ist die Methode <a href="https://developer.android.com/reference/androidx/core/view/ViewCompat.html">setOnApplyWindowInsetsListener</a> .  Schauen wir uns eine Beispielansicht an, in die wir einrücken möchten, damit sie nicht hinter der Navigationsleiste angezeigt wird: <br><br><pre> <code class="kotlin hljs">ViewCompat.setOnApplyWindowInsetsListener(view) { v, insets -&gt; v.updatePadding(bottom = insets.systemWindowInsets.bottom) <span class="hljs-comment"><span class="hljs-comment">// Return the insets so that they keep going down the view hierarchy insets }</span></span></code> </pre> <br>  Hier setzen wir einfach den unteren Einzug der <code>view</code> auf den unteren Einzugswert des <i>Systemfensters</i> . <br><br><blockquote>  <i>Hinweis</i> : Wenn Sie dies in einer <a href="https://developer.android.com/reference/android/view/ViewGroup.html">ViewGroup tun</a> , möchten Sie wahrscheinlich <code>android:clipToPadding="false"</code> .  Dies liegt daran, dass standardmäßig alle Arten von <i>Clip-Zeichnungen eingerückt sind</i> .  Dieses Attribut wird häufig in Verbindung mit <a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.html">RecyclerView verwendet</a> , auf das im nächsten Artikel näher <a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.html">eingegangen</a> wird. <br></blockquote><br>  Stellen Sie sicher, dass Ihre Hörfunktion nicht zu stark ist.  Wenn es mehrmals mit denselben Einschüben aufgerufen wird, sollte das Ergebnis jedes Mal identisch sein.  Ein Beispiel für eine nicht idempotente Funktion ist unten angegeben: <br><br><pre> <code class="kotlin hljs">ViewCompat.setOnApplyWindowInsetsListener(view) { v, insets -&gt; v.updatePadding(bottom = v.paddingBottom + insets.systemWindowInsets.bottom) insets }</code> </pre> <br>  Bei jedem Aufruf der Listen-Funktion sollte der Einzug der Ansicht nicht größer sein (ala + =).  Fenstereinsätze können jederzeit und mehrmals während der Gültigkeitsdauer der <i>Ansichtshierarchie auftreten</i> . <br><br><h4>  Jetpack </h4><br>  Eine andere Sache, die ich <i>zu</i> beachten empfehle <i>,</i> ist die Verwendung der <a href="https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.html">WindowInsetsCompat-</a> Klasse von <a href="https://developer.android.com/jetpack">Jetpack</a> , unabhängig von Ihrer minimalen SDK-Version.  Die WindowInsets-API wurde im Laufe der Jahre verbessert und erweitert. Die kompatible Version bietet API-Konsistenz und -Verhalten auf allen API-Ebenen. <br><br>  Wenn die in Android Q verfügbaren neuen Arten von <i>Insets betroffen sind</i> , handelt es sich bei der <i>Kompatibilitätsmethode</i> um eine Reihe von Werten, die für das <i>Hostgerät</i> auf allen API-Ebenen gültig sind.  Um auf die neuen APIs in <a href="https://developer.android.com/jetpack/androidx">Android X</a> zuzugreifen <a href="https://developer.android.com/jetpack/androidx">,</a> aktualisieren Sie sie auf <code>androidx.core:core:1.2.0-xxx</code> (jetzt in Alpha) oder höher.  <a href="https://developer.android.com/jetpack/androidx/releases/core">Hier</a> finden Sie die neueste Version. <br><br><h4>  Gehen wir noch weiter </h4><br>  Die oben genannten Methoden sind die einfachste Möglichkeit, die WindowInsets [Compat] -API zu verwenden, können jedoch dazu führen, dass Ihr Code zu lang und zu lang wird.  Zuvor schrieb ich einen Artikel, in dem ich ausführlich Methoden beschrieb, die die Ergonomie der Verarbeitung von Fenstereinsätzen mithilfe von Adapterbindern erheblich verbessern können.  Sie können es hier lesen. <br><br>  Im nächsten Artikel erfahren Sie, wie Sie mit Konflikten umgehen, die zwischen den Gesten Ihrer Anwendungen und den Systemgesten auftreten können. <br><br>  <i>Das ist alles.</i>  <i>Wir warten auf alle beim <a href="https://otus.pw/Fyj5/"><i>kostenlosen Webinar</i></a> , in dem unser Spezialist ausführlich über den <b><a href="https://otus.pw/Fyj5/">Kurs</a></b> spricht.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480778/">https://habr.com/ru/post/de480778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480760/index.html">Arbeiten im Ausland: In welchen Ländern ist das schnellste Internet?</a></li>
<li><a href="../de480762/index.html">V & V bedeutet nicht Vendetta</a></li>
<li><a href="../de480772/index.html">Einfache Gründe für die Unvermeidlichkeit der technischen Verschuldung</a></li>
<li><a href="../de480774/index.html">Nicht Nginx Unified: Ayhor Hosting - Dash-Scratch Live</a></li>
<li><a href="../de480776/index.html">Wir stellen Active Directory mit allen möglichen Methoden bereit.</a></li>
<li><a href="../de480780/index.html">Wie man eine Illustration aus Würfeln und Piktogrammen zusammensetzt</a></li>
<li><a href="../de480782/index.html">5 Dinge, die ich gerne wissen würde, als ich mit Angular anfing</a></li>
<li><a href="../de480786/index.html">Unabhängiges Klonen von Objekten in JavaScript</a></li>
<li><a href="../de480788/index.html">Weihnachtsbaum auf der Kommandozeile</a></li>
<li><a href="../de480790/index.html">"Werkseffizienz". Suche nach einem Engpass und Implementierung eines Pull-Systems zur Steigerung der Produktivität</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>