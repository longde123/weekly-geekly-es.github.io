<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¼â€ğŸ¤ â˜£ï¸ ğŸ‚ğŸ¿ RANS pengkodean entropi atau cara menulis pengarsipan Anda sendiri ğŸ‘¨ğŸ¾â€ğŸ’» ğŸ“ˆ ğŸ›ŒğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini mungkin menarik bagi mereka yang terlibat dalam kompresi data atau ingin menulis pengarsipan mereka sendiri. 

  

 Artikel ini ditulis te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RANS pengkodean entropi atau cara menulis pengarsipan Anda sendiri</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/441814/">  Artikel ini mungkin menarik bagi mereka yang terlibat dalam kompresi data atau ingin menulis pengarsipan mereka sendiri. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/jz/w8/xk/jzw8xkq1k6enudm8xozmna6m3ia.jpeg"></a> <br><br>  Artikel ini ditulis terutama pada bahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog</a> , yang dikelola oleh Fabian Giesen. <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Metode pengkodean entropi rANS ( <b>r</b> ange + ANS) adalah saudara kandung dari algoritma FSE, yang saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tulis sebelumnya</a> .  Singkatan ANS berarti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sistem Angka Asimetris</a> , dan rentang kata dalam namanya mengisyaratkan kesamaan metode ini dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengkodean interval</a> .  Penulis rans adalah <a href="">Yarek Duda</a> . <br><br>  Metode RANS memungkinkan Anda mencapai kompresi yang hampir optimal pada kecepatan yang sangat tinggi.  Dalam rANS ini tidak lebih buruk daripada FSE, yang tidak mengejutkan: kedua algoritma didasarkan pada landasan teori umum.  Namun, algoritma rANS jauh lebih mudah diimplementasikan daripada FSE. <br><br>  Pertama, akan ada bagian "teoretis" yang panjang, dan kemudian kita akan mencoba menulis pengarsipan sederhana. <br><br><h2>  Deskripsi Metode </h2><br>  Pengoperasian algoritma ditentukan oleh rumus sederhana berikut: <br><br>  <b>Pengkodean:</b> <code>C(s,x): x := (x / Fs) * M + Bs + (x % Fs)</code> <br>  <b>Decoding:</b> <code>D(x): s = sym[x % M], x := Fs * (x / M) + (x % M) - Bs</code> <br><br>  Mari kita analisa secara detail. <br><br>  Fungsi pengkodean <b>C (s, x)</b> menerima karakter <b>s</b> untuk dikodekan (biarkan bilangan bulat) dan keadaan saat ini dari enkoder <b>x</b> (juga bilangan bulat). <br><br>  <b>F <sub>s</sub></b> - frekuensi simbol <b>s</b> .  Pembagian oleh Fs di atas adalah bilangan bulat. <br>  <b>M</b> adalah jumlah frekuensi semua simbol alfabet ( <b>M =</b> Î£ <b>F <sub>s</sub></b> ). <br>  <b>Dalam <sub>s</sub></b> , awal interval sesuai dengan karakter yang dikodekan (pada gambar di bawah). <br>  <b>x</b> % <b>Fs</b> adalah sisa dari pembagian <b>x</b> oleh <b>F <sub>s</sub></b> . <br><br>  Prinsip operasi adalah sama seperti dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengkodean aritmatika</a> : kita mengambil segmen <b>[</b> 0, <b>M)</b> dan membaginya menjadi bagian-bagian sehingga setiap karakter sesuai dengan interval yang sama ukurannya dengan frekuensi karakter <b>Fs</b> .  Terjadinya nilai <b>x% M</b> dalam interval apa pun menunjukkan pengkodean simbol yang sesuai. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6i/vl/ql/6ivlqldcqlkeuwsxu6fcypus39o.png"></div><br>  Di awal pengkodean, inisialisasi <b>x dengan</b> nilai yang sesuai sewenang-wenang, dan kemudian hitung fungsi <b>C (s, x)</b> untuk semua karakter yang disandikan secara berurutan. <br><br>  Setiap perhitungan fungsi <b>C (s, x)</b> meningkatkan nilai <b>x</b> .  Ketika terlalu besar, Anda harus membuang data dalam output: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x &gt;= x_max) {   writeToStream(x % b); <span class="hljs-comment"><span class="hljs-comment">//     x /= b; //  x }</span></span></code> </pre> <br>  Langkah ini disebut <i>renormalisasi</i> .  Setelah itu, Anda dapat melanjutkan pengkodean. <br><br>  Di atas kode, konstanta baru muncul: <b>x_max</b> dan <b>b</b> .  Secara teori, angka <b>M</b> , <b>b,</b> dan <b>x_max</b> terkait oleh beberapa hubungan, tetapi dalam praktiknya paling efektif untuk menggunakan nilai berikut jika negara uint32 digunakan untuk negara <code>x</code> : <br><br>  <b>M</b> = 2 ^ <b>k</b> , di mana <b>k</b> &lt;= 16 <br>  <b>b</b> = 2 ^ 16 (setengah ukuran uint32) <br><br>  Pilihan <b>M</b> = 2 ^ <b>k</b> disebabkan oleh fakta bahwa ada pembagian oleh <b>M</b> dalam fungsi dekode, sehingga pembagian dengan sisanya dapat diganti dengan operasi bitwise. <br><br>  Nilai <b>k</b> dipilih dari pertimbangan berikut: semakin besar, semakin tinggi akurasi <b>Fs</b> dan semakin efisien kompresi.  Dalam hal ini, beberapa overhead untuk menyimpan tabel frekuensi harus diperhitungkan, sehingga tidak selalu layak menggunakan nilai maksimum <b>k</b> . <br><br>  Nilai <b>x_max</b> harus sedemikian rupa sehingga tidak terjadi overflow.  Berdasarkan fungsi enkode, kita mendapatkan <b>x</b> &lt; <b>uint32_max</b> * <b>Fs</b> / <b>M</b> atau cara yang sedikit berbeda: <b>x_max</b> &lt;= ( <b>b</b> * <b>L</b> ) * <b>Fs</b> / <b>M</b> , di mana <b>L</b> &lt;= <b>uint32_max</b> / <b>b</b> .  Dalam kode nyata, kondisi tersebut mengambil bentuk x / b&gt; = L / M * Fs untuk menghindari kelebihan dalam perhitungan. <br><br>  Nilai <b>b</b> = 2 ^ 16 (setengah ukuran uint32) dipilih sedemikian rupa sehingga jika <b>x</b> melebihi <b>x_max</b> , maka satu pembagian dengan <b>b</b> cukup untuk terus bekerja.  Akibatnya, <code>while</code> akan berakhir setelah iterasi pertama, yang berarti dapat diganti dengan <code>if</code> sederhana. <br><br>  Akibatnya, fungsi enkode mengambil bentuk berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> RansState; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> RANS_L = <span class="hljs-number"><span class="hljs-number">1u</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> k = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   constexpr uint32_t RANS_M = 1u &lt;&lt; k; // M = 2^k //   s void RansEnc(RansState&amp; x, uint32_t s, RansOutBuf&amp; out) {   assert(x &gt;= RANS_L); //        uint32 Fs = freq[s]; //   s   uint32 Bs = range_start[s]; //   s   assert(Fs &gt; 0 &amp;&amp; Fs &lt;= RANS_M);     // renormalize   if ((x &gt;&gt; 16) &gt;= (RANS_L &gt;&gt; k) * Fs) { // x / b &gt;=  L / M * Fs       out.put( x &amp; 0xffff );       x &gt;&gt;= 16;   }   x = ((x / Fs) &lt;&lt; k) + Bs + (x % Fs); // C(s,x)     assert(x &gt;= RANS_L); //      }</span></span></code> </pre> <br>  Di akhir pengkodean, Anda harus menyimpan nilai <b>x</b> , karena decoding akan dimulai dari itu.  Dan ya, kita akan memecahkan kode dari akhir ke awal, yaitu, dari karakter yang terakhir disandikan ke yang pertama.  (Artikel tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FSE</a> menjelaskan hal ini secara cukup rinci.) <br><br>  Saya ingin sedikit lebih memikirkan bagaimana rumus encoding bekerja. <br><br><pre> <code class="cpp hljs">x := (x / Fs) * M + Bs + (x % Fs)</code> </pre> <br>  Setelah komputasi ( <code>x / Fs) * M</code> , variabel <b>x</b> berisi <b>k</b> bit paling signifikan (ingat bahwa <b>M</b> = 2 ^ <b>k</b> ).  Menambahkan <code>+ Bs + (x % Fs)</code> pada dasarnya menulis ke bit-bit ini nilai tertentu dari <i>interval</i> karakter <b>s</b> , karena <b>Bs</b> adalah awal dari interval, dan (x% Fs) adalah angka dalam interval ini (ukuran intervalnya adalah Fs).  Jadi, ketika decoding, kita dapat menentukan karakter yang dikodekan oleh interval di mana ia jatuh (x% M). <br><br>  <b>Decoding</b> <br><br>  Mari kita beralih ke fungsi decoding. <br><br><pre> <code class="cpp hljs">D(x): s = sym[x % M], x := Fs * (x / M) + (x % M) - Bs</code> </pre> <br>  Seperti yang sudah kita pahami di atas, karakter yang diinginkan ditentukan oleh sisa divisi <b>x</b> % <b>M.</b>  Dalam interval berapa nilai (x% M) jatuh, karakter seperti itu dikodekan. <br><br>  Sebelumnya, kami secara khusus mendefinisikan M = 2 ^ k untuk menyederhanakan fungsi decoding.  Itu berakhir seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> RansDecode(RansState&amp; x, RansInBuf&amp; in) {   assert(x &gt;= RANS_L); <span class="hljs-comment"><span class="hljs-comment">//       uint32_t x_mod = x &amp; (RANS_M - 1); // = x % M   //  ,    x_mod,     assert(x_mod &lt; dct.size());   uint32_t s = dct[x_mod]; //     uint32 Fs = freq[s]; //   s   uint32 Bs = range_start[s]; //    s   x = (x &gt;&gt; k) * Fs + x_mod - Bs;     // renormalize   if (x &lt; RANS_L) {       x = (x &lt;&lt; 16) | in.read16(); //  16    }     assert(x &gt;= RANS_L); //     return s; }</span></span></code> </pre> <br>  Decoding dimulai dengan <b>x</b> yang sama yang diperoleh pada akhir pengkodean.  Untuk melakukan ini, itu harus disimpan bersama dengan data yang disandikan. <br><br>  Pada akhir decoding, keadaan decoder <b>x</b> harus persis sama dengan encoding.  Secara umum, pada setiap langkah <b>x</b> harus persis sama seperti pada langkah pengkodean yang sesuai.  Fakta ini sangat membantu ketika melakukan debugging. <br><br>  Seperti yang Anda lihat, decoding bekerja lebih cepat daripada encoding, karena tidak ada operasi pembagian. <br><br>  Momen paling sulit dalam fungsi decoding adalah metode penentuan interval yang nilainya turun (x% M). <br><br>  Metode termudah dan tercepat adalah dengan menggunakan tabel <b>sym []</b> , ukuran <b>M.</b>  Dalam hal ini, kita mendapatkan tabel dengan ukuran yang sama seperti pada algoritma FSE, dengan perbedaan bahwa dalam rANS tabel tidak â€œtercampurâ€, karakternya teratur, dan tabel seperti itu jauh lebih mudah untuk dibuat. <br><br>  Kelemahan utama dari pendekatan ini adalah ukuran tabel <b>sym</b> , yang tumbuh secara eksponensial dengan meningkatnya <b>k</b> . <br><br><h2>  Metode Alias </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metode alias</a> diciptakan untuk lebih efisien menentukan hit dalam suatu interval.  Metode ini memungkinkan Anda untuk dengan cepat menentukan interval yang diinginkan menggunakan tabel kecil - dengan jumlah karakter dalam alfabet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kv/v0/gu/kvv0guji6nfuxxr6mcjorxxsv9a.png"></div><br>  Penjelasan panjang dan panjang dapat ditemukan di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Darts, Dice and Coins</a> .  Saya akan menjelaskan esensi metode ini secara singkat: kami mengambil sepotong interval terpanjang dan melampirkannya pada interval terpendek sehingga ukuran totalnya persis <b>M</b> / <b>N</b> (di mana <b>N</b> adalah jumlah karakter dalam alfabet).  Ternyata jika Anda melakukan ini secara berurutan, Anda akan selalu berakhir dengan <b>N</b> pasang ukuran <b>M</b> / <b>N.</b> <br><br>  Secara alami, <b>M</b> harus dapat dibagi oleh <b>N.</b>  Dan jika kita ingat bahwa kita memiliki <b>M</b> = 2 ^ <b>k</b> , maka ukuran alfabet ternyata juga menjadi kekuatan dua.  Ini bukan masalah, karena Anda selalu dapat menambah alfabet ke ukuran yang diinginkan dengan karakter yang tidak digunakan dengan frekuensi nol. <br><br>  Fakta bahwa interval karakter dibagi menjadi beberapa bagian menyulitkan prosedur pengkodean sedikit, tetapi tidak banyak.  Jika Anda mengingat FSE, interval yang ada umumnya tersebar di seluruh rentang, seolah-olah mixer gila bekerja pada mereka, dan tidak ada yang berhasil =) <br><br>  Menentukan interval yang diinginkan tidak sulit: bagi <b>x</b> dengan <b>N</b> , dan jatuh ke dalam salah satu pasangan.  Selanjutnya, kami membandingkan sisa pembagian <b>x% N</b> dengan batas antara segmen dalam pasangan dan jatuh dalam satu interval atau dalam yang lain. <br><br><h2>  Kami mencoba dalam praktik </h2><br>  Kami akan menggunakan kode <a href="">contoh yang sudah jadi</a> . <br><br>  Kami mengambil data untuk kompresi dari file: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> in_size; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>* in_bytes = read_file(<span class="hljs-string"><span class="hljs-string">"book1"</span></span>, &amp;in_size);</code> </pre> <br>  <b>1.</b> Pertama, Anda perlu memutuskan <b>struktur data</b> . <br><br>  Kami menggunakan opsi paling sederhana: kami akan menyandikan satu byte menggunakan alfabet [0 ... 255]. <br><br>  <b>2.</b> Langkah selanjutnya adalah menentukan <b>frekuensi karakter</b> alfabet: <br><br>  (fungsi <code>stats.count_freqs</code> ) <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; in_size; i++) {   freqs[in_bytes[i]]++; }</code> </pre> <br>  <b>3.</b> Jadi, kita memiliki frekuensi simbol, tetapi sekarang mereka perlu <b>dinormalisasi</b> , yaitu dikurangi secara proporsional (atau meningkat) sehingga secara total kita mendapatkan M = 2 ^ k.  Sepertinya ini bukan tugas yang sederhana, jadi kami menggunakan fungsi yang sudah jadi: <br><br><pre> <code class="plaintext hljs">stats.normalize_freqs(...);</code> </pre> <br>  Omong-omong, Anda perlu menentukan nilai <b>k</b> .  Karena alfabet kami terdiri dari 256 karakter, <b>k</b> kurang dari 8 tidak boleh diambil.  Pertama, ambil maksimum - 16, dan kemudian coba nilai lainnya. <br><br>  <b>4.</b> Bangun <b>tabel alias</b> : <br><br><pre> <code class="cpp hljs">stats.make_alias_table();</code> </pre> <br>  <b>5. Kami</b> mengkodekan <b>dari akhir</b> , lalu mendekode dalam urutan normal. <br><br><pre> <code class="cpp hljs">RansState rans; <span class="hljs-comment"><span class="hljs-comment">//  rANS,    x RansEncInit(&amp;rans); //    uint8_t* ptr = out_buf + out_max_size; // *end* of output buffer for (size_t i = in_size; i &gt; 0; i--) { // NB: working in reverse!   int s = in_bytes[i - 1];   RansEncPutAlias(&amp;rans, &amp;ptr, &amp;stats, s, prob_bits); } //   .     . RansEncFlush(&amp;rans, &amp;ptr);</span></span></code> </pre> <br>  Selanjutnya, contoh dengan referensi menerjemahkan data terkompresi menggunakan statistik siap pakai.  Dalam kehidupan nyata, untuk decoding, Anda perlu menyimpan tabel frekuensi (statistik) bersama dengan data terkompresi.  Dalam kasus yang paling sederhana, Anda harus menghabiskan bit N * k untuk itu. <br><br>  Seperti yang dijanjikan di atas, mari kita lihat hasil kompresi untuk berbagai nilai k (dalam kode ini <code>prob_bits</code> ), dengan mempertimbangkan peningkatan ukuran karena pencatatan tabel frekuensi: <br><br>  ( <i>Ukuran</i> <i>file</i> book1 asli: 768771) <br>  k = 16: 435059 + 512 = 435571 byte <br>  k = <b>15</b> : 435078 + 480 = <b>435558</b> byte <br>  k = 14: 435113 + 448 = 435561 byte <br>  k = 13: 435239 + 416 = 435655 byte <br>  k = 12: 435603 + 384 = 435987 byte <br>  k = 11: 436530 + 352 = 436882 byte <br>  k = 10: 440895 + 320 = 441215 byte <br>  k = 9: 453418 + 288 = 453706 byte <br>  k = 8: 473126 + 256 = 473382 byte <br><br>  Anda dapat melihat bahwa semakin tinggi k, semakin baik kompresi.  Tetapi pada titik tertentu (pada k = 16), overhead dari tabel frekuensi mulai lebih besar daripada manfaat dari peningkatan akurasi.  Jika Anda mengompres file yang lebih kecil, efek ini akan muncul pada k yang lebih kecil. <br><br>  Anda juga perlu mengatakan beberapa kata tentang trik yang disebut "interleaved rans", yang juga diterapkan <a href="">dalam contoh ini</a> .  Idenya adalah bahwa secara bergantian menggunakan dua variabel keadaan bebas membuat penggunaan paralelisme prosesor lebih baik.  Akibatnya, decoding lebih cepat. <br><br>  Sebagai kesimpulan, saya ingin mencatat bahwa metode kompresi file yang dipilih terlalu sederhana.  Itu tidak mempertimbangkan fitur data, itulah sebabnya kompresi jauh dari optimal.  Jika Anda memperhatikan input dengan cermat, Anda dapat menemukan bahwa beberapa <i>kombinasi huruf</i> lebih umum daripada yang lain, dan beberapa tidak terjadi sama sekali.  Dengan menggunakan fakta ini, kompresi dapat ditingkatkan secara signifikan.  Tetapi ini adalah topik untuk artikel terpisah. <br><br><h2>  Kata penutup </h2><br>  Mengapa menulis arsip Anda sendiri ketika ada banyak utilitas yang teruji waktu?  Jawabannya cukup sederhana: pengarsip yang dirancang untuk kompres format tertentu jauh lebih baik. <br><br>  Saat mengembangkan game di <b>Playrix</b> , kita sering mengandalkan kebutuhan untuk mengurangi ukuran build.  Game terus berkembang, jumlah konten terus bertambah, dan ruang terbatas. <br><br>  Sekali lagi <s>,</s> melihat dengan <s>penuh</s> perhatian pada sumber daya, kami menyadari bahwa beberapa file dapat dikompresi jauh lebih baik daripada zip, mengingat strukturnya.  Selama percobaan, kami berhasil mengurangi ukuran format animasi kami secara signifikan, ada juga beberapa perubahan dalam kompresi file grafik. <br><br>  Saat mengembangkan algoritma kompresi, encoder entropi universal, seperti rANS atau FSE, adalah alat yang sangat diperlukan.  Ini sepenuhnya mengambil tugas menulis karakter dengan jumlah bit paling sedikit, memungkinkan pengembang untuk fokus pada detail utama dari algoritma.  Dan itu juga berfungsi sangat cepat baik dalam encoding dan decoding. <br><br>  Saya harap artikel ini membantu Anda mengenal RANS dan mulai menggunakannya dalam proyek Anda. <br><br><h2>  Referensi </h2><br>  Di sini Anda dapat melihat contoh kerja implementasi RANS (dengan berbagai opsi optimisasi): <br><br>  Fabian Giesen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/rygorous/ryg_rans</a> <br><br>  Anda dapat membaca detail dan detail menarik di blog Fabian (dalam bahasa Inggris): <br><br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RANS note</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RANS dengan distribusi probabilitas statis</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RANS dalam praktek</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441814/">https://habr.com/ru/post/id441814/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441804/index.html">Di mana mengajar anak-anak pemrograman?</a></li>
<li><a href="../id441806/index.html">VPN tanpa VPN atau cerita tentang penggunaan SSH yang tidak konvensional</a></li>
<li><a href="../id441808/index.html">Kami mengundang Anda pada tanggal 6 Maret ke ElixirLangMoscow Meetup # 9</a></li>
<li><a href="../id441810/index.html">Eclipse untuk mikrokontroler (STM32) + FreeRTOS Task Aware Debugger</a></li>
<li><a href="../id441812/index.html">Go Meetup streaming langsung di Acronis</a></li>
<li><a href="../id441816/index.html">Otoritas Perancis mendenda bank UBS $ 4 miliar karena membantu pelanggan menghindari pajak</a></li>
<li><a href="../id441818/index.html">Performa situs seimbang. Bagian 2: Optimasi Teknis</a></li>
<li><a href="../id441820/index.html">Pengabdian Horor dihapus dari Steam - penyebabnya lagi adalah Winnie the Pooh, Xi Jinping dan kemarahan China atas nada politik</a></li>
<li><a href="../id441824/index.html">Manajemen kebakaran sebagai bagian dari pekerjaan pemimpin</a></li>
<li><a href="../id441826/index.html">Apa yang terjadi di pasar streaming audio: mendiskusikan pengembangan platform streaming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>