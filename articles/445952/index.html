<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüíª üïí üôà Un trill√≥n de solteros üôãüèø ü¶Ç üßôüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fuente de la imagen: www.nikonsmallworld.com 


 El antiplagio es un motor de b√∫squeda especializado, sobre el que ya se escribi√≥ anteriormente . Y cu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un trill√≥n de solteros</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/antiplagiat/blog/445952/"><p><img src="https://habrastorage.org/webt/hc/qv/ma/hcqvmaxyzdevsbs7cs8lw_fpile.jpeg"></p><br><p>  <sub><em>Fuente de la imagen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.nikonsmallworld.com</a></em></sub> </p><br><p>  El antiplagio es un motor de b√∫squeda especializado, sobre el que ya se escribi√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anteriormente</a> .  Y cualquier motor de b√∫squeda, sea lo que sea que se diga, para funcionar r√°pidamente, necesita su propio √≠ndice, que tenga en cuenta todas las caracter√≠sticas del √°rea de b√∫squeda.  En mi primer art√≠culo sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Habr,</a> hablar√© sobre la implementaci√≥n actual de nuestro √≠ndice de b√∫squeda, el historial de su desarrollo y las razones para elegir una u otra soluci√≥n.  Los algoritmos .NET efectivos no son un mito, sino una realidad dura y productiva.  Nos sumergiremos en el mundo del hash, la compresi√≥n bit a bit y los cach√©s prioritarios de varios niveles.  ¬øQu√© sucede si necesita una b√∫squeda m√°s r√°pida que <b>O (1)</b> ? </p><br><p>  Si alguien m√°s no sabe d√≥nde est√°n las tejas en esta imagen, bienvenido ... </p><br><p><a name="habracut"></a></p><br><h1>  El herpes z√≥ster, el √≠ndice y por qu√© buscarlos </h1><br><p>  Una teja es un texto de unas pocas palabras de tama√±o.  Las ripias se superponen una tras otra, de ah√≠ el nombre (ingl√©s, ripias - escamas, mosaico).  Su tama√±o espec√≠fico es un secreto a voces: 4 palabras.  O 5?  Bueno, depende  Sin embargo, incluso este valor da poco y depende de la composici√≥n de las palabras de detenci√≥n, el algoritmo para normalizar las palabras y otros detalles que no son significativos en el marco de este art√≠culo.  Al final, calculamos el hash de 64 bits en funci√≥n de esta tabla, que llamaremos tabla en el futuro. </p><br><p>  Seg√∫n el texto del documento, puede crear muchas tejas, cuyo n√∫mero es comparable al n√∫mero de palabras en el documento: </p><br><p>  <em>texto: cadena ‚Üí ripias: uint64 []</em> </p><br><p>  Si varias tejas coinciden en dos documentos, suponemos que los documentos se cruzan.  Cuanto m√°s coinciden las tejas, el texto m√°s id√©ntico est√° en este par de documentos.  El √≠ndice busca documentos que tengan el mayor n√∫mero de intersecciones con el documento que se est√° verificando. </p><br><p><img src="https://habrastorage.org/webt/ud/th/z_/udthz_wa_avl6zbaij-cydicgx8.jpeg"></p><br><p>  <sub><em>Fuente de la imagen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a></em></sub> </p><br><p>  El √≠ndice de herpes z√≥ster le permite realizar dos operaciones principales: </p><br><ol><li><p>  Indice las tejas de los documentos con sus identificadores: </p><br><p>  <i>index.Add (docId, ripias)</i> </p></li><li><p>  Busque y muestre una lista clasificada de identificadores para documentos superpuestos: </p><br><p>  <i>index.Search (culebrilla) ‚Üí (docId, score) []</i> </p></li></ol><br><p>  El algoritmo de clasificaci√≥n, creo, es digno de un art√≠culo separado en general, por lo que no vamos a escribir sobre √©l aqu√≠. </p><br><p> El √≠ndice de herpes z√≥ster es muy diferente de los conocidos hermanos de texto completo, como Sphinx, Elastic o m√°s grandes: Google, Yandex, etc. ... Por un lado, no requiere ninguna PNL y otras alegr√≠as de la vida.  Todo el procesamiento de texto se elimina y no afecta el proceso, as√≠ como la secuencia de las tejas en el texto.  Por otro lado, la consulta de b√∫squeda no es una palabra o una frase de varias palabras, sino hasta varios cientos de miles de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hashes</a> , que son importantes en conjunto, y no por separado. </p><br><p>  Hipot√©ticamente, puede usar el √≠ndice de texto completo como reemplazo del √≠ndice de herpes z√≥ster, pero las diferencias son demasiado grandes.  La forma m√°s f√°cil de usar un almacenamiento clave-valor conocido, se mencionar√° a continuaci√≥n.  Estamos aserrando nuestra implementaci√≥n de <s>bicicleta</s> , que se llama - ShingleIndex. </p><br><p>  ¬øPor qu√© nos molestamos tanto?  Pero por qu√©. </p><br><ul><li>  <u>Vol√∫menes</u> : <br><ol><li>  Hay muchos documentos  Ahora tenemos alrededor de 650 millones de ellos, y este a√±o obviamente habr√° m√°s; </li><li>  El n√∫mero de tejas √∫nicas est√° creciendo a pasos agigantados y ya est√° llegando a cientos de miles de millones.  Estamos esperando un bill√≥n. </li></ol></li><li>  <u>Velocidad</u> : <br><ol><li>  Durante el d√≠a, durante la sesi√≥n de verano, se verifican m√°s de 300 mil documentos a trav√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">del sistema antiplagio</a> .  Esto es un poco para los est√°ndares de los motores de b√∫squeda populares, pero se mantiene en tono; </li><li>  Para una verificaci√≥n exitosa de los documentos para la unicidad, el n√∫mero de documentos indexados debe ser de un orden de magnitud mayor que los documentos que se verifican.  La versi√≥n actual de nuestro √≠ndice en promedio puede llenarse a una velocidad de m√°s de 4000 documentos medianos por segundo. </li></ol></li></ul><br><p>  ¬°Y todo est√° en una m√°quina!  S√≠, podemos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">replicar</a> , nos estamos acercando gradualmente a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fragmentaci√≥n</a> din√°mica en un cl√∫ster, pero desde 2005 hasta hoy, el √≠ndice en una m√°quina con cuidado ha podido hacer frente a todas las dificultades anteriores. </p><br><h1>  Experiencia extra√±a </h1><br><p>  Sin embargo, ahora tenemos mucha experiencia.  Nos guste o no, pero nosotros tambi√©n hemos crecido y hemos intentado diferentes cosas en el curso del crecimiento, que es divertido recordar ahora. </p><br><p><img src="https://habrastorage.org/webt/nx/l4/jx/nxl4jxkzhzumxh91qyds84byk70.jpeg"></p><br><p>  <sub><em>Fuente de la imagen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a></em></sub> </p><br><p>  En primer lugar, un lector inexperto querr√≠a usar una base de datos SQL.  No son los √∫nicos que piensan que s√≠, la implementaci√≥n de SQL nos ha servido durante varios a√±os para implementar colecciones muy peque√±as.  Sin embargo, la atenci√≥n se centr√≥ inmediatamente en millones de documentos, as√≠ que tuve que ir m√°s all√°. </p><br><p>  Como saben, a nadie le gustan las bicicletas, y LevelDB a√∫n no era p√∫blico, por lo que en 2010 nuestros ojos se posaron en BerkeleyDB.  Todo es genial: una persistente base de valor-clave incorporada con m√©todos adecuados de acceso btree y hash y una larga historia.  Todo con ella fue maravilloso, pero: </p><br><ul><li>  En el caso de una implementaci√≥n hash, cuando alcanz√≥ un volumen de 2 GB, simplemente cay√≥.  S√≠, todav√≠a est√°bamos trabajando en modo de 32 bits; </li><li>  La implementaci√≥n del √°rbol B + funcion√≥ de manera estable, pero con vol√∫menes de m√°s de unos pocos gigabytes, la velocidad de b√∫squeda comenz√≥ a disminuir significativamente. </li></ul><br><p>  Tenemos que admitir que nunca encontramos una manera de adaptarlo a nuestra tarea.  Tal vez el problema est√° en los enlaces .net, que a√∫n ten√≠an que terminarse.  La implementaci√≥n de BDB finalmente se us√≥ como un reemplazo para SQL como un √≠ndice intermedio antes de completar el principal. </p><br><p>  El tiempo paso  En 2014, probaron LMDB y LevelDB, pero no lo implementaron.  Los chicos de nuestro Departamento de Investigaci√≥n Antiplagio utilizaron RocksDB como su √≠ndice.  A primera vista, fue un hallazgo.  Pero la lenta reposici√≥n y la velocidad de b√∫squeda mediocre, incluso a peque√±os vol√∫menes, dejaron todo en nada. </p><br><p>  Hicimos todo lo anterior, mientras desarrollamos nuestro propio √≠ndice personalizado.  Como resultado, se volvi√≥ tan bueno resolviendo nuestros problemas que abandonamos los "enchufes" anteriores y nos enfocamos en mejorarlo, que ahora usamos en la producci√≥n en todas partes. </p><br><h1>  Capas de √≠ndice </h1><br><p>  Al final, ¬øqu√© tenemos ahora?  De hecho, el √≠ndice de herpes z√≥ster consta de varias capas (matrices) con elementos de longitud constante, de 0 a 128 bits, que depende no solo de la capa y no es necesariamente un m√∫ltiplo de ocho. </p><br><p>  Cada una de las capas juega un papel.  Algunos agilizan la b√∫squeda, otros ahorran espacio y otros nunca se usan, pero realmente se necesitan.  Intentaremos describirlos para aumentar su eficiencia total en la b√∫squeda. </p><br><p><img src="https://habrastorage.org/webt/sd/y9/ze/sdy9zefei-lyrhgpafxq9viz9pc.jpeg"></p><br><p>  <sub><em>Fuente de la imagen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a></em></sub> </p><br><h4>  1. Matriz de √≠ndice </h4><br><p>  Sin p√©rdida de generalidad, ahora consideraremos que se asigna una sola teja al documento, </p><br><p>  <i>(docId ‚Üí guijarro)</i> </p><br><p>  Cambiaremos los elementos del par (¬°invierte, porque el √≠ndice est√° realmente "invertido"), </p><br><p>  <i>(teja ‚Üí docId)</i> </p><br><p>  Ordenar por los valores de las tejas y formar una capa.  Porque  los tama√±os de la teja y el identificador del documento son constantes, ahora cualquiera que entienda la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b√∫squeda binaria</a> puede encontrar un par m√°s all√° de las lecturas <b>O (log)</b> del archivo.  Qu√© mucho, much√≠simo.  Pero esto es mejor que solo <b>O (n)</b> . </p><br><p>  Si el documento tiene varias tejas, habr√° varios pares de ese tipo en el documento.  Si hay varios documentos con la misma teja, entonces esto tampoco cambiar√° mucho: habr√° varios pares seguidos con la misma teja.  En ambos casos, la b√∫squeda durar√° un tiempo comparable. </p><br><h4>  2. Matriz de grupos </h4><br><p>  Dividimos cuidadosamente los elementos del √≠ndice del paso anterior en grupos de cualquier manera conveniente.  Por ejemplo, para que encajen en <s>el sector del cl√∫ster, el bloque de la</s> unidad de asignaci√≥n (lectura, 4096 bytes), teniendo en cuenta el n√∫mero de bits y otros trucos, formar√° un diccionario efectivo.  Obtenemos un conjunto simple de posiciones de tales grupos: </p><br><p>  <i>group_map (hash (shingle)) -&gt; group_position.</i> </p><br><p>  Al buscar una teja, ahora primero buscaremos la posici√≥n del grupo en este diccionario, y luego descargaremos el grupo y buscaremos directamente en la memoria.  Toda la operaci√≥n requiere dos lecturas. </p><br><p>  El diccionario de posiciones grupales ocupa varios √≥rdenes de magnitud menos espacio que el √≠ndice en s√≠, a menudo se puede descargar simplemente en la memoria.  Por lo tanto, no habr√° dos lecturas, sino una.  Total, <b>O (1)</b> . </p><br><h4>  3. Filtro de floraci√≥n </h4><br><p>  En las entrevistas, los candidatos a menudo resuelven problemas emitiendo soluciones √∫nicas con <b>O (n ^ 2)</b> o incluso <b>O (2 ^ n)</b> .  Pero no hacemos cosas est√∫pidas.  ¬øHay <b>O (0)</b> en el mundo, esa es la pregunta?  Probemos sin mucha esperanza un resultado ... </p><br><p>  Pasemos al √°rea tem√°tica.  Si el estudiante est√° bien hecho y escribi√≥ el trabajo √©l mismo, o simplemente no hay texto, sino basura, entonces una parte significativa de su culebrilla ser√° √∫nica y no se encontrar√° en el √≠ndice.  Una estructura de datos como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el filtro Bloom es</a> bien conocida en el mundo.  Antes de buscar, verifique la teja en √©l.  Si no hay guijarros en el √≠ndice, entonces no puede buscar m√°s, de lo contrario, vaya m√°s all√°. </p><br><p>  El filtro Bloom en s√≠ es bastante simple, pero no tiene sentido usar un vector hash con nuestros vol√∫menes.  Es suficiente usar uno: <b>+1</b> lectura del filtro Bloom.  Esto proporciona <b>-1</b> o <b>-2</b> lecturas de las etapas posteriores, en caso de que la teja sea √∫nica y no haya falsos positivos en el filtro.  Mira tus manos! </p><br><p>  La probabilidad de un error de filtro Bloom se establece durante la construcci√≥n; la probabilidad de una teja desconocida est√° determinada por la honestidad del estudiante.  Los c√°lculos simples pueden llegar a la siguiente dependencia: </p><br><ul><li>  Si confiamos en la honestidad de las personas (es decir, de hecho el documento es original), la velocidad de b√∫squeda disminuir√°; </li><li>  Si el documento est√° claramente cosido, la velocidad de b√∫squeda aumentar√°, pero necesitamos mucha memoria. </li></ul><br><p>  Con la confianza en los estudiantes, tenemos el principio de "confiar, pero verificar", y la pr√°ctica muestra que todav√≠a hay una ganancia del filtro Bloom. </p><br><p>  Dado que esta estructura de datos tambi√©n es m√°s peque√±a que el √≠ndice en s√≠ y puede almacenarse en cach√©, en el mejor de los casos, le permite soltar la teja sin ning√∫n acceso al disco. </p><br><h4>  4. colas pesadas </h4><br><p>  Hay herpes z√≥ster que se encuentran en casi todas partes.  Su participaci√≥n en el n√∫mero total es escasa, pero al construir el √≠ndice en el primer paso, en el segundo, se pueden obtener grupos de decenas y cientos de MB de tama√±o.  Los recordaremos por separado y los descartaremos inmediatamente de la consulta de b√∫squeda. </p><br><p>  Cuando este paso trivial se utiliz√≥ por primera vez en 2011, el tama√±o del √≠ndice se redujo a la mitad y la b√∫squeda en s√≠ misma se aceler√≥. </p><br><h4>  5. Otras colas </h4><br><p>  Aun as√≠, una teja puede tener muchos documentos.  Y esto es normal.  Decenas, cientos, miles ... Mantenerlos dentro del √≠ndice principal deja de ser rentable, tambi√©n pueden no encajar en el grupo, esto hace que el volumen del diccionario de posiciones grupales se infle.  P√≥ngalos en una secuencia separada con un almacenamiento m√°s eficiente.  Seg√∫n las estad√≠sticas, tal decisi√≥n est√° m√°s que justificada.  Adem√°s, varios paquetes bit a bit pueden reducir el n√∫mero de accesos al disco y el volumen del √≠ndice. </p><br><p>  Como resultado, para facilitar el mantenimiento, imprimimos todas estas capas en un archivo grande: fragmento.  Hay diez de esas capas en √©l.  Pero la parte no se usa en la b√∫squeda, la parte es muy peque√±a y siempre se almacena en la memoria, la parte se almacena en cach√© de forma activa seg√∫n sea necesario / posible. </p><br><p>  En la batalla, la b√∫squeda de guijarros se reduce a una o dos lecturas aleatorias de archivos.  En el peor de los casos, tienes que hacer tres.  Todas las capas son conjuntos de elementos de longitud constante (a veces bit a bit).  Tal es la normalizaci√≥n.  El tiempo para desempacar es insignificante en comparaci√≥n con el precio del volumen total durante el almacenamiento y la capacidad de almacenar en cach√© mejor. </p><br><p>  Al construir, los tama√±os de las capas se calculan principalmente por adelantado, escritos secuencialmente, por lo que este procedimiento es bastante r√°pido. </p><br><h1>  ¬øC√≥mo llegaste all√≠? No sab√≠a d√≥nde </h1><br><p></p><blockquote><code>     2010         ,                .    ,          .  ,      .</code> </blockquote> <br><p><img src="https://habrastorage.org/webt/2x/f7/-f/2xf7-fs8nt4rmfx7cvmeyyb_ftq.jpeg"></p><br><p>  <sub><em>Fuente de la imagen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a></em></sub> </p><br><p>  Inicialmente, nuestro √≠ndice constaba de dos partes: una constante, descrita anteriormente, y una temporal, cuyo rol era SQL o BDB, o su propio registro de actualizaci√≥n.  Ocasionalmente, por ejemplo, una vez al mes (y a veces un a√±o), el temporal se clasifica, filtra y combina con el principal.  El resultado fue unificado, y los dos viejos fueron eliminados.  Si el temporal no pod√≠a caber en la RAM, entonces el procedimiento pas√≥ por una clasificaci√≥n externa. </p><br><p>  Este procedimiento fue bastante problem√°tico, comenz√≥ en modo semi-manual y requer√≠a reescribir todo el archivo de √≠ndice desde cero.  Reescribir cientos de gigabytes para un par de millones de documentos, bueno, m√°s o menos placer, te digo ... </p><br><p></p><div class="spoiler">  <b class="spoiler_title">Recuerdos del pasado ...</b> <div class="spoiler_text"><blockquote> <code>       SSD.        ,  31    SSD          wcf-       .  ,          . ,  .</code> </blockquote> </div></div><br><p>  Para que el SSD no est√© particularmente tenso, y el √≠ndice se actualice con m√°s frecuencia, en 2012 involucramos una cadena de varias piezas, fragmentos de acuerdo con el siguiente esquema: </p><br><p><img src="https://habrastorage.org/webt/v4/5s/xo/v45sxoctvil0bhwkf2pfp7vamrs.png"></p><br><p>  Aqu√≠ el √≠ndice consiste en una cadena del mismo tipo de fragmentos, excepto el primero.  El primero, el complemento, era un registro de solo agregado con un √≠ndice en RAM.  Los fragmentos posteriores aumentaron de tama√±o (y edad) hasta el √∫ltimo (cero, principal, ra√≠z, ...). </p><br><p></p><div class="spoiler">  <b class="spoiler_title">Nota para los ciclistas ...</b> <div class="spoiler_text">  A veces no deber√≠as perder el tiempo para escribir c√≥digo y ni siquiera pensar, sino simplemente buscarlo en Google m√°s a fondo.  Hasta la notaci√≥n, el diagrama es similar a este del art√≠culo de 1996 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"El √°rbol de fusi√≥n estructurado de registro"</a> : <img src="https://habrastorage.org/webt/1z/r2/yh/1zr2yhxxboh0syuyfozcujnm5hm.png"></div></div><br><p>  Al agregar un documento, primero se dobl√≥ en un complemento.  Cuando estaba lleno o por otros criterios, se construy√≥ un fragmento permanente sobre √©l.  Los varios fragmentos vecinos, si es necesario, se fusionaron en uno nuevo, y los originales se eliminaron.  Actualizar un documento o eliminarlo funcion√≥ de la misma manera. </p><br><p>  Criterios de fusi√≥n, longitud de cadena, algoritmo de derivaci√≥n, contabilidad de elementos eliminados y actualizaciones, se ajustaron otros par√°metros.  El enfoque en s√≠ estaba involucrado en varias tareas similares y tom√≥ forma como un marco <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LSM</a> interno separado en un .net limpio.  Casi al mismo tiempo, LevelDB se hizo popular. </p><br><p></p><div class="spoiler">  <b class="spoiler_title">Peque√±a observaci√≥n sobre el √°rbol LSM</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LSM-Tree es un</a> algoritmo bastante interesante, con buena justificaci√≥n.  Pero, en mi humilde opini√≥n, hab√≠a algo borroso del significado del t√©rmino √°rbol.  En el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> original <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> se trataba de una cadena de √°rboles con la capacidad de transferir ramas.  En implementaciones modernas, este no es siempre el caso.  Entonces, nuestro marco finalmente se denomin√≥ LsmChain, es decir, la cadena de fragmentos lsm. </div></div><br><p>  El algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LSM</a> en nuestro caso tiene caracter√≠sticas muy adecuadas: </p><br><ol><li>  inserci√≥n / eliminaci√≥n / actualizaci√≥n instant√°nea, </li><li>  carga reducida en SSD durante la actualizaci√≥n, </li><li>  formato de fragmentos simplificado, </li><li>  b√∫squeda selectiva solo en fragmentos viejos / nuevos, </li><li>  copia de seguridad trivial </li><li>  ¬øQu√© m√°s quiere el alma? </li><li>  ... </li></ol><br><p>  En general, a veces es √∫til inventar bicicletas para el autodesarrollo. </p><br><h1>  Macro, micro, nano optimizaci√≥n </h1><br><p>  Y finalmente, compartiremos consejos t√©cnicos sobre c√≥mo nosotros en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">antiplagio</a> hacemos tales cosas en .Net (y no solo en √©l). </p><br><p>  Tenga en cuenta de antemano que a menudo todo depende en gran medida de su hardware espec√≠fico, datos o modo de uso.  Despu√©s de retorcernos en un lugar, salimos del cach√© de la CPU, en otro, nos encontramos con el ancho de banda de la interfaz SATA, en el tercero, comenzamos a colgarnos en el GC.  Y en alg√∫n lugar de la ineficiencia de la implementaci√≥n de una llamada espec√≠fica al sistema. </p><br><p><img src="https://habrastorage.org/webt/gl/pq/sp/glpqspyystghvhhemtthxysivp0.jpeg"></p><br><p>  <sub><em>Fuente de la imagen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a></em></sub> </p><br><h1>  Trabajar con archivo </h1><br><p>  El problema con el acceso al archivo no es exclusivo de nosotros.  Hay un archivo grande de <s>terabyte exabyte</s> , cuyo volumen es muchas veces mayor que la cantidad de RAM.  La tarea es leer el mill√≥n disperso a su alrededor de algunos peque√±os valores aleatorios.  Y hacerlo de forma r√°pida, eficiente y econ√≥mica.  Tenemos que exprimir, comparar y pensar mucho. </p><br><p>  Comencemos con uno simple.  Para leer el byte atesorado que necesita: </p><br><ol><li>  Abrir archivo (nuevo FileStream); </li><li>  Mu√©vase a la posici√≥n deseada (Posici√≥n o B√∫squeda, sin diferencia); </li><li>  Lea la matriz de bytes deseada (Leer); </li><li>  Cierre el archivo (desechar). </li></ol><br><p>  Y esto es malo, porque es largo y triste.  Mediante prueba, error y pasos repetidos en el rastrillo, identificamos el siguiente algoritmo de acciones: </p><br><ul><li><p>  <b>Solo abierto, lectura m√∫ltiple</b> </p><br><p>  Si esta secuencia se realiza en la frente, por cada solicitud al disco, nos doblaremos r√°pidamente.  Cada uno de estos elementos entra en una solicitud al n√∫cleo del sistema operativo, que es costoso. </p><br><p>  Obviamente, debe abrir el archivo una vez y leer de forma secuencial todos nuestros millones de valores, lo cual hacemos </p></li><li><p>  <b>Nada extra</b> </p><br><p>  Obtener el tama√±o del archivo, la posici√≥n actual en √©l tambi√©n es operaciones bastante dif√≠ciles.  Incluso si el archivo no cambi√≥. </p><br><p>  Deben evitarse consultas como obtener el tama√±o del archivo o la posici√≥n actual en √©l. </p></li><li><p>  <b>Filestreampool</b> </p><br><p>  Siguiente  Por desgracia, FileStream es esencialmente de un solo subproceso.  Si desea leer un archivo en paralelo, deber√° crear / cerrar nuevas secuencias de archivos. </p><br><p>  Hasta que crees algo como aiosync, tienes que inventar tus propias bicicletas. </p><br><p>  Mi consejo es crear un grupo de secuencias de archivos por archivo.  Esto evitar√° perder tiempo abriendo / cerrando un archivo.  Y si lo combina con ThreadPool y tiene en cuenta que el SSD emite sus megaIOPS con un fuerte subprocesamiento m√∫ltiple ... Bueno, me comprende. </p></li><li><p>  <b>Unidad de asignaci√≥n</b> </p><br><p>  Siguiente  Los dispositivos de almacenamiento (HDD, SSD, Optane) y el sistema de archivos funcionan con archivos a nivel de bloque (cl√∫ster, sector, unidad de asignaci√≥n).  Puede que no coincidan, pero ahora casi siempre son 4096 bytes.  Leer uno o dos bytes en el borde de dos de estos bloques en un SSD es aproximadamente una vez y media m√°s lento que dentro del bloque mismo. </p><br><p>  Debe organizar sus datos para que los elementos restados se encuentren dentro de los l√≠mites del bloque de <s>sector</s> del <s>cl√∫ster</s> . </p></li><li><p>  <b>Sin tamp√≥n.</b> </p><br><p>  Siguiente  FileStream utiliza de forma predeterminada un b√∫fer de 4096 bytes.  Y la mala noticia es que no puedes apagarlo.  Sin embargo, si est√° leyendo m√°s datos que el tama√±o del b√∫fer, este √∫ltimo ser√° ignorado. </p><br><p>  Para la lectura aleatoria, debe establecer el b√∫fer en 1 byte (no funcionar√° menos) y luego considerar que no se usa. </p></li><li><p>  <b>Usar tamp√≥n.</b> </p><br><p>  Adem√°s de las lecturas aleatorias, tambi√©n hay lecturas secuenciales.  Aqu√≠ el b√∫fer ya puede ser √∫til si no desea leer todo de una vez.  Te aconsejo que comiences con este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> .  El tama√±o del b√∫fer para configurar depende de si el archivo est√° en el HDD o en el SSD.  En el primer caso, 1 MB ser√° √≥ptimo; en el segundo, 4 KB est√°ndar ser√°n suficientes.  Si el tama√±o del √°rea de datos a leer es comparable con estos valores, entonces es mejor restarlo de una vez, omitiendo el b√∫fer, como en el caso de la lectura aleatoria.  Los amortiguadores grandes no generar√°n ganancias en velocidad, pero comenzar√°n a afectar a GC. </p><br><p>  Al leer secuencialmente grandes partes del archivo, debe establecer el b√∫fer en 1 MB para HDD y 4 KB para SSD.  Bueno, depende </p></li></ul><br><h1>  MMF vs FileStream </h1><br><p>  En 2011, lleg√≥ un consejo a MemoryMappedFile, ya que este mecanismo se ha implementado desde .Net Framework v4.0.  Primero, lo usaron cuando almacenaron en cach√© el filtro Bloom, que ya era inconveniente en el modo de 32 bits debido a la limitaci√≥n de 4 GB.  Pero cuando me mud√© al mundo de 64 bits, quer√≠a m√°s.  Las primeras pruebas fueron impresionantes.  Cach√© gratuito, velocidad anormal, interfaz de lectura de estructura conveniente.  Pero hubo problemas: </p><br><ul><li>  Primero, curiosamente, la velocidad.  Si los datos ya est√°n en cach√©, entonces todo est√° bien.  Pero si no, la lectura de un byte del archivo fue acompa√±ada por una "elevaci√≥n" de una cantidad de datos mucho mayor de lo que ser√≠a con una lectura regular. </li><li>  En segundo lugar, curiosamente, la memoria.  Cuando se calienta, la memoria compartida crece, funcionamiento, no, lo cual es l√≥gico.  Pero entonces los procesos vecinos comienzan a comportarse no muy bien.  Pueden entrar en un intercambio o caerse accidentalmente de OoM.  El volumen ocupado por el MMF en RAM, por desgracia, no se puede controlar.  Y el beneficio del cach√© en el caso en que el archivo legible es un par de √≥rdenes de magnitud mayor que la memoria deja de tener sentido. </li></ul><br><p>  El segundo problema a√∫n podr√≠a ser combatido.  Desaparece si el √≠ndice funciona en Docker o en una m√°quina virtual dedicada.  Pero el problema de la velocidad fue fatal. </p><br><p>  Como resultado, el MMF fue abandonado un poco m√°s que completamente.  El almacenamiento en cach√© en el antiplagio comenz√≥ a hacerse de forma expl√≠cita, si es posible, manteniendo en la memoria las capas m√°s utilizadas en las prioridades y l√≠mites dados. </p><br><p><img src="https://habrastorage.org/webt/qr/em/sd/qremsdrzpkqcxqrbam_finb4dyw.jpeg"></p><br><p>  <sub><em>Fuente de la imagen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a></em></sub> </p><br><h1>  Bits / bytes </h1><br><p>  No bytes, el mundo es uno.  A veces necesitas bajar al nivel de bits. </p><br><p>  Por ejemplo: suponga que tiene un bill√≥n de n√∫meros parcialmente ordenados, ansiosos por guardar y leer con frecuencia.  ¬øC√≥mo trabajar con todo esto? </p><br><ul><li>  Simple BinaryWriter.Write?  - R√°pido pero lento.  El tama√±o s√≠ importa.  La lectura en fr√≠o depende principalmente del tama√±o del archivo. </li><li>  ¬øOtra variaci√≥n de VarInt?  - R√°pido pero lento.  La consistencia importa.  El volumen comienza a depender de los datos, lo que requiere memoria adicional para el posicionamiento. </li><li>  Poco de embalaje?  - R√°pido pero lento.  Tienes que controlar m√°s cuidadosamente tus manos. </li></ul><br><p>  No existe una soluci√≥n ideal, pero en el caso espec√≠fico, simplemente comprimiendo el rango de 32 bits al necesario para almacenar las colas ahorr√≥ un 12% m√°s (¬°decenas de GB!) Que VarInt (ahorrando solo la diferencia de las vecinas, por supuesto), y eso es varias veces Opci√≥n b√°sica. </p><br><p>  Otro ejemplo.  Tiene un enlace en un archivo a una serie de n√∫meros.  Enlace de 64 bits, archivo por terabyte.  Todo parece estar bien.  A veces hay muchos n√∫meros en la matriz, a veces pocos.  A menudo un poco  Muy a menudo.  Luego, simplemente tome y almacene toda la matriz en el enlace.  Ganancia  Empaca con cuidado pero no lo olvides. </p><br><h1>  Estructura, inseguro, procesamiento por lotes, microopciones </h1><br><p>  Bueno y otra microoptimizaci√≥n.  No escribir√© aqu√≠ sobre el banal "¬øvale la pena guardar la longitud de la matriz en un bucle" o "que es m√°s r√°pido, para o para siempre". </p><br><p>  Hay dos reglas simples y las cumpliremos: 1. "comparar todo", 2. "m√°s benchmark". </p><br><ul><li><p>  <b>Estructura</b>  Usado en todas partes.  No env√≠e GC.  Y, como est√° de moda hoy, tambi√©n tenemos nuestra propia ValueList mega-r√°pida. </p></li><li><p>  <b>Inseguro</b>  Permite estructuras mapit (y unmap) a una matriz de bytes cuando se usa.  Por lo tanto, no necesitamos medios separados de serializaci√≥n.  Es cierto que hay preguntas para fijar y desfragmentar el mont√≥n, pero hasta ahora no se ha mostrado.  Bueno, depende </p></li><li><p>  <b>Lote</b> .  El trabajo con muchos elementos debe realizarse a trav√©s de paquetes / grupos / bloques.  Leer / escribir archivo, transferir entre funciones.  Otro problema es el tama√±o de estos paquetes.  Por lo general, hay un √≥ptimo, y su tama√±o suele estar en el rango de 1kB a 8MB (tama√±o de cach√© de CPU, tama√±o de cl√∫ster, tama√±o de p√°gina, tama√±o de otra cosa).  Intente bombear a trav√©s de la funci√≥n IEnumerable &lt;byte&gt; o IEnumerable &lt;byte [1024]&gt; y sienta la diferencia. </p></li><li><p>  <b>Pooling</b>  Cada vez que escribes "nuevo", un gatito muere en alg√∫n lugar.  Una vez nuevo byte [ <a href="">85000</a> ] - y el tractor mont√≥ una tonelada de gansos.  Si no es posible usar stackalloc, cree un grupo de objetos y vuelva a usarlo. </p></li><li><p>  <b>En l√≠nea</b> .  ¬øC√≥mo crear dos funciones en lugar de una puede acelerar todo diez veces?  Simple  Cuanto m√°s peque√±o sea el tama√±o del cuerpo de la funci√≥n (m√©todo), m√°s probable ser√° que est√© en l√≠nea.  Desafortunadamente, en el mundo dotnet todav√≠a no hay forma de hacer una alineaci√≥n parcial, por lo que si tiene una funci√≥n activa que en el 99% de los casos sale despu√©s de procesar las primeras l√≠neas, y las cien l√≠neas restantes van a procesar el 1% restante, luego div√≠dalo con seguridad dos (o tres), llevando la pesada cola a una funci√≥n separada. </p></li></ul><br><h1>  Que mas </h1><br><ul><li><p>  <b>Span &lt;T&gt;</b> , <b>Memoria &lt;T&gt;</b> - prometedora.  El c√≥digo ser√° m√°s simple y quiz√°s un poco m√°s r√°pido.  Estamos esperando el lanzamiento de .Net Core v3.0 y Std v2.1 para cambiar a ellos, porque  nuestro n√∫cleo en .Net Std v2.0, que normalmente no admite tramos. </p></li><li><p>  <b>As√≠ncrono / espera</b> - hasta ahora controvertido.  Los puntos de referencia de lectura aleatoria m√°s simples mostraron que el consumo de CPU en realidad est√° disminuyendo, pero la velocidad de lectura tambi√©n est√° disminuyendo.  Debo mirar.  Todav√≠a no lo estamos usando dentro del √≠ndice. </p></li></ul><br><h1>  Conclusi√≥n </h1><br><p>  Espero que mi lejan√≠a le d√© placer al comprender la belleza de algunas decisiones.  Realmente nos gusta nuestro √≠ndice.  Es eficiente, hermoso c√≥digo, funciona muy bien.  Una soluci√≥n altamente especializada en el n√∫cleo del sistema, el lugar cr√≠tico de su trabajo, es mejor que la general.  Nuestro sistema de control de versiones recuerda las inserciones de ensamblador en c√≥digo C ++.  Ahora hay cuatro ventajas: solo C # puro, solo .Net.  En √©l escribimos incluso los algoritmos de b√∫squeda m√°s complejos y no nos arrepentimos en absoluto.  Con la llegada de .Net Core, la transici√≥n a Docker, el camino hacia un futuro brillante de DevOps se ha vuelto m√°s f√°cil y claro.  A continuaci√≥n est√° la soluci√≥n del problema de la fragmentaci√≥n y replicaci√≥n din√°mica sin reducir la efectividad y la belleza de la soluci√≥n. </p><br><p>  Gracias a todos los que leyeron hasta el final.  Para todas las discrepancias y otras inconsistencias, escriba comentarios.  Estar√© encantado de cualquier consejo razonable y refutaci√≥n en los comentarios. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/445952/">https://habr.com/ru/post/445952/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445932/index.html">Seguridad de la aplicaci√≥n del cliente: consejos pr√°cticos para un desarrollador front-end</a></li>
<li><a href="../445936/index.html">Desarrollo de electr√≥nica. Sobre microcontroladores en los dedos</a></li>
<li><a href="../445940/index.html">AMA con Habr, v 7.0. Lim√≥n, Donuts y Noticias</a></li>
<li><a href="../445946/index.html">MWC: instrucciones de uso</a></li>
<li><a href="../445948/index.html">Herencia en C ++: principiante, intermedio, avanzado</a></li>
<li><a href="../445954/index.html">Acelerador de IA de HSE, MTS y Rostelecom</a></li>
<li><a href="../445958/index.html">SPDS GraphiCS - sistema de fachadas y cubiertas</a></li>
<li><a href="../445962/index.html">Pr√°cticas en TI: visi√≥n del gerente</a></li>
<li><a href="../445964/index.html">MEPhI organizar√° una olimpiada de seguridad de la informaci√≥n del estudiante: c√≥mo participar y qu√© ofrece</a></li>
<li><a href="../445966/index.html">Nota del arquitecto frontend # 1. No puedes simplemente obtener y usar Redux.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>