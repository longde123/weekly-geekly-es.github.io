<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â˜”ï¸ ğŸ‘ª ğŸ‘« Menggunakan pembelajaran mesin dalam analisis statis kode sumber program ğŸ”ª ğŸ‘¨ğŸ¾â€ğŸ’¼ ğŸ›¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pembelajaran mesin berakar dalam di berbagai bidang aktivitas manusia: dari pengenalan ucapan hingga diagnosa medis. Popularitas pendekatan ini begitu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan pembelajaran mesin dalam analisis statis kode sumber program</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/484208/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/0e0/738/38e0e0738ea8b928bdecb77040a207c1.png" alt="Menggunakan program pembelajaran dalam program analisis statistik kode sumber"></div><br>  Pembelajaran mesin berakar dalam di berbagai bidang aktivitas manusia: dari pengenalan ucapan hingga diagnosa medis.  Popularitas pendekatan ini begitu besar sehingga mereka mencoba menggunakannya sedapat mungkin.  Beberapa upaya untuk menggantikan pendekatan klasik dengan jaringan saraf tidak begitu berhasil.  Mari kita lihat pembelajaran mesin dari sudut pandang membuat penganalisis kode statis yang efektif untuk menemukan bug dan kerentanan potensial. <br><a name="habracut"></a><br>  Tim PVS-Studio sering ditanya apakah kita ingin mulai menggunakan pembelajaran mesin untuk menemukan kesalahan dalam kode sumber program.  Jawaban singkat: ya, tetapi sangat terbatas.  Kami percaya bahwa dengan penggunaan pembelajaran mesin dalam masalah analisis kode, ada banyak jebakan.  Di bagian kedua artikel ini kita akan membicarakannya.  Mari kita mulai dengan ulasan tentang solusi dan ide baru. <br><br><h2>  Pendekatan baru </h2><br>  Saat ini, sudah ada banyak implementasi analisa statis berdasarkan atau menggunakan pembelajaran mesin, termasuk pembelajaran mendalam dan NLP untuk deteksi kesalahan.  Tidak hanya penggemar, tetapi juga perusahaan besar, seperti Facebook, Amazon atau Mozilla, menarik perhatian pada potensi pembelajaran mesin ketika mencari kesalahan.  Beberapa proyek tidak sepenuhnya merupakan analisa statis, tetapi hanya di antaranya menemukan beberapa kesalahan spesifik selama melakukan. <br><br>  Menariknya, hampir semua diposisikan sebagai produk pengubah permainan yang, dengan bantuan kecerdasan buatan, akan mengubah proses pengembangan. <p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28c/cde/532/28ccde53241d54d5b927234ff729a19d.png"></div><br>  Perhatikan beberapa contoh terkenal: <br><br><ol>
<li>  Deepcode </li><li>  Infer, Sapienz, SapFix </li><li>  Embold </li><li>  Sumber {d} </li><li>  Pintar-Komit, Asisten Komit </li><li>  CodeGuru </li></ol><br><h3>  Deepcode </h3><br>  Deep Code adalah alat pencarian kerentanan dalam kode program yang ditulis dalam Java, JavaScript, TypeScript dan Python, di mana pembelajaran mesin hadir sebagai komponen.  Menurut Boris Paskalev, lebih dari 250 ribu aturan sudah berfungsi.  Alat ini dilatih berdasarkan perubahan yang dilakukan oleh pengembang terhadap kode sumber proyek terbuka (satu juta repositori).  Perusahaan itu sendiri mengatakan proyek mereka adalah Grammarly untuk pengembang. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c0/f09/8df/0c0f098dfabd07a95df228b434ab3bfb.png"></div><br><br>  Intinya, penganalisa ini membandingkan solusi Anda dengan database proyeknya dan menawarkan kepada Anda perkiraan solusi terbaik dari pengalaman pengembang lain. <br><br>  Pada Mei 2018, pengembang menulis bahwa dukungan untuk bahasa C ++ sedang dipersiapkan, namun, bahasa ini masih belum didukung.  Meskipun ditunjukkan di situs itu sendiri bahwa bahasa baru dapat ditambahkan dalam hitungan minggu, karena fakta bahwa hanya satu langkah tergantung pada penguraian bahasa. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a38/68e/7e5/a3868e7e5efa50016e7a7858054da47a.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/111/984/4f5/1119844f5406645778271c64f12d0df9.png"></div><br><br>  Sekelompok publikasi tentang metode yang menjadi dasar analisis juga diterbitkan di situs. <br><br><h3>  Infer </h3><br>  Facebook berusaha cukup luas untuk memperkenalkan pendekatan baru dalam produknya.  Mereka tidak mengabaikan perhatian dan pembelajaran mesin mereka.  Pada 2013, mereka membeli startup yang sedang mengembangkan analisa statis berbasis mesin.  Dan pada 2015, kode sumber proyek <a href="https://github.com/facebook/infer">menjadi terbuka</a> . <br><br>  Infer adalah penganalisa statis untuk proyek yang ditulis dalam Java, C, C ++, dan Objective-C, yang dikembangkan oleh Facebook.  Menurut situs, itu juga digunakan di Amazon Web Services, Oculus, Uber, dan proyek populer lainnya. <br><br>  Infer saat ini mampu mendeteksi kesalahan yang berkaitan dengan dereferencing pointer nol, kebocoran memori.  Infer didasarkan pada logika Hoar, logika pemisahan dan penculikan, serta teori interpretasi abstrak.  Menggunakan pendekatan ini memungkinkan penganalisa untuk memecah program menjadi blok-blok kecil (potongan) dan menganalisanya secara independen satu sama lain. <br><br>  Anda dapat mencoba menggunakan Infer pada proyek Anda, namun, pengembang memperingatkan bahwa meskipun di Facebook memproyeksikan tanggapan yang bermanfaat mencakup 80% dari hasil, pada proyek lain sejumlah kecil kesalahan positif tidak dijamin.  Beberapa kesalahan yang belum dapat ditemukan Infer, tetapi pengembang sedang berupaya memperkenalkan pemicu seperti itu: <br><br><ul><li>  keluar dari array; </li><li>  pengecualian typecast; </li><li>  kebocoran data yang tidak diverifikasi; </li><li>  kondisi lomba pacuan. </li></ul><br><h3>  Sapfix </h3><br>  SapFix adalah alat pengeditan otomatis.  Ia menerima informasi dari Sapienz, alat otomatisasi pengujian, dan penganalisa statis Infer, dan berdasarkan perubahan dan pesan terbaru, Infer memilih salah satu dari beberapa strategi untuk memperbaiki kesalahan. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/547/de6/baa/547de6baa2d74f4e3be984a78c704d45.png"></div><br><br>  Dalam beberapa kasus, SapFix memutar kembali semua atau sebagian dari perubahan.  Dalam kasus lain, ia mencoba menyelesaikan masalah dengan membuat tambalan dari set pola perbaikannya.  Set ini dibentuk dari template pengeditan yang dikompilasi oleh programmer sendiri dari set pengeditan yang sudah dilakukan sekali.  Jika template semacam itu tidak memperbaiki kesalahan, SapFix mencoba untuk menyesuaikan template dengan situasi, membuat modifikasi kecil di pohon sintaksis abstrak hingga solusi potensial ditemukan. <br><br>  Tetapi satu solusi potensial tidak cukup, jadi SapFix mengumpulkan beberapa solusi yang dipilih berdasarkan tiga pertanyaan: apakah ada kesalahan kompilasi, apakah ada crash, apakah edit memperkenalkan crash baru.  Setelah pengeditan sepenuhnya diuji, tambalan dikirim untuk ditinjau kepada programmer yang memutuskan yang mana dari pengeditan terbaik yang menyelesaikan masalah. <br><br><h3>  Embold </h3><br>  Embold adalah platform startup untuk analisis statis kode sumber program, yang sebelum diganti namanya disebut Gamma.  Analisis statis dilakukan berdasarkan diagnostik kami sendiri, serta berdasarkan analisis bawaan seperti CppCheck, SpotBugs, SQL Check, dan lainnya. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f40/406/bd8/f40406bd824b5eeb1815de357d95565b.png"></div><br><br>  Selain diagnosa itu sendiri, penekanannya adalah pada kemampuan untuk menampilkan infografis secara visual dengan memuat basis kode dan dengan mudah melihat kesalahan yang ditemukan, serta mencari refactoring.  Selain itu, penganalisa ini memiliki serangkaian pola-anti yang memungkinkan Anda untuk mendeteksi masalah dalam struktur kode di tingkat kelas dan metode, dan berbagai metrik untuk menghitung kualitas sistem. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/74f/abb/22074fabb8b67de2ce5d5427729387f7.png"></div><br><br>  Salah satu keuntungan utama adalah solusi cerdas dan sistem saran revisi, yang, selain diagnostik biasa, memeriksa revisi berdasarkan informasi tentang perubahan sebelumnya. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/122/c46/6e5122c462cd33320eafecd4deac2a49.png"></div><br><br>  Menggunakan NLP, Embold memecah kode menjadi beberapa bagian dan mencari interkoneksi dan dependensi antara fungsi dan metode di antara mereka, yang menghemat waktu refactoring. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94e/129/3fe/94e1293fe9e031d4065beb9ea1b21932.png"></div><br><br>  Dengan demikian, Embold terutama menawarkan visualisasi yang nyaman dari hasil analisis kode sumber Anda oleh berbagai analis, serta diagnostiknya sendiri, beberapa di antaranya didasarkan pada pembelajaran mesin. <br><br><h3>  Sumber {d} </h3><br>  Sumber {d} adalah yang paling terbuka dalam hal bagaimana menerapkannya dari analisis yang kami periksa.  Ini juga merupakan <a href="https://github.com/src-d/sourced-ce">solusi open source</a> .  Di situs web mereka, Anda dapat (sebagai ganti alamat email Anda) mendapatkan buklet dengan deskripsi teknologi yang mereka gunakan.  Selain itu, ini berisi <a href="https://github.com/src-d/awesome-machine-learning-on-source-code">tautan</a> ke basis publikasi yang telah mereka kumpulkan terkait dengan penggunaan pembelajaran mesin untuk analisis kode, serta <a href="https://github.com/src-d/datasets/tree/master/PublicGitArchive">repositori</a> dengan dataset untuk pelatihan kode.  Produk itu sendiri adalah platform keseluruhan untuk menganalisis kode sumber dan produk perangkat lunak, dan berfokus, bukan pada pengembang, tetapi pada tautan manajer.  Di antara kemampuannya ada fungsional untuk mengidentifikasi volume utang teknis, hambatan dalam proses pengembangan dan statistik global lainnya pada proyek. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af2/b8c/425/af2b8c42537b1a2628c95773165ed190.png"></div><br><br>  Mereka mendasarkan pendekatan mereka pada analisis kode berbantuan mesin pada Hipotesis Alami, yang diformulasikan dalam artikel " <a href="https://people.inf.ethz.ch/suz/publications/natural.pdf">On the Naturalness of Software</a> ". <br><br>  <i>â€œBahasa pemrograman, secara teori, kompleks fleksibel dan kuat, tetapi program yang orang-orang sebenarnya benar-benar tulis sebagian besar sederhana dan cukup berulang, dan karena itu mereka memiliki sifat statistik yang berguna dan dapat diprediksi yang dapat dinyatakan dalam statistik model bahasa dan digunakan untuk tugas pengembangan perangkat lunak. "</i> <br><br>  Berdasarkan hipotesis ini, semakin besar basis kode untuk melatih penganalisa, semakin banyak sifat statistik yang menonjol dan semakin akurat metrik yang dicapai melalui pelatihan. <br><br>  Untuk menganalisis kode, sumber {d} menggunakan layanan Babelfish, yang dapat mengurai file kode dalam salah satu bahasa yang tersedia, dapatkan pohon sintaksis abstrak dan mengonversinya menjadi struktur sintaksis universal. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39e/bbd/c4d/39ebbdc4d561895c1f7b9e251d44e17c.png"></div><br><br>  Namun, sumber {d} tidak mencari kesalahan dalam kode.  Berdasarkan pohon, menggunakan pembelajaran mesin berdasarkan seluruh proyek, sumber {d} mengungkapkan bagaimana kode diformat, gaya pengkodean apa yang digunakan dalam proyek dan ketika melakukan, dan jika kode baru tidak cocok dengan gaya kode proyek, itu membuat perubahan yang sesuai. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/196/c0a/e7f196c0a742ba8f68436b157708c109.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/f51/7bd/debf517bd5d74c2553a9b7fbd112a1b2.png"></div><br><br>  Pelatihan dipandu oleh beberapa elemen dasar: spasi, tab, jeda baris, dll. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39a/ade/8c5/39aade8c5ea77cb3bf89d4a0e999c5f7.png"></div><br><br>  Anda dapat membaca lebih lanjut tentang ini dalam publikasi mereka: " <a href="https://arxiv.org/abs/1904.00935">STYLE-ANALYZER: memperbaiki ketidakkonsistenan gaya kode dengan algoritma yang tidak dapat ditafsirkan yang dapat ditafsirkan</a> ". <br><br>  Secara umum, sumber {d} adalah platform luas untuk mengumpulkan berbagai statistik tentang kode sumber dan proses pengembangan proyek, mulai dari menghitung efektivitas pengembang hingga mengidentifikasi biaya waktu untuk tinjauan kode. <br><br><h3>  Komitmen pintar </h3><br>  Clever-Commit adalah penganalisa yang dibuat oleh Mozilla bekerja sama dengan Ubisoft.  Ini didasarkan pada studi Ubisoft's <a href="https://static-wordpress.akamaized.net/montreal.ubisoft.com/wp-content/uploads/2018/03/03172129/clever-commit-msr18.pdf">CLEVER</a> (Menggabungkan Tingkat Pencegahan Bug dan Teknik Resolusi), dan Asisten Komit berbasis produknya, yang mengidentifikasi komitmen mencurigakan yang kemungkinan mengandung kesalahan.  Karena fakta bahwa CLEVER didasarkan pada perbandingan kode, itu tidak hanya menunjukkan kode berbahaya, tetapi juga membuat saran tentang kemungkinan koreksi.  Menurut uraian, dalam 60-70% kasus Clever-Commit menemukan area masalah dan dengan frekuensi yang sama menawarkan koreksi yang benar untuk mereka.  Secara umum, ada sedikit informasi tentang proyek ini dan tentang kesalahan yang dapat ditemukan. <br><br><h3>  CodeGuru </h3><br>  Dan baru-baru ini, daftar analis yang menggunakan pembelajaran mesin telah diisi ulang dengan produk dari Amazon yang disebut CodeGuru.  Layanan ini didasarkan pada pembelajaran mesin, yang memungkinkan Anda menemukan kesalahan dalam kode, serta mengidentifikasi bagian yang mahal di dalamnya.  Sejauh ini, analisis hanya untuk kode Java, tetapi mereka menulis tentang dukungan untuk bahasa lain di masa depan.  Meskipun diumumkan baru-baru ini, CEO AWS (Amazon Web Services) Andy Jassi mengatakan dia telah menggunakannya untuk waktu yang lama di Amazon sendiri. <br><br>  Situs tersebut mengatakan bahwa pelatihan dilakukan pada basis kode Amazon sendiri, serta pada lebih dari 10.000 proyek sumber terbuka. <br><br>  Bahkan, layanan ini dibagi menjadi dua bagian: Peninjau KodeGuru, dilatih dengan mencari aturan asosiatif dan mencari kesalahan dalam kode, dan CodeGuru Profiler, yang memantau kinerja aplikasi. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/662/3a6/ee06623a61ab3f1345d05f169f3325ac.png"></div><br><br>  Secara umum, tidak banyak informasi yang telah dipublikasikan tentang proyek ini.  Situs tersebut mengatakan bahwa untuk mempelajari cara menangkap penyimpangan dari "praktik terbaik", Reviewer menganalisis basis kode Amazon dan mencari permintaan tarik yang berisi panggilan API AWS di dalamnya.  Kemudian dia melihat perubahan yang dilakukan dan membandingkannya dengan data dari dokumentasi, yang dianalisis secara paralel.  Hasilnya adalah model "praktik terbaik." <br><br>  Juga dikatakan bahwa rekomendasi untuk kode kustom meningkat setelah menerima umpan balik tentang rekomendasi tersebut. <br><br>  Daftar kesalahan yang direspon oleh Reviewer agak kabur, karena tidak ada dokumentasi khusus untuk kesalahan yang telah dipublikasikan: <ul><li>  Praktik Terbaik AWS </li><li>  Konkurensi </li><li>  Kebocoran sumber daya </li><li>  Kebocoran Informasi Rahasia </li><li>  "Praktik Terbaik" yang umum untuk Pengkodean </li></ul><br><h2>  Skeptisisme kami </h2><br>  Sekarang mari kita lihat masalah menemukan kesalahan melalui mata tim kami, yang telah mengembangkan analisa statis selama bertahun-tahun.  Kami melihat sejumlah masalah tingkat tinggi dari penerapan pelatihan, yang ingin kami bicarakan.  Tetapi pada awalnya kami secara kasar membagi semua pendekatan ML menjadi dua jenis: <br><br><ol><li>  Melatih penganalisa statis secara manual untuk mencari berbagai masalah menggunakan contoh kode sintetik dan nyata; </li><li>  Latih algoritma pada sejumlah besar kode sumber terbuka (GitHub) dan ubah riwayat, setelah itu penganalisa sendiri akan mulai mendeteksi kesalahan dan bahkan menyarankan perbaikan. </li></ol><br>  Kami akan berbicara tentang setiap arah secara terpisah, karena mereka akan memiliki berbagai kekurangan.  Setelah itu, saya pikir, akan menjadi jelas bagi pembaca mengapa kita tidak menyangkal kemungkinan pembelajaran mesin, tetapi juga tidak berbagi antusiasme. <br><br>  <b>Catatan</b>  Kami melihat dari perspektif mengembangkan alat analisa statik universal untuk keperluan umum.  Kami fokus pada pengembangan alat analisis yang berfokus bukan pada basis kode tertentu, tetapi yang dapat digunakan tim mana pun dalam proyek apa pun. <br><br><h3>  Pelatihan penganalisa statis manual </h3><br>  Misalkan kita ingin menggunakan ML sehingga penganalisa mulai mencari anomali dari bentuk berikut dalam kode: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == A)</code> </pre> <br>  Sungguh aneh membandingkan suatu variabel dengan dirinya sendiri.  Kami dapat menulis banyak contoh kode yang benar dan salah dan melatih penganalisa untuk mencari kesalahan tersebut.  Selain itu, dimungkinkan untuk menambahkan contoh nyata dari kesalahan yang telah ditemukan ke tes.  Pertanyaannya, tentu saja, adalah dari mana mendapatkan contoh-contoh ini.  Tetapi kami akan mempertimbangkan bahwa itu mungkin.  Misalnya, kami telah mengumpulkan sejumlah contoh kesalahan seperti itu: <a href="https://www.viva64.com/ru/examples/v501/">V501</a> , <a href="https://www.viva64.com/ru/examples/v3001/">V3001</a> , <a href="https://www.viva64.com/ru/examples/v6001/">V6001</a> . <br><br>  Jadi, apakah mungkin untuk mencari cacat dalam kode menggunakan algoritma pembelajaran mesin?  Kamu bisa.  Tetapi tidak jelas mengapa melakukan ini! <br><br>  Lihat, untuk melatih penganalisa kita perlu menghabiskan banyak upaya menyiapkan contoh untuk pelatihan.  Atau tandai kode aplikasi nyata, yang menunjukkan di mana harus bersumpah dan di mana tidak.  Bagaimanapun, banyak pekerjaan yang harus dilakukan, karena harus ada ribuan contoh untuk pelatihan.  Atau puluhan ribu. <br><br>  Bagaimanapun, kami ingin mencari tidak hanya untuk kasus (A == A), tetapi juga untuk: <br><br><ul><li>  if (X&amp;&amp; A == A) </li><li>  jika (A + 1 == A + 1) </li><li>  if (A [i] == A [i]) </li><li>  if ((A) == (A)) </li><li>  dan sebagainya. </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19e/a51/95d/19ea5195d9075802dbdcd3feda3c4aad.png"></div><br><br>  Sekarang mari kita lihat bagaimana diagnosis sederhana seperti itu akan diterapkan di PVS-Studio: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RulePrototype_V501</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VivaWalker &amp;walker, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *right, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *operation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SafeEq(operation, <span class="hljs-string"><span class="hljs-string">"=="</span></span>) &amp;&amp; SafeEqual(left, right)) { walker.AddError(<span class="hljs-string"><span class="hljs-string">" , !"</span></span>, left, <span class="hljs-number"><span class="hljs-number">501</span></span>, Level_1, <span class="hljs-string"><span class="hljs-string">"CWE-571"</span></span>); } }</code> </pre> <br>  Dan itu dia.  Tidak diperlukan basis pelatihan sampel! <br><br>  Di masa depan, diagnostik harus diajarkan untuk memperhitungkan sejumlah pengecualian dan memahami bahwa Anda perlu bersumpah (A [0] == A [1-1]).  Namun, semua ini sangat mudah diprogram.  Tetapi hanya dengan dasar contoh untuk pelatihan, semuanya akan menjadi buruk. <br><br>  Perhatikan bahwa dalam kedua kasus sistem pengujian, penulisan dokumentasi, dan sebagainya masih akan diperlukan.  Namun, upaya untuk menciptakan diagnostik baru jelas berada di sisi pendekatan klasik, di mana aturannya hanya berupa kode yang sulit. <br><br>  Mari kita lihat beberapa aturan lain.  Misalnya, bahwa hasil dari beberapa fungsi harus digunakan.  Tidak masuk akal untuk memanggil mereka tanpa menggunakan hasilnya.  Berikut adalah beberapa fitur ini: <ul><li>  malloc </li><li>  memcmp </li><li>  string :: kosong </li></ul><br>  Secara umum, inilah yang dilakukan diagnostik <a href="https://www.viva64.com/ru/w/v530/">V530</a> di PVS-Studio. <br><br>  Jadi, kami ingin mencari panggilan ke fungsi seperti itu di mana hasil pekerjaan mereka tidak digunakan.  Untuk melakukan ini, Anda dapat menghasilkan banyak tes.  Dan kami pikir semuanya akan bekerja dengan baik.  Tetapi sekali lagi, tidak jelas mengapa ini perlu. <br><br>  Implementasi diagnostik V530 dengan semua pengecualian dalam alat analisa PVS-Studio adalah 258 baris kode, di mana 64 baris adalah komentar.  Plus ada tabel dengan penjelasan fungsi, di mana dicatat bahwa hasilnya harus digunakan.  Mengisi ulang tabel ini jauh lebih mudah daripada membuat contoh sintetis. <br><br>  Situasi akan lebih buruk dengan diagnostik yang menggunakan analisis aliran data.  Misalnya, penganalisa PVS-Studio dapat melacak nilai pointer, yang memungkinkan menemukan kebocoran memori seperti itu: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* BnNew() { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>[kBigIntSize]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(result, <span class="hljs-number"><span class="hljs-number">0</span></span>, kBigIntSize * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AndroidRSAPublicKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(crypto::RSAPrivateKey* key)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* n = BnNew(); .... RSAPublicKey pkey; pkey.len = kRSANumWords; pkey.exponent = <span class="hljs-number"><span class="hljs-number">65537</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Fixed public exponent pkey.n0inv = 0 - ModInverse(n0, 0x100000000LL); if (pkey.n0inv == 0) return kDummyRSAPublicKey; // &lt;= .... }</span></span></code> </pre> <br>  Contoh diambil dari artikel " <a href="https://www.viva64.com/ru/b/0555/">Chromium: kebocoran memori</a> ."  Jika kondisi <i>(pkey.n0inv == 0) terpenuhi</i> , maka fungsi keluar tanpa membebaskan buffer, penunjuk yang disimpan dalam variabel <i>n</i> . <br><br>  Dari sudut pandang PVS-Studio, tidak ada yang rumit.  Penganalisis mempelajari fungsi <i>BnNew</i> dan ingat bahwa itu mengembalikan pointer ke blok memori yang dialokasikan.  Dalam fungsi lain, ia memperhatikan bahwa suatu situasi dimungkinkan di mana buffer tidak dibebaskan, dan pointer ke sana hilang ketika fungsi keluar. <br><br>  Algoritma pelacakan nilai umum berfungsi.  Tidak masalah bagaimana kode ditulis.  Tidak masalah apa pun yang ada dalam fungsi yang tidak terkait dengan bekerja dengan pointer.  Algoritma bersifat universal dan diagnostik V773 menemukan banyak kesalahan dalam berbagai proyek.  Lihat betapa berbedanya <a href="https://www.viva64.com/ru/examples/v773/">fragmen kode di</a> mana kesalahan terdeteksi! <br><br>  Kami bukan ahli dalam pembelajaran mesin, tetapi tampaknya akan ada masalah besar.  Ada banyak cara Anda dapat menulis kode dengan kebocoran memori.  Bahkan jika mesin dilatih untuk melacak nilai variabel, perlu melatihnya untuk memahami bahwa ada panggilan fungsi. <br><br>  Ada kecurigaan bahwa begitu banyak contoh akan diperlukan untuk pelatihan sehingga tugas menjadi menakutkan.  Kami tidak mengatakan bahwa itu tidak dapat direalisasikan.  Kami ragu bahwa biaya untuk membuat analisa akan terbayar. <br><br>  <b>Analogi.</b>  Sebuah analogi muncul dalam pikiran dengan kalkulator, di mana alih-alih diagnostik, perlu untuk memprogram operasi aritmatika.  Kami yakin Anda dapat mengajarkan kalkulator berbasis ML untuk menambahkan angka dengan baik dengan memperkenalkan basis pengetahuan tentang hasil operasi 1 + 1 = 2, 1 + 2 = 3, 2 + 1 = 3, 100 + 200 = 300, dan seterusnya.  Seperti yang Anda ketahui, kelayakan pengembangan kalkulator semacam itu adalah pertanyaan besar (jika hibah tidak dialokasikan untuk itu :).  Kalkulator yang lebih sederhana, lebih cepat, lebih akurat, dan andal dapat ditulis menggunakan operasi "+" biasa dalam kode. <br><br>  <b>Kesimpulan</b>  Metode ini akan bekerja.  Tetapi untuk menggunakannya, menurut pendapat kami, tidak masuk akal secara praktis.  Pengembangan akan lebih memakan waktu, dan hasilnya kurang dapat diandalkan dan akurat, terutama jika menyangkut implementasi diagnostik yang kompleks berdasarkan analisis aliran data. <br><br><h3>  Belajar dari banyak sumber terbuka </h3><br>  Ya, kami sudah menemukan contoh sintetik manual, tetapi ada GitHub.  Anda dapat melacak riwayat commit dan mendapatkan pola perubahan / koreksi kode.  Kemudian Anda dapat menunjukkan tidak hanya bagian dari kode yang mencurigakan, tetapi bahkan mungkin menyarankan cara untuk memperbaikinya. <br><br>  Jika Anda berhenti pada tingkat detail ini, maka semuanya terlihat bagus.  Iblis, seperti biasa, ada dalam perinciannya.  Mari kita bicarakan detail ini. <br><br>  <b>Nuansa pertama.</b>  <b>Sumber data.</b> <br><br>  Suntingan di GitHub cukup kacau dan bervariasi.  Orang-orang sering terlalu malas untuk membuat komitmen atom dan membuat beberapa perubahan pada kode sekaligus.  Anda sendiri tahu bagaimana hal itu terjadi: mereka memperbaiki kesalahan, dan pada saat yang sama sedikit refactored ("Dan di sini saya akan menambahkan pemrosesan kasus seperti itu pada saat yang sama ...").  Meski begitu, mungkin tidak jelas bagi seseorang apakah perubahan ini terkait satu sama lain atau tidak. <br><br>  Masalahnya adalah bagaimana membedakan kesalahan aktual dari menambahkan fungsionalitas baru atau sesuatu yang lain.  Anda tentu saja dapat menanam 1.000 orang secara manual untuk menandai komitmen.  Orang harus menunjukkan bahwa mereka memperbaiki kesalahan di sini, refactoring di sini, fungsionalitas baru di sini, persyaratan berubah di sini, dan sebagainya. <br><br>  Apakah markup ini mungkin?  Mungkin  Namun perhatikan seberapa cepat perubahan itu terjadi.  Alih-alih "mempelajari algoritme itu sendiri berdasarkan GitHub", kami sudah membahas cara membuat teka-teki ratusan orang untuk waktu yang lama.  Biaya tenaga kerja dan biaya pembuatan alat meningkat tajam. <br><br>  Anda dapat mencoba mengidentifikasi secara otomatis di mana kesalahan itu diperbaiki.  Untuk melakukan ini, Anda harus menganalisis komentar tentang komit, memperhatikan suntingan lokal kecil, yang, kemungkinan besar, adalah revisi kesalahan.  Sulit untuk mengatakan seberapa baik Anda dapat secara otomatis mencari perbaikan bug.  Bagaimanapun, ini adalah tugas besar yang membutuhkan penelitian dan pemrograman terpisah. <br><br>  Jadi, kami belum mencapai pelatihan, tetapi sudah ada nuansa :). <br><br>  <b>Nuansa kedua.</b>  <b>Tertunda dalam pengembangan.</b> <br><br>  Analisis yang akan dilatih berdasarkan database seperti GitHub akan selalu mengalami sindrom seperti "keterbelakangan mental."  Ini karena bahasa pemrograman berubah seiring waktu. <br><br>  C # 8.0 <a href="https://www.viva64.com/ru/b/0631/">memperkenalkan</a> jenis Referensi Nullable untuk membantu menangani Pengecualian Referensi Null (NRE).  JDK 12 memperkenalkan pernyataan pergantian baru ( <a href="https://openjdk.java.net/jeps/325">JEP 325</a> ).  Dalam C ++ 17, menjadi mungkin untuk mengeksekusi konstruksi kondisional pada tahap kompilasi ( <a href="https://www.bfilipek.com/2018/03/ifconstexpr.html">constexpr if</a> ).  Dan sebagainya. <br><br>  Bahasa pemrograman berkembang.  Selain itu, seperti C ++ sangat cepat dan aktif.  Desain baru muncul di dalamnya, fungsi standar baru ditambahkan, dan sebagainya.  Seiring dengan fitur baru, pola kesalahan baru juga muncul yang kami juga ingin mengidentifikasi menggunakan analisis kode statis. <br><br>  Dan di sini metode pengajaran yang dipertimbangkan memiliki masalah: pola kesalahan mungkin sudah diketahui, ada keinginan untuk mengidentifikasi itu, tetapi tidak ada yang bisa dipelajari. <br><br>  Mari kita lihat masalah ini dengan contoh spesifik.  Berbasis rentang untuk loop muncul di C ++ 11.  Dan Anda dapat menulis kode berikut, mengulangi semua elemen dalam wadah: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) foo(num);</code> </pre> <br>  Siklus baru membawa serta pola kesalahan baru.  Jika wadah diubah di dalam loop, ini akan menyebabkan pembatalan iterator "bayangan". <br><br>  Pertimbangkan kode yang salah berikut ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Kompiler akan mengubahnya menjadi seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> __begin = begin(numbers), __end = end(numbers); __begin != __end; ++__begin) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = *__begin; numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Selama operasi <i>push_back</i> , <i>pembatalan __begin</i> dan <i>__end</i> iterators dapat terjadi jika alokasi memori di dalam vektor terjadi.  Hasilnya adalah perilaku program yang tidak ditentukan. <br><br>  Jadi, pola kesalahan telah lama dikenal dan dijelaskan dalam literatur.  Penganalisa PVS-Studio mendiagnosisnya menggunakan diagnostik <a href="https://www.viva64.com/ru/w/v789/">V789</a> dan telah menemukan <a href="https://www.viva64.com/ru/examples/v789/">kesalahan nyata</a> dalam proyek terbuka. <br><br>  Seberapa cepat akan ada cukup kode baru di GitHub untuk memperhatikan pola ini?  Pertanyaan bagus ... Anda harus mengerti bahwa jika range-based for loop muncul, ini tidak berarti bahwa semua programmer segera mulai menggunakannya secara masif.  Mungkin perlu bertahun-tahun sebelum banyak kode muncul menggunakan loop baru.  Selain itu, banyak kesalahan harus dilakukan, dan kemudian mereka harus diperbaiki sehingga algoritme dapat melihat pola dalam perubahan. <br><br>  Berapa tahun harus berlalu?  Lima?  Sepuluh? <br><br>  Sepuluh terlalu banyak, dan apakah kita pesimis?  Tidak semuanya.  Delapan tahun telah berlalu pada saat artikel ini ditulis, karena range-based for loop muncul di C ++ 11.  Namun sejauh ini, hanya <a href="https://www.viva64.com/ru/examples/v789/">tiga kasus</a> kesalahan semacam itu yang telah dituliskan dalam basis data kami.  Tiga kesalahan itu tidak banyak dan tidak sedikit.  Tidak ada kesimpulan yang harus diambil dari jumlah mereka.  Hal utama adalah Anda dapat mengonfirmasi bahwa pola kesalahan seperti itu nyata dan masuk akal untuk mendeteksinya. <br><br>  Sekarang bandingkan jumlah ini, misalnya, dengan pola kesalahan ini: <a href="https://www.viva64.com/ru/examples/v595/">pointer direferensikan sebelum verifikasi</a> .  Secara total, ketika memeriksa proyek sumber terbuka, kami telah mengidentifikasi 1716 kasus seperti itu. <br><br>  Mungkin Anda seharusnya tidak mencari kesalahan loop berbasis sama sekali?  Tidak.  Hanya programmer yang inersia, dan operator ini sangat lambat mendapatkan popularitas.  Secara bertahap, akan ada banyak kode dengan partisipasinya, dan karenanya, juga akan ada lebih banyak kesalahan. <br><br>  Kemungkinan besar, ini akan terjadi hanya setelah 10-15 tahun dari saat C ++ 11 muncul.  Dan sekarang menjadi pertanyaan filosofis.  Sudah mengetahui pola kesalahan, kita hanya akan menunggu selama bertahun-tahun sampai banyak kesalahan menumpuk di proyek terbuka? <br><br>  Jika jawabannya "ya", maka mungkin untuk secara wajar mendiagnosis semua analisis berdasarkan ML, diagnosis "keterbelakangan mental". <br><br>  Jika jawabannya tidak, lalu apa yang harus saya lakukan?  Tidak ada contoh.  Untuk menulisnya secara manual?  Tapi kemudian kita kembali ke bab sebelumnya, di mana kami menganggap menulis seseorang banyak contoh untuk belajar. <br><br>  Ini bisa dilakukan, tetapi sekali lagi muncul pertanyaan tentang kemanfaatan.  Penerapan diagnostik V789 dengan semua pengecualian dalam penganalisa PVS-Studio hanya 118 baris kode, di mana 13 baris adalah komentar.  Yaitu  Ini adalah diagnosis yang sangat sederhana yang dapat dengan mudah diambil dan diprogram dengan cara klasik. <br><br>  Situasi serupa akan terjadi dengan inovasi lain yang muncul dalam bahasa lain.  Seperti yang mereka katakan, ada sesuatu untuk dipikirkan. <br><br>  <b>Nuansa ketiga.</b>  <b>Dokumentasi</b> <br><br>  Komponen penting dari penganalisa statis adalah dokumentasi yang menjelaskan setiap diagnostik.  Tanpa itu, menggunakan alat analisa akan sangat sulit atau bahkan tidak mungkin.  Dalam <a href="https://www.viva64.com/ru/w/">dokumentasi</a> untuk PVS-Studio, kami memiliki deskripsi masing-masing diagnostik, yang memberikan contoh kode yang salah dan cara memperbaikinya.  Ada juga tautan ke <a href="https://cwe.mitre.org/">CWE di</a> mana Anda dapat membaca deskripsi alternatif masalah.  Dan sama saja, terkadang ada sesuatu yang tidak bisa dipahami oleh pengguna, dan mereka menanyakan pertanyaan klarifikasi kepada kami. <br><br>  Dalam kasus analisis statis, yang didasarkan pada algoritma pembelajaran mesin, masalah dokumentasi entah bagaimana ditutup.  Diasumsikan bahwa penganalisa hanya menunjukkan tempat yang tampaknya mencurigakan baginya dan, mungkin, bahkan menyarankan cara memperbaikinya.  Keputusan untuk melakukan perubahan atau tidak tetap ada pada orang tersebut.  Dan di sini ... ahem ... Tidak mudah untuk membuat keputusan, tidak bisa membaca, atas dasar di mana penganalisa kelihatannya curiga terhadap satu atau tempat lain dalam kode. <br><br>  Tentu saja, dalam beberapa kasus semuanya akan jelas.  Misalkan penganalisa menunjuk ke kode ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Dan akan menawarkan untuk menggantinya dengan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src) + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Segera jelas bahwa programmer menutup dan menambahkan 1 ke tempat yang salah.  Akibatnya, lebih sedikit memori yang akan dialokasikan. <br><br>  Di sini, tanpa dokumentasi, semuanya jelas.  Namun, ini tidak selalu menjadi masalah. <br><br>  Bayangkan bahwa penganalisa secara diam-diam menunjuk ke kode ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  Dan menyarankan untuk mengubah jenis nilai pengembalian dari char ke int: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  Tidak ada dokumentasi untuk peringatan itu.  Dan tampaknya, teks peringatan itu sendiri, seperti yang kita pahami, tidak akan menjadi baik, jika kita berbicara tentang penganalisa yang sepenuhnya independen. <br><br>  Apa yang harus dilakukan  Apa bedanya?  Haruskah saya melakukan penggantian seperti itu? <br><br>  Pada prinsipnya, di sini Anda dapat mengambil risiko dan setuju untuk memperbaiki kode.  Meskipun menerima pengeditan tanpa memahaminya, ini adalah praktik biasa ... :) Anda dapat melihat deskripsi fungsi <a href="http://www.cplusplus.com/reference/cstring/memcmp/"><i>memcmp</i></a> dan membaca bahwa fungsi tersebut benar-benar mengembalikan nilai dari tipe <i>int</i> : 0, lebih besar dari nol dan kurang dari nol.  Tetapi semua sama, mungkin tidak jelas mengapa harus melakukan perubahan jika kode sudah bekerja dengan sukses. <br><br>  Sekarang, jika Anda tidak tahu apa gunanya hasil edit tersebut, lihat <a href="https://www.viva64.com/ru/w/v642/">deskripsi</a> diagnostik <a href="https://www.viva64.com/ru/w/v642/">V642</a> .  Segera menjadi jelas bahwa ini adalah kesalahan nyata.  Selain itu, dapat menyebabkan kerentanan. <br><br>  Mungkin contohnya tampak tidak meyakinkan.  Bagaimanapun, penganalisa mengusulkan kode yang mungkin lebih baik.  Ok  Mari kita lihat contoh pseudocode lain, kali ini, untuk perubahan, di Jawa. <br><br><pre> <code class="java hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj.state = <span class="hljs-number"><span class="hljs-number">200</span></span>; out.writeObject(obj); out.close();</code> </pre> <br>  Ada beberapa jenis objek.  Ini adalah serial.  Kemudian keadaan objek berubah, dan serialisasi lagi.  Segalanya tampak baik-baik saja.  Sekarang bayangkan penganalisa tiba-tiba tidak menyukai kode ini, dan ia menyarankan untuk menggantinya dengan: <br><br><pre> <code class="java hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); <span class="hljs-comment"><span class="hljs-comment">//    obj.state = 200; out.writeObject(obj); out.close();</span></span></code> </pre> <br>  Alih-alih mengubah objek dan merekam ulang, objek baru dibuat dan sudah serial. <br><br>  Tidak ada deskripsi masalah.  Tidak ada dokumentasi.  Kode menjadi lebih panjang.  Untuk beberapa alasan, penciptaan objek baru telah ditambahkan.  Apakah Anda siap melakukan pengeditan seperti itu dalam kode Anda? <br><br>  Anda akan mengatakan bahwa itu tidak jelas.  Memang tidak jelas.  Dan itu akan menjadi tidak bisa dipahami sepanjang waktu.  Bekerja dengan penganalisa "sunyi" seperti itu akan menjadi studi tanpa akhir dalam upaya untuk memahami mengapa penganalisa tidak menyukai sesuatu. <br><br>  Jika ada dokumentasi, maka semuanya menjadi transparan.  Kelas <i>java.io.ObjectOuputStream</i> , yang digunakan untuk serialisasi, membuat cache objek yang dapat ditulis.  Ini berarti bahwa objek yang sama tidak akan di-serialkan dua kali.  Setelah kelas membuat serial objek, dan kedua kalinya ia hanya menulis tautan ke objek pertama yang sama ke dalam aliran.  Baca selengkapnya: <a href="https://www.viva64.com/ru/w/v6076/">V6076</a> - Serialisasi serialisasi akan menggunakan keadaan objek yang di-cache dari serialisasi pertama. <br><br>  Kami berharap kami dapat menjelaskan pentingnya memiliki dokumentasi.  Dan sekarang pertanyaannya.  Bagaimana dokumentasi untuk alat analisis berdasarkan ML muncul? <br><br>  Ketika penganalisa kode klasik dikembangkan, maka semuanya sederhana dan jelas.  Ada pola kesalahan tertentu.  Kami menjelaskannya dalam dokumentasi dan menerapkan diagnostik. <br><br>  Dalam kasus ML, yang terjadi adalah sebaliknya.  Ya, penganalisa dapat melihat anomali dalam kode dan menunjukkannya.  Tapi dia tidak tahu apa-apa tentang esensi cacat.  Dia tidak mengerti dan tidak akan mengatakan mengapa kode tidak dapat ditulis seperti itu.  Ini adalah abstraksi tingkat tinggi.  Kemudian penganalisa juga harus belajar membaca dan <b>memahami</b> dokumentasi untuk fungsinya. <br><br>  Seperti yang saya katakan, karena topik dokumentasi tercakup dalam artikel tentang pembelajaran mesin, kami tidak siap untuk berbicara lebih lanjut.  Hanya nuansa besar lain yang kami bawa untuk ditinjau. <br><br>  <b>Catatan</b>  Dapat dikatakan bahwa dokumentasi itu opsional.  Penganalisa dapat mengarah ke banyak contoh perbaikan pada GitHub dan seseorang, melihat komitmen dan komentar pada mereka, akan mencari tahu apa apa.  Ya itu.  Namun idenya tidak terlihat menarik.  Alih-alih asisten, penganalisa bertindak sebagai alat yang akan lebih membingungkan programmer. <br><br>  <b>Nuansa keempat.</b>  <b>Bahasa yang sangat terspesialisasi.</b> <br><br>  Pendekatan yang diuraikan tidak berlaku untuk bahasa yang sangat terspesialisasi yang analisis statisnya juga bisa sangat berguna.  Alasannya adalah bahwa GitHub dan sumber lainnya tidak memiliki basis kode sumber yang cukup besar untuk memberikan pelatihan yang efektif. <br><br>  Pertimbangkan ini dengan contoh khusus.  Untuk memulai, buka GitHub dan cari repositori untuk bahasa Java yang populer. <br><br>  Hasil: bahasa: "Java": <b>3.128.884</b> hasil repositori yang tersedia <br><br>  Sekarang mari kita ambil bahasa khusus "1C Enterprise" yang digunakan dalam aplikasi akuntansi yang dikeluarkan oleh perusahaan Rusia <a href="https://ru.wikipedia.org/wiki/1%25D0%25A1">1C</a> . <br><br>  Hasil: bahasa: â€œ1C Enterpriseâ€: <b>551</b> hasil repositori yang tersedia <br><br>  Mungkin analisa untuk bahasa ini tidak diperlukan?  Dibutuhkan.  Ada kebutuhan praktis untuk analisis program semacam itu, dan analisis yang sesuai sudah ada.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalnya, ada Plugin SonarQube 1C (BSL) yang diproduksi oleh </font></font><a href="https://silverbulleters.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Silver Bullet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya pikir tidak diperlukan penjelasan khusus mengapa pendekatan pembelajaran mesin akan sulit untuk bahasa khusus. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuansa kelima. C, C ++, #include</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel yang dikhususkan untuk penelitian di bidang analisis statis kode berbasis ML condong ke bahasa seperti Java, JavaScript, Python. Ini dijelaskan oleh popularitas mereka yang ekstrem. Tapi bahasa C dan C ++ entah bagaimana memotong, meskipun mereka tentu tidak bisa disebut tidak populer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memiliki hipotesis bahwa ini bukan masalah popularitas / janji, tetapi ada masalah dengan bahasa C dan C ++. Dan sekarang kita akan "menarik" satu masalah yang tidak nyaman untuk ditinjau.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">File c / cpp abstrak bisa sangat sulit untuk dikompilasi. Setidaknya, itu tidak akan berfungsi untuk mengunduh proyek dari GitHub, pilih beberapa file cpp dan cukup kompilasi. Sekarang kami akan menjelaskan bagaimana semua ini berhubungan dengan ML. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, kami ingin melatih penganalisa. Kami mengunduh proyek dari GitHub. Kami tahu tambalan dan menganggap itu memperbaiki kesalahan. Kami ingin hasil edit ini menjadi salah satu contoh untuk pelatihan. Dengan kata lain, kami memiliki file .cpp sebelum dan sesudah diedit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sinilah masalahnya dimulai. Tidak cukup hanya mempelajari koreksi. Anda harus memiliki konteks yang lengkap. Anda perlu mengetahui deskripsi kelas yang digunakan, Anda perlu tahu prototipe fungsi yang digunakan, Anda perlu tahu bagaimana makro dibuka, dan sebagainya. Dan untuk ini, Anda perlu melakukan </font><a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D0%25BE%25D1%2580_%25D0%25A1%25D0%25B8"><font style="vertical-align: inherit;">preprocessing</font></a><font style="vertical-align: inherit;"> penuh</font></font><a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D0%25BE%25D1%2580_%25D0%25A1%25D0%25B8"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">file. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertimbangkan sebuah contoh. </font><font style="vertical-align: inherit;">Pada awalnya, kode itu terlihat seperti ini:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_name == <span class="hljs-string"><span class="hljs-string">"ML"</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Itu diperbaiki seperti ini: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(m_name, <span class="hljs-string"><span class="hljs-string">"ML"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haruskah saya mulai belajar berdasarkan kasus ini, di masa depan saya sarankan mengganti </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(x == "y")</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan strcmp (x, "y")? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertanyaan ini tidak dapat dijawab tanpa mengetahui bagaimana anggota </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_name dideklarasikan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di kelas. </font><font style="vertical-align: inherit;">Mungkin ada, misalnya, opsi seperti:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *m_name; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_name; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengeditan akan dilakukan jika kita berbicara tentang indeks biasa. Jika Anda tidak mempertimbangkan jenis variabel, Anda dapat belajar memberikan peringatan berbahaya bersama dengan peringatan yang berguna (untuk kasus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: string</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deklarasi kelas biasanya ditemukan dalam file header .h. Jadi kami sampai pada kebutuhan untuk melakukan preprocessing untuk mendapatkan semua informasi yang diperlukan. Ini sangat, sangat penting untuk C dan C ++. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika seseorang mengatakan bahwa Anda dapat melakukannya tanpa preprocessing, maka ia adalah penipu atau tidak cukup akrab dengan bahasa C atau C ++.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengumpulkan semua informasi yang diperlukan, Anda harus melakukan preproses dengan benar. Untuk melakukan ini, Anda perlu tahu di mana dan file header mana yang terletak, makro mana yang ditetapkan selama proses pembuatan. Untuk melakukan ini, Anda perlu tahu bagaimana file cpp tertentu dibangun. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini masalahnya. Anda tidak bisa hanya mengambil dan mengkompilasi file (atau lebih tepatnya, tentukan kunci untuk kompiler sehingga menghasilkan file preprocessed). Anda perlu mencari tahu bagaimana file ini dikompilasi. Informasi ini ada dalam skrip build, tetapi inilah cara mengeluarkannya, dalam kasus umum, tugasnya sangat sulit.</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e95/be0/9dd/e95be09ddb94d84555c134d961ce9566.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apalagi banyak proyek di GitHub yang berantakan. Jika Anda mengambil proyek abstrak dari sana, Anda sering harus mengotak-atiknya untuk mengkompilasinya. Beberapa perpustakaan tidak ada dan perlu ditemukan dan diunduh secara manual. Ia menggunakan semacam sistem perakitan samopisny, yang harus ditangani. Mungkin apa saja. Terkadang proyek yang diunduh, pada prinsipnya, menolak untuk berkumpul dan perlu â€œdimodifikasi dengan fileâ€. Tidak perlu hanya mengambil proyek dan secara otomatis mendapatkan representasi preprocessed (.i) mereka untuk file .cpp. Ini bahkan bisa sulit dilakukan secara manual.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisa dibilang, masalah dengan proyek yang tidak dirakit bisa dimengerti, tapi tidak menakutkan. Mari kita bekerja hanya dengan proyek-proyek yang dapat dirakit. Lagi pula, tugas preprocessing file tertentu tetap. Dan kami tidak akan mengatakan apa-apa tentang kasus-kasus itu ketika beberapa kompiler khusus akan digunakan, misalnya, untuk sistem embedded. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, masalah yang dijelaskan tidak dapat diatasi. Namun, semua ini sangat sulit dan memakan waktu. Dalam kasus C dan C ++, kode sumber di GitHub saja tidak menghasilkan apa-apa. Sejumlah besar pekerjaan perlu dilakukan untuk mempelajari cara memulai kompiler secara otomatis. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jika pembaca masih tidak memahami masalah, maka kami sarankan agar ia melakukan percobaan berikut. Ambil sepuluh proyek C ++ berukuran sedang dari GitHub dan cobalah untuk mengompilasinya, lalu dapatkan versi pra-prosesnya untuk file .cpp. Setelah itu, pertanyaan tentang kompleksitas tugas ini akan hilang :). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahasa lain mungkin memiliki masalah yang sama, tetapi dalam C dan C ++ mereka terutama diucapkan. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuansa keenam. Harga menghilangkan positif palsu.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Analisis statis cenderung menghasilkan positif palsu dan harus terus memperbaiki diagnostik untuk mengurangi jumlah mereka. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita kembali ke diagnostik </font><a href="https://www.viva64.com/ru/w/v789/"><font style="vertical-align: inherit;">V789 yang</font></a><font style="vertical-align: inherit;"> telah dibahas sebelumnya</font></font><a href="https://www.viva64.com/ru/w/v789/"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengungkapkan perubahan kontainer di dalam Rentang berbasis untuk loop. Misalkan kita tidak cukup berhati-hati dalam perkembangannya, dan klien melaporkan positif palsu. Dia menulis bahwa penganalisa tidak memperhitungkan skenario ketika, setelah memodifikasi wadah, siklus berakhir, dan karena itu tidak ada masalah. Dan dia memberikan contoh kode berikut, di mana penganalisa menghasilkan false positive:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { numbers.push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">// , , return } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya, ini cacat. Dalam analisa klasik, eliminasi ini sangat cepat dan murah. Dalam PVS-Studio, implementasi pengecualian ini terdiri dari 26 baris kode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cacat ini dapat dihilangkan dalam kasus ketika analisa dibangun pada algoritma pembelajaran. Tentunya, Anda dapat menyelesaikannya dengan membuat puluhan atau ratusan contoh kode yang harus dianggap benar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini sekali lagi, pertanyaannya bukan kelayakan, tetapi kepraktisan. Ada kecurigaan bahwa perlawanan terhadap kesalahan positif spesifik yang mengganggu pelanggan jauh lebih mahal dalam kasus ML.</font></font> Yaitu<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dukungan pelanggan dalam hal menghilangkan kesalahan positif akan membutuhkan lebih banyak uang. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuansa ketujuh. </font><font style="vertical-align: inherit;">Fitur yang jarang digunakan dan ekor yang panjang. </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelumnya, masalah bahasa yang sangat khusus dipertimbangkan, yang mungkin tidak ada kode sumber yang cukup untuk belajar. </font><font style="vertical-align: inherit;">Masalah serupa dengan fungsi yang jarang digunakan (sistem, WinAPI, dari perpustakaan populer, dll.). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kita berbicara tentang fungsi-fungsi bahasa C seperti </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strcmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , maka ada dasar untuk belajar. </font><font style="vertical-align: inherit;">GitHub, hasil kode yang tersedia:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> strcmp - 40.462.158 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stricmp - 1.256.053 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya, ada banyak contoh penggunaan. </font><font style="vertical-align: inherit;">Mungkin penganalisa akan belajar memperhatikan, misalnya, pola berikut:</font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sungguh aneh jika sebuah string dibandingkan dengan sendirinya. </font><font style="vertical-align: inherit;">Ini diperbaiki.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aneh jika salah satu petunjuknya adalah NULL. </font><font style="vertical-align: inherit;">Ini diperbaiki.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sungguh aneh bahwa hasil dari fungsi ini tidak digunakan. </font><font style="vertical-align: inherit;">Ini diperbaiki.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan sebagainya. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah semuanya baik-baik saja? </font><font style="vertical-align: inherit;">Tidak. </font><font style="vertical-align: inherit;">Di sini kita dihadapkan dengan "ekor panjang". </font><font style="vertical-align: inherit;">Secara singkat, inti dari "ekor panjang" adalah sebagai berikut. </font><font style="vertical-align: inherit;">Tidak praktis menjual di toko buku hanya Top50 buku paling populer dan saat ini dibaca. </font><font style="vertical-align: inherit;">Ya, setiap buku seperti itu akan diperoleh, katakanlah, 100 kali lebih sering daripada buku yang tidak ada dalam daftar ini. </font><font style="vertical-align: inherit;">Namun, sebagian besar pendapatan akan berasal dari buku-buku lain, yang, seperti yang mereka katakan, temukan pembacanya. </font><font style="vertical-align: inherit;">Misalnya, toko online Amazon.com menghasilkan lebih dari setengah laba dari apa yang melebihi 130 ribu "item paling populer." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada beberapa fitur yang populer dan beberapa di antaranya. </font><font style="vertical-align: inherit;">Ada yang tidak populer, tetapi ada banyak dari mereka. </font><font style="vertical-align: inherit;">Misalnya, masih ada varietas fungsi perbandingan string seperti itu:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> g_ascii_strncasecmp - 35.695 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lstrcmpiA - 27.512 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> _wcsicmp_l - 5,737 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> _strnicmp_l - 5,848 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> _mbscmp_l - 2,458 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dll. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat, mereka lebih jarang digunakan, tetapi Anda masih bisa membuat kesalahan yang sama saat menggunakannya. </font><font style="vertical-align: inherit;">Ada terlalu sedikit contoh untuk mengidentifikasi pola. </font><font style="vertical-align: inherit;">Namun, seseorang tidak dapat mengabaikan fungsi-fungsi ini. </font><font style="vertical-align: inherit;">Secara terpisah, mereka jarang digunakan, tetapi dalam jumlah penggunaannya, banyak kode telah ditulis yang berguna untuk memeriksa. </font><font style="vertical-align: inherit;">Di sinilah "ekor panjang" memanifestasikan dirinya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di PVS-Studio, kami membubuhi keterangan fungsi secara manual. </font><font style="vertical-align: inherit;">Misalnya, untuk C dan C ++, sekitar 7200 fungsi saat ini dilabeli. </font><font style="vertical-align: inherit;">Penandaan tunduk pada:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Winapi </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C library standar </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perpustakaan templat standar (STL), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> glibc (Perpustakaan GNU C) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qt </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mfc </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zlib </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> libpng </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Openssl </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dll. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di satu sisi, ini sepertinya jalan buntu. Tidak mungkin untuk membubuhi keterangan segalanya. Di sisi lain, ini berfungsi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang pertanyaannya. Apa manfaat ML? Keuntungan yang signifikan tidak terlihat, tetapi kesulitan terlihat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat mengatakan bahwa algoritma yang dibangun di atas ML sendiri akan mengungkapkan pola dengan fungsi yang sering digunakan dan mereka tidak harus ditandai. Ya itu benar. Namun, tidak ada masalah secara independen menandai fungsi populer seperti </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strcmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan ekor panjang, masalah dimulai. Anda bisa berlatih dengan membuat contoh-contoh sintetis. Namun, di sini kita kembali ke bagian artikel di mana kami menganggap bahwa lebih mudah dan lebih cepat untuk menulis diagnostik klasik, daripada menghasilkan banyak contoh.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambil contoh fungsi seperti </font></font><a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_fread_nolock</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tentu saja, ini lebih jarang digunakan daripada rasa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">takut</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tetapi ketika menggunakannya, Anda bisa membuat semua kesalahan yang sama. </font><font style="vertical-align: inherit;">Misalnya, buffer harus cukup besar. </font><font style="vertical-align: inherit;">Ukuran ini seharusnya tidak kurang dari hasil mengalikan argumen kedua dan ketiga. </font><font style="vertical-align: inherit;">Yaitu, saya ingin mendeteksi kode yang salah:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buffer[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n = _fread_nolock(buffer, size_of(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-number"><span class="hljs-number">100</span></span>, stream);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berikut ini penjelasan fungsi ini dalam PVS-Studio: </font></font><br><br><pre> <code class="cpp hljs">C_<span class="hljs-string"><span class="hljs-string">"size_t _fread_nolock"</span></span> <span class="hljs-string"><span class="hljs-string">"(void * _DstBuf, size_t _ElementSize, size_t _Count, FILE * _File);"</span></span> ADD(HAVE_STATE | RET_SKIP | F_MODIFY_PTR_1, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-string"><span class="hljs-string">"_fread_nolock"</span></span>, POINTER_1, BYTE_COUNT, COUNT, POINTER_2). Add_Read(from_2_3, to_return, buf_1). Add_DataSafetyStatusRelations(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekilas, anotasi semacam itu mungkin terlihat rumit, tetapi, pada kenyataannya, ketika Anda mulai menulisnya, itu menjadi sederhana. </font><font style="vertical-align: inherit;">Plus, perlu diingat bahwa ini hanya kode tulis. </font><font style="vertical-align: inherit;">Menulis dan lupa. </font><font style="vertical-align: inherit;">Anotasi jarang berubah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang mari kita bicara tentang fungsi ini dalam hal ML. </font><font style="vertical-align: inherit;">GitHub tidak akan membantu kami. </font><font style="vertical-align: inherit;">Ada sekitar 15.000 referensi untuk fungsi ini. </font><font style="vertical-align: inherit;">Bahkan ada kode yang kurang masuk akal. </font><font style="vertical-align: inherit;">Bagian penting dari hasil pencarian serupa:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> fread_unlocked _fread_nolock</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa saja pilihannya? </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jangan lakukan apa pun. </font><font style="vertical-align: inherit;">Ini adalah jalan menuju ke mana-mana.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latih penganalisa dengan menulis ratusan contoh untuk fungsi ini saja, sehingga penganalisa memahami hubungan antara ukuran buffer dan argumen lainnya. </font><font style="vertical-align: inherit;">Ya, Anda dapat melakukan ini, tetapi secara ekonomi tidak rasional. </font><font style="vertical-align: inherit;">Ini adalah jalan menuju ke mana-mana.</font></font></li><li>   ,  ,       . ,  .   ML       :).        . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat, ML dan ekor panjang fungsi yang jarang digunakan tidak digabungkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini, orang-orang yang terkait dengan tema ML keberatan dengan kami dan mengatakan bahwa kami tidak mempertimbangkan opsi ketika analis akan mempelajari fungsi dan menarik kesimpulan tentang apa yang mereka lakukan. Di sini, tampaknya, entah kita tidak memahami para ahli, atau mereka tidak mengerti kita. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi tubuh mungkin tidak diketahui. Misalnya, itu mungkin fungsi terkait WinAPI. Jika ini adalah fungsi yang jarang digunakan, lalu bagaimana penganalisa memahami apa fungsinya? Kita dapat berfantasi bahwa selama pelatihan analis akan menggunakan Google itu sendiri, menemukan deskripsi fungsi, membaca dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memahaminya</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Selain itu, perlu untuk mengambil kesimpulan tingkat tinggi dari dokumentasi. Dalam deskripsi </font></font><a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_fread_nolock</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak ada yang dikatakan tentang hubungan antara ukuran buffer, argumen kedua dan ketiga. Perbandingan ini harus disimpulkan oleh kecerdasan buatan secara independen, berdasarkan pada pemahaman prinsip-prinsip umum pemrograman dan bagaimana bahasa C ++ bekerja. Tampaknya dengan serius semua ini akan mungkin untuk dipikirkan dalam 20 tahun ke depan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Badan fungsi mungkin tersedia, tetapi mungkin tidak ada artinya dari ini. Pertimbangkan fungsi seperti </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memmove</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini sering diimplementasikan seperti ini:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memmove</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dest, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __builtin___memmove_chk(dest, src, len, __builtin_object_size(dest, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan apakah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__builtin___memmove_chk</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? Ini adalah fungsi intrinsik yang diimplementasikan oleh kompiler itu sendiri. Fungsi ini tidak memiliki kode sumber. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atau </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memmove</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mungkin terlihat seperti ini: </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versi pertama yang muncul di assembler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Anda dapat mengajarkan penganalisa untuk memahami varian assembler yang berbeda, tetapi ada sesuatu yang tidak benar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ok, terkadang fungsi tubuh benar-benar terkenal. Selain itu, fungsi tubuh dalam kode pengguna juga dikenal. Tampaknya dalam hal ini, ML mendapatkan keuntungan luar biasa dengan membaca dan memahami apa yang semua fungsi ini lakukan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, dalam kasus ini juga, kami penuh pesimisme. Tugas ini terlalu rumit. Sulit bagi seseorang. Ingat betapa sulitnya bagi Anda untuk memahami kode yang tidak Anda tulis. Jika ini sulit bagi manusia, mengapa tugas ini mudah untuk AI? Sebenarnya, AI memiliki masalah besar dalam memahami konsep tingkat tinggi. Jika kita berbicara tentang memahami kode, maka kita tidak dapat melakukannya tanpa kemampuan untuk mengabstraksi dari detail implementasi dan mempertimbangkan algoritma pada level tinggi. Tampaknya di sini lagi selama 20 tahun Anda dapat menunda diskusi. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuansa lain.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ada poin lain yang juga harus diperhitungkan, tapi yang kita pikirkan tidak hati-hati. Dan artikel itu sudah diseret. Karena itu, kami secara singkat menuliskan beberapa nuansa lagi, membiarkannya kepada pembaca untuk dipikirkan.</font></font><ul><li> <b> </b> .   ,  ,      .           ,    -     . .  C++         <a href="http://www.cplusplus.com/reference/memory/auto_ptr/"><i>auto_ptr</i></a> .          <i>unique_ptr</i> . </li><li> <b> </b> .  ,   C  C++   ,  <a href="https://www.viva64.com/ru/t/0012/"> </a> .  ,         .    ,     . ,  <i>long</i>  Windows 32/64    32 .    Linux       32/64      .    ,           .       -.  , ,  .       ,      (   ).     ,       . </li><li> <b> </b> .     ML,   ,  ,    .  Yaitu     ,   â€” ,    ,   .     ,       .    ,     ,   â€” ,  .          .      ,    /  , ,   ,       .        .   : " <a href="https://www.viva64.com/ru/b/0612/">   PVS-Studio:    </a> ".       ,   , . </li></ul><br><h2>  </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak menyangkal prospek pembelajaran mesin, termasuk dalam tugas analisis kode statis. Ada potensi untuk menggunakan ML dalam masalah pencarian kesalahan ketik, saat memfilter pesan palsu, dalam mencari pola kesalahan baru (belum dijelaskan di mana pun), dan sebagainya. Namun, kami sama sekali tidak berbagi optimisme dengan artikel-artikel tentang ML dalam masalah analisis kode yang jenuh. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam artikel tersebut, kami menjelaskan beberapa masalah yang harus kami selesaikan jika menggunakan ML sebagai basis. Nuansa yang dijelaskan sebagian besar meniadakan manfaat dari pendekatan baru, apalagi, pendekatan klasik lama untuk penerapan analisis lebih menguntungkan dan lebih layak secara ekonomi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menariknya, artikel dari penganut metodologi ML tidak menyebutkan perangkap ini. </font><font style="vertical-align: inherit;">Namun, ini tidak mengejutkan. </font><font style="vertical-align: inherit;">Tema ML terlalu hype sekarang dan aneh untuk diharapkan dari para apologisnya penilaian seimbang penerapannya dalam tugas-tugas analisis kode statis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari sudut pandang kami, pembelajaran mesin akan menempati ceruk dalam teknologi yang digunakan dalam analisis statis, bersama dengan analisis aliran kontrol, perhitungan simbolik, dan sebagainya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metodologi analisis statis mungkin mendapat manfaat dari penerapan ML, tetapi jangan melebih-lebihkan kemampuan teknologi ini.</font></font><br><br><h2>  PS </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena artikel tersebut pada umumnya kritis, seseorang mungkin berpikir bahwa kita </font><font style="vertical-align: inherit;">takut akan hal </font><font style="vertical-align: inherit;">baru dan bagaimana </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D1%2583%25D0%25B4%25D0%25B4%25D0%25B8%25D1%2582%25D1%258B"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luddit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berperang melawan ML, takut kehilangan pasar untuk alat analisis statis.</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/659/1f4/7fa/6591f47faa384c2ac9472bc1f5eeacb9.png" alt="Unicorn Luddite"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak, kami tidak takut. Kami hanya tidak melihat alasan untuk mengeluarkan uang untuk pendekatan yang tidak efisien dalam pengembangan alat analisa kode PVS-Studio. Dalam satu atau lain bentuk, kami akan mengadopsi ML. Selain itu, beberapa diagnostik sudah mengandung elemen algoritma belajar mandiri. Namun, kami pasti akan sangat konservatif dan hanya mengambil apa yang jelas akan memiliki efek yang lebih besar daripada pendekatan klasik berdasarkan loop dan if-ah :). Bagaimanapun, kita perlu membuat alat yang efektif, dan tidak menghasilkan dana :). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel itu ditulis dengan alasan semakin banyak pertanyaan diajukan pada topik yang dibahas, dan saya ingin memiliki artikel jawaban, meletakkan segala sesuatu di tempatnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terima kasih atas perhatian anda Dan kami menawarkan untuk berkenalan dengan artikel " </font></font><a href="https://www.viva64.com/ru/b/0687/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alasan untuk memperkenalkan analisa kode statis PVS-Studio ke dalam proses pengembangan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ."</font></font><br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/484202/"><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Andrey Karpov, Victoria Khanieva. </font></font><a href="https://habr.com/en/company/pvs-studio/blog/484202/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembelajaran Mesin dalam Analisis Statis Kode Sumber Program</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484208/">https://habr.com/ru/post/id484208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484198/index.html">Sisi sebaliknya dari koin: siapa yang menang dan kalah pada pertumbuhan saham Tesla</a></li>
<li><a href="../id484200/index.html">Cara menetapkan tujuan untuk mencapainya</a></li>
<li><a href="../id484202/index.html">Pembelajaran Mesin dalam Analisis Statis Kode Sumber Program</a></li>
<li><a href="../id484204/index.html">FTCODE ransomware tanpa fileless sekarang mencuri akun</a></li>
<li><a href="../id484206/index.html">Penggunaan mixin di Dart</a></li>
<li><a href="../id484212/index.html">Barang gratis untuk karma - kisah startup Belarusia yang mengubah prinsip konsumsi</a></li>
<li><a href="../id484214/index.html">Tensor dalam TensorFlow</a></li>
<li><a href="../id484216/index.html">Konferensi Zabbix kedua di Rusia: pendaftaran dan tanggal-tanggal penting</a></li>
<li><a href="../id484218/index.html">Kami mengoptimalkan otomatisasi: cara kami mempercepat autotest sebanyak 3-4 kali, menjaga perkembangan lama</a></li>
<li><a href="../id484220/index.html">Sudahkah Anda memesan pengiriman? Bagaimana Crossroads mengirimkan 6.000 pesanan per hari</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>