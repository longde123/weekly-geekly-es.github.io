<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôéÔ∏è üôä üë®‚Äçüíº Teil 6: MemTest86 + nach RISC-V portieren üßê üí≥ üö£üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wahrscheinlich m√ºssen nur wenige IT-Mitarbeiter erkl√§ren, was Memtest86 + ist - vielleicht ist es bereits mehr oder weniger zum Standard beim Testen v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teil 6: MemTest86 + nach RISC-V portieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484026/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ne/fb/ha/nefbhar5ihkfmvccfwp0jqrm78u.png"></div><br><p> Wahrscheinlich m√ºssen nur wenige IT-Mitarbeiter erkl√§ren, was Memtest86 + ist - vielleicht ist es bereits mehr oder weniger zum Standard beim Testen von RAM auf einem PC geworden.  Als ich in einem der <a href="https://habr.com/ru/post/459470/">vorherigen Teile</a> auf eine kaputte Speicherleiste stie√ü, die mit dem Board geliefert wurde, schien dies (zusammen mit einem DDR2-f√§higen Netbook) eine offensichtliche L√∂sung zu sein.  Eine andere Frage ist, dass dort der instabile Betrieb des Systems im Prinzip mit blo√üem Auge sichtbar war.  In schwierigeren F√§llen habe ich geh√∂rt, dass dieses Tool zus√§tzlich zum banalen ‚ÄûAbh√∂ren‚Äú von Speicherzellen ins Unendliche einige spezielle Datenmuster verwendet, bei denen Fehler im DDR-Betrieb mit gr√∂√üerer Wahrscheinlichkeit erkannt werden.  Im Allgemeinen eine wunderbare Sache, es ist schade, dass auch im Namen hei√üt: 86 - "Nur f√ºr x86-kompatible Systeme."  Oder nicht? </p><br><p>  Unter dem Schnitt sehen Sie meine Versuche, MemTest86 + v5.1 auf RISC-V und die Zwischensumme zu portieren.  <em>Spoiler: Es bewegt sich!</em> </p><a name="habracut"></a><br><p>  <strong>HAFTUNGSAUSSCHLUSS: Das resultierende Projekt wurde von mir auf einer bestimmten RocketChip-Baugruppe auf einer bestimmten Platine nur minimal getestet.</strong>  <strong>Genauigkeit und Sicherheit (insbesondere bei anderen Systemen) werden nicht garantiert.</strong>  <strong>Benutzung auf eigenes Risiko.</strong>  <strong>Insbesondere werden momentan reservierte Speicherbereiche in keiner Weise verarbeitet, wenn sie in den RAM-Bereich fallen.</strong> </p><br><p>  Wie ich bereits sagte, habe ich vor nicht allzu langer Zeit ein Motherboard mit Cyclone IV auf AliExpress gekauft, aber der Speicher darin war fehlerhaft.  Gl√ºcklicherweise war eines der wichtigen Merkmale dieses Boards die Verwendung herk√∂mmlicher DDR2-SO-DIMM-Module - genau wie bei meinem alten Netbook.  Trotzdem w√§re es interessant, sozusagen eine selbst gehostete L√∂sung zum Testen von Speichermodulen (und tats√§chlich auch des Controllers) zu bekommen.  Die Aussicht, meine Fehler unter den Bedingungen eines schlechten Ged√§chtnisses zu beseitigen, war irgendwie √ºberhaupt nicht erfreulich.  Vor allem, weil ich nicht auf eine schnelle L√∂sung gehofft hatte und mich mental darauf vorbereitete, das komplette Umschreiben in einem anderen Assembler auf unbestimmte Zeit zu verschieben, schlug ich einen Wikipedia-Artikel √ºber Memtest86 + auf und sah pl√∂tzlich ‚ÄûGeschrieben in: C und Assembler‚Äú auf der Karte.  Hmm, das hei√üt, er ist zwar "... 86", aber nicht ganz in Assembler geschrieben?  Das ist ermutigend.  Es bleibt nur die Beziehung zu verstehen. </p><br><p>  Gehen Sie also zu <a href="http://www.memtest.org/" rel="nofollow">memtest.org</a> und laden Sie die Version 5.01 unter der GPL2 herunter.  Zur Erleichterung der Entwicklung habe ich es auf GitHub <a href="https://github.com/atrosinenko/memtest86-plus-riscv" rel="nofollow">neu geladen</a> .  Zum Gl√ºck werden wir direkt im <a href="https://github.com/atrosinenko/memtest86-plus-riscv/blob/68b365d13cf22accd52f88af49c33f57c6643ae5/README.background" rel="nofollow">Quellarchiv</a> von der Datei <a href="https://github.com/atrosinenko/memtest86-plus-riscv/blob/68b365d13cf22accd52f88af49c33f57c6643ae5/README.background" rel="nofollow">README.background</a> mit dem Titel begr√º√üt </p><br><blockquote>  Die Anatomie und Physiologie von Memtest86-SMP </blockquote><p> Es erkl√§rt ausf√ºhrlich (und sogar mit Bildern in Form von ASCII-Kunst) die Funktionsweise des Codes auf hoher Ebene.  Ganz am Anfang des Dokuments sehen wir ein <code>setup.o</code> <em>Layout</em> , bestehend aus <code>bootsect.o</code> , <code>setup.o</code> , <code>head.o</code> und einigen <code>memtest_shared</code> .  Es ist leicht zu erkennen, dass diese drei Objektdateien aus den entsprechenden Assembler-Quellen stammen.  Alles andere ist auf den ersten Blick in C geschrieben!  Nicht schlecht, nicht schlecht ... </p><br><p>  Infolgedessen habe ich das <code>Makefile</code> nach <code>Makefile.arch</code> kopiert und angefangen, alles neu zu schreiben und zu versuchen, das herauszuwerfen, was nicht √ºbereinstimmt.  Zuallererst brauchte ich nat√ºrlich eine Toolchain f√ºr RISC-V, die zum Gl√ºck seit den vorherigen Experimenten immer noch bei mir ist.  Zuerst dachte ich daran, einen Port f√ºr die 32-Bit-Architektur zu <code>riscv64-</code> , aber dann fiel mir ein, dass ein 64-Bit-Prozessor auf das Board hochgeladen wurde, und ich hatte die <code>riscv64-</code> mit dem Pr√§fix <code>riscv64-</code> . </p><br><p>  <em>Lyrischer Exkurs:</em> Nat√ºrlich war das erste, was die Frage der Kompatibilit√§t von 32- und 64-Bit-Code untersuchte.  Infolgedessen lautet die Spezifikation f√ºr den nichtprivilegierten Teil der ISA (Instruction Set Architecture) in Abschnitt <code>1.3 RISC-V ISA Overview</code> : </p><br><blockquote>  Der Hauptvorteil der expliziten Trennung von Basis-ISAs besteht darin, dass jede Basis-ISA f√ºr ihre Anforderungen optimiert werden kann, ohne dass alle f√ºr andere Basis-ISAs erforderlichen Vorg√§nge unterst√ºtzt werden m√ºssen.  Beispielsweise kann RV64I Anweisungen und CSRs auslassen, die nur f√ºr die Verarbeitung der engeren Register in RV32I erforderlich sind.  Die RV32I-Optionen k√∂nnen Codierungsspeicher verwenden, der ansonsten f√ºr Anweisungen reserviert ist, die nur von breiteren Adressraumvarianten ben√∂tigt werden. </blockquote><p>  Ich m√∂chte auch darauf hinweisen, dass die Toolchain mit dem Pr√§fix <code>riscv64-</code> wahrscheinlich problemlos 32-Bit-Code sammelt, wenn die Zielarchitektur richtig ausgew√§hlt ist - dazu sp√§ter mehr. </p><br><p>  Beim Portieren ist es sinnvoll, die folgenden Dokumente griffbereit zu halten: </p><br><ul><li>  <a href="https://riscv.org/specifications/" rel="nofollow">Das Handbuch zum RISC-V-Befehlssatz Band I: Unprivilegiertes ISA</a> </li><li>  <a href="https://riscv.org/specifications/privileged-isa/" rel="nofollow">Das RISC-V Instruction Set Manual Band II: Privilegierte Architektur</a> </li><li>  Einige <a href="https://sifive.cdn.prismic.io/sifive%252F834354f0-08e6-423c-bf1f-0cb58ef14061_fu540-c000-v1.0.pdf" rel="nofollow">SiFive FU540-C000-Handb√ºcher</a> - ein Handbuch f√ºr den Chip, das sich √§hnlich <a href="https://sifive.cdn.prismic.io/sifive%252F834354f0-08e6-423c-bf1f-0cb58ef14061_fu540-c000-v1.0.pdf" rel="nofollow">verh√§lt</a> wie der Soft-Prozessor, der zum Debuggen in FPGAs verwendet wird, ist nicht <a href="https://sifive.cdn.prismic.io/sifive%252F834354f0-08e6-423c-bf1f-0cb58ef14061_fu540-c000-v1.0.pdf" rel="nofollow">unangebracht</a> </li></ul><br><h2 id="nastroyka-sborki">  Setup erstellen </h2><br><p>  Lassen Sie uns zun√§chst zustimmen: Ich m√∂chte einen Port erhalten, der f√ºr die weitere Portierung auf andere Architekturen als x86 und RISC-V geeignet ist.  Ich schlage auch vor, Bootdisketten und andere x86-Besonderheiten aus dem plattform√ºbergreifenden Build zu werfen. </p><br><p>  Was wir letztendlich haben: Es gibt drei Assembler-Dateien: <code>bootsect.S</code> , <code>setup.S</code> und <code>head.S</code>  Die ersten beiden werden nur beim Start ben√∂tigt und die dritte wird sp√§ter beim Umzug in einen anderen Speicherbereich ben√∂tigt.  Tatsache ist, dass, um den Speicher "unter sich" zu testen, der Testcode zuerst an einen neuen Ort verschoben werden muss.  Sich-Dateien werden in ELF gesammelt, aus denen dann Codeabschnitte, Daten usw. entnommen werden.  Dar√ºber hinaus wird es in Form von PIC (Position Independent Code) gesammelt - zun√§chst war ich sogar √ºberrascht: Obwohl der Code freistehend ist (dh ohne Kernel, libc usw.), verwendet er solche erweiterten Funktionen. </p><br><p>  Au√üerdem werden die Parameter, die die Architektur definieren, regelm√§√üig im Makefile <code>-march=i486</code> : <code>-march=i486</code> , <code>-m32</code> und dergleichen.  Ich muss so etwas schreiben, <del>  und dann wie ein Trottel </del>  .  Die Situation mit der RISC-V-Architektur <code>rv32</code> <code>rv64</code> so aus: Es gibt <code>rv32</code> und <code>rv64</code> (zum Beispiel gibt es immer noch die am st√§rksten verk√ºrzten eingebetteten und f√ºr die Zukunft reservierten rv128, aber wir sind nicht sehr daran interessiert), und der ISA-Name wird durch Zuweisen von Buchstaben zu diesem Pr√§fix gebildet erweiterungen: <code>i</code> - der grundlegende ganzzahlige Befehlssatz, <code>m</code> - ganzzahlige Multiplikation und Division, ... Nat√ºrlich w√ºrde ich gerne <code>rv64i</code> , aber Memtest86 wird ohne Multiplikation kaum leicht auf die Architektur portiert werden k√∂nnen.  Es ist richtig, dass der Compiler einfach Funktionsaufrufe anstelle von ‚Äûproblematischen‚Äú Anweisungen generiert. Es besteht jedoch die Gefahr, dass die Leistung stark reduziert bleibt (ganz zu schweigen davon, dass diese Funktionen irgendwo geschrieben oder ausgef√ºhrt werden m√ºssen). </p><br><p>  Sie ben√∂tigen auch die Linie ABI.  Grunds√§tzlich sind die Grundlagen der Aufrufkonvention bereits in dem angegebenen <code>Volume I</code> im "Handbuch f√ºr RISC-V-Assembly-Programmierer" beschrieben. Ich werde also einfach so etwas tun </p><br><pre> <code class="plaintext hljs">$ riscv64-linux-gnu-gcc-9 -mabi=help riscv64-linux-gnu-gcc-9: error: unrecognized argument in option '-mabi=help' riscv64-linux-gnu-gcc-9: note: valid arguments to '-mabi=' are: ilp32 ilp32d ilp32e ilp32f lp64 lp64d lp64f riscv64-linux-gnu-gcc-9: fatal error: no input files compilation terminated.</code> </pre> <br><p>  Und ohne nachzudenken, nehme ich <code>lp64</code> .  <em>Mit Blick auf die <code>lp64f</code> werde ich sagen, dass mit dieser ABI die Header-Dateien aus der Standardbibliothek nicht funktionierten, also habe ich <code>lp64f</code> und ARCH auf <code>rv64imf</code> ‚Äû <code>rv64imf</code> .</em>  <em>Ohne Panik habe ich nicht vor, Gleitkommazahlen in meinem Port zu verwenden.</em> </p><br><p>  Da ich irgendwie nicht in plattform√ºbergreifende Linker-Skripte <code>head.S</code> - und daher <em>die Schl√ºssel f√ºr ld</em> nicht sofort <em>finden</em> konnte, beschloss ich, mit der Assembler-Datei <code>head.S</code> und mich mit <code>head.S</code> an die restlichen Funktionen zu <code>memtest_shared.arch.lds</code> .  Ich habe daraufhin einen Hinweis auf das Ausgabeformat und die Architektur ausgegeben (schlie√ülich ist es einfacher, es von einer Variablen im Makefile zu √§ndern) und am Ende vor√ºbergehend <code>DISCARD</code> , da <code>DISCARD</code> nicht herausfinden konnte, welche spezifischen Abschnitte der Debugging-Informationen ich ben√∂tigte.  <em>(Vorausschauend: feine Debugging-Informationen, aber <code>.rela</code> musste hinzugef√ºgt werden)</em> Generell betonte die x86-Version die Notwendigkeit, in 64k zu passen - ich hoffe, dass dies nur irgendwie mit den Funktionen des Real-Modus zusammenh√§ngt und uns in RISC-V nicht betrifft .  Infolgedessen wird das gemeinsam genutzte Objekt mit dem PIC wie im Original gesammelt, und der Code und die Daten, die in den Speicher geladen werden, werden daraus herausgebissen. </p><br><p>  Wir sammeln ... und die Kompilierung f√§llt auf die erste <code>reloc.c</code> Datei - sie stammt anscheinend aus <code>ld-linux.so</code> und ist f√ºr die Unterst√ºtzung der globalen <code>ld-linux.so</code> usw. verantwortlich.  gem√§√ü Aufrufkonventionen f√ºr x86.  Es stellte sich heraus, dass es erforderlich war, mit Assembler-Einf√ºgungen direkt mit Registern zu arbeiten.  Aber wir sind bei RISC-V - es wurde urspr√ºnglich entwickelt, um PIC zu unterst√ºtzen, also <code>reloc.c</code> , <code>reloc.c</code> zu werfen.  Au√üerdem gab es immer noch Beilagen, manchmal ziemlich lang.  Zum Gl√ºck befanden sie sich entweder im Testcode unmittelbar nach dem auskommentierten C-Code, den sie optimieren (daraus habe ich wieder vollwertige Codeteile gemacht, die von der Pr√§prozessor-Direktive umgeschaltet wurden) oder etwas plattformabh√§ngiges, ohne das ich im Extremfall (wahrscheinlich) kann tun (wie das Ein- / Ausschalten des Cache, das Subtrahieren der CPUID usw.).  Schlie√ülich gab es einige Dinge wie den <code>rdtsc</code> Aufruf, den ich <code>rdtsc</code> ohne gro√üe Probleme in einen plattformabh√§ngigen Header gesteckt und gem√§√ü der Dokumentation zu RISC-V implementiert habe. </p><br><p>  Als Ergebnis haben wir das Verzeichnis <code>arch/i386</code> , in das eine gro√üe Menge von PCI-Unterst√ºtzungscode verschoben wurde, Informationen von den Chips√§tzen gelesen wurden, plattformspezifische Definitionen von Speicheradressen usw.  Dort blieb auch der Anfang der Funktion <code>test_start</code> , der der Einstiegspunkt von <code>setup.S</code> zum C-Code ist. Wie lang, kurz, aber alles <code>setup.S</code> , was m√∂glich ist, und alles realisieren, was unter RISC-V nicht <code>setup.S</code> (wie <code>setup.S</code> und der Code f√ºr die Arbeit mit serielle Schnittstelle in der SiFive-Implementierung) habe ich das <code>arch/riscv</code> , mit dem alles mehr oder weniger kompiliert wurde. </p><br><p>  Hier muss ich klarstellen, dass die Experimente selbst teilweise vor dem Schreiben des Artikels durchgef√ºhrt wurden, sodass eine bestimmte <em>Abfolge von</em> Aktionen eine gewisse Menge an ‚Äûk√ºnstlerischer Fiktion‚Äú enthalten kann.  Ich versuche jedoch, die Pr√§sentation zumindest so zu gestalten, dass sie auf jeden Fall einen der m√∂glichen Wege darstellt <em>(ich bin Programmierer, daran erinnere ich mich)</em> .  Also mal sehen, wie man alles anf√§ngt. </p><br><h2 id="zapusk-na-zheleze">  Laufen auf Eisen </h2><br><p>  Seit fr√ºheren Experimenten habe ich immer noch einen staubigen "Stand" vom Raspberry Pi, der mit dem Debugboard verbunden ist.  Die Dr√§hte versorgen UART, JTAG und einen Adapter mit einer SD-Karte.  Ein bestimmter RV64-Prozessor mit einem DDR2-Controller ist in den Konfigurationsspeicher eingen√§ht.  Wie in fr√ºheren Zeiten schalte ich die "Himbeere" ein, √∂ffne zwei SSH-Sitzungen davor, von denen eine den 3333-TCP-Port f√ºr die Verbindung von GDB mit OpenOCD weiterleitet.  In einer Sitzung starte ich minicom, um nach UART zu suchen, in einer anderen - openocd, um √ºber JTAG vom Host aus zu debuggen.  Ich schalte die Stromversorgung des Boards ein - und Meldungen in der Konsole dar√ºber, wie es Daten vom SD l√§dt, liefen. </p><br><p>  Jetzt k√∂nnen Sie den Befehl ausf√ºhren: </p><br><pre> <code class="plaintext hljs">riscv64-unknown-elf-gdb \ -ex 'target remote 127.0.0.1:3333' \ -ex 'restore /path/to/memtest_shared.bin binary 0x80010000' \ -ex 'add-symbol-file /path/to/memtest_shared 0x80010000' -ex 'set $pc=0x80010000'</code> </pre> <br><p>  Die Optionen <code>-ex</code> gdb an, so zu tun, als h√§tte der Benutzer die folgenden Befehle √ºber die Konsole eingegeben: </p><br><ul><li>  der erste stellt eine Verbindung mit OpenOCD her </li><li>  Die zweite kopiert den Inhalt der angegebenen Hostdatei an die angegebene Adresse </li><li>  der dritte erkl√§rt gdb, dass Informationen √ºber den Quellcode aus <em>dieser</em> Datei entnommen werden m√ºssen, unter Ber√ºcksichtigung der Tatsache, dass sie unter <em>dieser</em> Adresse heruntergeladen wurden (und nicht, was darin selbst angegeben ist). <br><ul><li>  Hinweis: Wir nehmen die Zeichen aus der ELF-Datei und laden die Bin√§rdatei "raw" </li></ul></li><li>  Schlie√ülich √ºbersetzt der vierte zwangsweise den aktuellen Befehlszeiger in unseren Code </li></ul><br><p>  Leider l√§uft nicht alles absolut reibungslos und die Codezeilen im Debugger werden zwar korrekt angezeigt, aber in allen globalen Variablen - Nullen.  Wenn wir in gdb einen Befehl in der Form <code>p &amp;global_var</code> ausf√ºhren, sehen wir die Adresse leider in √úbereinstimmung mit der urspr√ºnglichen Download-Adresse (ich habe <code>0x0</code> ), die nicht mit <code>add-symbol-file</code> .  Als Kr√ºcke, aber eine sehr einfache L√∂sung, habe ich einfach <code>0x80010000</code> manuell zur angegebenen Adresse hinzugef√ºgt und den Inhalt des Speichers √ºber <code>x/x 0xADDR</code> .  Tats√§chlich k√∂nnte im Linkerskript vor√ºbergehend die richtige Startadresse angegeben werden, die <em>im Moment</em> mit der Downloadadresse in <em>dieser Testkonfiguration</em> √ºbereinstimmt. </p><br><h2 id="osobennosti-relokacii-na-sovremennyh-arhitekturah">  Merkmale der Verlagerung auf moderne Architekturen </h2><br><p>  Nun, wie man den Code herunterl√§dt, haben wir herausgefunden - wir fangen an.  Das ____ funktioniert nicht.  Das schrittweise Debuggen zeigt, dass wir w√§hrend des Betriebs der <code>switch_to_main_stack</code> Funktion <code>switch_to_main_stack</code> - es scheint, dass immer noch versucht wird, den nicht zusammenh√§ngenden Wert der Adresse des Symbols zu verwenden, das dem Arbeitsstapel entspricht. </p><br><p>  Der erste Teil der Dokumentation enth√§lt Informationen zu verschiedenen Pseudobefehlen und ihrer Arbeit mit PIC on und off: </p><br><p><img src="https://habrastorage.org/webt/vj/7-/_u/vj7-_uqmqyqjloo1webrgpqsdc8.png" alt="Einige RISC-V-Pseudobefehle"></p><br><p>  Wie Sie sehen k√∂nnen, ist das allgemeine Prinzip, dass die Adressen im Speicher vom aktuellen Befehl an gez√§hlt werden, wobei der erste den oberen Rand des Offsets <code>add</code> und der n√§chste die niederwertigen Bits poliert.  Es hilft kaum, eine globale Variable wie zu deklarieren </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vars</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">variables</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br><p>  Daher nehmen wir die RISC-V ELF psABI-Dokumentation mit <a href="" rel="nofollow">Beschreibungen der</a> Umzugstypen und schreiben den plattformspezifischen Teil f√ºr <code>reloc.c</code> .  Hierbei ist zu beachten, dass die Originaldatei anscheinend aus plattform√ºbergreifendem Code stammt.  Dort werden, anstatt eine bestimmte Bittiefe anzugeben, Makros vom <code>ElfW(Addr)</code> , die in <code>Elf32_Addr</code> oder <code>Elf64_Addr</code> .  Aus diesem Grund f√ºgen wir sie nicht √ºberall dort hinzu, wo sie nicht im allgemeinen Code (sowie im Code <a href="" rel="nofollow"><code>arch/riscv/reloc.inc.c</code></a> Schlie√ülich ist es f√ºr RISC-V nicht sinnvoll, an eine bestimmte Bittiefe gebunden zu sein, wo dies nicht der Fall ist erforderlich). </p><br><p>  Infolgedessen begann <code>switch_to_main_stack</code> zu vergehen (nat√ºrlich nicht ohne plattformabh√§ngige Assembler-Anweisungen).  Der Debugger zeigt globale Variablen immer noch schief an.  Na ja, okay :( </p><br><h2 id="opredelenie-oborudovaniya">  Hardware-Definition </h2><br><p>  Nat√ºrlich w√§re es f√ºr Tests m√∂glich, hartcodierte Konstanten anstelle des weggeworfenen Ger√§te-Definitionscodes zu verwenden, aber f√ºr jede bestimmte Prozessorbaugruppe ist das Neuerstellen von memtest f√ºr die Standards meiner Anwendung sogar zu kostspielig.  Deshalb werden wir "als ernsthafte Erwachsene" auftreten.  Gl√ºcklicherweise ist es in RISC-V (und wahrscheinlich in den meisten modernen Architekturen) √ºblich, dass der Bootloader einen Code an das <a href="https://en.wikipedia.org/wiki/Device_tree" rel="nofollow">Device Tree Blob √ºbergibt</a> , das eine kompilierte Version der DTS-Beschreibung wie folgt ist: </p><br><div class="spoiler">  <b class="spoiler_title">zeowaa-1gb.dts</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/dts-v1/; / { #address-cells = ^_^lt gt^_^; #size-cells = ^_^lt gt^_^; compatible = "freechips,rocketchip-unknown-dev"; model = "freechips,rocketchip-unknown"; chosen { bootargs = "console=ttySIF0,125200 debug loglevel=7"; }; firmware { sifive,uboot = "YYYY-MM-DD"; }; L16: aliases { serial0 = &amp;L8; }; L15: cpus { #address-cells = ^_^lt gt^_^; #size-cells = ^_^lt&amp;#0;gt^_^; timebase-frequency = ^_^ltÛ¥âÄgt^_^; L5: cpu@0 { device_type = "cpu"; clock-frequency = ^_^lt&amp;#0;gt^_^; compatible = "sifive,rocket0", "riscv"; d-cache-block-size = ^_^lt gt^_^; d-cache-sets = ^_^lt@gt^_^; d-cache-size = ^_^lt·ÄÄgt^_^; d-tlb-sets = ^_^lt gt^_^; d-tlb-size = ^_^lt gt^_^; i-cache-block-size = ^_^lt gt^_^; i-cache-sets = ^_^lt@gt^_^; i-cache-size = ^_^lt·ÄÄgt^_^; i-tlb-sets = ^_^lt gt^_^; i-tlb-size = ^_^lt gt^_^; mmu-type = "riscv,sv39"; next-level-cache = &lt;&amp;L10&gt;; reg = &lt;0x0&gt;; riscv,isa = "rv64imafdc"; status = "okay"; timebase-frequency = ^_^ltÛ¥âÄgt^_^; tlb-split; L3: interrupt-controller { #interrupt-cells = ^_^lt gt^_^; compatible = "riscv,cpu-intc"; interrupt-controller; }; }; }; L10: ram@80000000 { device_type = "memory"; reg = &lt;0x0 0x80000000 0x0 0x40000000&gt;; reg-names = "mem"; }; L14: soc { #address-cells = ^_^lt gt^_^; #size-cells = ^_^lt gt^_^; compatible = "freechips,rocketchip-unknown-soc", "simple-bus"; ranges; L1: clint@2000000 { compatible = "riscv,clint0"; interrupts-extended = &lt;&amp;L3 3 &amp;L3 7&gt;; reg = &lt;0x2000000 0x10000&gt;; reg-names = "control"; }; L2: debug-controller@0 { compatible = "sifive,debug-013", "riscv,debug-013"; interrupts-extended = &lt;&amp;L3 65535&gt;; reg = &lt;0x0 0x1000&gt;; reg-names = "control"; }; L9: gpio@64002000 { #gpio-cells = ^_^lt gt^_^; #interrupt-cells = ^_^lt gt^_^; compatible = "sifive,gpio0"; gpio-controller; interrupt-controller; interrupt-parent = &lt;&amp;L0&gt;; interrupts = &lt;3 4 5 6 7 8&gt;; reg = &lt;0x64002000 0x1000&gt;; reg-names = "control"; }; L0: interrupt-controller@c000000 { #interrupt-cells = ^_^lt gt^_^; compatible = "riscv,plic0"; interrupt-controller; interrupts-extended = &lt;&amp;L3 11 &amp;L3 9&gt;; reg = &lt;0xc000000 0x4000000&gt;; reg-names = "control"; riscv,max-priority = ^_^lt gt^_^; riscv,ndev = ^_^lt gt^_^; }; L6: rom@10000 { compatible = "sifive,maskrom0"; reg = &lt;0x10000 0x2000&gt;; reg-names = "mem"; }; L8: serial@64000000 { compatible = "sifive,uart0"; interrupt-parent = &lt;&amp;L0&gt;; clocks = &lt;&amp;tlclk&gt;; interrupts = ^_^lt gt^_^; reg = &lt;0x64000000 0x1000&gt;; reg-names = "control"; }; L7: spi@64001000 { #address-cells = ^_^lt gt^_^; #size-cells = ^_^lt&amp;#0;gt^_^; compatible = "sifive,spi0"; interrupt-parent = &lt;&amp;L0&gt;; interrupts = ^_^lt gt^_^; reg = &lt;0x64001000 0x1000&gt;; clocks = &lt;&amp;tlclk&gt;; reg-names = "control"; L12: mmc@0 { compatible = "mmc-spi-slot"; disable-wp; reg = &lt;0x0&gt;; spi-max-frequency = ^_^lt gt^_^; voltage-ranges = &lt;3300 3300&gt;; }; }; tlclk: tlclk { #clock-cells = ^_^lt&amp;#0;gt^_^; clock-frequency = ^_^lt gt^_^; clock-output-names = "tlclk"; compatible = "fixed-clock"; }; }; };</code> </pre> </div></div><br><p>  Fr√ºher habe ich ELF-Dateien analysiert, aber jetzt bin ich wieder von FDT (Flat Device Tree) √ºberzeugt: Diese <em>freundlichen</em> <a href="https://github.com/devicetree-org/devicetree-specification/releases/download/v0.2/devicetree-specification-v0.2.pdf" rel="nofollow">Spezifikationen</a> wurden von <em>f√ºrsorglichen Menschen geschrieben</em> <del>  (Trotzdem analysieren sie es dann selbst!) </del>  Das Parsen solcher Dateien (zumindest bis Sie nicht vertrauensw√ºrdige Eingaben verarbeiten m√ºssen) wirft keine besonderen Probleme auf.  Also hier: Am Anfang der Datei befindet sich eine einfache Header-Struktur mit der magischen Nummer <code>0xd00dfeed</code> und ein paar weiteren Feldern.  Uns interessiert der Offset des "flat tree" <code>off_dt_struct</code> und der <code>off_dt_strings</code> .  Eigentlich m√ºssen Sie auch <code>off_mem_rsvmap</code> , wodurch Speicherbereiche <code>off_mem_rsvmap</code> , die am besten vermieden werden.  Ich ignoriere sie immer noch (sie befinden sich nicht auf meinem Board), <strong>wiederhole dies aber zu Hause nicht</strong> . </p><br><p>  Grunds√§tzlich ist die Verarbeitung nicht besonders schwierig: Sie m√ºssen nur auf einem flachen Baum gem√§√ü den Token gehen.  <em>Es gibt</em> drei <em>Schl√ºsselmarken</em> : </p><br><ul><li>  <code>FDT_BEGIN_NODE</code> - In den zus√§tzlichen Daten, die unmittelbar darauf folgen, steht der Name des Unterbaumelements in Form einer nullterminierten Zeichenfolge.  F√ºgen Sie einfach den Namen zum Stapel hinzu </li><li>  <code>FDT_END_NODE</code> - der Teilbaum ist vorbei, entferne das Element vom Stapel </li><li>  <code>FDT_PROP</code> - hier ist ein wenig kniffliger: Es folgt eine Struktur, gefolgt von len Bytes zus√§tzlicher Daten.  Der Name der "Variablen" liegt am Offset <code>nameoff</code> in der String-Tabelle <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> len; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nameoff; }</code> </pre> </li></ul><br><p>  Nun, im Allgemeinen ist das alles: Wir gehen diesen Abschnitt durch und vergessen nicht, die Ausrichtung um 4 Byte zu beobachten.  Oh ja, eine Fliege in der Salbe: Die Zahlen in FDT sind im Big-Endian-Format, also machen wir eine einfache Funktion </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">be32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | (x &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | ((x &amp; <span class="hljs-number"><span class="hljs-number">0xff0000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | ((x &amp; <span class="hljs-number"><span class="hljs-number">0xff00</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); }</code> </pre> <br><p>  Daher m√ºssen Sie in <code>riscv_entry</code> zun√§chst FDT und den Teil von <code>head.S</code> , der f√ºr die √úbertragung der Steuerung auf <code>riscv_entry</code> verantwortlich ist </p><br><pre> <code class="plaintext hljs"> .globl startup_32 #  --    ... startup_32: lla sp, boot_stack_top mv s0, a0 # s0, s1 -- callee-saved mv s1, a1 # ...  .bss #   jal _dl_start #      mv a0, s0 mv a1, s1 j riscv_entry</code> </pre> <br><p>  Im Register <code>a0</code> hart id an uns √ºbergeben (hart ist so etwas wie ein Hardware-Stream in der RISC-V-Terminologie) - ich verwende es noch nicht, ich m√ºsste es in einem Single-Thread-Fall herausfinden.  In <code>a1</code> Bootloader einen Zeiger auf das FDT.  Wir √ºbergeben es an die Funktion <code>void riscv_entry(ulong hartid, uint8_t *fdt_address)</code> . </p><br><p>  Mit dem Aufkommen der FDT-Parsilka in meinem Code wurde die Ladereihenfolge des Boards folgenderma√üen: </p><br><ul><li>  Schalten Sie den Strom ein </li><li>  Warten Sie auf die U-Boot-Konsole </li><li>  Geben Sie Befehle ein, um die richtige FDT vorzubereiten.  Insbesondere speichert das <code>/chosen/bootargs</code> command <code>/chosen/bootargs</code> die Kernel-Befehlszeile.  Alles andere, was ich von FDT nehme - RAM-Bereich, UART-Adresse, ... - kann und soll so belassen werden, wie es ist <br><pre> <code class="plaintext hljs">run fdtsetup fdt set /chosen bootargs "console=ttyS0 btrace"</code> </pre> </li><li>  <code>fdt addr</code> Befehl <code>fdt addr</code> die FDT-Download-Adresse, falls Sie nicht nachgeschaut haben </li></ul><br><p>  Und von GDB-Seite wird der Befehl hinzugef√ºgt </p><br><ul><li> <code>-ex 'set $a1=0xfdtaddr'</code> </li> </ul><br><h2 id="vyvod-informacii-na-ekran">  Informationsausgabe auf dem Bildschirm </h2><br><p>  Wie sich herausstellte, gibt es neben Assembler-Inserts auch bekannte Speicheradressen.  Zum Beispiel <code>SCREEN_ADR</code> (genau so, mit einem <code>D</code> ), das auf den Bereich zeigt, der dem entspricht, was auf dem Bildschirm angezeigt wird.  Als ich darauf stie√ü, platzierte ich einfach mit einer breiten Geste alles, was sich darauf bezieht, unter <code>#if HAS_SCREEN</code> und <code>#if HAS_SCREEN</code> lange Zeit blind.  Ich dachte schon einmal manuell, dies alles auf der Konsole abzulegen, aber dann bemerkte ich, dass derselbe Code schmerzhaft viele Escape-Sequenzen an die serielle Schnittstelle ausgibt.  Es stellte sich heraus, dass bereits alles vor uns geschrieben wurde. Sie m√ºssen nur die Definitionen genauer platzieren - und hier ist es, die vertraute Oberfl√§che (wenn auch schwarz und wei√ü) im Minicom-Fenster!  (Im Moment wird HAS_SCREEN √ºberhaupt nicht verwendet - ich habe gerade das <code>dummy_con</code> Array gestartet, um den urspr√ºnglichen Code mindestens zu √§ndern.) </p><br><h2 id="otladka-na-qemu">  Debuggen auf QEMU </h2><br><p>  Also habe ich alles auf einem echten Board getestet, und das schon seit einiger Zeit - nicht einmal blind.  Aber alles verlangsamt sich auf JTAG - Horror!  Nun, am Ende sollte alles auf echter Hardware funktionieren, aber es w√§re sch√∂n, auf QEMU zu debuggen.  Nach einer bestimmten Anzahl von Experimenten stellte sich heraus, dass es sich um eine Kr√ºcke handelte, die jedoch der Arbeit mit einem Brett sehr √§hnlich war: </p><br><pre> <code class="plaintext hljs">$ qemu-system-riscv64 -M help Supported machines are: none empty machine sifive_e RISC-V Board compatible with SiFive E SDK sifive_u RISC-V Board compatible with SiFive U SDK spike_v1.10 RISC-V Spike Board (Privileged ISA v1.10) (default) spike_v1.9.1 RISC-V Spike Board (Privileged ISA v1.9.1) virt RISC-V VirtIO Board (Privileged ISA v1.10)</code> </pre> <br><p>  Wir schauen uns an, welche Boards QEMU emulieren kann.  Ich interessiere mich f√ºr <code>sifive_u</code> kompatible Hardware. </p><br><pre> <code class="plaintext hljs">$ qemu-system-riscv64 -M sifive_u,dumpdtb -m 1g # - QEMU      on --  strace   $ ls -l on -rw-rw-r-- 1 trosinenko trosinenko 1923  19 20:14 on $ dtc -I dtb &lt; on &gt; on.dts #   $ vim on.dts #  bootargs $ dtc &lt; on.dts &gt; on.dtb &lt;stdout&gt;: Warning (clocks_property): /soc/ethernet@100900fc:clocks: cell 0 is not a phandle reference &lt;stdout&gt;: Warning (clocks_property): /soc/ethernet@100900fc:clocks: cell 1 is not a phandle reference &lt;stdout&gt;: Warning (clocks_property): /soc/ethernet@100900fc:clocks: cell 2 is not a phandle reference &lt;stdout&gt;: Warning (interrupts_extended_property): /soc/interrupt-controller@c000000:interrupts-extended: cell 0 is not a phandle reference &lt;stdout&gt;: Warning (interrupts_extended_property): /soc/interrupt-controller@c000000:interrupts-extended: cell 2 is not a phandle reference &lt;stdout&gt;: Warning (interrupts_extended_property): /soc/clint@2000000:interrupts-extended: cell 0 is not a phandle reference &lt;stdout&gt;: Warning (interrupts_extended_property): /soc/clint@2000000:interrupts-extended: cell 2 is not a phandle reference</code> </pre> <br><p>  Jetzt haben wir einen "festen" Ger√§tebaum-Blob.  F√ºhren Sie Folgendes aus, <strong>ohne die Konfiguration der VM zu √§ndern</strong> (Kr√ºcken!): </p><br><pre> <code class="plaintext hljs">qemu-system-riscv64 \ -M sifive_u -m 1g \ -serial stdio \ -s -S</code> </pre> <br><p>  <code>-serial stdio</code> leitet die serielle Schnittstelle an die Konsole weiter, da Escape-Sequenzen aktiv verwendet werden.  Mit den Optionen <code>-s -S</code> gdbserver aktiviert und eine VM erstellt, die angehalten werden soll.  Sie k√∂nnen den Code mit dem <code>loader</code> herunterladen, m√ºssen dann aber jedes Mal QEMU neu starten. </p><br><p>  Sie k√∂nnen eine Verbindung herstellen mit </p><br><pre> <code class="plaintext hljs">riscv64-unknown-elf-gdb \ -ex 'target remote 127.0.0.1:1234' \ -ex 'restore /path/to/on.dtb binary 0x80100000' \ -ex 'restore /path/to/memtest_shared.bin binary 0x80020000' \ -ex 'add-symbol-file memtest_shared 0x80100000' \ -ex 'set $a1=0x80020000' \ -ex 'set $pc=0x80100000'</code> </pre> <br><p>  Infolgedessen funktioniert alles mehr als schlau! </p><br><h2 id="obschiy-princip-raboty">  Allgemeines Prinzip der Arbeit </h2><br><p> , ,  ,   Memtest86+   <code>btrace</code> ,        ,      (  ,     QEMU): </p><br><p><img src="https://habrastorage.org/webt/su/lr/qh/sulrqhzmiona327osxqzaikijf0.png" alt="btrace mode"></p><br><p>  ,      , memtest          .     ,      (, trap):  ,   ,   QEMU - !  ¬´¬ª   <code>Illegal instruction</code>  ,    .      <code>mcause</code> (?),   ‚Äî <code>mepc</code> (?),   ‚Äî <code>mtval</code> (    ?),    . </p><br><p><img src="https://habrastorage.org/webt/lc/is/ho/lcishowkkjngpnorx_gkyav-svg.png" alt="Illegal instruction"></p><br><p>   ,      : </p><br><p> <strong>head.S:</strong> </p><br><pre> <code class="plaintext hljs">#       #   = 0 ---   ,   #  ,    ,     ... lla t1, _trap_entry csrw mtvec, t1 # ... _trap_entry: csrr a0, mcause csrr a1, mepc csrr a2, mtval jal riscv_trap_entry</code> </pre> <br><p>  ,        calling convention,  .        memtest,    HiFive_U-Boot,      <code>Volume II</code> : </p><br><p> <strong>arch.c:</strong> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *errors[] = { <span class="hljs-string"><span class="hljs-string">"Instruction address misaligned"</span></span>, <span class="hljs-string"><span class="hljs-string">"Instruction access fault"</span></span>, <span class="hljs-string"><span class="hljs-string">"Illegal instruction"</span></span>, <span class="hljs-string"><span class="hljs-string">"Breakpoint"</span></span>, <span class="hljs-string"><span class="hljs-string">"Load address misaligned"</span></span>, <span class="hljs-string"><span class="hljs-string">"Load access fault"</span></span>, <span class="hljs-string"><span class="hljs-string">"Store/AMO address misaligned"</span></span>, <span class="hljs-string"><span class="hljs-string">"Store/AMO access fault"</span></span>, ^_^quot quot^_^, ^_^quot quot^_^, ^_^quot quot^_^, ^_^quot quot^_^, <span class="hljs-string"><span class="hljs-string">"Instruction page fault"</span></span>, <span class="hljs-string"><span class="hljs-string">"Load page fault"</span></span>, ^_^quot quot^_^, <span class="hljs-string"><span class="hljs-string">"Store/AMO page fault"</span></span>, }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">riscv_trap_entry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ulong cause, ulong epc, ulong tval)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">32</span></span>]; cprint(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"EXCP: "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cause &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(errors) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(errors[<span class="hljs-number"><span class="hljs-number">0</span></span>])) { cprint(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, errors[cause]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { itoa(buf, cause); cprint(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, buf); } cprint(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"PC: "</span></span>); hprint3(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, epc, <span class="hljs-number"><span class="hljs-number">8</span></span>); cprint(<span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Addr: "</span></span>); hprint3(<span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, tval, <span class="hljs-number"><span class="hljs-number">8</span></span>); HALT(); }</code> </pre> <br><p>        ‚Äî    ¬´ ¬ª   .   ,   ¬´¬ª    ,  ,      ,  . </p><br><p>         :     .       ,  memtest  :    : ¬´       ,   ,    .        ¬ª.    :  <code>do_test</code>   <code>main.c</code>    2,   (    ),       ‚Äî    ¬´¬ª ,    memtest.       ,    <code>run_at</code> ,    memtest  <code>_start</code>  <code>_end</code>    (   ¬´¬ª  ),  -     spinlock'        <code>goto *addr;</code>        . ,  ,      ¬´¬ª    ,    ¬´¬ª. </p><br><p>      ,    <strong> </strong>  <code>bss</code>    ‚Äî    <code>_dl_start</code>  ,   <code>riscv_entry</code>  ,   trap entry. ,   :     L1I-,   .    ,     <code>fence.i</code> . </p><br><p>   ,  Memtest86+ ‚Äî ,         <code>barrier_s</code>    .       ,          . ,   ,       . </p><br><h2 id="podvodnye-kamni">   </h2><br><p>    ,   :   .   :           .    <em></em> : ,  -       (Own Address,     )   .     ,     ,   .       . -    .   ,   x86 , ,    <code>uint64_t</code>   <code>0x80000002</code>       . ,     : <a href="https://stackoverflow.com/questions/12491578/whats-the-actual-effect-of-successful-unaligned-accesses-on-x86" rel="nofollow"> </a> ,   load/store  x86   ,     ‚Äî .    ,    QEMU    ,  ¬´  ,      ¬ª. </p><br><p> ,     ,  <em>  </em> ‚Äî   unaligned access  .. </p><br><p> ,   ,     RocketChip,   ‚Äî QEMU,   ,  ,   RocketChip ‚Äî unaligned access trap,  QEMU  ¬´  ¬ª. <br>   ¬´misaligned¬ª            ,   </p><br><blockquote> Changed description of misaligned load and store behavior. The specification now allows visible misaligned address traps in execution environment interfaces, rather than just mandating invisible handling of misaligned loads and stores in user mode. Also, now allows access exceptions to be reported for misaligned accesses (including atomics) that should not be emulated. </blockquote><p>  , ,  ‚Äî   ,  user-mode code   ,             .     .   , ,   .   ,       ‚Äî -   machine mode    . ,     <code>rdtsc</code> (x86)  <code>rdtime</code> (rv64),   trap,     . , ,                memory-mapped . </p><br><p>    :      ,  <em> </em>   <code>low_test_addr</code> (       ),  ,   fdt   .   ,  ,  <code>low_test_addr</code>   ,  ,      2   <code>high_test_adr</code>    ‚Ä¶ ,     ‚Äî   : <code>head.S</code>       <code>initial_load_addr</code> ,    <code>riscv_entry</code>    <code>move_to_correct_addr</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move_to_correct_addr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> cur_start = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)&amp;_start; <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> cur_end = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)&amp;_end; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur_start == low_test_addr || cur_start == high_test_adr) { <span class="hljs-comment"><span class="hljs-comment">//  ,     return; } if (cur_start == initial_load_addr &amp;&amp; (cur_start - low_test_addr) &lt; (cur_end - cur_start) ) { //   " ":   , //           //     ,    ,   //     ... serial_echo_print("FIRST STARTUP RELOCATION...\n"); void *temp_addr = (((uintptr_t)&amp;_end &gt;&gt; 12) + 1) &lt;&lt; 12; run_at(temp_addr, 0); } else { // ,    --- ,  . serial_echo_print("FINAL STARTUP RELOCATION...\n"); run_at(low_test_addr, 0); } }</span></span></code> </pre> <br><p> ,     ‚Äî   ,  memtest ,  RAM  -   .  RISC-V    ,        <code>v-&gt;plim_lower</code> . </p><br><p>     ,   ¬´¬ª ,    -,   ‚Äî  <code>test.c</code>    <code>ulong</code> (  <code>unsigneg long</code> ),   32- x86   <code>uint32_t</code> ,    ¬´ 64 ¬ª   <code>uint64_t</code> .       ¬´!!! Good: ffffffff Real: ffffffff Bad bits: 00000000¬ª.   ?       - -1,  32    1.   ,         ,        0‚Ä¶  ,     : ,  <code>ulong</code>      ( <code>uint32_t</code> ),          ( <code>uintptr_t</code> ). ,       . ,     <code>uint64_t</code>   4. RISC-V  <em></em>  ,       C, ,    ‚Äî    UB. <del>     memtest  UBSan. </del>  ,  ,  UBSan   trap-on-error        JTAG. </p><br><h2 id="upakovyvaem-dlya-zagruzchika">    </h2><br><p> ,  memtest -  ,    ,          U-Boot. </p><br><p>       :    <code>mkimage</code>   U-Boot   <em>  Linux</em> : </p><br><pre> <code class="plaintext hljs">mkimage -A riscv -O linux -T kernel -C none \ -a 0x80000000 -e 0x80000000 \ -n memtest -d memtest.bin memtest.uboot</code> </pre> <br><p>      SD-      </p><br><pre> <code class="plaintext hljs">run mmcsetup; run fdtsetup; fdt set /chosen bootargs "console=ttyS0"; fatload mmc 0:1 82000000 memtest.uboot; bootm fdt; bootm 82000000 - ${fdtaddr}</code> </pre> <br><p> (   ,   <code>run</code>     ‚Äî        ). </p><br><p>      :       FDT: <code>0xbffb7c80</code> . ,  :    <code>ffffffff</code> ,     .     ,         (     ),    :   HiFive_U-Boot      : </p><br><pre> <code class="cpp hljs"> theKernel(machid, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)images-&gt;ft_addr);</code> </pre> <br><p>    ,     </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*theKernel)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arch, uint params);</code> </pre> <br><p>  ,     , ,  ,  32        ,     <code>head.S</code> : </p><br><pre> <code class="plaintext hljs"> li t0, 0xffffffffL and a1, a1, t0</code> </pre> <br><h2 id="promezhutochnyy-itog">   </h2><br><p> ,  , - ,  ,     ,  : </p><br><ul><li>     x86.       ‚Äî       review         <strong>   </strong> </li><li>   SMP   RISC-V </li><li>        <code>arch/</code> -  </li><li>     <code>test.c</code>  RISC-V (      <code>-O0</code> !) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484026/">https://habr.com/ru/post/de484026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484012/index.html">Optimieren Sie den Schreibvorgang in einem Blocknotizbuch</a></li>
<li><a href="../de484014/index.html">10 SEO-Mythen, die 2020 aufgegeben werden m√ºssen</a></li>
<li><a href="../de484016/index.html">Die Grundlagen des Deep Learning am Beispiel des Debug-Autoencoders, Teil 1</a></li>
<li><a href="../de484018/index.html">IT-technische Seite des Segelsports</a></li>
<li><a href="../de484020/index.html">Wen m√∂chten Sie mit Ihren Terminen beeindrucken?</a></li>
<li><a href="../de484028/index.html">Horseshoe Bend - Cabrio-Tablet mit Klappdisplay</a></li>
<li><a href="../de484034/index.html">Umsetzung des Arbeitsschemas der gezielten Warenlagerung auf Basis der Lagerabrechnungseinheit 1C Integrated Automation 2</a></li>
<li><a href="../de484036/index.html">Neue Industriegruppe schafft universellen Standard f√ºr Smart Homes</a></li>
<li><a href="../de484046/index.html">Emby mit PVS-Studio √ºberpr√ºfen</a></li>
<li><a href="../de484048/index.html">PHP und regul√§re Ausdr√ºcke: die Grundlagen f√ºr Anf√§nger</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>