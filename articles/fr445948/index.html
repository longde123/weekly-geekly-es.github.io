<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèΩ üçí ü•° H√©ritage en C ++: d√©butant, interm√©diaire, avanc√© ‚ôãÔ∏è ‚úçüèΩ üòá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article d√©crit l'h√©ritage √† trois niveaux: d√©butant, interm√©diaire et avanc√©. Expert no. Et pas un mot sur SOLID. Honn√™tement. 
 D√©butant 
 Qu'est...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>H√©ritage en C ++: d√©butant, interm√©diaire, avanc√©</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445948/"><p> Cet article d√©crit l'h√©ritage √† trois niveaux: d√©butant, interm√©diaire et avanc√©.  Expert no.  Et pas un mot sur SOLID.  Honn√™tement. </p><br><h1 id="beginner">  D√©butant </h1><br><h3 id="chto-takoe-nasledovanie">  Qu'est-ce que l'h√©ritage? </h3><br><p>  L'h√©ritage est l'un des principes fondamentaux de la POO.  Selon elle, une classe peut utiliser les variables et les m√©thodes d'une autre classe comme les siennes. </p><br><p>  Une classe qui h√©rite de donn√©es est appel√©e une sous-classe, une classe d√©riv√©e ou une classe enfant.  La classe dont les donn√©es ou les m√©thodes sont h√©rit√©es est appel√©e une super classe, une classe de base ou une classe parente.  Les termes ¬´parent¬ª et ¬´enfant¬ª sont extr√™mement utiles pour comprendre l'h√©ritage.  Lorsqu'un enfant re√ßoit les caract√©ristiques de ses parents, la classe d√©riv√©e re√ßoit les m√©thodes et les variables de la classe de base. </p><br><p>  L'h√©ritage est utile car il vous permet de structurer et de r√©utiliser du code, qui √† son tour <a name="habracut"></a>  peut acc√©l√©rer consid√©rablement le processus de d√©veloppement.  Malgr√© cela, l'h√©ritage doit √™tre utilis√© avec prudence, car la plupart des modifications apport√©es √† la superclasse affecteront toutes les sous-classes, ce qui peut entra√Æner des cons√©quences impr√©vues. </p><br><p> Dans cet exemple, la m√©thode <code>turn_on()</code> et la variable <code>serial_number</code> pas <code>serial_number</code> d√©clar√©es ou d√©finies dans la sous-classe <code>Computer</code> .  Cependant, ils peuvent √™tre utilis√©s car ils sont h√©rit√©s de la classe de base. </p><br><p>  <em>Remarque importante</em> : les variables et m√©thodes priv√©es ne peuvent pas √™tre h√©rit√©es. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: int serial_number = 12345678; void turn_on() { cout &lt;&lt; "Device is on" &lt;&lt; endl; } private: int pincode = 87654321; }; class Computer: public Device {}; int main() { Computer Computer_instance; Computer_instance.turn_on(); cout &lt;&lt; "Serial number is: " &lt;&lt; Computer_instance.serial_number &lt;&lt; endl; // cout &lt;&lt; "Pin code is: " &lt;&lt; Computer_instance.pincode &lt;&lt; endl; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h3 id="tipy-nasledovaniya">  Types d'h√©ritage </h3><br><p>  Il existe plusieurs types d'h√©ritage en C ++: </p><br><ul><li>  public - les donn√©es publiques ( <code>public</code> ) et prot√©g√©es ( <code>protected</code> ) sont h√©rit√©es sans changer le niveau d'acc√®s √† celles-ci; </li><li>  prot√©g√© ( <code>protected</code> ) - toutes les donn√©es h√©rit√©es deviennent prot√©g√©es; </li><li>  priv√© - toutes les donn√©es h√©rit√©es deviennent priv√©es. </li></ul><br><p>  Pour la classe de base <code>Device</code> , le niveau d'acc√®s aux donn√©es ne change pas, mais comme la classe d√©riv√©e <code>Computer</code> h√©rite des donn√©es priv√©es, les donn√©es deviennent priv√©es pour la classe <code>Computer</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: int serial_number = 12345678; void turn_on() { cout &lt;&lt; "Device is on" &lt;&lt; endl; } }; class Computer: private Device { public: void say_hello() { turn_on(); cout &lt;&lt; "Welcome to Windows 95!" &lt;&lt; endl; } }; int main() { Device Device_instance; Computer Computer_instance; cout &lt;&lt; "\t Device" &lt;&lt; endl; cout &lt;&lt; "Serial number is: "&lt;&lt; Device_instance.serial_number &lt;&lt; endl; Device_instance.turn_on(); // cout &lt;&lt; "Serial number is: " &lt;&lt; Computer_instance.serial_number &lt;&lt; endl; // Computer_instance.turn_on(); // will cause compile time error cout &lt;&lt; "\t Computer" &lt;&lt; endl; Computer_instance.say_hello(); return 0; }</span></span></span></span></code> </pre> <br><p>  La classe <code>Computer</code> utilise d√©sormais la m√©thode <code>turn_on()</code> comme n'importe quelle m√©thode priv√©e: <code>turn_on()</code> peut √™tre appel√©e √† partir de la classe, mais essayer de l'appeler directement √† partir de <code>main</code> entra√Ænera une erreur au moment de la compilation.  Pour la classe de base <code>Device</code> , la m√©thode <code>turn_on()</code> rest√©e publique et peut √™tre appel√©e depuis <code>main</code> . </p><br><h3 id="konstruktory-i-destruktory">  Constructeurs et destructeurs </h3><br><p>  En C ++, les constructeurs et destructeurs ne sont pas h√©rit√©s.  Cependant, ils sont appel√©s lorsque la classe enfant initialise son objet.  Les constructeurs sont appel√©s hi√©rarchiquement les uns apr√®s les autres, en commen√ßant par la classe de base et en terminant par la derni√®re classe d√©riv√©e.  Les destructeurs sont appel√©s dans l'ordre inverse. </p><br><p>  <em>Remarque importante:</em> cet article ne couvre pas les destructeurs virtuels.  Des informations suppl√©mentaires sur ce sujet peuvent √™tre trouv√©es, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans cet article sur le Habr</a> . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: // constructor Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } // destructor ~Device() { cout &lt;&lt; "Device destructor called" &lt;&lt; endl; } }; class Computer: public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } ~Computer() { cout &lt;&lt; "Computer destructor called" &lt;&lt; endl; } }; class Laptop: public Computer { public: Laptop() { cout &lt;&lt; "Laptop constructor called" &lt;&lt; endl; } ~Laptop() { cout &lt;&lt; "Laptop destructor called" &lt;&lt; endl; } }; int main() { cout &lt;&lt; "\tConstructors" &lt;&lt; endl; Laptop Laptop_instance; cout &lt;&lt; "\tDestructors" &lt;&lt; endl; return 0; }</span></span></span></span></code> </pre> <br><p>  Constructeurs: <code>Device</code> -&gt; <code>Computer</code> -&gt; <code>Laptop</code> . <br>  Destructeurs: <code>Laptop</code> -&gt; <code>Computer</code> -&gt; <code>Device</code> . </p><br><h3 id="mnozhestvennoe-nasledovanie">  H√©ritage multiple </h3><br><p>  L'h√©ritage multiple se produit lorsqu'une sous-classe a deux ou plusieurs superclasses.  Dans cet exemple, la classe <code>Laptop</code> h√©rite √† la fois de <code>Monitor</code> et <code>Computer</code> en m√™me temps. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Computer { public: void turn_on() { cout &lt;&lt; "Welcome to Windows 95" &lt;&lt; endl; } }; class Monitor { public: void show_image() { cout &lt;&lt; "Imagine image here" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); Laptop_instance.show_image(); return 0; }</span></span></span></span></code> </pre> <br><h3 id="problematika-mnozhestvennogo-nasledovaniya">  Probl√®mes d'h√©ritage multiples </h3><br><p>  L'h√©ritage multiple n√©cessite une conception soign√©e, car il peut entra√Æner des cons√©quences impr√©vues.  La plupart de ces cons√©quences sont caus√©es par l'ambigu√Øt√© de l'h√©ritage.  Dans cet exemple, <code>Laptop</code> h√©rite de la m√©thode <code>turn_on()</code> des deux parents et la m√©thode √† appeler n'est pas claire. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Computer { private: void turn_on() { cout &lt;&lt; "Computer is on." &lt;&lt; endl; } }; class Monitor { public: void turn_on() { cout &lt;&lt; "Monitor is on." &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; // Laptop_instance.turn_on(); // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><p>  Malgr√© le fait que les donn√©es priv√©es ne soient pas h√©rit√©es, il est impossible de r√©soudre l'h√©ritage ambigu en changeant le niveau d'acc√®s aux donn√©es en priv√©.  Lors de la compilation, une recherche de m√©thode ou de variable a d'abord lieu, puis v√©rifie le niveau d'acc√®s √† ces derni√®res. </p><br><h1 id="intermediate">  Interm√©diaire </h1><br><h3 id="problema-romba">  Probl√®me de losange </h3><br><img align="left" src="https://habrastorage.org/webt/qn/ae/po/qnaepojwdop6urntrubztgdd7x4.png"><br><p>  Le probl√®me du diamant est un probl√®me classique dans les langues qui prennent en charge l'h√©ritage multiple.  Ce probl√®me se produit lorsque les classes <code>B</code> et <code>C</code> h√©ritent de <code>A</code> et que la classe <code>D</code> h√©rite de <code>B</code> et <code>C</code> </p><br><p>  Par exemple, les classes <code>A</code> , <code>B</code> et <code>C</code> d√©finissent la m√©thode <code>print_letter()</code> .  Si <code>print_letter()</code> sera appel√© par la classe <code>D</code> , la m√©thode √† appeler n'est pas claire - une m√©thode de classe <code>A</code> , <code>B</code> ou <code>C</code>  Diff√©rentes langues ont diff√©rentes approches pour r√©soudre des probl√®mes en forme de diamant.  En C ++, la solution au probl√®me est laiss√©e √† la discr√©tion du programmeur. <br><br clear="all">  Le probl√®me en forme de losange est principalement un probl√®me de conception, et il devrait √™tre fourni au stade de la conception.  Au stade du d√©veloppement, il peut √™tre r√©solu comme suit: </p><br><ul><li>  appeler la m√©thode d'une superclasse sp√©cifique; </li><li>  d√©signer l'objet de la sous-classe comme un objet d'une super-classe particuli√®re; </li><li>  remplacer la m√©thode probl√©matique dans la derni√®re classe enfant (dans le code, <code>turn_on()</code> dans la sous-classe <code>Laptop</code> ). </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; class Computer: public Device {}; class Monitor: public Device {}; class Laptop: public Computer, public Monitor { /* public: void turn_on() { cout &lt;&lt; "Laptop is on." &lt;&lt; endl; } // uncommenting this function will resolve diamond problem */ }; int main() { Laptop Laptop_instance; // Laptop_instance.turn_on(); // will produce compile time error // if Laptop.turn_on function is commented out // calling method of specific superclass Laptop_instance.Monitor::turn_on(); // treating Laptop instance as Monitor instance via static cast static_cast&lt;Monitor&amp;&gt;( Laptop_instance ).turn_on(); return 0; }</span></span></span></span></code> </pre> <br><p>  Si la m√©thode <code>turn_on()</code> pas √©t√© remplac√©e dans Laptop, l'appel √† <code>Laptop_instance.turn_on()</code> entra√Ænera une erreur de compilation.  Un objet <code>Laptop</code> peut acc√©der <code>turn_on()</code> deux <code>turn_on()</code> m√©thode <code>turn_on()</code> : <code>Device:Computer:Laptop.turn_on()</code> et <code>Device:Monitor:Laptop.turn_on()</code> . </p><br><h3 id="problema-romba-konstruktory-i-destruktory">  Le probl√®me du diamant: constructeurs et destructeurs </h3><br><p>  Comme en C ++, lorsque l'objet de la classe enfant est initialis√©, les constructeurs de toutes les classes parentes sont appel√©s, un autre probl√®me se pose: le constructeur de la classe de base <code>Device</code> sera appel√© deux fois. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } }; class Computer: public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } }; class Monitor: public Device { public: Monitor() { cout &lt;&lt; "Monitor constructor called" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; return 0; }</span></span></span></span></code> </pre> <br><h3 id="virtualnoe-nasledovanie">  H√©ritage virtuel </h3><br><p>  L'h√©ritage virtuel emp√™che plusieurs objets de classe de base d'appara√Ætre dans la hi√©rarchie d'h√©ritage.  Ainsi, le constructeur de la classe de base <code>Device</code> ne sera appel√© qu'une seule fois et un appel √† la m√©thode <code>turn_on()</code> sans la <code>turn_on()</code> dans la classe enfant ne provoquera pas d'erreur de compilation. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; class Computer: virtual public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } }; class Monitor: virtual public Device { public: Monitor() { cout &lt;&lt; "Monitor constructor called" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); return 0; }</span></span></span></span></code> </pre> <br><p>  <em>Remarque</em> : l'h√©ritage virtuel dans les classes <code>Computer</code> et <code>Monitor</code> n'autorisera pas l'h√©ritage rhombo√Øde si la classe enfant <code>Laptop</code> n'h√©rite pas virtuellement de la classe <code>Device</code> ( <code>class Laptop: public Computer, public Monitor, public Device {};</code> ). </p><br><h3 id="abstraktnyy-klass">  Classe abstraite </h3><br><p>  En C ++, une classe dans laquelle existe au moins une m√©thode virtuelle pure est consid√©r√©e comme abstraite.  Si la m√©thode virtuelle n'est pas remplac√©e dans la classe enfant, le code ne sera pas compil√©.  De plus, en C ++, il est impossible de cr√©er un objet d'une classe abstraite - une tentative provoquera √©galement une erreur lors de la compilation. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } virtual void say_hello() = 0; }; class Laptop: public Device { public: void say_hello() { cout &lt;&lt; "Hello world!" &lt;&lt; endl; } }; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); Laptop_instance.say_hello(); // Device Device_instance; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h3 id="interfeys">  Interface </h3><br><p>  C ++, contrairement √† certains langages OOP, ne fournit pas de mot cl√© distinct pour d√©signer une interface.  Cependant, l'impl√©mentation de l'interface est possible en cr√©ant une classe abstraite pure - une classe dans laquelle il n'y a que des d√©clarations de m√©thode.  Ces classes sont √©galement souvent appel√©es classes de base abstraites (ABC). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: virtual void turn_on() = 0; }; class Laptop: public Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); // Device Device_instance; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h1 id="advanced">  Avanc√© </h1><br><p>  Bien que l'h√©ritage soit un principe fondamental de la POO, il doit √™tre utilis√© avec prudence.  Il est important de penser que tout code qui sera utilis√© est susceptible d'√™tre modifi√© et peut √™tre utilis√© d'une mani√®re qui n'est pas √©vidente pour le d√©veloppeur. </p><br><h3 id="nasledovanie-ot-realizovannogo-ili-chastichno-realizovannogo-klassa">  H√©ritage d'une classe impl√©ment√©e ou partiellement impl√©ment√©e </h3><br><p>  Si l'h√©ritage ne provient pas d'une interface (une pure classe abstraite dans le contexte de C ++), mais d'une classe dans laquelle il existe des impl√©mentations, il convient de consid√©rer que l'h√©ritier est connect√© √† la classe parente par la connexion la plus proche possible.  La plupart des modifications apport√©es √† la classe parent peuvent affecter l'h√©ritier, ce qui peut entra√Æner un comportement inattendu.  De tels changements dans le comportement de l'h√©ritier ne sont pas toujours √©vidents - une erreur peut se produire dans le code d√©j√† test√© et fonctionnel.  Cette situation est exacerb√©e par la pr√©sence d'une hi√©rarchie de classes complexe.  Il faut toujours se rappeler que le code peut √™tre modifi√© non seulement par la personne qui l'a √©crit, et les chemins d'h√©ritage √©vidents pour l'auteur peuvent ne pas √™tre pris en compte par ses coll√®gues. </p><br><p>  En revanche, il convient de noter que l'h√©ritage de classes partiellement impl√©ment√©es pr√©sente un avantage ind√©niable.  Les biblioth√®ques et les frameworks fonctionnent souvent comme suit: ils fournissent √† l'utilisateur une classe abstraite avec plusieurs m√©thodes virtuelles et plusieurs impl√©ment√©es.  Ainsi, la plus grande quantit√© de travail a d√©j√† √©t√© effectu√©e - la logique complexe a d√©j√† √©t√© √©crite et l'utilisateur ne peut personnaliser la solution pr√™te √† l'emploi qu'en fonction de ses besoins. </p><br><h3 id="interfeys-1">  Interface </h3><br><p>  L'h√©ritage d'une interface (pure classe abstraite) pr√©sente l'h√©ritage comme une opportunit√© de structurer le code et de prot√©ger l'utilisateur.  √âtant donn√© que l'interface d√©crit le travail que fera la classe d'impl√©mentation, mais ne d√©crit pas comment, tout utilisateur de l'interface est prot√©g√© contre les modifications de la classe qui impl√©mente cette interface. </p><br><h3 id="interfeys-primer-ispolzovaniya">  Interface: Exemple d'utilisation </h3><br><p>  Tout d'abord, il convient de noter que l'exemple est √©troitement li√© au concept de polymorphisme, mais sera consid√©r√© dans le contexte de l'h√©ritage d'une pure classe abstraite. </p><br><p>  Une application qui ex√©cute une logique m√©tier abstraite doit √™tre configur√©e √† partir d'un fichier de configuration distinct.  √Ä un stade pr√©coce de d√©veloppement, le formatage de ce fichier de configuration n'√©tait pas enti√®rement form√©.  Passer l'analyse de fichiers derri√®re une interface offre plusieurs avantages. </p><br><p>  Le manque de clart√© concernant le formatage du fichier de configuration ne ralentit pas le processus de d√©veloppement du programme principal.  Deux d√©veloppeurs peuvent travailler en parall√®le - l'un sur la logique m√©tier et l'autre sur l'analyseur.  Puisqu'ils interagissent via cette interface, chacun d'eux peut fonctionner de mani√®re ind√©pendante.  Cette approche facilite le codage des tests unitaires avec du code, car les tests n√©cessaires peuvent √™tre √©crits √† l'aide de mock pour cette interface. </p><br><p>  De plus, lors de la modification du format de fichier de configuration, la logique m√©tier de l'application n'est pas affect√©e.  La seule chose qui n√©cessite une transition compl√®te d'un formatage √† un autre est d'√©crire une nouvelle impl√©mentation de la classe abstraite d√©j√† existante (classe analyseur).  De plus, le retour au format de fichier d'origine n√©cessite un travail minimal - remplacer un analyseur existant par un autre. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  L'h√©ritage offre de nombreux avantages, mais doit √™tre soigneusement con√ßu pour √©viter les probl√®mes qu'il pr√©sente.  Dans le contexte de l'h√©ritage, C ++ fournit une large gamme d'outils qui ouvre une tonne de possibilit√©s au programmeur. </p><br><p>  Et SOLID est bon. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445948/">https://habr.com/ru/post/fr445948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445928/index.html">Comment nous avons augment√© la productivit√© de Tensorflow au service de 70%</a></li>
<li><a href="../fr445932/index.html">S√©curit√© des applications client: conseils pratiques pour un d√©veloppeur frontal</a></li>
<li><a href="../fr445936/index.html">D√©veloppement √©lectronique. √Ä propos des microcontr√¥leurs sur les doigts</a></li>
<li><a href="../fr445940/index.html">AMA avec Habr, v 7.0. Citron, beignets et nouvelles</a></li>
<li><a href="../fr445946/index.html">MWC: mode d'emploi</a></li>
<li><a href="../fr445952/index.html">Un billion de petits c√©libataires</a></li>
<li><a href="../fr445954/index.html">Acc√©l√©rateur d'IA de HSE, MTS et Rostelecom</a></li>
<li><a href="../fr445958/index.html">SPDS GraphiCS - syst√®me de fa√ßade et de toiture</a></li>
<li><a href="../fr445962/index.html">Stage en informatique: le point de vue du manager</a></li>
<li><a href="../fr445964/index.html">MEPhI accueillera une olympiade √©tudiante sur la s√©curit√© de l'information: comment participer et ce qu'elle donne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>