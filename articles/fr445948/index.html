<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏽 🍒 🥡 Héritage en C ++: débutant, intermédiaire, avancé ♋️ ✍🏽 😇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article décrit l'héritage à trois niveaux: débutant, intermédiaire et avancé. Expert no. Et pas un mot sur SOLID. Honnêtement. 
 Débutant 
 Qu'est...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Héritage en C ++: débutant, intermédiaire, avancé</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445948/"><p> Cet article décrit l'héritage à trois niveaux: débutant, intermédiaire et avancé.  Expert no.  Et pas un mot sur SOLID.  Honnêtement. </p><br><h1 id="beginner">  Débutant </h1><br><h3 id="chto-takoe-nasledovanie">  Qu'est-ce que l'héritage? </h3><br><p>  L'héritage est l'un des principes fondamentaux de la POO.  Selon elle, une classe peut utiliser les variables et les méthodes d'une autre classe comme les siennes. </p><br><p>  Une classe qui hérite de données est appelée une sous-classe, une classe dérivée ou une classe enfant.  La classe dont les données ou les méthodes sont héritées est appelée une super classe, une classe de base ou une classe parente.  Les termes «parent» et «enfant» sont extrêmement utiles pour comprendre l'héritage.  Lorsqu'un enfant reçoit les caractéristiques de ses parents, la classe dérivée reçoit les méthodes et les variables de la classe de base. </p><br><p>  L'héritage est utile car il vous permet de structurer et de réutiliser du code, qui à son tour <a name="habracut"></a>  peut accélérer considérablement le processus de développement.  Malgré cela, l'héritage doit être utilisé avec prudence, car la plupart des modifications apportées à la superclasse affecteront toutes les sous-classes, ce qui peut entraîner des conséquences imprévues. </p><br><p> Dans cet exemple, la méthode <code>turn_on()</code> et la variable <code>serial_number</code> pas <code>serial_number</code> déclarées ou définies dans la sous-classe <code>Computer</code> .  Cependant, ils peuvent être utilisés car ils sont hérités de la classe de base. </p><br><p>  <em>Remarque importante</em> : les variables et méthodes privées ne peuvent pas être héritées. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: int serial_number = 12345678; void turn_on() { cout &lt;&lt; "Device is on" &lt;&lt; endl; } private: int pincode = 87654321; }; class Computer: public Device {}; int main() { Computer Computer_instance; Computer_instance.turn_on(); cout &lt;&lt; "Serial number is: " &lt;&lt; Computer_instance.serial_number &lt;&lt; endl; // cout &lt;&lt; "Pin code is: " &lt;&lt; Computer_instance.pincode &lt;&lt; endl; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h3 id="tipy-nasledovaniya">  Types d'héritage </h3><br><p>  Il existe plusieurs types d'héritage en C ++: </p><br><ul><li>  public - les données publiques ( <code>public</code> ) et protégées ( <code>protected</code> ) sont héritées sans changer le niveau d'accès à celles-ci; </li><li>  protégé ( <code>protected</code> ) - toutes les données héritées deviennent protégées; </li><li>  privé - toutes les données héritées deviennent privées. </li></ul><br><p>  Pour la classe de base <code>Device</code> , le niveau d'accès aux données ne change pas, mais comme la classe dérivée <code>Computer</code> hérite des données privées, les données deviennent privées pour la classe <code>Computer</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: int serial_number = 12345678; void turn_on() { cout &lt;&lt; "Device is on" &lt;&lt; endl; } }; class Computer: private Device { public: void say_hello() { turn_on(); cout &lt;&lt; "Welcome to Windows 95!" &lt;&lt; endl; } }; int main() { Device Device_instance; Computer Computer_instance; cout &lt;&lt; "\t Device" &lt;&lt; endl; cout &lt;&lt; "Serial number is: "&lt;&lt; Device_instance.serial_number &lt;&lt; endl; Device_instance.turn_on(); // cout &lt;&lt; "Serial number is: " &lt;&lt; Computer_instance.serial_number &lt;&lt; endl; // Computer_instance.turn_on(); // will cause compile time error cout &lt;&lt; "\t Computer" &lt;&lt; endl; Computer_instance.say_hello(); return 0; }</span></span></span></span></code> </pre> <br><p>  La classe <code>Computer</code> utilise désormais la méthode <code>turn_on()</code> comme n'importe quelle méthode privée: <code>turn_on()</code> peut être appelée à partir de la classe, mais essayer de l'appeler directement à partir de <code>main</code> entraînera une erreur au moment de la compilation.  Pour la classe de base <code>Device</code> , la méthode <code>turn_on()</code> restée publique et peut être appelée depuis <code>main</code> . </p><br><h3 id="konstruktory-i-destruktory">  Constructeurs et destructeurs </h3><br><p>  En C ++, les constructeurs et destructeurs ne sont pas hérités.  Cependant, ils sont appelés lorsque la classe enfant initialise son objet.  Les constructeurs sont appelés hiérarchiquement les uns après les autres, en commençant par la classe de base et en terminant par la dernière classe dérivée.  Les destructeurs sont appelés dans l'ordre inverse. </p><br><p>  <em>Remarque importante:</em> cet article ne couvre pas les destructeurs virtuels.  Des informations supplémentaires sur ce sujet peuvent être trouvées, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans cet article sur le Habr</a> . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: // constructor Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } // destructor ~Device() { cout &lt;&lt; "Device destructor called" &lt;&lt; endl; } }; class Computer: public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } ~Computer() { cout &lt;&lt; "Computer destructor called" &lt;&lt; endl; } }; class Laptop: public Computer { public: Laptop() { cout &lt;&lt; "Laptop constructor called" &lt;&lt; endl; } ~Laptop() { cout &lt;&lt; "Laptop destructor called" &lt;&lt; endl; } }; int main() { cout &lt;&lt; "\tConstructors" &lt;&lt; endl; Laptop Laptop_instance; cout &lt;&lt; "\tDestructors" &lt;&lt; endl; return 0; }</span></span></span></span></code> </pre> <br><p>  Constructeurs: <code>Device</code> -&gt; <code>Computer</code> -&gt; <code>Laptop</code> . <br>  Destructeurs: <code>Laptop</code> -&gt; <code>Computer</code> -&gt; <code>Device</code> . </p><br><h3 id="mnozhestvennoe-nasledovanie">  Héritage multiple </h3><br><p>  L'héritage multiple se produit lorsqu'une sous-classe a deux ou plusieurs superclasses.  Dans cet exemple, la classe <code>Laptop</code> hérite à la fois de <code>Monitor</code> et <code>Computer</code> en même temps. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Computer { public: void turn_on() { cout &lt;&lt; "Welcome to Windows 95" &lt;&lt; endl; } }; class Monitor { public: void show_image() { cout &lt;&lt; "Imagine image here" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); Laptop_instance.show_image(); return 0; }</span></span></span></span></code> </pre> <br><h3 id="problematika-mnozhestvennogo-nasledovaniya">  Problèmes d'héritage multiples </h3><br><p>  L'héritage multiple nécessite une conception soignée, car il peut entraîner des conséquences imprévues.  La plupart de ces conséquences sont causées par l'ambiguïté de l'héritage.  Dans cet exemple, <code>Laptop</code> hérite de la méthode <code>turn_on()</code> des deux parents et la méthode à appeler n'est pas claire. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Computer { private: void turn_on() { cout &lt;&lt; "Computer is on." &lt;&lt; endl; } }; class Monitor { public: void turn_on() { cout &lt;&lt; "Monitor is on." &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; // Laptop_instance.turn_on(); // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><p>  Malgré le fait que les données privées ne soient pas héritées, il est impossible de résoudre l'héritage ambigu en changeant le niveau d'accès aux données en privé.  Lors de la compilation, une recherche de méthode ou de variable a d'abord lieu, puis vérifie le niveau d'accès à ces dernières. </p><br><h1 id="intermediate">  Intermédiaire </h1><br><h3 id="problema-romba">  Problème de losange </h3><br><img align="left" src="https://habrastorage.org/webt/qn/ae/po/qnaepojwdop6urntrubztgdd7x4.png"><br><p>  Le problème du diamant est un problème classique dans les langues qui prennent en charge l'héritage multiple.  Ce problème se produit lorsque les classes <code>B</code> et <code>C</code> héritent de <code>A</code> et que la classe <code>D</code> hérite de <code>B</code> et <code>C</code> </p><br><p>  Par exemple, les classes <code>A</code> , <code>B</code> et <code>C</code> définissent la méthode <code>print_letter()</code> .  Si <code>print_letter()</code> sera appelé par la classe <code>D</code> , la méthode à appeler n'est pas claire - une méthode de classe <code>A</code> , <code>B</code> ou <code>C</code>  Différentes langues ont différentes approches pour résoudre des problèmes en forme de diamant.  En C ++, la solution au problème est laissée à la discrétion du programmeur. <br><br clear="all">  Le problème en forme de losange est principalement un problème de conception, et il devrait être fourni au stade de la conception.  Au stade du développement, il peut être résolu comme suit: </p><br><ul><li>  appeler la méthode d'une superclasse spécifique; </li><li>  désigner l'objet de la sous-classe comme un objet d'une super-classe particulière; </li><li>  remplacer la méthode problématique dans la dernière classe enfant (dans le code, <code>turn_on()</code> dans la sous-classe <code>Laptop</code> ). </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; class Computer: public Device {}; class Monitor: public Device {}; class Laptop: public Computer, public Monitor { /* public: void turn_on() { cout &lt;&lt; "Laptop is on." &lt;&lt; endl; } // uncommenting this function will resolve diamond problem */ }; int main() { Laptop Laptop_instance; // Laptop_instance.turn_on(); // will produce compile time error // if Laptop.turn_on function is commented out // calling method of specific superclass Laptop_instance.Monitor::turn_on(); // treating Laptop instance as Monitor instance via static cast static_cast&lt;Monitor&amp;&gt;( Laptop_instance ).turn_on(); return 0; }</span></span></span></span></code> </pre> <br><p>  Si la méthode <code>turn_on()</code> pas été remplacée dans Laptop, l'appel à <code>Laptop_instance.turn_on()</code> entraînera une erreur de compilation.  Un objet <code>Laptop</code> peut accéder <code>turn_on()</code> deux <code>turn_on()</code> méthode <code>turn_on()</code> : <code>Device:Computer:Laptop.turn_on()</code> et <code>Device:Monitor:Laptop.turn_on()</code> . </p><br><h3 id="problema-romba-konstruktory-i-destruktory">  Le problème du diamant: constructeurs et destructeurs </h3><br><p>  Comme en C ++, lorsque l'objet de la classe enfant est initialisé, les constructeurs de toutes les classes parentes sont appelés, un autre problème se pose: le constructeur de la classe de base <code>Device</code> sera appelé deux fois. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } }; class Computer: public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } }; class Monitor: public Device { public: Monitor() { cout &lt;&lt; "Monitor constructor called" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; return 0; }</span></span></span></span></code> </pre> <br><h3 id="virtualnoe-nasledovanie">  Héritage virtuel </h3><br><p>  L'héritage virtuel empêche plusieurs objets de classe de base d'apparaître dans la hiérarchie d'héritage.  Ainsi, le constructeur de la classe de base <code>Device</code> ne sera appelé qu'une seule fois et un appel à la méthode <code>turn_on()</code> sans la <code>turn_on()</code> dans la classe enfant ne provoquera pas d'erreur de compilation. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; class Computer: virtual public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } }; class Monitor: virtual public Device { public: Monitor() { cout &lt;&lt; "Monitor constructor called" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); return 0; }</span></span></span></span></code> </pre> <br><p>  <em>Remarque</em> : l'héritage virtuel dans les classes <code>Computer</code> et <code>Monitor</code> n'autorisera pas l'héritage rhomboïde si la classe enfant <code>Laptop</code> n'hérite pas virtuellement de la classe <code>Device</code> ( <code>class Laptop: public Computer, public Monitor, public Device {};</code> ). </p><br><h3 id="abstraktnyy-klass">  Classe abstraite </h3><br><p>  En C ++, une classe dans laquelle existe au moins une méthode virtuelle pure est considérée comme abstraite.  Si la méthode virtuelle n'est pas remplacée dans la classe enfant, le code ne sera pas compilé.  De plus, en C ++, il est impossible de créer un objet d'une classe abstraite - une tentative provoquera également une erreur lors de la compilation. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } virtual void say_hello() = 0; }; class Laptop: public Device { public: void say_hello() { cout &lt;&lt; "Hello world!" &lt;&lt; endl; } }; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); Laptop_instance.say_hello(); // Device Device_instance; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h3 id="interfeys">  Interface </h3><br><p>  C ++, contrairement à certains langages OOP, ne fournit pas de mot clé distinct pour désigner une interface.  Cependant, l'implémentation de l'interface est possible en créant une classe abstraite pure - une classe dans laquelle il n'y a que des déclarations de méthode.  Ces classes sont également souvent appelées classes de base abstraites (ABC). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: virtual void turn_on() = 0; }; class Laptop: public Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); // Device Device_instance; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h1 id="advanced">  Avancé </h1><br><p>  Bien que l'héritage soit un principe fondamental de la POO, il doit être utilisé avec prudence.  Il est important de penser que tout code qui sera utilisé est susceptible d'être modifié et peut être utilisé d'une manière qui n'est pas évidente pour le développeur. </p><br><h3 id="nasledovanie-ot-realizovannogo-ili-chastichno-realizovannogo-klassa">  Héritage d'une classe implémentée ou partiellement implémentée </h3><br><p>  Si l'héritage ne provient pas d'une interface (une pure classe abstraite dans le contexte de C ++), mais d'une classe dans laquelle il existe des implémentations, il convient de considérer que l'héritier est connecté à la classe parente par la connexion la plus proche possible.  La plupart des modifications apportées à la classe parent peuvent affecter l'héritier, ce qui peut entraîner un comportement inattendu.  De tels changements dans le comportement de l'héritier ne sont pas toujours évidents - une erreur peut se produire dans le code déjà testé et fonctionnel.  Cette situation est exacerbée par la présence d'une hiérarchie de classes complexe.  Il faut toujours se rappeler que le code peut être modifié non seulement par la personne qui l'a écrit, et les chemins d'héritage évidents pour l'auteur peuvent ne pas être pris en compte par ses collègues. </p><br><p>  En revanche, il convient de noter que l'héritage de classes partiellement implémentées présente un avantage indéniable.  Les bibliothèques et les frameworks fonctionnent souvent comme suit: ils fournissent à l'utilisateur une classe abstraite avec plusieurs méthodes virtuelles et plusieurs implémentées.  Ainsi, la plus grande quantité de travail a déjà été effectuée - la logique complexe a déjà été écrite et l'utilisateur ne peut personnaliser la solution prête à l'emploi qu'en fonction de ses besoins. </p><br><h3 id="interfeys-1">  Interface </h3><br><p>  L'héritage d'une interface (pure classe abstraite) présente l'héritage comme une opportunité de structurer le code et de protéger l'utilisateur.  Étant donné que l'interface décrit le travail que fera la classe d'implémentation, mais ne décrit pas comment, tout utilisateur de l'interface est protégé contre les modifications de la classe qui implémente cette interface. </p><br><h3 id="interfeys-primer-ispolzovaniya">  Interface: Exemple d'utilisation </h3><br><p>  Tout d'abord, il convient de noter que l'exemple est étroitement lié au concept de polymorphisme, mais sera considéré dans le contexte de l'héritage d'une pure classe abstraite. </p><br><p>  Une application qui exécute une logique métier abstraite doit être configurée à partir d'un fichier de configuration distinct.  À un stade précoce de développement, le formatage de ce fichier de configuration n'était pas entièrement formé.  Passer l'analyse de fichiers derrière une interface offre plusieurs avantages. </p><br><p>  Le manque de clarté concernant le formatage du fichier de configuration ne ralentit pas le processus de développement du programme principal.  Deux développeurs peuvent travailler en parallèle - l'un sur la logique métier et l'autre sur l'analyseur.  Puisqu'ils interagissent via cette interface, chacun d'eux peut fonctionner de manière indépendante.  Cette approche facilite le codage des tests unitaires avec du code, car les tests nécessaires peuvent être écrits à l'aide de mock pour cette interface. </p><br><p>  De plus, lors de la modification du format de fichier de configuration, la logique métier de l'application n'est pas affectée.  La seule chose qui nécessite une transition complète d'un formatage à un autre est d'écrire une nouvelle implémentation de la classe abstraite déjà existante (classe analyseur).  De plus, le retour au format de fichier d'origine nécessite un travail minimal - remplacer un analyseur existant par un autre. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  L'héritage offre de nombreux avantages, mais doit être soigneusement conçu pour éviter les problèmes qu'il présente.  Dans le contexte de l'héritage, C ++ fournit une large gamme d'outils qui ouvre une tonne de possibilités au programmeur. </p><br><p>  Et SOLID est bon. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445948/">https://habr.com/ru/post/fr445948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445928/index.html">Comment nous avons augmenté la productivité de Tensorflow au service de 70%</a></li>
<li><a href="../fr445932/index.html">Sécurité des applications client: conseils pratiques pour un développeur frontal</a></li>
<li><a href="../fr445936/index.html">Développement électronique. À propos des microcontrôleurs sur les doigts</a></li>
<li><a href="../fr445940/index.html">AMA avec Habr, v 7.0. Citron, beignets et nouvelles</a></li>
<li><a href="../fr445946/index.html">MWC: mode d'emploi</a></li>
<li><a href="../fr445952/index.html">Un billion de petits célibataires</a></li>
<li><a href="../fr445954/index.html">Accélérateur d'IA de HSE, MTS et Rostelecom</a></li>
<li><a href="../fr445958/index.html">SPDS GraphiCS - système de façade et de toiture</a></li>
<li><a href="../fr445962/index.html">Stage en informatique: le point de vue du manager</a></li>
<li><a href="../fr445964/index.html">MEPhI accueillera une olympiade étudiante sur la sécurité de l'information: comment participer et ce qu'elle donne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>