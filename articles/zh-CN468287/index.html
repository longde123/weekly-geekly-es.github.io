<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📈 👷🏼 🏅 C＃属性：关于所有方面 👩‍❤️‍💋‍👩 ✌🏼 👩‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您好读者。 本文从各个方面描述了属性-从规范，属性的含义和定义，创建自己的属性以及如何使用它们，最后在运行时添加属性以及最有用和最有趣的现有属性。 如果您对C＃中的属性主题感兴趣，欢迎使用cat。 


 目录内容 


1. 引言 定义和分配属性 
2. 运行时支持有趣的属性。 在这里，将提供有关...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C＃属性：关于所有方面</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468287/"> 您好读者。 本文从各个方面描述了属性-从规范，属性的含义和定义，创建自己的属性以及如何使用它们，最后在运行时添加属性以及最有用和最有趣的现有属性。 如果您对C＃中的属性主题感兴趣，欢迎使用cat。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u4/uk/ee/u4ukeefozvzkxjtgw9i8zbap6ly.jpeg"></div><a name="habracut"></a><br><h2> 目录内容 </h2><br><ol><li> 引言 定义和分配属性 </li><li> 运行时支持有趣的属性。 在这里，将提供有关各种属性的简短信息，这些属性的存在鲜为人知，甚至很少使用。 由于这绝对是不切实际的信息，因此不会有太多的抱怨（与我对不适用的知识的热情相反） </li><li>一些有用的鲜为人知的属性。 </li><li> 定义属性并进行处理。 在运行时添加属性 </li></ol><br><h2> 引言 </h2><br> 与往常一样，从定义和规范开始。 这将有助于理解和实现各个级别的属性，这反过来对于找到适合它们的正确应用程序非常有用。 <br><br> 首先定义元数据。  <b>元</b>数据是描述和引用<abbr title="普通型系统">CTS</abbr>定义的类型的数据。 元数据的存储方式独立于任何特定的编程语言。 因此，元数据提供了一种通用的机制，可以在需要它的工具（编译器和调试器，以及程序本身）之间以及在<abbr title="虚拟执行系统">VES</abbr>之间交换有关程序的信息，以供使用。 元数据包含在程序集清单中。 它们可以与<abbr title="中级语言">IL</abbr>代码一起存储在<abbr title="可移植可执行文件">PE</abbr>文件中，也可以存储在单独的PE文件中，在该文件中只有程序集清单。 <br>  <b>属性</b>是包含描述性信息的类型或其成员（或其他语言构造）的特征。 尽管最常见的属性是预定义的，并且在元数据中具有特定的格式，但是也可以将自定义属性添加到元数据中。 属性是可交换的，即 它们在元素上的声明顺序并不重要 <br><br>  <b>从语法角度（在元数据中）来看，有以下属性</b> <br><br><ol><li> 在IL中使用特殊语法。 例如，关键字是属性。 对于他们来说，IL中有一种特殊的语法。 其中有很多；列出所有内容都没有意义 </li><li> 使用广义语法。 这些包括用户和库属性。 </li><li> 安全属性。 其中包括从SecurityAttribute继承的属性（直接或间接）。 它们以特殊方式处理。  IL中有一种特殊的语法，允许您创建直接描述这些属性的xml。 </li></ol><br><h4> 例子 </h4><br><div class="spoiler">  <b class="spoiler_title">包含上述所有类型的属性的C＃代码</b> <div class="spoiler_text"><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] [Serializable] [Obsolete] [SecurityPermission(SecurityAction.Assert)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Sample</span></span> { }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">结果IL</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.class public EXPLICIT ansi SERIALIZABLE beforefieldinit AttributeSamples.Sample extends [System.Runtime]System.Object { .custom instance void [System.Runtime]System.ObsoleteAttribute::.ctor() = (01 00 00 00 ) .permissionset assert = { class 'System.Security.Permissions.SecurityPermissionAttribute, System.Runtime.Extensions, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' = {}} .method public hidebysig specialname rtspecialname instance void .ctor() cil managed {/*constructor body*/} }</code> </pre><br></div></div><br> 如您所见，StructLayoutAttribute具有特殊的语法，因为在IL中它表示为“显式”。  ObsoleteAttribute使用通用语法-在IL中以“ .custom”开头。  SecurityPermissionAttribute作为安全属性已变成“ .permissionset assert”。 <br><br> 用户属性将用户信息添加到元数据。 此机制可用于在编译时存储特定于应用程序的信息，并在运行时访问该信息，或用于其他工具的读取和分析。 尽管任何用户定义的类型都可以用作属性，但<abbr title="通用语言规范">CLS</abbr>一致性要求属性继承自System.Attribute。  <abbr title="通用语言基础架构">CLI</abbr>预定义了一些属性，并使用它们来控制运行时行为。 一些语言定义属性以表示未在CTS中直接表示的语言功能。 <br><br> 如上所述，属性存储在元数据中，而元数据又在编译阶段生成，即 在PE文件中输入（通常是* .dll）。 因此，您只能在运行时修改可执行文件才能在运行时添加属性（但是自更改程序的时间已久）。 因此，它们不能在执行阶段添加，但这并不完全准确。 如果我们形成程序集，在其中定义类型，那么我们可以在执行阶段创建一个新类型并将其挂起属性。 因此，从形式上讲，我们仍然可以在运行时添加属性（示例将在最底部）。 <br><br><h4> 现在介绍一些限制 </h4><br> 如果由于某种原因，在同一程序集中有两个名称分别为Name和NameAtribute的属性，则无法将它们放在第一个。 使用[名称]（即不带后缀）时，编译器表示看到不确定性。 使用[NameAttribute]时，我们将放置NameAttribute，这是合乎逻辑的。 对于这种神秘的情况，有一种特殊的语法，命名时缺乏想象力。 要放置第一个不带后缀的版本，可以在属性名称[@Name]之前指定狗的符号（即[Name]是个笑话，没有必要）。 <br><br> 可以将自定义属性添加到除自定义属性之外的任何内容。 这是指元数据，即 如果将属性放在属性类上方的C＃中，则在元数据中它将引用该类。 但是您不能将属性添加到“公共”。 但是您可以使用程序集，模块，类，值类型，枚举，构造函数，方法，属性，字段，事件，接口，参数，委托，返回值或广义参数。 下面的示例显示了如何将属性放在特定构造上的明显示例，但不是非常示例。 <br><br><div class="spoiler">  <b class="spoiler_title">属性声明语法</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Runtime.InteropServices; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Security.Permissions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> AttributeSamples; [assembly:All] [module:All] <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">AttributeSamples</span></span> { [AttributeUsage(AttributeTargets.All)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AllAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { } [All] <span class="hljs-comment"><span class="hljs-comment">//   public class Usage { [All] //   [return:All] //     public int GiveMeInt&lt;[All]T&gt;([All]int param) { return 5 + param; } [All] //   [field:All] //        public event Action Event; [All] //   [field: All] //       public int Action { get; set; } } }</span></span></code> </pre><br></div></div><br> 属性具有两种类型的参数-命名参数和位置参数。 位置参数包括构造函数参数。 要命名-具有可访问设置器的公共属性。 而且，这些不只是形式名称；在属性名称后的方括号中声明属性时，可以指示所有参数。 命名的是可选的。 <br><br><div class="spoiler">  <b class="spoiler_title">参数类型</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AttributeUsage(AttributeTargets.All, AllowMultiple = true)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AttrParamsAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AttrParamsAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> positional</span></span></span><span class="hljs-function">) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//  { } public int Named { get; set; } //  } [AttrParams(1)] [AttrParams(1, Named = 2)] public class AttrParams { }</span></span></span></span></code> </pre><br></div></div><br> 该属性的有效参数（两种类型）必须是以下类型之一： <br><br><ol><li>  bool，byte，char，double，float，int，long，short，string以及其他基本类型（十进制除外） </li><li> 对象 </li><li> 系统类型 </li><li> 枚举 </li><li> 以上任何类型的一维数组 </li></ol><br> 这主要是因为它应该是一个编译时常量，并且上面的类型可以接受该常量（通过接受一个对象，我们可以传递int）。 但是出于某种原因，该参数不能为ValueType类型，尽管从逻辑角度来看这是可能的。 <br><br> 用户属性有两种：真正的定制属性和<b>伪定制</b> 。 <br> 在代码中，它们看起来相同（它们在语言结构上方的方括号中表示），但是它们的处理方式不同： <br><br><ol><li> 原始用户属性直接存储在元数据中； 属性参数按原样存储。 它们在运行时可用，并保存为一组字节（我不得不提醒您它们在编译时是已知的） </li><li> 可以识别伪用户属性，因为其名称是特殊列表之一。 而不是直接将其数据存储在元数据中，而是对其进行分析并用于设置元数据表中的位或字段，然后丢弃该数据，无法进一步接收该数据。 在运行时检查元数据表的速度要比真正的用户属性快，并且需要较少的存储空间来存储信息。 </li></ol><br><div class="spoiler">  <b class="spoiler_title">伪用户属性不可见</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] [StructLayout(LayoutKind.Explicit)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomPseudoCustom</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onlyCustom = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CustomPseudoCustom).GetCustomAttributes(); <span class="hljs-comment"><span class="hljs-comment">// SerializableAttribute } }</span></span></code> </pre><br></div></div><br> 大多数用户属性是在语言级别引入的。 它们由运行时存储并返回，而运行时对这些属性的含义一无所知。 但是，所有伪用户属性以及一些用户属性对于编译器和CLI都是特别重要的。 因此，我们继续下一部分。 <br><br><h2> 启用运行时的属性 </h2><br> 本部分仅提供参考，如果您对使用运行时没有兴趣，则可以滚动到下一部分。 <br><br> 下表列出了伪用户属性和特殊用户属性（CLI或编译器以特殊方式处理它们）。 <br><br> 伪用户属性（无法通过反射获得）。 <br>  CLI属性： <br><div class="scrollable-table"><table><tbody><tr><th> 属性 </th><th> 内容描述 </th></tr><tr><td>  AssemblyAlgorithmIDAttribute </td><td> 写入使用的哈希算法的标识符。 设置Assembly.HashAlgId字段 </td></tr><tr><td>  AssemblyFlagsAttribute </td><td> 为相应的程序集写入标志。 设置Assembly.Flags字段 </td></tr><tr><td>  DllImportAttribute </td><td> 提供有关在非托管库中实现的代码的信息。 设置相应方法的Method.Flags.PinvokeImpl位； 向ImplMap添加一个新条目（通过设置MappingFlags，MemberForwarded，ImportName和ImportScope的值） </td></tr><tr><td>  StructLayoutAttribute </td><td> 允许您显式设置放置引用字段或重要类型的字段的方法。 设置类型的TypeDef.Flags.LayoutMask字段。 它还可以设置TypeDef.Flags.StringFormatMask，ClassLayout.PackingSize和ClassLayout.ClassSize字段 </td></tr><tr><td>  FieldOffsetAttribute </td><td> 定义引用或有效类型中字段的字节偏移量。 设置对应方法的FieldLayout.OffSet的值。 </td></tr><tr><td> 归因 </td><td> 指示参数作为[in]参数传递。 设置相应参数的Param.Flags.In位。 </td></tr><tr><td> 超越属性 </td><td> 指示参数作为[out]参数传递。 设置相应参数的Param.Flags.Out位。 </td></tr><tr><td>  Marshalasattribute </td><td> 定义如何在托管和非托管代码之间封送数据。 设置字段的Field.Flags.HasFieldMarshal位（或为参数设置Param.Flags.HasFieldMarshal位）； 将一个条目添加到FieldMarshal表中（通过设置Parent和NativeType的值） </td></tr><tr><td>  MethodImplAttribute </td><td> 定义方法的实现细节。 设置相应方法的Method.ImplFlags值 </td></tr></tbody></table></div><br><br>  CLS属性-语言必须支持它们： <br><div class="scrollable-table"><table><tbody><tr><th> 属性 </th><th> 内容描述 </th></tr><tr><td>  AttributeUsageAttribute </td><td> 用于指示如何使用属性。 </td></tr><tr><td>  ObsoleteAttribute </td><td> 指示不应使用该项目。 </td></tr><tr><td>  CLSCompliantAttribute </td><td> 指示项目是否声明为符合CLS。 </td></tr></tbody></table></div><br> 杂项有趣 <br><div class="scrollable-table"><table><tbody><tr><th> 属性 </th><th> 内容描述 </th></tr><tr><td>  ThreadStaticAttribute </td><td> 提供与流相关的类型字段 </td></tr><tr><td> 条件属性 </td><td> 根据编译条件（在/ define中指定）将方法标记为已调用。 如果不满足条件，则将不会调用该方法（也不会将其编译为IL）。 只有void方法可以被标记。 否则，将发生编译错误。 </td></tr><tr><td>  DecimalConstantAttribute </td><td> 在元数据中存储十进制常数值 </td></tr><tr><td>  DefaultMemberAttribute </td><td> 定义默认情况下与InvokeMember方法一起使用的类的成员。 </td></tr><tr><td>  CompilationRelaxationsAttribute </td><td> 指示指令检查的异常是严格的还是宽松的。 当前，您只能传递NoStringInterning参数，该参数将程序集标记为不需要字符串文字内联。 但是这种机制仍然可以使用。 </td></tr><tr><td>  FlagsAttribute </td><td> 指示是否应将枚举视为位标志的属性 </td></tr><tr><td>  IndexerNameAttribute </td><td> 指定将在不直接支持此功能的编程语言中使用索引器的名称。 </td></tr><tr><td>  ParamArrayAttribute </td><td> 指示该方法接受可变数量的参数。 </td></tr></tbody></table></div><br><h2> 有用的属性 </h2><br> 软件产品开发的组成部分是调试。 而且在大型而复杂的系统中，运行相同的方法并监视对象的状态通常需要数十次甚至数百次。 同时，在20点的时间，它已经开始特别激起需要将一个对象扩展到400倍以查看一个变量的值并再次重新启动该方法的需要。 <br> 为了更安静，更快速地调试，您可以使用修改调试器行为的属性。 <br><br>  <b>DebuggerDisplayAttribute</b>指示类型或其成员在调试器变量窗口中的显示方式（不仅限于此）。 <br><br> 构造函数的唯一参数是具有显示格式的字符串。 括号之间的内容将被计算。 格式就像插值的字符串，只是没有美元。 您不能在计算值中使用指针。 顺便说一句，如果您有一个重写的ToString，则将显示它的值，就像它在此属性中一样。 如果同时有ToString和属性，则从属性获取值。 <br><img src="https://habrastorage.org/webt/eg/l9/mp/egl9mpyoppftcevpckbs4qznh-c.png"><br><br>  <b>DebuggerBrowsableAttribute</b>定义在调试器变量窗口中如何显示字段或属性。 接受DebuggerBrowsableState，它具有3个选项： <br><br><ul><li> 从不-调试期间完全不显示该字段。 扩展对象的层次结构时，不会显示此字段 </li><li> 折叠-字段尚未解决，但可以扩展。 这是默认行为。 </li><li>  RootHidden-字段本身未显示，但显示了其组成的对象（用于数组和集合） </li></ul><br><img src="https://habrastorage.org/webt/6m/a5/gf/6ma5gf06sqj0eryekzparfrzq0i.png"><br><br>  <b>DebuggerTypeProxy-</b>如果一天要在调试器中查看该对象数百次，您可能会感到困惑，花3分钟创建一个代理对象，该代理对象应按原样显示原始对象。 通常，要显示的代理对象是内部类。 实际上，它将显示而不是目标对象。 <br><br><img src="https://habrastorage.org/webt/np/bg/zd/npbgzdwf_ontlgkwcr3adapeink.png"><br><br> 其他有用的属性 <br><br>  <b>ThreadStatic-</b>一个属性，允许您为每个线程自己创建一个静态变量。 为此，请将属性放在静态字段上方。 值得记住的一个重要细微差别-静态构造函数的初始化将仅执行一次，并且变量将在静态构造函数执行的线程中更改。 在其他情况下，它将保持默认状态。  （PS。如果您需要这种行为，我建议您看一下ThreadLocal类）。 <br><br> 关于发动机舱的细微差别。 在Linux和Windows中，流本地都有一个内存区域（分别为<abbr title="线程本地存储">TLS</abbr>和<abbr title="特定于线程的数据">TSD</abbr> ）。 但是，这些区域本身很小。 因此，将创建一个ThreadLocalInfo结构，并将指针放在TLS中。 因此，仅使用一个插槽。 结构本身包含3个字段-Thread，AppDomain，ClrTlsInfo。 我们对第一个感兴趣。 正是使用ThreadLocalBlock和ThreadLocalModule来组织流静态信息在内存中的存储。 <br><br> 通过这种方式： <br><br><ul><li> 引用类型-位于堆上的ThreadStaticHandleTable（由ThreadLocalBlock类支持）保持与它们的链接。 </li><li> 结构-打包并存储在托管堆中以及引用类型 </li><li> 原始有效类型存储在ThreadLocalModule的一部分非托管内存中 </li></ul><br> 好吧，由于我们正在谈论这一点，因此值得一提的是异步方法。 细心的读者可能会注意到，如果我们使用异步，那么延续不一定会在同一线程中执行（我们可以影响执行上下文，但不会影响线程）。 相应地，如果我们使用ThreadLocal，我们将得到废话。 在这种情况下，建议使用AsyncLocal。 但是这篇文章不是关于这个的，所以我们走得更远。 <br><br>  <b>InternalsVisibleTo-</b>允许您指定程序集，该程序集将对标记为<i>internal的</i>元素可见。 看起来，如果某些程序集需要某些类型及其成员，则可以简单地将其标记为<i>公开，</i>而不用标明它们。 但是好的架构意味着隐藏实现细节。 但是，某些基础设施可能需要它们，例如测试项目。 使用此属性，可以同时支持封装和所需的测试覆盖率百分比。 <br><br>  <b>HandleProcessCorruptedStateExceptions-</b>允许您吓胆小的程序员并捕获损坏状态的异常。 默认情况下，对于此类异常，CLR不会捕获。 通常，最好的解决方案是让应用程序崩溃。 这些危险的异常表明进程内存已损坏，因此使用此属性是一个非常糟糕的主意。 但是在某些情况下，对于本地开发来说，设置此属性一段时间会很有用。 要捕获损坏状态的异常，只需将此属性放在方法上方。 并且，如果已经达到使用此属性的程度，则建议（不过，一如既往）捕获一些特定的异常。 <br><br>  <b>DisablePrivateReflection-</b>使程序集的所有私有成员无法进行反射。 该属性被放在装配上。 <br><br><h2> 定义属性 </h2><br> 不只是因为本节是最后一部分。 毕竟，了解在哪种情况下使用属性会有所帮助的最佳方法是查看已使用的属性。 当您考虑自己的属性时，很难说出正式的规则。 通常，它们被用作有关类型/其成员或完全不同的实体共有的另一种语言构造的附加信息。 例如，所有用于序列化/ ORM /格式化等的属性。 由于这些机制广泛应用于完全不同的类型，而相应机制的开发人员通常不知道这些类型，因此属性的使用是使用户能够为该机制提供声明性信息的好方法。 <br><br> 使用属性可以分为两个部分： <br><br><ol><li> 创建一个属性并使用它 </li><li> 获取属性并对其进行处理 </li></ol><br><h4> 创建一个属性并使用它 </h4><br> 要创建您的属性，从<i>System.Attribute</i>继承就足够了。 在这种情况下，建议遵循上述命名方式-在Attribute上结束类名。 但是，如果省略此后缀，则不会有任何错误。 如前所述，属性可以具有两种类型的参数-位置参数和命名参数。 它们的应用逻辑与该类的构造函数的属性和参数相同-将创建没有合理“默认”值的对象所需的值放在位置（即构造函数）中。 可以合理使用的默认值（通常会使用）可以更好地区分为已命名的值（即属性）。 <br><br> 创建属性的重要意义在于其应用位置的限制。  AttributeUsageAttribute用于此目的。 必需的参数（位置）是AttributeTarget，它确定使用属性的位置（方法，程序集等）。 可选（命名）参数为： <br><br><ol><li>  AllowMultiple-指示是否可以在其应用程序位置放置多个属性。 默认为假 </li><li>  Inherited-继承-确定此属性是否属于类的继承者（如果放置在基类上）和重写的方法（如果放置在方法上）。 默认值为true。 </li></ol><br> 之后，您可以使用有效负载加载属性。 属性是声明性信息，这意味着其中定义的所有内容都应描述与其相关的构造。 该属性不应包含任何深层逻辑。 对于您定义的属性的处理，应负责仅处理它们的特殊服务。 但是，属性不应该包含逻辑这一事实并不意味着它不应该包含方法。 <br><br> 方法（功能）也是信息，也可以描述设计。 并且，通过在属性中使用多态性，您可以提供一个功能强大且方便的工具，用户可以在其中影响工具所使用的信息以及执行和处理的某些阶段。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，他将不需要产生类，注入依赖项，成本工厂及其将创建这些类的接口。</font><font style="vertical-align: inherit;">创建一个单独的继承类就足够了，该继承类封装了与之相关的元素的工作细节。</font><font style="vertical-align: inherit;">但是，通常，具有几个属性的常规ROSO属性就足够了。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 检索和处理属性 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接收到的属性的处理取决于特定情况，并且可以完全不同的方式完成。为此很难给出有用的功能和技巧。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在运行时使用反射获得属性。有多种方法可从特定元素获取属性。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，一切都源自</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ICustomAttributeProvider</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接口</font><font style="vertical-align: inherit;">。它由Assembly，MemberInfo，Module，ParameterInfo等类型实现。反过来，MemberInfo的后继者是Type，EventInfo，FieldInfo，MethodBase，PropertyInfo。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该界面只有3个功能，而且不太方便。它们使用数组（即使我们知道只能有一个属性），也不按类型（它们使用对象）进行参数化。因此，您几乎不必直接访问此接口的功能（我从未说过，因为我不想被分类）。为了易于使用，有一个</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomAttributeExtensions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">，其中有许多用于各种类型的扩展方法，这些扩展方法可以执行简单的转换操作，选择单个值等等，从而使开发人员摆脱了这种需求。同样，这些方法在Attribute类中可以作为静态使用，具有忽略继承参数（对于非遵从者）的最有用功能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下面列出了使用的主要功能。</font><font style="vertical-align: inherit;">指示哪种类型扩展方法的第一个参数，我省略了。</font><font style="vertical-align: inherit;">另外，无论在何处</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定boolInherit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数</font><i><font style="vertical-align: inherit;">，都将</font></i><font style="vertical-align: inherit;">存在重载（默认值为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">此参数指定在执行方法时（如果在重写的方法上使用）是应考虑父类的属性还是基方法的属性。</font><font style="vertical-align: inherit;">如果在属性</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inherit = flase中</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那么即使将其设置为true也无助于考虑基类的属性</font></font><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 方法名称 </font></font></th><th> 内容描述 </th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttributes &lt;LogAttribute&gt;（布尔继承） </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获取指定类型的属性的枚举。</font><font style="vertical-align: inherit;">如果该属性为1，则将返回1个元素的枚举</font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttribute &lt;LogAttribute&gt;（布尔继承） </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回指定类型的单个属性。</font><font style="vertical-align: inherit;">如果有多个，则抛出</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Reflection.AmbiguousMatchException：找到相同类型的多个自定义属性</font></font></i> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttributes（） </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 返回所有类型的属性的枚举 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttributesData（） </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 返回枚举CustomAttributeData，其中包含允许您获取构造函数，参数（命名和位置），构造函数参数的属性 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IsDefined（类型attrType，布尔继承） </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果在元素上声明了属性，则返回true；否则，返回false </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为了清楚起见，我建议看一下所提到的所有功能的小型演示。 </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上述方法的返回值</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AttributeUsage(AttributeTargets.All, AllowMultiple = true)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LogAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LogName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } [AttributeUsage(AttributeTargets.All, AllowMultiple = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, Inherited = <span class="hljs-literal"><span class="hljs-literal">false</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SerializeAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SerializeName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogBase1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogBase2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeBase1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeBase2"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RandomDomainEntityBase</span></span> { [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogMethod1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogMethod2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeMethod1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeMethod2"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); } } [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogDerived1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogDerived2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeDerived1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeDerived2"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RandomDomainEntityDerived</span></span> : <span class="hljs-title"><span class="hljs-title">RandomDomainEntityBase</span></span> { [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogOverride1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogOverride2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeOverride1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeOverride2"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type derivedType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(RandomDomainEntityDerived); MemberInfo overrideMethod = derivedType.GetMethod(<span class="hljs-string"><span class="hljs-string">"VirtualMethod"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// overrideMethod.GetCustomAttribute(typeof(LogAttribute)); //System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. // overrideMethod.GetCustomAttribute&lt;LogAttribute&gt;(false); // System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. // Attribute.GetCustomAttribute(derivedType, typeof(SerializeAttribute)); // System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. IEnumerable&lt;Attribute&gt; allCustom = overrideMethod.GetCustomAttributes(); //LogOverride1 LogOverride2 SerializeOverride1 SerializeOverride2 LogMethod1 LogMethod2 IList&lt;CustomAttributeData&gt; allCustomInfo = overrideMethod.GetCustomAttributesData(); //  ,     IEnumerable&lt;LogAttribute&gt; typedCustom1 = overrideMethod.GetCustomAttributes&lt;LogAttribute&gt;(inherit:false); //LogOverride1 LogOverride2 IEnumerable&lt;LogAttribute&gt; typedInheritedCustom1 = overrideMethod.GetCustomAttributes&lt;LogAttribute&gt;(inherit:true); //LogOverride1 LogOverride2 LogMethod1 LogMethod2 IEnumerable&lt;SerializeAttribute&gt; typedCustom2 = overrideMethod.GetCustomAttributes&lt;SerializeAttribute&gt;(inherit:false); //SerializeOverride1 SerializeOverride2 IEnumerable&lt;SerializeAttribute&gt; typedInheritedCustom2 = overrideMethod.GetCustomAttributes&lt;SerializeAttribute&gt;(inherit:true); //SerializeOverride1 SerializeOverride2 Attribute[] customFromStaticClass = Attribute.GetCustomAttributes(overrideMethod, typeof(SerializeAttribute), inherit:true); //SerializeOverride1 SerializeOverride2 IEnumerable&lt;Attribute&gt; classCustom = derivedType.GetCustomAttributes(); //LogDerived1 LogDerived2 SerializeDerived1 SerializeDerived2 LogBase1 LogBase2 IList&lt;CustomAttributeData&gt; classCustomInfo = derivedType.GetCustomAttributesData(); //  ,     IEnumerable&lt;LogAttribute&gt; typedClassCustom1 = derivedType.GetCustomAttributes&lt;LogAttribute&gt;(false); //LogDerived1 LogDerived2 IEnumerable&lt;LogAttribute&gt; typedInheritedClassCustom1 = derivedType.GetCustomAttributes&lt;LogAttribute&gt;(true); //LogDerived1 LogDerived2 LogBase1 LogBase2 IEnumerable&lt;SerializeAttribute&gt; typedClassCustom2 = derivedType.GetCustomAttributes&lt;SerializeAttribute&gt;(false); //SerializeDerived1 SerializeDerived2 IEnumerable&lt;SerializeAttribute&gt; typedInheritedClassCustom2 = derivedType.GetCustomAttributes&lt;SerializeAttribute&gt;(true); //SerializeDerived1 SerializeDerived2 } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，出于学术兴趣，我举了一个在运行时定义属性的示例。</font><font style="vertical-align: inherit;">此代码并不声称是最精美和受支持的代码。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代号</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TypeCreator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> TypeSignature = <span class="hljs-string"><span class="hljs-string">"DynamicType"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ModuleName = <span class="hljs-string"><span class="hljs-string">"DynamicModule"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> AssemblyName = <span class="hljs-string"><span class="hljs-string">"DynamicModule"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> TypeBuilder _typeBuilder = GetTypeBuilder(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateTypeInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _typeBuilder.DefineNestedType(<span class="hljs-string"><span class="hljs-string">"ClassName"</span></span>); CreatePropertyWithAttribute&lt;SerializeAttribute&gt;(<span class="hljs-string"><span class="hljs-string">"PropWithAttr"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Type[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Type newType = _typeBuilder.CreateType(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Activator.CreateInstance(newType); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreatePropertyWithAttribute&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName, Type propertyType, Type[] ctorTypes, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] ctorArgs) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Attribute { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attributeCtor = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T).GetConstructor(ctorTypes); CustomAttributeBuilder caBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomAttributeBuilder(attributeCtor, ctorArgs); PropertyBuilder newProperty = CreateProperty(propertyName, propertyType); newProperty.SetCustomAttribute(caBuilder); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> PropertyBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> propertyName, Type propertyType</span></span></span><span class="hljs-function">)</span></span> { FieldBuilder fieldBuilder = _typeBuilder.DefineField(propertyName, propertyType, FieldAttributes.Private); PropertyBuilder propertyBuilder = _typeBuilder.DefineProperty(propertyName, PropertyAttributes.HasDefault, propertyType, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); MethodAttributes getSetAttr = MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig; MethodBuilder getter = GenerateGetter(); MethodBuilder setter = GenerateSetter(); propertyBuilder.SetGetMethod(getter); propertyBuilder.SetSetMethod(setter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> propertyBuilder; <span class="hljs-function"><span class="hljs-function">MethodBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateGetter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { MethodBuilder getMethodBuilder = _typeBuilder.DefineMethod(<span class="hljs-string"><span class="hljs-string">$"get_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{propertyName}</span></span></span><span class="hljs-string">"</span></span>, getSetAttr, propertyType, Type.EmptyTypes); ILGenerator getterIl = getMethodBuilder.GetILGenerator(); getterIl.Emit(OpCodes.Ldarg_0); getterIl.Emit(OpCodes.Ldfld, fieldBuilder); getterIl.Emit(OpCodes.Ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getMethodBuilder; } <span class="hljs-function"><span class="hljs-function">MethodBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateSetter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { MethodBuilder setMethodBuilder = _typeBuilder.DefineMethod(<span class="hljs-string"><span class="hljs-string">$"set_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{propertyName}</span></span></span><span class="hljs-string">"</span></span>, getSetAttr, <span class="hljs-literal"><span class="hljs-literal">null</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { propertyType }); ILGenerator setterIl = setMethodBuilder.GetILGenerator(); setterIl.Emit(OpCodes.Ldarg_0); setterIl.Emit(OpCodes.Ldarg_1); setterIl.Emit(OpCodes.Stfld, fieldBuilder); setterIl.Emit(OpCodes.Ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> setMethodBuilder; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTypeBuilder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AssemblyName(AssemblyName), AssemblyBuilderAccess.Run); ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(ModuleName); TypeBuilder typeBuilder = moduleBuilder.DefineType(TypeSignature, TypeAttributes.Public | TypeAttributes.Class | TypeAttributes.AutoClass | TypeAttributes.AnsiClass | TypeAttributes.BeforeFieldInit | TypeAttributes.AutoLayout,<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typeBuilder; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeCreator().CreateTypeInstance(); IEnumerable&lt;Attribute&gt; attrs = instance.GetType().GetProperty(<span class="hljs-string"><span class="hljs-string">"PropWithAttr"</span></span>).GetCustomAttributes(); <span class="hljs-comment"><span class="hljs-comment">// Serializable } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN468287/">https://habr.com/ru/post/zh-CN468287/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN468263/index.html">向新的Visual Studio终端问好</a></li>
<li><a href="../zh-CN468267/index.html">加强Alistair Coburn书中给出的UseCase方法</a></li>
<li><a href="../zh-CN468271/index.html">测试与 类型-Rust版本</a></li>
<li><a href="../zh-CN468277/index.html">程序员的工作艰辛吗？从心理生理学的角度来看</a></li>
<li><a href="../zh-CN468285/index.html">面向企业和初创企业的顶级软件开发公司</a></li>
<li><a href="../zh-CN468289/index.html">上午</a></li>
<li><a href="../zh-CN468291/index.html">马克·高尔斯顿（Mark Gaulston）的书“我能听见你的经历”的摘要</a></li>
<li><a href="../zh-CN468293/index.html">Vive Cosmos-HTC的新VR集评</a></li>
<li><a href="../zh-CN468295/index.html">matplotlib的50种阴影-主控​​图（带有完整的Python代码）</a></li>
<li><a href="../zh-CN468299/index.html">在2019年及之后为开发人员开发Oracle的内容</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>