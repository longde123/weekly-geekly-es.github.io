<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôé üöë üçï Python 3.5 Implementando a simultaneidade usando asyncio üë©üèø‚Äçü§ù‚Äçüë®üèæ ü§∞üèæ ‚¨ÖÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tradu√ß√£o do Cap√≠tulo 13 Concorr√™ncia 
 do livro 'Expert Python Programming', 
 Segunda edi√ß√£o 
 Micha≈Ç Jaworski e Tarek Ziad√©, 2016 
 
 Programa√ß√£o as...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python 3.5 Implementando a simultaneidade usando asyncio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484446/">  <i>Tradu√ß√£o do Cap√≠tulo 13 Concorr√™ncia</i> <i><br></i>  <i>do livro 'Expert Python Programming',</i> <i><br></i>  <i>Segunda edi√ß√£o</i> <i><br></i>  <i>Micha≈Ç Jaworski e Tarek Ziad√©, 2016</i> <i><br></i> <br><h4>  Programa√ß√£o ass√≠ncrona </h4><br>  Nos √∫ltimos anos, a programa√ß√£o ass√≠ncrona ganhou grande popularidade.  O Python 3.5 finalmente conseguiu algumas fun√ß√µes de sintaxe que refor√ßam os conceitos de solu√ß√µes ass√≠ncronas.  Mas isso n√£o significa que a programa√ß√£o ass√≠ncrona se tornou poss√≠vel apenas desde o Python 3.5.  Muitas bibliotecas e estruturas foram fornecidas muito antes, e a maioria delas se originou em vers√µes mais antigas do Python 2. Existe at√© uma implementa√ß√£o alternativa completa do Python chamada Stackless (consulte o Cap√≠tulo 1, ‚ÄúO status atual do Python‚Äù), que se concentra nessa √∫nica abordagem de programa√ß√£o.  Para algumas solu√ß√µes, como <b>Twisted, Tornado</b> ou <b>Eventlet</b> , as comunidades ativas ainda existem e valem a pena conhecer.  De qualquer forma, a partir do Python 3.5, a programa√ß√£o ass√≠ncrona ficou mais f√°cil do que nunca.  Portanto, espera-se que suas fun√ß√µes ass√≠ncronas incorporadas substituam a maioria das ferramentas antigas, ou projetos externos gradualmente se transformem em um tipo de estruturas de alto n√≠vel baseadas no Python interno. <br><a name="habracut"></a><br>  Ao tentar explicar o que √© programa√ß√£o ass√≠ncrona, √© mais f√°cil pensar nessa abordagem como algo semelhante aos threads, mas sem um planejador de sistema.  Isso significa que um programa ass√≠ncrono pode processar tarefas ao mesmo tempo, mas seu contexto √© alternado internamente e n√£o pelo planejador do sistema. <br><br>  Mas, √© claro, n√£o usamos threads para processamento paralelo de tarefas em um programa ass√≠ncrono.  A maioria das solu√ß√µes usa conceitos diferentes e, dependendo da implementa√ß√£o, s√£o chamados de maneira diferente.  Alguns exemplos de nomes usados ‚Äã‚Äãpara descrever esses objetos de programa paralelo s√£o: <br><br><ul><li>  Linhas verdes - <b>linhas</b> verdes (projetos de greenlet, gevent ou eventlet) </li><li>  Coroutines - coroutines (programa√ß√£o ass√≠ncrona pura em Python 3.5) </li><li>  <b>Tasklets (Python sem pilha)</b> Estes s√£o basicamente os mesmos conceitos, mas geralmente s√£o implementados de maneiras ligeiramente diferentes. </li></ul><br>  Por raz√µes √≥bvias, nesta se√ß√£o, focaremos apenas as corotinas que s√£o inicialmente suportadas pelo Python, come√ßando na vers√£o 3.5. <br><br><h4>  Multitarefa colaborativa e E / S ass√≠ncrona </h4><br>  A multitarefa colaborativa √© o n√∫cleo da programa√ß√£o ass√≠ncrona.  Nesse sentido, a multitarefa no sistema operacional n√£o √© necess√°ria para iniciar uma troca de contexto (para outro processo ou encadeamento), mas cada processo libera voluntariamente o controle quando est√° no modo de espera para garantir a execu√ß√£o simult√¢nea de v√°rios programas.  √â por isso que √© chamado de colaborativo.  Todos os processos devem trabalhar juntos para garantir que a multitarefa seja bem-sucedida. <br><br>  O modelo multitarefa √†s vezes era usado em sistemas operacionais, mas agora dificilmente pode ser encontrado como uma solu√ß√£o no n√≠vel do sistema.  Isso ocorre porque existe o risco de que um servi√ßo mal projetado possa prejudicar facilmente a estabilidade de todo o sistema.  Planejar encadeamentos e processos usando comutadores de contexto controlados diretamente pelo sistema operacional √© atualmente a abordagem dominante para simultaneidade no n√≠vel do sistema.  Mas a multitarefa colaborativa ainda √© uma excelente ferramenta de simultaneidade no n√≠vel do aplicativo. <br><br>  Falando em multitarefa conjunta no n√≠vel do aplicativo, n√£o estamos lidando com threads ou processos que precisam liberar o controle, pois toda a execu√ß√£o est√° contida em um processo e thread.  Em vez disso, temos v√°rias tarefas (corotinas, tasklets e threads verdes) que transferem o controle para uma √∫nica fun√ß√£o que controla a coordena√ß√£o das tarefas.  Essa fun√ß√£o geralmente √© um tipo de loop de eventos. <br><br>  Para evitar confus√£o (devido √† terminologia do Python), agora chamaremos essas tarefas paralelas de rotinas.  A quest√£o mais importante na multitarefa colaborativa √© quando transferir o controle.  Na maioria dos aplicativos ass√≠ncronos, o controle √© passado para o planejador ou loop de eventos durante opera√ß√µes de E / S.  Independentemente de o programa ler dados do sistema de arquivos ou se comunicar por meio de um soquete, essa opera√ß√£o de E / S sempre est√° associada a algum tempo de espera quando o processo se torna inativo.  A lat√™ncia depende de um recurso externo; portanto, √© uma boa oportunidade de liberar o controle para que outras corotinas possam fazer seu trabalho, at√© que tamb√©m precisem esperar que essa abordagem seja um pouco semelhante no comportamento de como o multithreading √© implementado no Python.  Sabemos que o GIL serializa threads Python, mas tamb√©m √© liberado a cada opera√ß√£o de E / S.  A principal diferen√ßa √© que os threads no Python s√£o implementados como threads no n√≠vel do sistema, para que o sistema operacional possa descarregar o thread em execu√ß√£o no momento e transferir o controle para outro. <br><br>  Na programa√ß√£o ass√≠ncrona, as tarefas nunca s√£o interrompidas pelo loop do evento principal.  √â por isso que esse estilo de multitarefa tamb√©m √© chamado de multitarefa sem prioridade. <br><br>  Obviamente, todo aplicativo Python √© executado em um sistema operacional em que existem outros processos competindo por recursos.  Isso significa que o sistema operacional sempre tem o direito de descarregar todo o processo e transferir o controle para outro.  Mas quando nosso aplicativo ass√≠ncrono √© iniciado, ele continua de onde foi pausado quando o agendador do sistema interveio.  √â por isso que as corotinas nesse contexto s√£o consideradas sem aglomera√ß√£o. <br><br><h4>  Python ass√≠ncrono e aguardar palavras-chave </h4><br>  As palavras <i>-</i> chave <i>async</i> e <i>wait</i> s√£o os principais componentes da programa√ß√£o ass√≠ncrona do Python. <br><br>  A <i>palavra-chave ass√≠ncrona</i> usada antes da declara√ß√£o <i>def</i> define uma nova corotina.  Uma fun√ß√£o de rotina pode ser suspensa e retomada em circunst√¢ncias estritamente definidas.  Sua sintaxe e comportamento s√£o muito semelhantes aos geradores (consulte o Cap√≠tulo 2, ‚ÄúRecomenda√ß√µes de sintaxe‚Äù, abaixo do n√≠vel da classe).  De fato, os geradores devem ser usados ‚Äã‚Äãem vers√µes mais antigas do Python para implementar corotinas.  Aqui est√° um exemplo de declara√ß√£o de uma fun√ß√£o que usa a <i>palavra-chave async</i> : <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async_hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"hello, world!"</span></span>)</code> </pre> <br>  As fun√ß√µes definidas usando a <i>palavra-chave ass√≠ncrona</i> s√£o especiais.  Quando chamados, eles n√£o executam o c√≥digo dentro, mas retornam um objeto de rotina: <br><br><pre> <b><code class="plaintext hljs">&gt;&gt;&gt;&gt; async def async_hello(): ... print("hello, world!") ... &gt;&gt;&gt; async_hello() &lt;coroutine object async_hello at 0x1014129e8&gt;</code></b> </pre><br>  O objeto coroutine n√£o faz nada at√© sua execu√ß√£o ser agendada no loop de eventos.  O m√≥dulo asyncio est√° dispon√≠vel para fornecer uma implementa√ß√£o b√°sica do loop de eventos, bem como muitos outros utilit√°rios ass√≠ncronos: <br><br><pre> <b><code class="plaintext hljs">&gt;&gt;&gt; import asyncio &gt;&gt;&gt; async def async_hello(): ... print("hello, world!") ... &gt;&gt;&gt; loop = asyncio.get_event_loop() &gt;&gt;&gt; loop.run_until_complete(async_hello()) hello, world! &gt;&gt;&gt; loop.close()</code></b> </pre><br>  Naturalmente, criando apenas uma simples rotina, em nosso programa n√£o implementamos paralelismo.  Para ver algo verdadeiramente paralelo, precisamos criar mais tarefas que ser√£o executadas por um loop de eventos. <br><br>  Novas tarefas podem ser adicionadas ao loop chamando o m√©todo <i>loop.create_task ()</i> ou fornecendo outro objeto para aguardar a fun√ß√£o <i>asyncio.wait ()</i> ser usada.  Usaremos a √∫ltima abordagem e tentaremos imprimir de forma ass√≠ncrona uma sequ√™ncia de n√∫meros gerados usando a fun√ß√£o <i>range ()</i> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_number</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> print(number) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: loop = asyncio.get_event_loop() loop.run_until_complete( asyncio.wait([ print_number(number) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>) ]) ) loop.close()</code> </pre><br>  A fun√ß√£o <i>asyncio.wait ()</i> aceita uma lista de objetos da corotina e retorna imediatamente.  O resultado √© um gerador que produz objetos que representam resultados futuros (futuros).  Como o nome sugere, √© usado para aguardar a conclus√£o de todas as corotinas fornecidas.  O motivo pelo qual ele retorna um gerador em vez de um objeto de rotina √© porque √© compat√≠vel com vers√µes anteriores do Python, que ser√£o explicadas mais adiante.  O resultado da execu√ß√£o desse script pode ser o seguinte: <br><br><pre> <b><code class="plaintext hljs">$ python asyncprint.py 0 7 8 3 9 4 1 5 2 6</code></b> </pre><br>  Como podemos ver, os n√∫meros n√£o s√£o impressos na ordem em que criamos nossas corotinas.  Mas √© exatamente isso que quer√≠amos alcan√ßar. <br><br>  A segunda palavra-chave importante adicionada no Python 3.5 est√° <i>aguardando</i> .  √â usado para aguardar os resultados de uma corrotina ou evento futuro (explicado posteriormente) e liberar o controle sobre a execu√ß√£o no loop de eventos.  Para entender melhor como isso funciona, precisamos considerar um exemplo de c√≥digo mais complexo. <br><br>  Suponha que desejemos criar duas corotinas que executam algumas tarefas simples em um loop: <br><br><ul><li>  Aguarde um n√∫mero aleat√≥rio de segundos </li><li>  Imprima algum texto fornecido como argumento e a quantidade de tempo gasto em espera.  Vamos come√ßar com uma implementa√ß√£o simples que possui alguns problemas de simultaneidade que tentaremos melhorar posteriormente com o uso adicional de wait: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waiter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">4</span></span>): time_to_sleep = random.randint(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) / <span class="hljs-number"><span class="hljs-number">4</span></span> time.sleep(time_to_sleep) print( <span class="hljs-string"><span class="hljs-string">"{} waited {} seconds"</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>.format(name, time_to_sleep) ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait([waiter(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>), waiter(<span class="hljs-string"><span class="hljs-string">"bar"</span></span>)]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: loop = asyncio.get_event_loop() loop.run_until_complete(main()) loop.close()</code> </pre></li></ul><br>  Quando executado no terminal (usando o comando time para medir o tempo), voc√™ pode ver: <br><br><pre> <b><code class="plaintext hljs">$ time python corowait.py bar waited 0.25 seconds bar waited 0.25 seconds bar waited 0.5 seconds bar waited 0.5 seconds foo waited 0.75 seconds foo waited 0.75 seconds foo waited 0.25 seconds foo waited 0.25 seconds real 0m3.734s user 0m0.153s sys 0m0.028s</code></b> </pre><br><br>  Como podemos ver, ambas as corotinas conclu√≠ram sua execu√ß√£o, mas n√£o de forma ass√≠ncrona.  O motivo √© que ambos usam a fun√ß√£o <i>time.sleep ()</i> , que bloqueia, mas n√£o libera o controle no loop de eventos.  Isso funcionar√° melhor em uma instala√ß√£o multithread, mas n√£o queremos usar fluxos no momento.  Ent√£o, como podemos corrigir isso? <br><br>  A resposta √© usar <i>asyncio.sleep ()</i> , que √© uma vers√£o ass√≠ncrona de time.sleep (), e esperar o resultado usando a palavra-chave wait.  J√° usamos essa declara√ß√£o na primeira vers√£o do <i>main ()</i> , mas isso foi apenas para melhorar a clareza do c√≥digo.  Isso claramente n√£o tornou nossa implementa√ß√£o mais paralela.  Vejamos uma vers√£o aprimorada da rotina <i>waiter ()</i> que usa waitit asyncio.sleep (): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waiter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">4</span></span>): time_to_sleep = random.randint(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) / <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(time_to_sleep) print( <span class="hljs-string"><span class="hljs-string">"{} waited {} seconds"</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>.format(name, time_to_sleep) )</code> </pre><br><br>  Executando o script atualizado, veremos como a sa√≠da de duas fun√ß√µes se alterna entre si: <br><br><pre> <b><code class="plaintext hljs">$ time python corowait_improved.py bar waited 0.25 seconds foo waited 0.25 seconds bar waited 0.25 seconds foo waited 0.5 seconds foo waited 0.25 seconds bar waited 0.75 seconds foo waited 0.25 seconds bar waited 0.5 seconds real 0m1.953s user 0m0.149s sys 0m0.026s</code></b> </pre><br><br>  Um benef√≠cio adicional desse aprimoramento simples √© que o c√≥digo √© executado mais rapidamente.  O tempo total de execu√ß√£o foi menor que a soma de todos os tempos de suspens√£o, porque as corotinas assumiram o controle uma a uma. <br><br><h4>  Ass√≠ncio em vers√µes anteriores do Python </h4><br>  O m√≥dulo asyncio apareceu no Python 3.4.  Portanto, esta √© a √∫nica vers√£o do Python que oferece suporte s√©rio √† programa√ß√£o ass√≠ncrona antes do Python 3.5.  Infelizmente, parece que essas duas vers√µes subseq√ºentes s√£o suficientes para apresentar problemas de compatibilidade. <br><br>  De qualquer forma, o n√∫cleo de programa√ß√£o ass√≠ncrona no Python foi introduzido anteriormente aos elementos de sintaxe que suportam esse modelo.  Antes tarde do que nunca, isso criou uma situa√ß√£o em que existem duas sintaxes para trabalhar com corotinas. <br><br>  A partir do Python 3.5, voc√™ pode usar o <i>ass√≠ncrono</i> e <i>aguardar</i> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br><br>  No entanto, no Python 3.4, voc√™ precisar√° aplicar adicionalmente o decorador asyncio.coroutine e produzir no texto da corotina: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@asyncio.couroutine def main(): yield from asyncio.sleep(0)</span></span></code> </pre><br><br>  Outro fato √∫til √© que o <i>rendimento da instru√ß√£o</i> foi introduzido no Python 3.3 e o PyPI possui um backport ass√≠ncrono.  Isso significa que voc√™ tamb√©m pode usar esta implementa√ß√£o de multitarefa colaborativa com o Python 3.3. <br><br><h4>  Um exemplo pr√°tico de programa√ß√£o ass√≠ncrona </h4><br>  Como mencionado muitas vezes neste cap√≠tulo, a programa√ß√£o ass√≠ncrona √© uma √≥tima ferramenta para lidar com E / S.  √â hora de criar algo mais pr√°tico do que apenas imprimir sequ√™ncias ou espera ass√≠ncrona. <br><br>  Para garantir consist√™ncia, tentaremos resolver o mesmo problema que resolvemos com a ajuda de multithreading e multiprocessing.  Portanto, tentaremos extrair assincronamente alguns dados de recursos externos por meio de uma conex√£o de rede.  Seria √≥timo se pud√©ssemos usar o mesmo pacote <i>python-gmaps</i> que nas se√ß√µes anteriores.  Infelizmente, n√£o podemos. <br><br>  O criador do <i>python-gmaps</i> era um pouco pregui√ßoso e levou apenas o nome.  Para simplificar o desenvolvimento, ele escolheu o pacote de solicita√ß√£o como sua biblioteca de clientes HTTP.  Infelizmente, as solicita√ß√µes n√£o suportam E / S <i>ass√≠ncrona</i> com <i>ass√≠ncrona</i> e <i>aguardam</i> .  Existem outros projetos que visam fornecer algum paralelismo para o projeto de consulta, mas eles dependem do <i>Gevent</i> ( <i>grequests</i> , consulte <i>https://github.com/ kennethreitz / grequests</i> ) ou executam um pool de processos / processos (query-futuros consulte <i><a href="https://github.com/ross/requests-futures" rel="nofollow">github.com/ross/requests-futures</a></i> ).  Nenhum deles resolve o nosso problema. <br><br><blockquote>  <i>Antes de me censurar por censurar um desenvolvedor de c√≥digo aberto inocente, acalme-se.</i>  <i>A pessoa por tr√°s do pacote <i>python-gmaps</i> sou eu.</i>  <i>Uma m√° escolha de depend√™ncias √© um dos problemas deste projeto.</i>  <i>Eu s√≥ gosto de me criticar publicamente de tempos em tempos.</i>  <i>Esta ser√° uma li√ß√£o amarga para mim, j√° que o <i>python-gmaps</i> em sua vers√£o mais recente (0.3.1 no momento da reda√ß√£o deste livro) n√£o pode ser facilmente integrado √† E / S ass√≠ncrona do Python.</i>  <i>De qualquer forma, isso pode mudar no futuro, para que nada se perca.</i> <br></blockquote>  Conhecendo as limita√ß√µes da biblioteca, que eram t√£o f√°ceis de usar nos exemplos anteriores, precisamos criar algo que preencha essa lacuna.  A API do Google Maps √© realmente f√°cil de usar; portanto, criaremos um utilit√°rio ass√≠ncrono apenas para ilustra√ß√£o.  A biblioteca padr√£o do Python 3.5 ainda n√£o possui uma biblioteca que possa executar solicita√ß√µes HTTP ass√≠ncronas t√£o facilmente quanto chamar <i>urllib.urlopen ()</i> .  Definitivamente, n√£o queremos criar suporte completo a protocolos do zero, portanto, usaremos uma pequena ajuda do pacote <i>aiohttp</i> dispon√≠vel no PyPI.  Esta √© uma biblioteca realmente promissora que adiciona implementa√ß√µes de cliente e servidor para HTTP ass√≠ncrono.  Aqui est√° um pequeno m√≥dulo constru√≠do sobre o <i>aiohttp</i> que cria uma fun√ß√£o auxiliar <i>geocode</i> <i>()</i> que executa solicita√ß√µes de geocodifica√ß√£o para o servi√ßo da API do Google Maps: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp session = aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">geocode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(place)</span></span></span><span class="hljs-function">:</span></span> params = { <span class="hljs-string"><span class="hljs-string">'sensor'</span></span>: <span class="hljs-string"><span class="hljs-string">'false'</span></span>, <span class="hljs-string"><span class="hljs-string">'address'</span></span>: place } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get( <span class="hljs-string"><span class="hljs-string">'https://maps.googleapis.com/maps/api/geocode/json'</span></span>, params=params ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response: result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.json() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-string"><span class="hljs-string">'results'</span></span>]</code> </pre><br><br>  Vamos supor que esse c√≥digo seja armazenado em um m√≥dulo chamado <i>asyncgmaps</i> , que usaremos mais tarde.  Agora estamos prontos para reescrever o exemplo usado na discuss√£o sobre multithreading e multiprocessing.  Anteriormente, costum√°vamos separar toda a opera√ß√£o em dois est√°gios separados: <br><br><ol><li>  Atenda a todas as solicita√ß√µes ao servi√ßo externo em paralelo usando a fun√ß√£o <i>fetch_place ()</i> . </li><li>  Exiba todos os resultados em um loop usando a fun√ß√£o <i>present_result ()</i> . </li></ol><br>  Mas como a multitarefa colaborativa √© completamente diferente do que o uso de v√°rios processos ou threads, podemos mudar um pouco nossa abordagem.  A maioria dos problemas levantados em Usando um √∫nico encadeamento por item n√£o √© mais nossa preocupa√ß√£o. <br>  As corotinas n√£o s√£o preventivas, portanto, podemos exibir facilmente os resultados imediatamente ap√≥s o recebimento das respostas HTTP.  Isso simplificar√° nosso c√≥digo e o tornar√° mais compreens√≠vel: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-comment"><span class="hljs-comment"># note: local module introduced earlier from asyncgmaps import geocode, session PLACES = ( 'Reykjavik', 'Vien', 'Zadar', 'Venice', 'Wroc≈Çaw', 'Bolognia', 'Berlin', 'S≈Çubice', 'New York', 'Dehli', ) async def fetch_place(place): return (await geocode(place))[0] async def present_result(result): geocoded = await result print("{:&gt;25s}, {:6.2f}, {:6.2f}".format( geocoded['formatted_address'], geocoded['geometry']['location']['lat'], geocoded['geometry']['location']['lng'], )) async def main(): await asyncio.wait([ present_result(fetch_place(place)) for place in PLACES ]) if __name__ == "__main__": loop = asyncio.get_event_loop() loop.run_until_complete(main()) # aiohttp will raise issue about unclosed # ClientSession so we perform cleanup manually loop.run_until_complete(session.close()) loop.close()</span></span></code> </pre><br><br>  A programa√ß√£o ass√≠ncrona √© excelente para desenvolvedores de back-end interessados ‚Äã‚Äãem criar aplicativos escal√°veis.  Na pr√°tica, essa √© uma das ferramentas mais importantes para criar servidores altamente competitivos. <br><br>  Mas a realidade √© triste.  Muitos pacotes populares que lidam com problemas de E / S n√£o devem ser usados ‚Äã‚Äãcom c√≥digo ass√≠ncrono.  As principais raz√µes para isso s√£o: <br><br><ul><li>  Ainda baixa implementa√ß√£o do Python 3 e alguns de seus recursos avan√ßados </li><li>  Baixo entendimento de v√°rios conceitos de simultaneidade entre iniciantes para aprender Python </li></ul><br>  Isso significa que muitas vezes a migra√ß√£o de aplicativos e pacotes s√≠ncronos multithread existentes √© imposs√≠vel (devido a restri√ß√µes de arquitetura) ou muito cara.  Muitos projetos podem se beneficiar muito da implementa√ß√£o do estilo de multitarefa ass√≠ncrona, mas apenas alguns o far√£o.  Isso significa que, no momento, voc√™ ter√° muitas dificuldades tentando criar aplicativos ass√≠ncronos desde o in√≠cio.  Na maioria dos casos, isso ser√° semelhante ao problema mencionado na se√ß√£o "Exemplo pr√°tico de programa√ß√£o ass√≠ncrona" - interfaces incompat√≠veis e bloqueio n√£o s√≠ncrono das opera√ß√µes de E / S.  Obviamente, √†s vezes voc√™ pode deixar de esperar quando sente essa incompatibilidade e obter os recursos necess√°rios de forma s√≠ncrona.  Mas isso impedir√° a execu√ß√£o de seu c√≥digo uma da outra rotina enquanto voc√™ espera pelos resultados.  Tecnicamente, isso funciona, mas tamb√©m destr√≥i todos os benef√≠cios da programa√ß√£o ass√≠ncrona.  Portanto, no final, combinar E / S ass√≠ncrona com E / S s√≠ncrona n√£o √© uma op√ß√£o.  Este √© um jogo de tudo ou nada. <br><br>  Outro problema s√£o as longas opera√ß√µes vinculadas ao processador.  Quando voc√™ executa uma opera√ß√£o de E / S, n√£o h√° problema em liberar o controle de uma corotina.  Ao escrever / ler a partir de um sistema de arquivos ou soquete, voc√™ acabar√° aguardando; portanto, uma chamada em espera √© o melhor que voc√™ pode fazer.  Mas e se voc√™ precisar calcular alguma coisa e souber que levar√° algum tempo?  Obviamente, voc√™ pode dividir o problema em partes e cancelar o controle toda vez que avan√ßar um pouco no trabalho.  Mas logo voc√™ descobrir√° que este n√£o √© um modelo muito bom.  Uma coisa dessas pode tornar o c√≥digo confuso e tamb√©m n√£o garante bons resultados. <br><br>  A liga√ß√£o temporal deve ser de responsabilidade do int√©rprete ou do sistema operacional. <br><br><h4>  Combinando c√≥digo ass√≠ncrono com futuros ass√≠ncronos </h4><br>  Ent√£o, o que fazer se voc√™ tiver um c√≥digo que execute E / S s√≠ncrona longa que n√£o pode ou n√£o deseja reescrever.  Ou o que fazer quando voc√™ precisar executar algumas opera√ß√µes pesadas do processador em um aplicativo projetado principalmente para E / S ass√≠ncrona?  Bem ... voc√™ precisa encontrar uma solu√ß√£o alternativa.  E com isso quero dizer multithreading ou multiprocessing. <br><br>  Isso pode n√£o parecer muito bom, mas √†s vezes a melhor solu√ß√£o pode ser a que tentamos evitar.  O processamento paralelo de tarefas que consomem muitos recursos em Python sempre √© executado melhor devido ao multiprocessamento.  E o multithreading pode lidar com opera√ß√µes de E / S igualmente bem (rapidamente e sem muitos recursos), como ass√≠ncrono e aguardando se configurado e manuseado com cuidado. <br><br>  Portanto, √†s vezes, quando voc√™ n√£o sabe o que fazer quando algo simplesmente n√£o se encaixa no seu aplicativo ass√≠ncrono, use um peda√ßo de c√≥digo que o coloque em um processo ou thread separado.  Voc√™ pode fingir que √© uma rotina, liberar controle para o loop de eventos e, finalmente, processar os resultados quando estiverem prontos. <br><br>  Felizmente para n√≥s, a biblioteca padr√£o do Python fornece o m√≥dulo <i>concurrent.futures</i> , que tamb√©m √© integrado ao m√≥dulo <i>asyncio</i> .  Juntos, esses dois m√≥dulos permitem planejar fun√ß√µes de bloqueio executadas em encadeamentos ou processos adicionais, como se fossem corotinas ass√≠ncronas sem bloqueio. <br><br><h4>  Executores e futuros </h4><br>  Antes de vermos como incorporar threads ou processos em um loop de evento ass√≠ncrono, examinamos mais de perto o m√≥dulo <i>concurrent.futures</i> , que mais tarde se tornar√° o principal componente da nossa solu√ß√£o alternativa. <br><br>  As classes mais importantes no m√≥dulo <i>concurrent.futures</i> s√£o <i>Executor</i> e <i>Future</i> . <br><br>  <i>Executor</i> √© um conjunto de recursos que podem processar itens de trabalho em paralelo.  Pode parecer muito semelhante em prop√≥sito √†s classes do m√≥dulo multiprocessador - <i>Pool</i> e <i>dummy.Pool</i> - mas tem uma interface e sem√¢ntica completamente diferentes.  Esta √© uma classe base que n√£o se destina a ser implementada e tem duas implementa√ß√µes espec√≠ficas: <br><br><ul><li>  <i>ThreadPoolExecutor</i> : que representa um conjunto de encadeamentos </li><li>  <i>ProcessPoolExecutor</i> : que representa um pool de processos </li></ul><br>  Cada <i>executor</i> apresenta tr√™s m√©todos: <br><br><ul><li>  <i>submit (fn, * args, ** kwargs)</i> : agenda a fun√ß√£o fn para executar no pool de recursos e retorna um objeto Future que representa a execu√ß√£o do objeto chamado </li><li>  <i>map (func, * iterables, timeout = None, chunksize = 1)</i> : a fun√ß√£o <i>func</i> √© executada na itera√ß√£o de maneira semelhante ao multiprocessamento.  <i>M√©todo Pool.map ()</i> </li><li>  <i>shutdown (wait = True)</i> : desliga o <i>executor</i> e libera todos os seus recursos. </li></ul><br>  O m√©todo mais interessante √© <i>submit ()</i> por causa do objeto Future que ele retorna.  Representa a execu√ß√£o ass√≠ncrona dos chamados e indiretamente representa apenas o resultado.  Para obter o valor de retorno real do objeto chamado despachado, voc√™ deve chamar o m√©todo <i>Future.result ()</i> .  E se o objeto chamado j√° estiver conclu√≠do, o m√©todo <i>result ()</i> n√£o o bloquear√° e simplesmente retornar√° a sa√≠da da fun√ß√£o.  Caso contr√°rio, ele o bloquear√° at√© que o resultado esteja pronto.  Pense nisso como uma promessa de resultado (na verdade, √© o mesmo conceito que uma promessa em JavaScript).  Voc√™ n√£o precisa descompact√°-lo imediatamente ap√≥s receb√™-lo (usando o m√©todo <i>result ()</i> ), mas se voc√™ tentar fazer isso, √© garantido que retornar√° algo: <br><br><pre> <b><code class="plaintext hljs">&gt;&gt;&gt; def loudy_return(): ... print("processing") ... return 42 ... &gt;&gt;&gt; from concurrent.futures import ThreadPoolExecutor &gt;&gt;&gt; with ThreadPoolExecutor(1) as executor: ... future = executor.submit(loudy_return) ... processing &gt;&gt;&gt; future &lt;Future at 0x33cbf98 state=finished returned int&gt; &gt;&gt;&gt; future.result() 42</code></b> </pre><br><br>  Se voc√™ deseja usar o m√©todo <i>Executor.map ()</i> , ele n√£o difere em uso do m√©todo <i>Pool.map ()</i> da classe <i>Pool</i> do m√≥dulo multiprocessador: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> ThreadPoolExecutor(POOL_SIZE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pool: results = pool.map(fetch_place, PLACES) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> results: present_result(result)</code> </pre><br><br><h4>  Usando o <i>executor</i> em um <i>loop de</i> eventos </h4><br>  As inst√¢ncias da classe Future retornadas pelo m√©todo <i>Executor.submit ()</i> s√£o conceitualmente muito pr√≥ximas das corotinas usadas na programa√ß√£o ass√≠ncrona.  √â por isso que podemos usar artistas para criar um h√≠brido entre multitarefa colaborativa e multiprocessamento ou multithreading. <br><br>  O n√∫cleo desta solu√ß√£o alternativa √© o <i>m√©todo BaseEventLoop.run_in_executor (executor, func, * args)</i> da classe do loop de <i>eventos</i> .  Isso permite planejar a execu√ß√£o da fun√ß√£o func em um conjunto de processos ou encadeamentos representado pelo argumento do executor.  O mais importante sobre esse m√©todo √© que ele retorna o novo objeto esperado (o objeto que pode ser esperado usando o operador de espera).  Assim, gra√ßas a isso, voc√™ pode executar uma fun√ß√£o de bloqueio que n√£o √© uma corotina exatamente como uma corotina, e ela n√£o ser√° bloqueada, n√£o importa quanto tempo leve para terminar.  Ele interromper√° apenas a fun√ß√£o que espera resultados dessa chamada, mas todo o ciclo de eventos continuar√°. <br><br>  E um fato √∫til √© que voc√™ nem precisa criar sua pr√≥pria inst√¢ncia de executor.  Se voc√™ passar <i>None</i> como argumento para o <i>executor</i> , a classe <i>ThreadPoolExecutor</i> ser√° usada com o n√∫mero padr√£o de threads (para Python 3.5, este √© o n√∫mero de processadores multiplicados por 5). <br><br>  Portanto, suponha que n√£o desej√°ssemos reescrever a parte problem√°tica do pacote python-gmaps que estava causando nossa dor de cabe√ßa.  Podemos adiar facilmente uma chamada de bloqueio para um thread separado, chamando <i>loop.run_in_executor ()</i> , enquanto deixamos a fun√ß√£o fetch_place () como a rotina prevista: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_place</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(place)</span></span></span><span class="hljs-function">:</span></span> coro = loop.run_in_executor(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, api.geocode, place) result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> coro <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa solu√ß√£o √© pior do que ter uma biblioteca totalmente ass√≠ncrona para fazer o trabalho, mas voc√™ sabe que pelo menos algo √© melhor que nada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de explicar o que realmente √© simultaneidade, agimos e analisamos um dos problemas paralelos t√≠picos usando multithreading. Depois de identificar as principais falhas do nosso c√≥digo e corrigi-las, passamos ao multiprocessamento para ver como funcionaria no nosso caso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois disso, descobrimos que, com um m√≥dulo multiprocessador, o uso de v√°rios processos √© muito mais f√°cil do que threads b√°sicos com multithreading. Mas somente depois disso percebemos que podemos usar a mesma API com threads, gra√ßas ao </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">multiprocessing.dummy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Portanto, a escolha entre multiprocessamento e multithreading agora depende apenas de qual solu√ß√£o corresponde melhor ao problema, e n√£o de qual solu√ß√£o possui a melhor interface. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falando em adaptar o problema, finalmente experimentamos a programa√ß√£o ass√≠ncrona, que deve ser a melhor solu√ß√£o para aplicativos relacionados a E / S, apenas para entender que n√£o podemos esquecer completamente os encadeamentos e processos. Ent√£o fizemos um c√≠rculo, de volta para onde come√ßamos!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E isso nos leva √† conclus√£o final deste cap√≠tulo. </font><font style="vertical-align: inherit;">N√£o h√° solu√ß√£o que atenda a todos. </font><font style="vertical-align: inherit;">Existem v√°rias abordagens que voc√™ pode preferir ou gostar mais. </font><font style="vertical-align: inherit;">Existem algumas abordagens que s√£o mais adequadas para esse conjunto de problemas, mas voc√™ precisa conhecer todas elas para ter sucesso. </font><font style="vertical-align: inherit;">Em cen√°rios realistas, voc√™ pode usar todo o arsenal de ferramentas e estilos de paralelismo em um aplicativo, e isso n√£o √© incomum. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A conclus√£o anterior √© uma excelente introdu√ß√£o ao t√≥pico do pr√≥ximo cap√≠tulo, cap√≠tulo 14 ‚ÄúPadr√µes de design √∫teis‚Äù. </font><font style="vertical-align: inherit;">Como n√£o h√° um modelo √∫nico que resolva todos os seus problemas. </font><font style="vertical-align: inherit;">Voc√™ deve saber o m√°ximo poss√≠vel, porque, em √∫ltima an√°lise, voc√™ os usar√° todos os dias.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt484446/">https://habr.com/ru/post/pt484446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt484436/index.html">C√≥digo-fonte ingrato: o desenvolvedor do servidor da Web mais r√°pido excluiu seu reposit√≥rio - Atualiza√ß√£o importante</a></li>
<li><a href="../pt484438/index.html">Equa√ß√µes famosas de fluidos vazaram</a></li>
<li><a href="../pt484440/index.html">Backup completo com ferramentas padr√£o do Windows</a></li>
<li><a href="../pt484442/index.html">Exemplo de SNMPv3</a></li>
<li><a href="../pt484444/index.html">Como as condi√ß√µes operacionais afetam a bateria ou a hist√≥ria de uma ressurrei√ß√£o milagrosa</a></li>
<li><a href="../pt484448/index.html">Confer√™ncia DEFCON 27. Hackeie a pol√≠cia. Parte 1</a></li>
<li><a href="../pt484454/index.html">Detetive Habra: sua foto est√° perdida</a></li>
<li><a href="../pt484456/index.html">ReactJS, renderiza√ß√£o no lado do servidor e algumas sutilezas do processamento de meta tags da p√°gina</a></li>
<li><a href="../pt484458/index.html">Este freelancer est√° quebrado - me d√™ o pr√≥ximo</a></li>
<li><a href="../pt484462/index.html">Scraping Github: Procurando por "segredos" para desenvolver</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>