<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüé® üåÑ üôáüèΩ Optimizaci√≥n de bases de datos relacionales sin tiempo de inactividad mediante el ejemplo de la base de datos m√°s cargada en Badoo üóÉÔ∏è üéõÔ∏è üíÖüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En condiciones de alta carga, la complejidad de optimizar las bases de datos relacionales aumenta en un orden de magnitud, ya que comprar hardware a√∫n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimizaci√≥n de bases de datos relacionales sin tiempo de inactividad mediante el ejemplo de la base de datos m√°s cargada en Badoo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/433730/"><img src="https://habrastorage.org/webt/kh/bf/3m/khbf3mojp_5d2lgszln2zsljisy.png"><br><br>  En condiciones de alta carga, la complejidad de optimizar las bases de datos relacionales aumenta en un orden de magnitud, ya que comprar hardware a√∫n m√°s potente es costoso y no hay forma de apagar la aplicaci√≥n por la noche para un largo proceso de alteraci√≥n de la base de datos y migraci√≥n de datos. <br><br>  Recientemente hablamos sobre c√≥mo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">optimizamos el c√≥digo PHP para nuestra aplicaci√≥n</a> .  Ahora ha llegado el turno del art√≠culo sobre c√≥mo cambiamos completamente la estructura interna de la base de datos m√°s cargada e importante de Badoo, sin perder una sola solicitud. <br><a name="habracut"></a><br><h2>  Paciente </h2><br>  Users DataBase, o UDB, es un servicio que inicia casi cualquier solicitud a Badoo.  Resuelve varios problemas: en primer lugar, es el repositorio central de los principales datos de usuario para los que se lleva a cabo la autorizaci√≥n (por ejemplo, correo electr√≥nico, user_id o facebook_id).  Adem√°s de almacenar estos datos, el servicio proporciona un control √∫nico (de modo que dos usuarios con el mismo correo electr√≥nico, facebook_id, etc., no pueden registrarse en el sistema).  Y el mismo servicio brinda informaci√≥n sobre cu√°l de los miles de fragmentos contiene todos los dem√°s datos de usuario. <br><br>  A finales de 2018, UDB almacena datos de m√°s de 800 millones de usuarios, que ocupan aproximadamente 1 TB de espacio en disco.  Todo esto es servido por pares de servidores MySQL maestro-esclavo en cada uno de nuestros centros de datos.  En total, procesan m√°s de 140,000 solicitudes por segundo. <br><br>  La ca√≠da de UDB significa la inaccesibilidad de todo Badoo, ya que el c√≥digo no podr√° encontrar el fragmento en el que se encuentran los datos del usuario.  Por lo tanto, se le imponen enormes exigencias de fiabilidad y disponibilidad. <br><br>  Debido a esta especificidad, es muy costoso realizar cambios en la estructura de almacenamiento, por lo que tomamos muy en serio el dise√±o de UDB en 2013.  Sin embargo, con el tiempo, los requisitos y los perfiles de carga cambian.  En un esfuerzo por adaptar el sistema a los nuevos requisitos y niveles de carga, se realizaron muchos cambios peque√±os y simples, pero, desafortunadamente, tales cambios est√°n lejos de ser los m√°s efectivos.  Y lleg√≥ el d√≠a en que, en lugar del siguiente hack o la compra de hardware costoso, era m√°s sabio hacer una optimizaci√≥n m√°s global.  Adem√°s consideraremos las etapas principales de este camino. <br><br><h2>  Optimizaciones no invasivas </h2><br>  Cualquier cambio en la estructura de una base de datos grande y cargada es bastante costoso debido a la complejidad del proceso de migraci√≥n de datos.  Por lo tanto, antes que nada, debe agotar todas las opciones de optimizaci√≥n que no afectan la estructura de datos, pero que se limitan a las consultas de c√≥digo y SQL.  Quiz√°s esto sea suficiente para posponer el problema de la carga de trabajo excesiva durante un par de a√±os, lo que le permitir√° hacer algo m√°s importante para el negocio en este momento. <br><br>  Cuanto mejor comprenda su sistema, m√°s f√°cil ser√° encontrar enfoques para tales optimizaciones.  Aseg√∫rese de recopilar todas las m√©tricas que pueden ayudarlo.  No se trata solo de m√©tricas del sistema como el uso de CPU y RAM o las m√©tricas de una base de datos espec√≠fica, sino tambi√©n de m√©tricas de nivel de aplicaci√≥n de una aplicaci√≥n que est√° vinculada a una base de datos optimizada.  ¬øCu√°ntas solicitudes por segundo tienen los diferentes tipos de operaciones?  ¬øCu√°l es su tiempo de respuesta?  ¬øCu√°l es el tama√±o de la entrada y salida?  Es sobre estas m√©tricas que puede juzgar el √©xito de la optimizaci√≥n.  Es poco probable que necesite una optimizaci√≥n que reduzca ligeramente el uso de la CPU en el servidor de la base de datos, pero al mismo tiempo aumente el tiempo de respuesta de su aplicaci√≥n en diez veces. <br><br><img src="https://habrastorage.org/webt/o_/wv/t0/o_wvt02zorm3oqwxxjvgeuwvz9m.png"><br><br>  Despu√©s de haber comenzado a recopilar m√©tricas de nivel de aplicaci√≥n adicionales para UDB, pudimos comprender mejor cu√°les de las operaciones realizadas crean el 80% de la carga y son los primeros candidatos para el estudio, y cu√°les se usan poco o nada m√°s. <br><br>  Un an√°lisis detallado de la operaci√≥n m√°s frecuente (extracci√≥n de usuarios que cumplen ciertos criterios) mostr√≥ que, a pesar del hecho de que todos los datos de usuario disponibles se solicitan de la base de datos, en realidad la aplicaci√≥n en el 95% de los casos usa solo user_id.  Simplemente separando este caso en un m√©todo API separado, que extrae solo una columna de la tabla, pudimos beneficiarnos del uso del √≠ndice de cobertura y usar esto para eliminar aproximadamente el 5% de la carga de la CPU del servidor de la base de datos. <br><br>  El an√°lisis de otra operaci√≥n frecuente mostr√≥ que, a pesar del hecho de que se realiza para cada solicitud HTTP, en realidad, los datos que recupera son extremadamente raros.  Tradujimos esta solicitud a un modelo perezoso. <br><br>  El objetivo principal de las m√©tricas en el caso de un proyecto de optimizaci√≥n es comprender mejor su base de datos y encontrar las piezas m√°s gordas.  No tiene sentido gastar mucho tiempo y esfuerzo optimizando consultas que representan menos del 1% de su perfil de carga.  Si no tiene m√©tricas que le permitan comprender el perfil de su carga, rec√≥jalas.  Con tales optimizaciones en el lado del c√≥digo, logramos eliminar aproximadamente el 15% del uso de la CPU del 80% de la base de datos consumida. <br><br><h2>  Ideas de prueba </h2><br>  Si va a optimizar una base de datos cargada cambiando su estructura, debe comenzar por verificar sus ideas en un banco de pruebas, ya que incluso las optimizaciones que parecen muy prometedoras en teor√≠a pueden no tener un efecto positivo en la pr√°ctica (y a veces incluso pueden tener un efecto negativo).  Y es poco probable que desee saber sobre esto solo despu√©s de una larga migraci√≥n de datos en producci√≥n. <br><br>  Cuanto m√°s cerca est√© la configuraci√≥n de su stand de la configuraci√≥n de producci√≥n, m√°s confiable ser√° el resultado.  Un punto importante es asegurar la carga correcta del soporte.  Ejecutar consultas aleatorias o las mismas puede conducir a resultados falsos.  La mejor opci√≥n es utilizar solicitudes reales de producci√≥n.  Para UDB, registramos desde la producci√≥n cada d√©cima solicitud de lectura de API (incluidos los par√°metros) en forma de solo un registro JSON en un archivo.  Por un d√≠a, recopilamos un registro de 65 GB de tama√±o de 700 millones de solicitudes. <br><br>  No probamos el registro, en comparaci√≥n con el n√∫mero de solicitudes de lectura, es muy peque√±o y no afecta nuestra carga.  Sin embargo, este puede no ser el caso en su caso.  Si desea cargar el banco de pruebas con solicitudes de escritura, deber√° recopilar cada solicitud, ya que omitir las solicitudes de escritura puede generar errores de coherencia en el banco de pruebas. <br><br>  El siguiente paso es perder correctamente el registro en el soporte.  Utilizamos 400 trabajadores PHP, lanzados desde nuestra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nube de script</a> , que leen el registro recopilado de la cola r√°pida y ejecutan solicitudes secuencialmente.  En este caso, la cola se llena con otro script con una velocidad estrictamente definida.  Para probar ideas, utilizamos la velocidad de x10, que, multiplicada por el hecho de que recolectamos de la producci√≥n solo cada d√©cima solicitud, proporcion√≥ la misma cantidad de RPS que en la producci√≥n. <br><br><img src="https://habrastorage.org/webt/p2/9p/ya/p29pyak41t3rygstxym5kguf3gm.png"><br><br>  Con estos coeficientes, resulta que el d√≠a de producci√≥n con todas las cargas ca√≠das en el banco de pruebas vuela en solo dos horas y media. <br><br>  Entonces, por ejemplo, la primera prueba que realizamos a una velocidad de x5 (50% de la carga de producci√≥n) en el registro de consultas durante medio d√≠a se ve√≠a as√≠: <br><br><img src="https://habrastorage.org/webt/4l/3z/sg/4l3zsggyvo-yklup3xmnl9x-0de.png"><br><br>  Se pueden usar las mismas herramientas para realizar una prueba de falla: aumentando la velocidad (y por lo tanto RPS) hasta que la base en el soporte comience a degradarse.  Esto le dar√° una idea clara de cu√°nto m√°s puede soportar su base de datos. <br><br>  Despu√©s de probar el nuevo esquema de datos, tambi√©n es importante realizar una prueba de control en la estructura de la base de datos original.  Si sus resultados y el rendimiento actual en la producci√≥n son muy diferentes, primero debe comprender los motivos.  Quiz√°s el servidor de prueba est√° configurado incorrectamente y no puede confiar en los datos de prueba de carga. <br><br>  Tambi√©n vale la pena asegurarse de que el nuevo c√≥digo funcione correctamente.  Tiene poco sentido probar el rendimiento de las consultas que no hacen el trabajo.  Le ayudar√°n las pruebas de integraci√≥n que verifican si las API antiguas y nuevas devuelven los mismos valores en las mismas llamadas API. <br><br>  Despu√©s de recibir resultados sobre todas las ideas, solo queda elegir opciones con el mejor equilibrio entre precio y calidad e introducir un nuevo esquema de producci√≥n. <br><br><h2>  Cambio de esquema </h2><br>  En primer lugar, observo que cambiar el esquema de datos sin detener el funcionamiento del servicio siempre es bastante dif√≠cil, costoso y arriesgado.  Por lo tanto, si tiene la oportunidad de detener su aplicaci√≥n mientras cambia la estructura, simplemente h√°galo.  En el caso de UDB, desafortunadamente, no pod√≠amos permitirnos esto. <br><br>  El segundo factor que afecta la complejidad de cambiar un circuito es la escala planificada del cambio.  Si todos los cambios propuestos a las tablas no van m√°s all√° de un simple cambio (por ejemplo, agregando un par de nuevos √≠ndices o columnas), puede ponerlos en marcha con procesos t√≠picos como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pt-online-schema-change</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gh-ost</a> para MySQL o un esclavo alternativo seguido de cambiar sus lugares . <br><br>  En nuestro caso, se mostr√≥ un excelente resultado mediante el fragmentaci√≥n vertical de una tabla gigante de una docena m√°s peque√±a con otras columnas e √≠ndices y datos en un formato diferente.  Tal conversi√≥n con herramientas t√≠picas ya no es posible.  Entonces que hacer? <br><br>  Aplicamos el siguiente algoritmo: <br><br><ol><li>  Alcanzamos un estado en el que tanto el esquema antiguo como el nuevo con datos actuales existen simult√°neamente.  La grabaci√≥n va en ambos, y al mismo tiempo hay una garant√≠a de consistencia de datos en ambas versiones.  Consideraremos este art√≠culo en detalle a continuaci√≥n. <br></li><li>  Cambie gradualmente toda la lectura a un nuevo circuito, controlando la carga. <br></li><li>  Apague la grabaci√≥n en el esquema anterior y elim√≠nelo. <br></li></ol><br>  Las principales ventajas de este enfoque: <br><br><ul><li>  seguridad: existe la posibilidad de retroceso instant√°neo hasta la √∫ltima etapa (simplemente cambie la lectura al esquema anterior, si algo sali√≥ mal); <br></li><li>  control de carga completa durante la migraci√≥n de datos; <br></li><li>  no se requiere alterar mucho la gran mesa del antiguo circuito. <br></li></ul><br>  Sin embargo, tambi√©n hay desventajas: <br><br><ul><li>  la necesidad de mantener ambas versiones de los esquemas en el disco durante el proceso de migraci√≥n (esto puede ser un problema si tiene poco espacio y la tabla que se est√° migrando es muy grande); <br></li><li>  una gran cantidad de c√≥digo temporal para admitir el proceso de migraci√≥n, que se cortar√° al finalizar; <br></li><li>  es posible lavar el cach√© leyendo dos esquemas en paralelo;  exist√≠a el temor de que las versiones antiguas y nuevas competir√≠an por la RAM, lo que podr√≠a conducir a la degradaci√≥n del servicio (en realidad, esto realmente cre√≥ una carga adicional, sin embargo, dado que la migraci√≥n se realiz√≥ fuera de las horas pico, esto no nos cre√≥ problemas). <br></li></ul><br>  La principal dificultad en este algoritmo es el primer punto.  Lo consideraremos en detalle. <br><br><h2>  Cambiar sincronizaci√≥n </h2><br>  La migraci√≥n de datos est√°ticos no es particularmente dif√≠cil.  Sin embargo, ¬øqu√© sucede si no puede detener la grabaci√≥n completa mientras se migra la base de datos? <br><br>  Hay varias opciones para lograr la sincronizaci√≥n del nuevo esquema: migraci√≥n con rodar el registro y la grabaci√≥n idempotente de migraci√≥n. <br><br><h3>  Migrar una instant√°nea de datos seguido de reproducir el registro de los siguientes cambios </h3><br>  Cada transacci√≥n de actualizaci√≥n de datos se registra en una tabla especial a trav√©s de disparadores, ya sea a nivel de aplicaci√≥n, o el binlog de replicaci√≥n se usa como un registro.  Despu√©s de tener dicho registro, puede abrir una transacci√≥n y migrar una instant√°nea de datos, recordando la posici√≥n en el registro.  Entonces queda por comenzar a aplicar el registro recopilado en el nuevo esquema.  Del mismo modo, por ejemplo, funciona la popular <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramienta de copia de seguridad MyStra Percona XtraBackup</a> . <br><br>  Una vez que el nuevo esquema ha alcanzado el registro en el registro actual, comienza la etapa m√°s crucial: a√∫n debe pausar la grabaci√≥n en el esquema anterior por un corto per√≠odo de tiempo y, asegur√°ndose de que todo el registro disponible se aplique al nuevo esquema, lo que significa que los datos entre los esquemas son consistentes, A nivel de aplicaci√≥n, habilite la grabaci√≥n a la vez en ambas fuentes. <br><br>  Las principales desventajas de este enfoque son que necesitar√° almacenar de alguna manera el registro de operaciones, que en s√≠ mismo puede crear una carga en el complejo proceso de conmutaci√≥n, as√≠ como en la probabilidad de romper el registro si, por alguna raz√≥n, los circuitos resultan ser inconsistentes. <br><br><h3>  Registro idempotente </h3><br>  La idea principal de este enfoque es comenzar a escribir en el nuevo esquema en paralelo con la escritura en el anterior antes de que los cambios est√©n completamente sincronizados, y luego completar la migraci√≥n de los datos restantes.  Del mismo modo, generalmente las columnas nuevas se llenan en tablas grandes. <br><br>  La grabaci√≥n s√≠ncrona se puede implementar tanto en los activadores de la base de datos como en el c√≥digo fuente.  Le aconsejo que haga esto precisamente en el c√≥digo, ya que, en cualquier caso, eventualmente tendr√° que escribir c√≥digo que escriba datos en el nuevo esquema, y ‚Äã‚Äãla implementaci√≥n de la migraci√≥n en el lado del c√≥digo le proporcionar√° m√°s control. <br><br>  Un punto importante a considerar es que hasta que se complete la migraci√≥n, el nuevo esquema estar√° en un estado inconsistente.  Debido a esto, es posible un escenario cuando la actualizaci√≥n de una nueva tabla conduce a una violaci√≥n de la constante de la base de datos (claves externas o un √≠ndice √∫nico), mientras que desde el punto de vista del esquema actual, la transacci√≥n es completamente correcta y debe llevarse a cabo. <br><br>  Esta situaci√≥n puede llevar a una reversi√≥n de buenas transacciones debido al proceso de migraci√≥n.  La forma m√°s f√°cil de solucionar este problema es agregar el modificador IGNORE a todas las solicitudes para escribir datos en un nuevo esquema o interceptar la reversi√≥n de dicha transacci√≥n y ejecutar la versi√≥n sin escribir en el nuevo esquema. <br><br>  El algoritmo de sincronizaci√≥n a trav√©s de la grabaci√≥n idempotente en nuestro caso es el siguiente: <br><br><ol><li>  Permitimos la grabaci√≥n en un nuevo esquema en paralelo con la grabaci√≥n en el antiguo en modo de compatibilidad (IGNORE). <br></li><li>  Ejecutamos un script que gradualmente pasa por alto el nuevo esquema y captura datos inconsistentes.  Despu√©s de eso, los datos en ambas tablas deben sincronizarse, pero esto es inexacto debido a posibles conflictos en la cl√°usula 1. <br></li><li>  Iniciamos el verificador de consistencia de datos: abre la transacci√≥n y lee secuencialmente las l√≠neas de los esquemas nuevos y antiguos comparando su correspondencia. <br></li><li>  Si hay conflictos, terminamos y volvemos al p√°rrafo 3. <br></li><li>  Despu√©s de que el verificador mostr√≥ que los datos en ambos esquemas est√°n sincronizados, entonces no deber√≠a haber m√°s discrepancias entre los esquemas, a menos, por supuesto, que hayamos perdido algunos matices.  Por lo tanto, esperamos un tiempo (por ejemplo, una semana) y ejecutamos una verificaci√≥n de control.  Si muestra que todo est√° bien, la tarea se completa con √©xito y puede traducir la lectura. <br></li></ol><br><h2>  Resultados </h2><br>  Como resultado de cambiar el formato de datos, pudimos reducir el tama√±o de la tabla principal de 544 GB a 226 GB, reduciendo as√≠ la carga en el disco y aumentando la cantidad de datos √∫tiles que caben en la RAM. <br><br>  En total, desde el comienzo del proyecto, utilizando todos los enfoques descritos, pudimos reducir el uso de la CPU del servidor de bases de datos del 80% al 35% en el pico de tr√°fico.  Los resultados de la prueba de esfuerzo posterior mostraron que a la tasa de crecimiento actual de la carga, podemos permanecer en el hardware existente durante al menos otros tres a√±os. <br><br>  Dividir una tabla enorme en varias simplific√≥ el proceso de realizar modificaciones futuras en la base de datos, y tambi√©n aceler√≥ significativamente algunos scripts que recopilaron datos para BI. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433730/">https://habr.com/ru/post/es433730/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433720/index.html">10 razones para elegir una soluci√≥n para SAP HANA de HPE</a></li>
<li><a href="../es433722/index.html">HeisenBug a trav√©s de los ojos de un empleado de SberTech</a></li>
<li><a href="../es433724/index.html">Alguna verdad inc√≥moda sobre LDAC</a></li>
<li><a href="../es433726/index.html">Introducci√≥n a la API de automatizaci√≥n: Parte 1: descripci√≥n general</a></li>
<li><a href="../es433728/index.html">Google cerr√≥ el proyecto de motor de b√∫squeda censurado chino debido a desacuerdos dentro de la empresa</a></li>
<li><a href="../es433732/index.html">Alan Kay: "¬øQu√© libros recomendar√≠as leer a alguien que estudie Inform√°tica"</a></li>
<li><a href="../es433734/index.html">Donald Knuth: ‚ÄúLos camaradas mayores jugaban al tenis, √©ramos pelotas. Nos golpearon, nos doli√≥ ‚Äù. (11,12 / 97)</a></li>
<li><a href="../es433738/index.html">Antig√ºedades: juegos en MS-DOS que no elegimos</a></li>
<li><a href="../es433740/index.html">Duma estatal cancela el roaming nacional en tercera lectura</a></li>
<li><a href="../es433742/index.html">Turborreactor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>