<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¥ üõÇ üï¢ Escrevendo uma interface do Snapchat no Swift ‚õé üìã üñêüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√≥logo 


 Em um dos meus projetos, eu precisava criar uma interface como essa no Snepchat. Quando um cart√£o com informa√ß√µes sai da c√¢mera em cima da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escrevendo uma interface do Snapchat no Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415795/"><h2 id="prolog">  Pr√≥logo </h2><br><p> Em um dos meus projetos, eu precisava criar uma interface como essa no Snepchat.  Quando um cart√£o com informa√ß√µes sai da c√¢mera em cima da imagem, substitua-o suavemente por uma cor s√≥lida e tamb√©m na dire√ß√£o oposta.  Pessoalmente, fiquei particularmente fascinado com a transi√ß√£o da janela da c√¢mera para o cart√£o lateral e, com grande prazer, recontamos maneiras de resolver esse problema. </p><br><p>  √Ä esquerda, um exemplo do Snepchat, √† direita, um exemplo de aplicativo que criaremos. </p><br><p><img src="https://habrastorage.org/webt/es/cx/sd/escxsdlqbwqu7rfh9l9lcjjcl0a.gif"><img src="https://habrastorage.org/webt/vg/xf/8v/vgxf8vdl1gwnu0vplvu9gikqaho.gif"></p><a name="habracut"></a><br><p> Provavelmente a primeira solu√ß√£o que vem √† mente √© adaptar o <code>UIScrollView</code> , organizar de alguma forma as visualiza√ß√µes, usar a pagina√ß√£o, mas, francamente, o pergaminho √© pensado para resolver problemas completamente diferentes, captando anima√ß√µes adicionais que consomem tempo e n√£o possuem a flexibilidade necess√°ria configura√ß√µes.  Portanto, us√°-lo para resolver esse problema √© absolutamente injustificado. </p><br><p>  A rolagem entre a janela da c√¢mera e a guia lateral √© enganosa - n√£o √© uma rolagem, √© uma transi√ß√£o interativa entre as visualiza√ß√µes pertencentes a diferentes controladores.  Os bot√µes na parte inferior s√£o guias comuns, clicando nos quais nos lan√ßa entre os controladores. </p><br><p><img src="https://habrastorage.org/webt/s1/xq/o7/s1xqo7xcojshfu3lqvdjiyonluk.jpeg"></p><br><p>  Dessa maneira, o Snatch usa sua pr√≥pria vers√£o de um controlador de navega√ß√£o, como o <code>UITabBarController</code> com transi√ß√µes interativas personalizadas. </p><br><p>  <code>UIKit</code> inclui duas op√ß√µes para controladores de navega√ß√£o que permitem personalizar transi√ß√µes - s√£o <code>UINavigationController</code> e <code>UITabBarController</code> .  Ambos t√™m <code>navigationController(_:interactionControllerFor:)</code> m√©todos <code>navigationController(_:interactionControllerFor:)</code> <code>tabBarController(_:interactionControllerFor:)</code> <code>navigationController(_:interactionControllerFor:)</code> e <code>tabBarController(_:interactionControllerFor:)</code> em seus delegados, respectivamente, o que nos permite usar nossa pr√≥pria anima√ß√£o interativa para a transi√ß√£o. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tabBarController (_ :actionControllerFor :)</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">navigationController (_ :actionControllerFor :)</a> </p><br><p>  Mas eu n√£o gostaria de ser limitado pela implementa√ß√£o de <code>UITabBarController</code> ou <code>UINavigationController</code> , especialmente porque n√£o podemos controlar sua l√≥gica interna.  Portanto, decidi escrever meu controlador semelhante e agora quero contar e mostrar o que veio dele. </p><br><h2 id="postanovka-zadachi">  Declara√ß√£o do problema </h2><br><p>  Crie seu pr√≥prio controlador de cont√™iner, no qual voc√™ pode alternar entre controladores filhos usando anima√ß√µes interativas para transi√ß√µes, usando o mecanismo padr√£o em <code>UITabBarController</code> e <code>UINavigationController</code> .  Precisamos desse mecanismo padr√£o para usar anima√ß√µes de transi√ß√£o prontas do tipo <code>UIViewControllerAnimatedTransitioning</code> j√° gravadas. </p><br><h2 id="podgotovka-proekta">  Prepara√ß√£o do projeto </h2><br><p>  Normalmente, tento mover os m√≥dulos para estruturas separadas, para isso crio um novo projeto de aplicativo e adiciono um destino adicional do <code>Cocoa Touch Framework</code> l√° e depois disperso as fontes no projeto para os destinos correspondentes.  Dessa forma, obtenho uma estrutura separada com um aplicativo de teste para depura√ß√£o. </p><br><p>  Crie um <code>Single View App</code> . </p><br><p><img src="https://habrastorage.org/webt/6p/eb/pa/6pebpaksin3ixvmlpse9tj7rnzs.png"></p><br><p>  <code>Product Name</code> ser√° nosso alvo. </p><br><p><img src="https://habrastorage.org/webt/aq/qv/fg/aqqvfgoimy4kv85lqjrb34tbkco.png"></p><br><p>  Clique em <code>+</code> para adicionar o alvo. </p><br><p><img src="https://habrastorage.org/webt/_b/2v/vj/_b2vvjuxpzkbvcmxuo8wxsctza0.png"></p><br><p>  Escolha <code>Cocoa Touch Framework</code> . </p><br><p><img src="https://habrastorage.org/webt/kr/mg/yy/krmgyylj_xfil50cdtejstjdpuc.png"></p><br><p>  Chamamos nossa estrutura de nome apropriado, o Xcode seleciona automaticamente o projeto para o nosso destino e nos oferece vincular o bin√°rio diretamente ao aplicativo.  N√≥s concordamos. </p><br><p><img src="https://habrastorage.org/webt/no/xi/cn/noxicnp_oslkyxhn3qkmcaukpom.png"></p><br><p>  N√£o precisaremos do <code>Main.storyboard</code> e do <code>Main.storyboard</code> padr√£o, os <code>Main.storyboard</code> . </p><br><p><img src="https://habrastorage.org/webt/_m/zq/aw/_mzqawkdo2pi9zgulfqlwnhs2vo.png"></p><br><p>  Al√©m disso, n√£o se esque√ßa de remover o valor da <code>Main Interface</code> no destino do aplicativo na guia <code>General</code> . </p><br><p><img src="https://habrastorage.org/webt/kt/sv/3v/ktsv3vjy_1vqgwdnkh288h4ecpc.png"></p><br><p>  Agora vamos para <code>AppDelegate.swift</code> e deixamos apenas o m√©todo de <code>application</code> do seguinte conte√∫do: </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">]?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Launch our master view controller let master = MasterViewController() window = UIWindow() window?.rootViewController = master window?.makeKeyAndVisible() return true }</span></span></code> </pre> <br><p>  Aqui, colocamos nosso controlador no local principal para que apare√ßa ap√≥s o iniciador. </p><br><p>  Agora crie esse mesmo <code>MasterViewController</code> .  Ser√° relacionado ao aplicativo, por isso √© importante escolher o destino certo ao criar o arquivo. </p><br><p><img src="https://habrastorage.org/webt/7m/0y/r8/7m0yr8cefaenhznoqbjisg7sy1q.png"></p><br><p>  <code>MasterViewController</code> do <code>SnapchatNavigationController</code> , que implementaremos posteriormente na estrutura.  N√£o se esque√ßa de especificar a <code>import</code> nossa estrutura.  Eu n√£o forne√ßo o c√≥digo completo do controlador aqui, as omiss√µes s√£o mostradas por retic√™ncias <code>...</code> , coloquei o aplicativo no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> , onde voc√™ pode ver todos os detalhes.  Neste controlador, estamos interessados ‚Äã‚Äãapenas no m√©todo <code>viewDidLoad()</code> , que inicializa o controlador em segundo plano com a c√¢mera + um controlador transparente (janela principal) + o controlador que cont√©m o cart√£o de partida. </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">MakingSnapchatNavigation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MasterViewController</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">SnapchatNavigationController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> func viewDidLoad() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() <span class="hljs-comment"><span class="hljs-comment">//   let camera = CameraViewController() setBackground(vc: camera) //     var vcs: [UIViewController] = [] //    var stub = UIViewController() stub.view.backgroundColor = .clear vcs.append(stub) //  ,     stub = UIViewController() stub.view.backgroundColor = .clear //   let scroll = UIScrollView() stub.view.addSubview(scroll) //  ... //  ,      let content = GradientView() //  ... //    scroll.addSubview(content) vcs.append(stub) //     - setViewControllers(vcs: vcs) } }</span></span></code> </pre> <br><p>  O que est√° acontecendo aqui?  Criamos um controlador com uma c√¢mera e o <code>setBackground</code> segundo plano usando o m√©todo <code>setBackground</code> do <code>SnapchatNavigationController</code> .  Este controlador cont√©m uma imagem esticada para toda a vis√£o da c√¢mera.  Em seguida, criamos um controlador transparente vazio e o adicionamos ao array, ele simplesmente passa a imagem da c√¢mera atrav√©s dele, podemos colocar controles nele, criar outro controlador transparente, adicionar um scroll a ele, adicionar uma visualiza√ß√£o com conte√∫do dentro do scroll, adicionar um segundo controlador ao matriz e defina essa matriz usando o m√©todo especial <code>setViewControllers</code> do pai <code>SnapchatNavigationController</code> . </p><br><p>  N√£o se esque√ßa de adicionar uma solicita√ß√£o para usar a c√¢mera no <code>Info.plist</code> </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSCameraUsageDescription<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>Need camera for background<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Nisso, consideramos o aplicativo de teste pronto e passamos √† parte mais interessante - a implementa√ß√£o da estrutura. </p><br><h2 id="struktura-roditelskogo-kontrollera">  Estrutura do controlador pai </h2><br><p>  Primeiro, crie um <code>SnapchatNavigationController</code> vazio, √© importante escolher o destino certo para ele.  Se tudo foi feito corretamente, o aplicativo deve ser constru√≠do.  Esse status do projeto pode ser descarregado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">refer√™ncia</a> . </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> SnapchatNavigationController: UIViewController { override <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> func viewDidLoad() { super.viewDidLoad() // <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> additional setup <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> loading the <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>. } // MARK: - <span class="hljs-built_in"><span class="hljs-built_in">Public</span></span> interface /// Sets <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controllers. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> func setViewControllers(vcs: [UIViewController]) { } /// Sets background <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> func setBackground(vc: UIViewController) { } }</code> </pre> <br><p>  Agora adicione os componentes internos nos quais o controlador ser√° composto.  N√£o trago todo o c√≥digo aqui, concentro-me apenas em pontos importantes. </p><br><p>  Definimos as vari√°veis ‚Äã‚Äãpara armazenar a matriz de controladores filhos.  Agora, definimos rigidamente a quantidade necess√°ria - 2 pe√ßas.  No futuro, ser√° poss√≠vel expandir a l√≥gica do controlador para uso com qualquer n√∫mero de controladores.  Tamb√©m configuramos uma vari√°vel para armazenar o controlador atual exibido. </p><br><pre> <code class="hljs pgsql">private let requiredChildrenAmount = <span class="hljs-number"><span class="hljs-number">2</span></span> // MARK: - <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> controllers /// top child <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controller private var topViewController: UIViewController? /// <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> children <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controllers private var children: [UIViewController] = []</code> </pre> <br><p>  Crie as visualiza√ß√µes.  Precisamos de uma vis√£o para o segundo plano, uma vis√£o com o efeito que queremos aplicar ao segundo plano ao alterar o controlador.  Tamb√©m temos um cont√™iner de visualiza√ß√£o para o controlador filho atual e um indicador de visualiza√ß√£o que informar√° ao usu√°rio como trabalhar com a navega√ß√£o. </p><br><pre> <code class="hljs bash">// MARK: - Views private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundViewContainer = UIView() private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffectView: UIVisualEffectView = { <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffect = UIBlurEffect(style: UIBlurEffectStyle.light) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffectView = UIVisualEffectView(effect: backgroundBlurEffect) backgroundBlurEffectView.alpha = 0 <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> backgroundBlurEffectView }() /// content view <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> children private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> contentViewContainer = UIView() private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> swipeIndicatorView = UIView()</code> </pre> <br><p>  No pr√≥ximo bloco, definimos duas vari√°veis: <code>swipeAnimator</code> √© respons√°vel pela anima√ß√£o, <code>swipeInteractor</code> √© respons√°vel pela intera√ß√£o (a capacidade de controlar o progresso da anima√ß√£o), precisamos inicializ√°-lo durante a inicializa√ß√£o do controlador, para for√ßar o desembrulhamento. </p><br><pre> <code class="hljs erlang">// MARK: - Animation <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> transition private <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> swipeAnimator = AnimatedTransitioning() private var swipeInteractor: CustomSwipeInteractor!</code> </pre> <br><p>  Tamb√©m definimos a transforma√ß√£o para o indicador.  Mudamos o indicador pela largura do cont√™iner + deslocamento duplo da borda + a largura do pr√≥prio indicador, de modo que o indicador esteja na extremidade oposta do cont√™iner.  A largura do cont√™iner ser√° conhecida durante o aplicativo, portanto a vari√°vel √© calculada em movimento. </p><br><pre> <code class="hljs pgsql">// MARK: - Animation transforms private var swipeIndicatorViewTransform: CGAffineTransform { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CGAffineTransform(translationX: -contentViewContainer.bounds.size.width + (swipeIndicatorViewXShift * <span class="hljs-number"><span class="hljs-number">2</span></span>) + swipeIndicatorViewWidth, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) } }</code> </pre> <br><p>  Durante o carregamento do controlador, atribu√≠mos <code>self</code> √† anima√ß√£o (implementaremos o protocolo correspondente abaixo), inicializamos o interator com base em nossa anima√ß√£o, cujo progresso ele controlar√°.  Tamb√©m o designamos como delegado.  O delegado responder√° ao in√≠cio do gesto do usu√°rio e iniciar√° a anima√ß√£o ou cancelar√° dependendo do estado do controlador.  Em seguida, adicionamos todas as visualiza√ß√µes √† principal e chamamos <code>setupViews()</code> , que define as restri√ß√µes. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() swipeAnimator.animation = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> swipeInteractor = <span class="hljs-type"><span class="hljs-type">CustomSwipeInteractor</span></span>(with: swipeAnimator) swipeInteractor.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> view.addSubview(backgroundViewContainer) view.addSubview(backgroundBlurEffectView) view.addSubview(contentViewContainer) view.addSubview(swipeIndicatorView) setupViews() }</code> </pre> <br><p>  Em seguida, passamos √† l√≥gica de instalar e remover controladores filhos em um cont√™iner.  Tudo aqui √© simples, como na documenta√ß√£o da Apple.  Usamos os m√©todos prescritos para esse tipo de opera√ß√£o. </p><br><p>  <code>addChildViewController(vc)</code> - adiciona um controlador filho ao atual. </p><br><p>  <code>contentViewContainer.addSubview(vc.view)</code> - adicione a visualiza√ß√£o do controlador √† hierarquia da visualiza√ß√£o. </p><br><p>  <code>vc.view.frame = contentViewContainer.bounds</code> - estende a exibi√ß√£o para todo o cont√™iner.  Como usamos os quadros aqui em vez do layout autom√°tico, precisamos alterar seus tamanhos sempre que o tamanho do controlador mudar, omitiremos essa l√≥gica e assumiremos que o cont√™iner n√£o alterar√° o tamanho do aplicativo enquanto o aplicativo estiver em execu√ß√£o. </p><br><p>  <code>vc.didMove(toParentViewController: self)</code> - encerra a opera√ß√£o de adi√ß√£o de um controlador filho. </p><br><p>  <code>swipeInteractor.wireTo</code> - vinculamos o controlador atual aos gestos do usu√°rio.  Mais tarde, analisaremos esse m√©todo. </p><br><pre> <code class="hljs pgsql">// MARK: - Private methods private func addChild(vc: UIViewController) { addChildViewController(vc) contentViewContainer.addSubview(vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>) vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.frame = contentViewContainer.bounds vc.didMove(toParentViewController: self) topViewController = vc let goingRight = children.<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>: topViewController!) == <span class="hljs-number"><span class="hljs-number">0</span></span> swipeInteractor.wireTo(viewController: topViewController!, edge: goingRight ? .right : .left) } private func removeChild(vc: UIViewController) { vc.willMove(toParentViewController: nil) vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.removeFromSuperview() vc.removeFromParentViewController() topViewController = nil }</code> </pre> <br><p>  Existem mais dois m√©todos cujo c√≥digo n√£o fornecerei aqui: <code>setViewControllers</code> e <code>setBackground</code> .  No m√©todo <code>setViewControllers</code> simplesmente configuramos a matriz de controladores filhos na vari√°vel correspondente do nosso controlador e chamamos <code>addChild</code> para exibir um deles na exibi√ß√£o.  No m√©todo <code>setBackground</code> fazemos o mesmo que em <code>addChild</code> , apenas para o controlador em segundo plano. </p><br><h2 id="logika-animacii-kontrollera-konteynera">  L√≥gica de anima√ß√£o do controlador de cont√™iner </h2><br><p>  Total, a base do nosso controlador pai √©: </p><br><ul><li>  UIView dividido em dois tipos <br><ul><li>  Contentores </li><li>  Ordin√°rio </li></ul></li><li>  Lista de filho UIViewController </li><li>  Um objeto de controle de anima√ß√£o do tipo <code>swipeAnimator</code> <code>AnimatedTransitioning</code> </li><li>  Um objeto que controla o curso interativo de uma anima√ß√£o <code>swipeInteractor</code> do tipo <code>CustomSwipeInteractor</code> </li><li>  Delegar Anima√ß√£o Interativa </li><li>  Implementa√ß√£o do Protocolo de Anima√ß√£o </li></ul><br><p>  Agora, analisaremos os dois √∫ltimos pontos e seguiremos para a implementa√ß√£o do <code>AnimatedTransitioning</code> e <code>CustomSwipeInteractor</code> . </p><br><h3 id="delegat-interaktivnogo-hoda-animacii">  Delegar Anima√ß√£o Interativa </h3><br><p>  O delegado consiste em apenas um <code>panGestureDidStart(rightToLeftSwipe: Bool) -&gt; Bool</code> , que informa o controlador sobre o in√≠cio do gesto e sua dire√ß√£o.  Em resposta, ele aguarda informa√ß√µes sobre se a anima√ß√£o pode ser considerada iniciada. </p><br><p>  Como delegado, verificamos a ordem atual dos controladores para entender se podemos iniciar a anima√ß√£o na dire√ß√£o especificada e, se estiver tudo bem, iniciamos o m√©todo de <code>transition</code> , com os par√¢metros: o controlador do qual estamos nos movendo, o controlador para o qual estamos nos movendo, dire√ß√£o do movimento, sinalizador de interatividade (em caso de <code>false</code> , uma anima√ß√£o de transi√ß√£o com tempo determinado √© iniciada). </p><br><pre> <code class="hljs julia">func panGestureDidStart(rightToLeftSwipe: <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span> { guard <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> topViewController = topViewController, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fromIndex = children.index(of: topViewController) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newIndex = rightToLeftSwipe ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> //   -    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> newIndex &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; newIndex &lt; children.count &amp;&amp; newIndex != fromIndex { transition(from: children[fromIndex], to: children[newIndex], goingRight: rightToLeftSwipe, interactive: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><p>  Vamos examinar imediatamente o corpo do m√©todo de <code>transition</code> .  Primeiro, criamos o contexto de anima√ß√£o para a anima√ß√£o <code>CustomControllerContext</code> .  Tamb√©m analisaremos essa classe um pouco mais tarde; ela implementa o protocolo <code>UIViewControllerContextTransitioning</code> .  No caso de <code>UINavigationController</code> e <code>UITabBarController</code> inst√¢ncia da implementa√ß√£o deste protocolo √© criada automaticamente pelo sistema e sua l√≥gica √© oculta para n√≥s, precisamos criar nossa pr√≥pria. </p><br><pre> <code class="hljs pgsql">let ctx = CustomControllerContext(fromViewController: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, toViewController: <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, containerView: contentViewContainer, goingRight: goingRight) ctx.isAnimated = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ctx.isInteractive = interactive ctx.completionBlock = { (didComplete: <span class="hljs-type"><span class="hljs-type">Bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> didComplete { self.removeChild(vc: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) self.addChild(vc: <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) } };</code> </pre> <br><p>  Em seguida, chamamos simplesmente anima√ß√£o fixa ou interativa.  No futuro, ser√° poss√≠vel travar um fixo nos bot√µes de tabula√ß√£o da navega√ß√£o entre controladores; neste exemplo, n√£o faremos isso. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> interactive { // Animate <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> interaction swipeInteractor.startInteractiveTransition(ctx) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // Animate <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> interaction swipeAnimator.animateTransition(<span class="hljs-keyword"><span class="hljs-keyword">using</span></span>: ctx) }</code> </pre> <br><h3 id="protokol-animacii">  Protocolo de Anima√ß√£o </h3><br><p>  <code>TransitionAnimation</code> protocolo de anima√ß√£o <code>TransitionAnimation</code> consiste em 4 m√©todos: </p><br><p>  <code>addTo</code> √© um m√©todo desenvolvido para criar a estrutura correta das visualiza√ß√µes filho no cont√™iner, de modo que a exibi√ß√£o anterior se sobreponha √† nova de acordo com a id√©ia da anima√ß√£o. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// Setup the views hirearchy for animation. func addTo(containerView: UIView, fromView: UIView, toView: UIView, fromLeft: Bool)</span></span></code> </pre> <br><p>  <code>prepare</code> √© o m√©todo chamado antes da anima√ß√£o para preparar a exibi√ß√£o. </p><br><pre> <code class="hljs sql">/// Setup the views position prior to the animation start. func <span class="hljs-keyword"><span class="hljs-keyword">prepare</span></span>(fromView <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: UIView?, toView <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>: UIView?, fromLeft: <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>)</code> </pre> <br><p>  <code>animation</code> - a pr√≥pria anima√ß√£o. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// The animation. func animation(fromView from: UIView?, toView to: UIView?, fromLeft: Bool)</span></span></code> </pre> <br><p>  <code>finalize</code> - as a√ß√µes necess√°rias ap√≥s a conclus√£o da anima√ß√£o. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// Cleanup the views position after the animation ended. func finalize(completed: Bool, fromView from: UIView?, toView to: UIView?, fromLeft: Bool)</span></span></code> </pre> <br><p>  N√£o consideraremos a implementa√ß√£o usada, tudo √© bastante transparente por l√°, iremos direto para as tr√™s classes principais, gra√ßas √†s quais a anima√ß√£o ocorre. </p><br><h2 id="class-customcontrollercontext-nsobject-uiviewcontrollercontexttransitioning"> <code>class CustomControllerContext: NSObject, UIViewControllerContextTransitioning</code> </h2> <br><p>  O contexto da anima√ß√£o.  Para descrever sua fun√ß√£o, nos referimos √† ajuda do protocolo <code>UIViewControllerContextTransitioning</code> : </p><br><blockquote>  Um objeto de contexto encapsula informa√ß√µes sobre as visualiza√ß√µes e controladores de visualiza√ß√£o envolvidos na transi√ß√£o.  Ele tamb√©m cont√©m detalhes sobre como executar a transi√ß√£o. </blockquote><p>  O mais interessante √© a proibi√ß√£o de adapta√ß√£o deste protocolo: </p><br><blockquote>  N√£o adote esse protocolo em suas pr√≥prias classes, nem crie objetos diretamente que adotem esse protocolo. </blockquote><p>  Mas n√≥s realmente precisamos que ele execute o mecanismo de anima√ß√£o padr√£o, ent√£o o adaptamos de qualquer maneira.  Quase n√£o tem l√≥gica, apenas armazena estado.  Portanto, nem vou traz√™-lo aqui.  Voc√™ pode assistir no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . </p><br><p>  Funciona muito bem em anima√ß√µes com tempo determinado.  Mas ao us√°-lo para anima√ß√µes interativas, surge um problema - <code>UIPercentDrivenInteractiveTransition</code> chama um m√©todo n√£o documentado no contexto.  A √∫nica solu√ß√£o certa nessa situa√ß√£o √© adaptar outro protocolo - <code>UIViewControllerInteractiveTransitioning</code> para usar seu pr√≥prio contexto. </p><br><h2 id="class-percentdriveninteractivetransition-nsobject-uiviewcontrollerinteractivetransitioning"> <code>class PercentDrivenInteractiveTransition: NSObject, UIViewControllerInteractiveTransitioning</code> </h2> <br><p>  Aqui est√° - o cora√ß√£o do projeto, permitindo que existam anima√ß√µes interativas em controladores de cont√™iner personalizados.  Vamos tom√°-lo em ordem. </p><br><p>  A classe √© inicializada com um par√¢metro do tipo <code>UIViewControllerAnimatedTransitioning</code> , este √© o protocolo padr√£o para animar a transi√ß√£o entre controladores.  Dessa forma, podemos usar qualquer uma das anima√ß√µes j√° escritas em conjunto com nossa classe. </p><br><pre> <code class="hljs objectivec">init(with animator: <span class="hljs-built_in"><span class="hljs-built_in">UIViewControllerAnimatedTransitioning</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.animator = animator }</code> </pre> <br><p>  A interface p√∫blica √© bastante simples, com quatro m√©todos, cuja funcionalidade deve ser √≥bvia. </p><br><p>  Basta observar o momento em que a anima√ß√£o come√ßa, pegamos a visualiza√ß√£o principal do cont√™iner e configuramos a velocidade da camada para 0, para que possamos controlar o progresso da anima√ß√£o manualmente. </p><br><pre> <code class="hljs pgsql">// MARK: - <span class="hljs-built_in"><span class="hljs-built_in">Public</span></span> func startInteractiveTransition(_ transitionContext: UIViewControllerContextTransitioning) { self.transitionContext = transitionContext transitionContext.containerView.superview?.layer.speed = <span class="hljs-number"><span class="hljs-number">0</span></span> animator.animateTransition(<span class="hljs-keyword"><span class="hljs-keyword">using</span></span>: transitionContext) } func updateInteractiveTransition(percentComplete: CGFloat) { setPercentComplete(percentComplete: (CGFloat(fmaxf(fminf(<span class="hljs-type"><span class="hljs-type">Float</span></span>(percentComplete), <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>)))) } func cancelInteractiveTransition() { transitionContext?.cancelInteractiveTransition() completeTransition() } func finishInteractiveTransition() { transitionContext?.finishInteractiveTransition() completeTransition() }</code> </pre> <br><p>  Agora nos voltamos para o bloco l√≥gico privado de nossa classe. </p><br><p>  <code>setPercentComplete</code> define o deslocamento de tempo do progresso da anima√ß√£o para a camada de superview, calculando o valor a partir da porcentagem de conclus√£o e dura√ß√£o da anima√ß√£o. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPercentComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(percentComplete: CGFloat)</span></span></span></span> { setTimeOffset(timeOffset: <span class="hljs-type"><span class="hljs-type">TimeInterval</span></span>(percentComplete) * duration) transitionContext?.updateInteractiveTransition(percentComplete) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setTimeOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset: TimeInterval)</span></span></span></span> { transitionContext?.containerView.superview?.layer.timeOffset = timeOffset }</code> </pre> <br><p>  <code>completeTransition</code> √© chamado quando o usu√°rio interrompe seu gesto.  Aqui, criamos uma inst√¢ncia da classe <code>CADisplayLink</code> , que nos permitir√° concluir automaticamente a anima√ß√£o lindamente a partir do momento em que o usu√°rio n√£o controla mais seu progresso.  Adicionamos nosso <code>displayLink</code> ao <code>run loop</code> para que o sistema chame nosso seletor sempre que precisar exibir um novo quadro na tela do dispositivo. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">completeTransition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { displayLink = <span class="hljs-type"><span class="hljs-type">CADisplayLink</span></span>(target: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, selector: #selector(tickAnimation)) displayLink!.add(to: .main, forMode: .commonModes) }</code> </pre> <br><p>  Em nosso seletor, calculamos e definimos o deslocamento tempor√°rio do progresso da anima√ß√£o, como fizemos anteriormente durante o gesto do usu√°rio, ou conclu√≠mos a anima√ß√£o quando ela atinge seu ponto inicial ou final. </p><br><pre> <code class="hljs coffeescript">@objc private func tickAnimation() { var timeOffset = self.timeOffset() let tick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(displayLink?.duration ?? </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> * TimeInterval</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completionSpeed)</span></span></span><span class="hljs-function"> timeOffset += </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transitionContext?.transitionWasCancelled ?? </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ? -tick : tick; if </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || timeOffset &gt; duration)</span></span></span><span class="hljs-function"> { transitionFinished</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> } else { setTimeOffset</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset: timeOffset)</span></span></span><span class="hljs-function"> } } private func timeOffset</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> TimeInterval { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> transitionContext?.containerView.superview?.layer.timeOffset ?? <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><p>  Terminando a anima√ß√£o, desligamos nosso <code>displayLink</code> , retornamos a velocidade da camada e, se a anima√ß√£o n√£o foi cancelada, ou seja, atingiu seu quadro final, calculamos o tempo a partir do qual a anima√ß√£o da camada deve come√ßar.  Voc√™ pode aprender mais sobre isso no Guia de programa√ß√£o da anima√ß√£o principal ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nesta resposta</a> ao stackoverflow. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transitionFinished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { displayLink?.invalidate() <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> layer = transitionContext?.containerView.superview?.layer <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } layer.speed = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wasNotCanceled = !(transitionContext?.transitionWasCancelled ?? <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wasNotCanceled) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pausedTime = layer.timeOffset layer.timeOffset = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timeSincePause = layer.convertTime(<span class="hljs-type"><span class="hljs-type">CACurrentMediaTime</span></span>(), from: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) - pausedTime layer.beginTime = timeSincePause } animator.animationEnded?(wasNotCanceled) }</code> </pre> <br><h2 id="class-animatedtransitioning-nsobject-uiviewcontrolleranimatedtransitioning"> <code>class AnimatedTransitioning: NSObject, UIViewControllerAnimatedTransitioning</code> </h2> <br><p>  A √∫ltima classe que ainda n√£o examinamos √© a implementa√ß√£o do protocolo <code>UIViewControllerAnimatedTransitioning</code> , no qual controlamos a ordem de execu√ß√£o dos m√©todos de protocolo da nossa anima√ß√£o <code>addTo</code> , <code>prepare</code> , <code>animation</code> , <code>finalize</code> .  Tudo aqui √© bastante prosaico, vale a pena notar apenas o uso do <code>UIViewPropertyAnimator</code> para executar anima√ß√£o em vez do <code>UIView.animate(withDuration:animations:)</code> mais t√≠pico <code>UIView.animate(withDuration:animations:)</code> .  Isso √© feito para que seja poss√≠vel controlar ainda mais o progresso da anima√ß√£o e, se for cancelada, retorne-a √† sua posi√ß√£o inicial chamando <code>finishAnimation(at: .start)</code> , que evita piscar desnecessariamente o quadro final da anima√ß√£o na tela. </p><br><h2 id="epilog">  Ep√≠logo </h2><br><p>  Criamos uma demonstra√ß√£o funcional de uma interface semelhante √† do Snapchat.  Na minha vers√£o, configurei as constantes para que existam campos √† direita e √† esquerda do cart√£o, al√©m disso, deixei a c√¢mera trabalhando na exibi√ß√£o em segundo plano para criar um efeito atr√°s do cart√£o.  Isso √© feito apenas para demonstrar os recursos dessa abordagem, como isso afetar√° o desempenho do dispositivo e eu n√£o verifiquei a carga da bateria. </p><br><p>   ‚Äî        ,    -  ,          .      ,    -    . </p><br><p>      GitHub  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . </p><br><p>   ,   ,  ,  ! </p><br><p><img src="https://habrastorage.org/webt/mh/se/2z/mhse2z7hfck6aicbobu-vwyi9bw.gif"></p><br><h2 id="istochniki-informacii">   </h2><br><p>        : </p><br><ol><li><p>  Custom Container View Controller Transitions,  Joachim Bondo. </p><br><p>        Objective C.          Swift. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> </p><br></li><li><p>  Interactive Custom Container View Controller Transitions,  Alek √Östr√∂m </p><br><p>               ,   Objective C,           Swift. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> </p><br></li><li><p> <code>SwipeableTabBarController</code> </p> <br><p> ,            <code>UITabBarController</code> .      . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> </p><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt415795/">https://habr.com/ru/post/pt415795/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt415783/index.html">Os discos estelares nos revelam os segredos da apar√™ncia dos planetas</a></li>
<li><a href="../pt415785/index.html">SpaceX envia rob√¥ de intelig√™ncia artificial para a ISS</a></li>
<li><a href="../pt415789/index.html">Algoritmos de patente para programas de computador</a></li>
<li><a href="../pt415791/index.html">Otimiza√ß√£o de contratos inteligentes. Como os tipos de solidez afetam os custos de transa√ß√£o</a></li>
<li><a href="../pt415793/index.html">Guia completo de pedidos pendentes de dom√≠nio</a></li>
<li><a href="../pt415797/index.html">Express√µes regulares + programa√ß√£o l√≥gica. Qual √© o resultado?</a></li>
<li><a href="../pt415801/index.html">Google: nossa IA de "telefone" n√£o √© boa o suficiente para ser perigosa</a></li>
<li><a href="../pt415805/index.html">Modifica√ß√£o do m√≥dulo de barreira GSM Doorhan para controle da Internet</a></li>
<li><a href="../pt415809/index.html">Como usar soy, requirejs, backbone js em plugins para o Atlassian Jira</a></li>
<li><a href="../pt415811/index.html">AI, curso pr√°tico. Vis√£o geral de redes neurais para classifica√ß√£o de imagens</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>