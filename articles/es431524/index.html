<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏾 🙎🏿 🤱🏻 Serialización en Java. No tan simple 👋🏼 👶🏻 🌨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La serialización es un proceso que traduce un objeto en una secuencia de bytes, desde la cual se puede restaurar por completo. ¿Por qué se necesita es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Serialización en Java. No tan simple</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431524/"><img src="https://habrastorage.org/webt/az/3t/pd/az3tpdhy1ajhximnq7nsjbxvsdy.png"><br><br>  <strong>La serialización</strong> es un proceso que traduce un objeto en una secuencia de bytes, desde la cual se puede restaurar por completo.  ¿Por qué se necesita esto? <a name="habracut"></a>  El hecho es que, durante la ejecución normal del programa, se conoce la vida útil máxima de cualquier objeto, desde el lanzamiento del programa hasta su finalización.  La serialización le permite expandir este marco y "dar vida" al objeto de la misma manera entre los lanzamientos de programas. <br><br>  Una ventaja adicional para todo es la preservación de la plataforma cruzada.  No importa qué sistema operativo tenga, la serialización traduce el objeto en una secuencia de bytes, que puede restaurarse en cualquier sistema operativo.  Si necesita transferir un objeto a través de la red, puede serializar el objeto, guardarlo en un archivo y transferirlo al destinatario a través de la red.  Podrá recuperar el objeto recibido.  La serialización también le permite llamar de forma remota métodos (Java RMI) que están en diferentes máquinas con, posiblemente, diferentes sistemas operativos, y trabajar con ellos como si estuvieran en la máquina del proceso de Java que realiza la llamada. <br><br>  Implementar un mecanismo de serialización es bastante simple.  Su clase necesita implementar la interfaz <strong><em>serializable</em></strong> .  Esta interfaz es un identificador que no tiene métodos, pero le dice a jvm que los objetos de esta clase se pueden serializar.  Dado que el mecanismo de serialización está conectado al sistema básico de entrada / salida y traduce el objeto en un flujo de bytes, para ejecutarlo debe crear un flujo de salida <em>OutputStream</em> , empaquetarlo en <em>ObjectOutputStream</em> y llamar al método <em>writeObject ().</em>  Para restaurar un objeto, debe empacar un <em>InputStream</em> en un <em>ObjectInputStream</em> y llamar al método <em>readObject ().</em> <br><br>  Durante el proceso de serialización, junto con el objeto serializable, se guarda su gráfico de objeto.  Es decir  todos los objetos relacionados con esto, los objetos de otras clases también se serializarán con él. <br><br>  Considere un ejemplo de serialización de un objeto de clase Persona. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.*; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Home</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String home; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Home</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String home)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.home = home; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> home; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> countOfNiva; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String fatherName; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Home home; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> countOfNiva, String fatherName, Home home)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.countOfNiva = countOfNiva; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fatherName = fatherName; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.home = home; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Person{"</span></span> + <span class="hljs-string"><span class="hljs-string">"name='"</span></span> + name + <span class="hljs-string"><span class="hljs-string">'\''</span></span> + <span class="hljs-string"><span class="hljs-string">", countOfNiva="</span></span> + countOfNiva + <span class="hljs-string"><span class="hljs-string">", fatherName='"</span></span> + fatherName + <span class="hljs-string"><span class="hljs-string">'\''</span></span> + <span class="hljs-string"><span class="hljs-string">", home="</span></span> + home + <span class="hljs-string"><span class="hljs-string">'}'</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, ClassNotFoundException </span></span>{ Home home = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Home(<span class="hljs-string"><span class="hljs-string">"Vishnevaia 1"</span></span>); Person igor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Igor"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"Raphael"</span></span>, home); Person renat = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Renat"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"Raphael"</span></span>, home); <span class="hljs-comment"><span class="hljs-comment">//      ObjectOutputStream ObjectOutputStream objectOutputStream = new ObjectOutputStream( new FileOutputStream("person.out")); objectOutputStream.writeObject(igor); objectOutputStream.writeObject(renat); objectOutputStream.close(); //       ObjectInputStream ObjectInputStream objectInputStream = new ObjectInputStream( new FileInputStream("person.out")); Person igorRestored = (Person) objectInputStream.readObject(); Person renatRestored = (Person) objectInputStream.readObject(); objectInputStream.close(); //    ByteArrayOutputStream ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream2 = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream2.writeObject(igor); objectOutputStream2.writeObject(renat); objectOutputStream2.flush(); //    ByteArrayInputStream ObjectInputStream objectInputStream2 = new ObjectInputStream( new ByteArrayInputStream(byteArrayOutputStream.toByteArray())); Person igorRestoredFromByte = (Person) objectInputStream2.readObject(); Person renatRestoredFromByte = (Person) objectInputStream2.readObject(); objectInputStream2.close(); System.out.println("Before Serialize: " + "\n" + igor + "\n" + renat); System.out.println("After Restored From Byte: " + "\n" + igorRestoredFromByte + "\n" + renatRestoredFromByte); System.out.println("After Restored: " + "\n" + igorRestored + "\n" + renatRestored); } }</span></span></code> </pre> <br>  <strong>Conclusión</strong> <br><br><pre> <code class="java hljs">Before Serialize: Person{name=<span class="hljs-string"><span class="hljs-string">'Igor'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">355</span></span>da254} Person{name=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">355</span></span>da254} After Restored From Byte: Person{name=<span class="hljs-string"><span class="hljs-string">'Igor'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">27973e9</span></span>b} Person{name=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">27973e9</span></span>b} After Restored: Person{name=<span class="hljs-string"><span class="hljs-string">'Igor'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">312</span></span>b1dae} Person{name=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">312</span></span>b1dae}</code> </pre> <br>  En este ejemplo, la clase <em>Home</em> se crea para demostrar que al serializar un objeto <em>Person</em> , el gráfico de sus objetos se serializa con él.  La clase <em>Home</em> también debe implementar la interfaz <em>serializable</em> , de lo contrario se producirá una <em>excepción java.io.NotSerializableException</em> .  El ejemplo también describe la serialización utilizando la clase <em>ByteArrayOutputStream</em> . <br><br>  Se puede sacar una conclusión interesante de los resultados de la ejecución del programa: <em>al restaurar objetos que tenían una referencia al mismo objeto antes de la serialización, este objeto se restaurará solo una vez</em> .  Esto se puede ver en los mismos enlaces en los objetos después de la recuperación: <br><br><pre> <code class="java hljs">After Restored From Byte: Person{name=<span class="hljs-string"><span class="hljs-string">'Igor'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">27973e9</span></span>b} Person{name=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">27973e9</span></span>b} After Restored: Person{name=<span class="hljs-string"><span class="hljs-string">'Igor'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">312</span></span>b1dae} Person{name=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, countOfNiva=<span class="hljs-number"><span class="hljs-number">2</span></span>, fatherName=<span class="hljs-string"><span class="hljs-string">'Raphael'</span></span>, home=Home@<span class="hljs-number"><span class="hljs-number">312</span></span>b1dae}</code> </pre> <br>  Sin embargo, también se ve que cuando se graba con dos secuencias de salida (tenemos <em>ObjectInputStream</em> y <em>ByteArrayOutputStream</em> ), el objeto de <em>inicio se</em> volverá a crear, a pesar de que ya se creó antes en una de las secuencias.  Vemos esto en diferentes direcciones de objetos <em>domésticos</em> recibidos en dos flujos.  Resulta que si serializa con una secuencia de salida, luego restaura el objeto, entonces tenemos la garantía de restaurar la red completa de objetos sin duplicados innecesarios.  Por supuesto, durante la ejecución del programa, el estado de los objetos puede cambiar, pero esto depende de la conciencia del programador. <br><br>  <strong>El problema</strong> <br><br>  El ejemplo también muestra que al restaurar un objeto, se puede producir una <em>ClassNotFoundException</em> .  ¿Cuál es la razón de esto?  El hecho es que podemos serializar fácilmente un objeto de la clase <em>Person</em> en un archivo, transferirlo a través de la red a nuestro amigo, quien puede restaurar el objeto mediante otra aplicación en la que la clase <em>Person</em> simplemente no existe. <br><br>  <strong>Su serialización.</strong>  <strong>Cómo hacer?</strong> <br><br>  ¿Qué sucede si desea gestionar la serialización usted mismo?  Por ejemplo, su objeto almacena el nombre de usuario y la contraseña de los usuarios.  Necesita serializarlo para una mayor transmisión a través de la red.  Pasar una contraseña en este caso es extremadamente poco confiable.  ¿Cómo resolver este problema?  Hay dos formas  Primero, use la palabra clave <strong><em>transitoria</em></strong> .  Segundo, en lugar de darse cuenta del interés <em>serializable</em> , use su extensión: la interfaz <em><strong>externalizable</strong></em> .  Considere los ejemplos del primer y segundo método para compararlos. <br><br>  <strong>La primera forma: serialización usando transitorios</strong> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logon</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String login; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transient</span></span> String password; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Logon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String login, String password)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.login = login; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.password = password; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Logon{"</span></span> + <span class="hljs-string"><span class="hljs-string">"login='"</span></span> + login + <span class="hljs-string"><span class="hljs-string">'\''</span></span> + <span class="hljs-string"><span class="hljs-string">", password='"</span></span> + password + <span class="hljs-string"><span class="hljs-string">'\''</span></span> + <span class="hljs-string"><span class="hljs-string">'}'</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, ClassNotFoundException </span></span>{ Logon igor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Logon(<span class="hljs-string"><span class="hljs-string">"IgorIvanovich"</span></span>, <span class="hljs-string"><span class="hljs-string">"Khoziain"</span></span>); Logon renat = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Logon(<span class="hljs-string"><span class="hljs-string">"Renat"</span></span>, <span class="hljs-string"><span class="hljs-string">"2500RUB"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Before: \n"</span></span> + igor); System.out.println(renat); ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(<span class="hljs-string"><span class="hljs-string">"Externals.out"</span></span>)); out.writeObject(igor); out.writeObject(renat); out.close(); ObjectInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectInputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(<span class="hljs-string"><span class="hljs-string">"Externals.out"</span></span>)); igor = (Logon) in.readObject(); renat = (Logon) in.readObject(); System.out.println(<span class="hljs-string"><span class="hljs-string">"After: \n"</span></span> + igor); System.out.println(renat); } }</code> </pre> <br>  <strong>Conclusión</strong> <br><br><pre> <code class="java hljs">Before: Logon{login=<span class="hljs-string"><span class="hljs-string">'IgorIvanovich'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'Khoziain'</span></span>} Logon{login=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'2500RUB'</span></span>} After: Logon{login=<span class="hljs-string"><span class="hljs-string">'IgorIvanovich'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'null'</span></span>} Logon{login=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'null'</span></span>}</code> </pre> <br>  <strong>La segunda forma: serialización con la implementación de la interfaz externalizable</strong> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logon</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Externalizable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String login; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String password; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Logon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Logon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String login, String password)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.login = login; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.password = password; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeExternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjectOutput out)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ out.writeObject(login); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Logon{"</span></span> + <span class="hljs-string"><span class="hljs-string">"login='"</span></span> + login + <span class="hljs-string"><span class="hljs-string">'\''</span></span> + <span class="hljs-string"><span class="hljs-string">", password='"</span></span> + password + <span class="hljs-string"><span class="hljs-string">'\''</span></span> + <span class="hljs-string"><span class="hljs-string">'}'</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readExternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjectInput in)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, ClassNotFoundException </span></span>{ login = (String) in.readObject(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, ClassNotFoundException </span></span>{ Logon igor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Logon(<span class="hljs-string"><span class="hljs-string">"IgorIvanovich"</span></span>, <span class="hljs-string"><span class="hljs-string">"Khoziain"</span></span>); Logon renat = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Logon(<span class="hljs-string"><span class="hljs-string">"Renat"</span></span>, <span class="hljs-string"><span class="hljs-string">"2500RUB"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Before: \n"</span></span> + igor); System.out.println(renat); ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(<span class="hljs-string"><span class="hljs-string">"Externals.out"</span></span>)); out.writeObject(igor); out.writeObject(renat); out.close(); ObjectInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectInputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(<span class="hljs-string"><span class="hljs-string">"Externals.out"</span></span>)); igor = (Logon) in.readObject(); renat = (Logon) in.readObject(); System.out.println(<span class="hljs-string"><span class="hljs-string">"After: \n"</span></span> + igor); System.out.println(renat); } }</code> </pre> <br>  <strong>Conclusión</strong> <br><br><pre> <code class="java hljs">Before: Logon{login=<span class="hljs-string"><span class="hljs-string">'IgorIvanovich'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'Khoziain'</span></span>} Logon{login=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'2500RUB'</span></span>} After: Logon{login=<span class="hljs-string"><span class="hljs-string">'IgorIvanovich'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'null'</span></span>} Logon{login=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'null'</span></span>}</code> </pre> <br>  La primera diferencia entre las dos opciones que llama la atención es el tamaño del código.  Al implementar la interfaz <em>Externalizable</em> , necesitamos anular dos métodos: <em><strong>writeExternal ()</strong></em> y <strong><em>readExternal ()</em></strong> .  En el método <em>writeExternal ()</em> , indicamos qué campos se serializarán y cómo, en <em>readExternal ()</em> cómo leerlos.  Cuando se usa la palabra <em>transitoria,</em> indicamos explícitamente qué campo o campos no necesitan ser serializados.  También notamos que en el segundo método, creamos explícitamente un constructor predeterminado, además, uno público.  ¿Por qué se hace esto?  Intentemos ejecutar el código sin este constructor.  Y mira la salida: <br><br><pre> <code class="java hljs">Before: Logon{login=<span class="hljs-string"><span class="hljs-string">'IgorIvanovich'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'Khoziain'</span></span>} Logon{login=<span class="hljs-string"><span class="hljs-string">'Renat'</span></span>, password=<span class="hljs-string"><span class="hljs-string">'2500RUB'</span></span>} Exception in thread <span class="hljs-string"><span class="hljs-string">"main"</span></span> java.io.InvalidClassException: Logon; no valid constructor at java.io.ObjectStreamClass$ExceptionInfo.newInvalidClassException(ObjectStreamClass.java:<span class="hljs-number"><span class="hljs-number">169</span></span>) at java.io.ObjectStreamClass.checkDeserialize(ObjectStreamClass.java:<span class="hljs-number"><span class="hljs-number">874</span></span>) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="hljs-number"><span class="hljs-number">2043</span></span>) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="hljs-number"><span class="hljs-number">1573</span></span>) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="hljs-number"><span class="hljs-number">431</span></span>) at Logon.main(Logon.java:<span class="hljs-number"><span class="hljs-number">45</span></span>)</code> </pre> <br>  Tenemos la excepción <em>java.io.InvalidClassException</em> .  ¿Cuál es la razón de esto?  Si sigue el seguimiento de la pila, puede descubrir que hay líneas en el constructor de la clase <em>ObjectStreamClass</em> : <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (externalizable) { cons = getExternalizableConstructor(cl); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cons = getSerializableConstructor(cl);</code> </pre> <br>  Para la interfaz <em>Externalizable</em> , se <em>llamará al</em> método del constructor <em>getExternalizableConstructor (),</em> dentro del cual a través de <em>Reflection</em> intentaremos obtener el constructor predeterminado de la clase para la que estamos restaurando el objeto.  Si no podemos encontrarlo, o no es <em>público</em> , entonces tenemos una excepción.  Puede solucionar esta situación de la siguiente manera: no cree explícitamente ningún constructor en la clase y llene los campos utilizando setters y obtenga el valor con getters.  Luego, al compilar la clase, se creará un constructor predeterminado, que estará disponible para <em>getExternalizableConstructor ()</em> .  Para <em>Serializable,</em> el método <em>getSerializableConstructor ()</em> obtiene el constructor de la clase <em>Object</em> y busca la clase deseada, si no lo encuentra, obtenemos una excepción <em>ClassNotFoundException</em> .  Resulta que la diferencia clave entre <em>Serializable</em> y <em>Externalizable</em> es que el primero no necesita un constructor para crear la recuperación de objetos.  Simplemente se recuperará completamente de los bytes.  Para el segundo, durante la restauración, primero se creará un objeto utilizando el constructor en el punto de declaración, y luego se escribirán en él los valores de sus campos de los bytes recibidos durante la serialización.  Personalmente, prefiero el primer método, es mucho más simple.  Además, incluso si aún necesitamos establecer el comportamiento de serialización, no podemos usar <em>Externalizable</em> , ni implementar <em>Serializable</em> agregando (sin anular) los <em>métodos writeObject ()</em> y <em>readObject ()</em> .  Pero para que puedan "trabajar", su firma debe ser estrictamente observada. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Talda</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String description; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Talda</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, String description)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.description = description; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjectOutputStream stream)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ stream.defaultWriteObject(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Our writeObject"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjectInputStream stream)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, ClassNotFoundException </span></span>{ stream.defaultReadObject(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Our readObject"</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Talda{"</span></span> + <span class="hljs-string"><span class="hljs-string">"name='"</span></span> + name + <span class="hljs-string"><span class="hljs-string">'\''</span></span> + <span class="hljs-string"><span class="hljs-string">", description='"</span></span> + description + <span class="hljs-string"><span class="hljs-string">'\''</span></span> + <span class="hljs-string"><span class="hljs-string">'}'</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, ClassNotFoundException </span></span>{ Talda partizanka = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Talda(<span class="hljs-string"><span class="hljs-string">"Partizanka"</span></span>, <span class="hljs-string"><span class="hljs-string">"Viiiski"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Before: \n"</span></span> + partizanka); ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(<span class="hljs-string"><span class="hljs-string">"Talda.out"</span></span>)); out.writeObject(partizanka); out.close(); ObjectInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectInputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(<span class="hljs-string"><span class="hljs-string">"Talda.out"</span></span>)); partizanka = (Talda) in.readObject(); System.out.println(<span class="hljs-string"><span class="hljs-string">"After: \n"</span></span> + partizanka); } }</code> </pre> <br>  <strong>Conclusión</strong> <br><br><pre> <code class="java hljs">Before: Talda{name=<span class="hljs-string"><span class="hljs-string">'Partizanka'</span></span>, description=<span class="hljs-string"><span class="hljs-string">'Viiiski'</span></span>} Our writeObject Our readObject After: Talda{name=<span class="hljs-string"><span class="hljs-string">'Partizanka'</span></span>, description=<span class="hljs-string"><span class="hljs-string">'Viiiski'</span></span>}</code> </pre> <br>  Dentro de nuestros métodos agregados, se <em>llama defaultWriteObject ()</em> y <em>defaultReadObject ()</em> .  Son responsables de la serialización predeterminada, como si funcionase sin los métodos que agregamos. <br><br>  De hecho, esto es solo la punta del iceberg, si continúa profundizando en el mecanismo de serialización, entonces con un alto grado de probabilidad, puede encontrar más matices, encontrando lo que decimos: "La serialización ... no es tan simple". </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431524/">https://habr.com/ru/post/es431524/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431512/index.html">Un pequeño estudio de las propiedades de una simple U-net, una red convolucional clásica para la segmentación.</a></li>
<li><a href="../es431514/index.html">Entrevista para entrevistadores.</a></li>
<li><a href="../es431516/index.html">Un día en la vida de un asesor financiero</a></li>
<li><a href="../es431518/index.html">Microsoft Connect (); Meetup en Moscú</a></li>
<li><a href="../es431520/index.html">Predecir la rotación de usuarios utilizando el método RFM</a></li>
<li><a href="../es431526/index.html">Influencia corrupta: cómo la Stasi defendió a Alemania Oriental de los videojuegos</a></li>
<li><a href="../es431528/index.html">Misterioso genio matemático y escritor promueven la solución del problema de la permutación</a></li>
<li><a href="../es431530/index.html">Lección abierta "Diseño de material Android: resumen de actualización"</a></li>
<li><a href="../es431532/index.html">Memorias que constan de piezas de 2 nm de espesor.</a></li>
<li><a href="../es431534/index.html">Identidades problemáticas entre desarrolladores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>