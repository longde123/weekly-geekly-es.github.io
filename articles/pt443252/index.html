<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëå üë®üèæ‚Äçüé§ üå∂Ô∏è Bots de formiga modulares com mem√≥ria üëô üçõ üèüÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um dos projetos que eu sempre sonhava em implementar eram os bots de tarefas modulares com mem√≥ria. O objetivo final do projeto era criar um mundo com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bots de formiga modulares com mem√≥ria</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443252/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/nt/w1/te/ntw1telvkd_gywv-7drpcook6ua.gif"></div><br>  Um dos projetos que eu sempre sonhava em implementar eram os bots de tarefas modulares com mem√≥ria.  O objetivo final do projeto era criar um mundo com criaturas capazes de agir de forma independente e coletiva. <br><br>  Eu costumava programar geradores mundiais, ent√£o queria preencher o mundo com bots simples que usam IA para determinar seu comportamento e intera√ß√µes.  Assim, gra√ßas √† influ√™ncia dos atores no mundo, foi poss√≠vel aumentar seus detalhes. <br><br>  Eu j√° implementei o sistema b√°sico de pipeline de tarefas Javascript (porque simplificou minha vida), mas queria algo mais confi√°vel e escal√°vel, por isso escrevi esse projeto em C ++.  A competi√ß√£o pela implementa√ß√£o do jardim processual na gera√ß√£o subreddit / r / procedural me levou a isso (da√≠ o t√≥pico correspondente). <br><br>  No meu sistema, a simula√ß√£o consiste em tr√™s componentes: o mundo, a popula√ß√£o e um conjunto de a√ß√µes que os conectam.  Portanto, eu precisava criar tr√™s modelos, os quais discutirei neste artigo. <br><br>  Para aumentar a dificuldade, eu queria que os atores mantivessem informa√ß√µes sobre experi√™ncias anteriores com o mundo e usassem o conhecimento sobre essas intera√ß√µes em a√ß√µes futuras. <br><a name="habracut"></a><br>  Ao criar um modelo do mundo, escolhi um caminho simples e usei o ru√≠do Perlin para coloc√°-lo na superf√≠cie da √°gua.  Todos os outros objetos no mundo foram localizados absolutamente aleatoriamente. <br><br>  Para o modelo de popula√ß√£o (e sua "mem√≥ria"), simplesmente criei uma classe com v√°rias caracter√≠sticas e coordenadas.  Era para ser uma simula√ß√£o de baixa resolu√ß√£o.  A mem√≥ria √© uma fila, os bots s√£o procurados, salvam informa√ß√µes sobre seu ambiente, gravam na fila e gerenciam essa fila como uma interpreta√ß√£o de sua mem√≥ria. <br><br>  Para conectar esses dois sistemas de a√ß√µes, eu queria criar uma estrutura de tarefas primitivas dentro de um sistema hier√°rquico de filas de tarefas, para que entidades individuais pudessem implementar um comportamento complexo no mundo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/571/a8c/77b/571a8c77bb291d6802fe9c87b8aa8986.png"></div><br>  <i>Mapa de exemplo.</i>  <i>A √°gua tomou a forma de um rio completamente sem inten√ß√£o.</i>  <i>Todos os outros elementos est√£o localizados aleatoriamente, incluindo o formigueiro, que nesta semente √© deslocado muito longe para a beira (mas o rio parece bonito).</i> <br><br>  Decidi que um monte de formigas nas folhas coletoras de grama se tornaria um bom modelo de teste que garante a confiabilidade da implementa√ß√£o de fun√ß√µes b√°sicas (e o sistema da fila de tarefas como um todo) e evita vazamentos de mem√≥ria (havia muitas). <br><br>  Quero descrever com mais detalhes a estrutura dos sistemas de tarefas e da mem√≥ria e tamb√©m mostrar como a complexidade foi criada a partir (principalmente) de fun√ß√µes b√°sicas primitivas.  Tamb√©m quero mostrar alguns "vazamentos de mem√≥ria de formigas" engra√ßados que voc√™ pode encontrar quando as formigas come√ßarem a correr loucamente em c√≠rculos em busca de grama ou ficarem paradas e tornarem o programa mais lento. <br><br><h3>  Estrutura geral </h3><br>  Eu escrevi essa simula√ß√£o em C ++ e usei o SDL2 para renderiza√ß√£o (eu j√° escrevi uma pequena classe de apresenta√ß√£o para o SLD2 antes).  Tamb√©m usei a implementa√ß√£o A * (ligeiramente modificada) que encontrei no github porque <em>minha implementa√ß√£o</em> era irremediavelmente lenta e n√£o conseguia entender o porqu√™. <br><br>  Um mapa √© apenas uma grade 100 √ó 100 com duas camadas - uma camada de solo (usada para procurar caminhos) e uma camada de preenchimento (para concluir caminhos de intera√ß√£o e pesquisa).  A classe mundial tamb√©m lida com v√°rias fun√ß√µes cosm√©ticas, como o crescimento de grama e vegeta√ß√£o.  Estou falando sobre isso agora, porque essas s√£o as √∫nicas partes que n√£o ser√£o descritas no artigo. <br><br><h2>  A popula√ß√£o </h2><br>  Bots estavam em uma classe com propriedades que descreviam uma √∫nica criatura.  Alguns deles eram cosm√©ticos, outros influenciaram a execu√ß√£o de a√ß√µes (por exemplo, a capacidade de voar, o alcance da vis√£o, o que come e o que a criatura pode usar). <br><br>  Os mais importantes aqui foram os valores auxiliares que determinam o comportamento.  Ou seja: um vetor contendo seu caminho atual A *, para que n√£o precise ser contado em cada ciclo do rel√≥gio (isso economiza tempo de computa√ß√£o e permite simular mais bots) e uma fila de mem√≥ria que define as criaturas que interpretam seu ambiente. <br><br><h3>  Fila de mem√≥ria </h3><br>  Uma fila de mem√≥ria √© uma fila simples que cont√©m um conjunto de objetos de mem√≥ria limitados em tamanho por uma propriedade bot.  Cada vez que novas mem√≥rias eram adicionadas, elas eram empurradas para a frente e tudo o que passava al√©m das fronteiras atr√°s era cortado.  Gra√ßas a isso, algumas lembran√ßas podem ser mais "frescas" do que outras. <br><br>  Se o bot queria recuperar informa√ß√µes da mem√≥ria, ele criou um objeto de mem√≥ria (pedido) e o comparou com o que estava na mem√≥ria.  Em seguida, a fun√ß√£o de rechamada retornou um vetor de mem√≥rias que correspondiam a algum ou a todos os crit√©rios especificados na consulta. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Memory</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Recall Score int recallScore = 1; //Memory Queryable? Array bool queryable[4] = {false, false, false, false}; //Memory Attributes std::string object; std::string task; Point location; bool reachable;</span></span></code> </pre> <br>  As mem√≥rias consistem em um objeto simples que cont√©m v√°rias propriedades.  Essas propriedades de mem√≥ria s√£o consideradas "associadas" uma √† outra.  Cada mem√≥ria tamb√©m recebe um valor de "recallScore", que √© iterado cada vez que as mem√≥rias s√£o lembradas pela fun√ß√£o de recall.  Cada vez que o bot se lembra das mem√≥rias, ele executa uma classifica√ß√£o de uma passagem, come√ßando por tr√°s, mudando a ordem das mem√≥rias se o recallScore de uma mem√≥ria antiga for maior que o de uma nova.  Gra√ßas a isso, algumas mem√≥rias podem ser mais "importantes" (com grandes tamanhos de mem√≥ria) e armazenadas por mais tempo na fila.  Com o tempo, eles ser√£o substitu√≠dos por novos. <br><br><h3>  Filas de mem√≥ria </h3><br>  Tamb√©m adicionei v√°rios operadores sobrecarregados a essa classe para que compara√ß√µes diretas entre a fila de mem√≥ria e a consulta possam ser executadas, comparando as propriedades "any" ou "all", para que somente as propriedades especificadas sejam substitu√≠das quando a mem√≥ria for substitu√≠da.  Gra√ßas a isso, podemos ter a mem√≥ria do objeto associada a algum lugar, mas se olharmos novamente para esse local e o objeto n√£o estiver l√°, podemos atualizar a mem√≥ria substituindo-a pela mem√≥ria que cont√©m um novo bloco de preenchimento, usando a consulta correspondente a esse local . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Bot::updateMemory(Memory &amp;query, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> all, Memory &amp;memory){ <span class="hljs-comment"><span class="hljs-comment">//Loop through all existing Memories //"memories" queue is a member of Bot for(unsigned int i = 0; i &lt; memories.size(); i++){ //If all matches are required and we have all matches if(all &amp;&amp; (memories[i] == query)){ //We have a memory that needs to be updated memories[i] = memory; continue; } //If not all matches are required and any query elements are contained else if(!all &amp;&amp; (memories[i] || query)){ //When overwriting, only overwrite specified quantities memories[i] = memory; continue; } } }</span></span></code> </pre> <br>  No processo de cria√ß√£o do c√≥digo para esse sistema, aprendi muito. <br><br><h2>  Sistema de tarefas </h2><br>  A natureza do loop ou da renderiza√ß√£o do jogo √© que as mesmas fun√ß√µes s√£o repetidas em todas as medidas; no entanto, eu queria implementar um comportamento n√£o c√≠clico nos meus bots. <br><br>  Nesta se√ß√£o, explicarei duas vis√µes sobre a estrutura do sistema de tarefas projetado para combater esse efeito. <br><br><h3>  Estrutura de baixo para cima </h3><br>  Decidi passar de baixo para cima e criar um conjunto de "a√ß√µes primitivas" que os bots devem executar.  Cada uma dessas a√ß√µes dura apenas uma batida.  Com uma boa biblioteca de fun√ß√µes primitivas, podemos combin√°-las em a√ß√µes complexas que consistem em v√°rias primitivas. <br><br>  Exemplos de tais a√ß√µes primitivas: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Primitives bool wait(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool look(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool step(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool swap(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool store(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool consume(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool move(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); //Continue with secondaries here...</span></span></code> </pre> <br>  Observe que essas a√ß√µes cont√™m refer√™ncias ao mundo e √† popula√ß√£o, permitindo que voc√™ as altere. <br><br><ul><li>  A espera faz com que a criatura n√£o fa√ßa nada nesse loop. </li><li>  O Look analisa o ambiente e enfileira novas mem√≥rias. </li><li>  O swap pega um objeto na m√£o da criatura e o substitui por um deitado no ch√£o. </li><li>  Consumir destr√≥i o item na m√£o da criatura. </li><li>  Etapa leva o caminho calculado atual para o destino e executa uma etapa (com v√°rias verifica√ß√µes de erro). </li><li>  ... e assim por diante. </li></ul><br>  Todas as fun√ß√µes de tarefas s√£o membros da minha classe de tarefas;  ap√≥s testes rigorosos, eles comprovaram sua confiabilidade e capacidade de combinar tarefas mais complexas. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Secondaries bool walk(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool idle(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool search(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool forage(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool take(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); //Species Masters bool Ant(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); bool Bee(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]); };</span></span></code> </pre> <br>  Nessas fun√ß√µes secund√°rias, constru√≠mos fun√ß√µes simplesmente encadeando outras tarefas: <br><br><ul><li>  A tarefa de caminhada √© apenas algumas etapas (com tratamento de erros) </li><li>  A tarefa take √© a tarefa look and swap (√© necess√°ria devido ao processamento da mem√≥ria ant, que explicarei mais adiante) </li><li>  A tarefa inativa √© selecionar um local aleat√≥rio e mudar para l√° (usando caminhada), aguardar v√°rios ciclos (usando espera) e repetir esse ciclo por um determinado n√∫mero de vezes </li><li>  ... e assim por diante </li></ul><br>  Outras tarefas s√£o mais complicadas.  A tarefa de pesquisa executa uma consulta de mem√≥ria para procurar por mem√≥rias de locais que cont√™m o objeto "comida" (comest√≠vel para esse tipo de bot).  Ela baixa essas mem√≥rias e percorre todas elas, ‚Äúprocurando‚Äù comida (no caso das formigas, isso √© grama).  Se n√£o houver lembran√ßas alimentares, a tarefa faz a criatura vagar aleatoriamente pelo mundo e olhar em volta.  Observando e estudando (fazendo um "olhar" com viewRadius = 1; isto √©, olhando apenas para o ladrilho embaixo), a criatura pode atualizar sua mem√≥ria com informa√ß√µes sobre seus arredores, procurando comida de maneira inteligente e intencional. <br><br>  Uma tarefa forrageira mais generalizada consiste em encontrar comida, pegar comida, inspecionar (para atualizar a mem√≥ria e encontrar comida na vizinhan√ßa), voltar para casa e armazenar comida. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c90/df8/2d8/c90df82d8de8bcf8a9d0de594d2c2e89.gif"></div><br>  <i>Voc√™ pode notar que as formigas saem do formigueiro e procuram comida de prop√≥sito.</i>  <i>Devido √† inicializa√ß√£o, o caminho inicial das formigas √© direcionado para um ponto aleat√≥rio, porque sua mem√≥ria em t = 0 est√° vazia.</i>  <i>Eles recebem a ordem de pegar comida na tarefa de forragem e tamb√©m olham em volta, certificando-se de que n√£o h√° mais comida.</i>  <i>De tempos em tempos, come√ßam a perambular, porque ficam sem lugares onde viram comida (falta de vis√£o amea√ßadora).</i> <br><br>  E, finalmente, o bot tem uma "vis√£o" que determina o tipo de IA atribu√≠do a ele.  Cada visualiza√ß√£o √© associada a uma tarefa de controle que define todo o seu comportamento: consiste em uma cascata de tarefas cada vez menores, facilmente determinadas por um conjunto de filas de mem√≥ria e tarefas primitivas.  Estas s√£o tarefas como Ant e Bee. <br><br><h3>  Estrutura de cima para baixo </h3><br>  Se voc√™ olhar de cima para baixo, o sistema consiste em uma classe de mestre de tarefas que coordena as tarefas de controle e sua execu√ß√£o para cada bot individual no mapa. <br><br>  O Taskmaster possui um vetor de tarefas de controle, cada uma delas associada a um bot.  Cada tarefa de controle, por sua vez, possui uma fila de subtarefas carregadas durante a primeira inicializa√ß√£o do objeto de tarefa com a fun√ß√£o de tarefa associada. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Members std::stack&lt;Task&gt; queue; bool initFlag = true; int args[10]; bool (Task::*handle)(Garden&amp;, Population&amp;, int (&amp;)[10]); int botID; std::string name; //Constructor Task(std::string taskName, int taskBotID, bool (Task::*taskHandle)(Garden&amp;, Population&amp;, int (&amp;)[10])){ name = taskName; botID = taskBotID; handle = taskHandle; } //Launch a Task bool perform(Garden &amp;garden, Population &amp;population); //Continue with primitives here...</span></span></code> </pre> <br>  Cada objeto de tarefa na fila armazena uma matriz de argumentos, que s√£o transmitidos ao manipulador de fun√ß√µes associado.  Esses argumentos determinam o comportamento dessas tarefas primitivas criadas da maneira mais geral poss√≠vel.  Os argumentos s√£o passados ‚Äã‚Äãpor refer√™ncia, para que o objeto de tarefa na fila possa armazenar seus argumentos e permitir que suas subfun√ß√µes sejam alteradas, para que voc√™ possa implementar coisas como itera√ß√µes para aguardar um certo n√∫mero de ticks ou solicita√ß√µes para coletar um certo n√∫mero de itens, etc.  As subfun√ß√µes alteram o valor do iterador (argumento [n]) da fun√ß√£o pai por refer√™ncia e tornam sua condi√ß√£o de sucesso dependente de seu valor. <br><br>  Em cada medida, o mestre de tarefas percorre a lista de tarefas de controle e as executa chamando seu m√©todo de execu√ß√£o.  O m√©todo perform, por sua vez, examina o elemento superior da fila dentro da tarefa e o executa com os argumentos da tarefa.  Assim, voc√™ pode cascatear a fila de tarefas, sempre executando a tarefa mais alta.  Em seguida, o valor de retorno da tarefa determina a conclus√£o da tarefa. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Execute Task Function bool Task::perform(Garden &amp;garden, Population &amp;population){ //Debug Message if(debug){std::cout&lt;&lt;"Bot with ID: "&lt;&lt;botID&lt;&lt;" performing task: "&lt;&lt;name&lt;&lt;std::endl;} //Change the Name and Execute the Task population.bots[botID].task = name; return (*this.*handle)(garden, population, args); }</span></span></code> </pre> <br>  Quando uma tarefa primitiva retorna true, ela atingiu seu ponto est√°vel, ou pelo menos n√£o deve ser repetida (por exemplo, step retorna true quando a criatura atinge o ponto final).  Ou seja, sua condi√ß√£o de retorno √© satisfeita e √© removida da fila para que a pr√≥xima tarefa possa ser conclu√≠da na pr√≥xima medida. <br><br>  Uma tarefa que cont√©m uma fila de tarefas retorna true ap√≥s a fila estar vazia.  Gra√ßas a isso, √© poss√≠vel criar tarefas complexas com a estrutura de filas e sub-filas nas quais as mesmas fun√ß√µes s√£o chamadas constantemente, mas cada chamada itera o estado do jogo e o estado da tarefa em uma etapa. <br><br>  Finalmente, as tarefas de controle usam uma estrutura simples - elas s√£o chamadas em cada ciclo, carregam a tarefa apenas se estiverem vazias e, de outra forma, executam tarefas carregadas em sua fila. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Species Functions bool Task::Ant(Garden &amp;garden, Population &amp;population, int (&amp;arguments)[10]){ //Initial Condition if(initFlag){ Task forage("Search for Food", botID, &amp;Task::forage); forage.args[0] = population.bots[botID].forage; //What are we looking for? queue.push(forage); initFlag = false; } //Queue Loop if(!queue.empty()){ //Get the Top Task Task newtask = queue.top(); queue.pop(); //If our new Task is not performed successfully if(!newtask.perform(garden, population)){ queue.push(newtask); return false; } //If it was successful, we leave it off return false; } //Return Case for Mastertask initFlag = true; return false; }</span></span></code> </pre> <br>  Com a ajuda do meu loop de fila (consulte o c√≥digo), posso executar repetidamente uma fun√ß√£o e cada vez que executar o elemento superior em sua fila, retirando elementos dela se chamar o m√©todo perform retornar true. <br><br><h2>  Resultados </h2><br>  Tudo isso est√° envolvido no libconfig, portanto os par√¢metros de simula√ß√£o s√£o muito f√°ceis de mudar.  Voc√™ pode codificar muitas tarefas de controle sem problemas (criei formigas e abelhas), e definir e carregar novas esp√©cies usando libconfig √© surpreendentemente simples. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Anthill General Configuration File debug = true; //World Generation Parameters seed = 15; water = true; //Species that the simulation recognizes Species: { //Ant Species Ant: { masterTask = "Ant"; color = (0, 0, 0); viewDistance = 2; memorySize = 5; forage = 2; trail = true; fly = false; } Bee: { masterTask = "Bee"; color = (240, 210, 30); viewDistance = 4; memorySize = 30; forage = 4; trail = false; fly = true; } Worm: { masterTask = "Bee"; color = (255, 154, 171); viewDistance = 1; memorySize = 5; forage = 3; trail = true; fly = false; } } Population: ( {species = "Ant"; number = 40;}//, //{species = "Bee"; number = 12;}, //{species = "Worm"; number = 5;} )</span></span></code> </pre> <br>  Eles foram elegantemente carregados na simula√ß√£o.  Gra√ßas a uma nova pesquisa aprimorada de caminhos, posso simular um grande n√∫mero de bots ativos individuais coletando alimentos em um plano bidimensional. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c30/991/682/c309916821a8538a0dd92db88caf6b6b.gif"></div><br>  <i>Simula√ß√£o de 40 formigas coletando grama ao mesmo tempo.</i>  <i>Os caminhos que eles criam na areia se devem ao aumento do peso atribu√≠do √† terra "intocada".</i>  <i>Isso leva √† cria√ß√£o de "estradas de formigas" caracter√≠sticas.</i>  <i>Eles tamb√©m podem ser interpretados como ferom√¥nios, mas seria mais parecido com a verdade se as formigas realmente trocassem mem√≥rias.</i> <br><br>  A modularidade desse sistema garante a r√°pida cria√ß√£o de novas esp√©cies cujo comportamento √© determinado por uma simples tarefa de controle.  No c√≥digo acima, voc√™ pode ver que eu criei worms e abelhas de IA simplesmente mudando de cor, restri√ß√µes de pesquisa de caminho (elas n√£o podem voar), alcance de visibilidade e tamanho da mem√≥ria.  Ao mesmo tempo, mudei seu comportamento geral, porque todos esses par√¢metros s√£o usados ‚Äã‚Äãpor fun√ß√µes de tarefas primitivas. <br><br><h3>  Depurando mem√≥rias Ant </h3><br>  A estrutura de tarefas e mem√≥ria complexas levou a dificuldades imprevistas e √† necessidade de lidar com exce√ß√µes. <br><br>  Aqui est√£o tr√™s erros de mem√≥ria particularmente complexos que me fizeram refazer os subsistemas: <br><br><h4>  Formigas correndo em c√≠rculo </h4><br>  Um dos primeiros insetos que tive que enfrentar: formigas corriam loucamente pelo padr√£o fechado na pra√ßa em busca de grama no ch√£o nu.  Esse problema surgiu porque naquela √©poca eu ainda n√£o havia implementado uma atualiza√ß√£o de mem√≥ria.  As formigas tinham lembran√ßas da localiza√ß√£o da comida e, assim que pegaram a grama e olharam em volta novamente, novas lembran√ßas se formaram. <br><br>  O problema era que a nova mem√≥ria estava no mesmo ponto, mas a antiga foi preservada.  Isso significava que, no processo de busca de alimentos, as formigas se lembravam e mantinham a localiza√ß√£o dos alimentos que n√£o eram mais v√°lidos, mas essas mem√≥rias antigas eram preservadas e substitu√≠am novas (elas se lembravam dessa deliciosa erva). <br><br>  Corrigi-o da seguinte forma: os dados do objeto s√£o simplesmente substitu√≠dos em mem√≥rias antigas, se virmos o mesmo lugar e o objeto mudar (por exemplo, a criatura v√™ que n√£o h√° mais grama ali, mas n√£o se lembra que costumava haver grama).  Talvez, no futuro, apenas adicione a propriedade "inv√°lida" √†s minhas mem√≥rias, para que os rob√¥s possam lembrar informa√ß√µes antigas que possam ser importantes, mas as informa√ß√µes que n√£o s√£o mais v√°lidas "apareceram" ("vi um urso aqui, mas agora n√£o est√° l√°"). <br><br><h4>  Formigas pegam objetos sob outras formigas </h4><br>  De tempos em tempos (especialmente com um grande n√∫mero de formigas e uma alta densidade de grama), duas formigas podem pegar um peda√ßo de grama de uma s√≥ vez e tentar peg√°-lo.  Isso significava que a primeira formiga entrou no ladrilho, olhou em volta e pegou o item em 3 etapas.  Por sua vez, a segunda formiga fez o mesmo, apenas logo antes de levantar o objeto, outra formiga o pegou debaixo do nariz.  Ele calmamente continuou suas tarefas, examinando o mesmo ambiente que a outra formiga na medida anterior, e processou sua linha de mem√≥ria da mesma maneira (porque nesse est√°gio suas mem√≥rias s√£o id√™nticas).  Isso levou a segunda formiga a copiar a primeira, nunca pegando objetos e seguindo a primeira, o que realmente fez todo o trabalho.  Percebi isso porque, na simula√ß√£o das cinco formigas, apenas tr√™s eram vis√≠veis.  Demorou muito tempo para encontrar a causa. <br><br>  Resolvi esse problema, tornando a tarefa de troca primitiva e criando a tarefa take, que primeiro olha para o ch√£o para ver se h√° um objeto l√°.  Se for, "troca" e, se n√£o, "espera" por dois movimentos, para que a outra formiga saia definitivamente.  Em um caso, essa a√ß√£o √© para duas medidas, no outro - para uma medida. <br><br><h4>  Locais inacess√≠veis </h4><br>  Outro bug desagrad√°vel que me for√ßou a refazer o processamento da mem√≥ria foi que alguns lugares que a formiga podia ver eram inating√≠veis para ele.  Eles surgiram por causa da minha pregui√ßosa coloca√ß√£o de "grama cruzada" em terra, que √†s vezes pairava sobre a √°gua.  Isso me fez generalizar a tarefa da etapa. <br><br>  Ao transmitir um pedido de busca de alimentos, as formigas geralmente tinham lembran√ßas de lugares que realmente n√£o podiam alcan√ßar (viam grama acima da √°gua e <em>insanamente</em> desejavam recolh√™-la).  Se n√£o estava marcado em sua mem√≥ria (por exemplo, a vari√°vel booleana ‚Äúalcan√ß√°vel‚Äù), eles continuaram lembrando e gravando na fila at√© que essa a√ß√£o fosse a √∫nica.  Isso causou uma inibi√ß√£o severa, porque eles <em>executavam constantemente opera√ß√µes de localiza√ß√£o de caminhos em cada medida, tentando chegar l√° e falhavam</em> . <br><br>  A solu√ß√£o foi atualizar a mem√≥ria na tarefa da etapa se ela n√£o conseguir encontrar o caminho para o local, marcando-a na mem√≥ria como inating√≠vel.  Al√©m disso, a tarefa de pesquisa consulta apenas locais com comida em busca de mem√≥rias alcan√ß√°veis. <br><br><h2>  Sistema em geral </h2><br>  Em geral, quero dizer - sim, me arrependo de ter passado uma semana da minha vida em uma maratona de programa√ß√£o porque fui inspirado a criar bots que fazem o que lhes digo (e tamb√©m o que eles querem fazer!).  Eu tive que fazer alguns truques e aprendi muito. <br><br>  O sistema que criei n√£o √© 100% confi√°vel e ainda percebo alguns artefatos.  Por exemplo, como a dire√ß√£o para analisar a apar√™ncia, a a√ß√£o √© usada de cima para baixo e esquerda-direita, ou seja, a √∫ltima mem√≥ria est√° no canto inferior direito.  Ao recuperar informa√ß√µes para procurar itens, isso significa que as criaturas tender√£o a se mover para sudeste.  Isso √© especialmente not√°vel em grandes simula√ß√µes, quando a grama cresce rapidamente e se inclina levemente em dire√ß√£o ao sudeste, independentemente da semente. <br><br><h3>  Aprimoramentos </h3><br>  Penso que s√£o necess√°rias melhorias significativas para simular mem√≥rias mais complexas de criaturas mais complexas. <br><br>  Isso inclui aumentar a confiabilidade das fun√ß√µes de processamento de mem√≥ria, al√©m de adicionar novas primitivas, como "pensar" e derivados de tarefas de alto n√≠vel, como "decidir" ou "sonhar".  "Pensar" pode ser uma a√ß√£o primitiva de uma solicita√ß√£o de mem√≥ria.  Um "sonho", por sua vez, pode consistir em v√°rias chamadas de "pensar": escolher uma mem√≥ria aleat√≥ria, obter uma propriedade aleat√≥ria e repeti-la repetidamente para refor√ßar temas comuns ou associa√ß√µes importantes. <br><br>  Para o futuro, planejo tr√™s adi√ß√µes espec√≠ficas: <br><br><ul><li>  Adicione manipula√ß√£o de interrup√ß√£o e prioriza√ß√£o de tarefas </li><li>  Adicionar comunica√ß√£o entre entidades </li><li>  Adicione uma estrutura de grupo para que as entidades possam se identificar formalmente </li></ul><br>  A interrup√ß√£o do processamento e a prioriza√ß√£o de tarefas podem ser necess√°rias para a intera√ß√£o entre entidades, porque o bot n√£o pode continuar cegamente suas atividades quando se comunica com ele (deve de alguma forma "ouvir") ou √© atacado ("foge" ou "luta" ) <br><br>  A comunica√ß√£o entre entidades provavelmente consiste em uma ou duas tarefas primitivas para trocar mem√≥rias ou fazer solicita√ß√µes √†s mem√≥rias de outros bots (por exemplo, "diga" ou "pergunte").  Dessa forma, informa√ß√µes como a localiza√ß√£o de alimentos ou outros recursos podem ser transmitidas. <br><br>  Espero implementar essas tarefas e elaborar um gr√°fico da taxa de acumula√ß√£o de recursos por um grande grupo com e sem comunica√ß√£o.  A popula√ß√£o j√° est√° acompanhando a quantidade de alimentos coletados em cada medida.  Seria interessante mostrar que compartilhar mem√≥rias pode afetar a efici√™ncia. <br><br><h3>  O futuro </h3><br>  A fun√ß√£o mais importante para simular comunidades ser√° adicionar estruturas de grupo e dotar esses grupos de propriedades em n√≠vel macro, por exemplo, seus ‚Äúobjetivos e responsabilidades‚Äù comuns.  Isso nos d√° um tipo de "semente" a partir da qual podemos obter tarefas de alto n√≠vel delegadas na hierarquia das estruturas de grupos para "tarefas inferiores de alto n√≠vel" que afetam diretamente o mundo.  Tamb√©m permite criar uma forma de estrutura pol√≠tica. <br><br>  Esse sistema √© bastante auto-suficiente e a visualiza√ß√£o √© simplesmente sobreposta a ele.  Ser√° muito simples substituir insetos por human√≥ides, coletando recursos e armazenando-os em algum lugar, para que cres√ßam em tamanho.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A natureza do crescimento de sua casa pode, por exemplo, ser muito dependente ou completamente independente das a√ß√µes dos bots. </font><font style="vertical-align: inherit;">Diferentes esp√©cies podem ter tribos diferentes, com caracter√≠sticas e tend√™ncias diferentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, eu posso combinar esse sistema com geradores de mapas criados anteriormente (expandindo a classe mundial) para tornar o mundo mais real.</font></font><br><br><h2>  Em conclus√£o </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No futuro pr√≥ximo, pretendo substituir as criaturas por pessoas e implementar algumas das √∫ltimas fun√ß√µes. </font><font style="vertical-align: inherit;">Talvez eu publique o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√≥digo fonte completo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quando melhorar a qualidade do sistema (em alguns lugares, o c√≥digo √© bastante ca√≥tico). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aguarde o pr√≥ximo artigo. </font><font style="vertical-align: inherit;">Enquanto isso, aqui est√° um v√≠deo com abelhas procurando p√≥len em flores; </font><font style="vertical-align: inherit;">eles s√£o codificados usando a mesma estrutura.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/332/b31/7d5/332b317d547edc53f2b2ffee6c3d4861.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu escolhi essa semente porque o ponto de partida est√° localizado em uma pequena ilha. </font><font style="vertical-align: inherit;">No entanto, as abelhas n√£o s√£o programadas para retornar √† colm√©ia, mas simplesmente coletam constantemente o p√≥len. </font><font style="vertical-align: inherit;">Voc√™ pode perceber que a vis√£o deles √© maior e, √†s vezes, eles intencionalmente se movem para a flor que acabaram de ver. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... e aqui est√° a fun√ß√£o do membro Bee Task:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Task::Bee(Garden &amp;garden, Population &amp;population, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (&amp;arguments)[<span class="hljs-number"><span class="hljs-number">10</span></span>]){ <span class="hljs-comment"><span class="hljs-comment">//Just Search for Flowers if(initFlag){ //Define our Tasks Task take("Take Food", botID, &amp;Task::take); Task eat("Eat Food", botID, &amp;Task::consume); Task search("Locate Food", botID, &amp;Task::search); search.args[0] = population.bots[botID].forage; queue.push(eat); queue.push(take); queue.push(search); initFlag = false; } //Work off our allocated queue. if(!queue.empty()){ //Get the Top Task Task newtask = queue.top(); queue.pop(); //If our new Task is not performed successfully if(!newtask.perform(garden, population)){ //Put the Task back on queue.push(newtask); } //If it was successful, we leave it off return false; } initFlag = true; return true; }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443252/">https://habr.com/ru/post/pt443252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443240/index.html">Entendendo o Q-learning, o problema ‚ÄúAndar sobre uma pedra‚Äù</a></li>
<li><a href="../pt443242/index.html">Quarkus √© um Java subat√¥mico supers√¥nico. Uma breve vis√£o geral da estrutura</a></li>
<li><a href="../pt443244/index.html">Tarefas de revis√£o. Beanpoisk_1</a></li>
<li><a href="../pt443246/index.html">Como reinventamos o Askozia IP PBX depois que o projeto foi vendido e fechado pelo desenvolvedor</a></li>
<li><a href="../pt443250/index.html">Coletor de Lixo Caseiro para OpenJDK</a></li>
<li><a href="../pt443254/index.html">Triton √© o v√≠rus mais mortal</a></li>
<li><a href="../pt443256/index.html">PowerShell, despejo da minha experi√™ncia</a></li>
<li><a href="../pt443258/index.html">Gotify - um projeto de c√≥digo aberto para entrega de notifica√ß√µes e envio de mensagens ao servidor</a></li>
<li><a href="../pt443260/index.html">Migrar para Zimbra sem arriscar neg√≥cios com um dom√≠nio comum</a></li>
<li><a href="../pt443262/index.html">Mau conselho: como escrever documenta√ß√£o t√©cnica? Parte Tr√™s e √öltima</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>