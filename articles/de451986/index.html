<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍 👨🏿‍🎨 👩🏽 Das Abrufen von Daten mit ORM ist einfach! Oder nicht? 👨‍💼 😒 👂🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 


 Fast jedes Informationssystem interagiert auf die eine oder andere Weise mit externen Datenspeichern. In den meisten Fällen handelt es ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Abrufen von Daten mit ORM ist einfach! Oder nicht?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/451986/"><p><img src="https://habrastorage.org/webt/uv/4h/wb/uv4hwblmcfkf-f6018hxpbkf1s8.jpeg"></p><br><h2 id="vvedenie">  Einführung </h2><br><p>  Fast jedes Informationssystem interagiert auf die eine oder andere Weise mit externen Datenspeichern.  In den meisten Fällen handelt es sich um eine relationale Datenbank, und häufig wird eine Art ORM-Framework verwendet, um mit Daten zu arbeiten.  ORM eliminiert die meisten Routineoperationen und bietet stattdessen einen kleinen Satz zusätzlicher Abstraktionen für die Arbeit mit Daten. </p><br><p>  Martin Fowler veröffentlichte einen interessanten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> , einer der wichtigsten Gedanken dort: „ORMs helfen uns, eine große Anzahl von Problemen in Unternehmensanwendungen zu lösen ... Dieses Tool kann nicht als hübsch bezeichnet werden, aber die Probleme, mit denen es sich befasst, sind auch nicht gut.  Ich denke, ORM verdient mehr Respekt und Verständnis. “ </p><br><p>  Wir setzen ORM sehr intensiv im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CUBA-</a> Framework ein, daher kennen wir die Probleme und Einschränkungen dieser Technologie aus erster Hand, da CUBA in verschiedenen Projekten auf der ganzen Welt eingesetzt wird.  Es gibt viele Themen, die in Bezug auf ORM diskutiert werden können, aber wir werden uns auf eines davon konzentrieren: die Wahl zwischen den „faulen“ (faulen) und den „gierigen“ (eifrigen) Methoden der Datenerfassung.  Wir werden anhand von Abbildungen aus der JPA-API und Spring über verschiedene Lösungsansätze für dieses Problem sprechen und auch beschreiben, wie (und warum genau) ORM in CUBA verwendet wird und welche Arbeit wir tun, um die Arbeit mit Daten in unserem Framework zu verbessern. </p><a name="habracut"></a><br><h2 id="vyborka-dannyh-lenivaya-ili-net">  Datenerfassung: faul oder nicht? </h2><br><p> Wenn Ihr Datenmodell nur eine Entität hat, werden Sie bei der Arbeit mit ORM höchstwahrscheinlich keine Probleme bemerken.  Schauen wir uns ein kleines Beispiel an.  Angenommen, wir haben eine <code>User ()</code> mit zwei Attributen: <code>ID</code> und <code>Name ()</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  Um eine Instanz dieser Entität aus der Datenbank abzurufen, müssen Sie nur eine Methode des <code>EntityManager</code> Objekts aufrufen: </p><br><pre> <code class="java hljs">EntityManager em = entityManagerFactory.createEntityManager(); User user = em.find(User.class, id);</code> </pre> <br><p>  Etwas interessanter wird es, wenn eine Eins-zu-Viele-Beziehung entsteht: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@OneToMany</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Address&gt; addresses; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  Wenn wir eine Benutzerinstanz aus der Datenbank extrahieren müssen, stellt sich die Frage: "Wählen wir auch Adressen aus?".  Und die "richtige" Antwort lautet hier: "Kommt auf ... an" In einigen Fällen benötigen wir Adressen, in anderen - nicht.  In der Regel bietet ORM zwei Möglichkeiten zum Abrufen abhängiger Datensätze: faul und gierig.  Standardmäßig verwenden die meisten ORMs den faulen Weg.  Aber wenn wir diesen Code schreiben: </p><br><pre> <code class="java hljs">EntityManager em = entityManagerFactory.createEntityManager(); User user = em.find(User.class, <span class="hljs-number"><span class="hljs-number">1</span></span>); em.close(); System.out.println(user.getAddresses().get(<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre> <br><p>  ... dann bekommen wir die Ausnahme <code>“LazyInitException”</code> , die Neulinge, die gerade mit ORM angefangen haben, schrecklich verwirrt.  Und hier kommt der Moment, in dem Sie eine Geschichte darüber beginnen müssen, was "angehängte" und "getrennte" Instanzen einer Entität sind, was Sitzungen und Transaktionen sind. <br>  Ja, das bedeutet, dass die Entität an die Sitzung „angehängt“ werden muss, damit Sie die abhängigen Daten auswählen können.  Lassen Sie uns Transaktionen nicht sofort abschließen, und das Leben wird sofort einfacher.  Und hier tritt ein weiteres Problem auf: Transaktionen werden länger, was das Risiko eines Deadlocks erhöht.  Transaktionen kürzer machen?  Es ist möglich, aber wenn Sie viele, viele kleine Transaktionen erstellen, erhalten wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Geschichte von Komar Komarovich - eine lange Nase und eine pelzige Mischa - einen kurzen Schwanz“</a> darüber, wie die Horde winziger Bärenmücken gewonnen hat - es wird mit der Datenbank geschehen.  Wenn die Anzahl kleiner Transaktionen erheblich zunimmt, treten Leistungsprobleme auf. <br>  Wie bereits erwähnt, sind beim Abrufen von Daten über einen Benutzer möglicherweise Adressen erforderlich oder nicht. Abhängig von der Geschäftslogik müssen Sie daher entweder die Sammlung auswählen oder nicht.  Es ist notwendig, dem Code neue Bedingungen hinzuzufügen ... Hmmm ... Etwas wird irgendwie kompliziert. </p><br><p>  Was ist, wenn Sie eine andere Art von Probe ausprobieren? </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@OneToMany</span></span>(fetch = FetchType.EAGER) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Address&gt; addresses; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  Nun ... man kann nicht sagen, dass es viel helfen wird.  Ja, wir werden das verhasste <code>LazyInit</code> und es besteht keine Notwendigkeit zu überprüfen, ob die Entität an die Sitzung angehängt ist oder nicht.  Jetzt können jedoch Leistungsprobleme auftreten, da wir nicht immer Adressen benötigen, diese Objekte jedoch im Speicher des Servers auswählen. <br>  Noch mehr Ideen? </p><br><h2 id="spring-jdbc">  Frühling jdbc </h2><br><p>  Einige Entwickler haben ORM so satt, dass sie zu alternativen Frameworks wechseln.  Zum Beispiel in Spring JDBC, das die Möglichkeit bietet, relationale Daten im "halbautomatischen" Modus in Objektdaten zu konvertieren.  Der Entwickler schreibt Abfragen für jeden Fall, in dem ein bestimmter Satz von Attributen benötigt wird (oder derselbe Code wird für Fälle wiederverwendet, in denen dieselben Datenstrukturen benötigt werden). </p><br><p>  Dies gibt uns große Flexibilität.  Sie können beispielsweise nur ein Attribut auswählen, ohne das entsprechende Entitätsobjekt zu erstellen: </p><br><pre> <code class="java hljs">String name = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jdbcTemplate.queryForObject( <span class="hljs-string"><span class="hljs-string">"select name from t_user where id = ?"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[]{<span class="hljs-number"><span class="hljs-number">1L</span></span>}, String.class);</code> </pre> <br><p>  Oder wählen Sie ein Objekt in der üblichen Form aus: </p><br><pre> <code class="java hljs">User user = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jdbcTemplate.queryForObject( <span class="hljs-string"><span class="hljs-string">"select id, name from t_user where id = ?"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[]{<span class="hljs-number"><span class="hljs-number">1L</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RowMapper&lt;User&gt;() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapRow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ResultSet rs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rowNum)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SQLException </span></span>{ User user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(); user.setName(rs.getString(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)); user.setId(rs.getInt(<span class="hljs-string"><span class="hljs-string">"id"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user; } });</code> </pre> <br><p>  Sie können auch eine Liste mit Adressen für den Benutzer auswählen. Sie müssen lediglich etwas mehr Code schreiben und die SQL-Abfrage korrekt erstellen, um das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Problem von n + 1-Abfragen</a> zu vermeiden. </p><br><p>  Soooo, wieder kompliziert.  Ja, wir steuern alle Abfragen und wie die Daten auf Objekte abgebildet werden, aber wir müssen mehr Code schreiben, SQL lernen und wissen, wie die Abfragen in der Datenbank ausgeführt werden.  Persönlich denke ich, dass SQL-Kenntnisse eine erforderliche Fähigkeit für einen Anwendungsprogrammierer sind, aber nicht jeder denkt so, und ich werde mich nicht auf Polemik einlassen.  Schließlich ist die Kenntnis der x86-Montageanleitung heutzutage auch optional.  Lassen Sie uns besser darüber nachdenken, wie wir Programmierern das Leben erleichtern können. </p><br><h2 id="jpa-entitygraph">  JPA EntityGraph </h2><br><p>  Und lassen Sie uns einen Schritt zurücktreten und überlegen, was wir brauchen.  Es scheint, dass wir nur genau angeben müssen, welche Attribute wir jeweils benötigen.  Nun, lass es uns tun!  JPA 2.1 führte eine neue API ein - EntityGraph (Entity Graph).  Die Idee ist sehr einfach: Wir verwenden Anmerkungen, um zu beschreiben, was wir aus der Datenbank auswählen werden.  Hier ist ein Beispiel: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraphs</span></span>({ <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraph</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user-only-entity-graph"</span></span>), <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraph</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user-addresses-entity-graph"</span></span>, attributeNodes = {<span class="hljs-meta"><span class="hljs-meta">@NamedAttributeNode</span></span>(<span class="hljs-string"><span class="hljs-string">"addresses"</span></span>)}) }) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@OneToMany</span></span>(fetch = FetchType.LAZY) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Set&lt;Address&gt; addresses; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  Für diese Entität werden zwei Diagramme beschrieben: Das <code>user-only-entity-graph</code> wählt das <code>Addresses</code> (als faul markiert) nicht aus, während das zweite Diagramm ORM anweist, dieses Attribut auszuwählen.  Wenn wir <code>Addresses</code> als eifrig markieren, wird das Diagramm ignoriert und Adressen werden trotzdem ausgewählt. </p><br><p>  In JPA 2.1 können Sie also Daten wie folgt testen: </p><br><pre> <code class="java hljs">EntityManager em = entityManagerFactory.createEntityManager(); EntityGraph graph = em.getEntityGraph(<span class="hljs-string"><span class="hljs-string">"user-addresses-entity-graph"</span></span>); Map&lt;String, Object&gt; properties = Map.of(<span class="hljs-string"><span class="hljs-string">"javax.persistence.fetchgraph"</span></span>, graph); User user = em.find(User.class, <span class="hljs-number"><span class="hljs-number">1</span></span>, properties); em.close();</code> </pre> <br><p>  Dieser Ansatz vereinfacht die Arbeit erheblich, Sie müssen nicht separat über faule Attribute und die Transaktionslänge nachdenken.  Ein zusätzlicher Bonus ist, dass das Diagramm auf der Ebene der SQL-Abfrage angewendet wird, sodass in der Java-Anwendung keine „zusätzlichen“ Daten ausgewählt werden.  Es gibt jedoch ein kleines Problem: Sie können nicht sagen, welche Attribute ausgewählt wurden und welche nicht.  Es gibt eine API zur Überprüfung. Dies erfolgt mithilfe der <code>PersistenceUtil</code> Klasse: </p><br><pre> <code class="java hljs">PersistenceUtil pu = entityManagerFactory.getPersistenceUnitUtil(); System.out.println(<span class="hljs-string"><span class="hljs-string">"User.addresses loaded: "</span></span> + pu.isLoaded(user, <span class="hljs-string"><span class="hljs-string">"addresses"</span></span>));</code> </pre> <br><p>  Aber das ist ziemlich langweilig und nicht jeder ist bereit, solche Überprüfungen durchzuführen.  Gibt es noch etwas, das Sie vereinfachen und nur keine Attribute anzeigen können, die nicht ausgewählt wurden? </p><br><h2 id="proekcii-spring">  Frühlingsprojektionen </h2><br><p>  Das Spring Framework hat eine großartige Funktion namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projektionen</a> (und dies ist nicht dasselbe wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projektionen im Ruhezustand</a> ).  Wenn Sie nur einige Attribute einer Entität auswählen müssen, wird eine Schnittstelle mit den erforderlichen Attributen erstellt, und Spring wählt "Instanzen" dieser Schnittstelle aus der Datenbank aus.  Betrachten Sie als Beispiel die folgende Schnittstelle: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamesOnly</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  Jetzt können Sie ein Spring JPA-Repository zum Abrufen von Benutzerentitäten wie folgt definieren: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Collection&lt;NamesOnly&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String lastname)</span></span></span></span>; }</code> </pre> <br><p>  In diesem Fall erhalten wir nach dem Aufrufen der findByName-Methode in der resultierenden Liste Entitäten, die nur Zugriff auf Attribute haben, die in der Schnittstelle definiert sind!  Nach dem gleichen Prinzip kann man abhängige Entitäten auswählen, d.h.  Wählen Sie sofort die Beziehung „Master-Detail“ aus.  Darüber hinaus generiert Spring in den meisten Fällen "korrektes" SQL, d. H.  Aus der Datenbank werden nur die Attribute ausgewählt, die in der Projektion beschrieben sind. Dies ist der Funktionsweise von Entitätsdiagrammen sehr ähnlich. <br>  Dies ist eine sehr leistungsfähige API. Bei der Definition von Schnittstellen können Sie SpEL-Ausdrücke verwenden, Klassen mit einer integrierten Logik anstelle von Schnittstellen verwenden und vieles mehr. In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> wird alles ausführlich beschrieben. <br>  Das einzige Problem bei Projektionen besteht darin, dass sie im Inneren als Schlüssel-Wert-Paare implementiert sind, d. H.  sind schreibgeschützt.  Dies bedeutet, dass wir die Änderungen weder über die CRUD-Repositorys noch über den EntityManager speichern können, selbst wenn wir eine Setter-Methode für die Projektion definieren.  Projektionen sind also DTOs, die nur dann wieder in Entity konvertiert und gespeichert werden können, wenn Sie dafür Ihren eigenen Code schreiben. </p><br><h2 id="kak-vybirayutsya-dannye-v-cuba">  So wählen Sie Daten in CUBA aus </h2><br><p>  Von Beginn der Entwicklung des CUBA-Frameworks an haben wir versucht, den Teil des Codes zu optimieren, der mit der Datenbank funktioniert.  Bei CUBA verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EclipseLink</a> als Basis für die Datenzugriffs-API.  Das Gute an EclipseLink ist, dass es das Laden von Teilentitäten von Anfang an unterstützte, und dies war ein entscheidender Faktor bei der Auswahl zwischen EclipseLink und Hibernate.  In EclipseLink können Sie Attribute angeben, die lange vor dem Erscheinen des JPA 2.1-Standards geladen werden sollen.  CUBA hat eine eigene Art, ein Entitätsdiagramm zu beschreiben, das als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CUBA-Ansichten bezeichnet wird</a> .  Repräsentationen CUBA ist eine ziemlich entwickelte API. Sie können einige Repräsentationen von anderen erben, sie kombinieren und sowohl auf Master- als auch auf Detailentitäten anwenden.  Eine weitere Motivation für die Erstellung von CUBA-Ansichten besteht darin, dass wir kurze Transaktionen verwenden wollten, damit wir mit getrennten Entitäten in der Webbenutzeroberfläche arbeiten können. <br>  In CUBA werden Ansichten in einer XML-Datei wie im folgenden Beispiel beschrieben: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">view</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.sample.User"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">extends</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"_minimal"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user-minimal-view"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"addresses"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">view</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"address-street-only-view"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">view</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Diese Ansicht wählt die <code>User</code> und ihren lokalen Attributnamen aus und wählt Adressen aus, indem die <code>address-street-only-view</code> .  All dies geschieht (Aufmerksamkeit!) Auf der Ebene der SQL-Abfrage.  Wenn die Ansicht erstellt wird, können Sie sie bei der Datenauswahl mithilfe der DataManager-Klasse verwenden: </p><br><pre> <code class="java hljs">List&lt;User&gt; users = dataManager.load(User.class).view(<span class="hljs-string"><span class="hljs-string">"user-edit-view"</span></span>).list();</code> </pre> <br><p>  Dieser Ansatz funktioniert gut, während der Netzwerkverkehr wirtschaftlich genutzt wird, da nicht verwendete Attribute einfach nicht von der Datenbank an die Anwendung übertragen werden. Wie bei JPA gibt es jedoch ein Problem: Es kann nicht gesagt werden, welche Attribute der Entität geladen wurden.  Und in CUBA gibt es eine Ausnahme <code>“IllegalStateException: Cannot get unfetched attribute [...] from detached object”</code> , die wie <code>LazyInit</code> von jedem angetroffen werden muss, der mit unserem Framework schreibt.  Wie in der JPA gibt es Möglichkeiten zu überprüfen, welche Attribute geladen wurden und welche nicht, aber das Schreiben solcher Überprüfungen ist wiederum eine mühsame, mühsame Aufgabe, die Entwickler sehr aufregt.  Es muss noch etwas anderes erfunden werden, um die Menschen nicht mit Arbeiten zu belasten, die Maschinen theoretisch leisten können. </p><br><h2 id="koncept---cuba-view-interfaces">  Konzept - CUBA View-Schnittstellen </h2><br><p>  Was aber, wenn Sie versuchen, Entitätsdiagramme und Projektionen zu kombinieren?  Wir haben uns dazu entschlossen und Schnittstellen für Entity-View-Schnittstellen entwickelt, die dem Spring-Projektionsansatz folgen.  Diese Schnittstellen werden beim Start der Anwendung in CUBA-Ansichten übersetzt und können im DataManager verwendet werden.  Die Idee ist einfach: Wir beschreiben eine Schnittstelle (oder eine Reihe von Schnittstellen), bei der es sich um ein Entitätsdiagramm handelt. </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserMinimalView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEntityView</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String val)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;AddressStreetOnly&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAddresses</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddressStreetOnly</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEntityView</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStreet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStreet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String street)</span></span></span></span>; } }</code> </pre> <br><p>  Es ist erwähnenswert, dass Sie in bestimmten Fällen lokale Schnittstellen erstellen können, wie im Fall von <code>AddressStreetOnly</code> aus dem obigen Beispiel, um die öffentliche API Ihrer Anwendung nicht zu "verschmutzen". </p><br><p>  Beim Starten einer CUBA-Anwendung (von der der größte Teil den Spring-Kontext initialisiert) erstellen wir programmgesteuert CUBA-Ansichten und fügen sie im Kontext in das interne Bean-Repository ein. <br>  Jetzt müssen Sie die Implementierung der DataManager-Klasse geringfügig ändern, damit sie Schnittstellenansichten akzeptiert, und Sie können Entitäten auf folgende Weise auswählen: </p><br><pre> <code class="java hljs">List&lt;UserMinimalView&gt; users = dataManager.load(UserMinimalView.class).list();</code> </pre> <br><p>  Unter der Haube wird ein Proxy-Objekt generiert, das die Schnittstelle implementiert und die aus der Datenbank ausgewählte Entitätsinstanz umschließt (ähnlich wie im Ruhezustand).  Wenn der Entwickler den Attributwert aufruft, delegiert der Proxy den Methodenaufruf an die "echte" Instanz der Entität. </p><br><p>  Bei der Entwicklung dieses Konzepts versuchen wir, zwei Fliegen mit einer Klappe zu schlagen: </p><br><ul><li>  Daten, die nicht in der Schnittstelle beschrieben sind, werden nicht in die Anwendung geladen, wodurch Serverressourcen gespart werden. </li><li>  Der Entwickler kann nur die Attribute verwenden, auf die über die Schnittstelle <code>UnfetchedAttribute</code> werden kann (und die daher aus der Datenbank ausgewählt werden), wodurch die oben beschriebenen <code>UnfetchedAttribute</code> Ausnahmen beseitigt werden. </li></ul><br><p>  Im Gegensatz zu Spring-Projektionen verpacken wir Entitäten in Proxy-Objekte. Außerdem erbt jede Schnittstelle die Standard-CUBA-Schnittstelle - <code>Entity</code> .  Dies bedeutet, dass Entitätsansichtsattribute geändert werden können und diese Änderungen dann mithilfe der Standard-CUBA-API für die Arbeit mit Daten in der Datenbank gespeichert werden. <br>  Übrigens der „dritte Hase“ - Sie können Attribute schreibgeschützt machen, wenn Sie eine Schnittstelle nur mit Getter-Methoden definieren.  Daher haben wir die Änderungsregeln bereits auf der Ebene der Entitäts-API festgelegt. <br>  Darüber hinaus können Sie einige lokale Operationen für getrennte Entitäten mithilfe verfügbarer Attribute ausführen, z. B. die Konvertierung von Namenszeichenfolgen, wie im folgenden Beispiel: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@MetaProperty</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNameLowercase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getName().toLowerCase(); }</code> </pre> <br><p>  Beachten Sie, dass berechnete Attribute aus dem Entitätsklassenmodell herausgenommen und an Schnittstellen übertragen werden können, die für eine bestimmte Geschäftslogik gelten. </p><br><p>  Ein weiteres interessantes Merkmal ist die Vererbung von Schnittstellen.  Sie können mehrere Ansichten mit unterschiedlichen Attributgruppen erstellen und diese dann kombinieren.  Sie können beispielsweise eine Schnittstelle für eine Benutzerentität mit den Attributen name und email und eine andere mit den Attributen name und address erstellen.  Wenn Sie nun Name, E-Mail-Adresse und Adresse auswählen müssen, müssen Sie diese Attribute nicht auf die dritte Schnittstelle kopieren, sondern nur von den ersten beiden Ansichten erben.  Und ja, Instanzen der dritten Schnittstelle können an Methoden übergeben werden, die Parameter mit dem Typ der übergeordneten Schnittstellen akzeptieren. Die OOP-Regeln sind für alle gleich. </p><br><p>  Eine Konvertierung zwischen Ansichten wurde ebenfalls implementiert - jede Schnittstelle verfügt über eine reload () -Methode, an die Sie die Ansichtsklasse als Parameter übergeben können: </p><br><pre> <code class="java hljs">UserFullView userFull = userMinimal.reload(UserFullView.class);</code> </pre> <br><p>  UserFullView kann zusätzliche Attribute enthalten, sodass die Entität bei Bedarf aus der Datenbank neu geladen wird.  Und dieser Prozess ist verzögert.  Der Zugriff auf die Datenbank erfolgt nur, wenn der erste Zugriff auf die Attribute der Entität erfolgt.  Dies verlangsamt den ersten Aufruf ein wenig, aber dieser Ansatz wurde absichtlich gewählt. Wenn die Entitätsinstanz im Webmodul verwendet wird, das die Benutzeroberfläche und ihre eigenen REST-Controller enthält, kann dieses Modul auf einem separaten Server bereitgestellt werden.  Dies bedeutet, dass die erzwungene Überlastung der Entität zusätzlichen Netzwerkverkehr erzeugt - Zugriff auf das Kernmodul und dann auf die Datenbank.  Indem wir die Überlastung bis zu dem Zeitpunkt verschieben, an dem dies erforderlich ist, sparen wir Datenverkehr und reduzieren die Anzahl der Datenbankabfragen. </p><br><p>  Das Konzept ist als Modul für CUBA konzipiert. Ein Anwendungsbeispiel kann von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> heruntergeladen werden. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Es scheint, dass wir ORM in naher Zukunft immer noch massiv in Unternehmensanwendungen einsetzen werden, nur weil wir etwas brauchen, das relationale Daten in Objekte verwandelt.  Natürlich werden spezifische Lösungen für komplexe, einzigartige Anwendungen mit ultrahoher Last entwickelt, aber es scheint, dass ORM-Frameworks so lange funktionieren wie relationale Datenbanken. <br>  In CUBA versuchen wir, die Arbeit mit ORM maximal zu vereinfachen, und in zukünftigen Versionen werden wir neue Funktionen für die Arbeit mit Daten einführen.  Es wird schwierig sein zu sagen, ob dies Präsentationsschnittstellen oder etwas anderes sein werden, aber ich bin mir einer Sache sicher: Wir werden die Arbeit mit Daten in zukünftigen Versionen des Frameworks weiter vereinfachen. </p><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451986/">https://habr.com/ru/post/de451986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451970/index.html">Thrangrycat: Durch eine kritische Sicherheitslücke in der Cisco-Gerätefirmware können Hacker Backdoors auf ihnen installieren</a></li>
<li><a href="../de451972/index.html">QuadCast - Klingt echt</a></li>
<li><a href="../de451974/index.html">AMD-Geschichte: 50 Jahre rasante Entwicklung</a></li>
<li><a href="../de451976/index.html">Was kostet ein "souveräner" Runet?</a></li>
<li><a href="../de451982/index.html">Je schneller Sie OOP vergessen, desto besser für Sie und Ihre Programme.</a></li>
<li><a href="../de451990/index.html">FAQ zu Transfers und Anschlussflügen: Was ist der Unterschied, den ein Passagier machen kann und was nicht</a></li>
<li><a href="../de451996/index.html">Meine Erfahrung von Fehlern</a></li>
<li><a href="../de451998/index.html">Probleme der Präzisionslandwirtschaft und wie man damit umgeht</a></li>
<li><a href="../de452000/index.html">Wie Sie in Leroy Merlin Waren aus dem Lager eines Lieferanten kaufen können, der sich nicht im Sortiment des Geschäfts befindet</a></li>
<li><a href="../de452004/index.html">Fand die Absturzstelle des Bereshit auf dem Mond</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>