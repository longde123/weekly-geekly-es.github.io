<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí≥ ‚úîÔ∏è üí± Ein weiterer Artikel √ºber die Lebenszeiten in Rust üò≥ üë≥üèø üë©üèΩ‚Äçü§ù‚Äçüë®üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den ersten Monaten eines unerfahrenen Riotman geht es in der Regel um eine √úberschrift √ºber das Konzept eines Lebens und Besitzes. Einige Leute bre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein weiterer Artikel √ºber die Lebenszeiten in Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442962/"><p> In den ersten Monaten eines unerfahrenen Riotman geht es in der Regel um eine √úberschrift √ºber das Konzept eines Lebens und Besitzes.  Einige Leute brechen dies zusammen, aber f√ºr diejenigen, die √ºberleben konnten, scheint dies nicht l√§nger ungew√∂hnlich oder falsch zu sein.  Ich werde die wichtigsten Punkte beschreiben, die meines Erachtens dazu beigetragen haben, sich schneller und besser an das Konzept von Leben und Besitz anzupassen. <img src="https://habrastorage.org/webt/vm/qw/p5/vmqwp5m_uwm9ghbbtcm5be3xqre.png" align="right"></p><br><p>  Nat√ºrlich ist der offizielle Newsletter umfassender und detaillierter, aber es erfordert auch mehr Zeit und Geduld, um alle Informationen vollst√§ndig zu verstehen und aufzunehmen.  Ich habe versucht, eine gro√üe Anzahl von Details zu vermeiden und alles in der Reihenfolge zunehmender Komplexit√§t zu pr√§sentieren, um diesen Artikel f√ºr diejenigen zug√§nglicher zu machen, die entweder gerade erst angefangen haben, das Rast zu sehen, oder die ersten Momente des offiziellen Bulletin Boards nicht wirklich verstanden haben. </p><br><p>  Es hat mich auch dazu gebracht zu schreiben, dass man zum Beispiel von Monaden einige offizielle Schulungsmaterialien finden kann, die jedoch nicht immer gut verstanden werden, und dass Verst√§ndnis erst entsteht, wenn man so etwas wie eine ‚Äûweitere Einf√ºhrung‚Äú zu diesem Thema liest. </p><br><h3 id="vremya-zhizni-lifetime">  Lebenszeit </h3><br><p>  Zuerst m√ºssen wir uns mit zwei Dingen vertraut machen - dem Ende des Blocks und dem Verschieben des Werts in einen anderen Block.  Sp√§ter werden wir beginnen, es durch Hinzuf√ºgen von "Kreditvergabe", "Ver√§nderlichkeit" und "versteckte Ver√§nderlichkeit" zu komplizieren. </p><a name="habracut"></a><br><p>  Zun√§chst wird die Lebensdauer eines Wertes durch das folgende Segment bestimmt: </p><br><ul><li>  Der Beginn des Lebens: Wertsch√∂pfung.  Dies ist f√ºr die meisten Programmiersprachen √ºblich und tr√§gt daher keine ungew√∂hnliche Last. </li><li>  Das Ende des Lebens.  Hier ruft Rust automatisch den Destruktor auf und vergisst den Wert.  In einem Scope-Block geschieht dies am Ende dieses Blocks, ohne sich zu bewegen.  Meiner Meinung nach ist die mentale Verfolgung des Lebensendes der Schl√ºssel f√ºr eine erfolgreiche Interaktion mit dem Kreditnehmer. </li></ul><cut></cut><br><p>  Ich werde ein Detail hinzuf√ºgen, das n√ºtzlich sein kann: Wenn der Bereich mehrere Werte enth√§lt, werden diese in umgekehrter Reihenfolge der Erstellung zerst√∂rt. </p><br><p>  Ein weiterer Punkt: Ich werde eine Zeichenfolge erstellen, da sie keine Kopiermarkierung enth√§lt und die Werte mit dieser Markierung nicht verschoben, sondern kopiert werden. Dies wird als recht billige Operation angesehen, √§ndert jedoch das Verhalten der Verschiebung (und erleichtert die Arbeit mit primitiven Typen). aber dazu sp√§ter mehr. </p><br><p>  Beispiele k√∂nnen hier ausgef√ºhrt werden: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://play.rust-lang.org/</a> </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { { <span class="hljs-comment"><span class="hljs-comment">//    let a = "a".to_string(); // &lt;-   "a" let b = 100; // &lt;-   "b" // &lt;-   b // &lt;-   a } //    //     "a"  "b" }</span></span></code> </pre> <br><p>  Mit einem einfachen Block ist alles relativ einfach. Die n√§chste Stufe tritt ein, wenn wir scheinbar einfache Dinge wie Funktionen und Verschl√ºsse verwenden: </p><br><h3 id="peremeschenie">  Umzug </h3><br><p>  F√ºgen Sie ein Konzept wie das Verschieben eines Werts hinzu.  Mit einfachen Worten bedeutet ‚ÄûBewegen‚Äú, dass der aktuelle Block nicht mehr am Schicksal des Werts interessiert ist und es vergisst und sein Schicksal auf einen anderen Block √ºbertragen wird, beispielsweise auf eine andere Funktion oder auf einen Abschluss oder einfach auf einen anderen Wert. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>&lt;T: std::fmt::Display&gt;(x: T) { <span class="hljs-comment"><span class="hljs-comment">//   ,         . println!("{}", x); // &lt;-  ,   "a",    . } fn main() { let a = "a".to_string(); // "a"    let b = 2; f(a); //   "a"  f //        f(a) -   ,    "a"        .    a  b,    ,      Copy   . // "b" . }</span></span></code> </pre> <br><p>  Mit Verschl√ºssen. </p><br><p>  Damit der Abschluss den erfassten Wert in seinen Block verschiebt, wird das Schl√ºsselwort move verwendet. Wenn Sie move nicht schreiben, wird der Wert ausgeliehen, √ºber den ich sehr bald schreiben werde. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string(); <span class="hljs-comment"><span class="hljs-comment">// "a"    let b = 2; let f_1 = move || {println!("{}", a)}; //   "a" //    "a"    . // let f_2 = move || {println!("{}", a)}; f_1(); }</span></span></code> </pre> <br><p>  Sie k√∂nnen sowohl zur Funktion als auch von der Funktion oder zu einem anderen Wert wechseln. </p><br><p>  Dieses Beispiel zeigt, wie Sie verfolgen k√∂nnen, wie sich Werte bewegen, um in Frieden mit dem Kreditpr√ºfer zu leben. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { x + <span class="hljs-string"><span class="hljs-string">" and x"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    x   +,     . //  +   String,    . } fn main() { let a = "a".to_string(); //  "a" let b = f(a); //  "a"  "f",  f     b. println!("{}", b); // "a"   . }</span></span></code> </pre> <br><h3 id="odalzhivanie">  Ausleihe </h3><br><p>  Wir f√ºhren dieses neue Konzept ein: Im Gegensatz zum Verschieben bedeutet dies, dass der aktuelle Block die Kontrolle √ºber den Wert beh√§lt und dem anderen Block einfach erlaubt, seinen Wert zu verwenden. </p><br><p>  Ich stelle fest, dass die Ausleihe auch dort stattfindet, wo sie beendet wurde, was in diesen Beispielen nicht sehr wichtig ist, aber im n√§chsten Absatz auftauchen wird. </p><br><p>  Hinweis: Ich werde nicht dar√ºber schreiben, wie die Lebensdauer direkt in der Funktion angegeben werden kann, da der moderne Rost dies automatisch besser macht als fr√ºher, und die Offenlegung all dessen ist ein paar weitere Seiten. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   &amp;,    . println!("{}", x); // &lt;-  ,  "x"     } fn main() { let a = "a".to_string(); // "a"    f(&amp;a); //   "a"  f //   f(&amp;a); //    -  . println!("{}", a); //   // "a"  . }</span></span></code> </pre> <br><p>  Mit Verschl√ºssen √§hnlich: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string(); <span class="hljs-comment"><span class="hljs-comment">// "a"    let f_1 = || a.push_str("and x"); //   "a" let f_2 = || a.push_str("and x"); //   f_1(); f_2(); println!("{}", a); // "a"  . }</span></span></code> </pre> <br><p>  Tats√§chlich muss der Benutzer in den meisten dieser einfachen Konstruktionen nur entscheiden, wo er die Lebensdauer des Werts beenden m√∂chte: am Ende des aktuellen Blocks und Ausleihen an einige Funktionen oder, wenn wir wissen, dass wir den Wert nicht mehr ben√∂tigen, ihn am Ende in die Funktion verschieben Dadurch, dass es selbst zerst√∂rt wird, wird der Speicher umso schneller freigegeben, aber der Wert ist im aktuellen Block nicht mehr verf√ºgbar. </p><br><h3 id="mutabelnost">  Ver√§nderlichkeit </h3><br><p>  In Rasta, wie zum Beispiel in Kotlin, gibt es eine Unterteilung in ver√§nderbare und instabile Werte.  Es stellt sich jedoch das Problem, dass sich die Ver√§nderlichkeit auf die Kreditvergabe auswirkt: <br>  Sie k√∂nnen einen nicht stabilen Wert viele Male ausleihen, und ein ver√§nderlicher Wert kann nur einmal gegenseitig ausgeliehen werden.  Sie k√∂nnen einen bereits zuvor geliehenen Wert nicht mutieren. </p><br><p>  Ein Beispiel, das nicht mit den vorherigen verwandt ist, wenn dieses Konzept uns vor Problemen bewahrt, indem es die gleichzeitige ver√§nderliche und nicht stabile Kreditvergabe verbietet: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>.to_string(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a.chars() { <span class="hljs-comment"><span class="hljs-comment">//   a.push_str(" and "); //  .  . a.push(x); } }</span></span></code> </pre> <br><p>  Hier ist es bereits notwendig, sich mit verschiedenen Tricks einzudecken, um die gerechten Anspr√ºche der Rasta gr√∂√ütenteils zu befriedigen.  Im obigen Beispiel w√§re es am einfachsten, "a" zu klonen -&gt; der Klon hat ein nicht stabiles Darlehen und bezieht sich nicht auf das urspr√ºngliche "a". </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a.clone().chars() { <span class="hljs-comment"><span class="hljs-comment">//  ,   . a.push_str(" and "); //  .      -   .</span></span></code> </pre> <br><p>  Aber ich gehe besser zu unseren Beispielen zur√ºck, um die Konsistenz aufrechtzuerhalten.  Wir m√ºssen "a" √§ndern und k√∂nnen es nicht tun. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string(); <span class="hljs-comment"><span class="hljs-comment">// "a"    let mut f_1 = || a.push_str(" and x"); //   "a".   - ,  mut  mut. //      ,   f_1  . let mut f_2 = || a.push_str(" and y"); //     : second mutable borrow occurs here f_1(); f_2(); println!("{}", a); }</span></span></code> </pre> <br><h3 id="skrytoe-mutirovanie">  Versteckte Mutation </h3><br><p>  Theoretisch kann ein Abschluss an eine Funktion √ºbergeben werden, die beispielsweise asynchron in einem anderen Thread verarbeitet wird, und dann h√§tten wir wirklich Probleme, aber in diesem Fall ist der Kreditpr√ºfer r√ºckversichert, obwohl dies nicht die Tatsache aufhebt, dass wir irgendwie damit einverstanden sein m√ºssen . </p><br><p>  Fazit: Wir brauchen zwei mutierende Anleihen, aber das Rast l√§sst nur eines zu, aber die gerissenen Erfinder des Rasta haben eine ‚Äûversteckte Mutation‚Äú: RefCell. </p><br><p>  RefCell - was wir in RefCell einschlie√üen - das Raster h√§lt es f√ºr nemable. Mit der Funktion bor_mut () k√∂nnen wir jedoch vor√ºbergehend einen ver√§nderlichen Link extrahieren, mit dem der Wert ge√§ndert werden kann. Es <strong>gibt jedoch eine wichtige Nuance</strong> : Der Link kann nur abgerufen werden, wenn RefCell zur Laufzeit sicherstellt, dass keine anderen vorhanden sind aktive Kredite, sonst wird er in Panik geraten oder einen Fehler zur√ºckgeben, wenn try_borrow_mut () verwendet wird.  Das hei√üt,  Hier macht das Wachstum alle Sorgen um die Kreditvergabe an den Benutzer, und er selbst muss sicherstellen, dass er den Wert nicht an mehreren Stellen gleichzeitig ausleiht. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cell::RefCell; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = RefCell::new(<span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string()); <span class="hljs-comment"><span class="hljs-comment">// "a"    let f_1 = || a.borrow_mut().push_str(" and x"); //    "a" let f_2 = || a.borrow_mut().push_str(" and y"); //    f_1(); //      a.borrow_mut() ,           mut    . f_2(); //   . println!("{}", a.borrow()); //         . }</span></span></code> </pre> <br><h3 id="schyotchik-ssylok-rc">  Rc Link Counter </h3><br><p>  Diese Konstruktion ist in vielen Sprachen bekannt und wird im Rast verwendet, wenn wir beispielsweise aus irgendeinem Grund keinen Wert ausleihen k√∂nnen und mehrere Referenzwerte f√ºr einen einzelnen Wert erforderlich sind.  Rc ist, wie der Name schon sagt, einfach ein Referenzz√§hler, der einen Wert besitzt. Er kann instabile Links ausleihen, ihre Nummer z√§hlen und sobald ihre Nummer zur√ºckgesetzt wird, den Wert und sich selbst zerst√∂ren.  Es stellt sich heraus, dass Rc es sozusagen erlaubt, die Lebensdauer des darin enthaltenen Werts heimlich zu verl√§ngern. </p><br><p>  Ich werde hinzuf√ºgen, dass der Rast automatisch deref f√ºr die Strukturen ausf√ºhren kann, f√ºr die er definiert ist, was bedeutet, dass Sie f√ºr die Arbeit mit Rc in der Regel keine zus√§tzliche Extraktion des internen Werts ben√∂tigen und wir nur mit Rc wie mit dem darin enthaltenen Wert arbeiten. </p><br><p>  Hier wurde ein einfaches Beispiel ein wenig √ºberlegt. Versuchen wir zu emulieren, dass der Abschluss aus dem obigen Beispiel &amp; T oder &amp; String nicht akzeptieren m√∂chte, sondern nur String: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  String,    &amp;String println!("{}", x); } fn main() { let a = "a".to_string(); let f_1 = move || f(a); //   move,    ... let f_2 = move || f(a); // ...     ,           f_1(); f_2(); println!("{}", a); }</span></span></code> </pre> <br><p>  Dieses Problem w√§re leicht zu l√∂sen, wenn wir die Funktion in <code>fn f(x: &amp;String)</code> (oder &amp; str) √§ndern k√∂nnten, aber stellen wir uns vor, dass wir &amp; aus irgendeinem Grund nicht verwenden k√∂nnen </p><br><p>  Wir verwenden Rc </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::rc::Rc; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: Rc&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;) { <span class="hljs-comment"><span class="hljs-comment">//       Rc println!("{}", x); //     ,  println          ,           ,       ,    . } fn main() { let a_rc = Rc::new("a".to_string()); //  Rc   let a_ref_1 = a.clone(); //   -,  . let a_ref_2 = a.clone(); //   let f_1 = move || f(a_ref_1); //      - let f_2 = move || f(a_ref_2); //  f_1(); f_2(); println!("{}", a_rc); //     Rc  . //    a_rc       . }</span></span></code> </pre> <br><p>  Ich werde das letzte Beispiel hinzuf√ºgen, da eines der h√§ufigsten Containerpaare, die gefunden werden k√∂nnen, Rc &lt;RefCell&gt; ist <br></p><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::rc::Rc; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cell::RefCell; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: Rc&lt;RefCell&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;&gt;) { x.borrow_mut().push_str(<span class="hljs-string"><span class="hljs-string">" and x"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      ,       ,   . } fn main() { let a = Rc::new(RefCell::new("a".to_string())); //      let a_ref_1 = a.clone(); let a_ref_2 = a.clone(); let f_1 = move || f(a_ref_1); let f_2 = move || f(a_ref_2); f_1(); f_2(); println!("{}", a.borrow()); // Rc   ,   RefCell   }</span></span></code> </pre> <br><p>  Au√üerdem w√§re es logisch, dieses Tutorial auf ein thread-sicheres Analogon von Rc-Arc zu verschieben und dann mit Mutex fortzufahren. Sie werden jedoch nicht in einem Absatz √ºber Thread-Sicherheit und Leihpr√ºfung sprechen, und es ist nicht klar, ob diese Art von Artikel √ºberhaupt ben√∂tigt wird, da es einen offiziellen Thread gibt.  Also schlie√üe ich. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442962/">https://habr.com/ru/post/de442962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442948/index.html">Durch Automatisierung entlassen</a></li>
<li><a href="../de442950/index.html">Bewertung Cutra Wonder Cutter</a></li>
<li><a href="../de442952/index.html">Neuer Hackathon bei Tinkoff.ru</a></li>
<li><a href="../de442954/index.html">Verwenden von SQLite in Unity (Unity + SQLite)</a></li>
<li><a href="../de442958/index.html">Nikita Shamgunov erz√§hlte The Bell von der Arbeit bei Microsoft und Facebook im Gespr√§ch mit Gates und der MemSQL-Datenbank</a></li>
<li><a href="../de442964/index.html">Die Kunst des Parsens oder Do-it-yourself-DOM</a></li>
<li><a href="../de442966/index.html">Bitcoin f√ºr Starbucks-Kaffee wirft erhebliche Probleme bei der Steuererkl√§rung auf</a></li>
<li><a href="../de442968/index.html">Erhalt eines CPE zur Unterst√ºtzung professioneller Zertifizierungen (Fallstudie von ISACA)</a></li>
<li><a href="../de442970/index.html">Brettspiel zum Erlernen der Grundlagen elektrischer Schaltkreise. Warum nicht?</a></li>
<li><a href="../de442974/index.html">Die Gesetzesvorlage zur Bek√§mpfung gef√§lschter Informationen wurde in dritter Lesung verabschiedet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>