<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💳 ✔️ 💱 Ein weiterer Artikel über die Lebenszeiten in Rust 😳 👳🏿 👩🏽‍🤝‍👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den ersten Monaten eines unerfahrenen Riotman geht es in der Regel um eine Überschrift über das Konzept eines Lebens und Besitzes. Einige Leute bre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein weiterer Artikel über die Lebenszeiten in Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442962/"><p> In den ersten Monaten eines unerfahrenen Riotman geht es in der Regel um eine Überschrift über das Konzept eines Lebens und Besitzes.  Einige Leute brechen dies zusammen, aber für diejenigen, die überleben konnten, scheint dies nicht länger ungewöhnlich oder falsch zu sein.  Ich werde die wichtigsten Punkte beschreiben, die meines Erachtens dazu beigetragen haben, sich schneller und besser an das Konzept von Leben und Besitz anzupassen. <img src="https://habrastorage.org/webt/vm/qw/p5/vmqwp5m_uwm9ghbbtcm5be3xqre.png" align="right"></p><br><p>  Natürlich ist der offizielle Newsletter umfassender und detaillierter, aber es erfordert auch mehr Zeit und Geduld, um alle Informationen vollständig zu verstehen und aufzunehmen.  Ich habe versucht, eine große Anzahl von Details zu vermeiden und alles in der Reihenfolge zunehmender Komplexität zu präsentieren, um diesen Artikel für diejenigen zugänglicher zu machen, die entweder gerade erst angefangen haben, das Rast zu sehen, oder die ersten Momente des offiziellen Bulletin Boards nicht wirklich verstanden haben. </p><br><p>  Es hat mich auch dazu gebracht zu schreiben, dass man zum Beispiel von Monaden einige offizielle Schulungsmaterialien finden kann, die jedoch nicht immer gut verstanden werden, und dass Verständnis erst entsteht, wenn man so etwas wie eine „weitere Einführung“ zu diesem Thema liest. </p><br><h3 id="vremya-zhizni-lifetime">  Lebenszeit </h3><br><p>  Zuerst müssen wir uns mit zwei Dingen vertraut machen - dem Ende des Blocks und dem Verschieben des Werts in einen anderen Block.  Später werden wir beginnen, es durch Hinzufügen von "Kreditvergabe", "Veränderlichkeit" und "versteckte Veränderlichkeit" zu komplizieren. </p><a name="habracut"></a><br><p>  Zunächst wird die Lebensdauer eines Wertes durch das folgende Segment bestimmt: </p><br><ul><li>  Der Beginn des Lebens: Wertschöpfung.  Dies ist für die meisten Programmiersprachen üblich und trägt daher keine ungewöhnliche Last. </li><li>  Das Ende des Lebens.  Hier ruft Rust automatisch den Destruktor auf und vergisst den Wert.  In einem Scope-Block geschieht dies am Ende dieses Blocks, ohne sich zu bewegen.  Meiner Meinung nach ist die mentale Verfolgung des Lebensendes der Schlüssel für eine erfolgreiche Interaktion mit dem Kreditnehmer. </li></ul><cut></cut><br><p>  Ich werde ein Detail hinzufügen, das nützlich sein kann: Wenn der Bereich mehrere Werte enthält, werden diese in umgekehrter Reihenfolge der Erstellung zerstört. </p><br><p>  Ein weiterer Punkt: Ich werde eine Zeichenfolge erstellen, da sie keine Kopiermarkierung enthält und die Werte mit dieser Markierung nicht verschoben, sondern kopiert werden. Dies wird als recht billige Operation angesehen, ändert jedoch das Verhalten der Verschiebung (und erleichtert die Arbeit mit primitiven Typen). aber dazu später mehr. </p><br><p>  Beispiele können hier ausgeführt werden: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://play.rust-lang.org/</a> </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { { <span class="hljs-comment"><span class="hljs-comment">//    let a = "a".to_string(); // &lt;-   "a" let b = 100; // &lt;-   "b" // &lt;-   b // &lt;-   a } //    //     "a"  "b" }</span></span></code> </pre> <br><p>  Mit einem einfachen Block ist alles relativ einfach. Die nächste Stufe tritt ein, wenn wir scheinbar einfache Dinge wie Funktionen und Verschlüsse verwenden: </p><br><h3 id="peremeschenie">  Umzug </h3><br><p>  Fügen Sie ein Konzept wie das Verschieben eines Werts hinzu.  Mit einfachen Worten bedeutet „Bewegen“, dass der aktuelle Block nicht mehr am Schicksal des Werts interessiert ist und es vergisst und sein Schicksal auf einen anderen Block übertragen wird, beispielsweise auf eine andere Funktion oder auf einen Abschluss oder einfach auf einen anderen Wert. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>&lt;T: std::fmt::Display&gt;(x: T) { <span class="hljs-comment"><span class="hljs-comment">//   ,         . println!("{}", x); // &lt;-  ,   "a",    . } fn main() { let a = "a".to_string(); // "a"    let b = 2; f(a); //   "a"  f //        f(a) -   ,    "a"        .    a  b,    ,      Copy   . // "b" . }</span></span></code> </pre> <br><p>  Mit Verschlüssen. </p><br><p>  Damit der Abschluss den erfassten Wert in seinen Block verschiebt, wird das Schlüsselwort move verwendet. Wenn Sie move nicht schreiben, wird der Wert ausgeliehen, über den ich sehr bald schreiben werde. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string(); <span class="hljs-comment"><span class="hljs-comment">// "a"    let b = 2; let f_1 = move || {println!("{}", a)}; //   "a" //    "a"    . // let f_2 = move || {println!("{}", a)}; f_1(); }</span></span></code> </pre> <br><p>  Sie können sowohl zur Funktion als auch von der Funktion oder zu einem anderen Wert wechseln. </p><br><p>  Dieses Beispiel zeigt, wie Sie verfolgen können, wie sich Werte bewegen, um in Frieden mit dem Kreditprüfer zu leben. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { x + <span class="hljs-string"><span class="hljs-string">" and x"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    x   +,     . //  +   String,    . } fn main() { let a = "a".to_string(); //  "a" let b = f(a); //  "a"  "f",  f     b. println!("{}", b); // "a"   . }</span></span></code> </pre> <br><h3 id="odalzhivanie">  Ausleihe </h3><br><p>  Wir führen dieses neue Konzept ein: Im Gegensatz zum Verschieben bedeutet dies, dass der aktuelle Block die Kontrolle über den Wert behält und dem anderen Block einfach erlaubt, seinen Wert zu verwenden. </p><br><p>  Ich stelle fest, dass die Ausleihe auch dort stattfindet, wo sie beendet wurde, was in diesen Beispielen nicht sehr wichtig ist, aber im nächsten Absatz auftauchen wird. </p><br><p>  Hinweis: Ich werde nicht darüber schreiben, wie die Lebensdauer direkt in der Funktion angegeben werden kann, da der moderne Rost dies automatisch besser macht als früher, und die Offenlegung all dessen ist ein paar weitere Seiten. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   &amp;,    . println!("{}", x); // &lt;-  ,  "x"     } fn main() { let a = "a".to_string(); // "a"    f(&amp;a); //   "a"  f //   f(&amp;a); //    -  . println!("{}", a); //   // "a"  . }</span></span></code> </pre> <br><p>  Mit Verschlüssen ähnlich: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string(); <span class="hljs-comment"><span class="hljs-comment">// "a"    let f_1 = || a.push_str("and x"); //   "a" let f_2 = || a.push_str("and x"); //   f_1(); f_2(); println!("{}", a); // "a"  . }</span></span></code> </pre> <br><p>  Tatsächlich muss der Benutzer in den meisten dieser einfachen Konstruktionen nur entscheiden, wo er die Lebensdauer des Werts beenden möchte: am Ende des aktuellen Blocks und Ausleihen an einige Funktionen oder, wenn wir wissen, dass wir den Wert nicht mehr benötigen, ihn am Ende in die Funktion verschieben Dadurch, dass es selbst zerstört wird, wird der Speicher umso schneller freigegeben, aber der Wert ist im aktuellen Block nicht mehr verfügbar. </p><br><h3 id="mutabelnost">  Veränderlichkeit </h3><br><p>  In Rasta, wie zum Beispiel in Kotlin, gibt es eine Unterteilung in veränderbare und instabile Werte.  Es stellt sich jedoch das Problem, dass sich die Veränderlichkeit auf die Kreditvergabe auswirkt: <br>  Sie können einen nicht stabilen Wert viele Male ausleihen, und ein veränderlicher Wert kann nur einmal gegenseitig ausgeliehen werden.  Sie können einen bereits zuvor geliehenen Wert nicht mutieren. </p><br><p>  Ein Beispiel, das nicht mit den vorherigen verwandt ist, wenn dieses Konzept uns vor Problemen bewahrt, indem es die gleichzeitige veränderliche und nicht stabile Kreditvergabe verbietet: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>.to_string(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a.chars() { <span class="hljs-comment"><span class="hljs-comment">//   a.push_str(" and "); //  .  . a.push(x); } }</span></span></code> </pre> <br><p>  Hier ist es bereits notwendig, sich mit verschiedenen Tricks einzudecken, um die gerechten Ansprüche der Rasta größtenteils zu befriedigen.  Im obigen Beispiel wäre es am einfachsten, "a" zu klonen -&gt; der Klon hat ein nicht stabiles Darlehen und bezieht sich nicht auf das ursprüngliche "a". </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a.clone().chars() { <span class="hljs-comment"><span class="hljs-comment">//  ,   . a.push_str(" and "); //  .      -   .</span></span></code> </pre> <br><p>  Aber ich gehe besser zu unseren Beispielen zurück, um die Konsistenz aufrechtzuerhalten.  Wir müssen "a" ändern und können es nicht tun. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string(); <span class="hljs-comment"><span class="hljs-comment">// "a"    let mut f_1 = || a.push_str(" and x"); //   "a".   - ,  mut  mut. //      ,   f_1  . let mut f_2 = || a.push_str(" and y"); //     : second mutable borrow occurs here f_1(); f_2(); println!("{}", a); }</span></span></code> </pre> <br><h3 id="skrytoe-mutirovanie">  Versteckte Mutation </h3><br><p>  Theoretisch kann ein Abschluss an eine Funktion übergeben werden, die beispielsweise asynchron in einem anderen Thread verarbeitet wird, und dann hätten wir wirklich Probleme, aber in diesem Fall ist der Kreditprüfer rückversichert, obwohl dies nicht die Tatsache aufhebt, dass wir irgendwie damit einverstanden sein müssen . </p><br><p>  Fazit: Wir brauchen zwei mutierende Anleihen, aber das Rast lässt nur eines zu, aber die gerissenen Erfinder des Rasta haben eine „versteckte Mutation“: RefCell. </p><br><p>  RefCell - was wir in RefCell einschließen - das Raster hält es für nemable. Mit der Funktion bor_mut () können wir jedoch vorübergehend einen veränderlichen Link extrahieren, mit dem der Wert geändert werden kann. Es <strong>gibt jedoch eine wichtige Nuance</strong> : Der Link kann nur abgerufen werden, wenn RefCell zur Laufzeit sicherstellt, dass keine anderen vorhanden sind aktive Kredite, sonst wird er in Panik geraten oder einen Fehler zurückgeben, wenn try_borrow_mut () verwendet wird.  Das heißt,  Hier macht das Wachstum alle Sorgen um die Kreditvergabe an den Benutzer, und er selbst muss sicherstellen, dass er den Wert nicht an mehreren Stellen gleichzeitig ausleiht. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cell::RefCell; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = RefCell::new(<span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string()); <span class="hljs-comment"><span class="hljs-comment">// "a"    let f_1 = || a.borrow_mut().push_str(" and x"); //    "a" let f_2 = || a.borrow_mut().push_str(" and y"); //    f_1(); //      a.borrow_mut() ,           mut    . f_2(); //   . println!("{}", a.borrow()); //         . }</span></span></code> </pre> <br><h3 id="schyotchik-ssylok-rc">  Rc Link Counter </h3><br><p>  Diese Konstruktion ist in vielen Sprachen bekannt und wird im Rast verwendet, wenn wir beispielsweise aus irgendeinem Grund keinen Wert ausleihen können und mehrere Referenzwerte für einen einzelnen Wert erforderlich sind.  Rc ist, wie der Name schon sagt, einfach ein Referenzzähler, der einen Wert besitzt. Er kann instabile Links ausleihen, ihre Nummer zählen und sobald ihre Nummer zurückgesetzt wird, den Wert und sich selbst zerstören.  Es stellt sich heraus, dass Rc es sozusagen erlaubt, die Lebensdauer des darin enthaltenen Werts heimlich zu verlängern. </p><br><p>  Ich werde hinzufügen, dass der Rast automatisch deref für die Strukturen ausführen kann, für die er definiert ist, was bedeutet, dass Sie für die Arbeit mit Rc in der Regel keine zusätzliche Extraktion des internen Werts benötigen und wir nur mit Rc wie mit dem darin enthaltenen Wert arbeiten. </p><br><p>  Hier wurde ein einfaches Beispiel ein wenig überlegt. Versuchen wir zu emulieren, dass der Abschluss aus dem obigen Beispiel &amp; T oder &amp; String nicht akzeptieren möchte, sondern nur String: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  String,    &amp;String println!("{}", x); } fn main() { let a = "a".to_string(); let f_1 = move || f(a); //   move,    ... let f_2 = move || f(a); // ...     ,           f_1(); f_2(); println!("{}", a); }</span></span></code> </pre> <br><p>  Dieses Problem wäre leicht zu lösen, wenn wir die Funktion in <code>fn f(x: &amp;String)</code> (oder &amp; str) ändern könnten, aber stellen wir uns vor, dass wir &amp; aus irgendeinem Grund nicht verwenden können </p><br><p>  Wir verwenden Rc </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::rc::Rc; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: Rc&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;) { <span class="hljs-comment"><span class="hljs-comment">//       Rc println!("{}", x); //     ,  println          ,           ,       ,    . } fn main() { let a_rc = Rc::new("a".to_string()); //  Rc   let a_ref_1 = a.clone(); //   -,  . let a_ref_2 = a.clone(); //   let f_1 = move || f(a_ref_1); //      - let f_2 = move || f(a_ref_2); //  f_1(); f_2(); println!("{}", a_rc); //     Rc  . //    a_rc       . }</span></span></code> </pre> <br><p>  Ich werde das letzte Beispiel hinzufügen, da eines der häufigsten Containerpaare, die gefunden werden können, Rc &lt;RefCell&gt; ist <br></p><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::rc::Rc; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cell::RefCell; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: Rc&lt;RefCell&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;&gt;) { x.borrow_mut().push_str(<span class="hljs-string"><span class="hljs-string">" and x"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      ,       ,   . } fn main() { let a = Rc::new(RefCell::new("a".to_string())); //      let a_ref_1 = a.clone(); let a_ref_2 = a.clone(); let f_1 = move || f(a_ref_1); let f_2 = move || f(a_ref_2); f_1(); f_2(); println!("{}", a.borrow()); // Rc   ,   RefCell   }</span></span></code> </pre> <br><p>  Außerdem wäre es logisch, dieses Tutorial auf ein thread-sicheres Analogon von Rc-Arc zu verschieben und dann mit Mutex fortzufahren. Sie werden jedoch nicht in einem Absatz über Thread-Sicherheit und Leihprüfung sprechen, und es ist nicht klar, ob diese Art von Artikel überhaupt benötigt wird, da es einen offiziellen Thread gibt.  Also schließe ich. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442962/">https://habr.com/ru/post/de442962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442948/index.html">Durch Automatisierung entlassen</a></li>
<li><a href="../de442950/index.html">Bewertung Cutra Wonder Cutter</a></li>
<li><a href="../de442952/index.html">Neuer Hackathon bei Tinkoff.ru</a></li>
<li><a href="../de442954/index.html">Verwenden von SQLite in Unity (Unity + SQLite)</a></li>
<li><a href="../de442958/index.html">Nikita Shamgunov erzählte The Bell von der Arbeit bei Microsoft und Facebook im Gespräch mit Gates und der MemSQL-Datenbank</a></li>
<li><a href="../de442964/index.html">Die Kunst des Parsens oder Do-it-yourself-DOM</a></li>
<li><a href="../de442966/index.html">Bitcoin für Starbucks-Kaffee wirft erhebliche Probleme bei der Steuererklärung auf</a></li>
<li><a href="../de442968/index.html">Erhalt eines CPE zur Unterstützung professioneller Zertifizierungen (Fallstudie von ISACA)</a></li>
<li><a href="../de442970/index.html">Brettspiel zum Erlernen der Grundlagen elektrischer Schaltkreise. Warum nicht?</a></li>
<li><a href="../de442974/index.html">Die Gesetzesvorlage zur Bekämpfung gefälschter Informationen wurde in dritter Lesung verabschiedet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>