<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆙 🐠 🧓🏽 Wie man sich in C und C ++ in den Fuß schießt. Haiku OS Kochbuch 🤳🏽 🎃 👩🏼‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Geschichte, wie sich der statische Analysator PVS-Studio und der Haiku-Betriebssystemcode kennengelernt haben, geht auf das Jahr 2015 zurück. Es w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man sich in C und C ++ in den Fuß schießt. Haiku OS Kochbuch</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/461253/">  Die Geschichte, wie sich der statische Analysator PVS-Studio und der Haiku-Betriebssystemcode kennengelernt haben, geht auf das Jahr 2015 zurück. Es war ein aufregendes Experiment und eine nützliche Erfahrung für die Teams beider Projekte.  Warum das Experiment?  In diesem Moment hatten wir den Analysator für Linux nicht und wir würden ihn noch anderthalb Jahre nicht haben.  Wie auch immer, die Bemühungen von Enthusiasten aus unserem Team wurden belohnt: Wir haben uns mit Haiku-Entwicklern getroffen und die Codequalität erhöht, unsere Fehlerbasis mit seltenen Fehlern von Entwicklern erweitert und den Analysator verfeinert.  Jetzt können Sie den Haiku-Code einfach und schnell auf Fehler überprüfen. <br><div style="text-align:center;"><img src="https://import.viva64.com/docx/blog/0644_Haiku_3/image1.png" alt="Bild 1"></div><br><a name="habracut"></a><br><h2>  Einführung </h2><br>  Lernen Sie die Hauptfiguren unserer Geschichte kennen - das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haiku</a> mit Open Source Code und den statischen Analysator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio</a> für C, C ++, C # und Java.  Als wir uns vor 4,5 Jahren mit der Projektanalyse befassten, mussten wir uns nur mit der kompilierten ausführbaren Analysedatei befassen.  Die gesamte Infrastruktur zum Parsen von Compilerparametern, Ausführen eines Präprozessors, Parallelschalten der Analyse usw. wurde aus der in C # geschriebenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benutzeroberfläche</a> des Dienstprogramms <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Compiler Monitoring</a> entnommen.  Dieses Dienstprogramm wurde teilweise auf die Mono-Plattform portiert, um unter Linux ausgeführt zu werden.  Das Haiku-Projekt wird mit dem Cross-Compiler unter verschiedenen Betriebssystemen außer Windows erstellt.  Ich möchte noch einmal die Bequemlichkeit und Vollständigkeit der Dokumentation im Zusammenhang mit dem Haiku-Gebäude erwähnen.  Außerdem möchte ich den Haiku-Entwicklern für ihre Hilfe beim Aufbau des Projekts danken. <br><br>  Es ist jetzt viel einfacher, die Analyse durchzuführen.  Hier ist die Liste aller Befehle zum Erstellen und Analysieren des Projekts: <br><br><pre><code class="cpp hljs">cd /opt git clone https:<span class="hljs-comment"><span class="hljs-comment">//review.haiku-os.org/buildtools git clone https://review.haiku-os.org/haiku cd ./haiku mkdir generated.x86_64; cd generated.x86_64 ../configure --distro-compatibility official -j12 \ --build-cross-tools x86_64 ../../buildtools cd ../../buildtools/jam make all cd /opt/haiku/generated.x86_64 pvs-studio-analyzer trace -- /opt/buildtools/jam/bin.linuxx86/jam \ -q -j1 @nightly-anyboot pvs-studio-analyzer analyze -l /mnt/svn/PVS-Studio.lic -r /opt/haiku \ -C x86_64-unknown-haiku-gcc -o /opt/haiku/haiku.log -j12</span></span></code> </pre> <br>  Die Projektanalyse wurde übrigens in einem Docker-Container implementiert.  Kürzlich haben wir eine neue Dokumentation zu diesem Thema vorbereitet: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausführen von PVS-Studio in Docker</a> .  Dies kann es einigen Unternehmen sehr leicht machen, statische Analysetechniken für ihre Projekte anzuwenden. <br><br><h2>  Nicht initialisierte Variablen </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V614</a> Nicht initialisierte Variable 'rval' verwendet.  fetch.c 1727 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">auto_fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argpos; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rval; <span class="hljs-comment"><span class="hljs-comment">// &lt;= argpos = 0; if (sigsetjmp(toplevel, 1)) { if (connected) disconnect(0, NULL); if (rval &gt; 0) // &lt;= rval = argpos + 1; return (rval); } .... }</span></span></code> </pre> <br>  Die Variable <i>rval</i> wurde bei der Deklaration nicht initialisiert, daher führt der Vergleich mit dem Nullwert zu einem undefinierten Ergebnis.  Wenn die Umstände fehlschlagen, kann der unsichere Wert der Variablen <i>rval</i> zu einem Rückgabewert der Funktion <i>auto_fetch</i> werden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V614</a> Nicht initialisierter Zeiger 'res' verwendet.  Befehle.c 2873 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addrinfo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_flags; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_family; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_socktype; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_protocol; <span class="hljs-keyword"><span class="hljs-keyword">socklen_t</span></span> ai_addrlen; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ai_canonname; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ai_addr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addrinfo</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ai_next</span></span></span><span class="hljs-class">;</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sourceroute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct addrinfo *ai, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **cpp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *lenp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *protop, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *optp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">1024</span></span> + ALIGNBYTES]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, *cp2, *lsrp, *ep; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_in</span></span></span><span class="hljs-class"> *_</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sin</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> INET6 struct sockaddr_in6 *sin6; struct ip6_rthdr *rth; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> struct addrinfo hints, *res; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= int error; char c; if (cpp == NULL || lenp == NULL) return -1; if (*cpp != NULL) { switch (res-&gt;ai_family) { // &lt;= case AF_INET: if (*lenp &lt; 7) return -1; break; .... } } .... }</span></span></span></span></code> </pre> <br>  Hier ist ein ähnlicher Fall der Verwendung der nicht initialisierten Variablen, außer dass <i>res</i> ein nicht initialisierter Zeiger ist, der hier stattfindet. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V506 Der</a> Zeiger auf die lokale Variable 'normalisiert' wird außerhalb des Bereichs dieser Variablen gespeichert.  Ein solcher Zeiger wird ungültig.  TextView.cpp 5596 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> BTextView::_ApplyStyleRange(...., <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BFont* font, ....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (font != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { BFont normalized = *font; _NormalizeFont(&amp;normalized); font = &amp;normalized; } .... fStyles-&gt;SetStyleRange(fromOffset, toOffset, fText-&gt;Length(), mode, font, color); }</code> </pre> <br>  Der Programmierer musste das Objekt wahrscheinlich mithilfe einer Zwischenvariablen normalisieren.  Jetzt enthält der <i>Schriftzeiger</i> den Zeiger auf das <i>normalisierte</i> Objekt, der nach dem Verlassen des Bereichs, in dem das temporäre Objekt erstellt wurde, entfernt wird. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V603</a> Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 27 <br><br><pre> <code class="cpp hljs">int8 BUnicodeChar::Type(uint32 c) { BUnicodeChar(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> u_charType(c); }</code> </pre> <br>  Ein sehr häufiger Fehler unter C ++ - Programmierern besteht darin, den Aufruf des Konstruktors zu verwenden, um angeblich Klassenfelder zu initialisieren / aufzuheben.  In diesem Fall erfolgt keine Änderung der Klassenfelder, aber ein neues unbenanntes Objekt dieser Klasse wird erstellt und sofort zerstört.  Leider gibt es viele solcher Stellen im Projekt: <br><br><ul><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 37 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 49 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 58 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 67 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 77 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 89 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 103 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 115 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 126 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 142 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 152 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 163 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 186 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 196 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 206 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 214 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 222 </li><li>  V603 Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' verwendet werden.  UnicodeChar.cpp 230 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V670</a> Das nicht initialisierte Klassenmitglied 'fPatternHandler' wird verwendet, um das 'fInternal'-Mitglied zu initialisieren.  Denken Sie daran, dass Mitglieder in der Reihenfolge ihrer Deklarationen innerhalb einer Klasse initialisiert werden.  Painter.cpp 184 <br><br><pre> <code class="cpp hljs">Painter::Painter() : fInternal(fPatternHandler), .... fPatternHandler(), .... { .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Painter</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> PainterAggInterface fInternal; <span class="hljs-comment"><span class="hljs-comment">// line 336 bool fSubpixelPrecise : 1; bool fValidClipping : 1; bool fDrawingText : 1; bool fAttached : 1; bool fIdentityTransform : 1; Transformable fTransform; float fPenSize; const BRegion* fClippingRegion; drawing_mode fDrawingMode; source_alpha fAlphaSrcMode; alpha_function fAlphaFncMode; cap_mode fLineCapMode; join_mode fLineJoinMode; float fMiterLimit; PatternHandler fPatternHandler; // line 355 mutable AGGTextRenderer fTextRenderer; };</span></span></code> </pre> <br>  Ein weiteres Beispiel für eine falsche Initialisierung.  Klassenfelder werden in der Reihenfolge ihrer Deklaration in der Klasse selbst initialisiert.  In diesem Beispiel wird das Feld " <i>Intern</i> " als erstes mit dem nicht <i>initialisierten</i> Wert " <i>fPatternHandler"</i> initialisiert. <br><br><h2>  Verdächtig #define </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V523</a> Die Anweisung 'then' entspricht der Anweisung 'else'.  subr_gtaskqueue.c 191 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TQ_LOCK(tq) \ do { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((tq)-&gt;tq_spin) \ mtx_lock_spin(&amp;(tq)-&gt;tq_mutex); \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> \ mtx_lock(&amp;(tq)-&gt;tq_mutex); \ } while (0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TQ_ASSERT_LOCKED(tq) mtx_assert(&amp;(tq)-&gt;tq_mutex, MA_OWNED) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TQ_UNLOCK(tq) \ do { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((tq)-&gt;tq_spin) \ mtx_unlock_spin(&amp;(tq)-&gt;tq_mutex); \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> \ mtx_unlock(&amp;(tq)-&gt;tq_mutex); \ } while (0) void grouptask_block(struct grouptask *grouptask) { .... TQ_LOCK(queue); gtask-&gt;ta_flags |= TASK_NOENQUEUE; gtaskqueue_drain_locked(queue, gtask); TQ_UNLOCK(queue); }</span></span></code> </pre> <br>  Dieses Code-Snippet sieht erst dann verdächtig aus, wenn Sie sich das Präprozessor-Ergebnis ansehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grouptask_block</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct grouptask *grouptask)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_spin) mtx_lock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> mtx_lock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>); gtask-&gt;ta_flags |= <span class="hljs-number"><span class="hljs-number">0x4</span></span>; gtaskqueue_drain_locked(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>, gtask); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_spin) mtx_unlock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> mtx_unlock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Der Analysator hat wirklich Recht - <i>wenn</i> und <i>sonst</i> Zweige identisch sind.  Aber wo sind die Funktionen <i>mtx_lock_spin</i> und <i>mtx_unlock_spin</i> ?  Die Makros <i>TQ_LOCK</i> , <i>TQ_UNLOCK</i> und die Funktion <i>grouptask_block</i> werden in einer Datei fast nebeneinander deklariert, dennoch fand hier irgendwo ein Ersatz statt. <br><br>  Das <i>Durchsuchen</i> der Dateien führte nur zu <i>mutex.h</i> mit folgendem Inhalt: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* on FreeBSD these are different functions */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> mtx_lock_spin(x) mtx_lock(x) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> mtx_unlock_spin(x) mtx_unlock(x)</span></span></code> </pre> <br>  Projektentwickler sollten prüfen, ob ein solcher Ersatz korrekt ist oder nicht.  Ich habe dieses Projekt unter Linux überprüft und ein solches Ersetzen schien mir verdächtig. <br><br><h2>  Fehler mit der freien Funktion </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V575</a> Der Nullzeiger wird an die Funktion 'frei' übergeben.  Überprüfen Sie das erste Argument.  setmime.cpp 727 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MimeType::_PurgeProperties() { fShort.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fLong.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fPrefApp.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fPrefAppSig.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fSniffRule.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fSmallIcon; fSmallIcon = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fBigIcon; fBigIcon = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; fVectorIcon = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= free(fVectorIcon); // &lt;= fExtensions.clear(); fAttributes.clear(); }</span></span></code> </pre> <br>  Sie können den Nullzeiger in der <i>freien</i> Funktion übergeben, aber eine solche Verwendung ist definitiv verdächtig.  Somit fand der Analysator gemischte Codezeilen.  Zuerst musste der Code-Autor den Speicher durch den <i>fVectorIcon-</i> Zeiger <i>freigeben</i> , nachdem er <i>NULL</i> zugewiesen hatte. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V575</a> Der Nullzeiger wird an die Funktion 'frei' übergeben.  Überprüfen Sie das erste Argument.  driver_settings.cpp 461 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> settings_handle * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_driver_settings_from_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *driverName)</span></span></span><span class="hljs-function"> </span></span>{ .... handle = new_settings(text, driverName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// everything went fine! return handle; } free(handle); // &lt;= .... }</span></span></code> </pre> <br>  Dies ist ein weiteres Beispiel für die explizite Übergabe eines Nullzeigers an die <i>freie</i> Funktion.  Diese Zeile kann gelöscht werden, da die Funktion nach erfolgreichem Abrufen des Zeigers beendet wird. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V575</a> Der Nullzeiger wird an die Funktion 'frei' übergeben.  Überprüfen Sie das erste Argument.  PackageFileHeapWriter.cpp 166 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* _GetBuffer() { .... <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* buffer = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(fBufferSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> &amp;&amp; !fBuffers.AddItem(buffer)) { <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(buffer); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_alloc(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer; }</code> </pre> <br>  Jemand hat hier einen Fehler gemacht.  Der Operator || muss anstelle von &amp;&amp; verwendet werden.  Nur in diesem Fall wird die Ausnahme <i>std :: bad_alloc ()</i> ausgelöst, wenn die Speicherzuweisung (mit der Funktion <i>malloc</i> ) fehlgeschlagen ist. <br><br><h2>  Fehler mit dem Löschoperator </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V611</a> Der Speicher wurde mit dem Operator 'new T []' zugewiesen, aber mit dem Operator 'delete' freigegeben.  Überprüfen Sie diesen Code.  Es ist wahrscheinlich besser, 'delete [] fMsg;' zu verwenden.  Err.cpp 65 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Err</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *fMsg; <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> fPos; }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Err::Unset() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fMsg; <span class="hljs-comment"><span class="hljs-comment">// &lt;= fMsg = __null; fPos = -1; } void Err::SetMsg(const char *msg) { if (fMsg) { delete fMsg; // &lt;= fMsg = __null; } if (msg) { fMsg = new(std::nothrow) char[strlen(msg)+1]; // &lt;= if (fMsg) strcpy(fMsg, msg); } }</span></span></code> </pre> <br>  Der <i>fMsg-</i> Zeiger wird verwendet, um Speicher für ein Array von Zeichen zuzuweisen.  Der <i>Löschoperator</i> wird verwendet, um den Speicher freizugeben, anstatt <i>[] zu löschen</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V611</a> Der Speicher wurde mit dem Operator 'new' zugewiesen, aber mit der Funktion 'free' freigegeben.  Überprüfen Sie die Operationslogik hinter der Variablen 'wrapperPool'.  vm_page.cpp 3080 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> vm_page_write_modified_page_range(....) { .... PageWriteWrapper* wrapperPool = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(malloc_flags(allocationFlags)) PageWriteWrapper[maxPages + <span class="hljs-number"><span class="hljs-number">1</span></span>]; PageWriteWrapper** wrappers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(malloc_flags(allocationFlags)) PageWriteWrapper*[maxPages]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapperPool == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || wrappers == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(wrapperPool); <span class="hljs-comment"><span class="hljs-comment">// &lt;= free(wrappers); // &lt;= wrapperPool = stackWrappersPool; wrappers = stackWrappers; maxPages = 1; } .... }</span></span></code> </pre> <br>  Hier ist <i>malloc_flags</i> eine Funktion, die <i>malloc</i> aufruft.  Dann erstellt platzierungsneu das Objekt hier.  Da die <i>PageWriteWrapper-</i> Klasse folgendermaßen implementiert wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PageWriteWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: PageWriteWrapper(); ~PageWriteWrapper(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vm_page* page)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">status_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> result)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: vm_page* fPage; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VMCache</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fCache</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fIsActive; }; PageWriteWrapper::PageWriteWrapper() : fIsActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) { } PageWriteWrapper::~PageWriteWrapper() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fIsActive) panic(<span class="hljs-string"><span class="hljs-string">"page write wrapper going out of scope but isn't completed"</span></span>); }</code> </pre> <br>  Die Objektdestruktoren dieser Klasse werden aufgrund der Verwendung der <i>freien</i> Funktion zum Freigeben von Speicher nicht aufgerufen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V611</a> Der Speicher wurde mit dem Operator 'new T []' zugewiesen, aber mit dem Operator 'delete' freigegeben.  Überprüfen Sie diesen Code.  Es ist wahrscheinlich besser, 'delete [] fOutBuffer;' zu verwenden.  Überprüfen Sie die Zeilen: 26, 45. PCL6Rasterizer.h 26 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PCL6Rasterizer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Rasterizer { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... ~PCL6Rasterizer() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fOutBuffer; fOutBuffer = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fOutBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> uchar[fOutBufferSize]; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: uchar* fOutBuffer; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fOutBufferSize; };</code> </pre> <br>  Es ist ein häufiger Fehler, den <i>Löschoperator</i> anstelle von <i>delete [] zu verwenden.</i>  Es ist am einfachsten, beim Schreiben einer Klasse einen Fehler zu machen, da der Code des Destruktors häufig weit von den Speicherorten entfernt ist.  Hier gibt der Programmierer den vom <i>fOutBuffer-</i> Zeiger im Destruktor gespeicherten Speicher fälschlicherweise frei. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V772 Das</a> Aufrufen eines Löschoperators für einen ungültigen Zeiger führt zu undefiniertem Verhalten.  Hashtable.cpp 207 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Hashtable::MakeEmpty(int8 keyMode,int8 valueMode) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (entry = fTable[index]; entry; entry = next) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (keyMode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HASH_EMPTY_DELETE: <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> destructors are not called! delete (void*)entry-&gt;key; break; case HASH_EMPTY_FREE: free((void*)entry-&gt;key); break; } switch (valueMode) { case HASH_EMPTY_DELETE: // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> destructors are not called! delete entry-&gt;value; break; case HASH_EMPTY_FREE: free(entry-&gt;value); break; } next = entry-&gt;next; delete entry; } .... }</span></span></code> </pre> <br>  Zusätzlich zu einer falschen Auswahl zwischen <i>Löschen</i> / <i>Löschen []</i> und <i>Frei</i> können Sie auch auf undefiniertes Verhalten stoßen, wenn Sie versuchen, den Speicher durch einen Zeiger auf den Void-Typ <i>(void *)</i> zu löschen. <br><br><h2>  Funktionen ohne Rückgabewert </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V591</a> Non-void-Funktion sollte einen Wert zurückgeben.  Referenceable.h 228 <br><br><pre> <code class="cpp hljs">BReference&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BReference&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Type&gt;&amp; other) { fReference = other.fReference; }</code> </pre> <br>  Einem überladenen Zuweisungsoperator fehlt ein Rückgabewert.  In diesem Fall gibt der Bediener einen zufälligen Wert zurück, was zu seltsamen Fehlern führen kann. <br><br>  Hier sind ähnliche Probleme in anderen Codefragmenten dieser Klasse: <br><br><ul><li>  V591 Non-void-Funktion sollte einen Wert zurückgeben.  Referenceable.h 233 </li><li>  V591 Non-void-Funktion sollte einen Wert zurückgeben.  Referenceable.h 239 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V591</a> Non-void-Funktion sollte einen Wert zurückgeben.  main.c 1010 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *, ...)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getoptionvalue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) errx(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"getoptionvalue() invoked with NULL name"</span></span>); c = getoption(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (c-&gt;value); errx(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"getoptionvalue() invoked with unknown option '%s'"</span></span>, name); <span class="hljs-comment"><span class="hljs-comment">/* NOTREACHED */</span></span> }</code> </pre> <br>  Der Kommentar eines Benutzers NOTREACHED bedeutet hier nichts.  Sie müssen Funktionen als noreturn mit Anmerkungen versehen, um Code für solche Szenarien ordnungsgemäß schreiben zu können.  Zu diesem Zweck gibt es noreturn-Attribute: standard und compilerspezifisch.  Zuallererst werden diese Attribute von Compilern für die ordnungsgemäße Codegenerierung oder Benachrichtigung über bestimmte Arten von Fehlern mithilfe von Warnungen berücksichtigt.  Verschiedene statische Analysewerkzeuge berücksichtigen auch Attribute, um die Analysequalität zu verbessern. <br><br><h2>  Ausnahmen behandeln </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V596</a> Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Das Schlüsselwort 'throw' könnte fehlen: throw ParseException (FOO);  Response.cpp 659 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Response::ExtractNumber(BDataIO&amp; stream) { BString <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> = ExtractString(stream); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* end; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> number = strtoul(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.String(), (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>**)&amp;end, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (end == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || end[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) ParseException(<span class="hljs-string"><span class="hljs-string">"Invalid number!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number; }</code> </pre> <br>  Das Schlüsselwort <i>throw</i> wurde hier versehentlich vergessen.  Daher wird die <i>ParseException-</i> Ausnahme nicht generiert, während das Objekt dieser Klasse beim Verlassen des Bereichs einfach zerstört wird.  Danach arbeitet die Funktion weiter, als wäre nichts passiert, als wäre die richtige Nummer eingegeben worden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1022</a> Eine Ausnahme wurde vom Zeiger ausgelöst.  Ziehen Sie es stattdessen nach Wert.  gensyscallinfos.cpp 316 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Main().Run(argc, argv); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception&amp; exception) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= fprintf(stderr, "%s\n", exception.what()); return 1; } } int Run(int argc, char** argv) { .... _ParseSyscalls(argv[1]); .... } void _ParseSyscalls(const char* filename) { ifstream file(filename, ifstream::in); if (!file.is_open()) throw new IOException(string("Failed to open '") + filename + "'."); // &lt;= .... }</span></span></code> </pre> <br>  Der Analysator hat die vom Zeiger ausgelöste <i>IOException-</i> Ausnahme erkannt.  Das Werfen eines Zeigers führt dazu, dass die Ausnahme nicht abgefangen wird.  Die Ausnahme wird also schließlich durch Bezugnahme erfasst.  Darüber hinaus zwingt die Verwendung eines Zeigers die Fangseite, den <i>Löschoperator</i> aufzurufen, um das erstellte Objekt zu zerstören, was noch nicht geschehen war. <br><br>  Einige andere Codefragmente mit Problemen: <br><br><ul><li>  V1022 Eine Ausnahme wurde vom Zeiger ausgelöst.  Ziehen Sie es stattdessen nach Wert.  gensyscallinfos.cpp 347 </li><li>  V1022 Eine Ausnahme wurde vom Zeiger ausgelöst.  Ziehen Sie es stattdessen nach Wert.  gensyscallinfos.cpp 413 </li></ul><br><h2>  Formale Sicherheit </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V597</a> Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das Objekt 'f_key' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  dst_api.c 1018 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SAFE_FREE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SAFE_FREE(a) \ do{</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(a != NULL){memset(a,0, sizeof(*a)); free(a); a=NULL;}} while (0) .... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> DST_KEY * dst_free_key(DST_KEY *f_key) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key == NULL) return (f_key); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key-&gt;dk_func &amp;&amp; f_key-&gt;dk_func-&gt;destroy) f_key-&gt;dk_KEY_struct = f_key-&gt;dk_func-&gt;destroy(f_key-&gt;dk_KEY_struct); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { EREPORT((</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dst_free_key(): Unknown key alg %d\n"</span></span></span><span class="hljs-meta">, f_key-&gt;dk_alg)); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key-&gt;dk_KEY_struct) { free(f_key-&gt;dk_KEY_struct); f_key-&gt;dk_KEY_struct = NULL; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key-&gt;dk_key_name) SAFE_FREE(f_key-&gt;dk_key_name); SAFE_FREE(f_key); return (NULL); }</span></span></code> </pre> <br>  Der Analysator hat verdächtigen Code erkannt, der für die sichere Löschung privater Daten vorgesehen ist.  Leider macht das <i>SAFE_FREE-</i> Makro, das sich in das <i>Memset</i> , <i>kostenlose</i> Aufrufe und die <i>NULL-</i> Zuweisung erweitert, den Code nicht sicherer, da alles vom Compiler direkt bei der Optimierung mit <i>O2 entfernt wird</i> . <br><br>  Übrigens ist es nichts anderes als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-14</a> : Compiler-Entfernung von Code zum Löschen von Puffern. <br><br>  Hier ist die Liste der Stellen, an denen das Löschen von Puffern tatsächlich nicht durchgeführt wird: <br><br><ul><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem der Puffer 'encoded_block' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  dst_api.c 446 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das Objekt 'key_st' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  dst_api.c 685 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem der Puffer 'in_buff' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  dst_api.c 916 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das Objekt 'ce' gelöscht wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  fs_cache.c 1078 </li></ul><br><h2>  Vergleiche mit vorzeichenlosen Variablen </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V547 Der</a> Ausdruck 'verbleibend &lt;0' ist immer falsch.  Der vorzeichenlose Typwert ist niemals &lt;0. DwarfFile.cpp 1947 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> DwarfFile::_UnwindCallFrame(....) { .... uint64 remaining = lengthOffset + length - dataReader.Offset(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remaining &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B_BAD_DATA; .... }</code> </pre> <br>  Der Analysator fand einen expliziten Vergleich der vorzeichenlosen Variablen mit negativen Werten.  Vielleicht sollte man die <i>verbleibende</i> Variable nur mit null vergleichen oder eine Überprüfung auf Überlauf durchführen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V547 Der</a> Ausdruck 'sleep ((unsigned) secs) &lt;0' ist immer falsch.  Der vorzeichenlose Typwert ist niemals &lt;0. Misc.cpp 56 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> snooze(<span class="hljs-keyword"><span class="hljs-keyword">bigtime_t</span></span> amount) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B_OK; int64 secs = amount / <span class="hljs-number"><span class="hljs-number">1000000L</span></span>L; int64 usecs = amount % <span class="hljs-number"><span class="hljs-number">1000000L</span></span>L; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (secs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sleep((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)secs) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= return errno; } if (usecs &gt; 0) { if (usleep((useconds_t)usecs) &lt; 0) return errno; } return B_OK; }</span></span></code> </pre> <br>  Um den Hauptpunkt des Fehlers zu ermitteln, gehen wir auf die Signaturen der <i>Schlaf-</i> und <i>Schlaffunktionen ein</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleep</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __seconds)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usleep</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">__useconds_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __useconds)</span></span></span></span>;</code> </pre> <br>  Wie wir sehen können, gibt die <i>Sleep-</i> Funktion den vorzeichenlosen Wert zurück und seine Verwendung im Code ist falsch. <br><br><h2>  Gefährliche Hinweise </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V774</a> Der Zeiger 'Gerät' wurde verwendet, nachdem der Speicher freigegeben wurde.  xhci.cpp 1572 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> XHCI::FreeDevice(Device *device) { uint8 slot = fPortSlots[device-&gt;HubPort()]; TRACE(<span class="hljs-string"><span class="hljs-string">"FreeDevice() port %d slot %d\n"</span></span>, device-&gt;HubPort(), slot); <span class="hljs-comment"><span class="hljs-comment">// Delete the device first, so it cleans up its pipes and tells us // what we need to destroy before we tear down our internal state. delete device; DisableSlot(slot); fDcba-&gt;baseAddress[slot] = 0; fPortSlots[device-&gt;HubPort()] = 0; // &lt;= delete_area(fDevices[slot].trb_area); delete_area(fDevices[slot].input_ctx_area); delete_area(fDevices[slot].device_ctx_area); memset(&amp;fDevices[slot], 0, sizeof(xhci_device)); fDevices[slot].state = XHCI_STATE_DISABLED; }</span></span></code> </pre> <br>  Ein <i>Geräteobjekt</i> wird vom <i>Löschoperator</i> freigegeben.  Für die <i>FreeDevice-</i> Funktion ist dies ziemlich logisch.  Aus irgendeinem Grund wird jedoch das bereits entfernte Objekt adressiert, um andere Ressourcen freizugeben. <br><br>  Ein solcher Code ist äußerst gefährlich und kann an mehreren anderen Stellen angewendet werden: <br><br><ul><li>  V774 Der 'Selbst'-Zeiger wurde verwendet, nachdem der Speicher freigegeben wurde.  TranslatorRoster.cpp 884 </li><li>  V774 Der 'String'-Zeiger wurde verwendet, nachdem der Speicher freigegeben wurde.  RemoteView.cpp 1269 </li><li>  V774 Der Zeiger 'bs' wurde verwendet, nachdem der Speicher freigegeben wurde.  mkntfs.c 4291 </li><li>  V774 Der Zeiger 'bs' wurde verwendet, nachdem der Speicher freigegeben wurde.  mkntfs.c 4308 </li><li>  V774 Der 'al'-Zeiger wurde verwendet, nachdem der Speicher neu zugewiesen wurde.  inode.c 1155 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V522 Eine</a> Dereferenzierung des Nullzeigers 'Daten' kann stattfinden.  Der Nullzeiger wird an die Funktion 'malo_hal_send_helper' übergeben.  Untersuchen Sie das dritte Argument.  Überprüfen Sie die Zeilen: 350, 394. if_malohal.c 350 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">malo_hal_fwload_helper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct malo_hal *mh, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *helper)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">/* tell the card we're done and... */</span></span> error = malo_hal_send_helper(mh, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, MALO_NOWAIT); <span class="hljs-comment"><span class="hljs-comment">// &lt;= NULL .... } static int malo_hal_send_helper(struct malo_hal *mh, int bsize, const void *data, size_t dsize, int waitfor) { mh-&gt;mh_cmdbuf[0] = htole16(MALO_HOSTCMD_CODE_DNLD); mh-&gt;mh_cmdbuf[1] = htole16(bsize); memcpy(&amp;mh-&gt;mh_cmdbuf[4], data , dsize); // &lt;= data .... }</span></span></code> </pre> <br>  Die interprozedurale Analyse ergab den Fall, dass <i>NULL</i> an die Funktion übergeben wird und der Datenzeiger mit einem solchen Wert schließlich in der <i>memcpy-</i> Funktion dereferenziert wird. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V773</a> Die Funktion wurde beendet, ohne den Zeiger 'inputFileFile' freizugeben.  Ein Speicherverlust ist möglich.  command_recompress.cpp 119 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">command_recompress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv)</span></span></span><span class="hljs-function"> </span></span>{ .... BFile* inputFileFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BFile; error = inputFileFile-&gt;SetTo(inputPackageFileName, O_RDONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error != B_OK) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Error: Failed to open input file \"%s\": %s\n"</span></span>, inputPackageFileName, strerror(error)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } inputFile = inputFileFile; .... }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio kann Speicherlecks erkennen</a> .  In diesem Beispiel wird im Falle eines Fehlers der Speicher nicht freigegeben.  Jemand könnte denken, dass Sie sich im Fehlerfall nicht um die Speicherfreigabe kümmern sollten, da das Programm immer noch endet.  Das ist aber nicht immer so.  Viele Programme müssen Fehler korrekt behandeln und weiterarbeiten. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V595</a> Der Zeiger 'fReply' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  Überprüfen Sie die Zeilen: 49, 52. ReplyBuilder.cpp 49 <br><br><pre> <code class="cpp hljs">RPC::CallbackReply* ReplyBuilder::Reply() { fReply-&gt;Stream().InsertUInt(fStatusPosition, _HaikuErrorToNFS4(fStatus)); fReply-&gt;Stream().InsertUInt(fOpCountPosition, fOpCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fReply == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || fReply-&gt;Stream().Error() == B_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fReply; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre> <br>  Es ist ein sehr häufiger Fehler, Zeiger zu dereferenzieren, bevor sie überprüft werden.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V595-</a> Diagnose hat fast immer Vorrang vor der Anzahl der Warnungen in einem Projekt.  Dieses Codefragment enthält die gefährliche Verwendung des <i>fReply-</i> Zeigers. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V595</a> Der Zeiger 'mq' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  Überprüfen Sie die Zeilen: 782, 786. oce_queue.c 782 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oce_mq_free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct oce_mq *mq)</span></span></span><span class="hljs-function"> </span></span>{ POCE_SOFTC sc = (POCE_SOFTC) mq-&gt;parent; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">oce_mbx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mbx</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mbx_destroy_common_mq</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fwcmd</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mq) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; .... }</code> </pre> <br>  Ein ähnliches Beispiel.  Der <i>mg-</i> Zeiger wird mehrere Zeilen früher dereferenziert, als er auf null geprüft wurde.  Es gibt viele ähnliche Stellen im Projekt.  In einigen Snippets sind die Verwendung und Überprüfung von Zeigern ziemlich weit voneinander entfernt. In diesem Artikel finden Sie daher nur einige Beispiele.  Entwickler können gerne weitere Beispiele im vollständigen Analysebericht lesen. <br><br><h2>  Verschiedenes </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V645</a> Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  NamespaceDump.cpp 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump_acpi_namespace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(acpi_ns_device_info *device, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *root, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> indenting)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> output[<span class="hljs-number"><span class="hljs-number">320</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tabs[<span class="hljs-number"><span class="hljs-number">255</span></span>] = <span class="hljs-string"><span class="hljs-string">""</span></span>; .... strlcat(tabs, <span class="hljs-string"><span class="hljs-string">"|--- "</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tabs)); .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (....) { uint32 type = device-&gt;acpi-&gt;get_object_type(result); <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(output, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(output), <span class="hljs-string"><span class="hljs-string">"%s%s"</span></span>, tabs, result + depth); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ACPI_TYPE_INTEGER: <span class="hljs-built_in"><span class="hljs-built_in">strncat</span></span>(output, <span class="hljs-string"><span class="hljs-string">" INTEGER"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(output)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ACPI_TYPE_STRING: <span class="hljs-built_in"><span class="hljs-built_in">strncat</span></span>(output, <span class="hljs-string"><span class="hljs-string">" STRING"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(output)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... } .... } .... }</code> </pre> <br>  Der Unterschied zwischen <i>strlcat-</i> und <i>strncat-</i> Funktionen ist für jemanden, der mit der Beschreibung dieser Funktionen nicht vertraut ist, nicht sehr offensichtlich.  Die Funktion <i>strlcat</i> erwartet die Größe des gesamten Puffers als drittes Argument, während die Funktion <i>strncat</i> - die Größe des freien Speicherplatzes in einem Puffer, für den vor dem Aufrufen der Funktion ein erforderlicher Wert ausgewertet werden muss.  Aber Entwickler vergessen es oft oder wissen es nicht.  Das Übergeben der gesamten Puffergröße an die <i>strncat-</i> Funktion kann zu einem Pufferüberlauf führen, da die Funktion diesen Wert als akzeptable Anzahl zu kopierender Zeichen betrachtet.  Die <i>strlcat-</i> Funktion hat kein solches Problem.  Sie müssen jedoch Zeichenfolgen übergeben, die mit dem Terminal null enden, damit es ordnungsgemäß funktioniert. <br><br>  Hier ist die gesamte Liste gefährlicher Orte mit Zeichenfolgen: <br><br><ul><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  NamespaceDump.cpp 104 </li><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  NamespaceDump.cpp 107 </li><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  NamespaceDump.cpp 110 </li><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  NamespaceDump.cpp 113 </li><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  NamespaceDump.cpp 118 </li><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  NamespaceDump.cpp 119 </li><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  NamespaceDump.cpp 120 </li><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  NamespaceDump.cpp 123 </li><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  NamespaceDump.cpp 126 </li><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  NamespaceDump.cpp 129 </li><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  NamespaceDump.cpp 132 </li><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  NamespaceDump.cpp 135 </li><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  NamespaceDump.cpp 138 </li><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  NamespaceDump.cpp 141 </li><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'output' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  NamespaceDump.cpp 144 </li><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'features_string' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  VirtioDevice.cpp 283 </li><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'features_string' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  VirtioDevice.cpp 284 </li><li>  V645 Der Funktionsaufruf 'strncat' kann zum Pufferüberlauf 'features_string' führen.  Die Grenzen sollten nicht die Größe des Puffers enthalten, sondern eine Anzahl von Zeichen, die er enthalten kann.  VirtioDevice.cpp 285 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V792</a> Die Funktion 'SetDecoratorSettings' befindet sich rechts vom Operator '|'  wird unabhängig vom Wert des linken Operanden aufgerufen.  Vielleicht ist es besser, '||' zu verwenden.  DesktopListener.cpp 324 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DesktopListener</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DoublyLinkedListLinkImpl&lt;DesktopListener&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDecoratorSettings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Window* window, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BMessage&amp; settings)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> DesktopObservable::SetDecoratorSettings(Window* window, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BMessage&amp; settings) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fWeAreInvoking) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-function">InvokeGuard </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invokeGuard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fWeAreInvoking)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> changed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (DesktopListener* listener = fDesktopListenerList.First(); listener != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; listener = fDesktopListenerList.GetNext(listener)) changed = changed | listener-&gt;SetDecoratorSettings(window, settings); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> changed; }</code> </pre> <br>  Höchstwahrscheinlich '|'  und '||'  Die Betreiber waren durcheinander.  Dieser Fehler führt zu unnötigen Aufrufen der <i>SetDecoratorSettings-</i> Funktion. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V627</a> Überprüfen Sie den Ausdruck.  Das Argument von sizeof () ist das Makro, das zu einer Zahl erweitert wird.  device.c 72 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PCI_line_size 0x0c </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* (1 byte) cache line size in 32 bit words */</span></span></span><span class="hljs-meta"> static status_t wb840_open(const char* name, uint32 flags, void** cookie) { .... data-&gt;wb_cachesize = gPci-&gt;read_pci_config(data-&gt;pciInfo-&gt;bus, data-&gt;pciInfo-&gt;device, data-&gt;pciInfo-&gt;function, PCI_line_size, sizeof(PCI_line_size)) &amp; 0xff; .... }</span></span></code> </pre> <br>  Das Übergeben des Werts <i>0x0c</i> an den Operator <i>sizeof</i> sieht verdächtig aus.  Vielleicht hätte der Autor die Größe eines Objekts bewerten sollen, zum Beispiel <i>Daten</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V562</a> Es ist seltsam, einen Wert vom Typ Bool mit einem Wert von 18 zu vergleichen: 0x12 == IsProfessionalSpdif ().  CEchoGals_mixer.cpp 533 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BOOL; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsProfessionalSpdif</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ECHOSTATUS_DSP_DEAD 0x12 ECHOSTATUS CEchoGals::ProcessMixerFunction(....) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( ECHOSTATUS_DSP_DEAD == IsProfessionalSpdif() ) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= { Status = ECHOSTATUS_DSP_DEAD; } else { pMixerFunction-&gt;Data.bProfSpdif = IsProfessionalSpdif(); } .... }</span></span></span></span></code> </pre> <br>  Die Funktion <i>IsProfessionalSpdif</i> gibt den Wert des <i>Bool-</i> Typs zurück.  Dabei wird das Ergebnis der Funktion mit der Zahl <i>0x12</i> in der Bedingung verglichen. <br><br><h2>  Fazit </h2><br>  Wir haben die Veröffentlichung der ersten Haiku-Beta im letzten Herbst verpasst, da wir gerade mit der Veröffentlichung von PVS-Studio für Java beschäftigt waren.  Programmierfehler sind jedoch so beschaffen, dass sie nicht verschwinden, wenn Sie nicht nach ihnen suchen und nicht auf die Codequalität achten.  Die Projektentwickler verwendeten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Coverity Scan</a> , aber der letzte Lauf war vor fast zwei Jahren.  Dies muss für Haiku-Benutzer ärgerlich sein.  Obwohl die Analyse 2014 mit Coverity konfiguriert wurde, hat sie uns nicht davon abgehalten, 2015 zwei lange Artikel zur Fehlerüberprüfung zu schreiben ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> ). <br><br>  Eine weitere Haiku-Überprüfung der Fehler erscheint in Kürze für diejenigen, die diesen Beitrag bis zum Ende lesen.  Der vollständige Analysatorbericht wird an die Entwickler gesendet, bevor diese Fehlerüberprüfung veröffentlicht wird. Daher können einige Fehler behoben sein, wenn Sie diese lesen.  Um die Zeit zwischen den Artikeln zu vertreiben, empfehle ich, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio</a> für Ihr Projekt herunterzuladen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auszuprobieren</a> . <br><br>  Möchten Sie Haiku ausprobieren und haben Fragen?  Haiku-Entwickler laden Sie zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegrammkanal ein</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461253/">https://habr.com/ru/post/de461253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461241/index.html">Wolfram Mathematica in Geophysik</a></li>
<li><a href="../de461243/index.html">Gehen Sie nicht nach Afrika spazieren: Wie ist die Situation mit der Internet-Zensur auf dem schwarzen Kontinent?</a></li>
<li><a href="../de461247/index.html">50 beste Quellen zum Produktmanagement zum Lesen, Hören und Anschauen</a></li>
<li><a href="../de461249/index.html">Schreiben einer Android App für Filmfans - Teil 2 (Design)</a></li>
<li><a href="../de461251/index.html">Eine Auswahl nützlicher Folien von Julia Evans</a></li>
<li><a href="../de461255/index.html">Wie man sich in C und C ++ in den Fuß schießt. Haiku OS Rezeptsammlung</a></li>
<li><a href="../de461257/index.html">Wie berechnet man den ROI aus der Testautomatisierung mit Selen?</a></li>
<li><a href="../de461259/index.html">Lagerparty, 8. August, Moskau</a></li>
<li><a href="../de461261/index.html">Checkliste nützlicher RRC-Webinare zu RRC-Produkten</a></li>
<li><a href="../de461265/index.html">Über den Missbrauch der Verwendung des Betriebssystems in Projekten für Mikrocontroller</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>