<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¥– ğŸ© ğŸ‘©ğŸ½â€ğŸ« Bereaksi pada Î»ambda ğŸ•°ï¸ ğŸ¥• ğŸ§œğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tanpa upacara khusus, kami akan mulai mendistribusikan bream dan berteriak tentang fungsionalisme, dan omong-omong, halo semua orang! 


 Dengan penge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bereaksi pada Î»ambda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449114/"><p><img src="https://habrastorage.org/webt/zy/o3/p1/zyo3p1946w7q4jmpgf8bvm5d-dg.png"></p><br><p>  Tanpa upacara khusus, kami akan mulai mendistribusikan bream dan berteriak tentang fungsionalisme, dan omong-omong, halo semua orang! </p><br><p>  Dengan pengembangan, reagen dengan lancar menghilangkan ketidakmurnian OOP dan semakin mendekati pendekatan pemrograman fungsional.  Pada awalnya, komponen orde tinggi (HOC) muncul di dalamnya alih-alih mixin, lalu komponen tanpa kewarganegaraan hampir merupakan pengganti kelas, dan di sini adalah brengsek terakhir, kait yang diluncurkan yang benar-benar menghilangkan kelas reaksi. </p><br><p>  Saya tidak tahu ke mana cabang pengembangan selanjutnya akan mengarah, tetapi saya dapat dengan yakin mengatakan sudah waktunya untuk menyingkirkan BEJ, dan ya mendukung fungsi-fungsi itu.  Jika Sergey Druzhko bersama kami, kami akan mendengar: </p><br><p>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Pernyataan yang kuat, saya pasti tidak akan memeriksanya</a> .</em> </p><br><p>  Tapi saya mengundang Anda untuk memeriksanya, atau lebih tepatnya memperkirakan reaksi apa yang bisa terjadi tanpa BEJ. </p><a name="habracut"></a><br><br>
<h3 id="korolevstvo-shablonov">  Kerajaan pola </h3><br><p>  Dalam dunia templat, segala sesuatu berputar di sekitar keagungan-Nya teks, Anda terjun ke telinga dan melanjutkan ke bisnis kotor, yaitu, memasukkan kode, menunjukkan di mana harus mengulang, dan di mana untuk menunjukkan atau menyembunyikan sesuatu.  Dan untuk menunjukkan batas antara teks dan kode, antena (kurung kurawal), tag atau arahan lain digunakan. </p><br><img src="https://habrastorage.org/webt/o7/d3/fk/o7d3fkbj95eydzhu8mehsnithx8.png" width="320"><br><br><p>  Tidak seperti mesin template, di JSX, transisi dari kode ke HTML terjadi secara otomatis tanpa markup dan transisi ini dapat diulang secara rekursif.  Itulah sebabnya Anda dapat mendengar kritik terhadap JSX, mengatakan bahwa Anda sedang menyandikan JS di dalam HTML, dan di dalamnya JS adalah HTML lain yang disematkan, dll. </p><br><p>  Nah, untuk sisanya, JSX adalah mesin template yang sama, tetapi semua karena pada awalnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">XHP</a> memengaruhi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">reaksi</a> , sebenarnya itu adalah PHP yang disetel oleh Facebook.  Jika reaktivitas murni kecil, yang ada hubungannya dengan XHP, maka JSX adalah saudara kembarnya, tetapi hanya di dunia JavaScript. </p><br><p>  Tidak ada yang salah dengan mesin templat, sebaliknya itu adalah alat yang sangat nyaman untuk bekerja dengan teks.  Namun, untuk pengembangan komponen, fungsi adalah alat yang paling tepat.  Sebuah pertanyaan logis mungkin muncul: bagaimana fungsi dapat menyederhanakan pekerjaan pada teks? </p><br><p>  Lagi pula, sekarang Anda mendapatkan HTML + CSS dari tata letak / perancang, dengan cepat memasukkan antena atau arahan di sana, dan komponen sudah siap, atau bahkan melihat seluruh halaman.  Ya, tentu di sini kerangka kerja seperti Vue / Angular sedang meluncur keluar dan reaksi kami diam-diam menangis.  Sayangnya, dalam praktiknya saya belum pernah bertemu dengan perancang yang menyediakan HTML + CSS, dan penyetel adalah karakter mitos yang belum pernah dijumpai seorang pun dalam kehidupan, dan dalam kehidupan banyak perusahaan, bahkan perancang pada staf adalah makhluk fiksi, dan semua pekerjaan ini dilakukan , kanan - ujung depan.  Itulah sebabnya seringkali dalam persyaratan pekerjaan kami menemukan yang berikut: </p><br><p>  <em>- Pengalaman kerja di Bootstrap versi kedelapan selama setidaknya 10 tahun.</em> </p><br><p>  Jika ini adalah kasus Anda, maka tidak ada perbedaan di sana: mengeset di awal HTML dengan antena atau segera bam komponen pada fungsi murni.  Meskipun tentu saja ada perbedaan dengan fungsinya, Anda akan memiliki lebih sedikit untuk mengetuk tombol. <br><br></p><br><h3 id="korolevstvo-funkcii">  Fungsi kerajaan </h3><br><p>  Kemungkinan besar, Anda sudah menebak bahwa Yang Mulia akan memerintah di dunia ini, dan segala sesuatu di sekitar akan memiliki fungsi, sekarang komponen adalah fungsi, tag juga fungsi, dalam kerajaan ini diskriminasi akan mempengaruhi variabel genap, dan sekali lagi mendukung fungsi.  Rasisme total. </p><br><p>  Namun, di dunia ini, tidak semua fungsi sama, ada fungsi mutts yang biasa, dan ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi</a> bangsawan - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kari</a> , rupanya Sir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Curry Haskell sendiri</a> menganugerahkan gelar ini kepadanya. </p><br><p>  Lebih jauh dalam contoh, saya akan menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">react-on-lambda</a> dari penulis tertentu - saya, tetapi tidak ada yang mencegah Anda membuat sepeda sendiri. </p><br><p>  Ok, mari kita lihat para bangsawan ini: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Î» <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-on-lambda'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> postLink = Î».a({<span class="hljs-attr"><span class="hljs-attr">href</span></span>: <span class="hljs-string"><span class="hljs-string">`/posts/123`</span></span>})</code> </pre> <br><p>  Pada pandangan pertama, fungsi biasa, tetapi ada fitur karakteristik, <strong>postLink</strong> belum menjadi elemen HTML atau bahkan elemen reaksi, tetapi fungsi di mana Anda dapat memasukkannya dan akan selalu mengembalikan fungsi hingga kami memberikannya elemen anak dalam bentuk: string, angka, fungsi lambda lain atau nilai kosong, dan kemudian keajaiban akan terjadi, elemen reaksi akan dikembalikan, yang pada akhirnya akan dikonversi ke HTML. </p><br><p>  Misalnya, seperti ini: </p><br><pre> <code class="javascript hljs">postLink(<span class="hljs-string"><span class="hljs-string">`Read more`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// JSX equivalent &lt;a href=â€/posts/123â€&gt;Read more&lt;/a&gt;</span></span></code> </pre> <br><p>  Ah, ya, huruf Yunani bisa membingungkan Anda: abaikan saja, Anda bisa menggantinya dengan pengenal lain, misalnya: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> l <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-on-lambda'</span></span> <span class="hljs-comment"><span class="hljs-comment">// or import {div, h1} from 'react-on-lambda'</span></span></code> </pre> <br><p>  Saya pikir jenis quirks ini bukan pertama kalinya dalam js, bagi kami ini sudah seperti karakter asli <strong>$ _</strong> , akan tampak seperti beberapa koneksi dengan dolar dan apa pun untuk manipulasi DOM.  Dan lambda memenuhi selera saya, karena itu menggemakan nama lib itu sendiri. </p><br><p>  Jadi selama pelaksanaan program, sifat-sifat elemen / komponen dapat dirangkai dari bagian yang berbeda tanpa menggunakan variabel global, dan yang paling penting, Anda dapat membangun komposisi bebas titik: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> title = Î».compose( Î».h1({<span class="hljs-attr"><span class="hljs-attr">className</span></span>: <span class="hljs-string"><span class="hljs-string">`post-title`</span></span>}), postLink ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> post = Î».div( title(<span class="hljs-string"><span class="hljs-string">`How to use react on lambda?`</span></span>), Î».p(<span class="hljs-string"><span class="hljs-string">` Lorem ipsum dolor sit amet, Ernestina Urbanski consectetur adipiscing elit. Ut blandit viverra diam luctus luctus... `</span></span>), postLink(<span class="hljs-string"><span class="hljs-string">`Read more`</span></span>) ) render( post, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">`app`</span></span>) )</code> </pre> <br><p>  Dengan menggunakan komposisi, kami membuat fungsi <strong>judul</strong> baru, yang terdiri dari dua fungsi lainnya, <strong>h1</strong> dan <strong>postLink</strong> .  Melewati nilai ke <strong>judul,</strong> kami mendapatkan judul yang dapat diklik dengan teks: "Bagaimana cara menggunakan bereaksi pada lambda?".  Dalam komposisi, hasil dari satu fungsi ditransfer ke yang lain, dengan aliran data pergi dari bawah ke atas. </p><br><img src="https://habrastorage.org/webt/5c/ps/wc/5cpswcjh8l4wkjkr5wm5s0qf7zw.png" width="320"><br><br><p>  Berkat fitur ini, fungsi dalam komposisi ditempatkan tanpa bersarang.  Ingat callback sebelum <strong>Promise</strong> dan <strong>async / menunggu muncul</strong> , bagaimana mereka tegang, dan bagaimana mereka tidak memanggil mereka: kode spaghetti, callback hell, piramida malapetaka, pohon natal dari neraka, tetapi untuk beberapa alasan bersarang bertingkat di HTML tidak mengganggu siapa pun. </p><br><p>  Selanjutnya, kami sekali lagi menerapkan <strong>postLink</strong> , tetapi dengan parameter yang berbeda, jadi kami menggunakan fungsi lebih dari sekali.  Tentu saja, ini bisa dilakukan dengan JSX, membungkusnya dalam suatu fungsi, tetapi kemudian kita sampai pada pertanyaan utama, atau bisakah kita menggunakan fungsi saja daripada JSX? </p><br><br><h3 id="korolevstvo-react-on-ambda">  Kingdom Bereaksi pada Î»ambda </h3><br><p>  Alih-alih, itu bukan kerajaan, tetapi sebuah daerah kecil di kerajaan fungsi.  Saya sarankan untuk mengenal <a href="">Bereaksi pada lambda</a> lebih baik: </p><br><p>  Fitur utama perpustakaan: </p><br><ul><li>  output akan mendapatkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ukuran bundel yang lebih kecil</a> , hingga 20% dibandingkan dengan proyek serupa yang ditulis dalam BEJ; </li><li>  tidak diperlukan transpiler (babel) atau pengaturan webpack terpisah; bekerja langsung di browser; </li><li>  integrasi tanpa batas ke proyek reaksi yang ada dengan BEJ. </li></ul><br><p>  Untuk pengantar yang lebih rinci, saya sarankan melihat proyek demo: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">meja putar</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rol-todos</a> </li></ul><br><br><p>  <strong>Kreasionisme dalam RoL</strong> </p><br><p>  Untuk membuat elemen reaksi, cukup ketik: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Î», {div} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-on-lambda'</span></span> div({<span class="hljs-attr"><span class="hljs-attr">class</span></span>: <span class="hljs-string"><span class="hljs-string">`sample`</span></span>}, <span class="hljs-string"><span class="hljs-string">`Hello world!`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// you can use class instead className // JSX equivalent &lt;div className=â€sampleâ€&gt;Hello world!&lt;/div&gt;</span></span></code> </pre> <br><p>  Properti dapat tumpang tindih: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> span = Î».span({<span class="hljs-attr"><span class="hljs-attr">class</span></span>: <span class="hljs-string"><span class="hljs-string">`large`</span></span>}) <span class="hljs-comment"><span class="hljs-comment">// -&gt; function span({class: `small`}, `Sorry we changed our mind`) // JSX equivalent &lt;span className="small"&gt;Sorry we changed our mind&lt;/span&gt;</span></span></code> </pre> <br><p>  Cukup dengan membungkus komponen <strong>Î» yang ada</strong> untuk mendapatkan fungsi dan semua roti FP dari mereka. </p><br><pre> <code class="javascript hljs">Î»(Provider, {store}, app) <span class="hljs-comment"><span class="hljs-comment">// JSX equivalent &lt;Provider store={store}&gt;&lt;App/&gt;&lt;/Provider&gt;</span></span></code> </pre> <br><p>  Semua fungsi lambda anak akan dipanggil secara otomatis oleh elemen induk: </p><br><pre> <code class="javascript hljs">Î».div( Î».div({<span class="hljs-attr"><span class="hljs-attr">class</span></span>: <span class="hljs-string"><span class="hljs-string">`followers`</span></span>}), Î».br )</code> </pre> <br><p>  Artinya, tidak perlu memanggil mereka: </p><br><pre> <code class="javascript hljs">Î».div( Î».div({<span class="hljs-attr"><span class="hljs-attr">class</span></span>: <span class="hljs-string"><span class="hljs-string">`followers`</span></span>})(), Î».br() )()</code> </pre> <br><p>  Ini dilakukan untuk kenyamanan dan kemudahan integrasi dengan perpustakaan lain, seperti redux. </p><br><p>  Dan kemudian saya akan secara singkat memperkenalkan Anda ke fungsi bantu lainnya.  Saya ingin mengingatkan Anda bahwa semua subjek dari <strong>react-on-lambda</strong> adalah fungsi kari. </p><br><br><h3 id="mapkey">  Î».mapKey </h3><br><p>  Fungsi mapKey digunakan untuk beralih di atas array. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pages = [<span class="hljs-string"><span class="hljs-string">`Home page`</span></span>, <span class="hljs-string"><span class="hljs-string">`Portfolio`</span></span>, <span class="hljs-string"><span class="hljs-string">`About`</span></span>] Î».ul( Î».mapKey(Î».li, pages) ) <span class="hljs-comment"><span class="hljs-comment">// JSX equivalent &lt;ul&gt; {pages.map((item, key) =&gt; &lt;li key={key}&gt; {item} &lt;/li&gt; )} &lt;/ul&gt;</span></span></code> </pre> <br><p>  Penyisipan kunci (kunci) akan otomatis dan akan sama dengan indeks elemen dari array.  Penyisipan kunci otomatis hanya akan terjadi jika kunci belum dikirim. </p><br><br><h3 id="mapprops">  Î».mapProps </h3><br><p>  Berfungsi untuk mengkonversi properti suatu objek.  Fungsi yang cukup kontroversial, dapat diperoleh dari perpustakaan pihak ketiga lainnya, tetapi saya memutuskan untuk meninggalkannya. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = [ {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">`Albert`</span></span>, <span class="hljs-attr"><span class="hljs-attr">surname</span></span>: <span class="hljs-string"><span class="hljs-string">`Einstein`</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">124</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">`Daimaou `</span></span>, <span class="hljs-attr"><span class="hljs-attr">surname</span></span>: <span class="hljs-string"><span class="hljs-string">`Kosaka`</span></span>}, ] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userList = Î».compose( Î».div({<span class="hljs-attr"><span class="hljs-attr">class</span></span>: <span class="hljs-string"><span class="hljs-string">`followers`</span></span>}), Î».ul, Î».mapKey(Î».li), Î».mapProps({<span class="hljs-attr"><span class="hljs-attr">key</span></span>: <span class="hljs-string"><span class="hljs-string">`id`</span></span>, <span class="hljs-attr"><span class="hljs-attr">children</span></span>: <span class="hljs-string"><span class="hljs-string">`name`</span></span>}) ) userList(data) <span class="hljs-comment"><span class="hljs-comment">// JSX equivalent const UserList = props =&gt; ( &lt;div className="followers"&gt; &lt;ul&gt; {props.data.map(user =&gt; &lt;li key={user.id}&gt; {user.name} &lt;/li&gt; )} &lt;/ul&gt; &lt;/div&gt; ) &lt;UserList data={data}/&gt;</span></span></code> </pre> <br><br><h3 id="log">  Î».log </h3><br><p>  Fungsi untuk debugging: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userList = Î».compose( Î».div, Î».ul, Î».log(<span class="hljs-string"><span class="hljs-string">`after mapping`</span></span>), <span class="hljs-comment"><span class="hljs-comment">// -&gt; will log piping value Î».mapKey(Î».li) )</span></span></code> </pre> <br><h3 id="stilizaciya-komponentov">  Styling Komponen </h3><br><p>  Untuk pecinta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komponen yang ditata</a> , ada pembungkus bawaan yang mengembalikan komponen yang ditata sebagai fungsi: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Î» <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-on-lambda'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> header = Î».h1<span class="hljs-string"><span class="hljs-string">` color: #ff813f; font-size: 22px; `</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> alert(<span class="hljs-string"><span class="hljs-string">`Hi!`</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = Î».div( header(<span class="hljs-string"><span class="hljs-string">`Welcome to React on Î»amda!`</span></span>), Î».button({onClick}, <span class="hljs-string"><span class="hljs-string">`OK`</span></span>) )</code> </pre> <br><p>  Saya sengaja tidak mengisi perpustakaan dengan fungsi lain, karena banyak chip dapat diperoleh dari perpustakaan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ramda</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rambda</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lodash / fp</a> . </p><br><p>  Yah itu saja, saya akan senang mendengar tanggapan Anda. </p><br><br><p>  Jaga dirimu, semoga functor suci bersamamu! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449114/">https://habr.com/ru/post/id449114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449100/index.html">Setelah RTM. Investigasi forensik komputer yang terinfeksi trojan perbankan</a></li>
<li><a href="../id449106/index.html">UPS untuk lembaga perbankan dan keuangan</a></li>
<li><a href="../id449108/index.html">UDB. Apa ini Bagian 7. Pengaturan waktu dan reset modul kontrol</a></li>
<li><a href="../id449110/index.html">Memperbaiki bug yang terkait dengan ketidakmampuan untuk menggunakan alfabet Cyrillic dalam nama folder IMAP</a></li>
<li><a href="../id449112/index.html">Kami pensiun - kami membahas gadget audio yang dulu populer yang sudah "kedaluwarsa"</a></li>
<li><a href="../id449118/index.html">Kremlin Demon Pill</a></li>
<li><a href="../id449120/index.html">Dengan janggut, kacamata gelap dan profil: situasi sulit untuk penglihatan komputer</a></li>
<li><a href="../id449122/index.html">Menyesali ulang ketidakhadiran dalam C ++ dari statis penuh jika atau ...</a></li>
<li><a href="../id449124/index.html">Sangat sulit ditemukan, mudah dilewatkan, dan mustahil dikeluarkan</a></li>
<li><a href="../id449128/index.html">Perusahaan pengembang game top di dunia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>