<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧟 👩🏼‍🏭 👨🏿‍🏭 Highload ++: So helfen Sie dem ERP-System, 500.000 Anfragen pro Sekunde zu bewältigen 👩🏿‍🏭 👶🏻 ✴️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir bei X5 verarbeiten viele Daten in einem ERP-System. Es wird angenommen, dass uns sonst niemand in SAP ERP und SAP BW in Russland verarbeitet. Aber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Highload ++: So helfen Sie dem ERP-System, 500.000 Anfragen pro Sekunde zu bewältigen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/X5RetailGroup/blog/432412/">  Wir bei X5 verarbeiten viele Daten in einem ERP-System.  Es wird angenommen, dass uns sonst niemand in SAP ERP und SAP BW in Russland verarbeitet.  Aber es gibt noch einen anderen Punkt: Die Anzahl der Operationen und die Belastung dieses Systems nehmen rapide zu.  3 Jahre lang haben wir um die Leistung unseres ERP-Schwergewichts „gekämpft“, viele Zapfen bekommen und mit welchen Methoden sie behandelt wurden, sagen wir unter dem Schnitt. <br><br><img src="https://habrastorage.org/webt/5h/bu/5x/5hbu5xxbs9yb6vojgiy-2wl06hk.png" alt="Bild"><br><a name="habracut"></a><br><h2>  ERP X5 </h2><br>  Jetzt betreibt X5 mehr als 13.000 Geschäfte.  Die meisten Geschäftsprozesse eines jeden von ihnen durchlaufen ein einziges ERP-System.  Jedes Geschäft kann zwischen 3.000 und 30.000 Produkte haben, was zu Problemen mit der Systemlast führt, weil  Prozesse der regelmäßigen Neuberechnung von Preisen durchlaufen sie in Übereinstimmung mit Beförderungen und gesetzlichen Anforderungen sowie der Berechnung der Wiederauffüllung von Lagerbeständen.  All dies ist von entscheidender Bedeutung. Wenn nicht rechtzeitig berechnet wird, welche Waren in welcher Menge morgen in das Geschäft geliefert werden sollen oder welcher Preis für die Waren gelten soll, finden Käufer in den Regalen nicht das, wonach sie gesucht haben, oder können die Waren nicht zum Preis der aktuellen Aktion kaufen Aktien.  Im Allgemeinen ist das ERP-System neben der Bilanzierung von Finanztransaktionen für einen Großteil des Alltags in jedem Geschäft verantwortlich. <br><br>  Einige Leistungsmerkmale eines ERP-Systems.  Die Architektur ist klassisch, dreistufig mit serviceorientierten Elementen: Darüber hinaus haben wir mehr als 5.000 Kunden und Terabyte an Informationsflüssen aus Filialen und Distributionszentren in der Anwendungsschicht - SAP ABAP mit mehr als 10.000 Prozessen und schließlich Oracle Database mit mehr als 100 TB Daten.  Jeder ABAP-Prozess ist eine bedingt virtuelle Maschine, auf der ABAP-Geschäftslogik mit einem eigenen DBSL- und SQL-Dialekt, Caching, Speicherverwaltung, ORM usw. ausgeführt wird.  Jeden Tag erhalten wir mehr als 15 TB Änderungen im Datenbankprotokoll.  Die Laststufe beträgt 500.000 Anforderungen pro Sekunde. <br><br>  Diese Architektur ist eine heterogene Umgebung.  Jede der Komponenten ist plattformübergreifend. Wir können sie auf verschiedene Plattformen verschieben, die optimalen auswählen usw. <br><br>  Die Tatsache, dass das ERP-System 365 Tage im Jahr 24 Stunden am Tag unter Last steht, fügt dem Feuer Treibstoff hinzu.  Verfügbarkeit - 99,9% der Zeit während des ganzen Jahres.  Die Ladung ist in Tag- und Nachtprofile und Hauswirtschaft in der Freizeit unterteilt. <br><br>  Das ist aber noch nicht alles.  Das System hat einen engen und engen Freigabezyklus.  Es werden über 2.000 Chargenwechsel pro Jahr durchgeführt.  Dies kann eine neue Schaltfläche und schwerwiegende Änderungen in der Logik von Geschäftsanwendungen sein. <br><br><img src="https://habrastorage.org/webt/xa/g3/xi/xag3xio65zfdslyhgosbjrmtakw.png" alt="Bild"><br><br>  Infolgedessen ist es ein großes und hoch ausgelastetes, aber gleichzeitig stabiles, vorhersehbares und wachstumsfähiges System, das Zehntausende von Geschäften beherbergen kann.  Das war aber nicht immer der Fall. <br><br><h2>  2014. Bifurkationspunkt </h2><br>  Um in das praktische Material einzutauchen, müssen Sie bis 2014 zurückgehen.  Dann gab es die schwierigsten Aufgaben, um das System zu optimieren.  Es gab ungefähr 5.000 Geschäfte. <br><br>  Das System befand sich zu diesem Zeitpunkt in einem solchen Zustand, dass die meisten kritischen Prozesse nicht skalierbar waren und nicht angemessen auf die wachsende Last (dh das Erscheinen neuer Geschäfte und Waren) reagierten.  Außerdem wurde zwei Jahre zuvor ein teures Hi-End gekauft, und für einige Zeit war ein Upgrade nicht Teil unserer Pläne.  Darüber hinaus standen die Prozesse in ERP bereits kurz vor dem Verstoß gegen SLA.  Der Anbieter kam zu dem Schluss, dass die Belastung des Systems nicht skalierbar ist.  Niemand wusste, ob sie mindestens + 10% des Lastanstiegs aushalten konnte.  Und es war geplant, innerhalb von drei Jahren doppelt so viele Geschäfte zu eröffnen. <br><br>  Es war unmöglich, das ERP-System einfach mit neuem Eisen zu versorgen, und es würde nicht helfen.  Daher haben wir uns zunächst entschlossen, eine Softwareoptimierungstechnik in den Release-Zyklus aufzunehmen und die Regel zu befolgen: Das lineare Lastwachstum im Verhältnis zum Wachstum der Lasttreiber ist der Schlüssel zur Vorhersagbarkeit und Skalierbarkeit. <br><br>  Was war die Optimierungstechnik?  Dies ist ein zyklischer Prozess, der in mehrere Phasen unterteilt ist: <br><br><ul><li>  Überwachung (Ermittlung von Engpässen im System und Ermittlung der Hauptverbraucher von Ressourcen) </li><li>  Analyse (Profilierung von Verbraucherprozessen, Identifizierung von Strukturen mit dem größten und nichtlinearen Einfluss auf die Last) </li><li>  Entwicklung (Verringerung des Einflusses von Strukturen auf die Last, Erreichen einer linearen Last) </li><li>  Testen in einer Qualitätsbewertungsumgebung oder Implementierung in einer produktiven Umgebung </li></ul><br>  Als nächstes wurde der Zyklus wiederholt. <br><br>  Dabei haben wir festgestellt, dass die aktuellen Überwachungstools es uns nicht ermöglichen, Top-Verbraucher, Engpässe und ressourcenhungrige Prozesse schnell zu identifizieren.  Um dies zu beschleunigen, haben wir die elastischen Such- und Grafana-Tools ausprobiert.  Zu diesem Zweck entwickelten sie unabhängig voneinander Kollektoren, die von Standardüberwachungstools in Oracle / SAP / AIX / Linux Metriken auf die elastische Suche übertrugen und eine Echtzeitüberwachung des Systemzustands ermöglichten.  Darüber hinaus bereicherten sie die Überwachung mit ihren benutzerdefinierten Metriken, z. B. Antwortzeit und Durchsatz bestimmter SAP-Komponenten oder Layout von Lastprofilen für Geschäftsprozesse. <br><img src="https://habrastorage.org/webt/m2/k3/dz/m2k3dzdu-nz384_pz4phtnlvkc0.png" alt="Bild"><br><br><h2>  Code- und Prozessoptimierung </h2><br>  Erstens sorgten sie für eine geringere Auswirkung von Engpässen auf die Geschwindigkeit für eine reibungslosere Lastversorgung des Systems. <br><br>  Die meisten Geschäftsprozesse in unserem ERP-System, wie z. B. die regelmäßige Preisgestaltung oder die Bestandsauffüllungsplanung, sind die schrittweise Verarbeitung einer großen Datenmenge (für alle Waren und alle Filialen).  Um die Verarbeitung im Rahmen derart schwieriger Aufgaben zu implementieren, haben wir einmal einen eigenen Batch-Parallel-Processing-Dispatcher entwickelt (im Folgenden als Load Scheduler bezeichnet).  In diesem Fall wird in Form eines Pakets ein separat durchgeführter Verarbeitungsschritt für ein separates Geschäft dargestellt. <br><br>  Anfänglich war die Logik des Schedulers so, dass zuerst die Pakete der ersten Verarbeitungsstufe für alle Speicher ausgeführt wurden, dann die Pakete der zweiten Stufe usw.  Das heißt, das System führte gleichzeitig Prozesse aus, die denselben Lasttyp erzeugten und die Verschlechterung bestimmter Ressourcen verursachten (Eingabe-Ausgabe in die Datenbank oder CPU auf Anwendungsservern usw.). <br><img src="https://habrastorage.org/webt/kj/_r/sf/kj_rsf_nxsu309iuygujkxzavty.png" alt="Bild"><br><br>  Wir haben die Logik des Schedulers so umgeschrieben, dass die Paketkette für jedes Geschäft separat gebildet wurde und die Priorität beim Starten neuer Pakete nicht nach Stufen, sondern nach Geschäften erstellt wurde. <br><img src="https://habrastorage.org/webt/rc/_3/kw/rc_3kwnwqdi_hemnvuxnpmps_q0.png" alt="Bild"><br><br>  Aufgrund der unterschiedlichen Dauer der Pakete für verschiedene Filialen und der kontrollierten großen Anzahl gleichzeitig ausgeführter Prozesse im Rahmen der Aufgaben des Load Scheduler haben wir die gleichzeitige Ausführung heterogener Prozesse, eine reibungslosere Beladung der Load und die Beseitigung einiger Engpässe erreicht. <br><br>  Dann begannen sie, einzelne Designs zu optimieren.  Jedes einzelne Paket wurde überprüft, profiliert und nicht optimale Designs zusammengestellt und Ansätze angewendet, um sie zu optimieren.  Anschließend wurden diese Ansätze in die Vorschriften des Entwicklers aufgenommen, um ein unerwünschtes Lastwachstum während der Entwicklung des Systems zu verhindern.  Einige von ihnen: <br><br><ul><li>  Übermäßige Belastung der CPU von Anwendungsservern (Wird häufig durch nichtlineare Algorithmen im Programmcode generiert, z. B. die gute alte lineare Suche in Schleifen oder nichtlineare Suchalgorithmen für Schnittpunkte von Sätzen ungeordneter Elemente usw. ... Es wurde durch Ersetzen durch lineare Algorithmen behandelt: Ersetzen der linearen Suche in Schleifen durch Binär; Um nach Schnittpunkten von Mengen zu suchen, verwenden wir lineare Algorithmen, Vorbestellungselemente usw.) </li><li>  Identische Aufrufe der Datenbank mit denselben Bedingungen innerhalb desselben Prozesses führen häufig zu einer übermäßigen CPU-Auslastung der Datenbank (dies wird behandelt, indem die Ergebnisse des ersten Beispiels im Programmspeicher oder auf der Ebene des Anwendungsservers zwischengespeichert werden und zwischengespeicherte Daten für nachfolgende Beispiele verwendet werden). </li><li>  Häufige Join-Anforderungen (es ist natürlich besser, sie auf Datenbankebene auszuführen, aber manchmal haben wir uns erlaubt, sie in einfache Beispiele aufzuteilen, deren Ergebnis zwischengespeichert wird, und die Klebelogik an die Anwendung zu übertragen. In diesen Fällen ist es besser, den Anwendungsserver und nicht die Datenbank aufzuwärmen. ) </li><li>  Starke Join-Anforderungen führen zu vielen E / A. </li></ul><br>  Über letzteres im Detail.  In diesem Fall wurde das Datenmodell in eine weniger normale Form übersetzt.  Ein klassisches Beispiel ist eine Auswahl von Buchhaltungsbelegen für ein bestimmtes Datum für ein einzelnes Geschäft.  Viele Mitarbeiter fordern es an.  Die Haupttabelle (Überschriften-Tabelle) speichert die Daten der Dokumente in der Positionstabelle - das Geschäft und die Waren.  Die häufigsten Abfragen sind eine Auswahl aller Dokumente für ein bestimmtes Geschäft für ein bestimmtes Datum.  Bei dieser Anforderung gibt der Filter nach Datum in der Überschriften-Tabelle 500.000 Datensätze an, der Filter nach Speicher - die gleiche Menge.  Gleichzeitig haben wir nach dem Aufkleben eines separaten Geschäfts zum richtigen Datum eine Laufzeit von 3.000.  Unabhängig davon, aus welcher Tabelle wir Daten filtern und kleben, erhalten wir immer viele unerwünschte E / A. <br><img src="https://habrastorage.org/webt/rw/dp/kr/rwdpkruti_tjhpazqtcoonzpeq0.png" alt="Bild"><br><br>  Dies kann vermieden werden, indem die Daten in einer weniger normalen Form dargestellt werden.  In einem Fall wurde das Datumsfeld in der Positionstabelle dupliziert, beim Erstellen von Dokumenten ausgefüllt, die Indizes für die Schnellsuche gesammelt und bereits nach der Positionstabelle gefiltert.  Nachdem wir unbedeutende Gemeinkosten für das Speichern eines neuen Felds und neuer Indizes geopfert haben, haben wir die Anzahl der Eingabe- / Ausgabeoperationen, die durch problematische Abfragen generiert wurden, mehrmals reduziert. <br><br><img src="https://habrastorage.org/webt/62/oh/gb/62ohgb45gxmmt9plaeuzdgckhds.png" alt="Bild"><br><br><h2>  2015. Das Problem eines Dienstes </h2><br>  Eineinhalb Jahre lang haben wir das System hervorragend optimiert. Es ist vorhersehbarer geworden.  Die Pläne, die Anzahl der Filialen zu verdoppeln, blieben jedoch relevant, sodass die Herausforderungen weiterhin vor uns lagen. <br><br>  Auf dem Weg nach oben stießen wir auf verschiedene Engpässe.  Zum Beispiel stellten sie Ende 2015 fest, dass sie sich in der Leistung eines Kerndienstes der Plattform ausgeruht hatten.  Dies ist ein logischer Sperrdienst von SAP ABAP.  Aus diesem Grund würde das System dem Wachstum der Last eindeutig nicht standhalten.  Am Horizont zeichneten sich große Geldverluste ab. <br><br>  Zur Verdeutlichung besteht die Aufgabe des Dienstes darin, die logische Transaktionalität auf die Ebene des Anwendungsservers zu bringen.  In ABAP kann eine einzelne Transaktion mehrere Schritte in verschiedenen Workflows durchlaufen.  Damit die Transaktion abgeschlossen werden kann, gibt es einen Sperrdienst und zugehörige Mechanismen.  Die darin enthaltenen Sperr- und Entsperrvorgänge erfolgen schnell, sind jedoch atomar und können nicht getrennt werden.  Es gab ein Problem mit der synchronen E / A. <br><br>  Der Service wurde etwas beschleunigt, nachdem die SAP-Entwickler einen speziellen Patch veröffentlicht hatten. Wir haben den Service auf eine andere Hardware umgestellt und an den Systemeinstellungen gearbeitet, aber dies war immer noch nicht genug.  Die Obergrenze des Passdienstes lag bei ungefähr 7.000 Operationen pro Sekunde, und wir brauchten lange Zeit bereits 10.000. <br><br>  Nach dem synthetischen Belastungstest wurde festgestellt, dass die Verschlechterung nicht linear ist und wir uns dennoch an der Grenze der Serviceleistung befinden, oberhalb derer sich die inakzeptable Verschlechterung des gesamten ERP-Systems manifestiert.  Wiederholte Anrufe bei den Entwicklern haben nur zu einem enttäuschenden Urteil geführt - der Service funktioniert ordnungsgemäß, wir benötigen in der aktuellen Lösungsarchitektur einfach zu viel.  Selbst wenn wir uns sofort verpflichten würden, die gesamte Architektur der Lösung zu wiederholen, würden wir mehrere Monate brauchen, um die Funktionsfähigkeit des aktuellen Systems aufrechtzuerhalten. <br><br>  Eine der ersten Möglichkeiten, um die Lebensdauer eines Sperrdienstes zu verlängern, besteht darin, die E / A zu beschleunigen und in das Dateisystem zu schreiben.  Was?  Experimente mit einer Alternative zu AIX.  Übertrug den Dienst auf Linux auf der leistungsstärksten Power-Maschine und gewann viel Reaktionszeit.  Der Dienst mit eingeschaltetem Dateisystem verhielt sich genauso wie auf Aix mit deaktiviertem Dateisystem.  Dann haben wir diesen Code auf eines der x86_64-Blades übertragen und eine noch fantastischere, sanft abfallende Leistungskurve als zuvor erhalten.  Es sah lustig aus. <br><br>  Es ist davon auszugehen, dass die Entwickler unter AIX und Linux im letzten Test etwas anderes gemacht haben, aber auch hier hat sich die Prozessorarchitektur ausgewirkt. <br><img src="https://habrastorage.org/webt/73/1v/pl/731vplzz4ndclyo0l7tga0mlhv8.png" alt="Bild"><br><br>  Was war die Schlussfolgerung?  Einige Plattformen eignen sich ideal für Multithread-Datenbanken und bieten sowohl Leistung als auch Fehlertoleranz. Ein Prozessor mit einer anderen Architektur kann jedoch bestimmte Aufgaben besser bewältigen.  Wenn Sie zu Beginn einer Lösung eine plattformübergreifende Aufgabe aufgeben, können Sie in Zukunft Platz für Manöver verlieren. <br><br>  Trotzdem haben wir dieses Problem herausgefunden und der Service begann 3-4 mal schneller zu arbeiten, was für ein sehr langes Wachstum ausreicht. <br><br><h2>  2016. DB-CPU-Engpass </h2><br>  Buchstäblich ein halbes Jahr später traten exotische Probleme mit der CPU in der Datenbank auf.  Es scheint klar zu sein, dass mit zunehmender Last der Verbrauch an Prozessorressourcen zunimmt.  Aber SysTime begann, das meiste davon aufzunehmen, und es gab eindeutig ein Problem im Kernel.  Sie begannen zu verstehen, synthetische Belastungstests durchzuführen und stellten fest, dass unser Durchsatz 300.000 Operationen pro Sekunde betrug, d. H.  Milliarden Anfragen pro Stunde und dann Verschlechterung. <br><br>  Als Ergebnis kamen wir zu dem Schluss, dass die perfekte Anfrage eine ist, die es nicht gibt.  Wir haben unsere Optimierungstechnik um neue Ansätze erweitert und eine Prüfung des ERP-Systems durchgeführt: Wir haben begonnen, nach Abfragen zu suchen, beispielsweise mit geringer Effizienz (100.000 Auswahlen - als Ergebnis von 100 Zeilen oder 0 im Allgemeinen) -, um sie zu wiederholen.  Wenn die "leeren" Anforderungen nicht entfernt werden können, lassen Sie sie gegebenenfalls in den "negativen Cache" wechseln.  Wenn viele Anfragen nach denselben Produktdaten parallel verarbeitet werden, lassen Sie sie den Anwendungsserver und nicht die Datenbank quälen, wir zwischenspeichern sie.  Wir „vergrößern“ auch eine große Anzahl häufiger Einzelabfragen zu einem Schlüssel im Rahmen eines Prozesses und ersetzen ihn durch seltenere Auswahlen für einen Teil eines Schlüssels.  Um beispielsweise die Last in der Verarbeitungskette zu verteilen, können verschiedene Schritte auf verschiedenen Anwendungsservern ausgeführt werden.  Das ist gut, aber in verschiedenen Phasen können sie dasselbe von der Basis verlangen.  Lassen Sie dann den ersten Schritt nach dem Starten des Anwendungs-Cache einen Teil der Anforderungen, und es bleibt dort, um den Rest der Kette zu beenden. <br><img src="https://habrastorage.org/webt/ww/cx/uz/wwcxuzeyehn_idgaokwh2psy984.png" alt="Bild"><br><br>  Mit Hilfe solcher Tricks haben wir überall ein wenig gewonnen, aber am Ende haben wir die Basis ernsthaft entladen.  Das System wurde zum Leben erweckt.  In der Zwischenzeit kamen wir zu Aix. <br><br>  Andere Experimente ergaben, dass es eine Leistungsobergrenze gibt - die bereits erwähnten 300.000 Datenbankaufrufe pro Sekunde.  Die Wurzel des Problems war die Leistung der Netzwerkschnittstelle, die eine Obergrenze hatte - etwa 300.000 Pakete pro Sekunde in eine Richtung.  Als sich die Decke näherte, wuchs die Zeit der Systemaufrufe.  Wie sich später herausstellte, war es auch ein Erbe des AIX-Kernel-Netzwerkstapels. <br><br>  Im Allgemeinen hatten wir nie Probleme mit der Latenz, der Kern des Netzwerks war produktiv, alle Kabel wurden zu einem großen unzerstörbaren Kanal auf einer Schnittstelle zusammengebaut.  Wir haben eine Problemumgehung vorgenommen: Wir haben das gesamte Netzwerk zwischen Anwendungsservern und der Datenbank in Gruppen auf verschiedenen Schnittstellen aufgeteilt.  Infolgedessen kommunizierte jede Gruppe von Anwendungsservern über eine eigene separate Schnittstelle mit der Datenbank.  Die maximale Leistung jeder Schnittstelle wurde geringfügig reduziert, aber insgesamt haben wir das Netzwerk auf 1 Million Pakete pro Sekunde in eine Richtung übertaktet. <br><br>  Und das Prinzip "Die beste Anfrage ist die, die es nicht gibt" wurde dem Talmud für Entwickler hinzugefügt, damit dies beim Schreiben von Code berücksichtigt wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u-/lo/qh/u-loqhu4_avqxvne0eam6lmittq.png" alt="Bild"></div><br><h2>  2017. Live zum Upgrade </h2><br>  Nun, die letzte Phase der Wiederherstellung unseres Systems ist 2017 vergangen.  Alles, was blieb, war, bis zum Upgrade einiges zu leben, und es war notwendig, die SLA für nichts zu halten.  Der Code wurde optimiert, aber wir haben festgestellt, dass die Prozesse umso langsamer funktionieren, je höher die Auslastung der Datenbank-CPU ist, obwohl die Auslastungsspanne 10 bis 20% betrug.  Anfangs wurde geschätzt, dass 100% doppelt so viel sind wie 50%.  Und wenn es eine Reserve von 10-20% gibt, sind dies 10-20%.  Tatsächlich erhöhte sich bei einer Last über 67-80% die Dauer der Aufgaben nichtlinear, d.h.  Amdahls Gesetz hat funktioniert.  Das System hatte eine Parallelisierungsgrenze, und als diese überschritten wurde und eine zunehmende Anzahl von Prozessoren in die Arbeit einbezogen wurde, nahm die Leistung jedes einzelnen Prozessors ab. <br><br>  Zu dieser Zeit verwendeten wir 125 physische oder 500 logische Prozessoren, wobei Multithreading auf AIX-Ebene in Betracht gezogen wurde.  Was würden Sie vorschlagen?  Upgrade?  Noch vor dem Ende der Koordinierung war es notwendig, mehrere Monate durchzuhalten und das SLA nicht fallen zu lassen. <br><br>  Irgendwann stellten sie fest, dass herkömmliche Prozessorauslastungsmetriken für uns keine Indikatoren sind - sie zeigen nicht den tatsächlichen Beginn der Verschlechterung.  Für eine realistische Einschätzung des Systemzustands haben wir begonnen, die integrierte Metrik - das Ergebnis eines synthetischen Tests - als Metrik für die Leistung des Datenbankprozessors zu verwenden.  Einmal pro Minute führten sie einen synthetischen Test durch, maßen seine Dauer und zeigten diese Metrik auf unseren Monitoren an.  Und sie reagierten, wenn die Metrik über den deklarierten kritischen Punkt stieg.  Wir haben die Last unserer Lastplaner etwas gehalten, damit sie im Bereich „maximales Drehmoment“ der Datenbank verbleibt. <br><img src="https://habrastorage.org/webt/fg/o0/0u/fgo00uye8ms6yklbxscplqcly7s.png" alt="Bild"><br><br>  Die manuelle Steuerung war jedoch unwirksam und wir waren es leid, nachts aufzuwachen.  Dann haben wir den Lastplaner umgeschrieben, damit er Feedback zu den aktuellen Leistungsmetriken erhält.  Wenn die Metriken den gelben Schwellenwert überschritten (siehe Abbildung), wurde die Planung von Paketen mit niedriger Priorität eingefroren und nur geschäftskritische Prozesse erhielten Priorität.  So konnten wir automatisch die Intensität der Belastung steuern und die Ressourcen effizient nutzen.  Und das Interessanteste ist, dass wir, wenn wir das System in derselben Zone mit maximalem Drehmoment innerhalb von 80% der Last halten, die Gesamtzeit für die Ausführung von Geschäftsprozessen reduzieren konnten, weil  Jeder Thread begann viel schneller zu arbeiten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gi/54/7w/gi547wixu3bnefxdvvy6wl-golc.png" alt="Bild"></div><br><h2>  Ein paar Tipps für diejenigen, die mit hoch geladenem ERP arbeiten </h2><br><ul><li>  Es ist sehr wichtig, die Leistung von Systemen zu Beginn eines Projekts zu überwachen, insbesondere anhand ihrer eigenen Metriken. </li><li>  Stellen Sie eine lineare Zunahme der Last im Verhältnis zur Zunahme der Anzahl der Lasttreiber sicher (in unserem Fall waren dies Waren und Geschäfte). </li><li>  Beseitigen Sie nichtlineare Konstruktionen im Code und verwenden Sie das Caching, um identische Datenbankabfragen zu entfernen. </li><li>  Wenn Sie die Last von der Datenbank-CPU auf die Anwendungsserver-CPU übertragen müssen, können Sie Join-Anforderungen in einfache Beispiele aufteilen. </li><li>  Denken Sie bei allen Optimierungen daran, dass eine schnelle Anfrage gut und eine schnelle und häufige Anfrage manchmal schlecht ist. </li><li>         . </li><li>        ,    ;       “  ”  . </li><li>                       </li></ul><br> <i>  Highload         ,         . <br></i> <br> <i> ,  ,   SAP  #ITX5</i> <br><br> , #ITX5 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  SAP. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432412/">https://habr.com/ru/post/de432412/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar486174/index.html">لدي صفر دوران</a></li>
<li><a href="../de432402/index.html">Hey HR, wo ist mein Souvenir?</a></li>
<li><a href="../de432404/index.html">Backup für Linux schreibt keine Briefe</a></li>
<li><a href="../de432408/index.html">Fintech Digest: Vorbereitung für die Trennung kleiner Banken von Visa und Mastercard, einem Rentenrechner und nicht nur</a></li>
<li><a href="../de432410/index.html">Entitäten im DDD-Stil mit Entity Framework Core</a></li>
<li><a href="../de432414/index.html">Alte Geheimnisse für schnelles Debuggen: Animieren des Quellcodes</a></li>
<li><a href="../de432416/index.html">Abhängige Typen - Die Zukunft der Programmiersprachen</a></li>
<li><a href="../de432418/index.html">Analysieren von Lambda-Ausdrücken in Java</a></li>
<li><a href="../de432420/index.html">Einführung in Git Merge und Git Rebase: Warum und wann sie verwendet werden sollen</a></li>
<li><a href="../de432422/index.html">Offline-Modus unter iOS und Funktionen seiner Implementierung unter Realm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>