<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äç‚öïÔ∏è üóª ü§¥üèæ Introducci√≥n a GitOps para OpenShift ‚úåüèæ üëéüèæ üëèüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy hablaremos sobre los principios y modelos de GitOps, as√≠ como sobre c√≥mo estos modelos se implementan en la plataforma OpenShift. Una gu√≠a en l√≠ne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introducci√≥n a GitOps para OpenShift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/478852/">  Hoy hablaremos sobre los principios y modelos de GitOps, as√≠ como sobre c√≥mo estos modelos se implementan en la plataforma OpenShift.  Una gu√≠a en l√≠nea sobre este tema est√° disponible <a href="https://learn.openshift.com/introduction/gitops-introduction/%3FextIdCarryOver%3Dtrue%26sc_cid%3D701f2000001OH74AAG">aqu√≠</a> . <br><br><img src="https://habrastorage.org/webt/sk/g4/vk/skg4vkilbd51gs_dk6vk3-emy2o.jpeg" width="100%"><br><br>  En resumen, GitOps es un conjunto de m√©todos pr√°cticos para usar las solicitudes de extracci√≥n de Git para administrar la infraestructura y las configuraciones de las aplicaciones.  El repositorio de Git dentro de GitOps se considera como una √∫nica fuente de informaci√≥n sobre el estado del sistema, y ‚Äã‚Äãcualquier cambio en este estado se supervisa y audita por completo. <br><a name="habracut"></a><br>  La idea del seguimiento de cambios en GitOps no es nueva; este enfoque se ha utilizado durante mucho tiempo en casi todas partes cuando se trabaja con el c√≥digo fuente de la aplicaci√≥n.  GitOps simplemente implementa funciones similares (revisiones de revisi√≥n, solicitudes de extracci√≥n, etiquetas, etc.) al administrar la infraestructura y las configuraciones de la aplicaci√≥n y ofrece ventajas similares a las de la administraci√≥n del c√≥digo fuente. <br><br>  Para GitOps, no existe una definici√≥n acad√©mica o un conjunto aprobado de reglas, solo un conjunto de principios en los que se basa esta pr√°ctica: <br><br><ul><li>  La descripci√≥n declarativa del sistema se almacena en el repositorio de Git (configuraciones, monitoreo, etc.). </li><li>  Los cambios de estado se realizan mediante solicitudes de extracci√≥n. </li><li>  El estado de los sistemas en ejecuci√≥n est√° alineado con los datos en el repositorio utilizando solicitudes push de Git. </li></ul><br><h3>  Principios de GitOps </h3><br><ul><li>  <b>Las definiciones del sistema se describen como c√≥digo fuente.</b> </li></ul><br>  La configuraci√≥n del sistema se considera como c√≥digo, por lo que puede almacenarse y versionarse autom√°ticamente en el repositorio de Git, que sirve como la √∫nica fuente de verdad.  Este enfoque facilita el despliegue y la reversi√≥n de los cambios en los sistemas. <br><br><ul><li>  <b>El estado deseado y la configuraci√≥n del sistema se configuran y versionan en Git</b> </li></ul><br>  Al almacenar y versionar en Git el estado deseado de los sistemas, tenemos la capacidad de revertir y revertir f√°cilmente los cambios en los sistemas y aplicaciones.  Tambi√©n podemos usar los mecanismos de seguridad de Git para controlar la propiedad del c√≥digo y verificar su autenticidad. <br><br><ul><li>  <b>Los cambios de configuraci√≥n se pueden aplicar autom√°ticamente mediante solicitudes de extracci√≥n.</b> </li></ul><br>  Usando las solicitudes de extracci√≥n de Git, podemos controlar f√°cilmente c√≥mo se aplican los cambios a las configuraciones en el repositorio.  Por ejemplo, pueden enviarse para verificaci√≥n a otros miembros del equipo o pasar por pruebas de CI, etc. <br><br>  Y al mismo tiempo, no es necesario que otorgue autoridad de administrador a derecha e izquierda.  Para confirmar los cambios de configuraci√≥n, los usuarios tienen permisos suficientes en el repositorio de Git donde se almacenan estas configuraciones. <br><br><ul><li>  <b>Arreglar configuraciones de deriva no controladas</b> </li></ul><br>  Cuando el estado deseado del sistema se almacena en el repositorio de Git, solo podemos encontrar software que controle que el estado actual del sistema corresponda a su estado deseado.  Si esto no es as√≠, entonces este software deber√≠a, dependiendo de la configuraci√≥n, corregir la discrepancia por s√≠ solo o notificarnos la deriva de la configuraci√≥n. <br><br><h3>  Modelos GitOps para OpenShift </h3><br><h4>  Reconciliador de recursos en cl√∫ster </h4><br>  Seg√∫n este modelo, el cl√∫ster tiene un controlador que se encarga de comparar los recursos de Kubernetes (archivos YAML) en el repositorio de Git con los recursos reales del cl√∫ster.  En caso de discrepancias, el controlador env√≠a notificaciones y, posiblemente, toma medidas para eliminar inconsistencias.  Este modelo de GitOps es utilizado por Anthos Config Management y Weaveworks Flux. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/c9/p2/lhc9p2tphyarqpe6jrsh10fgo7e.png"></div><br><br>
<h4>  Reconciliador de recursos externos (Push) </h4><br>  Este modelo puede considerarse como una variaci√≥n del anterior, cuando tenemos uno o m√°s controladores responsables de sincronizar recursos en pares "Repositorio de Git - Cl√∫ster de Kubernetes".  La diferencia aqu√≠ es que cada cl√∫ster administrado no tiene que tener su propio controlador separado.  Los pares de cl√∫ster Git - k8 a menudo se definen como CRD de definici√≥n de recursos personalizados, que describen c√≥mo el controlador debe realizar la sincronizaci√≥n.  Dentro de este modelo, los controladores comparan el repositorio de Git especificado en CRD con los recursos del cl√∫ster de Kubernetes, que tambi√©n se definen en CRD, y realizan las acciones correspondientes en funci√≥n de los resultados de la comparaci√≥n.  En particular, dicho modelo GitOps se usa en ArgoCD. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/51/ip/zw51ipo5hqcn8ccnc8vfqkqbc88.png"></div><br><br><h3>  GitOps en la plataforma OpenShift </h3><br><h4>  Administraci√≥n de Infraestructura Kubernetes Multicl√∫ster </h4><br>  Con la propagaci√≥n de Kubernetes y la creciente popularidad de las estrategias multi-nube y la inform√°tica de punta, el n√∫mero promedio de cl√∫steres OpenShift por cliente tambi√©n ha aumentado. <br><br>  Por ejemplo, cuando se utiliza la inform√°tica perif√©rica, los cl√∫steres de un solo cliente se pueden implementar en cientos o incluso miles.  Como resultado, se ve obligado a administrar varios cl√∫steres OpenShift independientes o coordinados en la nube p√∫blica y en las instalaciones. <br><br>  Al mismo tiempo, se deben resolver muchos problemas, en particular: <br><br><ul><li>  Para controlar que los cl√∫steres est√©n en id√©nticas condiciones (configuraciones, monitoreo, almacenamiento, etc.) </li><li>  Vuelva a crear (o restaurar) cl√∫steres de acuerdo con un estado conocido. </li><li>  Cree nuevos cl√∫steres de acuerdo con un estado conocido. </li><li>  Tire de los cambios en m√∫ltiples cl√∫steres OpenShift. </li><li>  Retroceda los cambios a m√∫ltiples cl√∫steres OpenShift. </li><li>  Configuraciones de enlace de patrones con diferentes entornos. </li></ul><br><h4>  Configuraciones de aplicaciones </h4><br>  Durante su ciclo de vida, las aplicaciones a menudo pasan por una cadena de cl√∫steres (desarrollo, etapa, etc.) antes de ingresar a un cl√∫ster de producci√≥n.  Adem√°s, debido a los requisitos de disponibilidad y escalabilidad, los clientes a menudo implementan aplicaciones en m√∫ltiples cl√∫steres locales o en m√∫ltiples regiones de una plataforma de nube p√∫blica. <br><br>  En este caso, es necesario resolver los siguientes problemas: <br><ul><li>  Asegure el movimiento de aplicaciones (binarios, configuraciones, etc.) entre cl√∫steres (dev, stage, etc.). </li><li>  Enrolle los cambios en las aplicaciones (binarios, configuraciones, etc.) en varios cl√∫steres de OpenShift. </li><li>  Revierta los cambios en las aplicaciones al nivel del estado anterior conocido. </li></ul><br><h3>  Escenarios de uso de OpenShift GitOps </h3><br><h4>  1. Aplicar cambios desde el repositorio de Git </h4><br>  El administrador del cl√∫ster puede almacenar las configuraciones de cl√∫ster OpenShift en el repositorio de Git y aplicarlas autom√°ticamente para crear nuevos cl√∫steres sin ning√∫n esfuerzo adicional y llevarlos a un estado id√©ntico al estado conocido almacenado en el repositorio de Git. <br><br><h4>  2. Sincroniza con Secret Manager </h4><br>  El administrador tambi√©n encontrar√° √∫til sincronizar los objetos secretos de OpenShift con el software apropiado como Vault para administrarlos utilizando herramientas especialmente creadas para esto. <br><br><h4>  3. Configuraciones de deriva de control </h4><br>  El administrador solo estar√° a favor si OpenShift GitOps detecta y advierte sobre las discrepancias entre las configuraciones reales y las especificadas en el repositorio, para que pueda responder r√°pidamente a la deriva. <br><br><h4>  4. Notificaciones de deriva de configuraci√≥n </h4><br>  Ser√° √∫til cuando el administrador quiera conocer r√°pidamente las configuraciones de deriva para tomar r√°pidamente las medidas apropiadas por su cuenta. <br><br><h4>  5. Sincronizaci√≥n manual de configuraciones al derivar </h4><br>  Permite al administrador sincronizar el cl√∫ster de OpenShift con el repositorio de Git en caso de configuraciones de deriva para devolver r√°pidamente el cl√∫ster a un estado conocido anterior. <br><br><h4>  6. Sincronizaci√≥n autom√°tica de configuraciones de deriva </h4><br>  El administrador tambi√©n puede configurar el cl√∫ster OpenShift para sincronizar autom√°ticamente con el repositorio cuando se detecta una deriva, de modo que la configuraci√≥n del cl√∫ster siempre coincida con las configuraciones en Git. <br><br><h4>  7. Varios cl√∫steres: un repositorio </h4><br>  El administrador puede almacenar configuraciones de varios cl√∫steres OpenShift diferentes en un repositorio Git y aplicarlas selectivamente seg√∫n sea necesario. <br><br><h4>  8. Jerarqu√≠a de configuraciones de cl√∫ster (herencia) </h4><br>  El administrador puede establecer la jerarqu√≠a de configuraciones de cl√∫ster en el repositorio (etapa, prod, cartera de aplicaciones, etc. con herencia).  En otras palabras, puede determinar c√≥mo se deben aplicar las configuraciones, a uno o varios cl√∫steres. <br><br>  Por ejemplo, si el administrador define la jerarqu√≠a ‚ÄúCl√∫steres de producci√≥n (prod) ‚Üí Cl√∫steres del sistema X ‚Üí Cl√∫steres de producci√≥n del sistema X‚Äù en el repositorio de Git, las siguientes configuraciones se aplican a los cl√∫steres de producci√≥n del sistema X: <br><br><ul><li>  Configuraciones comunes a todos los grupos de producci√≥n. </li><li>  Configuraciones para el sistema de cl√∫ster X. </li><li>  Configuraciones para el cluster de producci√≥n del sistema X. </li></ul><br><h4>  9. Patrones y anulaciones de configuraci√≥n </h4><br>  El administrador puede anular el conjunto de configuraciones heredadas y sus valores, por ejemplo, para ajustar la configuraci√≥n para cl√∫steres espec√≠ficos a los que se aplicar√°n. <br><br><h4>  10. Incluir y excluir selectivamente para configuraciones, configuraci√≥n de aplicaciones </h4><br>  El administrador puede establecer las condiciones para aplicar o no ciertas configuraciones a cl√∫steres con ciertas caracter√≠sticas. <br><br><h4>  11. Soporte de patrones </h4><br>  Los desarrolladores encontrar√°n √∫til elegir c√≥mo se determinar√°n los recursos de la aplicaci√≥n (Helm Chart, Kubernetes yaml puro, etc.) para usar el formato m√°s adecuado para cada aplicaci√≥n espec√≠fica. <br><br><h3>  Herramientas de GitOps en la plataforma OpenShift </h3><br><h4>  Argocd </h4><br>  ArgoCD implementa el modelo de Reconciliaci√≥n de recursos externos y ofrece una interfaz de usuario centralizada para organizar las relaciones entre cl√∫steres y repositorios de Git de una a una.  Las desventajas de este programa incluyen la incapacidad de administrar aplicaciones mientras ArgoCD no funciona. <br><br>  <a href="https://argoproj.github.io/argo-cd/">Sitio web oficial</a> <br><br><h4>  Flujo </h4><br>  Flux implementa el modelo de reconciliaci√≥n de recursos en el cl√∫ster y, como resultado, no existe una administraci√≥n centralizada del repositorio de definiciones, que es un punto d√©bil.  Por otro lado, precisamente por la falta de centralizaci√≥n, la capacidad de administrar aplicaciones se conserva incluso cuando falla un cl√∫ster. <br><br>  <a href="https://fluxcd.io/">Sitio web oficial</a> <br><br><h3>  Instale ArgoCD en OpenShift </h3><br>  ArgoCD ofrece una excelente interfaz de l√≠nea de comandos y consola web, por lo que no consideraremos Flux y otras alternativas aqu√≠. <br><br>  Para implementar ArgoCD en la plataforma OpenShift 4, siga estos pasos como administrador de cl√∫ster: <br><br><h4>  Despliegue de componentes ArgoCD en la plataforma OpenShift </h4><br><pre><code class="plaintext hljs"># Create a new namespace for ArgoCD components oc create namespace argocd # Apply the ArgoCD Install Manifest oc -n argocd apply -f https://raw.githubusercontent.com/argoproj/argo-cd/v1.2.2/manifests/install.yaml # Get the ArgoCD Server password ARGOCD_SERVER_PASSWORD=$(oc -n argocd get pod -l "app.kubernetes.io/name=argocd-server" -o jsonpath='{.items[*].metadata.name}')</code> </pre> <br><h4>  Refinamiento del servidor ArgoCD para ser visto por OpenShift Route </h4><br><pre> <code class="plaintext hljs"># Patch ArgoCD Server so no TLS is configured on the server (--insecure) PATCH='{"spec":{"template":{"spec":{"$setElementOrder/containers":[{"name":"argocd-server"}],"containers":[{"command":["argocd-server","--insecure","--staticassets","/shared/app"],"name":"argocd-server"}]}}}}' oc -n argocd patch deployment argocd-server -p $PATCH # Expose the ArgoCD Server using an Edge OpenShift Route so TLS is used for incoming connections oc -n argocd create route edge argocd-server --service=argocd-server --port=http --insecure-policy=Redirect</code> </pre> <br><h4>  Implementar ArgoCD Cli Tool </h4><br><pre> <code class="plaintext hljs"># Download the argocd binary, place it under /usr/local/bin and give it execution permissions curl -L https://github.com/argoproj/argo-cd/releases/download/v1.2.2/argocd-linux-amd64 -o /usr/local/bin/argocd chmod +x /usr/local/bin/argocd</code> </pre> <br><h4>  Cambiar contrase√±a de administrador del Servidor ArgoCD </h4><br><pre> <code class="plaintext hljs"># Get ArgoCD Server Route Hostname ARGOCD_ROUTE=$(oc -n argocd get route argocd-server -o jsonpath='{.spec.host}') # Login with the current admin password argocd --insecure --grpc-web login ${ARGOCD_ROUTE}:443 --username admin --password ${ARGOCD_SERVER_PASSWORD} # Update admin's password argocd --insecure --grpc-web --server ${ARGOCD_ROUTE}:443 account update-password --current-password ${ARGOCD_SERVER_PASSWORD} --new-password</code> </pre> <br>  Despu√©s de completar estos pasos, puede trabajar con ArgoCD Server a trav√©s de la consola web ArgoCD WebUI o la herramienta de l√≠nea de comandos ArgoCD Cli. <br>  <a href="https://blog.openshift.com/is-it-too-late-to-integrate-gitops/">https://blog.openshift.com/is-it-too-late-to-integrate-gitops/</a> <br><br><h3>  GitOps: nunca es demasiado tarde </h3><br>  "El tren se ha ido": esto es lo que dicen sobre la situaci√≥n cuando se pierde la oportunidad de hacer algo.  En el caso de OpenShift, el deseo de comenzar a usar de inmediato esta nueva y genial plataforma a menudo crea tal situaci√≥n con la administraci√≥n y el mantenimiento de rutas, implementaciones y otros objetos de OpenShift.  ¬øPero la oportunidad siempre se pierde por completo? <br><br>  Continuando con una serie de art√≠culos sobre <a href="https://blog.openshift.com/introduction-to-gitops-with-openshift/">GitOps</a> , hoy mostraremos c√≥mo transformar una aplicaci√≥n creada manualmente y sus recursos en un proceso determinado donde el kit de herramientas GitOps controla todo.  Para hacer esto, primero implementamos la aplicaci√≥n httpd con nuestras manos.  La siguiente captura de pantalla muestra c√≥mo creamos un espacio de nombres, implementaci√≥n y servicio, y luego exponemos para que este servicio cree una ruta. <br><br><pre> <code class="plaintext hljs">oc create -f https://raw.githubusercontent.com/openshift/federation-dev/master/labs/lab-4-assets/namespace.yaml oc create -f https://raw.githubusercontent.com/openshift/federation-dev/master/labs/lab-4-assets/deployment.yaml oc create -f https://raw.githubusercontent.com/openshift/federation-dev/master/labs/lab-4-assets/service.yaml oc expose svc/httpd -n simple-app</code> </pre> <br>  Entonces, tenemos una aplicaci√≥n creada manualmente.  Ahora debe transferirse bajo el control de GitOps sin p√©rdida de disponibilidad.  En resumen, hace esto: <br><br><ul><li>  Crea un repositorio Git para el c√≥digo. </li><li>  Exportamos nuestros objetos actuales y los cargamos en el repositorio de Git. </li><li>  Seleccione e implemente el kit de herramientas GitOps. </li><li>  Agregue nuestro repositorio a este kit de herramientas. </li><li>  Definimos la aplicaci√≥n en nuestro kit de herramientas de GitOps. </li><li>  Realice una ejecuci√≥n de prueba de la aplicaci√≥n utilizando el kit de herramientas GitOps. </li><li>  Sincronizamos objetos usando el kit de herramientas GitOps. </li><li>  Activamos la poda y la sincronizaci√≥n autom√°tica de objetos. </li></ul><br>  Como se mencion√≥ en el <a href="https://blog.openshift.com/introduction-to-gitops-with-openshift/">art√≠culo</a> anterior, GitOps tiene una y solo una fuente de informaci√≥n sobre todos los objetos en los cl√∫steres de Kubernetes: el repositorio de Git.  Adem√°s, procedemos de la premisa de que su organizaci√≥n ya utiliza un repositorio Git.  Puede ser p√∫blico o privado, pero debe estar disponible para los cl√∫steres de Kubernetes.  Puede ser el mismo repositorio que para el c√≥digo de la aplicaci√≥n, o un repositorio separado creado espec√≠ficamente para la implementaci√≥n.  Se recomienda que tenga permisos estrictos en el repositorio, ya que los objetos secretos, las rutas y otras cosas sensibles a la seguridad se almacenar√°n all√≠. <br><br>  En nuestro ejemplo, crearemos un nuevo repositorio p√∫blico en GitHub.  Puedes nombrarlo como quieras, usamos el nombre blogpost. <br><br>  Si los archivos YAML de los objetos no se almacenaron localmente o en Git, deber√° usar los binarios oc o kubectl.  En la captura de pantalla a continuaci√≥n, solicitamos YAML para nuestro espacio de nombres, implementaci√≥n, servicio y ruta.  Antes de eso, clonamos el repositorio reci√©n creado y lo trasladamos con el comando cd. <br><br><pre> <code class="plaintext hljs">oc get namespace simple-app -o yaml --export &gt; namespace.yaml oc get deployment httpd -o yaml -n simple-app --export &gt; deployment.yaml oc get service httpd -o yaml -n simple-app --export &gt; service.yaml oc get route httpd -o yaml -n simple-app --export &gt; route.yaml</code> </pre> <br>  Ahora arregle el archivo deploy.yaml para eliminar un campo que Argo CD no puede sincronizar. <br><br><pre> <code class="plaintext hljs">sed -i '/\sgeneration: .*/d' deployment.yaml</code> </pre> <br>  Adem√°s, debe cambiar la ruta.  Primero estableceremos la variable multil√≠nea y luego reemplazaremos el ingreso: nulo con el contenido de esta variable. <br><br><pre> <code class="plaintext hljs">export ROUTE=" ingress:\\ - conditions:\\ - status: 'True'\\ type: Admitted" sed -i "s/ ingress: null/$ROUTE/g" route.yaml</code> </pre> <br>  Entonces, con los archivos ordenados, queda guardarlos en el repositorio de Git.  Despu√©s de eso, este repositorio se convierte en la √∫nica fuente de informaci√≥n, y cualquier cambio manual en los objetos deber√≠a estar estrictamente prohibido. <br><br><pre> <code class="plaintext hljs">git commit -am 'initial commit of objects' git push origin master</code> </pre> <br>  Adem√°s, procedemos del hecho de que ArgoCD ya est√° implementado para usted (c√≥mo hacer esto, consulte la <a href="https://blog.openshift.com/introduction-to-gitops-with-openshift/">publicaci√≥n</a> anterior).  Por lo tanto, agregamos al CD Argo el repositorio que creamos que contiene el c√≥digo de la aplicaci√≥n de nuestro ejemplo.  Solo aseg√∫rese de especificar el repositorio exacto que cre√≥ anteriormente. <br><br><pre> <code class="plaintext hljs">argocd repo add https://github.com/cooktheryan/blogpost</code> </pre> <br>  Ahora crea la aplicaci√≥n.  La aplicaci√≥n establece valores para que el kit de herramientas GitOps comprenda qu√© repositorio y rutas usar, qu√© OpenShift se necesita para administrar objetos, as√≠ como qu√© rama espec√≠fica del repositorio se necesita y si los recursos deben sincronizarse autom√°ticamente. <br><br><pre> <code class="plaintext hljs">argocd app create --project default \ --name simple-app --repo https://github.com/cooktheryan/blogpost.git \ --path . --dest-server https://kubernetes.default.svc \ --dest-namespace simple-app --revision master --sync-policy none</code> </pre> <br>  Una vez que se especifica la aplicaci√≥n en el CD de Argo, este kit de herramientas comienza a verificar que los objetos ya implementados cumplan con las definiciones del repositorio.  En nuestro ejemplo, la sincronizaci√≥n autom√°tica y la limpieza est√°n deshabilitadas, por lo que los elementos a√∫n no cambian.  Tenga en cuenta que en la interfaz de Argo CD, nuestra aplicaci√≥n tendr√° el estado "Fuera de sincronizaci√≥n" (No sincronizado), ya que no hay una etiqueta que coloque ArgoCD. <br>  Por eso, cuando comenzamos la sincronizaci√≥n un poco m√°s tarde, no se realizar√° la redistribuci√≥n de objetos. <br><br>  Ahora ejecute una prueba para asegurarse de que no haya errores en nuestros archivos. <br><br><pre> <code class="plaintext hljs">argocd app sync simple-app --dry-run</code> </pre> <br>  Si no hay errores, puede proceder a la sincronizaci√≥n. <br><br><pre> <code class="plaintext hljs">argocd app sync simple-app</code> </pre> <br>  Despu√©s de ejecutar el comando argocd get en nuestra aplicaci√≥n, deber√≠amos ver que el estado de la aplicaci√≥n ha cambiado a Saludable o Sincronizado.  Esto significar√° que todos los recursos en el repositorio de Git ahora corresponden a aquellos recursos que ya est√°n implementados. <br><br><pre> <code class="plaintext hljs">argocd app get simple-app Name: simple-app Project: default Server: https://kubernetes.default.svc Namespace: simple-app URL: https://argocd-server-route-argocd.apps.example.com/applications/simple-app Repo: https://github.com/cooktheryan/blogpost.git Target: master Path: . Sync Policy: &lt;none&gt; Sync Status: Synced to master (60e1678) Health Status: Healthy ...</code> </pre> <br>  Pero ahora puede activar la sincronizaci√≥n autom√°tica y la limpieza para asegurarse de que no se crear√° nada manualmente y que cada vez que se crea o actualiza el objeto en el repositorio, se realizar√° la implementaci√≥n. <br><br><pre> <code class="plaintext hljs">argocd app set simple-app --sync-policy automated --auto-prune</code> </pre> <br>  Entonces, transferimos con √©xito al control de GitOps una aplicaci√≥n que inicialmente no usaba GitOps de ninguna manera. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/478852/">https://habr.com/ru/post/478852/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../478840/index.html">¬øD√≥nde comienza la creaci√≥n de un mercado? Parte dos</a></li>
<li><a href="../478844/index.html">Miedo y asco en TI</a></li>
<li><a href="../478846/index.html">Systemd, guiones interactivos y temporizadores</a></li>
<li><a href="../478848/index.html">La evoluci√≥n de la fotograf√≠a digital.</a></li>
<li><a href="../478850/index.html">Nomenclatura de cuadr√≠cula CSS</a></li>
<li><a href="../478854/index.html">La batalla de los servidores web. Parte 1 - HTTP divorciado de la realidad:</a></li>
<li><a href="../478856/index.html">SD-WAN: tendencias y pron√≥sticos recientes para 2020</a></li>
<li><a href="../478858/index.html">Comparaci√≥n de sesiones de creaci√≥n de perfiles en XHProf Admin</a></li>
<li><a href="../478862/index.html">¬øC√≥mo se organizan las pruebas frontend en Yandex.Market y por qu√© rechazamos los lanzamientos semanales?</a></li>
<li><a href="../478866/index.html">Meet Space - Nuevo producto de JetBrains</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>