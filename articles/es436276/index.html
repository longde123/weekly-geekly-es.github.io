<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐕 🤹🏿 ☘️ Visualización tridimensional en simuladores de material rodante basados ​​en el motor OpenSceneGraph 🕓 🏁 🔘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace poco menos de un año, se publicó una publicación donde hablamos sobre el complejo de capacitación y laboratorio (ULK) del tren eléctrico ES1 Last...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Visualización tridimensional en simuladores de material rodante basados ​​en el motor OpenSceneGraph</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436276/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bp/4h/_g/bp4h_g1ct8gq0ntec_7pe8pkan8.jpeg"></div><br><br>  Hace poco menos de un año, se publicó una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicación</a> donde hablamos sobre el complejo de capacitación y laboratorio (ULK) del tren eléctrico ES1 Lastochka desarrollado por nuestra universidad.  Luego prometí que esta no sería la última publicación sobre este tema, en particular, amenacé con hablar sobre los problemas de crear una visualización tridimensional para tales simuladores y describir los principales enfoques para resolverlos. <br><br>  El año pasado, estuvimos satisfechos con nuestro próximo lanzamiento: el ULK del tren eléctrico de alta velocidad Sapsan EVS2, que tuvo lugar en agosto del año pasado.  El complejo educativo y de laboratorio de este tren eléctrico en sí merece una historia aparte, pero en el contexto de esta publicación hablaremos sobre la llaga: el problema de crear un subsistema adecuado de visualización tridimensional, cuya solución se acercó a nuestro equipo desde diferentes lados durante aproximadamente dos años.  El lanzamiento del simulador Sapsan es significativo (entre otras cosas) y en eso determinó el vector de desarrollo de nuestros desarrollos en esta área. <br><a name="habracut"></a><br><h1>  1. Brevemente sobre ULK EVS2 "Sapsan" </h1><br>  Quiero enfatizar una vez más (lo que hago con una frecuencia envidiable) que los complejos educativos y de laboratorio de material rodante desarrollados en nuestra universidad no están destinados a la preparación de brigadas de locomotoras.  Como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uno de los comentaristas del</a> artículo anterior <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">señaló</a> acertadamente, nuestros ULK no son simuladores, sino simuladores, donde el énfasis principal está en la implementación competente de la física del movimiento del tren y la simulación de la operación de los subsistemas de material rodante que aseguran su movimiento y parada.  El simulador Sapsan no es una excepción, en la que se resuelven las siguientes tareas: <br><br><ul><li>  Se implementó un modelo dinámico de la parte mecánica del tren teniendo en cuenta las fuerzas longitudinales y el perfil de la vía. </li><li>  Se ha construido un modelo informático detallado del funcionamiento de los subsistemas clave del tren eléctrico: circuito eléctrico de potencia, accionamiento eléctrico de tracción, frenos neumáticos y electroneumáticos. </li><li>  Se reproducen los algoritmos básicos del funcionamiento del sistema de control del tren eléctrico a diferentes niveles. </li></ul><br>  Además, el complejo de capacitación y laboratorio incluye un modelo de tamaño completo de la cabina del tren eléctrico con los controles principales y los medios para mostrar la información.  A diferencia del simulador Swallows, esta cabina no fue fabricada por nosotros por nuestra cuenta, sino que fue comprada en 2015 en una oficina en el país que produce simuladores de entrenamiento.  Por lo tanto, el proceso de desarrollo del simulador se centró en la creación de software. <br><br><div class="spoiler">  <b class="spoiler_title">Foto de la cabina</b> <div class="spoiler_text">  <i>Vista general del interior de la cabina.</i> <br><img src="https://habrastorage.org/webt/ud/de/ic/uddeiczrsp23eszvl6tx6zwal7y.jpeg"><br><br>  <i>Ver a través del parabrisas</i> <br><img src="https://habrastorage.org/webt/r1/nz/kn/r1nzknpyastfa6b8iy6ghp2m4ic.jpeg"><br><br>  <i>Display dispositivo locomotor de seguridad integrado (CLUB-U).</i>  <i>El rojo "290" es el límite de velocidad actual obtenido de la tarjeta electrónica CLUB-U.</i>  <i>Hasta ahora, el límite de velocidad alcanzado por Sapsan en el ferrocarril de octubre hace alarde aquí.</i>  <i>En el futuro, la tarjeta electrónica se implementará como se hace en la vida.</i> <br><img src="https://habrastorage.org/webt/nt/on/-g/nton-ggphlulx1e0yxmznf_epnu.jpeg"><br><br>  <i>Pantalla principal "Interfaz hombre-máquina"</i> <br><img src="https://habrastorage.org/webt/xk/kd/qk/xkkdqkxqznjjkl_vx-lfbdhys4w.jpeg"><br><br>  <i>Visualización del estado del sistema de frenos del tren eléctrico.</i> <br><img src="https://habrastorage.org/webt/ap/wl/qv/apwlqvuggyfjgwd_prliwn3hjck.jpeg"><br><br>  <i>Ajustador de velocidad y controlador de tracción</i> <br><img src="https://habrastorage.org/webt/u3/ok/nb/u3oknbv0nitjk-d7fcpqmywhxr4.jpeg"><br><br>  <i>Controlador de control de freno de tren eléctrico</i> <br><img src="https://habrastorage.org/webt/6k/mf/eg/6kmfegwxufy_317kqfvmp7n00k8.jpeg"><br><br>  <i>Interruptores de palanca para el control de colectores de corriente y dispositivos de protección (BV / GV) - interruptores de palanca negros cerca del ajustador de velocidad</i> <br><img src="https://habrastorage.org/webt/dn/gs/3p/dngs3pxzgoqcawtdewf84z8squc.jpeg"><br><br>  <i>Interfaz de gestión de formación: pantalla de selección de ruta</i> <br><img src="https://habrastorage.org/webt/_n/sh/jp/_nshjpyo8nu8wbxalcfhtfowns0.jpeg"><br><br>  <i>Pantalla de control de volumen de efectos de audio</i> <br><img src="https://habrastorage.org/webt/ba/ll/p_/ballp_v52zh8rmq4iosfkicienw.jpeg"><br><br>  <i>Contador de kilometraje.</i>  <i>Una historia divertida se asocia con su apariencia.</i>  <i>Cuando entregamos nuestro primer simulador de la locomotora diesel 2TE116, el representante del cliente bromeó con nuestra pregunta sobre cuándo se firmará el acto de finalización: “Bueno, hagámoslo como en la vida: cuando se pone en funcionamiento una nueva locomotora, debe pasar por una carrera de 5000 kilómetros.</i>  <i>Eso pasará ... ".</i>  <i>El acto, por supuesto, se firmó mucho antes, pero, evaluando el humor de la situación, ya hicimos un contador similar en el simulador Swallows.</i>  <i>El contador se puede restablecer a "0" ingresando la contraseña de servicio.</i> <br><img src="https://habrastorage.org/webt/yo/hc/jq/yohcjqcfhoe8irnm6j3ynr9exby.jpeg"><br><br>  <i>Panel accesorio derecho con manómetros de freno y válvula de freno de emergencia.</i>  <i>No todos los elementos inherentes a este Sapsan están instalados aquí; el proveedor recibió un control remoto de este tipo</i> <br><img src="https://habrastorage.org/webt/fr/te/5l/frte5lrezbuss2ng2iesdqcl0p8.jpeg"><br><br>  <i>Por lo tanto, algunos de los controles que son críticos para nosotros se implementaron en el software, en particular, el panel de interruptores de derivación controlados desde la pantalla táctil</i> <br><img src="https://habrastorage.org/webt/he/c2/ga/hec2gahq08cziegrxl1qfkriqya.png"><br></div></div><br>  El desarrollo de software para dicho simulador es una pregunta muy amplia, y trataré (lo mejor que pueda) de satisfacer el interés de los lectores en estos temas en el futuro (si corresponde), pero por ahora, volvamos al tema principal del artículo: visualización tridimensional del proceso de movimiento del tren. <br><br><h1>  2. Antecedentes y tecnología del pasado. </h1><br>  En los comentarios al último artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">, se hizo una pregunta</a> que, francamente, me divirtió bastante.  Sí, de hecho, en muchos simuladores que todavía se usan hoy en día, este enfoque todavía se usa: el video se graba en una sección real del ferrocarril y luego se desplaza en el simulador a una velocidad proporcional a la velocidad de movimiento.  Esto se hizo solo porque en aquellos días en que se crearon tales simuladores, la calidad de los gráficos tridimensionales dejaba mucho que desear, y esto también se aplicaba a las estaciones gráficas duras en Unix comerciales, y no había duda de una PC.  Por lo tanto, incluso los fabricantes de juegos de computadora, por ejemplo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> , no dudaron en utilizar este enfoque. <br><br>  Esto no tiene sentido hoy, porque: <br><br><ol><li>  La velocidad de fotogramas insuficiente a bajas velocidades del tren no proporciona la suavidad deseada de la actualización de la imagen.  Tendremos los atesorados 25 fps solo a la velocidad a la que se grabó el video desde la cabina del conductor.  Y esta falla fatal no se puede superar de ninguna manera, ni disparando con una cámara de alta velocidad (¿cuánto pesará el video a 120 cuadros por segundo? Eso es lo mismo ...), ni por la generación programada de cuadros intermedios.  Este último lo llevamos a cabo utilizando la tecnología OpenCV, pero no condujo a resultados normales.  Esta pregunta se estudió repetidamente desde todos los lados y, como resultado, se concluyó que el costo de los recursos para crear dicho sistema es mucho mayor que el desarrollo de un sistema similar, pero basado en gráficos 3D </li><li>  Dificultades para desplazar suavemente el video hacia atrás.  E incluso teniendo en cuenta que serán superados, entonces, ¿dónde correrán los perros que corren en la plataforma? ¿Creemos que debemos ir en reversa? </li><li>  La falta de toda "interactividad".  ¿Qué hacer con un cambio en el semáforo, con el movimiento de desvíos, el movimiento de trenes que se aproximan y pasan? </li></ol><br>  Por lo tanto, todos los simuladores y simuladores modernos se crean utilizando gráficos 3D interactivos, ya que hoy en día no existen obstáculos desde el punto de vista del software o del hardware. <br><br>  Si todo está muy claro desde el punto de vista del hardware: el monitor instalado en lugar del parabrisas está conectado a una PC con una tarjeta de video normal (ni siquiera la de gama alta), entonces, desde el punto de vista del software, surge la pregunta de elegir la tecnología para implementar la tarea. <br><br><h1>  3. El motor gráfico versus el motor del juego o por qué se eligió OpenSceneGraph </h1><br>  Puedo estar equivocado, pero anticipo los comentarios por adelantado, lo que hará una pregunta completamente lógica, ¿por qué, al analizar las tecnologías existentes, nuestra elección no se detuvo en mastodontes como Unity o Unreal Engine 4?  Contestaré esta pregunta, además, justificaré mi respuesta. <br><br>  Brevemente, ni Unity ni Unreal Engine satisfacen los requisitos de la tarea que se está resolviendo.  Una respuesta más detallada proporciona, en primer lugar, una lista de los requisitos en cuestión.  TK, compilado por nosotros en el subsistema de visualización tridimensional, incluye (en orden decreciente de importancia) las siguientes disposiciones: <br><br><ol><li>  Independencia del proceso de desarrollo de software del subsistema de visualización y del proceso de creación de recursos para él.  Los recursos, en este caso, incluyen modelos tridimensionales, texturas, así como las llamadas <i>rutas</i> .  Una ruta se entiende como una combinación de objetos de configuración y recursos que permiten que el subsistema de video muestre la sección deseada del ferrocarril y simule el movimiento del tren a lo largo de él.  Esto también incluye la <i>posibilidad de cambiar la ruta sin reconstruir la parte del software del subsistema de video</i> </li><li>  Crea rutas de longitud ilimitada.  Haré una reserva de que una longitud ilimitada es en principio inalcanzable debido a los recursos limitados de hardware.  Este requisito debe entenderse que la longitud de la ruta debe estar al menos dentro de un "arcén", es decir, una sección de la carretera entre los puntos de giro, y esto, dependiendo de varios factores, es una distancia suficientemente grande, estimada en más de cien kilómetros.  Este requisito impone la necesidad de proporcionar carga / descarga dinámica de los recursos del programa con suficiente suavidad con un consumo de memoria razonable.  Y es deseable que el motor contenga dicha funcionalidad "fuera de la caja" </li><li>  Integración conveniente con la pila de tecnología utilizada.  Tradicionalmente, debido a razones objetivas nuevamente, nuestro equipo usa lenguaje C ++ con Qt Framework, QtCreator IDE y Git como un sistema de control de versiones para desarrollar software para ULK PS.  Como plataforma de sistema ULK PS, se utiliza un sistema operativo basado en el kernel de Linux </li></ol><br>  ¿Qué hay de malo en Unity y UE?  ¿Cuál es el hecho de que otros motores pueden importar recursos de formatos completamente diferentes?  Sin embargo, al ensamblar el proyecto, se convierten irreversiblemente al formato binario interno, lo que hace que sea imposible agregar y cambiar recursos sin volver a ensamblar el proyecto.  Las tecnologías como los prefabricados y los paquetes de activos disponibles en Unity no resuelven el problema, ya que el editor del motor no es el mejor lugar para crear ubicaciones ferroviarias, lo que requiere la extensión del editor, lo que lleva a la necesidad de escribir un "motor dentro del motor".  Además, la creación de prefabricados y paquetes es imposible sin el uso del editor de Unity, y esto, como ha demostrado la práctica, no es muy conveniente, especialmente para modeladores y diseñadores de niveles puros.  En cuanto a la UE, hice muchas preguntas sobre este y otros recursos durante dos años sobre cómo separar el proceso de construcción de un proyecto del proceso de agregar / cambiar los recursos que usa, y no obtuve una respuesta adecuada ni en la documentación ni en " inveterados "desarrolladores de juegos.  Sería muy feliz (sin sarcasmo) si me topara razonablemente con algo que me perdí. <br><br>  En cuanto al segundo requisito, tanto Unity como UE parecen proporcionar la capacidad de crear ubicaciones cargadas dinámicamente, pero la pregunta sigue sin respuesta, ¿cómo pueden crearse dichas ubicaciones independientemente del editor y sin reconstruir el proyecto?  Solo hay una salida: escribir un "motor dentro del motor", que cargará la geometría y las texturas "en bruto" (en cualquiera de los formatos de exportación establecidos previamente desde editores 3D), aplicará todos los efectos necesarios y colóquelas en el espacio en función de los datos descritos en un tercero independiente del formato del motor, que aún necesita ser desarrollado y enseñado para interpretar el motor. <br><br>  En relación con lo anterior, surge la pregunta: si para resolver este problema es necesario escribir una capa de software potente sobre el motor del juego, cuya mayor parte de la funcionalidad simplemente no es necesaria en el problema en consideración, entonces ¿por qué necesitamos un motor de juego? <br><br>  Tal vez el motor de gráficos es suficiente?  Le hice esta pregunta al equipo anterior, que abordó el problema en discusión, confiando en Unity (y naturalmente se fusionó un poco más tarde).  En respuesta, recibió una contrapregunta: "¿Qué sugieres?", Respondiendo que, en el espíritu del texto anterior, recibió la sonrisa sarcástica de un oponente. <br><br>  Si no tiene sarcasmo, la tarea presentada es una tarea típica de visualización: solo requiere un marco para trabajar con gráficos, ya que tanto la física como el subsistema de audio basado en la física se implementan en el lado del servidor.  Mi equipo y yo llegamos a comprender este hecho, moviéndonos por inercia de los desarrolladores anteriores, primero hacia Unity, a través de UE e intentando sujetar el subsistema de gráficos de uno de los simuladores de ferrocarril abierto (OpenBVE, que por cierto resultó, pero se convirtió en una muleta temporal) <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenSceneGraph</a> es, con mucho, el motor gráfico más desarrollado (abierto y gratuito) centrado en el desarrollo de C ++.  Es ampliamente utilizado en el extranjero precisamente para la visualización técnica tridimensional.  Este motor no se libró de ningún tipo de simulador, el más famoso de los cuales es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FlightGear</a> .  Hubo una vez un simulador ferroviario basado en este motor: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Indra</a> , que, sin embargo, dejó solo capturas de pantalla aburridas del enlace de arriba y su destino adicional es desconocido para mí. <br><br>  En el contexto de la tarea en cuestión, el motor de gráficos OSG tiene las siguientes cualidades positivas: <br><br><ul><li>  Multiplataforma, lo que hace posible su aplicación en el ecosistema GNU / Linux </li><li>  El lenguaje de desarrollo es C ++ / STL, lo que permite integrarlo fácil y naturalmente en el proceso tecnológico de desarrollo establecido; </li><li>  La gama más amplia de formatos de recursos admitidos "listos para usar": geometría 3D y texturas debido al sistema de plug-in desarrollado.  Una interfaz simple e intuitiva para escribir sus propios complementos para configurar el administrador de recursos para formatos no estándar, que utilizamos (escribiré sobre esto a continuación); </li><li>  Un sistema de gestión de memoria basado en su propio modelo de punteros inteligentes (históricamente se ha utilizado un formato patentado de punteros inteligentes, debido al hecho de que al comienzo del desarrollo del motor de puntero inteligente no había un estándar en C ++); </li><li>  Arquitectura modular flexible; </li><li>  El gestor de objetos de escena que carga dinámicamente objetos, proporciona carga y representación de solo aquellos objetos que caen dentro de la pirámide de recorte (debido a la clase osg :: PagedLOD) </li><li>  Capacidad para integrarse con el marco Qt.  Gracias al conveniente modelo de "señales - ranuras" proporcionado por Qt, que simplifica y acelera significativamente el desarrollo de C ++, utilizamos ampliamente este marco para desarrollar software complejo de capacitación.  En consecuencia, hemos acumulado una importante base de código reutilizada en diferentes proyectos, especialmente con respecto a la biblioteca de comunicación entre procesos basada en sockets TCP.  Usar las capacidades de Qt en el proyecto del subsistema de video parece ser una decisión lógica; </li><li>  Suficiente calidad de imagen para la tarea a resolver. </li></ul><br>  Tomó cerca de seis meses de estudio intensivo de las capacidades de OSG para "investigar el terreno" a fondo y encontrar enfoques para resolver el problema con este motor.  Lo que nació como resultado merece una discusión por separado. <br><br><h1>  4. De la arquitectura al prototipo de trabajo. </h1><br>  El subsistema de video de los simuladores de capacitación de material rodante (HTSC) es una aplicación cliente, denominada rutinariamente video3d-client, y realiza las siguientes funciones: <br><br><ul><li>  Solicitud de conexión a la parte del servidor del simulador, autorización en el servidor con solicitud periódica posterior para el identificador de la ruta cargada, y luego la posición actual del tren.  Si la conexión se desconecta del lado del servidor, el sistema cambia al modo de espera para volver a conectarse; </li><li>  Descarga de la ruta seleccionada, organización de la gestión dinámica de los contenidos de la escena renderizada; </li><li>  Realmente renderizando la escena de acuerdo con la posición actual del tren en la ruta </li></ul><br>  No es que este proyecto fuera de código abierto, pero el código de una demostración de tecnología con todas las funciones se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> .  El proyecto consta de los siguientes módulos: <br><br><ul><li>  <i>sistema de archivos</i> : una biblioteca para trabajar con el sistema de archivos, proporciona la generación de rutas a archivos de configuración y recursos de aplicaciones </li><li>  <i>biblioteca</i> : una implementación multiplataforma del cargador dinámico de bibliotecas.  En general, una muleta escrita en un momento en que las posibilidades de integración con Qt (donde hay un módulo QLibrary listo para la batalla) todavía era vago </li><li>  <i>osgdb_dmd</i> es un complemento para cargar modelos de un formato específico para el motor DGLEngine versión 1.1.  Para lo que se requirió, explicaré un poco más abajo </li><li>  <i>route-loader</i> es una biblioteca que proporciona una interfaz abstracta para el cargador de rutas.  Es posible cargar rutas de formato arbitrario </li><li>  <i>tcp-connection</i> : biblioteca de comunicación entre procesos a través de sockets TCP </li><li>  <i>visor</i> - el principal módulo ejecutable del programa </li><li>  <i>zds-route-loader</i> : complemento para cargar rutas del formato ZDSimulator </li></ul><br>  Al diseñar el VTPS, surgió la pregunta de si desarrollar un formato de ruta de forma independiente, o usar el formato de ruta existente, así como rutas ya preparadas de ferrocarriles domésticos para el simulador ferroviario existente.  Afortunadamente, surgió la decisión: el producto cerrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ZDSimulator</a> , que tiene la característica de que está diseñado para el material rodante nacional y los detalles de la red ferroviaria.  A pesar de los elogios de los autores del proyecto, tiene muchos inconvenientes importantes, pero tiene un formato simple y claro de rutas de acceso público.  En la primera etapa, era un pecado no aprovechar la oportunidad, a pesar de que la parte gráfica del simulador se basa en el motor abierto DGLEngine.  El problema es que este motor, aunque está en desarrollo (el estado actual del proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se puede ver aquí</a> ), pero su segunda versión actual es incompatible con la versión 1.1, en la que se basa ZDSimulator.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los códigos fuente de la versión 1.1 se pierden, los enlaces que conducen a ellos se han desvanecido durante mucho tiempo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una búsqueda exhaustiva en el archivo web permitió encontrar a los perdidos y guardarlos publicando </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DGLEngine v1.1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en Gtihub. </font><font style="vertical-align: inherit;">Este motor utiliza su propio formato específico de modelos 3D. </font><font style="vertical-align: inherit;">Teniendo la fuente del motor, fue fácil escribir el complemento apropiado para OSG. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, la tarea de crear HTPS se redujo a escribir la parte del software en el motor OSG. </font><font style="vertical-align: inherit;">En el futuro, se planea desarrollar su propio formato de rutas, ya que el formato actual permite el movimiento solo a lo largo de las rutas principales y tiene una serie de inconvenientes que no permiten recrear una serie de rutas complejas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La jerarquía de las clases principales de HTPS se presenta en el siguiente diagrama</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/2l/sx/592lsx2l9c4ktp7q9j__9mqu3ic.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La jerarquía de clases del cargador de rutas se ve así </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dl/yw/lb/dlywlbrbkjuzxgl_3whfakiv11q.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El cargador de cualquier otro formato de ruta se puede escribir como un complemento que contiene una clase que hereda de la clase RouteLoader. </font><font style="vertical-align: inherit;">Al comienzo de VTPS, la ruta al directorio con la ruta se transfiere a ella, se determina el formato de la ruta y el complemento correspondiente se carga dinámicamente, lo que realiza el resto del trabajo sucio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un matiz fundamentalmente importante fue la integración del motor OSG y Qt. </font><font style="vertical-align: inherit;">Dicha integración existe y se llama </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">osgQt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esta biblioteca no se usó en este proyecto por dos razones:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No hay necesidad de controles de ventana proporcionados por Qt. </font><font style="vertical-align: inherit;">OSG tiene su propio sistema de gestión de ventanas GUI bien desarrollado y no tiene sentido cerrar la GUI encima de otra GUI, ya que osgQt está destinado principalmente a integrar el visor OSG en la GUI basada en Qt</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">osgQt está sujeto a un error: operación incorrecta con el contexto OpenGL, que en algunos casos no se puede dividir entre OSG y QGLWidget, debido a que la escena se muestra en cualquier lugar, pero no en el widget Qt. </font><font style="vertical-align: inherit;">Además, aún no ha sido posible descubrir las razones, ya que en algunos sistemas este error no se manifiesta.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se entendió que la integración con Qt es necesaria en términos del uso del concepto de "ranuras de señal" para garantizar la interacción con el subsistema de red de conexión tcp que usa Qt y es el estándar de facto en nuestros diseños. </font><font style="vertical-align: inherit;">Realmente no quería confiar en el sistema de mensajería OSG y reescribir el cliente TCP (e incluso multiplataforma). </font><font style="vertical-align: inherit;">Se encontró una solución elegante, basada en el hecho de que si queremos que un objeto envíe una señal que active una ranura para otro objeto, debemos cumplir tres condiciones:</font></font><br><br><ol><li>  Heredar clases interactivas de QObject </li><li>  Organice un bucle de procesamiento de señal </li><li>  Cree una instancia de la clase QApplication (o QCoreApplication) que existe en la memoria durante la operación de la aplicación </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este caso, en ningún caso debe realizar una llamada a QApplication :: exec (), que inicia el ciclo de procesamiento de señal regular, es suficiente para organizar un ciclo en el que sea fácil procesar señales llamando a QApplication :: processEvents (). OSG tiene dicho ciclo (el ciclo en el que se realiza el renderizado) y es posible crear un controlador de eventos en el que se procesa el evento osgGA :: GUIEventAdapter :: FRAME generado por el motor cuando se procesa el siguiente marco. Por lo tanto, toda la integración se redujo a código</font></font><br><br>  <b>qt-events.h</b> <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> QT_EVENTS_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QT_EVENTS_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgGA/GUIEventHandler&gt; #include &lt;QtCore/QtCore&gt; class QtEventsHandler : public osgGA::GUIEventHandler { public: QtEventsHandler(){} virtual bool handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa); protected: }; #endif // QT_EVENTS_H</span></span></span></span></code> </pre> <br><br>  <b>qt-events.cpp</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"qt-events.h"</span></span></span><span class="hljs-meta"> bool QtEventsHandler::handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { switch (ea.getEventType()) { case osgGA::GUIEventAdapter::FRAME: { QCoreApplication::processEvents(QEventLoop::AllEvents, 100); break; } default: break; } return false; }</span></span></code> </pre><br>  <b>main.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*! * \fn * \brief Entry point */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { QCoreApplication app(argc, argv); RouteViewer viewer(argc, argv); if (viewer.isReady()) return viewer.run(); return 0; }</span></span></span></span></code> </pre><br>  después de lo cual, las clases heredadas de QObject y sus derivados pueden intercambiar señales hasta que se pierde el pulso. <br><br>  Todo lo anterior permitió durante dos meses crear el primer prototipo funcional de HTPS.  Para demostrar lo que sucedió al final, propongo la siguiente sección de viajes experimentales en rutas reales.  Pido disculpas de antemano por la calidad de los disparos: no obtuvieron tecnología inteligente <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/CENZVOC2ZxE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Conclusión y conclusiones </h1><br>  La conclusión principal, al menos para nuestro equipo, fue que no había una "bala gris" en la elección de la tecnología para implementar el proyecto.  Los motores de juego comercializados agresivamente no siempre son adecuados para resolver tareas específicas, que incluyen la visualización de los resultados de los sistemas técnicos de modelado.  Y si son adecuados, entonces no son óptimos en términos de los esfuerzos dedicados al desarrollo y mantenimiento del proyecto. <br><br>  Es una pena que un motor de gráficos OSG muy bueno y, lo más importante, gratuito, de hecho, no tenga una comunidad en nuestro país.  Para solucionar este problema, escribo una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">serie de artículos aquí sobre el recurso</a> (allí recopilé todos los enlaces a fuentes de información más o menos adecuadas, incluso en ruso).  Además, como documentación que describe los principios básicos de OSG, también puedo ofrecer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este blog</a> .  Espero que alguien encuentre útil esta información. <br><br>  En cuanto a HTSC, el trabajo en esta dirección continúa.  Todavía hay muchas tareas importantes que deben resolverse en el futuro cercano. <br><br>  Gracias por su atencion! <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">(c) Centro para el Desarrollo de Competencias de Innovación</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436276/">https://habr.com/ru/post/es436276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436266/index.html">Escalamiento extremo en Alibaba JDK</a></li>
<li><a href="../es436268/index.html">Recopilamos un mazo completo</a></li>
<li><a href="../es436270/index.html">El 35% de la audiencia de Runet no usa una computadora para Internet</a></li>
<li><a href="../es436272/index.html">Programación visual para Sonoff Basic</a></li>
<li><a href="../es436274/index.html">Se está creando una aplicación móvil para el registro de accidentes en Rusia</a></li>
<li><a href="../es436278/index.html">Verificación de un proyecto CDK con el analizador estático IntelliJ IDEA</a></li>
<li><a href="../es436282/index.html">Desafío de una empresa extranjera o cómo fallé una entrevista</a></li>
<li><a href="../es436284/index.html">Hackear Amazon Echo y Google Home para proteger la privacidad</a></li>
<li><a href="../es436288/index.html">¿Cómo comenzó el monopolio, o un pequeño alboroto con la PC 5150 de IBM?</a></li>
<li><a href="../es436292/index.html">Controlar, modificar, eliminar: los 10 mejores informes de DotNext 2018 Moscú</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>