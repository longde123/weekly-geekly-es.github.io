<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦓 👐🏿 🈳 在Unity中创建猫钩。 第二部分 🗺️ 🌒 🌂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="注意 ：本教程面向高级和有经验的用户，不涉及诸如添加组件，创建新的GameObject脚本和C＃语法之类的主题。 如果您需要提高Unity技能，请查看我们的Unity入门和Unity脚本简介教程。 
 在本教程的第一部分中 ，我们学习了如何使用将绳索缠绕在障碍物上的机制来创建猫钩。 但是，我们还需要...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Unity中创建猫钩。 第二部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415217/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db0/187/d5e/db0187d5e9f5fc2bfa78b078dcb2a178.png" alt="图片"></div><br><blockquote> <em>注意</em> ：本教程面向高级和有经验的用户，不涉及诸如添加组件，创建新的GameObject脚本和C＃语法之类的主题。 如果您需要提高Unity技能，请查看我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Unity入门</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Unity脚本简介</a>教程。 </blockquote><br> 在本教程的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分中</a> ，我们学习了如何使用将绳索缠绕在障碍物上的机制来创建猫钩。 但是，我们还需要更多：绳索可以在水平面上缠绕对象，但返回时不会分离。 <br><a name="habracut"></a><br><h2> 开始工作 </h2><br> 从Unity的第一部分中打开完成的项目，或下载本部分教程的<a href="">草稿</a> ，然后打开<em>2DGrapplingHook-Part2-Starter</em> 。 与第一部分一样，我们将使用Unity版本2017.1或更高版本。 <br><br> 在“ <em>场景”</em>项目文件夹中的编辑器中打开“ <em>游戏”</em>场景。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/89c/ee3/48c/89cee348caa1656418bcc0ded8e91bab.png"></div><br> 启动游戏场景，尝试将猫钩钩在角色上方的石头上，然后摆动以将绳子缠绕在一对石头边缘上。 <br><br> 当您返回时，您会注意到绳索用来转过的石头的点不会再次脱钩。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e9/d83/da7/4e9d83da7eda544a3f48cecbf3e64b08.gif"></div><br> 考虑绳索应展开的位置。 为了简化任务，最好使用绳索缠绕边缘的情况。 <br><br> 如果嵌在其头部上方的石头上的子弹向右摆动，则绳索将在阈值之后弯曲，在该阈值处，该子弹与当前子弹所连接的肋骨交叉180度角点。 在下图中，它以突出显示的绿点显示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3eb/257/132/3eb25713213c01fb76fb97c49e6958cf.png"></div><br> 当子弹向另一个方向摆动时，绳索应再次在同一点解钩（上图中以红色突出显示）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ef/ad3/e22/2efad3e22fddf83cefcf52fca6175792.png"></div><br><h2> 松开的逻辑 </h2><br> 要计算需要在绳索较早缠绕的点上解开绳索的力矩，我们需要了解几何形状。 特别是，我们将使用角度的比较来确定绳索何时应从边缘分离。 <br><br> 这项任务似乎有些令人生畏。 即使在最勇敢的时候，数学也会激发恐惧和绝望。 <br><br> 幸运的是，Unity具有一些出色的数学助手功能，可以使我们的生活更加轻松。 <br><br> 在IDE中打开<em>RopeSystem</em>脚本，并创建一个名为<code>HandleRopeUnwrap()</code>的新方法。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleRopeUnwrap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br> 转到<code>Update()</code>并在最后添加对我们的新方法的调用。 <br><br><pre> <code class="cs hljs">HandleRopeUnwrap();</code> </pre> <br> 尽管<code>HandleRopeUnwrap()</code>什么也不做，但是现在我们可以处理与从边缘分离的整个过程相关的逻辑。 <br><br> 正如您在本教程的第一部分中所记得的那样，我们将绳索缠绕位置存储在一个名为<code>ropePositions</code>的集合中，该集合是一个<code>List&lt;Vector2&gt;</code>集合。 每次绳索缠绕一条边缘时，我们都会在该集合中保留此包裹点的位置。 <br><br> 为了使过程更高效，如果集合中存储的位置数等于或小于1，我们将不会在<code>HandleRopeUnwrap()</code>执行任何逻辑。 <br><br> 换句话说，当<code>ropePositions</code>钩到起点并且其绳索尚未缠绕在边缘上时， <code>ropePositions</code>的数量将为1，并且我们将不会遵循<code>ropePositions</code>的处理逻辑。 <br><br> 将此简单的<code>return</code>添加到<code>HandleRopeUnwrap()</code>的顶部，以节省宝贵的CPU周期，因为每秒从<code>Update()</code>多次调用此方法。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ropePositions.Count &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><h3> 添加新变量 </h3><br> 在此新测试下，我们将添加一些尺寸和参考，以实现实现扭曲逻辑基础所需的不同角度。 将以下代码添加到<code>HandleRopeUnwrap()</code> ： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Hinge =       // Anchor =     Hinge // Hinge Angle =   anchor  hinge // Player Angle =   anchor  player // 1 var anchorIndex = ropePositions.Count - 2; // 2 var hingeIndex = ropePositions.Count - 1; // 3 var anchorPosition = ropePositions[anchorIndex]; // 4 var hingePosition = ropePositions[hingeIndex]; // 5 var hingeDir = hingePosition - anchorPosition; // 6 var hingeAngle = Vector2.Angle(anchorPosition, hingeDir); // 7 var playerDir = playerPosition - anchorPosition; // 8 var playerAngle = Vector2.Angle(anchorPosition, playerDir);</span></span></code> </pre> <br> 这里有很多变量，因此我将解释它们中的每一个，并添加一个方便的插图以帮助理解它们的目的。 <br><br><ol><li>  <code>anchorIndex</code>是<code>ropePositions</code>集合中位于集合末尾两个位置的索引。 我们可以将其视为从子弹位置到绳索上两个位置的点。 在下图中，这是将挂钩连接到表面的第一个点。 当<code>ropePositions</code>新的包裹点填充<code>ropePositions</code>集合<code>ropePositions</code> ，该点将始终保持包裹点<code>ropePositions</code>相距两个位置。 </li><li> 铰链索引是存储当前铰链点的集合的索引； 换句话说，绳子当前缠绕在从条塞最接近绳子末端的点周围的位置。 它总是与<code>ropePositions.Count - 1</code>相距一个位置，这就是为什么我们使用<code>ropePositions.Count - 1</code> 。 </li><li>  <code>anchorPosition</code>通过引用<code>ropePositions</code>集合中的<code>anchorIndex</code>位置<code>anchorPosition</code>计算的，并且是该位置的简单Vector2值。 </li><li>  <code>hingePosition</code>通过引用<code>ropePositions</code>集合中<code>hingeIndex</code>索引的位置<code>hingePosition</code>计算的，并且是该位置的简单Vector2值。 </li><li>  <code>hingeDir</code>是从<code>anchorPosition</code>定向到<code>hingePosition</code>的向量。 在以下变量中使用它来获取角度。 </li><li> 铰链角度-有用的辅助函数<code>Vector2.Angle()</code>在此处用于计算<code>anchorPosition</code>和铰链点之间的角度。 </li><li>  <code>playerDir</code>是从<code>anchorPosition</code>指向<code>playerDir</code>当前位置（playerPosition）的向量 </li><li> 然后，使用锚点和玩家（子弹）之间的角度，计算玩家角度。 </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73f/207/4c4/73f2074c470b3016bcd5ee386ce240e8.png"></div><br> 所有这些变量都是使用存储在<code>ropePositions</code>集合中的Vector2值存储的位置并将这些位置与其他位置或播放器（子弹）的当前位置进行比较来计算的。 <br><br> 用于比较的两个重要变量是<code>hingeAngle</code>和<code>hingeAngle</code> 。 <br><br> 存储在<code>hingeAngle</code>角度中的值必须保持静态，因为它始终是从<code>hingeAngle</code>的两个“绳索折叠”处的点到<code>hingeAngle</code>的当前“绳索的折叠”之间的点之间恒定的角度，直到松开绳索或折叠后该点才移动将添加一个新的弯曲点。 <br><br> 当<code>playerAngle</code>改变。 通过将这个角度与<code>hingeAngle</code>角度进行<code>hingeAngle</code> ，并检查<code>hingeAngle</code>是在该角的左侧还是右侧，我们可以确定是否应分离最靠近<code>hingeAngle</code>的当前折叠点。 <br><br> 在本教程的第一部分中，我们将折叠位置保存在名为<code>wrapPointsLookup</code>的字典中。 每次保存弯曲点时，我们都将弯曲点添加到字典中，位置为键，值为0。 但是，这个0值相当神秘，对吧？ <br><br> 我们将使用该值存储弹头相对于其与铰链点（当前折叠点最接近弹头）的角度的位置。 <br><br> 如果您将值指定为<em>-1</em> ，则<code>hingeAngle</code>的角度（ <code>hingeAngle</code> ）小于铰链的角度（ <code>hingeAngle</code> ），并且值为<em>1时，</em> <code>hingeAngle</code> <em>的</em>角度大于<code>hingeAngle</code> <em>的</em>角度。 <br><br> 由于我们将值保存在字典中，因此，每次将<code>hingeAngle</code>与<code>hingeAngle</code>进行比较时，我们都可以了解到弹头是否刚刚超过了限制，然后就可以解开绳索了。 <br><br> 可以用不同的方式解释：如果刚检查了弹头的角度并且该角度小于铰链角度，但是最后一次将其保存在折弯点字典中时，将其标记为一个值，指示该点位于该拐角的另一侧，则应立即移除该点。 ！ <br><br><h3> 解开绳 </h3><br> 请看下面的屏幕截图，并附上注释。 我们的弹头紧紧抓住岩石，向上摇摆，在上升的过程中将一根绳子缠绕在岩石的边缘。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db0/187/d5e/db0187d5e9f5fc2bfa78b078dcb2a178.png"></div><br> 您可能会注意到，在<code>wrapPointsLookup</code>不透明的最高挥杆位置，其当前最近的折叠点（标有白点）将存储在<code>wrapPointsLookup</code>词典中，值为<em>1</em> 。 <br><br> 在向下的过程中，当<code>playerAngle</code>变得小于<code>hingeAngle</code> （两条绿色的虚线）时，如蓝色箭头所示，将执行检查，如果折弯点的最后一个（当前）值为<em>1</em> ，则应删除折弯点。 <br><br> 现在，让我们在代码中实现此逻辑。 但是在开始之前，让我们创建一个将用于展开的方法的空白。 因此，创建逻辑后，不会导致错误。 <br><br> 通过插入以下行来添加新的<code>UnwrapRopePosition(anchorIndex, hingeIndex)</code>方法<code>UnwrapRopePosition(anchorIndex, hingeIndex)</code> ： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnwrapRopePosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> anchorIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hingeIndex</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br> 完成此操作后，回到<code>HandleRopeUnwrap()</code> 。 在新添加的变量下，添加以下逻辑，该逻辑将处理两种情况： <code>hingeAngle</code>小于<code>hingeAngle</code>以及<code>hingeAngle</code>大于<code>hingeAngle</code> ： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (playerAngle &lt; hingeAngle) { <span class="hljs-comment"><span class="hljs-comment">// 1 if (wrapPointsLookup[hingePosition] == 1) { UnwrapRopePosition(anchorIndex, hingeIndex); return; } // 2 wrapPointsLookup[hingePosition] = -1; } else { // 3 if (wrapPointsLookup[hingePosition] == -1) { UnwrapRopePosition(anchorIndex, hingeIndex); return; } // 4 wrapPointsLookup[hingePosition] = 1; }</span></span></code> </pre> <br> 此代码应对应于上述第一种情况的逻辑说明（当<code>hingeAngle</code> &lt; <code>hingeAngle</code> ），但也应处理第二种情况（当<code>hingeAngle</code> &gt; <code>hingeAngle</code> ）。 <br><br><ol><li> 如果最接近<code>hingeAngle</code>的当前折叠点在<code>hingeAngle</code> &lt; <code>hingeAngle</code>角度的点处的值为<em>1</em> ，则我们删除该点并执行返回操作，以便该方法的其余部分不执行。 </li><li> 否则，如果弯曲点最后未标记为值<em>1</em> ，但<code>hingeAngle</code>小于<code>hingeAngle</code> ，则分配<em>-1</em> 。 </li><li> 如果当前最靠近<code>hingeAngle</code>折叠点在<code>hingeAngle</code> &gt; <code>hingeAngle</code>的点处为<em>-1</em> ，则移除该点并返回。 </li><li> 否则，我们将折点字典中位于铰链位置的条目分配为<em>1</em> 。 </li></ol><br> 此代码确保<code>wrapPointsLookup</code>字典始终处于更新状态，以确保当前折弯点的值（最接近<code>wrapPointsLookup</code>块）与当前相对于折弯点的<code>wrapPointsLookup</code>块角度匹配。 <br><br> 不要忘记，当凸角小于铰链角（相对于参考点）时，该值为-1；而当凸角大于铰链角时，该值为1。 <br><br> 现在，我们将在<em>RopeSystem</em>脚本中<code>UnwrapRopePosition()</code>代码， <em>该</em>代码将直接进行解耦，移动参考位置并为绳索距离值DistanceJoint2D分配新的距离值。 将以下行添加到以前创建的方法光盘中： <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// 1 var newAnchorPosition = ropePositions[anchorIndex]; wrapPointsLookup.Remove(ropePositions[hingeIndex]); ropePositions.RemoveAt(hingeIndex); // 2 ropeHingeAnchorRb.transform.position = newAnchorPosition; distanceSet = false; // Set new rope distance joint distance for anchor position if not yet set. if (distanceSet) { return; } ropeJoint.distance = Vector2.Distance(transform.position, newAnchorPosition); distanceSet = true;</span></span></code> </pre> <br><ol><li> 当前锚点的索引（绳索从子弹的第二位置）变为铰链的新位置，并且铰链的旧位置被移除（以前最靠近子弹的位置，现在我们“解开”）。 变量<code>newAnchorPosition</code>在绳索位置列表中分配了值<code>anchorIndex</code> 。 然后将其用于定位锚点的更新位置。 </li><li> 绳索接头RigidBody2D（DivistJoint2D绳索连接到该绳索接头）将其位置更改为锚点的新位置。 这确保了将子弹连接到DistanceJoint2D时，它在绳索上的平稳连续运动，并且此连接应允许它相对于新位置继续摆动，该新位置成为参考-换句话说，相对于绳索从其位置向下的下一个点。 </li><li> 然后，您需要更新distanceJoint2D距离值，以考虑从弹头到新参考点的距离的急剧变化。 如果尚未完成此操作，则将对<code>distanceSet</code>标志进行快速检查，并为该距离分配弹头与锚点的新位置之间的计算距离值。 </li></ol><br> 保存脚本并返回到编辑器。 再次开始游戏，并观察当弹头超过每个弯曲点的阈值时绳索如何从边缘脱离！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65b/4af/3a1/65b4af3a13e464947b394595dc052a06.gif"></div><br> 尽管逻辑已经准备好了，但我们还是在将<code>hingeAngle</code>与<code>hingeAngle</code> （ <code>if (playerAngle &lt; hingeAngle)</code> ）进行比较之前，向<code>HandleRopeUnwrap()</code>添加了一些辅助代码。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!wrapPointsLookup.ContainsKey(hingePosition)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"We were not tracking hingePosition ("</span></span> + hingePosition + <span class="hljs-string"><span class="hljs-string">") in the look up dictionary."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br> 实际上，这不应该发生，因为当猫钩两次缠绕一条肋骨时，我们会重新定义并断开其连接，但是如果仍然发生这种情况，我们可以通过简单的<code>return</code>和错误消息轻松退出此方法。在控制台中。 <br><br> 此外，由于此，我们将更方便地处理这种限制情况； 此外，如果发生不必要的事情，我们会收到错误消息。 <br><br><h2> 接下来要去哪里？ </h2><br> 这里是本教程第二部分和最后一部分<a href="">的完成项目的链接</a> 。 <br><br> 祝贺您完成本教程系列！ 当比较角度和位置时，一切都变得相当复杂，但是我们幸免于难，现在我们有了一个很棒的钩猫和绳索系统，可以将游戏中的物体缠绕起来。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5f/69a/cbe/b5f69acbefc9de390ff25f0fbc4cbe10.png"></div><br> 您知道我们的Unity开发团队写过书吗？ 如果不是，请查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Unity Games By Tutorials</a> 。 该游戏将教您如何从头开始创建四个现成的游戏： <br><br><ul><li> 两杆射手 </li><li> 第一人称射击游戏 </li><li> 塔防游戏（具有VR支持！） </li><li>  2D平台游戏 </li></ul><br> 阅读本书之后，您将学习如何为Windows，macOS，iOS和其他平台创建自己的游戏！ <br><br> 本书既适合初学者，又适合希望将Unity技能提升到专业水平的人。 要掌握这本书，您需要具有编程经验（任何语言）。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN415217/">https://habr.com/ru/post/zh-CN415217/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN415207/index.html">当天堂失去完美时</a></li>
<li><a href="../zh-CN415209/index.html">“我需要保护一个空房间”：无意义的工作的出现</a></li>
<li><a href="../zh-CN415211/index.html">银河系隐藏了成千上万个黑洞</a></li>
<li><a href="../zh-CN415213/index.html">选举根本行不通； 必须责怪数学</a></li>
<li><a href="../zh-CN415215/index.html">密歇根大学推出世界上最小的计算机</a></li>
<li><a href="../zh-CN415219/index.html">我如何收到国外知名出版​​商的报价，希望成为在线课程的作者</a></li>
<li><a href="../zh-CN415221/index.html">安全周23：500亿个物联网设备</a></li>
<li><a href="../zh-CN415223/index.html">销售渠道</a></li>
<li><a href="../zh-CN415227/index.html">2018年的开发生态系统：俄罗斯和世界上程序员的生活</a></li>
<li><a href="../zh-CN415229/index.html">DevTube-适用于开发人员的新型开源视频聚合器</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>