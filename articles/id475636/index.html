<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👨🏽 👩🏼‍💻 🔨 Elemen Vektor Bertambah 👩🏽‍🍳 🏴 🍯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam hal apa kenaikan elemen std :: vector lebih cepat - jika bertipe uint8_t atau uint32_t ? 

 Agar tidak beralasan secara abstrak, kami mempertimb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elemen Vektor Bertambah</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/475636/">  Dalam hal apa kenaikan elemen <i>std :: vector</i> lebih cepat - jika bertipe <i>uint8_t</i> atau <i>uint32_t</i> ? <br><br>  Agar tidak beralasan secara abstrak, kami mempertimbangkan dua implementasi spesifik: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector8_inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); i++) { v[i]++; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector32_inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); i++) { v[i]++; } }</code> </pre> <a name="habracut"></a><br><h2>  Mari kita coba tebak </h2><br>  Mudah untuk menjawab pertanyaan ini menggunakan tolok ukur, dan beberapa saat kemudian kami akan melakukannya, tetapi pertama-tama kami akan mencoba menebak (ini disebut "penalaran berdasarkan prinsip-prinsip dasar" - ini terdengar lebih seperti aroma). <br><br>  Pertama, ada baiknya mengajukan pertanyaan: <i>Berapa ukuran vektor ini</i> ? <br><br>  Baiklah, mari kita pilih beberapa nomor.  Biarkan ada 20.000 elemen di masing-masing. <br><br>  Lebih lanjut, diketahui bahwa kita akan menguji pada prosesor Intel Skylake - kita akan melihat karakteristik perintah tambahan untuk operan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8-bit</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">32-bit</a> dengan pengalamatan langsung.  Ternyata indikator utamanya sama: 1 operasi per siklus dan penundaan 4 siklus per akses memori (1).  Dalam hal ini, penundaan tidak menjadi masalah, karena setiap operasi penambahan dilakukan secara independen, sehingga kecepatan yang dihitung adalah 1 elemen per siklus, dengan ketentuan bahwa semua sisa pekerjaan pada loop akan dilakukan secara paralel. <br><br>  Anda juga dapat melihat bahwa 20.000 item sesuai dengan dataset 20 Kbyte untuk versi dengan <i>uint8_t</i> dan sebanyak 80 Kbytes untuk versi dengan <i>uint32_t</i> .  Dalam kasus pertama, mereka secara ideal sesuai dengan cache level L1 dari komputer berbasis x86 modern, dan yang kedua - tidak.  Ternyata versi 8-bit akan mendapatkan kemajuan karena caching yang efisien? <br><br>  Akhirnya, kami mencatat bahwa tugas kami sangat mirip dengan kasus klasik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vektorisasi otomatis</a> : dalam satu lingkaran dengan jumlah iterasi yang diketahui, operasi aritmatika dilakukan pada elemen-elemen yang secara berurutan terletak di memori.  Dalam hal ini, versi 8-bit harus memiliki keunggulan luar biasa dibandingkan versi 32-bit, karena satu operasi vektor akan memproses elemen empat kali lebih banyak dan, secara umum, prosesor Intel melakukan operasi vektor pada elemen byte tunggal pada kecepatan yang sama dengan lebih dari 32 elemen bit. <br><br>  Baiklah, berhenti mengomel.  Saatnya beralih ke ujian. <br><br><h2>  Tolok ukur </h2><br>  Saya mendapatkan pewaktuan berikut untuk vektor dari 20.000 elemen pada <i>kompiler</i> <i>gcc 8</i> dan <i>clang 8</i> dengan tingkat optimisasi yang berbeda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l_/6r/k7/l_6rk7tnbeguzjnreatqtggsopg.png"></div><br>  Ternyata, dengan pengecualian tingkat <i>-O1</i> , versi dengan <i>uint32_t</i> lebih cepat daripada versi dengan <i>uint8_t</i> , dan dalam beberapa kasus ini penting: 5,4 kali pada gcc di tingkat <i>-O3</i> dan tepat 8 kali dentang di kedua tingkat, <i>-O2</i> dan <i>- O3</i> .  Ya, peningkatan bilangan bulat 32-bit dalam <i>std :: vector</i> hingga delapan kali lebih cepat daripada peningkatan bilangan bulat 8-bit pada kompiler populer dengan pengaturan optimalisasi standar. <br><br>  Seperti biasa, mari kita beralih ke daftar assembler dengan harapan akan menjelaskan apa yang terjadi. <br><br>  Berikut adalah daftar untuk gcc 8 pada level <i>-O2</i> , di mana versi 8-bit "hanya" 1,5 kali lebih lambat dari versi 32-bit (2): <br><br>  <b>8-bit:</b> <br><br><pre> <code class="cpp hljs">.L3: inc BYTE PTR [rdx+rax] mov rdx, QWORD PTR [rdi] inc rax mov rcx, QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>] sub rcx, rdx cmp rax, rcx jb .L3</code> </pre> <br>  <b>32-bit:</b> <br><pre> <code class="cpp hljs">.L9: inc DWORD PTR [rax] add rax, <span class="hljs-number"><span class="hljs-number">4</span></span> cmp rax, rdx jne .L9</code> </pre> <br>  Versi 32-bit terlihat persis seperti yang kita harapkan dari loop (3) undeveloped: increment (4) dengan alamat, lalu tiga perintah kontrol loop: <i>add rax</i> , <i>4 -</i> kenaikan variabel inductive (5) dan beberapa perintah <i>cmp</i> dan <i>jne</i> untuk memeriksa kondisi untuk keluar dari loop dan melompat bersyarat di atasnya.  Semuanya tampak hebat - penyebaran akan mengimbangi biaya penambahan penghitung dan memeriksa kondisinya, dan kode kami akan hampir mencapai kecepatan maksimum yang mungkin dari 1 elemen per siklus clock (6), tetapi untuk aplikasi open-source itu akan dilakukan.  Dan bagaimana dengan versi 8-bit?  Selain perintah <i>inc</i> dengan alamat, dua perintah tambahan untuk membaca dari memori dieksekusi, serta perintah <i>sub</i> , yang diambil entah dari mana. <br><br>  Berikut adalah daftar dengan komentar: <br><br>  <b>8-bit:</b> <br><br><pre> <code class="cpp hljs">.L3: inc BYTE PTR [rdx+rax] ;    v[i] mov rdx, QWORD PTR [rdi] ;  v.begin inc rax ; i++ mov rcx, QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;  v.end sub rcx, rdx ; end - start (.. <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.size()) cmp rax, rcx ; i &lt; size() jb .L3 ; .   i &lt; size()</code> </pre> <br>  Di sini <i>vector :: begin</i> dan <i>vector :: end</i> adalah pointer internal <i>std :: vector</i> , yang digunakan untuk menunjukkan awal dan akhir dari urutan elemen yang terkandung dalam area yang dipilih untuk itu (7), ini pada dasarnya adalah nilai yang sama yang digunakan untuk mengimplementasikan <i>vector :: begin ()</i> dan <i>vector :: end ()</i> (walaupun mereka bertipe berbeda).  Ternyata semua perintah tambahan hanyalah konsekuensi dari perhitungan <i>vector.size ()</i> .  Sepertinya tidak ada yang aneh?  Tetapi setelah semua, dalam versi 32-bit, tentu saja, <i>size ()</i> juga dihitung, namun, perintah ini tidak ada dalam daftar itu.  Perhitungan <i>ukuran ()</i> terjadi hanya sekali - di luar loop. <br><br>  Jadi ada apa?  Jawaban singkatnya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pointer alias</a> .  Saya akan memberikan jawaban terinci di bawah ini. <br><br><h2>  Jawaban terinci </h2><br>  Vektor dilewatkan ke fungsi dengan referensi, yang, pada kenyataannya, adalah pointer bertopeng.  Compiler harus pergi ke anggota <i>v :: begin</i> dan <i>v :: end of</i> vector untuk menghitung ukuran <i>ukurannya ()</i> , dan dalam contoh kita, <i>ukuran ()</i> dihitung <i>pada</i> setiap iterasi.  Tetapi kompiler tidak diwajibkan untuk secara buta mematuhi kode sumber: itu mungkin membawa hasil memanggil fungsi <i>size () di</i> luar loop, tetapi hanya jika ia tahu pasti bahwa semantik program <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak akan berubah</a> .  Dari sudut pandang ini, satu-satunya tempat yang bermasalah dalam loop adalah kenaikan <i>v [i] ++</i> .  Rekaman berlangsung di alamat yang tidak dikenal.  Bisakah operasi seperti itu mengubah nilai ukuran ()? <br><br>  Jika catatan terjadi di <i>std :: vector &lt;uint32_t&gt;</i> (mis. Oleh pointer <i>uint32_t *</i> ), maka tidak, itu tidak dapat mengubah nilai <i>size ()</i> .  Menulis ke objek tipe <i>uint32_t</i> hanya dapat memodifikasi objek tipe <i>uint32_t</i> , dan pointer yang terlibat dalam menghitung <i>ukuran ()</i> memiliki tipe yang berbeda (8). <br><br>  Namun, dalam kasus <i>uint8_t</i> , setidaknya pada kompiler populer (9), jawabannya adalah: ya, secara teoritis, nilai <b><i>ukuran ()</i></b> <b>dapat berubah</b> , karena <i>uint8_t</i> adalah alias untuk <i>char unsigned</i> , dan array tipe <i>char unsigned</i> (dan <i>char</i> ) bisa <i>Alias ​​dengan tipe lain</i> .  Ini berarti bahwa, menurut kompiler, menulis ke <i>pointer uint8_t</i> dapat mengubah isi memori yang tidak diketahui asalnya di alamat mana pun (10).  Oleh karena itu, diasumsikan bahwa setiap operasi kenaikan <i>v [i] ++</i> dapat mengubah nilai <i>size ()</i> , dan karena itu dipaksa untuk menghitung ulang pada setiap iterasi dari loop. <br><br>  Kita semua tahu bahwa menulis ke memori yang ditunjuk oleh <i>std :: vector</i> tidak akan pernah mengubah ukurannya sendiri <i>()</i> , karena ini berarti bahwa vektor itu sendiri entah bagaimana dialokasikan di dalam tumpukannya sendiri, dan itu praktis mustahil dan mirip dengan masalah ayam dan telur (11).  Namun sayangnya ini tidak diketahui oleh kompiler! <br><br><h2>  Bagaimana dengan sisa hasilnya? </h2><br>  Yah, kami menemukan mengapa versi dengan <i>uint8_</i> sedikit lebih lambat dari versi <i>uint32_t</i> pada gcc di level <i>-O2</i> .  Tapi mengapa menjelaskan perbedaan besar - hingga 8 kali - pada dentang atau gcc yang sama pada <i>-O3</i> ? <br><br>  Semuanya sederhana di sini: dalam kasus <i>uint32_t,</i> dentang dapat melakukan loop otomatis vektorisasi: <br><br><pre> <code class="cpp hljs">.LBB1_6: ; =&gt;This Inner Loop Header: Depth=<span class="hljs-number"><span class="hljs-number">1</span></span> vmovdqu ymm1, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi] vmovdqu ymm2, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">32</span></span>] vmovdqu ymm3, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">64</span></span>] vmovdqu ymm4, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">96</span></span>] vpsubd ymm1, ymm1, ymm0 vpsubd ymm2, ymm2, ymm0 vpsubd ymm3, ymm3, ymm0 vpsubd ymm4, ymm4, ymm0 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi], ymm1 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">32</span></span>], ymm2 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">64</span></span>], ymm3 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">96</span></span>], ymm4 vmovdqu ymm1, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">128</span></span>] vmovdqu ymm2, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">160</span></span>] vmovdqu ymm3, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">192</span></span>] vmovdqu ymm4, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">224</span></span>] vpsubd ymm1, ymm1, ymm0 vpsubd ymm2, ymm2, ymm0 vpsubd ymm3, ymm3, ymm0 vpsubd ymm4, ymm4, ymm0 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">128</span></span>], ymm1 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">160</span></span>], ymm2 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">192</span></span>], ymm3 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">224</span></span>], ymm4 add rdi, <span class="hljs-number"><span class="hljs-number">64</span></span> add rsi, <span class="hljs-number"><span class="hljs-number">2</span></span> jne .LBB1_6</code> </pre> <br>  Siklus ini digunakan 8 kali, dan ini secara umum adalah kinerja maksimum yang bisa Anda dapatkan: satu vektor (8 elemen) per siklus clock untuk cache L1 (ini tidak akan lagi berfungsi karena keterbatasan satu operasi tulis per siklus clock (12)). <br><br>  <i>Vektorisasi</i> tidak dilakukan untuk <i>uint8_t</i> , karena terhambat oleh kebutuhan untuk menghitung <i>ukuran ()</i> untuk memeriksa kondisi loop pada setiap iterasi.  Alasan lag masih sama, tetapi lag itu sendiri jauh lebih besar. <br><br>  Pengaturan waktu terendah dijelaskan oleh auto-vektorisasi: gcc hanya menerapkannya pada level <i>-O3</i> , dan dentang berlaku pada level <i>-O2</i> dan <i>-O3</i> secara default.  Compiler level -cc gcc menghasilkan kode yang sedikit lebih lambat daripada dentang karena tidak memperluas loop yang di-autovektorat. <br><br><h2>  Perbaiki situasi </h2><br>  Kami menemukan apa masalahnya - bagaimana kami bisa memperbaikinya? <br><br>  Pertama, mari kita coba satu cara yang, bagaimanapun, tidak akan berhasil, yaitu, kita akan menulis siklus yang lebih idiomatis berdasarkan iterator: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = v.begin(); i != v.end(); ++i) { (*i)++; }</code> </pre> <br>  Kode yang dihasilkan <i>gcc</i> pada level <i>-O2</i> akan sedikit lebih baik daripada opsi dengan <i>ukuran ()</i> : <br><br><pre> <code class="cpp hljs">.L17: add BYTE PTR [rax], <span class="hljs-number"><span class="hljs-number">1</span></span> add rax, <span class="hljs-number"><span class="hljs-number">1</span></span> cmp QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>], rax jne .L17</code> </pre> <br>  Dua operasi baca tambahan berubah menjadi satu, karena <i>saya</i> sekarang kita bandingkan dengan pointer <i>akhir</i> vektor, dan jangan menghitung ulang <i>ukuran ()</i> , kurangi pointer ke awal vektor dari pointer akhir.  Dengan jumlah instruksi, kode ini menyusul <i>uint32_t</i> , karena operasi baca ekstra digabungkan dengan operasi perbandingan.  Namun, masalahnya belum hilang dan auto-vektorisasi masih belum tersedia, jadi <i>uint8_t</i> masih signifikan di belakang <i>uint32_t</i> - lebih dari 5 kali pada gcc dan dentang pada level di mana auto-vektorisasi disediakan. <br><br>  Mari kita coba yang lain.  Kami tidak akan berhasil lagi, atau lebih tepatnya, kami akan menemukan metode <i>lain yang</i> tidak beroperasi. <br><br>  Dalam versi ini, kami menghitung <i>ukuran ()</i> hanya sekali sebelum loop dan menempatkan hasilnya dalam variabel lokal: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, s = v.size(); i &lt; s; i++) { v[i]++; }</code> </pre> <br>  Tampaknya bisa berfungsi?  Masalahnya adalah <i>size ()</i> , dan sekarang kami memerintahkan compiler untuk melakukan hasil <i>size ()</i> ke variabel lokal di awal loop, dan variabel lokal, seperti yang Anda tahu, tidak berpotongan dengan data lain.  Kami benar-benar melakukan apa yang tidak dapat dilakukan oleh kompiler.  Dan kode yang akan dihasilkannya sebenarnya akan lebih baik (dibandingkan dengan yang asli): <br><br><pre> <code class="cpp hljs">.L9: mov rdx, QWORD PTR [rdi] add BYTE PTR [rdx+rax], <span class="hljs-number"><span class="hljs-number">1</span></span> add rax, <span class="hljs-number"><span class="hljs-number">1</span></span> cmp rax, rcx jne .L9</code> </pre> <br>  Hanya ada satu operasi baca tambahan dan tidak ada perintah <i>sub</i> .  Tapi apa yang dilakukan perintah tambahan ini ( <i>rdx, QWORD PTR [rdi]</i> ) jika tidak terlibat dalam perhitungan ukuran?  Bunyinya pointer <i>data ()</i> dari <i>v</i> ! <br><br>  Ekspresi <i>v [i]</i> diimplementasikan sebagai <i>* (v.data () + i)</i> , dan anggota dikembalikan oleh <i>data ()</i> (dan, pada kenyataannya, pointer <i>awalan</i> reguler) menimbulkan masalah yang sama dengan <i>size ()</i> .  Benar, saya tidak melihat operasi ini dalam versi asli, karena itu ada "gratis", karena masih harus dilakukan untuk menghitung ukuran. <br><br>  Beruang dengan sedikit lagi, kami hampir menemukan solusi.  Anda hanya perlu menghapus dari loop kami <i>semua</i> dependensi pada konten <i>std :: vector</i> .  Cara termudah untuk melakukannya adalah dengan memodifikasi idiom kami dengan iterator sedikit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = v.begin(), e = v.end(); i != e; ++i) { (*i)++; }</code> </pre> <br>  Sekarang semuanya telah berubah secara dramatis (di sini kita hanya membandingkan versi dengan <i>uint8_t</i> - di satu kita menyimpan iterator <i>akhir</i> dalam variabel lokal <i>sebelum</i> loop, yang lain - tidak): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lp/pe/xj/lppexj0vgqumpzvblxctc7xkkoa.png"></div><br>  Perubahan kecil ini memberi kami peningkatan kecepatan 20 kali lipat pada level dengan auto-vektorisasi.  Selain itu, kode dengan <i>uint8_t</i> tidak hanya mengejar kode dengan <i>uint32_t</i> - itu menyalip hampir tepat 4 kali oleh gcc <i>-O3</i> dan dentang <i>-O2</i> dan <i>-O3</i> , seperti yang kami harapkan di awal, mengandalkan vektorisasi: pada akhirnya, tepat empat kali lebih banyak elemen dapat diproses oleh operasi vektor dan kita membutuhkan bandwidth empat kali lebih sedikit - terlepas dari tingkat cache (13). <br><br>  Jika Anda membaca ke tempat ini, maka Anda harus berseru kepada diri sendiri selama ini: <br><br>  <i>Tapi bagaimana dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>for-loop dengan band traversal yang</i></a> diperkenalkan di C ++ 11?</i> <br><br>  Saya cepat-cepat menyenangkan Anda: itu berhasil!  Ini, pada kenyataannya, adalah gula sintaksis, di belakang yang bersembunyi versi kita dengan iterator dalam bentuk yang hampir sama, di mana kita memperbaiki pointer <i>akhir</i> dalam variabel lokal sebelum dimulainya loop.  Jadi kecepatannya sama. <br><br>  Jika kami tiba-tiba memutuskan untuk kembali ke zaman gua purba dan menulis fungsi mirip-C, kode seperti itu akan berfungsi juga: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array_inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { a[i]++; } }</code> </pre> <br>  Di sini, pointer ke array <i>a</i> dan <i>ukuran</i> variabel dilewatkan ke fungsi dengan nilai, sehingga mereka tidak dapat diubah sebagai hasil dari penulisan ke pointer <i>a</i> (14) - sama seperti variabel lokal.  Kinerja kode ini sama dengan opsi sebelumnya. <br><br>  Akhirnya, pada kompiler di mana opsi ini tersedia, Anda dapat mendeklarasikan vektor dengan <i>__restrict</i> (15): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector8_inc_restrict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; __restrict v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); i++) { v[i]++; } }</code> </pre> <br>  <i>Kata kunci terbatas __</i> bukan bagian dari standar C ++, tetapi bagian dari standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C sejak C99</a> (sebagai <i>batasan</i> ).  Jika ini diterapkan sebagai ekstensi C ++ di kompiler, maka kemungkinan besar ia akan mematuhi semantik C. Tentu saja, tidak ada tautan di C, sehingga Anda dapat secara mental mengganti tautan ke vektor dengan penunjuk ke vektor. <br><br>  Perhatikan bahwa pembatasan tidak memiliki <i>properti</i> transitif: aksi specifier <i>__restrict</i> , dengan mana tautan ke <i>std :: vector</i> dideklarasikan, hanya berlaku untuk anggota vektor itu sendiri, dan tidak ke heap region yang dirujuk oleh <i>v.data ()</i> .  Dalam kasus kami, lebih banyak tidak diperlukan, karena (seperti dalam kasus variabel lokal) cukup meyakinkan kompiler bahwa istilah itu sendiri, menunjuk ke awal dan akhir vektor, tidak berpotongan dengan apa pun.  Klausa tentang <i>pembatasan</i> , bagaimanapun, masih relevan, karena menulis melalui <i>v.data ()</i> masih dapat menyebabkan objek lain di fungsi Anda berubah karena alias. <br><br><h2>  Kekecewaan </h2><br>  Di sini kita sampai pada kesimpulan terakhir - dan sangat mengecewakan -.  Faktanya adalah bahwa semua solusi yang ditunjukkan di atas hanya berlaku untuk kasus khusus ini, ketika vektor secara teoritis dapat mengganggu dengan sendirinya.  Solusinya adalah keluar dari loop atau mengisolasi hasil memanggil <i>ukuran ()</i> atau <i>end () dari</i> vektor, dan <i>tidak</i> memberi tahu kompiler bahwa menulis ke data vektor tidak mempengaruhi data lain.  Kode seperti itu akan sulit untuk skala ketika fungsinya bertambah. <br><br>  Masalah aliasing belum hilang, dan perintah tulis masih bisa pergi "ke mana saja" - tidak ada data lain dalam fungsi ini yang dapat terpengaruh ... untuk saat ini.  Begitu kode baru muncul di dalamnya, semuanya akan diulang.  Berikut ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contohnya begitu saja</a> .  Jika dalam loop kecil Anda menulis ke array elemen dari tipe <i>uint8_t</i> , Anda harus bertarung dengan kompiler sampai akhir (16). <br><br><h2>  Komentar </h2><br>  Saya akan dengan senang hati menerima umpan balik.  Saya belum memiliki sistem komentar (17), jadi, seperti biasa, kita akan membahas di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utas ini tentang HackerNews</a> . <br><br><ol><li>  Dengan mengakses memori di sini, dapat dipahami bahwa rantai dependensi melewati memori: perintah tulis pada alamat yang sama harus membaca nilai terakhir yang ditulis di sana, oleh karena itu operasi tersebut tergantung (dalam praktiknya, pengalihan untuk memuat (STLF) akan digunakan jika perekaman sudah cukup. sering).  Ketergantungan perintah <i>add</i> ketika mengakses memori dapat terjadi dengan cara lain, misalnya, dengan menghitung alamat, tetapi untuk kasus kami ini tidak relevan. </li><li>  Hanya siklus kecil yang ditampilkan di sini;  Kode instalasi sederhana dan berfungsi cepat.  Untuk melihat daftar lengkap, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">unggah kode ke godbolt</a> . </li><li>  Mungkin itu harus disebut "diminimalkan"?  Meskipun demikian, kompiler gcc biasanya tidak membuka gulungan bahkan pada level <i>-O2</i> dan <i>-O3</i> , kecuali dalam kasus-kasus khusus ketika jumlah iterasi kecil dan <i>diketahui pada tahap kompilasi</i> .  Karena itu, gcc menunjukkan hasil tes yang lebih rendah dibandingkan dengan dentang, tetapi menghemat banyak pada ukuran kode.  Anda dapat <i>memaksa gcc untuk membuka gulungan dengan</i> menerapkan optimasi profil atau dengan mengaktifkan flag <i>-funroll-loop</i> . </li><li>  Sebenarnya, perintah <i>DWORD PTR [rax] inc</i> di gcc adalah optimasi yang terlewatkan: hampir selalu lebih baik menggunakan perintah <i>add [rax], 1</i> , karena hanya terdiri dari 2 operasi mikro gabungan versus 3 untuk <i>inc</i> .  Dalam hal ini, perbedaannya hanya sekitar 6%, tetapi jika siklusnya sedikit diperluas sehingga hanya operasi penulisan yang diulang, perbedaannya akan signifikan (ekspansi lebih lanjut tidak lagi berperan, karena kita akan mencapai batas 1) merekam operasi per siklus, yang tidak tergantung pada jumlah total operasi mikro). </li><li>  Saya menyebut variabel ini <i>induktif</i> , dan bukan hanya <i>saya</i> , seperti dalam kode sumber, karena kompiler mengubah operasi unit kenaikan <i>i</i> menjadi peningkatan 4-byte dari penunjuk yang disimpan dalam register <i>rax</i> , dan karenanya memperbaiki kondisi loop.  Dalam bentuk aslinya, loop kami membahas elemen-elemen vektor, dan setelah konversi ini, ia menambah pointer / iterator, yang merupakan salah satu cara untuk <i>mengurangi biaya operasi</i> . </li><li>  Bahkan, jika Anda mengaktifkan <i>-funroll-loop</i> , pada gcc kecepatannya akan menjadi 1,08 langkah per elemen dengan <i>8x roll-</i> out.  Tetapi bahkan dengan flag ini, ia <i>tidak akan</i> memperluas loop untuk versi dengan elemen 8-bit, sehingga kelambatan dalam kecepatan akan lebih terlihat! </li><li>  Anggota-anggota ini memiliki pengubah <i>pribadi</i> , dan nama-nama mereka bergantung pada implementasi, tetapi dalam stdlibc ++ mereka tidak benar-benar disebut <i>mulai</i> dan <i>selesai</i> , seperti dalam gcc.  Mereka disebut <i>_Vector_base :: _ Vector_impl :: _ M_start</i> dan <i>_Vector_base :: _ Vector_impl :: _ M_finish masing-masing</i> , mis.  masukkan struktur <i>_Vector_impl</i> , yang merupakan anggota <i>_M_impl</i> (dan satu-satunya) dari kelas <i>_Vector_base</i> , dan itu, pada gilirannya, adalah kelas dasar untuk <i>std :: vector</i> .  Baik, baik!  Untungnya, kompiler dengan mudah mengatasi tumpukan abstraksi ini. </li><li>  Standar tidak menentukan apa yang seharusnya menjadi tipe internal <i>std :: vector</i> members, tetapi di libstdc ++ library mereka hanya didefinisikan sebagai <i>Alloc :: pointer</i> (di mana <i>Alloc</i> adalah pengalokasi untuk vektor), dan untuk <i>std :: dialokasikan objek</i> default mereka hanya akan pointer tipe <i>T *</i> , yaitu  pointer reguler ke objek - dalam hal ini <i>uint32_t *</i> . </li><li>  Saya membuat reservasi ini karena suatu alasan.  Ada kecurigaan bahwa <i>uint8_t</i> dapat dianggap sebagai tipe selain <i>char</i> , <i>char yang ditandatangani</i> , dan <i>char yang tidak ditandatangani</i> .  Karena aliasing bekerja dengan <i>tipe karakter</i> , ini pada prinsipnya tidak berlaku untuk <i>uint8_t</i> dan harus berperilaku seperti tipe non-karakter lainnya.  Namun, tidak ada dari kompiler yang saya tahu berpikir demikian: di semua dari mereka <i>mengetik uint8_t</i> adalah alias dari <i>unsigned char</i> , sehingga kompiler tidak melihat perbedaan di antara mereka, bahkan jika mereka ingin menggunakannya. </li><li>  Maksud "asal tidak diketahui" Maksud saya di sini hanya bahwa kompiler tidak tahu di mana isi dari memori menunjuk atau bagaimana tampilannya.  Ini termasuk pointer arbitrer yang diteruskan ke fungsi, serta variabel global dan statis.  , ,            ,  ,   ,     (    -     ). ,     <i>malloc</i>  <i>new</i> ,   <i></i>    ,      ,   ,        :  ,      ,       . ,       <i>malloc</i>  <i>new</i> . </li><li>  ,   <i>std::vector</i>  - <i></i> ? ,    <i>std::vector&lt;uint8_t&gt; a</i>     <i></i>  <i>a.data()</i>    <i>placement new</i>       <i>b</i> .   <i>std::swap(a, b)</i> ,       – ,  <i>b</i>      ?       ,     <i>b</i> .       :          -  (,       ),      ,       . </li><li>        8 , ..  32 .     ,   <i>std::vector</i>      . </li><li> -        4 :     ,        ,   – .       : 8-      L1,  32-        –   L2    ,      . </li><li>        ,  –  :        .      ,      ,    «». </li><li>        <i>v[i]</i> ,           . </li><li>     . ,   «» ,          <i>uint8_t</i> .      , ,       ,  <i>uint8_t</i> ,          . ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   clang,      gcc</a> ,     ,    <i>uint8_t</i> . -     <i>gcc</i>          ,   .     ,     , -     <i>__restrict</i> . </li><li>  -  ,       ,      (   Disqus),           (        ),    . </li></ol><br> <i>     .  : Travis Downs. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Incrementing vectors</a> .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id475636/">https://habr.com/ru/post/id475636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id475618/index.html">Cara menulis kontrak Python yang cerdas di jaringan Ontology. Bagian 2: API Penyimpanan</a></li>
<li><a href="../id475622/index.html">Memperluas UObject di Unreal Engine 4</a></li>
<li><a href="../id475624/index.html">PHP-Watcher: alat yang menyederhanakan pengembangan aplikasi berumur panjang</a></li>
<li><a href="../id475626/index.html">Bisakah autotests menggantikan seseorang dalam mencari kerentanan: wawancara dengan Alexandra Svatikova</a></li>
<li><a href="../id475630/index.html">Knative - platform berbasis k8s sebagai layanan dengan dukungan serverless</a></li>
<li><a href="../id475640/index.html">Jika Anda membuat sesuatu, hindari jadwal manajer.</a></li>
<li><a href="../id475642/index.html">Heap hanya mekanisme tuple di PostgreSQL</a></li>
<li><a href="../id475646/index.html">Yuri Ryabtsev: "Pencegatan pertama rudal balistik adalah peristiwa yang kira-kira sama dengan penerbangan Gagarin"</a></li>
<li><a href="../id475652/index.html">Bagaimana kami mengembangkan aplikasi seluler di Aurora OS (Sailfish Mobile OS RUS)</a></li>
<li><a href="../id475654/index.html">"Bulan pertama tiga pria sehat takut menyalakan turbin" - bagaimana Alexei Statsenko membuat jetpack dari awal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>