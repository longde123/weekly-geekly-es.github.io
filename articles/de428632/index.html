<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥪 👎🏾 🛸 Umgang mit Abfangjägern in Reaktion 🤚🏻 👨🏾‍🤝‍👨🏼 ⛹🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 Mit unglaublichem Stolz und Erleichterung haben wir heute Abend ein neues Buch über React an die Druckerei übergeben. 



 Bei dieser G...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Umgang mit Abfangjägern in Reaktion</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/428632/">  Hallo Habr! <br><br>  Mit unglaublichem Stolz und Erleichterung haben wir heute Abend ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neues Buch über React</a> an die Druckerei übergeben. <br><br><img src="https://habrastorage.org/webt/yy/eu/am/yyeuamoit3imb91e5gligyk4oys.jpeg"><br><br>  Bei dieser Gelegenheit bieten wir Ihnen eine leicht gekürzte Übersetzung eines Artikels von Dan Abramov an, in dem die Verwendung von Abfangjägern in der 16. Version von React beschrieben wird.  Das Buch, auf das wir uns schon freuen, ist in Kapitel 5 beschrieben. <br><a name="habracut"></a><br>  Letzte Woche haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sophie Alpert und ich</a> auf der React Conf-Konferenz das Konzept der „Interceptors“ vorgestellt, gefolgt von einer ausführlichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diskussion</a> des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Themas</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ryan Florence</a> . <br><br>  Ich empfehle dringend, dass Sie sich diese Plenarvorlesung ansehen, um sich mit den verschiedenen Problemen vertraut zu machen, die wir mithilfe von Abfangjägern lösen wollen.  Selbst die Stunde Ihrer Zeit schätze ich sehr, daher habe ich mich entschlossen, in diesem Artikel kurz die wichtigsten Überlegungen für Abfangjäger zu skizzieren. <br><blockquote>  Hinweis: React Interceptors sind noch experimentell.  Sie müssen sich jetzt nicht mit ihnen befassen.  Beachten Sie auch, dass diese Veröffentlichung meine persönlichen Ansichten enthält, die möglicherweise nicht mit der Position der React-Entwickler übereinstimmen. </blockquote>  <b>Warum werden Abfangjäger benötigt?</b> <br><br>  Es ist bekannt, dass die Organisation von Komponenten und ein Datenfluss nach unten dazu beitragen, eine große Benutzeroberfläche in Form kleiner, unabhängiger und wiederverwendbarer Fragmente zu organisieren.  <b>Es ist jedoch oft nicht möglich, komplexe Komponenten über eine bestimmte Grenze hinaus aufzubrechen, da die Logik den Zustand beibehält und nicht in eine Funktion oder eine andere Komponente extrahiert werden kann</b> .  Manchmal beschweren sich diejenigen darüber, die sagen, dass React keine „Aufgabentrennung“ erreicht. <br>  Solche Fälle sind sehr häufig und hängen beispielsweise mit Animation, Formularverarbeitung, Verbindung zu externen Datenquellen und vielen anderen Vorgängen zusammen, die wir möglicherweise mit unseren Komponenten ausführen müssen.  Wenn wir versuchen, solche Probleme nur mit Komponenten zu lösen, erhalten wir normalerweise: <br><br><ul><li>  <b>Riesige Komponenten</b> , die schwer zu überarbeiten und zu testen sind. </li><li> <b>Duplizierung der Logik</b> zwischen verschiedenen Komponenten und Lebenszyklusmethoden. </li><li>  Insbesondere <b>komplexe Muster</b> , die Requisiten und Komponenten höherer Ordnung rendern. </li></ul><br>  Wir glauben, dass Abfangjäger am vielversprechendsten sind, um all diese Probleme zu lösen.  <b>Interceptors helfen dabei, die Logik innerhalb der Komponente in Form wiederverwendbarer isolierter Einheiten zu organisieren</b> : <br><br><img src="https://habrastorage.org/webt/4g/xr/jw/4gxrjwrsbsq2o6nqjrcjvq8lifo.jpeg"><br><br><img src="https://habrastorage.org/webt/cs/sx/ac/cssxacn4rnmwuob4lhtqflnnyxw.jpeg"><br><br>  <b>Interceptors entsprechen der React-Philosophie (expliziter Datenfluss und Zusammensetzung) und innerhalb einer Komponente, nicht nur zwischen Komponenten</b> .  Deshalb scheint es mir, dass Interzeptoren natürlich in das React-Komponentenmodell passen. <br><br>  Im Gegensatz zu Mustern wie Rendering-Eigenschaften oder Komponenten höherer Ordnung belasten Sniffer Ihren Komponentenbaum nicht mit unnötig tiefen Anhängen.  Sie haben auch nicht die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nachteile</a> , die Verunreinigungen inhärent sind. <br><br>  Auch wenn die Abfangjäger Sie auf den ersten Blick verzerren (genau wie ich zuerst!), Empfehle ich, dieser Option eine Chance zu geben und damit zu experimentieren.  Ich denke es wird dir gefallen. <br><br>  <b>Schwillt React aufgrund von Abfangjägern an?</b> <br><br>  Bis wir die Abfangjäger ausführlich behandelt haben, können Sie befürchten, dass das Hinzufügen von Abfangjägern in React nur eine Multiplikation von Entitäten ist.  Das ist faire Kritik.  Ich denke das: Obwohl Sie kurzfristig wirklich eine zusätzliche kognitive Belastung spüren (um sie zu studieren), werden Sie sich am Ende nur besser fühlen. <br><br>  <b>Wenn Interceptors in der React-Community Fuß fassen, wird die Anzahl der Entitäten, die beim Schreiben von React-Anwendungen verwaltet <i>werden müssen, reduziert</i></b> .  Mit Interceptors können Sie ständig Funktionen verwenden, anstatt zwischen Funktionen, Klassen, Komponenten höherer Ordnung und Komponenten-Rendering zu wechseln. <br><br>  Was die Vergrößerung der Implementierung betrifft, so erhöht sich die React-Anwendung mit Unterstützung von Interceptors nur um etwa ~ 1,5 kB (min + gzip).  Obwohl dies an sich nicht zu viel ist, ist es sehr wahrscheinlich, dass sich <b>bei Verwendung von Interceptors Ihre Assemblygröße sogar verringert</b> , da Interceptor-Code normalerweise besser minimiert wird als äquivalenter Code unter Verwendung von Klassen.  Das folgende Beispiel ist etwas extrem, zeigt aber deutlich, warum alles so ist ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://twitter.com/jamiebuilds/status/1056015484364087297/photo/1%3Fref_src%3Dtwsrc%255Etfw%257Ctwcamp%255Etweetembed%257Ctwterm%255E1056015484364087297%26ref_url%3D">klicken Sie</a> , um den gesamten Thread zu erweitern): <br><br><img src="https://habrastorage.org/webt/_z/zp/7k/_zzp7ky6u-3dcsitdyla1mt-ive.jpeg"><br><br>  <b>Es gibt keine revolutionären Änderungen am Abfangvorschlag</b> .  Ihr Code funktioniert auch dann einwandfrei, wenn Sie Interceptors in neuen Komponenten verwenden.  Genau das empfehlen wir: Schreiben Sie nichts global um!  Es wäre ratsam zu warten, bis die Verwendung von Interceptors in allen kritischen Codes festgelegt ist.  Wir sind Ihnen jedoch dankbar, wenn Sie mit der Alpha-Version 16.7 experimentieren und uns Feedback zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorschlag für Abfangjäger geben</a> sowie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://github.com/login%3Freturn_to%3D">Fehler melden können</a> . <br><br>  <b>Was ist das - Abfangjäger?</b> <br><br>  Um zu verstehen, was Interceptors sind, müssen Sie einen Schritt zurückgehen und überlegen, was Code-Wiederverwendung ist. <br><br>  Es gibt heute viele Möglichkeiten, Logik in React-Anwendungen wiederzuverwenden.  Um etwas zu berechnen, können Sie einfache Funktionen schreiben und sie dann aufrufen.  Sie können auch Komponenten schreiben (die selbst Funktionen oder Klassen sein können).  Die Komponenten sind leistungsfähiger, aber wenn Sie mit ihnen arbeiten, müssen Sie eine Benutzeroberfläche anzeigen.  Daher ist die Verwendung von Komponenten unpraktisch, um nicht visuelle Logik zu übertragen.  Wir kommen also zu komplexen Mustern wie Rendering-Eigenschaften und Komponenten höherer Ordnung.  <b>Würde React es nicht einfacher machen, wenn es nur einen allgemeinen Weg gäbe, Code darin wiederzuverwenden, und nicht so viel?</b> <br><br>  Funktionen scheinen perfekt für wiederverwendbaren Code zu sein.  Das Übergeben von Logik zwischen Funktionen ist am kostengünstigsten.  Der lokale Status von React kann jedoch nicht in Funktionen gespeichert werden.  Sie können aus einer Klassenkomponente kein Verhalten wie "Fenstergröße und Aktualisierungsstatus verfolgen" oder "Wert für einige Zeit animieren" extrahieren, ohne den Code neu zu strukturieren oder Abstraktionen wie Observables einzuführen.  Beide Ansätze erschweren den Code nur, und React ist mit seiner Einfachheit nett zu uns. <br><br>  Abfangjäger lösen genau dieses Problem.  Dank Interceptors können Sie React-Funktionen (z. B. state) einer Funktion verwenden, indem Sie sie nur einmal aufrufen.  React bietet mehrere integrierte Interceptors, die den React-Bausteinen entsprechen: Status, Lebenszyklus und Kontext. <br><br>  <b>Da Interceptors reguläre JavaScript-Funktionen sind, können Sie die in React bereitgestellten integrierten Interceptors kombinieren, um „native Interceptors“ zu erstellen</b> .  So können komplexe Probleme mit einer einzigen Codezeile gelöst und dann in Ihrer Anwendung multipliziert oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://twitter.com/seldo/status/1057030727512911874%3Fref_src%3Dtwsrc%255Etfw%257Ctwcamp%255Etweetembed%257Ctwterm%255E1057030727512911874%26ref_url%3D">in der React-Community freigegeben werden</a> <br><br>  Achtung: Genau genommen gehören Ihre eigenen Abfangjäger nicht zu den Funktionen von React.  Die Fähigkeit, eigene Abfangjäger zu schreiben, beruht natürlich auf ihrer sehr internen Organisation. <br><br>  <b>Zeig mir den Code!</b> <br><br>  Angenommen, wir möchten eine Komponente für die aktuelle Fensterbreite abonnieren (z. B. um anderen Inhalt oder einen engeren Anzeigebereich anzuzeigen). <br>  Ähnlicher Code kann heute auf verschiedene Arten geschrieben werden.  Um beispielsweise eine Klasse zu erstellen, mehrere Lebenszyklusmethoden zu erstellen oder sogar auf Rendering-Eigenschaften zurückzugreifen oder eine Komponente höherer Ordnung anzuwenden, wenn Sie nach einer Wiederverwendung suchen.  Ich denke jedoch, nichts ist vergleichbar damit: <br><br><img src="https://habrastorage.org/webt/it/yg/sm/itygsmtcllercyaret5qvglik7u.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gist.github.com/gaearon/cb5add26336003ed8c0004c4ba820eae</a> <br><br>  <b>Wenn Sie diesen Code lesen, bedeutet dies, dass er genau das tut, was er sagt</b> .  Wir verwenden die Breite des Fensters in unserer Komponente und React zeichnet Ihre Komponente neu, wenn sie sich ändert.  Genau dafür werden Interceptors benötigt - um Komponenten wirklich deklarativ zu machen, selbst wenn sie Zustands- und Nebenwirkungen enthalten. <br><br>  Überlegen Sie, wie dieser eigene Interceptor implementiert werden könnte.  Wir könnten den lokalen Reaktionsstatus verwenden, um die aktuelle Fensterbreite beizubehalten, und den Status festlegen, wenn die Größe des Fensters mithilfe eines Nebeneffekts geändert wird: <br><br><img src="https://habrastorage.org/webt/9t/wf/rx/9twfrxgngukwpy1geu5m8hvcqjk.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gist.github.com/gaearon/cb5add26336003ed8c0004c4ba820eae</a> <br><br>  Wie oben gezeigt, dienen die in React integrierten Interceptors wie <code>useState</code> und <code>useEffect</code> als Bausteine.  Wir können sie direkt aus unseren Komponenten verwenden oder unsere eigenen Abfangjäger daraus zusammensetzen, z. B. <code>useWindowWidth</code> .  Die Verwendung eigener Abfangjäger scheint nicht weniger idiomatisch zu sein als die Arbeit mit der integrierten React-API. <br><br>  Weitere Informationen zu den integrierten Abfangjägern finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Test</a> . <br><br>  <b>Interceptors sind gekapselt - jedes Mal, wenn der Interceptor aufgerufen wird, empfängt er einen isolierten lokalen Status innerhalb der aktuell ausgeführten Komponente</b> .  In diesem Beispiel ist dies nicht wichtig (die Fensterbreite ist für alle Komponenten gleich!), Aber genau darin liegt die Kraft der Abfangjäger!  Sie sollen nicht den Zustand, sondern die zustandserhaltende Logik trennen.  <b>Wir möchten den nachgelagerten Datenstrom nicht unterbrechen!</b> <br><br>  Jeder Abfangjäger kann einige lokale Zustände und Nebenwirkungen enthalten.  Sie können Daten zwischen mehreren Interceptors übertragen, wie dies normalerweise zwischen Funktionen der Fall ist.  Sie können Argumente annehmen und Werte zurückgeben, da es sich um JavaScript-Funktionen handelt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist ein Beispiel einer</a> React-Animationsbibliothek, in der wir mit Interceptors experimentieren: <br>  Beachten Sie, wie beeindruckend die Animation im gezeigten Quellcode implementiert ist: Wir übergeben Werte zwischen mehreren nativen Interceptors innerhalb derselben Renderfunktion. <br><br><img src="https://habrastorage.org/webt/uc/h_/fs/uch_fszu4xmd8xnegfqvwz-flzc.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codesandbox.io/s/ppxnl191zx</a> <br><br>  (Dieses Beispiel wird in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Handbuch</a> ausführlicher erläutert.) <br><br>  Aufgrund der Möglichkeit, Daten zwischen Interceptors zu übertragen, sind sie sehr praktisch, um Animationen zu implementieren, Daten zu abonnieren, Formulare zu verwalten und mit anderen zustandsbehafteten Abstraktionen zu arbeiten.  <b>Im Gegensatz zu Rendering-Eigenschaften oder Komponenten höherer Ordnung erstellen Interceptors keine „falsche Hierarchie“ in Ihrem Renderbaum</b> .  Sie ähneln eher einer zweidimensionalen Liste von "Speicherzellen", die an eine Komponente angehängt sind.  Keine zusätzlichen Levels. <br><br>  <b>Was ist mit Klassen?</b> <br><br>  Unsere eigenen Abfangjäger sind unserer Meinung nach das interessanteste Detail im gesamten Angebot.  Damit die eigenen Abfangjäger funktionsfähig sind, muss React auf Funktionsebene die Möglichkeit bieten, den Zustand und die Nebenwirkungen zu deklarieren.  Genau dies ermöglicht es uns, integrierte Interceptors wie <code>useState</code> und <code>useEffect</code> .  Lesen Sie mehr dazu in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . <br><br>  Es stellt sich heraus, dass solche eingebauten Abfangjäger nicht nur beim Erstellen eigener Abfangjäger praktisch sind.  Sie reichen auch aus, um die Komponenten als Ganzes zu bestimmen, da sie uns die notwendigen Fähigkeiten bieten - zum Beispiel den Zustand.  Aus diesem Grund möchten wir, dass Interceptors in Zukunft das wichtigste Mittel zur Definition von React-Komponenten sind. <br>  Nein, wir planen nicht, den Unterricht schrittweise abzuschaffen.  Wir verwenden Zehntausende von Klassenkomponenten auf Facebook und möchten sie (genau wie Sie) auf keinen Fall neu schreiben.  Wenn die React-Community jedoch Interceptors verwendet, ist es unangemessen, die beiden empfohlenen Methoden zum Schreiben von Komponenten beizubehalten.  Interceptors decken alle praktischen Fälle ab, in denen Klassen verwendet werden, bieten jedoch eine größere Flexibilität beim Extrahieren, Testen und Wiederverwenden von Code.  Deshalb verbinden wir Interceptors mit unseren Ideen über die Zukunft von React. <br><br>  <b>Was ist, wenn Abfangjäger Magie sind?</b> <br><br>  Vielleicht werden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Abfangregeln</a> verwirren. <br><br>  <b>Obwohl es nicht üblich ist, einen Abfangjäger auf der oberen Ebene anzurufen, möchten Sie den Zustand in dem Zustand wahrscheinlich nicht selbst bestimmen, selbst wenn Sie könnten</b> .  Zum Beispiel kann ein zustandsgebundener Zustand im Klassenzimmer nicht festgestellt werden, und seit vier Jahren der Kommunikation mit React-Benutzern habe ich keine Beschwerden darüber gehört. <br><br>  Ein solches Design ist entscheidend für die Einführung eigener Interceptors, ohne übermäßiges Syntaxrauschen oder Fallstricke zu verursachen.  Wir verstehen, dass es aus Gewohnheit schwierig ist, aber wir glauben, dass dieser Kompromiss angesichts der sich bietenden Möglichkeiten akzeptabel ist.  Wenn Sie nicht einverstanden sind, empfehle ich Ihnen, selbst zu experimentieren und zu versuchen, wie Ihnen dieser Ansatz gefällt. <br><br>  Wir verwenden seit einem Monat Produktions-Hooks, um zu sehen, ob die neuen Regeln Programmierer verwirren werden.  Die Praxis zeigt, dass eine Person innerhalb weniger Stunden mit Abfangjägern meistert.  Ich gestehe, dass mir diese Regeln auf den ersten Blick ketzerisch erschienen, aber dieses Gefühl ging schnell vorbei.  Das war der Eindruck, den ich hatte, als ich React zum ersten Mal traf.  (React hat dir nicht gefallen? Und es hat mir erst zum zweiten Mal gefallen.) <br><br>  Bitte beachten Sie: Auf der Ebene der Implementierung von Interceptors gibt es auch keine Magie.  Laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jamie</a> bekommt sie so etwas: <br><br><img src="https://habrastorage.org/webt/cf/xl/zt/cfxlztqheooupmcgmecqjp1kk2g.jpeg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gist.github.com/gaearon/62866046e396f4de9b4827eae861ff19</a> <br><br>  Wir führen eine explodierte Liste von Abfangjägern und fahren jedes Mal mit der nächsten Komponente in der Liste fort, wenn Sie einen Abfangjäger verwenden.  Dank der Regeln der Interceptors ist ihre Reihenfolge in jeder Rendering-Engine gleich, sodass wir bei jedem Aufruf der Komponente den richtigen Status geben können. <br><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In diesem Artikel von Rudy Yardley wird</a> alles auf den Bildern wunderschön erklärt!) <br><br>  Vielleicht haben Sie sich gefragt, wo React den Zustand der Abfangjäger speichert.  Am selben Ort wie der Zustand der Klassen.  React verfügt über eine interne Aktualisierungswarteschlange, die die ultimative Wahrheit für jeden Status enthält, unabhängig davon, wie Sie Ihre Komponenten definieren. <br><br>  Interceptors sind unabhängig von Proxys und Gettern, wie sie in modernen JavaScript-Bibliotheken üblich sind.  Daher kann argumentiert werden, dass Abfangjäger weniger Magie enthalten als andere gängige Ansätze zur Lösung solcher Probleme.  Nicht mehr als in <code>array.push</code> und <code>array.pop</code> (bei denen auch die Reihenfolge der Aufrufe wichtig ist!) <br><br>  Das Interceptor-Design ist nicht an React gebunden.  Einige Tage nach der Veröffentlichung des Vorschlags zeigten uns verschiedene Personen experimentelle Implementierungen derselben Interceptor-API für Vue, Webkomponenten und sogar gewöhnliche JavaScript-Funktionen. <br>  Wenn Sie sich fanatisch der funktionalen Programmierung widmen und sich unwohl fühlen, wenn React beginnt, sich im Rahmen einer Implementierung auf einen veränderlichen Zustand zu verlassen.  Es kann Sie jedoch trösten, dass die Interceptor-Verarbeitung in ihrer reinen Form implementiert werden kann und sich auf algebraische Effekte beschränkt (sofern diese in JavaScript unterstützt wurden).  Natürlich hat sich React auf systeminterner Ebene immer auf einen veränderlichen Zustand verlassen - und genau das möchten Sie vermeiden. <br><br>  Unabhängig davon, welcher Standpunkt Ihnen näher steht - pragmatisch oder dogmatisch - hoffe ich, dass Ihnen mindestens eine dieser Optionen logisch erscheint.  Am wichtigsten ist meiner Meinung nach, dass Abfangjäger unsere Arbeit vereinfachen und es für Benutzer bequemer wird, zu arbeiten.  Das ist es, was mich Abfangjäger so bestechen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428632/">https://habr.com/ru/post/de428632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428620/index.html">Wie erstelle ich Roguelike?</a></li>
<li><a href="../de428624/index.html">Jeffrey Richter, Pavel Yosifovich, Greg Young und alles in allem. Hardcore und Architektur bei DotNext 2018 Moskau</a></li>
<li><a href="../de428626/index.html">Wie man die Erweiterung in PHP7 schwieriger macht als "Hallo Welt" und nicht rotäugig wird. Teil 1</a></li>
<li><a href="../de428628/index.html">Arbeiten Sie mit abstrakten JavaScript-Syntaxbäumen</a></li>
<li><a href="../de428630/index.html">Nein, Bitcoin wird unser Klima bis 2033 nicht zerstören.</a></li>
<li><a href="../de428634/index.html">Portierung von Quake3</a></li>
<li><a href="../de428636/index.html">Roskomnadzor wird eine Geldstrafe von Google zurückfordern</a></li>
<li><a href="../de428638/index.html">Herzflammenmotor: QardioCore Heart Monitor Review</a></li>
<li><a href="../de428640/index.html">Mit dem Mobilteil in der Tasche: Snom DECT-Geräte für schnurlose Telefonnetzwerke</a></li>
<li><a href="../de428644/index.html">Low-Level-Brainfuck</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>