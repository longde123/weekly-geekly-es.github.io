<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍💻 🙏 🧓 使用Rust的10个显而易见的好处 🚀 🔩 🧑🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust是一种年轻且雄心勃勃的系统编程语言。 它实现了自动内存管理，而没有垃圾收集器和其他执行时间开销。 另外，Rust语言中使用了默认语言，访问可变数据的规则空前，并且还考虑了链接寿命。 由于缺乏数据竞速，这使他能够保证内存安全性并促进多线程编程。 





所有这一切对于至少跟随现代编程技术发...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用Rust的10个显而易见的好处</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430294/"><p>  Rust是一种年轻且雄心勃勃的系统编程语言。 它实现了自动内存管理，而没有垃圾收集器和其他执行时间开销。 另外，Rust语言中使用了默认语言，访问可变数据的规则空前，并且还考虑了链接寿命。 由于缺乏数据竞速，这使他能够保证内存安全性并促进多线程编程。 </p><br><p><img src="https://habrastorage.org/webt/4q/db/t-/4qdbt-1pfubt4paba4gojjth7zs.jpeg"></p><br><p>所有这一切对于至少跟随现代编程技术发展的每个人都是众所周知的。 但是，如果您不是系统程序员，并且项目中没有很多多线程代码，该怎么办，但是Rust的性能仍然吸引着您。 在应用程序中使用它还会获得其他好处吗？ 还是他还会给您带来的全部挑战是与编译器的艰苦斗争，这将迫使您编写程序，使其始终遵循借用和所有权语言的规则？ </p><br><p> 本文收集了数十种使用Rust的非显而易见的和未特别宣传的优点，我希望这些优点将帮助您决定在项目中选择这种语言。 </p><a name="habracut"></a><br><h2 id="1-universalnost-yazyka">  1.语言的普遍性 </h2><br><p> 尽管Rust定位为系统编程语言，但它也适合解决高级应用问题。 除非您的任务需要原始指针，否则不必使用原始指针。 标准语言库已经实现了应用程序开发中可能需要的大多数类型和功能。 您也可以轻松连接外部库并使用它们。  Rust中的类型系统和通用编程允许使用相当高水平的抽象，尽管该语言没有直接支持OOP。 </p><br><p> 让我们看一些使用Rust的简单示例。 </p><br><p> 在两个成对的元素上将两个迭代器组合为一个迭代器的示例： </p><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zipper: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt; = (<span class="hljs-number"><span class="hljs-number">1</span></span>..).zip(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars()).collect(); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'f'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>跑</em></a> </p><br><blockquote> 注意：对格式<code>name!(...)</code>的调用<code>name!(...)</code>是对功能宏的调用。  Rust中此类宏的名称始终以符号结尾<code>!</code> 这样就可以将它们与函数名和其他标识符区分开。 使用宏的好处将在下面讨论。 </blockquote><p> 使用外部<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>regex</code></a>库处理正则表达式的示例： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> regex; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> regex::Regex; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> re = Regex::new(<span class="hljs-string"><span class="hljs-string">r"^\d{4}-\d{2}-\d{2}$"</span></span>).unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(re.is_match(<span class="hljs-string"><span class="hljs-string">"2018-12-06"</span></span>));</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>跑</em></a> </p><br><p> 为自己的<code>Point</code>结构实现<code>Add</code>以重载加法运算符的示例： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Add; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Add <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Point { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Point; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: Point) -&gt; Point { Point { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x + other.x, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y + other.y } } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = Point { x: <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p3 = p1 + p2;</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>跑</em></a> </p><br><p> 在结构中使用通用类型的示例： </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span>&lt;T&gt; { x: T, y: T, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> int_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> float_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0.0</span></span> };</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>跑</em></a> </p><br><p> 在Rust上，您可以编写高效的系统实用程序，大型桌面应用程序，微服务，Web应用程序（包括客户端部分，因为Rust可以在Wasm中进行编译），移动应用程序（尽管在这个方向上语言生态系统的开发仍然很差）。 这种多功能性对于多项目团队而言可能是一个优势，因为它使您可以在许多不同项目中使用相同的方法和相同的模块。 如果您习惯于每种工具都是针对其狭窄的应用领域而设计的，那么请尝试将Rust视为具有相同可靠性和便利性的工具箱。 也许这正是您所缺少的。 </p><br><h2 id="2-udobnye-instrumenty-sborki-i-upravleniya-zavisimostyami">  2.便捷的构建和依赖管理工具 </h2><br><p> 显然，这没有广告，但是许多人注意到Rust具有当今可用的最佳构建和依赖管理系统之一。 如果您使用C或C ++进行编程，并且无痛使用外部库的问题对您来说非常紧迫，那么使用Rust及其构建工具和Cargo依赖管理器将是您新项目的不错选择。 </p><br><p>  Cargo除了会为您下载依赖关系并管理其版本，构建和运行您的应用程序，运行测试并生成文档这一事实外，还可以使用其他有用功能的插件进行扩展。 例如，有一些扩展使Cargo可以确定项目的过时依赖项，对源代码执行静态分析，构建和重新部署Web应用程序的客户端部分，等等。 </p><br><p> 货物配置文件使用友好且最小的toml标记语言来描述项目设置。 这是典型的<code>Cargo.toml</code>配置<code>Cargo.toml</code>的示例： </p><br><pre> <code class="plaintext hljs">[package] name = "some_app" version = "0.1.0" authors = ["Your Name &lt;you@example.com&gt;"] [dependencies] regex = "1.0" chrono = "0.4" [dev-dependencies] rand = "*"</code> </pre> <br><p> 以下是使用货运的三个典型命令： </p><br><pre> <code class="plaintext hljs">$ cargo check $ cargo test $ cargo run</code> </pre> <br><p> 在他们的帮助下，将分别检查源代码中的编译错误，项目的汇编和测试的启动，程序的汇编和启动以执行。 </p><br><h2 id="3-vstroennye-testy">  3.内置测试 </h2><br><p> 在Rust中编写单元测试是如此简单容易，您想一次又一次地进行。  :)通常，编写单元测试比尝试以其他方式测试功能要容易。 这是功能和测试示例： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { !a } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { a + <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-meta"><span class="hljs-meta">#[cfg(test)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> test { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::*; <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(is_false(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(!is_false(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, add_two(-<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">2</span></span>)); } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>跑</em></a> </p><br><p>  <code>test</code>模块中标记为<code>#[test]</code>属性的功能是单元测试。 当调用<code>cargo test</code>命令时，它们将并行执行。 条件编译属性<code>#[cfg(test)]</code>标记整个模块）将导致以下事实：仅在执行测试时才编译模块，而不会进入常规程序集。 </p><br><p> 只需将<code>test</code>子模块添加到其中，将<code>test</code>与<code>test</code>功能放在同一模块中非常方便。 而且，如果您需要集成测试，只需将测试放在项目根目录下的<code>tests</code>目录中，然后在其中将您的应用程序用作外部软件包即可。 在这种情况下，不需要添加单独的<code>test</code>模块和条件编译指令。 </p><br><p> 作为测试执行的文档的特殊示例值得特别注意，但是下面将对此进行讨论。 </p><br><p> 还可以使用内置的性能测试（基准），但是它们还不稳定，因此仅在编译器夜间程序集中可用。 在稳定的Rust中，您将必须使用外部库进行此类测试。 </p><br><h2 id="4-horoshaya-dokumentaciya-s-aktualnymi-primerami">  4.良好的文档和当前示例 </h2><br><p> 标准的Rust库有很多文档。  HTML文档是由源代码自动生成的，在码头注释中带有markdown描述。 此外，Rust代码中的文档注释包含在运行测试时执行的示例代码。 这样可以确保示例的相关性： </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Returns a byte slice of this `String`'s contents. /// /// The inverse of this method is [`from_utf8`]. /// /// [`from_utf8`]: #method.from_utf8 /// /// # Examples /// /// Basic usage: /// /// ``` /// let s = String::from("hello"); /// /// assert_eq!(&amp;[104, 101, 108, 108, 111], s.as_bytes()); /// ``` #[inline] #[stable(feature = "rust1", since = "1.0.0")] pub fn as_bytes(&amp;self) -&gt; &amp;[u8] { &amp;self.vec }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>该文件</em></a> </p><br><p> 这是使用<code>String</code>类型的<code>as_bytes</code>方法的示例 </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(&amp;[<span class="hljs-number"><span class="hljs-number">104</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">111</span></span>], s.as_bytes());</code> </pre> <br><p> 将在测试启动期间作为测试执行。 </p><br><p> 此外，Rust库通常以位于项目根目录的<code>examples</code>目录中的小型独立程序的形式创建其使用示例的做法。 这些示例也是文档的重要组成部分，它们也在测试运行期间进行编译和执行，但是它们可以独立于测试运行。 </p><br><h2 id="5-umnoe-avtovyvedenie-tipov">  5.智能自动推断类型 </h2><br><p> 在Rust程序中，如果编译器能够根据使用上下文自动输出表达式，则不能显式指定表达式的类型。 这不仅适用于声明了变量的地方。 让我们看一个例子： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>跑</em></a> </p><br><p> 如果我们安排类型注释，那么此示例将如下所示： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p> 也就是说，我们有一个字符串切片的向量和一个字符串切片类型的变量。 但是在这种情况下，指定类型是完全多余的，因为编译器可以自行输出它们（使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hindley-Milner</a>算法的扩展版本）。  <code>vec</code>是向量的事实已经通过<code>Vec::new()</code>的返回值类型进行了明确说明，但尚不清楚其元素将是哪种类型。  <code>text</code>类型是字符串切片的事实可以通过为其分配文字类型的事实来理解。 因此，在<code>vec.push(text)</code> ，矢量元素的类型变得明显。 请注意， <code>vec</code>变量的类型完全取决于它在执行线程中的使用，而不是在初始化阶段。 </p><br><p> 这种类型推断系统消除了代码中的噪音，并使之与某些动态类型化编程语言中的代码一样简洁。 而这同时保持严格的静态类型！ </p><br><p> 当然，我们不能完全摆脱使用静态类型语言的键入。 程序必须具有确保知道对象类型的位置，以便可以在其他位置显示这些类型。  Rust中的这些要点是对用户定义的数据类型和函数签名的声明，在其中必须指定所使用的类型。 但是，您可以使用通用编程在其中输入“类型的元变量”。 </p><br><h2 id="6-sopostavlenie-s-obrazcom-v-mestah-obyavleniya-peremennyh">  6.变量声明点的模式匹配 </h2><br><p>  <code>let</code>操作 </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p = Point::new();</code> </pre> <br><p> 并不仅限于声明新变量。 她实际上所做的是将等号右边的表达式与左侧的模式匹配。 并且可以将新变量作为示例的一部分引入（并且仅如此）。 看下面的示例，它对您来说将变得更加清晰： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Point { x, y } = Point::new();</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>跑</em></a> </p><br><p> 在这里执行解构：这样的比较将引入变量<code>x</code>和<code>y</code> ，它们将使用<code>Point</code>结构的对象的<code>x</code>和<code>y</code>字段的值初始化，该值通过调用<code>Point::new()</code> 。 同时，由于右侧表达式的类型与左侧<code>Point</code>类型的<code>Point</code>模式相对应，因此比较是正确的。 以类似的方式，您可以采用例如数组的前两个元素： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [a, b, _] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br><p> 还有更多要做的事情。 最值得注意的是，在可以在Rust中输入新变量名称的所有位置执行这样的比较，即：在<code>match</code> ， <code>let</code> ， <code>if let</code> ， <code>while let</code> <code>if let</code> ，在<code>for</code>循环的头文件，函数和闭包的参数中。 这是在<code>for</code>循环中优雅地使用模式匹配的示例： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, ch) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars().enumerate() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Index: {}, char: {}"</span></span>, i, ch); }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>跑</em></a> </p><br><p> 在迭代器上调用的<code>enumerate</code>方法构造了一个新的迭代器，该迭代器将不迭代初始值，而是遍历元组，将“序数索引，初始值”配对。 这些循环中的每个元组都将映射到指定的模式<code>(i, ch)</code> ，其结果是变量<code>i</code>将接收来自元组的第一个值-索引，变量<code>ch</code>接收第二个值，即第二个，即字符串的字符。 在循环主体中，我们可以使用这些变量。 </p><br><p> 在<code>for</code>循环中使用模式的另一个流行示例： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">5</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   5  }</span></span></code> </pre> <br><p> 在这里，我们仅使用<code>_</code>模式忽略迭代器的值。 因为我们不在循环主体中使用迭代编号。 可以使用例如函数参数来完成此操作： </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, _: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre> <br><p> 或在<code>match</code>语句中进行<code>match</code> ： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> p { Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x == 1 detected"</span></span>), Point { y: <span class="hljs-number"><span class="hljs-number">2</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x != 1 and y == 2 detected"</span></span>), _ =&gt; (), <span class="hljs-comment"><span class="hljs-comment">//        }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>跑</em></a> </p><br><p> 模式匹配使代码非常紧凑和富有表现力，并且在<code>match</code>语句中通常是不可替代的。  <code>match</code>运算符是完整变量分析的运算符，因此您将不会偶然忘记检查其中的已分析表达式的某些可能匹配项。 </p><br><h2 id="7-rasshirenie-sintaksisa-i-polzovatelskie-dsl">  7.语法扩展和自定义DSL </h2><br><p>  Rust语法受到限制，这在很大程度上是由于该语言所使用的类型系统的复杂性。 例如，Rust没有命名函数参数或具有可变数量参数的函数。 但是您可以使用宏来克服这些限制和其他限制。  Rust有两种宏：声明性和过程性。 使用声明性宏，您将永远不会遇到与C中的宏相同的问题，因为它们是卫生的，在文本替换级别不起作用，而在抽象语法树中的替换级别不起作用。 宏允许您在语言语法级别创建抽象。 例如： </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, {name}! Do you know about {}?"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, name = <span class="hljs-string"><span class="hljs-string">"User"</span></span>);</code> </pre> <br><p> 除了此宏扩展了调用打印格式化字符串的“函数”的语法功能外，它还将在其实现中在编译时而不是在运行时验证输入参数是否与指定的格式字符串匹配。 使用宏，您可以为自己的设计需求输入简洁的语法，创建和使用DSL。 这是在Wasm中编译的Rust程序中使用JavaScript代码的示例： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = js! { var msg = <span class="hljs-string"><span class="hljs-string">"Hello from JS, "</span></span> + @{name} + <span class="hljs-string"><span class="hljs-string">"!"</span></span>; console.log(msg); alert(msg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"2 + 2 = {:?}"</span></span>, result);</code> </pre> <br><p> 宏<code>js!</code> 定义在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>stdweb</code></a>软件包中，它允许您将完整的JavaScript代码嵌入程序中（单引号字符串和未使用分号完成的运算符除外），并使用语法<code>@{expr}</code>使用Rust代码中的对象。 </p><br><p> 宏为将Rust程序的语法适应特定主题领域的特定任务提供了巨大的机会。 在开发复杂的应用程序时，它们将节省您的时间和精力。 不是通过增加运行时开销，而是通过增加编译时间。  :) </p><br><h2 id="8-avtogeneraciya-zavisimogo-koda">  8.自动生成相关代码 </h2><br><p>  Rust的过程派生宏被广泛用于自动实现特征和其他代码生成。 这是一个例子： </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, }</code> </pre> <br><p> 由于标准库中的所有这些类型（ <code>Copy</code> ， <code>Clone</code> ， <code>Debug</code> ， <code>Default</code> ， <code>PartialEq</code>和<code>Eq</code> ）都是针对<code>i32</code>结构的字段类型实现的，因此它们的实现可以在整个结构中自动显示。 另一个例子： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_derive; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> serde_derive::{Serialize, Deserialize}; <span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  Point  JSON . let serialized = serde_json::to_string(&amp;point).unwrap(); assert_eq!("{\"x\":1,\"y\":2}", serialized); //  JSON   Point. let deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>跑</em></a> </p><br><p> 在这里，使用来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>serde</code></a>库的<code>Deserialize</code>和<code>Deserialize</code>用于<code>Point</code>结构，可以自动生成其序列化和反序列化的方法。 然后，您可以将此结构的实例传递给各种序列化函数，例如，将其转换为JSON字符串。 </p><br><p> 您可以创建自己的程序宏，以生成所需的代码。 或者使用其他开发人员已经创建的许多宏。 除了使程序员免于编写样板代码之外，宏还具有不需要将代码的不同部分保持一致状态的优点。 假设，如果将第三个字段<code>z</code>添加到<code>Point</code>结构中，则如果使用了derive，则可以正确地将其用于序列化，无需执行任何其他操作。 如果我们自己将实现<code>Point</code>序列化的必要特征，那么我们将必须确保该实现始终与<code>Point</code>结构的最新更改保持一致。 </p><br><h2 id="9-algebraicheskiy-tip-dannyh">  9.代数数据类型 </h2><br><p> 简而言之，代数数据类型是复合数据类型，是结构的并集。 更正式地说，它是产品类型的类型总和。 在Rust中，使用<code>enum</code>关键字定义此类型： </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span></span> { Quit, ChangeColor(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>), Move { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> }, Write(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), }</code> </pre> <br><p>  <code>Message</code>类型的变量的特定值的类型只能是<code>Message</code>中列出的结构类型之一。 这要么是类似于单元的<code>Quit</code>无边界结构，要么是带有无名字段的<code>ChangeColor</code>或<code>Write</code> tuple结构之一，要么是通常的<code>Move</code>结构。 传统的枚举类型可以表示为代数数据类型的特例： </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { Red, Green, Blue, White, Black, Unknown, }</code> </pre> <br><p> 使用模式匹配可以找出在特定情况下哪种类型实际上具有价值： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: Color = get_color(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> color { Color::Red =&gt; <span class="hljs-string"><span class="hljs-string">"Red"</span></span>, Color::Green =&gt; <span class="hljs-string"><span class="hljs-string">"Green"</span></span>, Color::Blue =&gt; <span class="hljs-string"><span class="hljs-string">"Blue"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"Other color"</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, text); ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_message</span></span></span></span>(msg: Message) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> msg { Message::Quit =&gt; quit(), Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b), Message::Move { x, y } =&gt; move_cursor(x, y), Message::Write(s) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, s), }; }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>跑</em></a> </p><br><p> 以代数数据类型的形式，Rust实现了诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>Option</code></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>Result</code></a>这样的重要类型，它们分别用于表示缺失值和正确/错误的结果。 在标准库中定义<code>Option</code>方法如下： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; { <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(T), }</code> </pre> <br><p>  Rust没有空值，就像意外调用它的烦人的错误一样。 相反，在确实需要指示可能缺少值的地方，使用<code>Option</code> ： </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span></span>(numerator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>, denominator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> denominator == <span class="hljs-number"><span class="hljs-number">0.0</span></span> { <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(numerator / denominator) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = divide(<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> result { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(x) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Result: {}"</span></span>, x), <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot divide by 0"</span></span>), }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>跑</em></a> </p><br><p> 代数数据类型是功能强大的表达工具，为类型驱动开发打开了大门。 在该范例中，由合格的程序编写的程序会将其工作正确性的大部分检查分配给类型系统。 因此，如果您在日常工业编程中缺少Haskell，Rust可以作为您的出路。  :) </p><br><h2 id="10-legkiy-refaktoring">  10.易于重构 </h2><br><p>  Rust开发的严格的静态类型系统以及在编译过程中尝试执行尽可能多的检查的事实导致修改和重构代码变得非常简单和安全。 如果在更改之后对程序进行了编译，则意味着仅逻辑错误保留在其中，与验证已分配给编译器的功能无关。 结合将单元测试添加到测试逻辑的简便性，可以极大地保证程序的可靠性，并提高程序员对更改后代码正确操作的信心。 </p><br><hr><br><p> 也许这就是我在本文中想要谈论的全部。 当然，Rust具有许多其他优点，以及许多缺点（语言有些笨拙，缺少熟悉的编程习惯和“非文学”语法），在此未提及。 如果您有话要说，请在评论中写。 通常，请在实践中尝试Rust。 就像我的情况一样，也许他对您的好处会胜过他的所有缺点。 最后，您将获得长时间所需的确切工具集。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430294/">https://habr.com/ru/post/zh-CN430294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430282/index.html">每10个人中有9个人同意在有意义的工作中赚取更少的钱</a></li>
<li><a href="../zh-CN430284/index.html">275号移动开发人员的有趣材料摘要（11月12日至18日）</a></li>
<li><a href="../zh-CN430286/index.html">Nintendo Switch海盗游戏的阴暗面的详细信息</a></li>
<li><a href="../zh-CN430290/index.html">尝试预测SpaceX BFR项目的第四次迭代</a></li>
<li><a href="../zh-CN430292/index.html">电子前沿基金会：美国警察车牌网络的性能为0.5％</a></li>
<li><a href="../zh-CN430296/index.html">使您的想法成为应用程序。 无服务器应用程序-分步说明</a></li>
<li><a href="../zh-CN430300/index.html">带有Go套件的Go on Microservices：简介</a></li>
<li><a href="../zh-CN430302/index.html">有趣的sshd中的ptrace或代码注入简介</a></li>
<li><a href="../zh-CN430304/index.html">轨道上的奇妙前哨</a></li>
<li><a href="../zh-CN430306/index.html">Ilona Mask钻探的无聊公司的第一条隧道</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>