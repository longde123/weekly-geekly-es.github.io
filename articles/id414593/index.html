<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕊️ 👨🏽‍💻 🤱🏿 Perbandingan C # dan JavaScript. Dasar-dasarnya 🍯 👨🏽‍🤝‍👨🏻 🏂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jalur saya yang kurang lebih serius dalam pemrograman dimulai dengan menulis program dalam C #, kadang-kadang saya mencoba untuk menulis dalam JavaScr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perbandingan C # dan JavaScript. Dasar-dasarnya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414593/"><p><img src="https://habrastorage.org/webt/kk/qk/mh/kkqkmhvelvgdfaantf2jkxvzyky.png" alt="C # dan javascript"></p><br><p>  Jalur saya yang kurang lebih serius dalam pemrograman dimulai dengan menulis program dalam C #, kadang-kadang saya mencoba untuk menulis dalam JavaScript, dan sekarang dan kemudian jatuh ke dalam keadaan pingsan dalam situasi di mana saya salah menunjukkan nama variabel dan mengetahui tentang hal itu nanti <del>  bertahun-tahun </del>  satu jam debugging, karena saya tidak dekat kompiler saya, yang akan membantu saya keluar di masa-masa sulit.  Setelah beberapa waktu, selain C #, saya mulai menulis banyak kode JavaScript dan sekarang saya bisa melakukannya tanpa banyak kesulitan, saya tidak lagi bingung dengan casting tipe implisit dan pengetikan dinamis. </p><br><p> Dalam artikel ini, saya ingin mensistematisasikan pengetahuan dasar saya tentang bahasa-bahasa ini dan mempertimbangkan persamaan dan perbedaannya.  Artikel ini dapat berfungsi sebagai panduan bagi pengembang C # yang ingin mempelajari JavaScript dan sebaliknya.  Saya juga ingin mencatat bahwa artikel ini menjelaskan kemampuan JS sisi klien, karena saya tidak memiliki pengalaman pengembangan di Node.js.  Jadi, jika Anda masih belum kehilangan minat, mari kita mulai. </p><a name="habracut"></a><br><h2 id="namespace-i-js-moduli">  Modul Namespace dan js </h2><br><p>  Di setiap program, untuk menghindari konflik atas nama variabel, fungsi, kelas atau objek lain, kami menggabungkannya di beberapa area.  Dengan demikian, jika dua area berbeda mengandung elemen dengan nama yang sama, tidak akan terjadi konflik. </p><br><p> Di C #, ruang nama digunakan untuk membagi program menjadi beberapa bagian.  Kata kunci <code>namespace</code> digunakan untuk mendeklarasikannya.  Misalnya, jika kita ingin membuat satu set komponen antarmuka pengguna, masuk akal untuk menempatkan semuanya dalam satu ruang nama, misalnya, <code>Components</code> .  Sudah menjadi kebiasaan bahwa namespace memiliki penamaan berikut <code>[AssemblyName].[DirectoryName].[DirectoryName].[...]</code> .  Di setiap file, kelas komponen antarmuka pengguna harus ditempatkan di dalam namespace: </p><br><p>  Isi file <code>ComboBox.cs</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">AssemblyName.Components</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ComboBox</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br><p>  Untuk mulai menggunakan komponen, Anda perlu mengimpornya dari namespace sebagai berikut <code>using AssemblyName.Components</code> .  Dengan metode koneksi satu baris ini, kami mengimpor semua objek ke file saat ini. </p><br><p>  JS menggunakan modul ES untuk tujuan yang sama.  Saat menggunakannya, kami sedikit banyak meniru perilaku namespaces dengan menulis kode tambahan.  Pertimbangkan contoh yang sama dengan pustaka komponen.  Katakanlah kita memiliki folder <code>Components</code> , yang berisi komponen-komponen antarmuka pengguna <code>ComboBox.js</code> , <code>Button.js</code> , <code>Button.js</code> , dll.  Untuk mendapatkan perilaku serupa dibandingkan dengan namespace di folder <code>Components</code> , Anda harus membuat file <code>index.js</code> yang akan berisi kode berikut: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Dialog } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./ComboBox'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Button } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Button'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Checkbox } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Checkbox'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  Untuk menggunakan komponen ini, Anda perlu mengimpornya ke file saat ini.  Ini dapat dilakukan sebagai berikut: <code>import * as Components from './../Components'</code> , setelah dari kata kunci, kita perlu menentukan path ke folder di mana semua komponen yang dijelaskan berada. </p><br><h2 id="sposoby-obyavleniya-peremennyh">  Cara mendeklarasikan variabel </h2><br><h3 id="klyuchevoe-slovo-var">  Kata kunci <code>var</code> </h3><br><p>  Seperti yang Anda ketahui, C # adalah bahasa pemrograman yang sangat diketik, oleh karena itu, ketika mendeklarasikan variabel, kompiler harus mengetahui tipenya, karena ini biasanya ditunjukkan sebelum namanya. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pi = <span class="hljs-number"><span class="hljs-number">3.14</span></span>; User user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <br><p>  Tetapi kita juga bisa memberi tahu kompiler bahwa ia harus menyimpulkan sendiri tipe dari ekspresi yang mengikuti tanda tugas.  Ini dimungkinkan dengan memperkenalkan kata kunci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>var</code></a> di C # 3.0. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// i - int var i = 5; // a - int[] var a = new[] { 0, 1, 2 };</span></span></code> </pre> <br><p>  Dengan <code>var</code> kita dapat membuat objek dengan tipe anonim: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// anon -      var anon = new { Name = "Terry", Age = 34 }; var type = anon.GetType();//"&lt;&gt;f__AnonymousType0`2"</span></span></code> </pre> <br><p>  Dalam JavaScript, Anda juga dapat menggunakan kata kunci <code>var</code> untuk mendeklarasikan variabel, namun, tidak seperti C #, ruang lingkup variabel-variabel ini akan menjadi seluruh fungsi atau objek <code>window</code> jika variabel tersebut dinyatakan di luar fungsi. </p><br><pre> <code class="hljs powershell">var a = <span class="hljs-number"><span class="hljs-number">5</span></span> //   - window <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { var a = <span class="hljs-number"><span class="hljs-number">6</span></span> //   -  go // ... }</code> </pre><br><p>  Meskipun Anda memiliki kemampuan untuk mendeklarasikan variabel menggunakan <code>var</code> dalam JavaScript, ini tidak disarankan sekarang, setelah rilis standar ES6, kata kunci <code>let</code> ditambahkan, yang juga memungkinkan Anda untuk mendeklarasikan variabel, tetapi keuntungannya adalah bahwa ruang lingkupnya akan menjadi blok di mana mereka dideklarasikan, bukan seluruh fungsi. </p><br><h3 id="konstanty">  Konstanta </h3><br><p>  Baik C # dan JavaScript menggunakan kata kunci <code>const</code> untuk menyatakan bidang yang konstan.  Benar, perlu dicatat bahwa konsep konstanta dalam kasus ini berbeda untuk bahasa-bahasa ini. </p><br><p>  Dalam C #, konstanta adalah ekspresi yang dapat sepenuhnya dievaluasi pada tahap kompilasi, mis.  konstanta dapat berupa angka, boolean, string, atau referensi nol .. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c1 = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c2 = c1 + <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> c3 = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> c4 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> User human = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> User human = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(firstName); <span class="hljs-comment"><span class="hljs-comment">//,  </span></span></code> </pre> <br><p>  Dalam JavaScript, nilai konstanta juga tidak dapat diubah, namun, tidak ada batasan pada nilai seperti dalam C #, Anda dapat menetapkan nilai / objek / array ke dalamnya.  Namun, jika suatu objek ditugaskan ke sebuah konstanta, maka konstanta itu sendiri dilindungi dari perubahan, tetapi bukan properti di dalamnya: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c1 = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c2 = c1 + <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c3 = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c4 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = { name: <span class="hljs-string"><span class="hljs-string">""</span></span> }; user.name = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  user = 5; // ,  </span></span></code> </pre> <br><h2 id="klyuchevoe-slovo-void">  <code>void</code> kata kunci </h2><br><p>  Saat menulis artikel ini, saya bereksperimen dengan fungsi di konsol dan kebiasaan mulai menggambarkan fungsi seperti di C # <code>void SomeFunction...</code> dan itu adalah kejutan besar bagi saya ketika saya menemukan bahwa kata kunci JavaScript tidak <code>void</code> .  Ternyata, <code>void</code> dalam JavaScript adalah operator unary yang menghitung nilai operan, lalu membuangnya dan mengembalikan yang <code>undefined</code> . </p><br><pre> <code class="hljs ruby">alert(<span class="hljs-string"><span class="hljs-string">"!"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> alert(void <span class="hljs-string"><span class="hljs-string">"!"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> undefined</code> </pre> <br><p>  Dengan demikian, kita dapat mengatakan bahwa penggunaan <code>void</code> jelas menunjukkan tidak adanya nilai balik, untuk detail lebih lanjut tentang contoh penggunaannya, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> selanjutnya. </p><br><p>  Dalam C #, <code>void</code> bukan operator, tetapi pada dasarnya memiliki arti yang serupa.  Di sini, ini menunjukkan tidak adanya nilai pengembalian fungsi: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Namun, seperti yang Anda lihat pada contoh di atas, <code>void</code> di tempat di mana jenis nilai pengembalian biasanya ditunjukkan, dan ini bukan kebetulan, karena dalam C # <code>void</code> juga merupakan jenis. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); t.Name <span class="hljs-comment"><span class="hljs-comment">// System.Void</span></span></code> </pre> <br><p>  <code>void</code> sebagai tipe hanya dapat digunakan dalam konteks yang tidak aman saat bekerja dengan pointer. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* identifier; <span class="hljs-comment"><span class="hljs-comment">//,    }</span></span></code> </pre> <br><h2 id="klyuchevoe-slovo-new">  Kata kunci <code>new</code> </h2><br><p>  Dalam JavaScript, kata kunci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>new</code></a> adalah operator, dan digunakan dengan cara biasa untuk banyak bahasa mirip-C untuk membuat objek. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Animal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { //... } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animal</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Animal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br><p>  Di C #, <code>new</code> dapat digunakan untuk tujuan berikut: </p><br><ul><li>  untuk membuat objek; </li><li>  untuk menyembunyikan anggota kelas dasar yang diwarisi; </li><li>  untuk membatasi tipe yang dapat digunakan sebagai argumen untuk parameter tipe dalam kelas generik. </li></ul><br><p>  Kasus pertama mirip dengan menggunakan <code>new</code> dalam JavaScript. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Animal</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... } var animal = new Animal();</span></span></code> </pre> <br><h2 id="osnovnye-tipy-dannyh">  Tipe data dasar </h2><br><p>  Setiap bahasa memiliki tipe data - primitif berdasarkan tipe data lainnya dibangun, mari kita lihat tipe data yang diberikan kepada kita dalam C # dan JavaScript. </p><br><p>  Jenis C # primitif: </p><br><ul><li>  <code>sbyte</code> bulat <code>sbyte</code> : <code>sbyte</code> , <code>short</code> , <code>int</code> , <code>long</code> </li><li>  Bilangan bulat tak <code>ushort</code> : <code>byte</code> , <code>ushort</code> , <code>uint</code> , <code>ulong</code> </li><li>  Karakter Unicode: <code>char</code> </li><li>  Kumpulan karakter Unicode: <code>char</code> </li><li>  Nomor titik <code>float</code> : <code>float</code> , <code>double</code> </li><li>  Desimal Desimal: <code>decimal</code> </li><li>  Nilai Boolean: <code>bool</code> </li></ul><br><p>  Kelas dasar adalah <code>Object</code> . </p><br><p>  Untuk JS: </p><br><p>  Jenis data primitif: </p><br><ul><li>  Nomor <code>number</code> </li><li>  String <code>string</code> </li><li>  Boolean <code>boolean</code> </li><li>  <code>null</code> khusus </li><li>  Arti khusus <code>undefined</code> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>symbol</code></a> </li> </ul><br><p>  Tipe dasarnya adalah <code>Object</code> . </p><br><p>  Setelah mempelajari primitif dari kedua bahasa, kita dapat sampai pada kesimpulan berikut: </p><br><ul><li>  Alih-alih satu set tipe angka yang cukup besar, JavaScript memiliki <code>number</code> tipe tunggal; </li><li>  JavaScript tidak memiliki tipe <code>char</code> , melainkan menggunakan tipe <code>string</code> ; </li><li>  Dalam kedua bahasa, tipe dasarnya adalah <code>Object</code> ; </li><li>  Fitur khas JS adalah bahwa <code>null</code> dan <code>undefined</code> dipisahkan menjadi tipe yang terpisah, sedangkan di C # <code>null</code> adalah kata kunci yang menunjukkan tidak adanya nilai. </li><li>  JS memiliki tipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>symbol</code></a> , yang digunakan terutama di dalam standar JavaScript itu sendiri, agar dapat menambahkan fungsionalitas baru tanpa konflik dengan basis kode yang ada. </li></ul><br><p>  Sebagai aturan, sekarang ada semakin banyak aplikasi di mana perlu untuk memproses data pada klien, yang membutuhkan akurasi yang lebih besar dalam perhitungan.  JavaScript saat ini tidak memiliki kemampuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>BigInt</code></a> untuk bekerja dengan jumlah besar, tetapi dalam waktu dekat ini direncanakan untuk menambah jenis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>BigInt</code></a> .  Untuk mengatasi masalah serupa di C # ada <code>System.Numerics.BigInteger</code> kelas. </p><br><h2 id="proverka-tipa-obekta">  Pemeriksaan Tipe Objek </h2><br><p>  Pengecekan tipe adalah operasi yang cukup umum untuk sebagian besar bahasa pemrograman.  Berdasarkan jenisnya, kita dapat melakukan berbagai tindakan.  Sebagai contoh, perhatikan contoh kehidupan: Anda mendengar bel pintu, jika tetangga yang mabuk mendatangi Anda (objek dengan tipe <em>Drunk Neighbor</em> ) untuk meminjam uang, maka Anda tidak mungkin membuka pintu untuknya, tetapi jika sahabat Anda ada di belakang pintu (objek dengan tipe <em>terbaik teman</em> ), maka Anda jangan ragu untuk membiarkannya masuk ke apartemen.  C # dan JavaScript juga menyediakan fasilitas untuk memeriksa jenis objek. </p><br><h3 id="operator-typeof">  <code>typeof</code> operator </h3><br><p>  Untuk informasi jenis, baik C # dan JavaScript memiliki operator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>typeof</code></a> .  Mari kita lihat cara kerjanya dalam kedua bahasa: </p><br><p>  Dalam C #, operator <code>typeof</code> diterapkan ke tipe dan mengembalikan objek dari kelas <code>Type</code> yang berisi semua informasi tipe. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Zoo</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Animal</span></span> {} } Type t = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Animal); t.Name <span class="hljs-comment"><span class="hljs-comment">// 'Animal' t.FullName // 'Zoo.Animall' t.GetMethods //    t.GetFields //     // ...</span></span></code> </pre> <br><p>  Di JS, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>typeof</code></a> mengembalikan string yang menunjukkan jenis operan. </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> // <span class="hljs-string"><span class="hljs-string">'number'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> Symbol() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'symbol'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'undefined'</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Animal() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> object <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> function() {} <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'function'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {} // '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class">';</span></span></code> </pre> <br><p>  Pada contoh di atas, Anda dapat melihat beberapa fitur operator ini.  Tampaknya logis jika ekspresi <code>typeof new Animal()</code> akan mengembalikan string <code>'Animal'</code> , dan <code>typeof [1,2,3]</code> - string <code>Array</code> , namun secara paradoks, hasilnya dalam kedua kasus adalah <code>'object'</code> .  Juga, karena fakta bahwa kelas-kelas di JS adalah pembungkus fungsi, tipe ekspresi <code>typeof class C {}</code> akan mengembalikan <code>'function'</code> alih-alih <code>'class'</code> .  Fakta menarik lainnya adalah bahwa <code>typeof null</code> expression akan mengembalikan <code>'object'</code> .  Dalam JavaScript, operator ini memiliki kelemahan besar: semua objek non-primitif agar terlihat sama, mereka semua memiliki jenis <code>object</code> sama. </p><br><p>  Perlu dicatat bahwa dalam JavaScript <code>typeof</code> dapat diterapkan ke apa saja: objek, fungsi, kelas, dll ... Dalam C #, operator ini hanya berlaku untuk jenis. </p><br><h3 id="ishttpsdocsmicrosoftcomru-rudotnetcsharplanguage-referencekeywordsis-i-instanceofhttpslearnjavascriptruinstanceof">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">adalah</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instanceof</a> </h3><br><p>  Selain mendapatkan informasi tentang suatu jenis, terkadang bermanfaat untuk memverifikasi bahwa suatu objek termasuk jenis tertentu. </p><br><p>  Di C # ada operator <code>is</code> untuk keperluan ini. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Person</span></span> { } <span class="hljs-comment"><span class="hljs-comment">// Programmer  Person class Programmer : Person { } var person = new Person(); var programmer = new Programmer(); person is Person //true person is Programmer //false programmer is Person //true programmer is Programmer //true</span></span></code> </pre> <br><p>  Dalam JavaScript, untuk mengetahui tipe objek yang dimiliki, Anda perlu menggunakan operator - <code>instanceof</code> . </p><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Programmer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} // Programmer  Person Programmer.prototype = Object.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(Person.prototype); var person = new Person(); var programmer = new Programmer(); console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(person instanceof Person); // <span class="hljs-literal"><span class="hljs-literal">true</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(person instanceof Programmer); // <span class="hljs-literal"><span class="hljs-literal">false</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(programmer instanceof Person); // <span class="hljs-literal"><span class="hljs-literal">true</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(programmer instanceof Programmer); // <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><h2 id="logicheskie-znacheniya-i-proverka-na-null">  Boolean dan cek kosong </h2><br><p>  Hampir di mana-mana, agar tidak mendapatkan <code>Null reference exception</code> , sebelum menggunakan variabel, kami memeriksanya untuk <code>null</code> , dan dalam kasus JavaScript, juga untuk <code>undefined</code> . </p><br><p>  Dalam C #, kami terus-menerus melihat kode serupa: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(user != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; String.IsNullOrEmpty(user.name)) { user.SetName(<span class="hljs-string"><span class="hljs-string">""</span></span>); }</code> </pre> <br><p>  Dalam JavaScript, konstruk ini dapat ditulis agak lebih pendek.  Ini disebabkan oleh fakta bahwa, tidak seperti C #, dalam JavaScript, banyak nilai kecuali <code>false</code> ketika casting juga dianggap <code>false</code> : </p><br><ol><li> <code>null</code> </li> <li> <code>undefined</code> </li> <li>  "" (Baris kosong) </li><li> <code>0</code> </li> <li>  <code>NaN</code> (bukan angka) </li></ol><br><p>  Dengan demikian, kode C # di atas dapat ditulis sebagai berikut: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> &amp;&amp; !<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name) { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.setName(""); }</code> </pre> <br><p>  atau </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">user</span></span> &amp;&amp; !<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.setName("");</code> </pre> <br><p>  Karena fakta bahwa cek <code>null</code> ada di mana-mana, <em>Operator Propagasi Null</em> ditambahkan dalam C # 6.0 <code>.?</code>  . </p><br><p>  Kode C #: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; user.parent != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; user.parent.parent != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { user.parent.parent.SetName(<span class="hljs-string"><span class="hljs-string">""</span></span>); }</code> </pre> <br><p>  Dengan bantuannya, bagian kode ini dapat ditulis ulang sebagai berikut: </p><br><pre> <code class="cs hljs">user?.parent?.parent?.SetName(<span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre> <br><p>  Dalam JavaScript, biasanya dilakukan sebagai berikut: </p><br><pre> <code class="hljs mel">user &amp;&amp; user.<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> &amp;&amp; user.<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> &amp;&amp; user.<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.setName(<span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre> <br><h2 id="ustanovka-znacheniy-po-umolchaniyu">  Menetapkan nilai default </h2><br><p>  Operasi umum lainnya adalah untuk menetapkan nilai default, dari versi 2.0 di C # <em>Null Coalescing Operator muncul - <code>??</code></em>  . </p><br><p>  Dua baris kode C # berikut ini setara: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = user != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; user.name != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? user.name : <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = user?.name ?? <span class="hljs-string"><span class="hljs-string">""</span></span>;</code> </pre> <br><p>  Dalam JavaScript, operasi serupa biasanya dilakukan sebagai berikut. </p><br><pre> <code class="hljs pgsql">var <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name || "";</code> </pre> <br><p>  Namun, kita dapat menggunakan operator <code>&amp;&amp;</code> dan <code>||</code>  hanya jika <code>0</code> , <code>false</code> dan <em>string kosong</em> bukan nilai yang valid. </p><br><p>  Di masa mendatang, operator <code>?.</code>  , <code>??</code>  harus muncul dalam JavaScript (mereka sekarang telah melewati tahap <a href="">Stage0</a> ), rincian lebih lanjut tentang operator ini dalam JavaScript dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> . </p><br><h2 id="klyuchevoe-slovo-this">  Kata kunci ini </h2><br><p>  Baik C # maupun JavaScript memiliki <code>this</code> .  Biasanya dalam C # memahami tujuan <code>this</code> adalah mudah, tetapi dalam JavaScript ini adalah salah satu konsep bahasa yang paling rumit.  Selanjutnya kami akan mempertimbangkan penerapan <code>this</code> pada contoh. </p><br><p>  Di C #, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>this</code></a> menunjuk ke instance kelas saat ini. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintEmployee</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name); } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee(); E1.PrintEmployee();</code> </pre> <br><p>  Dalam contoh ini, dalam ekspresi <code>Console.WriteLine(this.name)</code> , <code>this</code> menunjuk ke variabel <code>employee</code> . </p><br><p>  Karena <code>this</code> adalah instance kelas saat ini, itu tidak dapat digunakan dalam metode yang tidak terikat pada jenis tertentu, misalnya, dalam metode statis. </p><br><p>  Dalam JavaScript, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>this</code></a> disebut <em>konteks panggilan</em> dan akan ditentukan saat fungsi dipanggil.  Jika Anda menjalankan fungsi yang sama dalam konteks objek yang berbeda, ia akan menerima yang berbeda <code>this</code> : </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = { firstName: <span class="hljs-string"><span class="hljs-string">""</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> admin = { firstName: <span class="hljs-string"><span class="hljs-string">""</span></span> }; function <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { alert( this.firstName ); } user.f = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">admin</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">; // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">    : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  admin.g(); //  func();// undefined -    this -   window</span></span></code> </pre> <br><p>  Selain itu, dalam JavaScript ada kemungkinan secara eksplisit menentukan nilai fungsi yang menggunakan <code>this</code> : <code>call</code> , <code>bind</code> , <code>apply</code> .  Sebagai contoh, contoh di atas dapat ditulis ulang sebagai berikut: </p><br><pre> <code class="hljs matlab">var user = { firstName: <span class="hljs-string"><span class="hljs-string">""</span></span> }; var admin = { firstName: <span class="hljs-string"><span class="hljs-string">""</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( this.firstName )</span></span></span><span class="hljs-function">; } // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">    : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user)</span></span></span><span class="hljs-function">; //  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(admin)</span></span></span><span class="hljs-function">; //  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;//  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(admin)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;// </span></span></code> </pre> <br><h2 id="destrukturizaciya">  Restrukturisasi </h2><br><p>  Seringkali diperlukan untuk menetapkan beberapa bidang objek ke variabel lokal.  Misalnya, seberapa sering Anda mengamati kode yang sama? </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">User user</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName = user.FirstName; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName = user.LastName; <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p>  Untuk tujuan tersebut, Anda dapat menggunakan destrukturisasi.  Kedua bahasa mendukung fitur ini hingga derajat yang berbeda-beda. </p><br><p>  C # 7.0 memperkenalkan jenis fungsi baru yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dekonstruktor</a> untuk mendukung perusakan.  Untuk mendeklarasikan dekonstruktor, kita perlu mendefinisikan metode yang disebut <code>Deconstruct</code> , semua parameter yang harus dideklarasikan dengan <code>out</code> modifier: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Person</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FirstName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LastName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//   public void Deconstruct(out string firstName, out string lastName) { firstName = this.FirstName; lastName = this.LastName; } } ... Person person = new Person { FirstName = "", LastName = "" }; (string firstName, string lastName) = person; (string firstName, _ ) = person;</span></span></code> </pre> <br><p>  Dukungan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>perusakan</em> atau <em>(penugasan perusakan)</em></a> dalam JavaScript muncul dalam standar EcmaScript keenam.  Dengan bantuannya.  Anda dapat menetapkan array atau objek ke beberapa variabel sekaligus, memecahnya menjadi beberapa bagian. </p><br><pre> <code class="hljs powershell">let [<span class="hljs-type"><span class="hljs-type">firstName</span></span>, <span class="hljs-type"><span class="hljs-type">lastName</span></span>] = [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>]; let [<span class="hljs-type"><span class="hljs-type">firstName</span></span>, <span class="hljs-type"><span class="hljs-type">_</span></span> ] = [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>]; let { firstName, lastName } = { firstName: <span class="hljs-string"><span class="hljs-string">""</span></span>, lastName: <span class="hljs-string"><span class="hljs-string">""</span></span> }; let { firstName } = { firstName: <span class="hljs-string"><span class="hljs-string">""</span></span>, lastName: <span class="hljs-string"><span class="hljs-string">""</span></span> };</code> </pre> <br><p>  Perlu dicatat bahwa restrukturisasi dalam JavaScript memiliki lebih banyak fitur daripada di C #: </p><br><ul><li>  Ubah urutan variabel; </li><li>  Tidak perlu mendeklarasikan dekonstruksi secara eksplisit; </li><li>  Array dukungan restrukturisasi; </li><li>  Menetapkan nilai default; </li><li>  Menetapkan properti suatu objek ke variabel dengan nama yang berbeda; </li><li>  Dukungan untuk penghancuran bersarang. </li></ul><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Pada artikel ini, kami hanya membahas konsep paling dasar dari bahasa C # dan JavaScript.  Tetapi banyak aspek tetap tidak terpengaruh: </p><br><ul><li>  koleksi </li><li>  fungsi </li><li>  kelas </li><li>  multithreading </li></ul><br><p>  Masing-masing topik ini cukup luas dan akan diungkapkan kemudian dalam artikel terpisah. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414593/">https://habr.com/ru/post/id414593/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414581/index.html">Di mana kancingnya ?! Bagaimana orang sederhana bisa membongkar data dari Kibana dan Elasticsearch dan tidak membebani pengembang</a></li>
<li><a href="../id414583/index.html">RIT ++, Tech RaDarts, dan semuanya</a></li>
<li><a href="../id414585/index.html">Bagaimana String.getBytes (UTF_8) saya rusak dan apa yang saya lakukan dengannya</a></li>
<li><a href="../id414587/index.html">DIY drone mandiri dengan kontrol atas Internet. Bagian 2 tentang perangkat lunak</a></li>
<li><a href="../id414589/index.html">Robotika kolaboratif Sberbank: robot apa yang bisa kami lakukan dengan Anda?</a></li>
<li><a href="../id414597/index.html">Tanyakan pada Ethan: Seberapa dekat peradaban asing dapat bersatu?</a></li>
<li><a href="../id414601/index.html">Ketika gunung-gunung tinggi dan laptop-laptop besar: sedikit sejarah TI lagi</a></li>
<li><a href="../id414605/index.html">Kerajaan mini</a></li>
<li><a href="../id414609/index.html">Bisakah 2018 PWA (Progressive Web Apps) menjadi kompetisi yang layak untuk aplikasi asli?</a></li>
<li><a href="../id414611/index.html">Kisah saya tentang membuat aplikasi motivasi (iOS dan Android) untuk anak perempuan dengan anak perempuan di Unity dan C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>