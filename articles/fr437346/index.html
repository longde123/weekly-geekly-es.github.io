<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽🏿 🧕 🏗️ Un jeu (pas) pour les imbéciles. Nous écrivons l'IA pour "The Fool" (partie 1) 🕣 👨🏿‍🚒 🙅🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je pense que ce n'est un secret pour personne que "Fool" (ci-après ce mot sera écrit avec une petite lettre et sans guillemets) est le jeu de cartes l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un jeu (pas) pour les imbéciles. Nous écrivons l'IA pour "The Fool" (partie 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437346/"><p>  Je pense que ce n'est un secret pour personne que "Fool" (ci-après ce mot sera écrit avec une petite lettre et sans guillemets) est le jeu de cartes le plus populaire en Russie et dans les pays de l'ex-URSS (bien qu'il soit presque inconnu en dehors).  Malgré son nom et des règles assez simples, le gagner dépend encore plus de l'habileté du joueur que de la distribution aléatoire des cartes (dans la terminologie anglaise, les jeux des deux types sont respectivement appelés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jeu d'adresse</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jeu de hasard</a> . Donc - un imbécile dans plus de <em>jeu d'adresse</em> ). </p><br><p>  Le but de l'article est d'écrire une IA simple pour le jeu.  Le mot "simple" signifie ce qui suit: </p><br><ul><li>  un algorithme intuitif de prise de décision (c'est-à-dire, par conséquent, pas d'apprentissage automatique dans lequel cet algorithme est caché profondément "sous le capot"); </li><li>  manque d'état (c'est-à-dire que l'algorithme n'est guidé que par les données du moment présent, simplement dit, il ne se souvient de rien (par exemple, il ne "compte" pas les cartes qui ont quitté le jeu). </li></ul><a name="habracut"></a><br><p>  (À strictement parler, le premier paragraphe ne donne plus le droit à une telle IA d'être appelée <strong>intelligence artificielle en</strong> <em>soi</em> , mais seulement une pseudo-IA. Mais cette terminologie a été établie dans le développement de jeux, nous ne la changerons donc pas.) </p><br><p>  Je pense que les règles du jeu sont connues de tout le monde, je ne vais donc plus les rappeler.  Ceux qui veulent vérifier, je vous conseille de contacter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wikipédia</a> , il y a un assez bon article sur ce sujet. </p><br><p>  Commençons donc.  Évidemment, dans un imbécile, plus la carte est ancienne, mieux c'est de l'avoir en main.  Par conséquent, nous allons construire l'algorithme sur l'évaluation classique de la force de la main et prendre une décision (par exemple, lancer une carte particulière) sur la base de cette évaluation.  Nous attribuons les valeurs aux cartes, par exemple comme ceci: </p><br><ul><li>  <strong>as</strong> (A) - +600 points, </li><li>  <strong>roi</strong> (K) - +500, </li><li>  <strong>dame</strong> (Q) - +400, </li><li>  <strong>Jack</strong> (J) - +300, </li><li>  <strong>dix</strong> (10) - +200, </li><li>  <strong>neuf</strong> (9) - +100, </li><li>  <strong>huit</strong> (8) - 0, </li><li>  <strong>sept</strong> (7) - -100, </li><li>  <strong>six</strong> (6) - -200, </li><li>  <strong>cinq</strong> (5) - -300, </li><li>  <strong>quatre</strong> (4) - -400, </li><li>  <strong>trois</strong> (3) - -500, </li><li>  et enfin, <strong>diable</strong> (2) - -600 points. </li></ul><br><p>  (Nous utilisons des nombres qui sont des multiples de 100 afin de se débarrasser de la virgule flottante dans nos calculs et n'utilisons que des entiers. Pour cela, nous avons besoin de notes négatives, voir ci-dessous dans l'article.) </p><br><p>  Les cartes Trump sont plus précieuses que toutes les cartes simples (même un dump atout bat un as «ordinaire»), et la hiérarchie dans le costume d'atout est la même, donc pour les évaluer, nous ajoutons simplement 1300 à la valeur «de base» - puis, par exemple, le dump trump «coûtera» -600 + 1300 = 700 points (c'est-à-dire un peu plus qu'un atout aceless). </p><br><p> Dans le code (tous les exemples de code de l'article seront dans Kotlin), cela ressemble à ceci (la fonction <code>relativaCardValue()</code> renvoie l'estimation même, et <code>RANK_MULTIPLIER</code> n'est qu'un coefficient égal à 100): </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> hand) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r = c.rank <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s = c.suit res += ((relativeCardValue(r.value)) * RANK_MULTIPLIER).toInt() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s === trumpSuit) res += <span class="hljs-number"><span class="hljs-number">13</span></span> * RANK_MULTIPLIER <span class="hljs-comment"><span class="hljs-comment">//   ,    }</span></span></code> </pre> <br><p>  Hélas, ce n'est pas tout.  Il est également important de considérer les règles d'évaluation suivantes: </p><br><ul><li>  il est avantageux d'avoir de nombreuses cartes de même valeur - non seulement parce qu'elles peuvent «remplir» l'adversaire, mais aussi repousser facilement l'attaque (surtout si les cartes sont de grande valeur).  Par exemple, à la fin du jeu, une main (pour simplifier, nous supposons que les atouts ci-après sont des tambourins) <p><math> </math> $$ afficher $$ \ clubuit 2 \ combinaison pique 2 \ combinaison diamant Q \ combinaison coeur Q \ combinaison club Q \ combinaison pique Q $$ afficher $$   presque parfait (bien sûr, si l'adversaire ne passe pas sous vous avec des rois ou des as): vous serez battu par les dames, après quoi <del>  accrocher des rivaux </del>  donnez-lui une paire de deux. </p><br>  mais de nombreuses cartes de la même couleur (bien sûr, non-atout), au contraire, ont un inconvénient - elles «interfèrent» les unes avec les autres.  Par exemple, la main <p><math> </math> $$ afficher $$ \ combinaison de plongée 5 \ combinaison de plongée J \ combinaison de combinaison A \ combinaison de diamants 6 \ combinaison de diamants 9 \ combinaison de diamants K $$ afficher $$   très malheureux - même si l'adversaire ne "frappe pas" votre atout avec le premier coup et va avec une carte de la couleur de pointe, alors toutes les autres cartes lancées seront d'autres couleurs, et ils devront donner des atouts.  De plus, il y a une forte probabilité que les cinq rushs restent non réclamés - vous avez tous les atouts avec une dignité supérieure à cinq, donc en aucun cas (à moins, bien sûr, que vous n'ayez initialement entré avec une carte plus jeune), vous ne pourrez pas le couvrir avec une autre carte - il est très probable que cela prenne haut.  D'un autre côté, nous remplaçons le cric de pique par dix massues, et l'atout six par triple: </p><p><math> </math> $$ afficher $$ \ combinaison de plongée 5 \ combinaison de club 10 \ combinaison de combinaison A \ combinaison de diamants 3 \ combinaison de diamants 9 \ combinaison de diamants K $$ afficher $$   Malgré le fait que nous ayons remplacé les cartes par des cartes inférieures, une telle main est bien meilleure - premièrement, vous n'aurez pas à jouer un atout (et vous pouvez plus probablement utiliser l'as de pique), et deuxièmement, si vous battez n'importe quelle puis une carte avec votre atout trois, il y a une chance que quelqu'un vous jette un trois de pique (car il n'y a généralement aucun sens à détenir une telle carte), et vous "saisirez" les cinq. </p><br><p></p><br><p>  Pour mettre en œuvre ces stratégies, nous modifions notre algorithme: ici nous considérons le nombre de cartes de chaque couleur et avantage ... </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">/*          - ,      -     ,   ,    4    1.25 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bonuses = doubleArrayOf(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">1.25</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> countsByRank = IntArray(<span class="hljs-number"><span class="hljs-number">13</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> countsBySuit = IntArray(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> hand) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r = c.rank <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s = c.suit res += ((relativeCardValue(r.value)) * RANK_MULTIPLIER).toInt() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s === trumpSuit) res += <span class="hljs-number"><span class="hljs-number">13</span></span> * RANK_MULTIPLIER countsByRank[r.value - <span class="hljs-number"><span class="hljs-number">1</span></span>]++ countsBySuit[s.value]++ }</code> </pre> <br><p>  ... ici, nous leur ajoutons des bonus (l'appel <code>Math.max</code> est nécessaire pour ne pas accumuler de bonus négatifs pour les cartes basses - car dans ce cas, il est également bénéfique) ... </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">13</span></span>) { res += (Math.max(relativeCardValue(i), <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * bonuses[countsByRank[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]]).toInt() }</code> </pre> <br><p>  ... et ici, au contraire, nous allons bien pour une combinaison non équilibrée en combinaisons (la valeur <code>UNBALANCED_HAND_PENALTY</code> fixée expérimentalement à 200): </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//      ... var avgSuit = 0.0 for (c in hand) { if (c.suit !== trumpSuit) avgSuit++ } avgSuit /= 3.0 for (s in Suit.values()) { if (s !== trumpSuit) { //              val dev = Math.abs((countsBySuit[s.value] - avgSuit) / avgSuit) res -= (UNBALANCED_HAND_PENALTY * dev).toInt() } }</span></span></code> </pre> <br><p>  Enfin, nous prenons en compte une chose aussi banale que le nombre de cartes en main.  En fait, avoir 12 bonnes cartes en début de partie est très bien (surtout qu'elles ne peuvent toujours pas être lancées plus de 6), mais en fin de partie, quand il n'y a qu'un adversaire avec 2 cartes à côté de vous, ce n'est pas du tout le cas. </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//       (      ) var cardsInPlay = cardsRemaining for (p in playerHands) cardsInPlay += p cardsInPlay -= hand.size // ,      ,     ( MANY_CARDS_PENALTY = 600) val cardRatio = if (cardsInPlay != 0) (hand.size / cardsInPlay).toDouble() else 10.0 res += ((0.25 - cardRatio) * MANY_CARDS_PENALTY).toInt() return res</span></span></code> </pre> <br><p>  Nous résumons - dans son intégralité, la fonction d'évaluation ressemble à ceci: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hand: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ArrayList</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Card</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, trumpSuit: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Suit</span></span></span></span><span class="hljs-function"><span class="hljs-params">, cardsRemaining: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, playerHands: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cardsRemaining == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; hand.size == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OUT_OF_PLAY } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bonuses = doubleArrayOf(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">1.25</span></span>) <span class="hljs-comment"><span class="hljs-comment">// for cards of same rank var res = 0 val countsByRank = IntArray(13) val countsBySuit = IntArray(4) for (c in hand) { val r = c.rank val s = c.suit res += ((relativeCardValue(r.value)) * RANK_MULTIPLIER).toInt() if (s === trumpSuit) res += 13 * RANK_MULTIPLIER countsByRank[r.value - 1]++ countsBySuit[s.value]++ } for (i in 1..13) { res += (Math.max(relativeCardValue(i), 1.0) * bonuses[countsByRank[i - 1]]).toInt() } var avgSuit = 0.0 for (c in hand) { if (c.suit !== trumpSuit) avgSuit++ } avgSuit /= 3.0 for (s in Suit.values()) { if (s !== trumpSuit) { val dev = Math.abs((countsBySuit[s.value] - avgSuit) / avgSuit) res -= (UNBALANCED_HAND_PENALTY * dev).toInt() } } var cardsInPlay = cardsRemaining for (p in playerHands) cardsInPlay += p cardsInPlay -= hand.size val cardRatio = if (cardsInPlay != 0) (hand.size / cardsInPlay).toDouble() else 10.0 res += ((0.25 - cardRatio) * MANY_CARDS_PENALTY).toInt() return res }</span></span></code> </pre> <br><p>  Nous avons donc la fonction d'évaluation prête.  Dans la partie suivante, il est prévu de décrire une tâche plus intéressante - prendre des décisions sur la base d'une telle évaluation. </p><br><p>  Merci à tous pour votre attention! </p><br><p>  PS Ce code fait partie de l'application développée par l'auteur pendant son temps libre.  Il est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur GitHub</a> (versions binaires pour Desktop et Android, pour ce dernier l'application est également disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur F-Droid</a> ). </p></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437346/">https://habr.com/ru/post/fr437346/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437332/index.html">Deux pour cent du «chat» ou qui a photographié Maître Yoda?</a></li>
<li><a href="../fr437334/index.html">Que se passera-t-il le 1er février?</a></li>
<li><a href="../fr437336/index.html">De Penza à Berlin: histoire du déménagement de l'automate de test</a></li>
<li><a href="../fr437342/index.html">Comment choisir une plateforme de vidéosurveillance: Cloud vs DVR / NVR / VMS</a></li>
<li><a href="../fr437344/index.html">Cas d'utilisation des solutions de visibilité réseau</a></li>
<li><a href="../fr437348/index.html">Augmentez la productivité sur GitHub: conseils pour les débutants et plus</a></li>
<li><a href="../fr437350/index.html">Une voiture à l'ère de la multifonctionnalité. Quelles conversions sont possibles?</a></li>
<li><a href="../fr437352/index.html">L'informatique quantique dans les jeux, ou devenir fou au sérieux</a></li>
<li><a href="../fr437354/index.html">Affaiblir les noix, partie 2: la période de vote pour les publications et autres changements</a></li>
<li><a href="../fr437356/index.html">Qu'est-il arrivé au SSD en 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>