<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐟 🚴🏻 🥙 5 principes de bon sens pour créer des applications natives du cloud 👨🏻‍🏭 📟 🍻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Des applications «basées sur le cloud» (natives du cloud) ou simplement «cloud» sont créées spécifiquement pour être utilisées dans les infrastructure...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 principes de bon sens pour créer des applications natives du cloud</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/455024/">  Des applications «basées sur le cloud» (natives du cloud) ou simplement «cloud» sont créées spécifiquement pour être utilisées dans les infrastructures cloud.  Habituellement, ils sont construits comme un ensemble de microservices à couplage lâche emballés dans des conteneurs, qui, à leur tour, sont gérés par une plateforme cloud.  Par défaut, ces applications sont prêtes pour les pannes, ce qui signifie qu'elles fonctionnent de manière fiable et évoluent même en cas de pannes graves au niveau de l'infrastructure.  Le revers de la médaille est l'ensemble des restrictions (contrats) que la plate-forme cloud impose aux applications de conteneurs afin de pouvoir les gérer automatiquement. <br><br><img src="https://habrastorage.org/webt/i4/jg/_8/i4jg_8cdsmt7yazeyaz_e2lclmo.png" width="100%"><br><br>  Conscientes de la nécessité et de l'importance de passer aux applications cloud, de nombreuses entreprises ne savent toujours pas par où commencer.  Dans cet article, nous examinerons un certain nombre de principes dont le respect lors du développement des applications de conteneur réalisera le potentiel des plates-formes cloud et réalisera un fonctionnement et une mise à l'échelle fiables des applications, même en cas de graves défaillances au niveau de l'infrastructure informatique.  Le but ultime des principes énoncés ici est d'apprendre à créer des applications qui peuvent être gérées automatiquement par des plateformes cloud telles que Kubernetes. <br><a name="habracut"></a><br><h3>  Principes de conception de logiciels </h3><br>  Dans le monde de la programmation, les principes sont compris comme des règles assez générales à respecter lors du développement de logiciels.  Ils peuvent être utilisés lorsque vous travaillez avec n'importe quel langage de programmation.  Chaque principe a ses propres objectifs, les modèles et les pratiques servent généralement d'instrument pour leur réalisation.  Il existe également un certain nombre de principes fondamentaux pour la création de logiciels de haute qualité, dont tous les autres découlent.  Voici quelques exemples de principes fondamentaux: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">KISS</a> (Restez simple, stupide) - ne vous compliquez pas; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SEC</a> (ne vous répétez pas) - ne répétez pas; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">YAGNI</a> (vous n'en aurez pas besoin) - ne créez pas quelque chose dans lequel il n'y a pas de besoin immédiat; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SoC</a> (Séparation des préoccupations) - pour partager les responsabilités. </li></ul><br>  Comme vous pouvez le voir, ces principes ne fixent pas de règles spécifiques, mais appartiennent à la catégorie des considérations dites de bon sens basées sur une expérience pratique partagée par de nombreux développeurs et auxquelles ils se réfèrent régulièrement. <br>  En outre, il existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SOLID</a> - un ensemble des cinq premiers principes de programmation et de conception orientées objet, formulés par Robert Martin.  SOLID comprend des principes mutuellement complémentaires qui sont généralisés et ouverts à l'interprétation, qui - lorsqu'ils sont appliqués en combinaison - aident à créer de meilleurs systèmes logiciels et à mieux les soutenir à long terme. <br><br>  Les principes SOLID s'appliquent à la POO et sont formulés en termes de concepts et de concepts tels que les classes, les interfaces et l'héritage.  Par analogie, pour les applications cloud, vous pouvez également formuler les principes de développement, seul l'élément de base ici ne sera pas une classe, mais un conteneur.  En suivant ces principes, vous pouvez créer des applications conteneurisées qui répondent mieux aux buts et objectifs des plates-formes cloud comme Kubernetes. <br><br><h3>  Conteneurs basés sur le cloud: approche Red Hat </h3><br>  Aujourd'hui, presque toutes les applications sont relativement faciles à emballer dans des conteneurs.  Mais pour que les applications soient efficacement automatisées et orchestrées au sein d'une plateforme cloud comme Kubernetes, des efforts supplémentaires sont nécessaires. <br>  Les idées présentées ci-dessous étaient basées sur la méthodologie de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'application à douze facteurs</a> et de nombreux autres travaux sur divers aspects de la création d'applications Web, du contrôle des sources aux modèles à l'échelle.  Les principes décrits s'appliquent uniquement au développement d'applications de conteneurs construites sur la base de microservices et conçues pour des plates-formes cloud telles que Kubernetes.  L'élément de base de notre discussion est l'image du conteneur, et le runtime cible du conteneur est la plate-forme d'orchestration de conteneur.  Le but des principes proposés est de créer des conteneurs pour lesquels, sur la plupart des plateformes d'orchestration, vous pouvez automatiser les tâches de planification (planification - choix d'un hôte pour exécuter l'instance de conteneur), la mise à l'échelle et la surveillance.  Les principes sont énoncés dans un ordre aléatoire. <br><br><h3>  Principe de préoccupation unique (SCP) </h3><br>  Ce principe est à bien des égards similaire au principe de responsabilité unique ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SRP</a> ), qui fait partie de la suite SOLID et stipule que chaque objet doit avoir une responsabilité, et cette responsabilité doit être entièrement encapsulée dans la classe.  L'essence du SRP est que chaque devoir est une raison de changement, et une classe doit avoir une et une seule raison de changement. <br><br>  Dans SCP, au lieu du mot «responsabilité», nous utilisons le mot «préoccupation» pour indiquer un niveau d'abstraction plus élevé et un objectif plus large du conteneur par rapport à la classe OOP.  Et si l'objectif de SRP est de n'avoir qu'une seule raison de changer, alors SCP souhaite étendre les possibilités de réutilisation et de remplacement des conteneurs.  En suivant SRP et en créant un conteneur qui résout une seule tâche et le fait d'une manière fonctionnelle complète, vous augmentez les chances de réutiliser l'image de ce conteneur dans divers contextes d'application. <br><br>  Le principe de SCP stipule que chaque conteneur doit résoudre une seule tâche et bien le faire.  De plus, SCP dans le monde des conteneurs est réalisé plus facilement que SRP dans le monde de la POO, car les conteneurs effectuent généralement un seul processus, et la plupart du temps ce processus résout une seule tâche. <br><br>  Si un microservice de conteneur doit résoudre plusieurs problèmes à la fois, il peut être divisé en conteneurs à tâche unique et fusionné en un seul pod (unités de déploiement de plateforme de conteneur) à l'aide de modèles de side-car et de conteneurs d'initialisation.  De plus, SCP facilite le remplacement d'un ancien conteneur (tel qu'un serveur Web ou un courtier de messages) par un nouveau qui résout le même problème mais a des fonctionnalités améliorées ou évolue mieux. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/4j/3o/ud4j3okts2jt7hdfr68-tdjlkw4.png"></div><br><br><h3>  Principe de commodité de la surveillance (principe de haute observabilité, HOP) </h3><br>  Lorsque les conteneurs sont utilisés comme un moyen unifié d'emballage et de lancement d'applications, les applications elles-mêmes sont considérées comme une «boîte noire».  Cependant, s'il s'agit de conteneurs cloud, ils doivent fournir au runtime des API spéciales pour surveiller la santé des conteneurs et prendre les mesures appropriées si nécessaire.  Sans cela, il ne sera pas possible d'unifier l'automatisation de la mise à jour des conteneurs et la gestion de leur cycle de vie, ce qui, à son tour, aggravera la stabilité et la convivialité du système logiciel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nm/_y/lh/nm_ylhsfix0alpq7uwqmjy8smf0.png"></div><br>  Dans la pratique, une application de conteneur doit, au minimum, avoir une API pour différents types de contrôles d'intégrité: tests de vivacité et tests de préparation.  Si la demande prétend être supérieure, elle devrait fournir d'autres moyens de surveiller son état.  Par exemple, la journalisation des événements importants via STDERR et STDOUT pour agréger les journaux à l'aide de Fluentd, Logstash et d'autres outils similaires.  Ainsi que l'intégration avec les bibliothèques de trace et de collection de métriques telles que OpenTracing, Prometheus, etc. <br><br>  En général, l'application peut toujours être considérée comme une «boîte noire», mais en même temps, elle doit être équipée de toutes les API dont la plate-forme a besoin pour la surveiller et la gérer au mieux. <br><br><h3>  Principe de conformité du cycle de vie (LCP) </h3><br>  LCP est l'antithèse de HOP.  Si le HOP indique que le conteneur doit fournir à la plate-forme des API pour la lecture, alors LCP requiert que l'application puisse recevoir des informations de la plate-forme.  De plus, le conteneur doit non seulement recevoir des événements, mais également s'adapter, en d'autres termes, y répondre.  D'où le nom du principe, qui peut être considéré comme une exigence pour fournir à la plateforme des API d'écriture. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bd/3s/p8/bd3sp8v4heoylqg4rzjmk5oiyue.png"></div><br>  Les plates-formes ont différents types d'événements qui aident à gérer le cycle de vie du conteneur.  Mais c'est à l'application de décider laquelle percevoir et comment y répondre. <br><br>  Il est clair que certains événements sont plus importants que d'autres.  Par exemple, si l'application ne tolère pas l'arrêt d'urgence, elle doit accepter les messages signal: terminate (SIGTERM) et lancer sa procédure de terminaison dès que possible afin d'attraper le signal: kill (SIGKILL) qui vient après SIGTERM. <br><br>  De plus, des événements tels que PostStart et PreStop peuvent être importants pour le cycle de vie de l'application.  Par exemple, après le lancement de l'application, il peut s'écouler un certain temps avant de répondre aux demandes.  Ou l'application doit en quelque sorte libérer des ressources à l'arrêt. <br><br><h3>  Le principe d'immuabilité de l'image du contenant (Principe d'Immutabilité d'Image, IIP) </h3><br>  Il est généralement admis que les applications conteneurisées doivent rester inchangées après l'assemblage, même si elles s'exécutent dans des environnements différents.  Cela implique la nécessité d'externaliser le stockage des données lors de l'exécution (en d'autres termes, d'utiliser des outils externes pour cela), ainsi que de s'appuyer sur des configurations externes configurées pour un environnement d'exécution spécifique, au lieu de modifier ou de créer des conteneurs uniques pour chaque environnement.  Après toute modification de l'application, l'image du conteneur doit être réassemblée et déployée dans tous les environnements utilisés.  Soit dit en passant, lors de la gestion des systèmes informatiques, un principe similaire est utilisé, connu sous le nom de principe d'immuabilité des serveurs et des infrastructures. <br><br>  Le but de IIP est d'empêcher la création d'images de conteneurs distinctes pour différents environnements d'exécution et d'utiliser la même image partout avec la configuration appropriée pour un environnement spécifique.  Le respect de ce principe vous permet de mettre en œuvre des pratiques aussi importantes du point de vue de l'automatisation des systèmes cloud que la restauration et la restauration des mises à jour des applications. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hl/rr/t9/hlrrt9r4lw4f7wcik19j3o5zmou.png"></div><br><h3>  Principe d'élimination des processus (PDP) </h3><br>  L'une des caractéristiques les plus importantes d'un conteneur est son éphéméralité: une instance de conteneur est facilement créée et facilement détruite, de sorte qu'elle peut être facilement remplacée par une autre instance à tout moment.  Il peut y avoir plusieurs raisons à un tel remplacement: échec du test d'intégrité, mise à l'échelle de l'application, transfert vers un autre hôte, épuisement des ressources de la plateforme ou autres situations. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tk/qw/lq/tkqwlqu9-qyusgg6n-wpgl0hxks.png"></div><br>  Par conséquent, les applications de conteneur doivent conserver leur état en utilisant des moyens externes, ou utiliser des circuits distribués internes avec redondance pour cela.  De plus, l'application doit se lancer rapidement et s'arrêter rapidement, et être préparée à une panne matérielle soudaine et fatale. <br><br>  Une pratique qui aide à mettre en œuvre ce principe est de créer de petits conteneurs.  Les environnements cloud peuvent sélectionner automatiquement un hôte pour lancer une instance de conteneur, donc plus le conteneur est petit, plus il démarrera rapidement - il sera simplement copié sur l'hôte cible sur le réseau plus rapidement. <br><br><h3>  Principe d'auto-confinement (S-CP) </h3><br>  Selon ce principe, au stade de l'assemblage, tous les composants nécessaires sont inclus dans le conteneur.  Le conteneur doit être construit dans l'espoir que le système ne dispose que d'un noyau Linux propre, donc toutes les bibliothèques supplémentaires nécessaires doivent être placées dans le conteneur lui-même.  Des éléments doivent également s'y trouver, tels que le runtime du langage de programmation correspondant, la plate-forme d'application (si nécessaire) et d'autres dépendances qui seront nécessaires pendant le fonctionnement de l'application conteneur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p7/ia/qb/p7iaqbxksacennpuyk5vvhzdnw4.png"></div><br><br>  Des exceptions sont faites uniquement pour les configurations qui varient d'un environnement à l'autre et doivent être fournies au moment de l'exécution, par exemple via Kubernetes ConfigMap. <br><br>  Une application peut inclure plusieurs composants conteneurisés, par exemple, un conteneur SGBD distinct dans le cadre d'une application de conteneur Web.  Selon le principe S-CP, ces conteneurs ne doivent pas être combinés en un seul, mais conçus de manière à ce que le conteneur SGBD contienne tout ce qui est nécessaire au fonctionnement de la base de données et que le conteneur d'application Web contienne tout le nécessaire au fonctionnement de l'application Web, le même serveur Web. .  Par conséquent, au moment de l'exécution, le conteneur d'application Web dépendra du conteneur SGBD et y accédera si nécessaire. <br><br><h3>  Principe de confinement d'exécution (RCP) </h3><br>  Le principe S-CP définit comment un conteneur doit être assemblé et ce qu'un fichier image binaire doit contenir.  Mais un conteneur n'est pas seulement une «boîte noire», qui n'a qu'une seule caractéristique - la taille du fichier.  Au moment de l'exécution, le conteneur acquiert d'autres dimensions: la quantité de mémoire utilisée, le temps processeur et d'autres ressources système. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e5/v5/vb/e5v5vbk3witcr7oe1bgs23forks.png"></div><br>  Et ici, le principe RCP est utile, selon lequel le conteneur doit décapiter ses besoins en ressources système et les transférer sur la plateforme.  Ayant les profils de ressources de chaque conteneur (combien de ressources CPU, mémoire, réseau et système de disque dont elle a besoin), la plateforme peut effectuer de manière optimale la planification et la mise à l'échelle automatique, gérer les capacités informatiques et prendre en charge les niveaux SLA pour les conteneurs. <br><br>  En plus de répondre aux besoins en ressources du conteneur, il est également important que l'application ne dépasse pas le cadre désigné par celui-ci.  Sinon, en cas de manque de ressources, la plateforme est plus susceptible de l'inclure dans la liste des applications qui doivent être interrompues ou migrées. <br><br>  Parlant de l'accent mis sur le cloud, nous entendons principalement notre façon de travailler. <br>  Ci-dessus, nous avons formulé un certain nombre de principes généraux qui jettent les bases méthodologiques pour la création d'applications de conteneurs de haute qualité pour les environnements cloud. <br><br>  Notez qu'en plus de ces principes généraux, vous aurez également besoin de méthodes et de techniques avancées supplémentaires pour travailler avec des conteneurs.  De plus, nous avons quelques courtes recommandations plus spécifiques et qui doivent être appliquées (ou non) en fonction de la situation: <br><br><ul><li>  Essayez de réduire la taille des images: supprimez les fichiers temporaires et ne placez pas de packages inutiles - plus le conteneur est petit, plus il est collecté et copié rapidement sur l'hôte cible sur le réseau. </li><li>  Concentrez-vous sur les ID utilisateur arbitraires: n'utilisez pas la commande sudo ou un ID utilisateur spécial pour exécuter vos conteneurs. </li><li>  Étiquetez les ports importants: les numéros de port peuvent également être définis au moment de l'exécution, mais il est préférable de les spécifier à l'aide de la commande EXPOSE - il sera plus facile pour d'autres personnes et programmes d'utiliser vos images. </li><li>  Conserver les données persistantes sur les volumes: les données qui doivent rester après la destruction du conteneur doivent être écrites sur les volumes. </li><li>  Écrire des métadonnées d'image: les balises, les étiquettes et les annotations facilitent l'utilisation des images - les autres développeurs vous en seront reconnaissants. </li><li>  Synchroniser l'hôte et les images: pour certaines applications de conteneur, il est nécessaire de synchroniser le conteneur avec l'hôte en fonction de certains attributs, tels que l'heure ou l'ID de la machine. </li><li>  En conclusion, nous partageons des modèles et des meilleures pratiques qui aideront à mettre en œuvre plus efficacement les principes ci-dessus: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.slideshare.net/luebken/container-patterns</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.projectatomic.io/container-best-practices</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.openshift.com/enterprise/3.0/creating_images/guidelines.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.usenix.org/system/files/conference/hotcloud16/hotcloud16_burns.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">leanpub.com/k8spatterns</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">12factor.net</a> </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>Webinaire sur la nouvelle version d'OpenShift Container Platform - 4</b></a> <br>  11 juin à 11h00 <br><br>  Ce que vous apprendrez: <br><br><ul><li>  Immuable Red Hat Enterprise Linux CoreOS </li><li>  Maillage de service OpenShift </li><li>  Cadre opérateur </li><li>  Cadre Knative </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455024/">https://habr.com/ru/post/fr455024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455012/index.html">FAQ sur l'interception cellulaire: Que sont les intercepteurs / SCAT IMSI et puis-je les protéger contre eux?</a></li>
<li><a href="../fr455016/index.html">Nous créons le site le plus inaccessible avec une cote idéale Phare</a></li>
<li><a href="../fr455018/index.html">Le poste du grand amour pour les petites entreprises</a></li>
<li><a href="../fr455020/index.html">Avantages et inconvénients de l'utilisation de Flutter pour le développement mobile</a></li>
<li><a href="../fr455022/index.html">Comment exécuter Scrum efficacement en 2019? Guide rapide pour les débutants</a></li>
<li><a href="../fr455026/index.html">Téléphonie avec Snom: pour ceux qui travaillent à domicile</a></li>
<li><a href="../fr455030/index.html">Spécifications PHP</a></li>
<li><a href="../fr455032/index.html">Pas un insecte, mais une caractéristique: une étude de la motilité et de l'activité cérébrale d'une personne atteinte de polydactylie</a></li>
<li><a href="../fr455038/index.html">Comment Plesk a visité KubeCon</a></li>
<li><a href="../fr455040/index.html">Améliorer le travail du Wi-Fi. Partie 2. Caractéristiques de l'équipement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>