<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò¥ üòπ ‚õ∑Ô∏è Pruebas de IU codificadas de Visual Studio: teor√≠a y pr√°ctica de aplicaci√≥n en nuestra empresa üë®üèΩ‚Äçüé§ ü§úüèø üìó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las pruebas de interfaz de usuario automatizadas son un tema que incluso los desarrolladores experimentados desconf√≠an. Adem√°s, la tecnolog√≠a de tales...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pruebas de IU codificadas de Visual Studio: teor√≠a y pr√°ctica de aplicaci√≥n en nuestra empresa</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/416171/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/e4d/592/2aee4d592fcaceeb418e5833c067dcbd.png" alt="Imagen 2"></div><br>  Las pruebas de interfaz de usuario automatizadas son un tema que incluso los desarrolladores experimentados desconf√≠an.  Adem√°s, la tecnolog√≠a de tales pruebas no es algo extraordinario, y en el caso de las Pruebas de IU codificadas de Visual Studio es una extensi√≥n del sistema de pruebas de unidad incorporado Visual Studio Team Test.  En este art√≠culo, quiero profundizar en el tema de las pruebas de IU en general, as√≠ como en nuestra experiencia personal de usar las pruebas de IU codificadas de Visual Studio al trabajar en el analizador est√°tico PVS-Studio. <br><a name="habracut"></a><br><h2>  Los fundamentos </h2><br>  Primero, intentemos descubrir por qu√© las pruebas de IU no son tan populares entre los desarrolladores como, por ejemplo, las pruebas unitarias cl√°sicas. <br><br>  Hay muchas llamadas "pir√°mides de prueba" en la red que muestran la distribuci√≥n √≥ptima recomendada del n√∫mero de pruebas en las capas de aplicaci√≥n.  Todas las pir√°mides son similares y contienen una idea general: tantas pruebas como sea posible deber√≠an estar lo m√°s cerca posible del c√≥digo.  Y viceversa.  Dar√© un ejemplo de una de estas pir√°mides, que contiene recomendaciones adicionales sobre la proporci√≥n del n√∫mero de pruebas en porcentaje. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/430/7b5/b4b/4307b5b4b72a27aade942e0ff1747545.png" alt="Cuadro 4"></div><br>  En la base de la pir√°mide hay pruebas unitarias.  De hecho, tales pruebas son m√°s f√°ciles de hacer en la etapa de desarrollo y se ejecutar√°n muy r√°pidamente.  En la parte superior de la pir√°mide, por otro lado, hay pruebas de interfaz automatizadas.  Estas pruebas no deber√≠an ser muchas, ya que la complejidad de su creaci√≥n, as√≠ como el tiempo de ejecuci√≥n, son bastante grandes.  Adem√°s, no est√° claro a qui√©n confiar la creaci√≥n de pruebas de IU.  De hecho, en esencia, estamos hablando de emular las acciones del usuario.  Todo esto est√° muy lejos del c√≥digo de la aplicaci√≥n, por lo que los desarrolladores son reacios a hacer este tipo de trabajo.  Y para realizar pruebas automatizadas de alta calidad de las interfaces sin la participaci√≥n (o con una participaci√≥n m√≠nima) de los programadores, se requiere el uso de herramientas pagas.  La combinaci√≥n de todos estos factores a menudo conduce al hecho de que las pruebas de IU no funcionan en absoluto, limit√°ndose a pruebas manuales √∫nicas de nuevas funcionalidades.  Adem√°s, las pruebas de interfaz son extremadamente costosas no solo en la etapa de desarrollo, sino tambi√©n durante el ciclo de vida de la aplicaci√≥n.  Incluso un ligero cambio en la interfaz de usuario puede provocar errores en la ejecuci√≥n de muchas pruebas y la necesidad de modificarlas. <br><br>  Observo que en la actualidad, nuestro sistema de prueba en general cumple con las recomendaciones.  El n√∫mero de pruebas de GUI automatizadas (45) es aproximadamente una d√©cima parte del n√∫mero total de pruebas de PVS-Studio.  Al mismo tiempo, el n√∫mero de pruebas unitarias no es tan grande, pero se complementan con una gran cantidad de otros sistemas de prueba: <br><br><ul><li> Pruebas de rendimiento de analizadores (C / C ++ / C # / Java), durante las cuales verifican un gran conjunto de proyectos de prueba en diferentes sistemas operativos (Windows, Linux, macOS) y comparan los registros de nuevas advertencias con los de referencia; </li><li>  Pruebas de caracter√≠sticas espec√≠ficas (seguimiento del lanzamiento de compiladores, etc.); </li><li>  Pruebas externas de aplicaciones de l√≠nea de comandos; </li><li>  Pruebas de montaje, instalaci√≥n y despliegue correctos; </li><li>  Pruebas de documentaci√≥n. </li></ul><br>  En la etapa inicial de su desarrollo, el analizador PVS-Studio era una aplicaci√≥n para encontrar errores al portar c√≥digo C / C ++ a una plataforma de 64 bits.  S√≠, y fue llamado en ese momento de una manera diferente, "Viva64".  La historia del producto se puede encontrar en el art√≠culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo comenz√≥ el proyecto PVS-Studio hace 10 a√±os</a> ".  Despu√©s de la integraci√≥n en Visual Studio 2005, el analizador adquiri√≥ una interfaz gr√°fica de usuario, esencialmente la interfaz del IDE de Visual Studio, en la cual, despu√©s de instalar el complemento, apareci√≥ un men√∫ adicional para acceder a la funcionalidad del analizador.  El men√∫ ten√≠a dos o tres elementos, por lo que no hab√≠a nada que probar all√≠.  Y Visual Studio en ese momento no conten√≠a ninguna herramienta integrada para probar las GUI. <br><br><h2>  Pruebas y alternativas de IU codificadas de Visual Studio </h2><br>  Todo cambi√≥ con el lanzamiento de Visual Studio 2010, que introdujo un sistema integrado para crear pruebas de IU: Pruebas de IU codificadas de Visual Studio (CUIT).  Basado en el sistema de prueba de la unidad Visual Studio Team Test, CUIT inicialmente utiliz√≥ la tecnolog√≠a Microsoft Active Accessibility (MSAA) para acceder a los elementos de la interfaz visual.  En el futuro, la tecnolog√≠a se mejor√≥ y actualmente es un modelo desarrollado de automatizaci√≥n de la interfaz de usuario para probar el c√≥digo UIA (UI Automation).  Permite que el sistema de prueba acceda a campos abiertos (nombre del objeto, nombre interno de la clase del objeto, estado actual del objeto, su lugar en la estructura jer√°rquica de la interfaz, etc.) de los elementos COM y .NET UI, y el sistema le permite emular los efectos en estos elementos a trav√©s de dispositivos de entrada est√°ndar (mouse, teclado).  Desde el primer momento, se admiten modos para registrar las acciones del usuario cuando interact√∫a con la interfaz (similar a las macros de Visual Studio), la automatizaci√≥n de la construcci√≥n de un "mapa de interfaz" (propiedades de controles, par√°metros de b√∫squeda y acceso a ellos), junto con la generaci√≥n autom√°tica de c√≥digo de control.  En el futuro, toda la informaci√≥n acumulada es f√°cil de modificar y mantener actualizada, as√≠ como personalizar las secuencias de prueba que desee, al tiempo que posee habilidades m√≠nimas de programaci√≥n. <br><br>  Adem√°s, como dije antes, ahora al crear complejas pruebas de IU inteligentes, puede prescindir de cualquier habilidad de programaci√≥n, siempre que use herramientas especializadas pagas.  Bueno, si no hay deseo o capacidad de usar entornos de prueba patentados, hay muchos productos y marcos gratuitos.  El sistema de Pruebas de IU codificadas de Visual Studio es una soluci√≥n intermedia que permite no solo automatizar el proceso de creaci√≥n de pruebas de IU tanto como sea posible.  Con su ayuda, es f√°cil crear secuencias de prueba arbitrarias en los lenguajes de programaci√≥n C # o VB. <br><br>  Todo esto puede reducir significativamente el costo de crear y mantener la relevancia de las pruebas de GUI.  El marco utilizado es simple de entender y, en general, se puede representar en forma de diagrama. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10b/b6a/756/10bb6a7561749453f882bfa0c86b9f43.png" alt="Imagen 1"></div><br>  De los elementos clave, deben tenerse en cuenta los llamados "adaptadores de interfaz", que se encuentran en el nivel m√°s bajo de abstracci√≥n.  Esta capa interact√∫a con los elementos finitos de la interfaz de usuario, y sus capacidades se pueden ampliar utilizando adaptadores adicionales.  Arriba hay una capa que oculta las tecnolog√≠as de acceso a la GUI del resto del c√≥digo, incluidas las interfaces de acceso al programa y el c√≥digo de la aplicaci√≥n de prueba real, que incluye todos los elementos necesarios para probar la automatizaci√≥n.  La tecnolog√≠a es extensible, cada nivel puede complementarse con los elementos necesarios dentro del marco del marco. <br><br>  Las caracter√≠sticas principales de CUIT de Microsoft incluyen: <br><br><ul><li>  Pruebas funcionales de interfaces de usuario.  Se admiten aplicaciones cl√°sicas basadas en Windows, aplicaciones web y servicios, WPF </li><li>  Generaci√≥n de c√≥digo (incluido autom√°tico) en VB / C # </li><li>  Capacidad para integrarse en el proceso de ensamblaje </li><li>  Lanzamientos locales o remotos, recopilaci√≥n de informes </li><li>  Disponibilidad de grabaci√≥n y reproducci√≥n de secuencias de prueba. </li><li>  Buena extensibilidad </li></ul><br>  A pesar de una serie de dificultades asociadas con CUIT, se prefiere el uso de esta tecnolog√≠a de prueba por varias razones: <br><br><ul><li>  Interacci√≥n efectiva de desarrolladores y probadores dentro de una herramienta y lenguaje de programaci√≥n </li><li>  Caracter√≠sticas adicionales de trabajar con la "tarjeta de interfaz", que permite la identificaci√≥n de controles "sobre la marcha", la sincronizaci√≥n de elementos y la realizaci√≥n de secuencias de prueba </li><li>  Afinando el mecanismo de reproducci√≥n, que permite junto con configuraciones b√°sicas, como un retraso entre operaciones, un tiempo de espera de b√∫squeda de elementos, etc., utilizar mecanismos especializados en el c√≥digo.  Por ejemplo, bloquear el subproceso actual hasta que el control se active (visualice) utilizando los <i>m√©todos</i> <i>WaitForControlExist</i> o <i>WaitForReady</i> con la enumeraci√≥n <i>WaitForReadyLevel</i> , etc. </li><li>  Capacidad para programar pruebas ilimitadamente complejas </li></ul><br>  No profundizar√© en los aspectos te√≥ricos de la tecnolog√≠a de Pruebas de IU codificadas de Visual Studio, todos se detallan en la documentaci√≥n pertinente.  All√≠ puede encontrar instrucciones detalladas paso a paso para crear la prueba de IU m√°s simple basada en este sistema.  Y s√≠, el sistema no es gratuito, necesitar√° Visual Studio Enterprise para trabajar con √©l. <br><br>  La tecnolog√≠a descrita no es la √∫nica en el mercado.  Hay muchas otras soluciones.  Todos los sistemas alternativos de prueba de IU se pueden dividir en pagos y gratuitos.  Adem√°s, la elecci√≥n de un sistema en particular no siempre depender√° de su precio.  Por ejemplo, la capacidad de crear pruebas sin la necesidad de programaci√≥n puede servir como un factor importante, pero al mismo tiempo, las pruebas pueden no ser lo suficientemente flexibles.  Tambi√©n es importante admitir el entorno de prueba necesario: sistemas operativos y aplicaciones.  Finalmente, las caracter√≠sticas puramente espec√≠ficas de la aplicaci√≥n y su interfaz pueden influir en la elecci√≥n.  Aqu√≠ hay algunos sistemas y tecnolog√≠as populares para probar las GUI. <br><br>  <i>Pagado</i> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TestComplete</a> (SmartBear), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prueba funcional unificada</a> (Micro Focus), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Squish</a> (froglogic), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Herramientas de prueba automatizadas</a> (Ranorex), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Berenjena funcional</a> (berenjena), etc. <br><br>  <i>Gratis</i> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AutoIt</a> (windows), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Selenium</a> (web), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Katalon Studio</a> (web, m√≥vil), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sahi</a> (web), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Robot Framework</a> (web), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LDTP</a> (Linux Desktop Testing Project), marcos de c√≥digo abierto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TestStack.White</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UIAutomationVerify,.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NET biblioteca de automatizaci√≥n de Windows</a> , etc. <br><br>  Por supuesto, esta lista no est√° completa.  Sin embargo, es obvio que los sistemas libres generalmente se centran en un sistema operativo espec√≠fico o tecnolog√≠a de prueba.  La regla general es que entre los sistemas pagos encontrar√° mucho m√°s r√°pido algo adecuado espec√≠ficamente para sus necesidades, el desarrollo y mantenimiento de las pruebas ser√° m√°s f√°cil y la lista de entornos de prueba compatibles es exhaustiva. <br><br>  En nuestro caso, no hab√≠a ning√∫n problema de elecci√≥n: con el lanzamiento de Visual Studio 2010 con la adici√≥n de Pruebas de IU codificadas, se hizo posible agregar f√°cilmente un conjunto de pruebas funcionales a nuestro entorno de prueba para probar la interfaz de usuario del complemento PVS-Studio para Visual Studio. <br><br><h2>  PVS-Studio UI pruebas </h2><br>  Por lo tanto, las pruebas de GUI en nuestra empresa se han utilizado durante m√°s de 6 a√±os.  El conjunto inicial de pruebas de IU para Visual Studio 2010 se bas√≥ en la √∫nica tecnolog√≠a MSAA (Microsoft Active Accessibility) disponible en ese momento.  Con el lanzamiento de Visual Studio 2012, la tecnolog√≠a MSAA se ha desarrollado significativamente y ahora se llama UIA (UI Automation).  Se decidi√≥ continuar usando el UIA y dejar las pruebas basadas en MSAA para probar el complemento para Visual Studio 2010 (admitimos y probamos complementos para todas las versiones de Visual Studio, comenzando con Visual Studio 2010). <br><br>  Como resultado, hemos formado dos "ramas" de pruebas de IU.  Adem√°s, en el proyecto de prueba, ambas ramas utilizaron un mapa de interfaz com√∫n y un c√≥digo compartido.  En el c√≥digo, se parec√≠a a esto (m√©todo para restablecer la configuraci√≥n de Visual Studio a est√°ndar antes de ejecutar la prueba): <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVSSettings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TestingMode mode)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-meta"><span class="hljs-meta">#region MSAA Mode </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (mode == TestingMode.MSAA) { .... return; } #endregion </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//UIA Mode .... }</span></span></span></span></code> </pre> <br>  Al realizar cambios en la interfaz del complemento, fue necesario realizar cambios en ambas ramas de las pruebas de IU, y agregar nuevas funcionalidades hizo necesario duplicar el elemento de la interfaz en el mapa: es decir, crear dos elementos diferentes para cada una de las tecnolog√≠as MSAA y UIA.  Todo esto requiri√≥ mucho esfuerzo no solo para crear o modificar pruebas, sino tambi√©n para mantener el entorno de prueba en un estado estable.  Me detendr√© en este aspecto con m√°s detalle. <br><br>  Seg√∫n mis observaciones, la estabilidad del entorno de prueba cuando se prueba la GUI es un problema importante.  Esto se debe principalmente a la fuerte dependencia de tales pruebas de muchos factores externos.  De hecho, de hecho, las acciones del usuario son emuladas: presionar teclas, mover el cursor del mouse, clics del mouse, etc.  Hay muchas cosas que pueden "salir mal".  Por ejemplo, si durante la prueba alguien interact√∫a con un teclado conectado al servidor de prueba.  Adem√°s, inesperadamente, la resoluci√≥n del monitor puede no ser suficiente para mostrar ning√∫n control y el entorno de prueba no la encontrar√°. <br><br>  En espera: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/57b/2fb/f0757b2fb7075dcfac29b66f81832b69.png" alt="Cuadro 3"></div><br>  Realidad: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/rh/ty/jdrhtyxluox8lhxhab_btiuhjp8.png"></div><br>  Un elemento de mapa de interfaz sintonizado descuidadamente (y no encontrado m√°s adelante) es pr√°cticamente el l√≠der del comportamiento problem√°tico.  Por ejemplo, al crear un nuevo control, el asistente de mapa de interfaz de Pruebas de IU codificadas de Visual Studio usa los criterios de b√∫squeda Equals predeterminados para √©l.  Es decir, se requiere una coincidencia exacta de los nombres de propiedad con los valores especificados.  Esto generalmente funciona, pero a veces la estabilidad de la ejecuci√≥n de la prueba se puede mejorar significativamente utilizando los criterios de b√∫squeda menos estrictos "Contiene" en lugar de "Igual".  Este es solo un ejemplo de un "ajuste" que puede encontrar al trabajar en pruebas de IU. <br><br>  Finalmente, algunas de sus pruebas pueden consistir en realizar una acci√≥n y esperar a√∫n m√°s un resultado, que, por ejemplo, est√° asociado con la visualizaci√≥n de una ventana.  En este caso, al problema de buscar un elemento, se agregar√°n preguntas sobre c√≥mo configurar el retraso de reproducci√≥n hasta que aparezca la ventana y luego sincronizar el trabajo.  Algunos de estos problemas pueden resolverse mediante m√©todos de marco est√°ndar ( <i>WaitForControlExist</i> , etc.), mientras que para otros ser√° necesario inventar algoritmos ingeniosos. <br><br>  Nos enfrentamos a un problema similar mientras trabaj√°bamos en una de las pruebas de nuestro complemento.  En esta prueba, primero se abre un entorno de Visual Studio vac√≠o, luego se carga una determinada soluci√≥n de prueba, que se prueba completamente usando PVS-Studio (men√∫ ‚ÄúPVS-Studio‚Äù -&gt; ‚ÄúVerificar‚Äù -&gt; ‚ÄúSoluci√≥n‚Äù).  El problema era determinar cu√°ndo se completar√≠a la verificaci√≥n.  Dependiendo de una serie de condiciones, la verificaci√≥n puede no tomar siempre el mismo tiempo, por lo que los tiempos de espera simples no funcionan aqu√≠.  Adem√°s, no puede utilizar los mecanismos est√°ndar para suspender el flujo de prueba y esperar la aparici√≥n (u ocultaci√≥n) de ning√∫n control, ya que no hay nada a lo que apegarse.  Durante la verificaci√≥n, aparece una ventana con el estado del trabajo, pero esta ventana puede ocultarse y la verificaci√≥n continuar√°.  Es decir  esta ventana no se puede guiar (adem√°s, tiene la configuraci√≥n "No cerrar despu√©s de completar el an√°lisis").  Y quer√≠a que el algoritmo fuera m√°s general para poder usarlo en varias pruebas relacionadas con la verificaci√≥n de proyectos y la espera de la finalizaci√≥n de este proceso.  Se ha encontrado una soluci√≥n.  Despu√©s de comenzar la prueba y hasta su finalizaci√≥n, el mismo elemento del men√∫ "PVS-Studio" -&gt; "Verificar" -&gt; "Soluci√≥n" est√° inactivo.  Solo tuvimos que verificar la propiedad "Habilitado" de este elemento del men√∫ en un intervalo de tiempo determinado (a trav√©s del objeto de mapa de interfaz) y, si se descubri√≥ que el elemento se hab√≠a activado, considerar el proceso de verificaci√≥n de decisi√≥n completo. <br><br>  Por lo tanto, en el caso de las pruebas de IU, no es suficiente simplemente crear pruebas.  Se requiere una sintonizaci√≥n sutil y meticulosa en cada caso.  Es necesario comprender y sincronizar toda la secuencia de acciones realizadas.  Por ejemplo, el elemento del men√∫ contextual no se encontrar√° hasta que este men√∫ se muestre en la pantalla, etc.  Tambi√©n se requiere una preparaci√≥n cuidadosa del entorno de prueba.  En este caso, puede contar con el funcionamiento estable de las pruebas y los resultados adecuados. <br><br>  Perm√≠tame recordarle que el sistema de pruebas de IU en nuestra empresa se ha desarrollado desde 2010.  Durante este tiempo, se crearon varias docenas de secuencias de prueba y se escribi√≥ una gran cantidad de c√≥digo auxiliar.  Las pruebas de aplicaciones independientes se han agregado a las pruebas de complementos a lo largo del tiempo.  En este punto, la antigua rama de prueba de complementos para Visual Studio 2010 hab√≠a perdido su relevancia y fue abandonada, pero era simplemente imposible eliminar este c√≥digo "muerto" del proyecto.  En primer lugar, como mostr√© antes, el c√≥digo estaba bastante integrado en los m√©todos de prueba.  Y en segundo lugar, m√°s de la mitad de los elementos de la tarjeta de interfaz existente pertenec√≠an a la antigua tecnolog√≠a MSAA, pero se reutilizaron (en lugar de duplicar) en muchas pruebas nuevas junto con elementos UIA (esto es posible debido a la continuidad de la tecnolog√≠a).  Al mismo tiempo, la masa del c√≥digo generado autom√°ticamente y el contenido de los m√©todos de prueba estaba vinculado a los elementos "antiguos". <br><br>  Para el oto√±o de 2017, era necesario mejorar el sistema de pruebas de IU.  En general, las pruebas funcionaron bien, pero de vez en cuando algunas "fallaron" por razones desconocidas.  M√°s precisamente, la raz√≥n generalmente era encontrar un control.  En cada caso, tuve que ir a trav√©s del √°rbol del mapa de interfaz a un elemento espec√≠fico y verificar sus criterios de b√∫squeda y otras configuraciones.  A veces, un reinicio del software de estas configuraciones ayud√≥ antes de ejecutar la prueba.  Dado el mapa de interfaz que ha crecido (y en muchos aspectos, de muchas maneras) por la tarjeta de interfaz, as√≠ como la presencia de c√≥digo "inactivo", este proceso requiri√≥ un esfuerzo considerable. <br><br>  Durante alg√∫n tiempo, la tarea "estaba esperando a su h√©roe", hasta que, finalmente, se me ocurri√≥. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3b/a0e/940/c3ba0e9405d26985a0519cf66544ca36.png" alt="Cuadro 5"></div><br>  No te aburrir√© con una descripci√≥n de los matices.  Solo puedo decir que el trabajo no fue dif√≠cil, pero requiri√≥ considerable perseverancia y atenci√≥n.  Todo sobre todo me llev√≥ unas dos semanas.  Pas√© la mitad de este tiempo refactorizando el c√≥digo y las tarjetas de interfaz.  En el tiempo restante, se dedic√≥ a la estabilizaci√≥n de la ejecuci√≥n de la prueba, que b√°sicamente se redujo a un ajuste m√°s fino de los criterios de b√∫squeda de elementos visuales (edici√≥n del mapa de la interfaz), as√≠ como a una cierta optimizaci√≥n del c√≥digo. <br><br>  Como resultado, logramos reducir el tama√±o del c√≥digo de los m√©todos de prueba en aproximadamente un 30%, y la cantidad de controles en el √°rbol del mapa de interfaz se redujo a la mitad.  Pero lo m√°s importante, las pruebas de IU comenzaron a mostrar un rendimiento m√°s estable y requieren menos atenci√≥n.  Y la ca√≠da comenz√≥ a ocurrir con mayor frecuencia debido a razones para realizar cambios en la funcionalidad del analizador o al detectar inconsistencias (errores).  En realidad, para estos fines, necesitamos un sistema de pruebas de IU. <br><br>  Por lo tanto, en la actualidad, el sistema de pruebas autom√°ticas de la interfaz PVS-Studio tiene las siguientes caracter√≠sticas b√°sicas: <br><br><ul><li>  Prueba de IU codificada de Visual Studio </li><li>  45 escenarios </li><li>  4,095 l√≠neas de c√≥digo para m√©todos de prueba </li><li>  19,889 l√≠neas de c√≥digo generado autom√°ticamente (excluyendo el tama√±o del archivo xml para almacenar la configuraci√≥n del Mapa de la IU) </li><li>  1 hora 34 minutos de ejecuci√≥n (valor promedio de acuerdo con los resultados de los √∫ltimos 30 inicios) </li><li>  Trabajar en un servidor dedicado (ejecutando la utilidad MSTest.exe) </li><li>  Monitoreo de rendimiento y an√°lisis de informe de rendimiento (Jenkins) </li></ul><br><h2>  Conclusi√≥n </h2><br>  En conclusi√≥n, quiero dar una lista de criterios de √©xito para las pruebas de GUI autom√°ticas, que se basa en un an√°lisis de nuestra experiencia con esta tecnolog√≠a (algunos de los criterios se aplican a otras tecnolog√≠as de prueba, por ejemplo, pruebas unitarias). <br><br>  <i>Herramientas adecuadas</i>  Elija el entorno para crear y ejecutar CUIT de acuerdo con las caracter√≠sticas de su aplicaci√≥n, as√≠ como el entorno de prueba.  Las soluciones pagas no siempre tienen sentido, pero generalmente ayudan a resolver un problema de manera muy efectiva. <br><br>  <i>Configuraci√≥n de infraestructura de alta calidad</i> .  No guarde al desarrollar una tarjeta de interfaz.  Simplifique el trabajo del marco cuando busque elementos describiendo cuidadosamente todas sus propiedades y estableciendo criterios de b√∫squeda inteligentes.  Presta atenci√≥n a las posibilidades de modificaciones adicionales. <br><br>  <i>Minimizaci√≥n del trabajo manual</i> .  Siempre que sea posible, aseg√∫rese de utilizar medios autom√°ticos para generar c√≥digo y grabar secuencias.  Por lo tanto, acelerar√° significativamente el desarrollo y minimizar√° la probabilidad de errores (no siempre es f√°cil encontrar la raz√≥n por la cual la prueba de IU falla, especialmente si se comete un error en el c√≥digo para trabajar con el marco). <br><br>  <i>Pruebas inteligentes simples e independientes</i> .  Cuanto m√°s simples sean tus ex√°menes, mejor.  Intente hacer una prueba por separado para probar un control espec√≠fico o una situaci√≥n simulada.  Tambi√©n aseg√∫rese de que las pruebas sean independientes entre s√≠.  La ca√≠da de una de las pruebas no deber√≠a afectar todo el proceso. <br><br>  <i>Nombres amistosos</i> .  Use prefijos en los nombres de pruebas similares.  Muchos entornos le permiten ejecutar pruebas filtrando por nombre.  Utilice tambi√©n la agrupaci√≥n de prueba siempre que sea posible. <br><br>  <i>Tiempo de ejecuci√≥n aislado</i> .  Aseg√∫rese de que las pruebas se ejecuten en un servidor dedicado con un impacto externo m√≠nimo.  Desconecte todos los dispositivos de entrada de usuario externos, proporcione la resoluci√≥n de pantalla necesaria para su aplicaci√≥n o use un dispositivo ficticio de hardware que simule una conexi√≥n de monitor de alta resoluci√≥n.  Aseg√∫rese de que durante la ejecuci√≥n de la prueba no se ejecuten otras aplicaciones que interact√∫en, por ejemplo, con el escritorio y los mensajes de pantalla.  Tambi√©n es necesario planificar la hora de inicio y considerar la duraci√≥n m√°xima de las pruebas. <br><br>  <i>An√°lisis de informes emitidos</i> .  Proporcione una forma simple y clara para informar sobre el progreso.  Utilice sistemas de integraci√≥n continua para enviar pruebas, as√≠ como obtener y analizar r√°pidamente los resultados de las pruebas. <br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Si desea compartir este art√≠culo con una audiencia de habla inglesa, utilice el enlace a la traducci√≥n: Sergey Khrenov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pruebas de IU codificadas de Visual Studio: teor√≠a y experiencia de usuario de nuestra empresa</a> <br><br><div class="spoiler">  <b class="spoiler_title">¬øHas le√≠do el art√≠culo y tienes una pregunta?</b> <div class="spoiler_text">  A menudo nuestros art√≠culos tienen las mismas preguntas.  Recolectamos las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">respuestas</a> aqu√≠: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Respuestas a las preguntas de los lectores de art√≠culos sobre PVS-Studio, versi√≥n 2015</a> .  Por favor vea la lista. </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416171/">https://habr.com/ru/post/es416171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416159/index.html">C√≥mo nos encargaron comparar un erizo con una serpiente</a></li>
<li><a href="../es416161/index.html">10 razones [para no] usar k8s</a></li>
<li><a href="../es416163/index.html">Aprende OpenGL. Lecci√≥n 5.6 - Mapeo de paralaje</a></li>
<li><a href="../es416167/index.html">Peter Norwig: Aprenda programaci√≥n en ... 10 a√±os</a></li>
<li><a href="../es416169/index.html">Contenedores para adultos (Parte 01): una gu√≠a pr√°ctica de terminolog√≠a</a></li>
<li><a href="../es416175/index.html">Resultados de la competencia de j√≥venes desarrolladores de aplicaciones AR Epson Moverio BT-300</a></li>
<li><a href="../es416177/index.html">F√≥rmula Tupper e implementaci√≥n del algoritmo en Python</a></li>
<li><a href="../es416179/index.html">Una puerta que nos saluda por nombre y se abre solo para los empleados del departamento.</a></li>
<li><a href="../es416183/index.html">Prueba de datos: requisitos y niveles</a></li>
<li><a href="../es416187/index.html">Despu√©s de la reuni√≥n "Nuevas caracter√≠sticas de PostgreSQL 11" (Parte 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>