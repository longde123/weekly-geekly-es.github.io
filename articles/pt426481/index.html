<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ó ü¶ì üßúüèæ Mapas hexagonais no Unity: Path Finder, esquadr√µes de jogadores, anima√ß√µes üôéüèº üëù üìô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partes 1-3: malha, cores e altura das c√©lulas 

 Partes 4-7: solavancos, rios e estradas 

 Pe√ßas 8-11: √°gua, formas terrestres e muralhas 

 Pe√ßas 12...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mapas hexagonais no Unity: Path Finder, esquadr√µes de jogadores, anima√ß√µes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426481/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 1-3: malha, cores e altura das c√©lulas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 4-7: solavancos, rios e estradas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pe√ßas 8-11: √°gua, formas terrestres e muralhas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pe√ßas 12-15: salvar e carregar, texturas, dist√¢ncias</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 16-19: encontrando o caminho, esquadr√µes de jogadores, anima√ß√µes</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 20-23: Nevoeiro da Guerra, Pesquisa de Mapas, Gera√ß√£o de Procedimentos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 24-27: ciclo da √°gua, eros√£o, biomas, mapa cil√≠ndrico</a> <br><br><h1>  Parte 16: encontrando o caminho </h1><br><ul><li>  Real√ßar c√©lulas </li><li>  Selecione um destino de pesquisa </li><li>  Encontre o caminho mais curto </li><li>  Crie uma fila priorit√°ria </li></ul><br>  Depois de calcular as dist√¢ncias entre as c√©lulas, passamos a encontrar os caminhos entre elas. <br><br>  A partir desta parte, os tutoriais de mapa hexagonal ser√£o criados no Unity 5.6.0.  Deve-se notar que na vers√£o 5.6 existe um erro que destr√≥i matrizes de texturas em montagens para v√°rias plataformas.  Voc√™ pode contornar isso incluindo <em>√â leg√≠vel</em> no inspetor de matriz de textura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/165/c4e/1d9165c4e1862b050015df3c9dcc48cd.jpg"></div><br>  <i>Planejando uma viagem</i> <br><a name="habracut"></a><br><h2>  C√©lulas destacadas </h2><br>  Para pesquisar o caminho entre duas c√©lulas, primeiro precisamos selecionar essas c√©lulas.  √â mais do que apenas escolher uma c√©lula e monitorar a pesquisa no mapa.  Por exemplo, primeiro selecionaremos a c√©lula inicial e depois a final.  Nesse caso, seria conveniente que eles fossem destacados.  Portanto, vamos adicionar essa funcionalidade.  At√© criarmos uma maneira sofisticada ou eficiente de destacar, apenas criamos algo para nos ajudar no desenvolvimento. <br><br><h3>  Textura de contorno </h3><br>  Uma maneira simples de selecionar c√©lulas √© adicionar um caminho a elas.  A maneira mais f√°cil de fazer isso √© com uma textura contendo um contorno hexagonal.  <a href="">Aqui</a> voc√™ pode baixar essa textura.  √â transparente, exceto pelo contorno branco do hex√°gono.  Depois de branco, no futuro poderemos colorir conforme necess√°rio. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0j/4u/vs/0j4uvsbyjtxiavcwaajn73csp68.png"></div><br>  <i>Contorno de c√©lula em fundo preto</i> <br><br>  Importe a textura e defina seu <em>Tipo de textura</em> como <em>Sprite</em> .  O <em>Modo Sprite</em> dela ser√° definido como <em>√önico</em> com as configura√ß√µes padr√£o.  Como essa √© uma textura excepcionalmente branca, n√£o precisamos converter para <em>sRGB</em> .  O canal alfa indica transpar√™ncia, portanto, ative <em>Alpha √© Transparency</em> .  Tamb√©m defino a textura do <em>Modo de filtro</em> como <em>Trilinear</em> , porque, caso contr√°rio, as transi√ß√µes mip para os caminhos podem se tornar muito vis√≠veis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebb/e4a/a88/ebbe4aa88f93b71cf5946c4c011339dc.png"></div><br>  <i>Op√ß√µes de importa√ß√£o de textura</i> <br><br><h3>  Um sprite por c√©lula </h3><br>  A maneira mais r√°pida √© adicionar um poss√≠vel contorno √†s c√©lulas, adicionando cada sprite.  Crie um novo objeto de jogo, adicione o componente Imagem ( <em>Componente / UI / Imagem</em> ) e atribua a ele nosso sprite de estrutura de t√≥picos.  Em seguida, insira a inst√¢ncia pr√©-fabricada do <em>Hex Cell Label</em> na cena, torne o objeto sprite filho dela, aplique as altera√ß√µes √† pr√©-fabricada e depois se livre da pr√©-fabricada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/7f6/7f4/5c27f67f4596673f5b2e73b2db5073cd.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/f7c/ea8/5daf7cea84e2ff46829460e0523bfa91.png"></div><br>  <i>Elemento de sele√ß√£o filho pr√©-fabricado</i> <br><br>  Agora cada c√©lula tem um sprite, mas ser√° muito grande.  Para fazer com que os contornos correspondam aos centros das c√©lulas, altere a <em>Largura</em> e a <em>Altura</em> do componente de transforma√ß√£o do sprite para 17. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc1/069/e42/bc1069e4216435f1a30af953af5b948a.png"></div><br>  <i>Sprites de sele√ß√£o parcialmente ocultos por um relevo</i> <br><br><h3>  Desenho em cima de tudo </h3><br>  Como o contorno √© sobreposto √† √°rea das bordas das c√©lulas, geralmente aparece sob a geometria do relevo.  Por esse motivo, parte do circuito desaparece.  Isso pode ser evitado aumentando ligeiramente os sprites na vertical, mas n√£o no caso de quebras.  Em vez disso, podemos fazer o seguinte: sempre desenhe sprites em cima de tudo o mais.  Para fazer isso, crie seu pr√≥prio shader de sprite.  Ser√° suficiente copiarmos o shader de sprite padr√£o do Unity e fazermos algumas altera√ß√µes. <br><br><pre><code class="hljs powershell">Shader <span class="hljs-string"><span class="hljs-string">"Custom/Highlight"</span></span> { Properties { <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainTex</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Sprite Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Color (<span class="hljs-string"><span class="hljs-string">"Tint"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">MaterialToggle</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PixelSnap</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Pixel snap"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">HideInInspector</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RendererColor</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"RendererColor"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">HideInInspector</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Flip</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Flip"</span></span>, Vector) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AlphaTex</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"External Alpha"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableExternalAlpha</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Enable External Alpha"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> } SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"IgnoreProjector"</span></span>=<span class="hljs-string"><span class="hljs-string">"True"</span></span> <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"PreviewType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Plane"</span></span> <span class="hljs-string"><span class="hljs-string">"CanUseSpriteAtlas"</span></span>=<span class="hljs-string"><span class="hljs-string">"True"</span></span> } Cull Off ZWrite Off Blend One OneMinusSrcAlpha Pass { CGPROGRAM <span class="hljs-comment"><span class="hljs-comment">#pragma vertex SpriteVert #pragma fragment SpriteFrag #pragma target 2.0 #pragma multi_compile_instancing #pragma multi_compile _ PIXELSNAP_ON #pragma multi_compile _ ETC1_EXTERNAL_ALPHA #include "UnitySprites.cginc" ENDCG } } }</span></span></code> </pre> <br>  A primeira mudan√ßa √© que ignoramos o buffer de profundidade, tornando o teste Z sempre bem-sucedido. <br><br><pre> <code class="hljs pgsql"> ZWrite <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> ZTest <span class="hljs-keyword"><span class="hljs-keyword">Always</span></span></code> </pre> <br>  A segunda mudan√ßa √© que estamos renderizando ap√≥s o restante da geometria transparente.  O suficiente para adicionar 10 √† fila de transpar√™ncia. <br><br><pre> <code class="hljs objectivec"> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent+10"</span></span></code> </pre> <br>  Crie um novo material que esse shader usar√°.  Podemos ignorar todas as suas propriedades, aderindo aos valores padr√£o.  Em seguida, fa√ßa a pr√©-fabricada de sprite usar esse material. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15b/d01/812/15bd01812d94f52ced67308dd000c430.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/393/e24/ef5393e241252d81513a0ff5f8972b50.png"></div><br>  <i>Usamos nosso pr√≥prio material de sprite</i> <br><br>  Agora os contornos da sele√ß√£o est√£o sempre vis√≠veis.  Mesmo se a c√©lula estiver oculta sob um relevo mais alto, seu contorno ainda ser√° desenhado em cima de tudo o resto.  Pode n√£o parecer bonito, mas as c√©lulas selecionadas sempre estar√£o vis√≠veis, o que √© √∫til para n√≥s. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce2/8bc/418/ce28bc418dc0ec116cff1bcbaddf0363.png"></div><br>  <i>Ignore o buffer de profundidade</i> <br><br><h3>  Controle de sele√ß√£o </h3><br>  N√£o queremos que todas as c√©lulas sejam destacadas ao mesmo tempo.  De fato, inicialmente todos eles devem ser desmarcados.  Podemos implementar isso desabilitando o componente Image do objeto pr√©-fabricado <em>Highlight</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82f/00e/164/82f00e164316900fb9d9694030298bcc.png"></div><br>  <i>Componente de imagem desativada</i> <br><br>  Para habilitar a sele√ß√£o de c√©lulas, adicione o m√©todo <code>EnableHighlight</code> ao <code>EnableHighlight</code> .  Ele deve pegar o √∫nico filho do <code>uiRect</code> e incluir o componente Image.  Tamb√©m criaremos o m√©todo <code>DisableHighlight</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Finalmente, podemos especificar a cor para que, quando ativada, d√™ um tom √† luz de fundo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color color</span></span></span><span class="hljs-function">)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.color = color; highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">unitypackage</a> <br><br><h2>  Encontrando o caminho </h2><br>  Agora que podemos selecionar as c√©lulas, precisamos seguir em frente e selecionar duas c√©lulas e, em seguida, encontrar o caminho entre elas.  Primeiro, precisamos selecionar as c√©lulas, depois restringir a pesquisa a um caminho entre elas e, finalmente, mostrar esse caminho. <br><br><h3>  In√≠cio da pesquisa </h3><br>  Precisamos selecionar duas c√©lulas diferentes, os pontos inicial e final da pesquisa.  Suponha que, para selecionar a c√©lula de pesquisa inicial, mantenha pressionada a tecla Shift esquerda enquanto clica no mouse.  Nesse caso, a c√©lula √© destacada em azul.  Precisamos salvar o link para esta c√©lula para futuras pesquisas.  Al√©m disso, ao escolher uma nova c√©lula inicial, a sele√ß√£o da antiga deve ser desativada.  Portanto, adicionamos o campo <code>searchFromCell</code> ao <code>searchFromCell</code> . <br><br><pre> <code class="cs hljs"> HexCell previousCell, searchFromCell;</code> </pre> <br>  Dentro do <code>HandleInput</code> podemos usar <code>Input.GetKey(KeyCode.LeftShift)</code> para testar a tecla Shift pressionada. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.FindDistancesTo(currentCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d50/a63/1c3/d50a631c3f4701e414b2e9a9078a57a2.png"></div><br>  <i>Onde procurar</i> <br><br><h3>  Ponto final de pesquisa </h3><br>  Em vez de procurar todas as dist√¢ncias de uma c√©lula, agora estamos procurando um caminho entre duas c√©lulas espec√≠ficas.  Portanto, renomeie <code>HexGrid.FindDistancesTo</code> para <code>HexGrid.FindPath</code> e atribua o segundo par√¢metro <code>HexCell</code> , al√©m de alterar o m√©todo <code>Search</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(fromCell, toCell)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); List&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Add(fromCell); ‚Ä¶ }</code> </pre> <br>  Agora <code>HexMapEditor.HandleInput</code> deve chamar o m√©todo modificado, usando <code>searchFromCell</code> e <code>currentCell</code> como argumentos.  Al√©m disso, s√≥ podemos pesquisar quando sabemos em qual c√©lula pesquisar.  E n√£o precisamos nos preocupar em procurar se os pontos inicial e final coincidem. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { hexGrid.FindPath(searchFromCell, currentCell); }</code> </pre> <br>  Voltando √† pesquisa, primeiro precisamos nos livrar de todas as sele√ß√µes anteriores.  Portanto, fa√ßa o <code>HexGrid.Search</code> desativar a sele√ß√£o ao redefinir dist√¢ncias.  Como isso tamb√©m desliga a ilumina√ß√£o da c√©lula inicial, ligue-a novamente.  Nesta fase, tamb√©m podemos destacar o ponto final.  Vamos faz√™-la vermelha. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; cells[i].DisableHighlight(); } fromCell.EnableHighlight(Color.blue); toCell.EnableHighlight(Color.red); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/181/01c/5e5/18101c5e578322ea99598cbca70f60a9.png"></div><br>  <i>Pontos finais de um caminho potencial</i> <br><br><h3>  Limitar pesquisa </h3><br>  Nesse ponto, nosso algoritmo de pesquisa ainda calcula as dist√¢ncias para todas as c√©lulas acess√≠veis a partir da c√©lula inicial.  Mas n√£o precisamos mais disso.  Podemos parar assim que encontrarmos a dist√¢ncia final para a c√©lula final.  Ou seja, quando a c√©lula atual √© finita, podemos sair do loop do algoritmo. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier[<span class="hljs-number"><span class="hljs-number">0</span></span>]; frontier.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/424/6e0/d49/4246e0d491a1938dfb1e9b3a00080e42.png"></div><br>  <i>Pare no ponto final</i> <br><br><div class="spoiler">  <b class="spoiler_title">O que acontece se o ponto final n√£o puder ser alcan√ßado?</b> <div class="spoiler_text">  Em seguida, o algoritmo continuar√° funcionando at√© encontrar todas as c√©lulas acess√≠veis.  Sem a possibilidade de uma sa√≠da prematura, ele funcionar√° como o antigo m√©todo <code>FindDistancesTo</code> . </div></div><br><h3>  Exibi√ß√£o de caminho </h3><br>  Podemos encontrar a dist√¢ncia entre o come√ßo e o fim do caminho, mas ainda n√£o sabemos qual ser√° o caminho real.  Para encontr√°-lo, voc√™ precisa acompanhar como cada c√©lula √© alcan√ßada.  Mas como fazer isso? <br><br>  Ao adicionar uma c√©lula √† borda, fazemos isso porque √© uma vizinha da c√©lula atual.  A √∫nica exce√ß√£o √© a c√©lula inicial.  Todas as outras c√©lulas foram alcan√ßadas atrav√©s da c√©lula atual.  Se mantivermos o controle de qual c√©lula cada c√©lula foi alcan√ßada, obtemos uma rede de c√©lulas como resultado.  Mais precisamente, uma rede em forma de √°rvore, cuja raiz √© o ponto de partida.  Podemos us√°-lo para construir o caminho depois de atingir o ponto final. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a71/331/153/a713311534e05f46c6fd22a632100494.png"></div><br>  <i>Rede em √°rvore que descreve os caminhos para o centro</i> <br><br>  Podemos salvar essas informa√ß√µes adicionando um link para outra c√©lula no <code>HexCell</code> .  Como n√£o precisamos serializar esses dados, usamos a propriedade padr√£o para isso. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell PathFrom { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  No <code>HexGrid.Search</code> defina o valor <code>PathFrom</code> do vizinho para a c√©lula atual ao adicion√°-lo √† borda.  Al√©m disso, precisamos alterar esse link quando encontrarmos um caminho mais curto para o vizinho. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; frontier.Add(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { neighbor.Distance = distance; neighbor.PathFrom = current; }</code> </pre> <br>  Tendo atingido o ponto final, podemos visualizar o caminho seguindo esses links de volta √† c√©lula inicial e selecion√°-los. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { current = current.PathFrom; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != fromCell) { current.EnableHighlight(Color.white); current = current.PathFrom; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f89/9cc/8de/f899cc8de04e0c5666a2a05558b28042.png"></div><br>  <i>Caminho encontrado</i> <br><br>  Vale a pena considerar que muitas vezes existem v√°rios caminhos mais curtos.  O encontrado depende da ordem de processamento das c√©lulas.  Alguns caminhos podem parecer bons, outros podem ser ruins, mas nunca h√° um caminho mais curto.  Voltaremos a isso mais tarde. <br><br><h3>  Alterar o in√≠cio da pesquisa </h3><br>  Ap√≥s selecionar o ponto inicial, a altera√ß√£o do ponto final acionar√° uma nova pesquisa.  O mesmo deve acontecer ao escolher uma nova c√©lula inicial.  Para tornar isso poss√≠vel, o <code>HexMapEditor</code> tamb√©m deve se lembrar do ponto final. <br><br><pre> <code class="cs hljs"> HexCell previousCell, searchFromCell, searchToCell;</code> </pre> <br>  Usando esse campo, tamb√©m podemos iniciar uma nova pesquisa ao escolher um novo come√ßo. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell); }</code> </pre> <br>  Al√©m disso, precisamos evitar pontos iguais de in√≠cio e de t√©rmino. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { ‚Ä¶ }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">unitypackage</a> <br><br><h2>  Pesquisa mais inteligente </h2><br>  Embora nosso algoritmo encontre o caminho mais curto, ele passa muito tempo explorando pontos que obviamente n√£o far√£o parte desse caminho.  Pelo menos √© √≥bvio para n√≥s.  O algoritmo n√£o pode olhar para baixo no mapa; n√£o pode ver que uma pesquisa em algumas dire√ß√µes n√£o faz sentido.  Ele prefere seguir as estradas, apesar de estarem na dire√ß√£o oposta ao ponto final.  √â poss√≠vel tornar a pesquisa mais inteligente? <br><br>  No momento, ao escolher a c√©lula a ser processada a seguir, consideramos apenas a dist√¢ncia da c√©lula ao in√≠cio.  Se queremos ser mais inteligentes, tamb√©m devemos considerar a dist√¢ncia at√© o ponto final.  Infelizmente, ainda n√£o o conhecemos.  Mas podemos criar uma estimativa da dist√¢ncia restante.  Adicionar esta estimativa √† dist√¢ncia da c√©lula nos d√° uma compreens√£o do comprimento total do caminho que passa por essa c√©lula.  Em seguida, podemos us√°-lo para priorizar pesquisas em c√©lulas. <br><br><h3>  Heur√≠stica da Pesquisa </h3><br>  Quando usamos estimativas ou suposi√ß√µes em vez de dados exatamente conhecidos, isso √© chamado usando heur√≠sticas de pesquisa.  Essa heur√≠stica representa o melhor palpite da dist√¢ncia restante.  Devemos determinar esse valor para cada c√©lula que estamos procurando, portanto, adicionaremos uma propriedade inteira <code>HexCell</code> .  N√£o precisamos serializ√°-lo, portanto outra propriedade padr√£o ser√° suficiente. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchHeuristic { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Como fazemos uma suposi√ß√£o sobre a dist√¢ncia restante?  No caso mais ideal, teremos uma estrada que leva diretamente ao ponto final.  Nesse caso, a dist√¢ncia √© igual √† dist√¢ncia inalterada entre as coordenadas dessa c√©lula e a c√©lula final.  Vamos tirar proveito disso em nossa heur√≠stica. <br><br>  Como a heur√≠stica n√£o depende de um caminho percorrido anteriormente, √© constante no processo de busca.  Portanto, precisamos calcul√°-lo apenas uma vez quando o <code>HexGrid.Search</code> adicionar uma c√©lula √† borda. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); frontier.Add(neighbor); }</code> </pre> <br><h3>  Prioridade de pesquisa </h3><br>  A partir de agora, determinaremos a prioridade da pesquisa com base na dist√¢ncia da c√©lula mais suas heur√≠sticas.  Vamos adicionar uma propriedade para esse valor no <code>HexCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchPriority { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance + SearchHeuristic; } }</code> </pre> <br>  Para que isso funcione, <code>HexGrid.Search</code> para que ele use essa propriedade para classificar a borda. <br><br><pre> <code class="cs hljs"> frontier.Sort( (x, y) =&gt; x.SearchPriority.CompareTo(y.SearchPriority) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b58/a22/c9a/b58a22c9a65a2088309a46c6cbc2d102.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/0a3/c0a/b440a3c0aa42dc771ba3a7a0948c835f.png"></div><br>  <i>Pesquisa sem heur√≠stica e com heur√≠stica</i> <br><br><h3>  Heur√≠stica v√°lida </h3><br>  Gra√ßas √†s novas prioridades de pesquisa, visitaremos menos c√©lulas como resultado.  No entanto, em um mapa uniforme, o algoritmo ainda processa c√©lulas que est√£o na dire√ß√£o errada.  Isso ocorre porque, por padr√£o, os custos para cada etapa da movimenta√ß√£o s√£o 5 e a heur√≠stica por etapa adiciona apenas 1. Ou seja, a influ√™ncia da heur√≠stica n√£o √© muito forte. <br><br>  Se os custos de movimenta√ß√£o de todas as cartas forem os mesmos, podemos usar os mesmos custos ao determinar a heur√≠stica.  No nosso caso, essa ser√° a heur√≠stica atual multiplicada por 5. Isso reduzir√° significativamente o n√∫mero de c√©lulas processadas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a4/6c7/ac3/9a46c7ac3c0df63797bfda1f143f9409.png"></div><br>  <i>Usando heur√≠stica √ó 5</i> <br><br>  No entanto, se houver estradas no mapa, podemos superestimar a dist√¢ncia restante.  Como resultado, o algoritmo pode cometer erros e criar um caminho que na verdade n√£o √© o mais curto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd2/7bb/dc7/cd27bbdc7043804a8d2a21ac096a6409.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0af/017/2a2/0af0172a264285358f99b0ece93833a3.png"></div><br>  <i>Heur√≠sticas superestimadas e v√°lidas</i> <br><br>  Para garantir que o caminho mais curto seja encontrado, precisamos garantir que nunca superestimamos a dist√¢ncia restante.  Essa abordagem √© chamada heur√≠stica v√°lida.  Como o custo m√≠nimo de movimenta√ß√£o √© 1, n√£o temos escolha a n√£o ser usar os mesmos custos na determina√ß√£o da heur√≠stica. <br><br>  A rigor, √© bastante normal usar custos ainda mais baixos, mas isso s√≥ tornar√° a heur√≠stica mais fraca.  A heur√≠stica m√≠nima poss√≠vel √© zero, o que nos d√° apenas o algoritmo de Dijkstra.  Para heur√≠sticas diferentes de zero, o algoritmo √© chamado A <sup>*</sup> (pronunciado "Uma estrela"). <br><br><div class="spoiler">  <b class="spoiler_title">Por que √© chamado A *?</b> <div class="spoiler_text">  A id√©ia de adicionar heur√≠sticas ao algoritmo de Dijkstra foi proposta pela primeira vez por Niels Nilsson.  Ele nomeou sua vers√£o A1.  Mais tarde, Bertram Rafael apresentou a melhor vers√£o que ele chamou de A2.  Ent√£o, Peter Hart provou que, com uma boa heur√≠stica A2, √© ideal, ou seja, n√£o pode haver uma vers√£o melhor.  Isso o for√ßou a chamar o algoritmo A <sup>*</sup> para mostrar que n√£o poderia ser melhorado, ou seja, A3 ou A4 n√£o apareceria.  Ent√£o, sim, o algoritmo A <sup>*</sup> √© o melhor que podemos obter, mas √© t√£o bom quanto sua heur√≠stica. </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">unitypackage</a> <br><br><h2>  Fila priorit√°ria </h2><br>  Embora A <sup>* seja um</sup> bom algoritmo, nossa implementa√ß√£o n√£o √© t√£o eficaz, porque para armazenar a borda, usamos uma lista que precisa ser classificada em cada itera√ß√£o.  Como mencionado na parte anterior, precisamos de uma fila de prioridade, mas sua implementa√ß√£o padr√£o n√£o existe.  Portanto, vamos criar voc√™ mesmo. <br><br>  Nossa vez deve apoiar a opera√ß√£o de configura√ß√£o e exclus√£o da fila com base na prioridade.  Ele tamb√©m deve suportar a altera√ß√£o da prioridade de uma c√©lula que j√° est√° na fila.  Idealmente, n√≥s o implementamos, minimizando a busca por classifica√ß√£o e mem√≥ria alocada.  Al√©m disso, deve permanecer simples. <br><br><h3>  Crie sua pr√≥pria fila </h3><br>  Crie uma nova classe <code>HexCellPriorityQueue</code> com os m√©todos comuns necess√°rios.  Usamos uma lista simples para rastrear o conte√∫do de uma fila.  Al√©m disso, adicionaremos o m√©todo <code>Clear</code> para limpar a fila para que possa ser usado repetidamente. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellPriorityQueue</span></span> { List&lt;HexCell&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); } }</code> </pre> <br>  Armazenamos as prioridades das c√©lulas nas pr√≥prias c√©lulas.  Ou seja, antes de adicionar uma c√©lula √† fila, sua prioridade deve ser definida.  Mas, no caso de uma mudan√ßa de prioridade, provavelmente ser√° √∫til saber qual era a antiga prioridade.  Ent√£o, vamos adicionar isso a <code>Change</code> como um par√¢metro. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Tamb√©m √© √∫til saber quantas c√©lulas est√£o na fila, ent√£o vamos adicionar a propriedade <code>Count</code> para isso.  Basta usar o campo para o qual executaremos o incremento e decremento correspondente. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); count = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3>  Adicionar √† fila </h3><br>  Quando uma c√©lula √© adicionada √† fila, primeiro vamos usar sua prioridade como um √≠ndice, tratando a lista como uma matriz simples. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; list[priority] = cell; }</code> </pre> <br>  No entanto, isso s√≥ funciona se a lista for longa o suficiente, caso contr√°rio, iremos al√©m das fronteiras.  Voc√™ pode evitar isso adicionando itens vazios √† lista at√© atingir o comprimento necess√°rio.  Esses elementos vazios n√£o fazem refer√™ncia √† c√©lula, para que voc√™ possa cri√°-los adicionando <code>null</code> √† lista. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (priority &gt;= list.Count) { list.Add(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } list[priority] = cell;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e77/000/fec/e77000feca5c0bfdb769062356ca9935.png"></div><br>  <i>Lista com furos</i> <br><br>  Mas √© assim que armazenamos apenas uma c√©lula por prioridade e, provavelmente, haver√° v√°rias.  Para rastrear todas as c√©lulas com a mesma prioridade, precisamos usar outra lista.  Embora possamos usar uma lista real para todas as prioridades, tamb√©m podemos adicionar uma propriedade ao <code>HexCell</code> para <code>HexCell</code> -las.  Isso nos permite criar uma cadeia de c√©lulas chamada lista vinculada. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell NextWithSamePriority { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Para criar uma cadeia, deixe <code>HexCellPriorityQueue.Enqueue</code> for√ßar a c√©lula rec√©m-adicionada a se referir ao valor atual com a mesma prioridade, antes de exclu√≠-lo. <br><br><pre> <code class="cs hljs"> cell.NextWithSamePriority = list[priority]; list[priority] = cell;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45b/082/87c/45b08287cf76c4636d7a673869aa39b5.png"></div><br>  <i>Lista de listas vinculadas</i> <br><br><h3>  Remover da fila </h3><br>  Para obter uma c√©lula de uma fila priorit√°ria, precisamos acessar a lista vinculada no menor √≠ndice n√£o vazio.  Portanto, percorreremos a lista em um loop at√© encontr√°-la.  Se n√£o encontrarmos, a fila est√° vazia e retornamos <code>null</code> . <br><br>  Da cadeia encontrada, podemos retornar qualquer c√©lula, porque todas elas t√™m a mesma prioridade.  A maneira mais f√°cil √© devolver a c√©lula desde o in√≠cio da cadeia. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.Count; i++) { HexCell cell = list[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Para manter o link para a cadeia restante, use a pr√≥xima c√©lula com a mesma prioridade que o novo in√≠cio.  Se houvesse apenas uma c√©lula nesse n√≠vel de prioridade, o elemento se <code>null</code> e ser√° ignorado no futuro. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { list[i] = cell.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; }</code> </pre> <br><h3>  Rastreamento m√≠nimo </h3><br>  Essa abordagem funciona, mas percorre a lista sempre que uma c√©lula √© recebida.  N√£o podemos evitar encontrar o menor √≠ndice n√£o vazio, mas n√£o somos obrigados a come√ßar do zero todas as vezes.  Em vez disso, podemos rastrear a prioridade m√≠nima e iniciar a pesquisa com ela.  Inicialmente, o m√≠nimo √© essencialmente igual ao infinito. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minimum = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); count = <span class="hljs-number"><span class="hljs-number">0</span></span>; minimum = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; }</code> </pre> <br>  Ao adicionar uma c√©lula √† fila, alteramos o m√≠nimo conforme necess√°rio. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (priority &lt; minimum) { minimum = priority; } ‚Ä¶ }</code> </pre> <br>  E ao sair da fila, usamos pelo menos a lista para itera√ß√µes e n√£o come√ßamos do zero. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; minimum &lt; list.Count; minimum++) { HexCell cell = list[minimum]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { list[minimum] = cell.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Isso reduz significativamente a quantidade de tempo necess√°ria para ignorar o loop da lista de prioridades. <br><br><h3>  Alterar prioridades </h3><br>  Ao alterar a prioridade de uma c√©lula, ela deve ser removida da lista vinculada da qual faz parte.  Para fazer isso, precisamos seguir a cadeia at√© encontr√°-la. <br><br>  Vamos come√ßar declarando que o cabe√ßalho da lista de prioridades antiga ser√° a c√©lula atual e tamb√©m rastrearemos a pr√≥xima c√©lula.  Podemos pegar a pr√≥xima c√©lula imediatamente, porque sabemos que h√° pelo menos uma c√©lula nesse √≠ndice. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { HexCell current = list[oldPriority]; HexCell next = current.NextWithSamePriority; }</code> </pre> <br>  Se a c√©lula atual √© uma c√©lula alterada, essa √© a c√©lula principal e podemos cort√°-la como se a tiv√©ssemos retirado da fila. <br><br><pre> <code class="cs hljs"> HexCell current = list[oldPriority]; HexCell next = current.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == cell) { list[oldPriority] = next; }</code> </pre> <br>  Se n√£o for esse o caso, precisamos seguir a cadeia at√© estarmos na c√©lula em frente √† c√©lula alterada.  Ele cont√©m um link para a c√©lula que foi modificada. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == cell) { list[oldPriority] = next; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next != cell) { current = next; next = current.NextWithSamePriority; } }</code> </pre> <br>  Nesse ponto, podemos remover a c√©lula alterada da lista vinculada, ignorando-a. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next != cell) { current = next; next = current.NextWithSamePriority; } current.NextWithSamePriority = cell.NextWithSamePriority;</code> </pre> <br>  Ap√≥s excluir uma c√©lula, √© necess√°rio adicion√°-la novamente para que ela apare√ßa na lista de sua nova prioridade. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Enqueue(cell); }</code> </pre> <br>  O m√©todo <code>Enqueue</code> incrementa o contador, mas, na realidade, n√£o estamos adicionando uma nova c√©lula.  Portanto, para compensar isso, teremos que diminuir o contador. <br><br><pre> <code class="cs hljs"> Enqueue(cell); count -= <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><h3>  Uso da fila </h3><br>  Agora podemos tirar proveito da nossa fila de prioridades no <code>HexGrid</code> .  Isso pode ser feito com uma √∫nica inst√¢ncia, reutiliz√°vel para todas as opera√ß√µes de pesquisa. <br><br><pre> <code class="cs hljs"> HexCellPriorityQueue searchFrontier; ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de iniciar o loop, o m√©todo </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve primeiro ser adicionado √† fila </font></font><code>fromCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e cada itera√ß√£o come√ßa com a sa√≠da da c√©lula da fila. </font><font style="vertical-align: inherit;">Isso substituir√° o c√≥digo de borda antigo.</font></font><br><br><pre> <code class="cs hljs"> WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// List&lt;HexCell&gt; frontier = new List&lt;HexCell&gt;(); fromCell.Distance = 0; // frontier.Add(fromCell); searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { yield return delay; HexCell current = searchFrontier.Dequeue(); // frontier.RemoveAt(0); ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Altere o c√≥digo para adicionar e alterar o vizinho. </font><font style="vertical-align: inherit;">Antes da mudan√ßa, lembraremos da antiga prioridade.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); <span class="hljs-comment"><span class="hljs-comment">// frontier.Add(neighbor); searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al√©m disso, n√£o precisamos mais classificar a borda. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// frontier.Sort( // (x, y) =&gt; x.SearchPriority.CompareTo(y.SearchPriority) // );</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesquisa usando uma fila de prioridade</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como mencionado anteriormente, o caminho mais curto encontrado depende da ordem de processamento das c√©lulas. </font><font style="vertical-align: inherit;">Nossa vez cria uma ordem diferente da ordem da lista classificada, para que possamos obter outras maneiras. </font><font style="vertical-align: inherit;">Como adicionamos e removemos do cabe√ßalho da lista vinculada para cada prioridade, elas s√£o mais como pilhas do que filas. </font><font style="vertical-align: inherit;">As c√©lulas adicionadas por √∫ltimo s√£o processadas primeiro. </font><font style="vertical-align: inherit;">Um efeito colateral dessa abordagem √© que o algoritmo √© propenso a ziguezague. </font><font style="vertical-align: inherit;">Portanto, a probabilidade de caminhos em zigue-zague tamb√©m aumenta. </font><font style="vertical-align: inherit;">Felizmente, esses caminhos geralmente parecem melhores, ent√£o esse efeito colateral √© a nosso favor.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/0a3/c0a/b440a3c0aa42dc771ba3a7a0948c835f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/908/1e9/cc5/9081e9cc5b0ea1d6f4309b6221eab1ac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista e fila classificadas com prioridade para </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 17: movimento limitado </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Encontramos formas de movimento passo a passo. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exiba imediatamente o caminho. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criamos uma pesquisa mais eficaz. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√≥s visualizamos apenas o caminho. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nesta parte, dividiremos o movimento em movimentos e aceleraremos a busca o m√°ximo poss√≠vel. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4d/572/9cc/c4d5729ccbf9cc994b7c8328950e6f5b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viaje de v√°rios movimentos</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimento passo a passo </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jogos de estrat√©gia que usam redes hexagonais s√£o quase sempre baseados em turnos. </font><font style="vertical-align: inherit;">As unidades que se deslocam no mapa t√™m uma velocidade limitada, o que limita a dist√¢ncia percorrida em um turno.</font></font><br><br><h3>  Velocidade </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para fornecer suporte a movimentos limitados, adicionamos </font></font><code>HexGrid.FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inserimos o par√¢metro inteiro </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Determina a amplitude de movimento de um movimento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(fromCell, toCell, speed)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferentes tipos de unidades no jogo usam velocidades diferentes. </font><font style="vertical-align: inherit;">A cavalaria √© r√°pida, a infantaria √© lenta e assim por diante. </font><font style="vertical-align: inherit;">Ainda n√£o temos unidades, portanto, por enquanto, usaremos uma velocidade constante. </font><font style="vertical-align: inherit;">Vamos pegar um valor de 24. Esse √© um valor razoavelmente grande, n√£o divis√≠vel por 5 (o custo padr√£o da mudan√ßa). </font><font style="vertical-align: inherit;">Adicionar um argumento para </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma velocidade constante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimentos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m de rastrear o custo total da movimenta√ß√£o ao longo do caminho, agora tamb√©m precisamos saber quantos movimentos ser√£o necess√°rios para mov√™-lo. Mas n√£o precisamos armazenar essas informa√ß√µes em cada c√©lula. Pode ser obtido dividindo a dist√¢ncia percorrida pela velocidade. Como esses n√∫meros s√£o inteiros, usaremos a divis√£o inteira. Ou seja, as dist√¢ncias totais n√£o superiores a 24 correspondem ao curso 0. Isso significa que todo o caminho pode ser conclu√≠do no curso atual. Se o ponto final estiver a uma dist√¢ncia de 30, esse dever√° ser o turno 1. Para chegar ao ponto final, a unidade ter√° que gastar todo o seu movimento no turno atual e em parte do pr√≥ximo turno. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos determinar o curso da c√©lula atual e todos os seus vizinhos dentro</font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O curso da c√©lula atual pode ser calculado apenas uma vez, logo antes de dar a volta no ciclo vizinho. </font><font style="vertical-align: inherit;">A jogada do vizinho pode ser determinada assim que encontrarmos a dist√¢ncia para ele.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentTurn = current.Distance / speed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Walled != neighbor.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = distance / speed; ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimento perdido </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o movimento do vizinho for maior que o movimento atual, cruzamos o limite do movimento. </font><font style="vertical-align: inherit;">Se o movimento necess√°rio para alcan√ßar um vizinho foi 1, tudo est√° bem. </font><font style="vertical-align: inherit;">Mas se a mudan√ßa para a pr√≥xima c√©lula for mais cara, tudo ficar√° mais complicado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponha que movamos ao longo de um mapa homog√™neo, ou seja, para entrar em cada c√©lula, voc√™ precisa de 5 unidades de movimento. </font><font style="vertical-align: inherit;">Nossa velocidade √© 24. Ap√≥s quatro etapas, gastamos 20 unidades de nosso estoque de movimento e restam 4. Na pr√≥xima etapa, s√£o necess√°rias 5 unidades novamente, ou seja, uma a mais do que as dispon√≠veis. </font><font style="vertical-align: inherit;">O que precisamos fazer nesta fase?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem duas abordagens para essa situa√ß√£o. A primeira √© permitir que a unidade entre na quinta c√©lula no turno atual, mesmo que n√£o tenhamos movimento suficiente. O segundo √© proibir o movimento durante o movimento atual, ou seja, os pontos de movimento restantes n√£o podem ser usados ‚Äã‚Äãe eles ser√£o perdidos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A escolha da op√ß√£o depende do jogo. Em geral, a primeira abordagem √© mais apropriada para jogos nos quais as unidades podem se mover apenas alguns passos por turno, por exemplo, para jogos da s√©rie Civilization. Isso garante que as unidades sempre possam mover pelo menos uma c√©lula por turno. Se as unidades puderem mover muitas c√©lulas por turno, como no Age of Wonders ou no Battle for Wesnoth, a segunda op√ß√£o ser√° melhor.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como usamos a velocidade 24, vamos escolher a segunda abordagem. </font><font style="vertical-align: inherit;">Para que ele comece a funcionar, precisamos isolar os custos de entrar na pr√≥xima c√©lula antes de adicion√°-la √† dist√¢ncia atual.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// int distance = current.Distance; int moveCost; if (current.HasRoadThroughEdge(d)) { moveCost = 1; } else if (current.Walled != neighbor.Walled) { continue; } else { moveCost = edgeType == HexEdgeType.Flat ? 5 : 10; moveCost += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; } int distance = current.Distance + moveCost; int turn = distance / speed;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se, como resultado, cruzarmos a borda do movimento, primeiro usaremos todos os pontos de movimento do movimento atual. </font><font style="vertical-align: inherit;">Podemos fazer isso simplesmente multiplicando o movimento pela velocidade. </font><font style="vertical-align: inherit;">Depois disso, adicionamos o custo da mudan√ßa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + moveCost; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = distance / speed; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (turn &gt; currentTurn) { distance = turn * speed + moveCost; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, concluiremos o primeiro movimento na quarta c√©lula com 4 pontos de movimento n√£o utilizados. </font><font style="vertical-align: inherit;">Esses pontos perdidos s√£o adicionados aos custos da quinta c√©lula, de modo que sua dist√¢ncia se torna 29, e n√£o 25. Como resultado, as dist√¢ncias s√£o maiores do que antes. </font><font style="vertical-align: inherit;">Por exemplo, a d√©cima c√©lula tinha uma dist√¢ncia de 50. Mas agora, para entrar nela, precisamos cruzar as fronteiras de dois movimentos, perdendo 8 pontos de movimento, ou seja, a dist√¢ncia at√© agora se torna 58.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff3/7f4/1f1/ff37f41f11c85f7f759367fd2b33334d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais do que o esperado</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como os pontos de movimento n√£o utilizados s√£o adicionados √†s dist√¢ncias das c√©lulas, eles s√£o levados em considera√ß√£o na determina√ß√£o do caminho mais curto. </font><font style="vertical-align: inherit;">A maneira mais eficaz √© desperdi√ßar o m√≠nimo de pontos poss√≠vel. </font><font style="vertical-align: inherit;">Portanto, em velocidades diferentes, podemos obter caminhos diferentes.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mostrando movimentos em vez de dist√¢ncias </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando jogamos o jogo, n√£o estamos muito interessados ‚Äã‚Äãnos valores de dist√¢ncia usados ‚Äã‚Äãpara encontrar o caminho mais curto. </font><font style="vertical-align: inherit;">Estamos interessados ‚Äã‚Äãno n√∫mero de movimentos necess√°rios para alcan√ßar o ponto final. </font><font style="vertical-align: inherit;">Portanto, em vez de dist√¢ncias, vamos exibir os movimentos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, livre-se da </font></font><code>UpdateDistanceLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">liga√ß√£o dele </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Distance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-comment"><span class="hljs-comment">// UpdateDistanceLabel(); } } ‚Ä¶ // void UpdateDistanceLabel () { // UnityEngine.UI.Text label = uiRect.GetComponent&lt;Text&gt;(); // label.text = distance == int.MaxValue ? "" : distance.ToString(); // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em vez disso, adicionaremos ao </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo geral </font></font><code>SetLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que recebe uma string arbitr√°ria.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { UnityEngine.UI.Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = text; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos esse novo m√©todo na </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limpeza de c√©lulas. </font><font style="vertical-align: inherit;">Para ocultar c√©lulas, basta atribu√≠-las </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; cells[i].SetLabel(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); cells[i].DisableHighlight(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, atribu√≠mos √† marca do vizinho o valor de sua jogada. </font><font style="vertical-align: inherit;">Depois disso, poderemos ver quantos movimentos adicionais ser√£o necess√°rios para percorrer todo o caminho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d4/6d6/97d/0d46d697d7c08be6d3381ce030541e4d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O n√∫mero de movimentos necess√°rios para percorrer o caminho do </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caminhos instant√¢neos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, quando jogamos o jogo, n√£o nos importamos como o algoritmo de pesquisa de caminho encontra o caminho. </font><font style="vertical-align: inherit;">Queremos ver o caminho solicitado imediatamente. </font><font style="vertical-align: inherit;">No momento, podemos ter certeza de que o algoritmo funciona, ent√£o vamos nos livrar da visualiza√ß√£o de pesquisa.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sem corutin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para uma passagem lenta pelo algoritmo, usamos corutin. </font><font style="vertical-align: inherit;">Mais disto que precisamos, ent√£o se livrar da chamada </font></font><code>StartCoroutine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>StopAllCoroutines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em vez disso, simplesmente o invocamos </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como um m√©todo regular.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// StopAllCoroutines(); ‚Ä¶ } public void FindPath (HexCell fromCell, HexCell toCell, int speed) { // StopAllCoroutines(); // StartCoroutine(Search(fromCell, toCell, speed)); Search(fromCell, toCell, speed); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como n√£o a usamos mais </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como corotina, ela n√£o precisa de rendimento, portanto, nos livraremos desse operador. </font><font style="vertical-align: inherit;">Isso significa que tamb√©m removeremos a declara√ß√£o </font></font><code>WaitForSeconds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e alteraremos o tipo de retorno do m√©todo para </font></font><code>void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// WaitForSeconds delay = new WaitForSeconds(1 / 60f); fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { // yield return delay; HexCell current = searchFrontier.Dequeue(); ‚Ä¶ } }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultados instant√¢neos</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Defini√ß√£o do tempo de pesquisa </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos encontrar os caminhos instantaneamente, mas com que rapidez eles s√£o calculados? Caminhos curtos aparecem quase imediatamente, mas caminhos longos em mapas grandes podem parecer um pouco lentos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos medir quanto tempo leva para encontrar e exibir o caminho. Podemos usar um criador de perfil para determinar o tempo de pesquisa, mas isso √© um pouco demais e cria custos adicionais. Vamos usar em vez disso </font></font><code>Stopwatch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que est√° no espa√ßo para nome </font></font><code>System.Diagnostics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Como o usamos apenas temporariamente, n√£o adicionarei a constru√ß√£o </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ao in√≠cio do script. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logo antes da pesquisa, crie um novo cron√¥metro e inicie-o. Ap√≥s a conclus√£o da pesquisa, pare o cron√¥metro e exiba o tempo decorrido no console.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { System.Diagnostics.Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Diagnostics.Stopwatch(); sw.Start(); Search(fromCell, toCell, speed); sw.Stop(); Debug.Log(sw.ElapsedMilliseconds); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos escolher o pior caso para o nosso algoritmo - uma pesquisa do canto inferior esquerdo ao canto superior direito de um mapa grande. O pior √© um mapa uniforme, porque o algoritmo ter√° que processar todas as 4.800 c√©lulas do mapa.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce1/c03/524/ce1c0352479d7d8cddcff0b014291662.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesquise no pior dos casos O tempo</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gasto na pesquisa pode ser diferente, porque o editor do Unity n√£o √© o √∫nico processo em execu√ß√£o na sua m√°quina. Portanto, teste-o v√°rias vezes para entender a dura√ß√£o m√©dia. No meu caso, a pesquisa leva cerca de 45 milissegundos. Isso n√£o √© muito e corresponde a 22,22 caminhos por segundo; denote isso como 22 pps (caminhos por segundo). Isso significa que a taxa de quadros do jogo tamb√©m diminuir√° em um m√°ximo de 22 qps nesse quadro quando esse caminho for calculado. E isso sem levar em considera√ß√£o todos os outros trabalhos, por exemplo, renderizar o pr√≥prio quadro. Ou seja, temos uma diminui√ß√£o bastante grande na taxa de quadros, ela cair√° para 20 fps.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao executar esse teste de desempenho, √© necess√°rio considerar que o desempenho do editor do Unity n√£o ser√° t√£o alto quanto o desempenho do aplicativo finalizado. </font><font style="vertical-align: inherit;">Se eu realizar o mesmo teste com a montagem, em m√©dia, ser√£o necess√°rios apenas 15 ms. </font><font style="vertical-align: inherit;">S√£o 66 pps, o que √© muito melhor. </font><font style="vertical-align: inherit;">No entanto, essa ainda √© uma grande parte dos recursos alocados por quadro, portanto a taxa de quadros ficar√° menor que 60 fps.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Onde posso ver o log de depura√ß√£o do assembly?</font></font></b> <div class="spoiler_text">  Unity     ,    .     .  ,       ,   Unity  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Log Files</a> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pesquise apenas se necess√°rio. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos fazer uma otimiza√ß√£o simples - realizar uma pesquisa somente quando necess√°rio. </font><font style="vertical-align: inherit;">Enquanto iniciamos uma nova pesquisa em cada quadro em que o bot√£o do mouse √© pressionado. </font><font style="vertical-align: inherit;">Portanto, a taxa de quadros ser√° constantemente subestimada ao arrastar e soltar. </font><font style="vertical-align: inherit;">Podemos evitar isso iniciando uma nova pesquisa </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apenas quando estamos realmente lidando com um novo ponto de extremidade. </font><font style="vertical-align: inherit;">Caso contr√°rio, o caminho vis√≠vel atual ainda √© v√°lido.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell != currentCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mostrar r√≥tulos apenas para o caminho </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exibir marcas de viagem √© uma opera√ß√£o bastante cara, principalmente porque usamos uma abordagem n√£o otimizada. </font><font style="vertical-align: inherit;">Executar esta opera√ß√£o para todas as c√©lulas definitivamente atrasar√° a execu√ß√£o. </font><font style="vertical-align: inherit;">Ent√£o, vamos pular a marca√ß√£o </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; <span class="hljs-comment"><span class="hljs-comment">// neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; // neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos ver essas informa√ß√µes apenas para o caminho encontrado. </font><font style="vertical-align: inherit;">Portanto, depois de atingir o ponto final, calcularemos o curso e definiremos os r√≥tulos apenas das c√©lulas que est√£o a caminho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { current = current.PathFrom; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != fromCell) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/090/f8f/2f1/090f8f2f121b6fafdb7b95d48fb41c8d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exibindo r√≥tulos apenas para c√©lulas de caminho</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora, inclu√≠mos apenas r√≥tulos de c√©lulas entre o in√≠cio e o fim. </font><font style="vertical-align: inherit;">Mas o ponto final √© a coisa mais importante, tamb√©m devemos definir um r√≥tulo para ele. </font><font style="vertical-align: inherit;">Voc√™ pode fazer isso iniciando o ciclo do caminho a partir da c√©lula de destino e n√£o da c√©lula na frente dela. </font><font style="vertical-align: inherit;">Nesse caso, a ilumina√ß√£o do ponto final do vermelho mudar√° para branco, ent√£o removeremos a luz de fundo do ciclo.</font></font><br><br><pre> <code class="cs hljs"> fromCell.EnableHighlight(Color.blue); <span class="hljs-comment"><span class="hljs-comment">// toCell.EnableHighlight(Color.red); fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { HexCell current = searchFrontier.Dequeue(); if (current == toCell) { // current = current.PathFrom; while (current != fromCell) { int turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } toCell.EnableHighlight(Color.red); break; } ‚Ä¶ }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dda/273/ea9/dda273ea9b4aa1767db16c19abf512cd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As informa√ß√µes de progresso s√£o mais importantes para o terminal.Depois</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dessas altera√ß√µes, o pior caso √© reduzido para 23 milissegundos no editor e para 6 milissegundos na montagem finalizada. </font><font style="vertical-align: inherit;">Estes s√£o 43 pps e 166 pps - muito melhor. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A pesquisa mais inteligente </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na parte anterior, tornamos o procedimento de pesquisa mais inteligente, implementando o algoritmo A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">No entanto, na realidade, ainda n√£o estamos realizando a pesquisa da maneira mais ideal. </font><font style="vertical-align: inherit;">Em cada itera√ß√£o, calculamos as dist√¢ncias da c√©lula atual para todos os seus vizinhos. </font><font style="vertical-align: inherit;">Isso √© verdade para c√©lulas que ainda n√£o fazem parte da borda de pesquisa. </font><font style="vertical-align: inherit;">Mas as c√©lulas que j√° foram removidas da borda n√£o precisam mais ser consideradas, porque j√° encontramos o caminho mais curto para essas c√©lulas. </font><font style="vertical-align: inherit;">A implementa√ß√£o correta de A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ignora essas c√©lulas, para que possamos fazer o mesmo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fase de Pesquisa Celular </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como sabemos se uma c√©lula j√° saiu da fronteira? </font><font style="vertical-align: inherit;">Enquanto n√£o podemos determinar isso. </font><font style="vertical-align: inherit;">Portanto, voc√™ precisa acompanhar em que fase da pesquisa a c√©lula est√°. </font><font style="vertical-align: inherit;">Ela ainda n√£o estava na fronteira, ou est√° agora ou est√° no exterior. </font><font style="vertical-align: inherit;">Podemos acompanhar isso adicionando a uma </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriedade inteira simples.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchPhase { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por exemplo, 0 significa que as c√©lulas ainda n√£o atingiram, 1 - que a c√©lula est√° na borda agora e 2 - que j√° foi removida da borda. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atingindo a fronteira </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">podemos redefinir todas as c√©lulas para 0 e sempre usar 1 para a borda. </font><font style="vertical-align: inherit;">Ou podemos aumentar o n√∫mero de bordas a cada nova pesquisa. </font><font style="vertical-align: inherit;">Gra√ßas a isso, n√£o teremos que lidar com o despejo de c√©lulas se aumentarmos o n√∫mero de fronteiras a cada duas vezes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> searchFrontierPhase; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora precisamos definir a fase da pesquisa de c√©lulas ao adicion√°-las √† borda. </font><font style="vertical-align: inherit;">O processo come√ßa com uma c√©lula inicial, que √© adicionada √† borda.</font></font><br><br><pre> <code class="cs hljs"> fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E tamb√©m toda vez que adicionamos um vizinho √† fronteira. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verifica√ß√£o de fronteira </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© agora, para verificar se a c√©lula ainda n√£o foi adicionada √† borda, usamos uma dist√¢ncia igual a </font></font><code>int.MaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Agora podemos comparar a fase da pesquisa de c√©lulas com a borda atual.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// if (neighbor.Distance == int.MaxValue) { if (neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isso significa que n√£o precisamos mais redefinir as dist√¢ncias das c√©lulas antes de pesquisar, ou seja, teremos que fazer menos trabalho, o que √© bom. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// cells[i].Distance = int.MaxValue; cells[i].SetLabel(null); cells[i].DisableHighlight(); }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saindo da fronteira </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando uma c√©lula √© removida do limite, denotamos isso por um aumento em sua fase de pesquisa. </font><font style="vertical-align: inherit;">Isso a coloca al√©m da fronteira atual e antes da pr√≥xima.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora podemos pular c√©lulas removidas da borda, evitando c√°lculos in√∫teis e compara√ß√µes de dist√¢ncias. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste ponto, nosso algoritmo ainda produz os mesmos resultados, mas com mais efici√™ncia. </font><font style="vertical-align: inherit;">Na minha m√°quina, a pesquisa de pior caso leva 20 ms no editor e 5 ms na montagem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m podemos calcular quantas vezes a c√©lula foi processada pelo algoritmo, aumentando o contador ao calcular a dist√¢ncia at√© a c√©lula. </font><font style="vertical-align: inherit;">Anteriormente, nosso algoritmo, na pior das hip√≥teses, calculava 28.239 dist√¢ncias. </font><font style="vertical-align: inherit;">No algoritmo A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pronto, </font><font style="vertical-align: inherit;">calculamos suas 14.120 dist√¢ncias. </font><font style="vertical-align: inherit;">A quantidade diminuiu 50%. </font><font style="vertical-align: inherit;">O grau de impacto desses indicadores na produtividade depende dos custos no c√°lculo do custo da mudan√ßa. </font><font style="vertical-align: inherit;">No nosso caso, n√£o h√° muito trabalho aqui, portanto, a melhoria na montagem n√£o √© muito grande, mas √© muito percept√≠vel no editor. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abrindo caminho </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao iniciar uma nova pesquisa, primeiro precisamos limpar a visualiza√ß√£o do caminho anterior. </font><font style="vertical-align: inherit;">Enquanto fazemos isso, desative a sele√ß√£o e remova os r√≥tulos de cada c√©lula da grade. </font><font style="vertical-align: inherit;">Esta √© uma abordagem muito dif√≠cil. </font><font style="vertical-align: inherit;">Idealmente, precisamos descartar apenas as c√©lulas que faziam parte do caminho anterior.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Somente Pesquisa </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos come√ßar removendo completamente o c√≥digo de visualiza√ß√£o de </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ele s√≥ precisa realizar uma pesquisa de caminho e n√£o precisa saber o que faremos com essas informa√ß√µes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; cells.Length; i++) { // cells[i].SetLabel(null); // cells[i].DisableHighlight(); // } // fromCell.EnableHighlight(Color.blue); fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += 1; if (current == toCell) { // while (current != fromCell) { // int turn = current.Distance / speed; // current.SetLabel(turn.ToString()); // current.EnableHighlight(Color.white); // current = current.PathFrom; // } // toCell.EnableHighlight(Color.red); // break; } ‚Ä¶ } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para relatar que </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encontramos uma maneira, retornaremos booleano.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lembre-se do caminho </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando o caminho √© encontrado, precisamos nos lembrar dele. </font><font style="vertical-align: inherit;">Gra√ßas a isso, poderemos limp√°-lo no futuro. </font><font style="vertical-align: inherit;">Portanto, rastrearemos os pontos finais e se existe um caminho entre eles.</font></font><br><br><pre> <code class="cs hljs"> HexCell currentPathFrom, currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> currentPathExists; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { System.Diagnostics.Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Diagnostics.Stopwatch(); sw.Start(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); sw.Stop(); Debug.Log(sw.ElapsedMilliseconds); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exibir o caminho novamente </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar os dados de pesquisa que gravamos para visualizar o caminho novamente. </font><font style="vertical-align: inherit;">Vamos criar um novo m√©todo para isso </font></font><code>ShowPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ele percorrer√° o ciclo do final ao in√≠cio do caminho, destacando as c√©lulas e atribuindo um valor de tra√ßado aos seus r√≥tulos. </font><font style="vertical-align: inherit;">Para fazer isso, precisamos saber a velocidade, portanto, torne-o um par√¢metro. </font><font style="vertical-align: inherit;">Se n√£o temos um caminho, o m√©todo simplesmente seleciona os pontos finais.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } } currentPathFrom.EnableHighlight(Color.blue); currentPathTo.EnableHighlight(Color.red); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chame esse m√©todo </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ap√≥s a pesquisa.</font></font><br><br><pre> <code class="cs hljs"> currentPathExists = Search(fromCell, toCell, speed); ShowPath(speed);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Varrer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≥s vemos o caminho novamente, mas agora ele n√£o est√° se afastando. </font><font style="vertical-align: inherit;">Para limp√°-lo, crie um m√©todo </font></font><code>ClearPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">De fato, √© uma c√≥pia </font></font><code>ShowPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, exceto que desativa a sele√ß√£o e os r√≥tulos, mas n√£o os inclui. </font><font style="vertical-align: inherit;">Feito isso, ele deve limpar os dados do caminho gravado que n√£o s√£o mais v√°lidos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { current.SetLabel(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); current.DisableHighlight(); current = current.PathFrom; } current.DisableHighlight(); currentPathExists = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } currentPathFrom = currentPathTo = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando esse m√©todo, podemos limpar a visualiza√ß√£o do caminho antigo, visitando apenas as c√©lulas necess√°rias; o tamanho do mapa n√£o √© mais importante. </font><font style="vertical-align: inherit;">Vamos cham√°-lo </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antes de iniciar uma nova pesquisa.</font></font><br><br><pre> <code class="cs hljs"> sw.Start(); ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { ShowPath(speed); } sw.Stop();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al√©m disso, limparemos o caminho ao criar um novo mapa. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ ClearPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunks != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { Destroy(chunks[i].gameObject); } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E tamb√©m antes de carregar outro cart√£o. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A visualiza√ß√£o do caminho √© limpa novamente, como antes dessa altera√ß√£o. </font><font style="vertical-align: inherit;">Mas agora estamos usando uma abordagem mais eficiente e, no pior caso da pesquisa, o tempo diminuiu para 14 milissegundos. </font><font style="vertical-align: inherit;">Bastante melhoria s√©ria apenas devido √† limpeza mais inteligente. </font><font style="vertical-align: inherit;">O tempo de montagem diminuiu para 3 ms, ou seja, 333 pps. </font><font style="vertical-align: inherit;">Gra√ßas a isso, a pesquisa de caminhos √© exatamente aplic√°vel em tempo real. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que fizemos uma pesquisa r√°pida por caminhos, podemos remover o c√≥digo de depura√ß√£o tempor√°rio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch(); // sw.Start(); ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); ShowPath(speed); // sw.Stop(); // Debug.Log(sw.ElapsedMilliseconds); }</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 18: unidades </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colocamos os esquadr√µes no mapa. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salve e carregue esquadr√µes. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√≥s encontramos caminhos para as tropas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√≥s movemos as unidades. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora que descobrimos como procurar um caminho, vamos colocar os esquadr√µes no mapa. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/881/316/9bb/8813169bb32795f4ea1d0c4696fddde2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chegaram refor√ßos</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criando esquadr√µes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© agora, lidamos apenas com c√©lulas e seus objetos fixos. </font><font style="vertical-align: inherit;">As unidades diferem deles por serem m√≥veis. </font><font style="vertical-align: inherit;">Um esquadr√£o pode significar qualquer coisa de qualquer escala, de uma pessoa ou ve√≠culo a um ex√©rcito inteiro. </font><font style="vertical-align: inherit;">Neste tutorial, nos restringimos a um tipo simples e generalizado de unidade. </font><font style="vertical-align: inherit;">Depois disso, passaremos a apoiar combina√ß√µes de v√°rios tipos de unidades.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esquadr√£o de pr√©-fabricados </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para trabalhar com esquadr√µes, crie um novo tipo de componente </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por enquanto, vamos come√ßar com um vazio </font></font><code>MonoBehaviour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, posteriormente, adicionar funcionalidade a ele.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crie um objeto de jogo vazio com este componente, que deve se tornar uma pr√©-fabricada. </font><font style="vertical-align: inherit;">Este ser√° o objeto raiz do esquadr√£o.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8de/c85/2f2/8dec852f21d7aaa2c3002dc119d890ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esquadr√£o de pr√©-fabricados. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um modelo 3D simbolizando o desapego como um objeto filho. </font><font style="vertical-align: inherit;">Usei um cubo em escala simples para o qual criei material azul. </font><font style="vertical-align: inherit;">O objeto raiz determina o n√≠vel do solo do desapego; portanto, substitu√≠mos o elemento filho.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be6/157/db2/be6157db233e9e6fc0a40eae6747c731.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be6/157/db2/be6157db233e9e6fc0a40eae6747c731.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elemento do cubo filho</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicione um colisor ao esquadr√£o para facilitar a sele√ß√£o no futuro. </font><font style="vertical-align: inherit;">O colisor do cubo padr√£o √© bastante adequado para n√≥s, basta fazer o colisor caber em uma c√©lula.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criando inst√¢ncias de esquadr√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ainda n√£o temos jogabilidade, a cria√ß√£o de unidades ocorre no modo de edi√ß√£o. </font><font style="vertical-align: inherit;">Portanto, isso deve ser resolvido </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para fazer isso, ele precisa de uma pr√©-fabricada, ent√£o adicione um campo </font></font><code>HexUnit unitPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e conecte-o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit unitPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85c/b00/4bd/85cb004bd7bae06a6feaa8c93f144de9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conectando a pr√©-fabricada</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ao criar unidades, as colocaremos na c√©lula abaixo do cursor. </font><font style="vertical-align: inherit;">Existe </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um c√≥digo para encontrar essa c√©lula ao editar um terreno. </font><font style="vertical-align: inherit;">Agora tamb√©m precisamos dele para os esquadr√µes, para que movamos o c√≥digo correspondente para um m√©todo separado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellUnderCursor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexGrid.GetCell(hit.point); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos usar esse m√©todo para </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplific√°-lo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); // RaycastHit hit; // if (Physics.Raycast(inputRay, out hit)) { // HexCell currentCell = hexGrid.GetCell(hit.point); HexCell currentCell = GetCellUnderCursor(); if (currentCell) { ‚Ä¶ } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, adicione um novo m√©todo </font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que tamb√©m use </font></font><code>GetCellUnderCursor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se houver uma c√©lula, criaremos um novo esquadr√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { Instantiate(unitPrefab); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para manter a hierarquia limpa, vamos usar a grade como pai de todos os objetos do jogo nos esquadr√µes. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maneira mais f√°cil de adicionar </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suporte √† cria√ß√£o de unidades √© pressionando uma tecla. </font><font style="vertical-align: inherit;">Altere o m√©todo </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que ele chame </font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando voc√™ pressiona a tecla U. Assim como em c </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, isso deve acontecer se o cursor n√£o estiver sobre o elemento GUI. </font><font style="vertical-align: inherit;">Primeiro, verificaremos se devemos editar o mapa e, se n√£o, verificaremos se devemos adicionar um esquadr√£o. </font><font style="vertical-align: inherit;">Se sim, ent√£o ligue </font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// if ( // Input.GetMouseButton(0) &amp;&amp; // !EventSystem.current.IsPointerOverGameObject() // ) { // HandleInput(); // } // else { // previousCell = null; // } if (!EventSystem.current.IsPointerOverGameObject()) { if (Input.GetMouseButton(0)) { HandleInput(); return; } if (Input.GetKeyDown(KeyCode.U)) { CreateUnit(); return; } } previousCell = null; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55e/b48/c86/55eb48c8601711d74720f29cfba7a4f3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inst√¢ncia criada do esquadr√£o</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coloca√ß√£o de tropas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos criar unidades, mas elas aparecem na origem do mapa. </font><font style="vertical-align: inherit;">Precisamos coloc√°-los no lugar certo. </font><font style="vertical-align: inherit;">Para isso, √© necess√°rio que as tropas estejam cientes de sua posi√ß√£o. </font><font style="vertical-align: inherit;">Portanto, adicionamos √† </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriedade </font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">denotando a c√©lula que eles ocupam. </font><font style="vertical-align: inherit;">Ao definir a propriedade, alteraremos a posi√ß√£o do esquadr√£o para que ele corresponda √† posi√ß√£o da c√©lula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } } HexCell location;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora devo </font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atribuir a posi√ß√£o da c√©lula de esquadr√£o sob o cursor. </font><font style="vertical-align: inherit;">Ent√£o as unidades estar√£o onde deveriam.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = cell; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf6/71f/92d/bf671f92d2e587bebec2bf08efafadbc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esquadr√µes no mapa</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Orienta√ß√£o da unidade </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© agora, todas as unidades t√™m a mesma orienta√ß√£o, o que parece pouco natural. </font><font style="vertical-align: inherit;">Para apimentar as coisas, aumentando a </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriedade </font></font><code>Orientation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este √© um valor flutuante que indica a rota√ß√£o do esquadr√£o ao longo do eixo Y em graus. </font><font style="vertical-align: inherit;">Ao configur√°-lo, alteraremos a rota√ß√£o do pr√≥prio objeto do jogo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Orientation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> orientation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { orientation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em </font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atribuir uma rota√ß√£o aleat√≥ria de 0 a 360 graus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = cell; unit.Orientation = Random.Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74f/c4a/8c9/74fc4a8c943830b4abd6049889b41843.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferentes orienta√ß√µes da unidade</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um esquadr√£o por c√©lula </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As unidades ficam bem se n√£o forem criadas em uma c√©lula. </font><font style="vertical-align: inherit;">Nesse caso, temos um conjunto de cubos de apar√™ncia estranha.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f8/a68/4b6/9f8a684b6425be20e23ac65901bf5888.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unidades sobrepostas</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alguns jogos permitem a coloca√ß√£o de v√°rias unidades em um s√≥ lugar, outros n√£o. </font><font style="vertical-align: inherit;">Como √© mais f√°cil trabalhar com um esquadr√£o por c√©lula, escolherei essa op√ß√£o. </font><font style="vertical-align: inherit;">Isso significa que devemos criar um novo esquadr√£o apenas quando a c√©lula atual n√£o estiver ocupada. </font><font style="vertical-align: inherit;">Para que voc√™ possa descobrir, adicione √† </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriedade padr√£o </font></font><code>Unit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit Unit { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos essa propriedade </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para informar √† c√©lula se a unidade est√° nela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora ele </font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode verificar se a c√©lula atual est√° livre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; !cell.Unit) { HexUnit unit = Instantiate(unitPrefab); unit.Location = cell; unit.Orientation = Random.Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Editando c√©lulas ocupadas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicialmente, as unidades s√£o colocadas corretamente, mas tudo pode mudar se suas c√©lulas forem editadas posteriormente. </font><font style="vertical-align: inherit;">Se a altura da c√©lula mudar, a unidade que a ocupar ficar√° pendurada acima dela ou mergulhar√° nela.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27b/b7d/1c1/27bb7d1c120bc1546dfa0fd42823d66c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esquadr√µes pendurados e afogados</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A solu√ß√£o √© verificar a posi√ß√£o do esquadr√£o depois de fazer altera√ß√µes. </font><font style="vertical-align: inherit;">Para fazer isso, adicione o m√©todo a </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">At√© agora, estamos interessados ‚Äã‚Äãapenas na posi√ß√£o da equipe, ent√£o pergunte novamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateLocation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localPosition = location.Position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Devemos coordenar a posi√ß√£o do desapego ao atualizar a c√©lula, o que acontece quando os m√©todos </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objetos s√£o </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chamados. </font><font style="vertical-align: inherit;">Obviamente, isso √© necess√°rio apenas quando realmente existe um desapego na c√©lula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Unit) { Unit.ValidateLocation(); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshSelfOnly</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Unit) { Unit.ValidateLocation(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Remo√ß√£o de esquadr√µes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m de criar unidades, seria √∫til destru√≠-las. </font><font style="vertical-align: inherit;">Portanto, n√≥s adicionamos o </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ele deve verificar se h√° um desapego na c√©lula sob o cursor e, se houver, destruir o objeto de jogo do desapego.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { Destroy(cell.Unit.gameObject); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que, para chegar ao esquadr√£o, passamos pela c√©lula. </font><font style="vertical-align: inherit;">Para interagir com o esquadr√£o, basta passar o mouse sobre sua c√©lula. </font><font style="vertical-align: inherit;">Portanto, para que isso funcione, o esquadr√£o n√£o precisa ter um colisor. </font><font style="vertical-align: inherit;">No entanto, adicionar um colisor facilita a sele√ß√£o porque bloqueia os raios que, de outra forma, colidiriam com a c√©lula atr√°s do esquadr√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usar uma combina√ß√£o de Shift + U esquerdo </font><font style="vertical-align: inherit;">para destruir o esquadr√£o </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.U)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { DestroyUnit(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CreateUnit(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No caso em que criamos e destru√≠mos v√°rias unidades, tenha cuidado e limpe a propriedade ao remover a unidade. </font><font style="vertical-align: inherit;">Ou seja, limpamos explicitamente o link da c√©lula para o esquadr√£o. </font><font style="vertical-align: inherit;">Adicione ao </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>Die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que lida com isso, bem como a destrui√ß√£o do seu pr√≥prio objeto de jogo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Die</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Destroy(gameObject); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos chamar esse m√©todo de </font></font><code>HexMapEditor.DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e n√£o destruir o esquadr√£o diretamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// Destroy(cell.Unit.gameObject); cell.Unit.Die(); } }</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salvando e carregando esquadr√µes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que podemos ter unidades no mapa, precisamos inclu√≠-las no processo de salvar e carregar. </font><font style="vertical-align: inherit;">Podemos abordar essa tarefa de duas maneiras. </font><font style="vertical-align: inherit;">O primeiro √© gravar dados do esquadr√£o ao gravar uma c√©lula, para que os dados da c√©lula e do esquadr√£o sejam misturados. </font><font style="vertical-align: inherit;">A segunda maneira √© salvar os dados de c√©lula e esquadr√£o separadamente. </font><font style="vertical-align: inherit;">Embora possa parecer que a primeira abordagem seja mais f√°cil de implementar, a segunda nos fornece dados mais estruturados. </font><font style="vertical-align: inherit;">Se compartilharmos os dados, ser√° mais f√°cil trabalhar com eles no futuro.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rastreamento de unidade </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para manter todas as unidades juntas, precisamos rastre√°-las. </font><font style="vertical-align: inherit;">Faremos isso adicionando √† </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lista de unidades. </font><font style="vertical-align: inherit;">Esta lista deve conter todas as unidades no mapa.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexUnit&gt; units = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexUnit&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao criar ou carregar um novo mapa, precisamos nos livrar de todas as unidades no mapa. </font><font style="vertical-align: inherit;">Para simplificar esse processo, crie um m√©todo </font></font><code>ClearUnits</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que mate todos na lista e apague-o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearUnits</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { units[i].Die(); } units.Clear(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chamamos esse m√©todo dentro </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e dentro </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Vamos fazer isso depois de limpar o caminho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ ClearPath(); ClearUnits(); ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ClearUnits(); ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicionando esquadr√µes √† grade </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, ao criar novas unidades, precisamos adicion√°-las √† lista. </font><font style="vertical-align: inherit;">Vamos definir um m√©todo para isso </font></font><code>AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que tamb√©m ir√° lidar com a localiza√ß√£o do esquadr√£o e os par√¢metros do seu objeto pai.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = location; unit.Orientation = orientation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora </font></font><code>HexMapEditor.CreatUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ser√° suficiente chamar </font></font><code>AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com uma nova inst√¢ncia do desapego, sua localiza√ß√£o e orienta√ß√£o aleat√≥ria.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; !cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// HexUnit unit = Instantiate(unitPrefab); // unit.transform.SetParent(hexGrid.transform, false); // unit.Location = cell; // unit.Orientation = Random.Range(0f, 360f); hexGrid.AddUnit( Instantiate(unitPrefab), cell, Random.Range(0f, 360f) ); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Removendo esquadr√µes da grade </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um m√©todo para remover o esquadr√£o e c </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Apenas remova o esquadr√£o da lista e ordene que ele morra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { units.Remove(unit); unit.Die(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chamamos esse m√©todo de </font></font><code>HexMapEditor.DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">em </font><font style="vertical-align: inherit;">vez de destruir o esquadr√£o diretamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// cell.Unit.Die(); hexGrid.RemoveUnit(cell.Unit); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salvando unidades </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como vamos manter todas as unidades juntas, precisamos lembrar quais c√©lulas elas ocupam. </font><font style="vertical-align: inherit;">A maneira mais confi√°vel √© salvar as coordenadas de sua localiza√ß√£o. </font><font style="vertical-align: inherit;">Para tornar isso poss√≠vel, adicionamos os </font><font style="vertical-align: inherit;">campos X e Z </font><font style="vertical-align: inherit;">ao </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que o escreve.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexCoordinates { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(x); writer.Write(z); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O m√©todo </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agora pode gravar as coordenadas e a orienta√ß√£o do esquadr√£o. </font><font style="vertical-align: inherit;">Esses s√£o todos os dados das unidades que temos no momento.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { location.coordinates.Save(writer); writer.Write(orientation); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rastreia unidades, seu m√©todo </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registra os dados das unidades. </font><font style="vertical-align: inherit;">Primeiro, anote o n√∫mero total de unidades e, em seguida, contorne todas elas em um loop.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } writer.Write(units.Count); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { units[i].Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como alteramos os dados armazenados, aumentamos o n√∫mero da vers√£o </font></font><code>SaveLoadMenu.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para 2. O c√≥digo de inicializa√ß√£o antigo ainda funcionar√°, porque simplesmente n√£o l√™ os dados do esquadr√£o. </font><font style="vertical-align: inherit;">No entanto, voc√™ precisa aumentar o n√∫mero da vers√£o para indicar que h√° informa√ß√µes da unidade no arquivo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">2</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Carregando esquadr√µes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© uma estrutura, n√£o faz muito sentido adicionar o m√©todo usual a ela </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Vamos torn√°-lo um m√©todo est√°tico que l√™ e retorna coordenadas armazenadas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates c; cx = reader.ReadInt32(); cz = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o n√∫mero de unidades √© vari√°vel, n√£o temos unidades pr√©-existentes nas quais os dados podem ser carregados. </font><font style="vertical-align: inherit;">Podemos criar novas inst√¢ncias de unidades antes de carregar seus dados, mas isso exigir√° a </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cria√ß√£o de inst√¢ncias de novas unidades no momento da inicializa√ß√£o. </font><font style="vertical-align: inherit;">Ent√£o √© melhor deixar isso </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tamb√©m usamos o m√©todo est√°tico </font></font><code>HexUnit.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Vamos come√ßar simplesmente lendo esses esquadr√µes. </font><font style="vertical-align: inherit;">Para ler o valor de orienta√ß√µes flutuador usar o m√©todo </font></font><code>BinaryReader.ReadSingle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que solteiro?</font></font></b> <div class="spoiler_text">  <code>float</code>        ,     .     ,   <code>double</code> ,     .  Unity   . </div></div><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates coordinates = HexCoordinates.Load(reader); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation = reader.ReadSingle(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O pr√≥ximo passo √© criar uma inst√¢ncia de um novo esquadr√£o. </font><font style="vertical-align: inherit;">No entanto, para isso, precisamos de um link para a pr√©-fabricada da unidade. </font><font style="vertical-align: inherit;">Para n√£o complicar ainda, vamos adicionar um </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo est√°tico </font><font style="vertical-align: inherit;">para isso </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexUnit unitPrefab;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para definir esse link, vamos us√°-lo novamente </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como fizemos com a textura do ru√≠do. </font><font style="vertical-align: inherit;">Quando precisarmos oferecer suporte a muitos tipos de unidades, seguiremos para uma solu√ß√£o melhor.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit unitPrefab; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; CreateMap(cellCountX, cellCountZ); } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/251/e2e/9c0/251e2e9c0e0f9ec8c6da0a0a7bce6f85.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passamos pela pr√©-fabrica√ß√£o da unidade.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ap√≥s conectar o campo, n√£o precisamos mais de um link direto para </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em vez disso, ele pode usar </font></font><code>HexUnit.unitPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public HexUnit unitPrefab; ‚Ä¶ void CreateUnit () { HexCell cell = GetCellUnderCursor(); if (cell &amp;&amp; !cell.Unit) { hexGrid.AddUnit( Instantiate(HexUnit.unitPrefab), cell, Random.Range(0f, 360f) ); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos criar uma inst√¢ncia do novo esquadr√£o </font></font><code>HexUnit.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em vez de devolv√™-lo, podemos usar as coordenadas e a orienta√ß√£o carregadas para adicion√°-lo √† grade. </font><font style="vertical-align: inherit;">Para tornar isso poss√≠vel, adicione um par√¢metro </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, HexGrid grid</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates coordinates = HexCoordinates.Load(reader); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation = reader.ReadSingle(); grid.AddUnit( Instantiate(unitPrefab), grid.GetCell(coordinates), orientation ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No final, </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contamos o n√∫mero de unidades e o usamos para carregar todas as unidades armazenadas, passando-nos como um argumento adicional.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unitCount = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; unitCount; i++) { HexUnit.Load(reader, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obviamente, isso funcionar√° apenas para salvar arquivos com vers√£o n√£o inferior a 2, nas vers√µes mais novas n√£o h√° unidades para carregar. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unitCount = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; unitCount; i++) { HexUnit.Load(reader, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, podemos fazer o upload correto dos arquivos da vers√£o 2, </font></font><code>SaveLoadMenu.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aumentando o n√∫mero da vers√£o suportada para 2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimento de Tropa </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os esquadr√µes s√£o m√≥veis, por isso devemos ser capazes de mov√™-los pelo mapa. </font><font style="vertical-align: inherit;">J√° temos um c√≥digo de busca de caminho, mas at√© agora o testamos apenas para locais arbitr√°rios. </font><font style="vertical-align: inherit;">Agora precisamos remover a interface do usu√°rio de teste antiga e criar uma nova interface para o gerenciamento de esquadr√£o.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Limpeza do Editor de Mapas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mover unidades ao longo de caminhos faz parte da jogabilidade, n√£o se aplica ao editor de mapas. </font><font style="vertical-align: inherit;">Portanto, nos livraremos </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de todo o c√≥digo associado √† localiza√ß√£o do caminho.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// HexCell previousCell, searchFromCell, searchToCell; HexCell previousCell; ‚Ä¶ void HandleInput () { HexCell currentCell = GetCellUnderCursor(); if (currentCell) { if (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } else { isDrag = false; } if (editMode) { EditCells(currentCell); } // else if ( // Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell // ) { // if (searchFromCell != currentCell) { // if (searchFromCell) { // searchFromCell.DisableHighlight(); // } // searchFromCell = currentCell; // searchFromCell.EnableHighlight(Color.blue); // if (searchToCell) { // hexGrid.FindPath(searchFromCell, searchToCell, 24); // } // } // } // else if (searchFromCell &amp;&amp; searchFromCell != currentCell) { // if (searchToCell != currentCell) { // searchToCell = currentCell; // hexGrid.FindPath(searchFromCell, searchToCell, 24); // } // } previousCell = currentCell; } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de remover esse c√≥digo, n√£o faz mais sentido deixar o editor ativo quando n√£o estamos no modo de edi√ß√£o. </font><font style="vertical-align: inherit;">Portanto, em vez de um campo de rastreamento de modo, podemos simplesmente ativar ou desativar o componente </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Al√©m disso, o editor agora n√£o precisa lidar com os r√≥tulos da interface do usu√°rio.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// bool editMode; ‚Ä¶ public void SetEditMode (bool toggle) { // editMode = toggle; // hexGrid.ShowUI(!toggle); enabled = toggle; } ‚Ä¶ void HandleInput () { HexCell currentCell = GetCellUnderCursor(); if (currentCell) { if (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } else { isDrag = false; } // if (editMode) { EditCells(currentCell); // } previousCell = currentCell; } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como, por padr√£o, n√£o estamos no modo de edi√ß√£o de mapas, no Desperto, desativaremos o editor. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); SetEditMode(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use o raycast para procurar a c√©lula atual sob o cursor e necess√°rio ao editar o mapa e gerenciar unidades. </font><font style="vertical-align: inherit;">Talvez no futuro nos seja √∫til para outra coisa. </font><font style="vertical-align: inherit;">Vamos passar a l√≥gica do raycasting de </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para um novo m√©todo </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com um par√¢metro de feixe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetCell(hit.point); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br> <code>HexMapEditor.GetCellUniderCursor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode apenas chamar esse m√©todo com o feixe do cursor. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellUnderCursor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexGrid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI do jogo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para controlar a interface do usu√°rio do modo de jogo, usaremos um novo componente. </font><font style="vertical-align: inherit;">Enquanto ele s√≥ vai lidar com a sele√ß√£o e movimenta√ß√£o de unidades. </font><font style="vertical-align: inherit;">Crie um novo tipo de componente para ele </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para fazer seu trabalho, basta um link para a rede.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGameUI</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione este componente ao novo objeto de jogo na hierarquia da interface do usu√°rio. </font><font style="vertical-align: inherit;">Ele n√£o precisa ter seu pr√≥prio objeto, mas ser√° √≥bvio para n√≥s que existe uma interface do usu√°rio separada para o jogo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/515/769/bdd/515769bdd0b6fbee9cb8451348595a57.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b3/b7c/0d7/9b3b7c0d719d05862a76ba8e70409970.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objeto de interface do jogo do jogo</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicione um </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>SetEditMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como em </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A interface do jogo deve ser ativada quando n√£o estamos no modo de edi√ß√£o. </font><font style="vertical-align: inherit;">Al√©m disso, os r√≥tulos precisam ser inclu√≠dos aqui, porque a interface do usu√°rio do jogo funciona com caminhos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione o m√©todo da interface do jogo √† lista de eventos da op√ß√£o do modo de edi√ß√£o. </font><font style="vertical-align: inherit;">Isso significa que quando o jogador muda de modo, os dois m√©todos s√£o chamados.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92b/dde/778/92bdde778bfc97ae4b5bdc1d49a2bb6b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V√°rios m√©todos de eventos. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rastrear c√©lula atual </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependendo da situa√ß√£o, </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voc√™ precisa saber qual c√©lula est√° atualmente sob o cursor. </font><font style="vertical-align: inherit;">Portanto, adicionamos um campo a ele </font></font><code>currentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCell currentCell;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crie um m√©todo </font></font><code>UpdateCurrentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que use a </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">viga </font><font style="vertical-align: inherit;">do </font><font style="vertical-align: inherit;">cursor para atualizar este campo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCurrentCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { currentCell = grid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao atualizar a c√©lula atual, podemos precisar descobrir se ela mudou. </font><font style="vertical-align: inherit;">For√ßar a </font></font><code>UpdateCurrentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retornar essas informa√ß√µes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCurrentCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = grid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != currentCell) { currentCell = cell; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sele√ß√£o de Unidade </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de mover um esquadr√£o, ele deve ser selecionado e rastreado. </font><font style="vertical-align: inherit;">Portanto, adicione um campo </font></font><code>selectedUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexUnit selectedUnit;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando tentamos fazer uma sele√ß√£o, precisamos come√ßar atualizando a c√©lula atual. </font><font style="vertical-align: inherit;">Se a c√©lula atual for, a unidade que ocupa essa c√©lula se torna a unidade selecionada. </font><font style="vertical-align: inherit;">Se n√£o houver nenhuma unidade na c√©lula, nenhuma unidade ser√° selecionada. </font><font style="vertical-align: inherit;">Vamos criar um m√©todo para isso </font></font><code>DoSelection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSelection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { UpdateCurrentCell(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { selectedUnit = currentCell.Unit; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Percebemos a escolha das unidades com um simples clique do mouse. </font><font style="vertical-align: inherit;">Portanto, adicionamos um m√©todo </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que faz uma sele√ß√£o quando o bot√£o do mouse √© ativado.Claro, precisamos execut√°-lo apenas quando o cursor n√£o est√° acima do elemento GUI.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta fase, aprendemos como selecionar uma unidade de cada vez com o clique de um mouse. </font><font style="vertical-align: inherit;">Quando voc√™ clica em uma c√©lula vazia, a sele√ß√£o de qualquer unidade √© removida. </font><font style="vertical-align: inherit;">Mas enquanto n√£o recebemos nenhuma confirma√ß√£o visual disso.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pesquisa de esquadr√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando uma unidade √© selecionada, podemos usar sua localiza√ß√£o como ponto de partida para encontrar um caminho. </font><font style="vertical-align: inherit;">Para ativar isso, n√£o ser√° necess√°rio outro clique no bot√£o do mouse. </font><font style="vertical-align: inherit;">Em vez disso, encontraremos e mostraremos automaticamente o caminho entre a posi√ß√£o do esquadr√£o e a c√©lula atual. </font><font style="vertical-align: inherit;">Sempre faremos isso </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, exceto quando a escolha for feita. </font><font style="vertical-align: inherit;">Para fazer isso, quando temos um plantel, chamamos o m√©todo </font></font><code>DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedUnit) { DoPathfinding(); } } }</code> </pre> <br> <code>DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apenas atualiza a c√©lula atual e chama </font></font><code>HexGrid.FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se houver um ponto de extremidade. </font><font style="vertical-align: inherit;">Novamente, usamos uma velocidade constante de 24.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { UpdateCurrentCell(); grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Observe que n√£o devemos encontrar um novo caminho toda vez que atualizamos, mas somente quando a c√©lula atual √© alterada. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39f/8d1/ce9/39f8d1ce9040ae5370fd12f447ecd8e7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Localizando um caminho para um esquadr√£o</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora, vemos os caminhos que aparecem quando voc√™ move o cursor ap√≥s selecionar um esquadr√£o. </font><font style="vertical-align: inherit;">Gra√ßas a isso, √© √≥bvio qual unidade est√° selecionada. </font><font style="vertical-align: inherit;">No entanto, os caminhos nem sempre s√£o limpos corretamente. </font><font style="vertical-align: inherit;">Primeiro, vamos limpar o caminho antigo se o cursor estiver fora do mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, isso exige que </font></font><code>HexGrid.ClearPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seja comum, ent√£o fazemos essa altera√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em segundo lugar, limparemos o caminho antigo ao escolher um desapego. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSelection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { grid.ClearPath(); UpdateCurrentCell(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { selectedUnit = currentCell.Unit; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por fim, limparemos o caminho ao alterar o modo de edi√ß√£o. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); grid.ClearPath(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Procure apenas pontos de extremidade v√°lidos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nem sempre podemos encontrar o caminho, porque √†s vezes √© imposs√≠vel chegar √† c√©lula final. </font><font style="vertical-align: inherit;">Isso √© normal. </font><font style="vertical-align: inherit;">Mas √†s vezes a pr√≥pria c√©lula final √© inaceit√°vel. </font><font style="vertical-align: inherit;">Por exemplo, decidimos que os caminhos n√£o podem incluir c√©lulas subaqu√°ticas. </font><font style="vertical-align: inherit;">Mas isso pode depender da unidade. </font><font style="vertical-align: inherit;">Vamos adicionar a um </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo que nos diz se uma c√©lula √© um ponto de extremidade v√°lido. </font><font style="vertical-align: inherit;">As c√©lulas subaqu√°ticas n√£o s√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !cell.IsUnderwater; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, permitimos que apenas uma unidade permanecesse na c√©lula. </font><font style="vertical-align: inherit;">Portanto, a c√©lula final n√£o ser√° v√°lida se estiver ocupada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !cell.IsUnderwater &amp;&amp; !cell.Unit; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos esse m√©todo </font></font><code>HexGameUI.DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para ignorar pontos de extremidade inv√°lidos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell &amp;&amp; selectedUnit.IsValidDestination(currentCell)) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mover para o ponto final </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se tivermos um caminho v√°lido, poderemos mover o esquadr√£o para o ponto final. </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sabe quando isso pode ser feito. </font><font style="vertical-align: inherit;">Fazemos passar essas informa√ß√µes em uma nova propriedade somente leitura </font></font><code>HasPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentPathExists; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mover um esquadr√£o, adicione ao </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>DoMove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este m√©todo ser√° chamado quando um comando for emitido e se uma unidade for selecionada. </font><font style="vertical-align: inherit;">Portanto, ele deve verificar se existe uma maneira e, se houver, alterar a localiza√ß√£o do destacamento. </font><font style="vertical-align: inherit;">Enquanto teletransportamos imediatamente o esquadr√£o para o ponto final. </font><font style="vertical-align: inherit;">Em um dos tutoriais a seguir, faremos com que o esquadr√£o v√° at√© o fim.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoMove</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.HasPath) { selectedUnit.Location = currentCell; grid.ClearPath(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos usar o bot√£o 1 do mouse (clique direito) para enviar o comando. </font><font style="vertical-align: inherit;">Verificaremos isso se um destacamento for selecionado. </font><font style="vertical-align: inherit;">Se o bot√£o n√£o for pressionado, procuraremos o caminho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedUnit) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { DoMove(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { DoPathfinding(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos mover unidades! </font><font style="vertical-align: inherit;">Mas, √†s vezes, eles se recusam a encontrar um caminho para algumas c√©lulas. </font><font style="vertical-align: inherit;">Em particular, naquelas c√©lulas em que costumava estar o desapego. </font><font style="vertical-align: inherit;">Isso acontece porque ele </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o atualiza o local antigo ao definir um novo. </font><font style="vertical-align: inherit;">Para consertar isso, limparemos o link para o esquadr√£o em seu antigo local.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evite esquadr√µes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encontrar o caminho agora funciona corretamente e as unidades podem se teletransportar no mapa. </font><font style="vertical-align: inherit;">Embora eles n√£o possam se mudar para c√©lulas que j√° possuem um esquadr√£o, os destacamentos no caminho s√£o ignorados.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/3d8/7dd/5193d87dd25bfa2fbc9e0ba26529b926.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As unidades no caminho s√£o ignoradas: as</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unidades da mesma fac√ß√£o geralmente podem se mover, mas at√© agora n√£o temos fac√ß√µes. </font><font style="vertical-align: inherit;">Portanto, vamos considerar todas as unidades desconectadas uma da outra e bloqueando os caminhos. </font><font style="vertical-align: inherit;">Isso pode ser implementado pulando c√©lulas ocupadas </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater || neighbor.Unit) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3c/f3b/698/f3cf3b698191010f55c0c994d3e324d8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evitar destacamentos </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 19: Anima√ß√£o em Movimento </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movemos as unidades entre as c√©lulas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualize o caminho percorrido. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√≥s movemos as tropas ao longo das curvas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√≥s for√ßamos as tropas a olhar na dire√ß√£o do movimento. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nesta parte, for√ßaremos as unidades em vez do teletransporte a se moverem ao longo dos trilhos. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a08/e41/a4f/a08e41a4fd0e90ea26dc11f16ff518f2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esquadr√µes a caminho</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimento ao longo do caminho </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na parte anterior, adicionamos unidades e a capacidade de mov√™-las. </font><font style="vertical-align: inherit;">Embora tenhamos usado a busca do caminho para determinar os pontos finais v√°lidos, depois de dar o comando, as tropas simplesmente se teletransportaram para a c√©lula final. </font><font style="vertical-align: inherit;">Para realmente seguir o caminho encontrado, precisamos rastrear esse caminho e criar um processo de anima√ß√£o que force o esquadr√£o a se mover de c√©lula em c√©lula. </font><font style="vertical-align: inherit;">J√° que, olhando as anima√ß√µes, √© dif√≠cil perceber como o esquadr√£o se moveu, tamb√©m visualizamos o caminho percorrido com a ajuda de aparelhos. </font><font style="vertical-align: inherit;">Mas antes de seguirmos em frente, precisamos corrigir o erro.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erro nas voltas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Devido a uma supervis√£o, calculamos incorretamente o curso em que a c√©lula ser√° atingida. </font><font style="vertical-align: inherit;">Agora, determinamos o percurso dividindo a dist√¢ncia total pela velocidade do esquadr√£o</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d </font></font></span><span class="MJXp-mrow" id="MJXp-Span-5"><span class="MJXp-mo" id="MJXp-Span-6" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e descartando o restante. </font><font style="vertical-align: inherit;">O erro ocorre quando, para entrar na c√©lula, voc√™ precisa gastar exatamente todos os pontos de movimento restantes por movimento. </font><font style="vertical-align: inherit;">Por exemplo, quando cada passo custa 1 e a velocidade √© 3, podemos mover tr√™s c√©lulas por turno. </font><font style="vertical-align: inherit;">No entanto, com os c√°lculos existentes, s√≥ podemos dar dois passos no primeiro passo, porque no terceiro passo</font></font><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.407ex" height="2.66ex" viewBox="0 -832 3189.1 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-64" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-2F" x="2219" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-73" x="2719" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1">t = d / s</script><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-8"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d </font></font></span><span class="MJXp-mrow" id="MJXp-Span-12"><span class="MJXp-mo" id="MJXp-Span-13" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s </font></font></span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-16"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-17"><span class="MJXp-mo" id="MJXp-Span-18" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-19"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3 </font></font></span><span class="MJXp-mo" id="MJXp-Span-20" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-21"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.254ex" height="2.66ex" viewBox="0 -832 7859.2 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-64" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-2F" x="2219" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-73" x="2719" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-3D" x="3466" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-33" x="4523" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-2F" x="5023" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-33" x="5524" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-3D" x="6302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-31" x="7358" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2">t = d / s = 3 / 3 = 1</script>  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d80/9ec/098/d809ec098cac1850cf16d47ce45ed030.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os custos somados da movimenta√ß√£o com movimentos definidos incorretamente, velocidade 3</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para o c√°lculo correto dos movimentos, precisamos mover a borda um passo a partir da c√©lula inicial. </font><font style="vertical-align: inherit;">Podemos fazer isso reduzindo a dist√¢ncia em 1 antes de calcular o movimento, e o movimento para o terceiro passo ser√°</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-22"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-24" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-25"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-26"><span class="MJXp-mo" id="MJXp-Span-27" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-28"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3 </font></font></span><span class="MJXp-mo" id="MJXp-Span-29" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-30"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.686ex" height="2.66ex" viewBox="0 -832 5031.6 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-32" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-2F" x="2196" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-33" x="2696" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-3D" x="3474" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-30" x="4531" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3">t = 2 / 3 = 0</script><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/291/37e/65629137e3267e033d1f5f6d3fd1f724.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Movimentos corretos</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Podemos fazer isso alterando a f√≥rmula de c√°lculo para</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-31"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mo" id="MJXp-Span-34" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d </font></font></span><span class="MJXp-mo" id="MJXp-Span-36" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mn" id="MJXp-Span-37"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-38" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mrow" id="MJXp-Span-39"><span class="MJXp-mo" id="MJXp-Span-40" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.219ex" height="2.66ex" viewBox="0 -832 5691.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-74" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-3D" x="639" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-28" x="1695" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-64" x="2085" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-2212" x="2830" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-31" x="3831" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-29" x="4332" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-2F" x="4721" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-73" x="5222" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4">t = (d - 1) / s</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faremos essa altera√ß√£o em </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentTurn = (current.Distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + moveCost; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = (distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (turn &gt; currentTurn) { distance = turn * speed + moveCost; } ‚Ä¶ } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tamb√©m mudamos as marcas dos movimentos. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = (current.Distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; ‚Ä¶ } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que, com essa abordagem, o caminho inicial da c√©lula √© -1. </font><font style="vertical-align: inherit;">Isso √© normal, porque n√£o o exibimos e o algoritmo de busca permanece operacional.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ficando maneira </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Movendo-se ao longo do caminho √© a tarefa do esquadr√£o. </font><font style="vertical-align: inherit;">Para ele fazer isso, ele precisa saber o caminho. </font><font style="vertical-align: inherit;">Como temos essas informa√ß√µes </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vamos adicionar um m√©todo para obter o caminho atual na forma de uma lista de c√©lulas. </font><font style="vertical-align: inherit;">Ele pode retir√°-lo do pool de listas e retornar se realmente houver um caminho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!currentPathExists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } List&lt;HexCell&gt; path = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A lista √© preenchida seguindo o caminho do link da c√©lula final at√© a inicial, como √© feito ao visualizar o caminho. </font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; path = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexCell c = currentPathTo; c != currentPathFrom; c = c.PathFrom) { path.Add(c); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nesse caso, precisamos de todo o caminho, que inclui a c√©lula inicial. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexCell c = currentPathTo; c != currentPathFrom; c = c.PathFrom) { path.Add(c); } path.Add(currentPathFrom); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora temos o caminho na ordem inversa. </font><font style="vertical-align: inherit;">Podemos trabalhar com ele, mas n√£o ser√° muito intuitivo. </font><font style="vertical-align: inherit;">Vamos virar a lista para que ela v√° do come√ßo ao fim.</font></font><br><br><pre> <code class="cs hljs"> path.Add(currentPathFrom); path.Reverse(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solicita√ß√£o de movimento </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos adicionar ao </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo, ordenando que ele siga o caminho. </font><font style="vertical-align: inherit;">Inicialmente, simplesmente deixamos que ele se teletransportasse para a c√©lula final. </font><font style="vertical-align: inherit;">N√£o retornaremos imediatamente a lista √† piscina, porque ela ser√° √∫til por um tempo.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para solicitar movimento, alteramos </font></font><code>HexGameUI.DoMove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que ele chame um novo m√©todo com o caminho atual, e n√£o apenas defina a localiza√ß√£o da unidade.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoMove</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.HasPath) { <span class="hljs-comment"><span class="hljs-comment">// selectedUnit.Location = currentCell; selectedUnit.Travel(grid.GetPath()); grid.ClearPath(); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualiza√ß√£o de caminho </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de come√ßarmos a animar o esquadr√£o, vamos verificar se os caminhos est√£o corretos. </font><font style="vertical-align: inherit;">Faremos isso ordenando </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lembrar o caminho ao longo do qual ele deve se mover, para que possa ser visualizado usando dispositivos.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; pathToTravel; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; pathToTravel = path; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um m√©todo </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para mostrar o √∫ltimo caminho a percorrer (se existir). </font><font style="vertical-align: inherit;">Se a unidade ainda n√£o se moveu, o caminho deve ser igual </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por√©m, devido √† serializa√ß√£o do Unity durante a edi√ß√£o ap√≥s a recompila√ß√£o no modo Play, tamb√©m pode ser uma lista vazia.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maneira mais f√°cil de mostrar o caminho √© desenhar uma esfera de dispositivo para cada c√©lula do caminho. </font><font style="vertical-align: inherit;">Uma esfera com um raio de 2 unidades √© adequada para n√≥s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pathToTravel.Count; i++) { Gizmos.DrawSphere(pathToTravel[i].Position, <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como mostraremos os caminhos para o desapego, poderemos ver simultaneamente todos os seus √∫ltimos caminhos. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dac/907/a7d/dac907a7da12a75436c7ae26956884bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os aparelhos exibem os √∫ltimos caminhos percorridos.Para</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mostrar melhor as conex√µes das c√©lulas, desenhamos v√°rias esferas em um loop em uma linha entre as c√©lulas anteriores e as atuais. </font><font style="vertical-align: inherit;">Para fazer isso, precisamos iniciar o processo a partir da segunda c√©lula. </font><font style="vertical-align: inherit;">As esferas podem ser organizadas usando interpola√ß√£o linear com um incremento de 0,1 unidades, para que possamos obter dez esferas por segmento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/46a/11c/5c246a11c0753d03b2572de5bfc297a4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maneiras mais √≥bvias</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deslize ao longo do caminho </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode usar o mesmo m√©todo para mover unidades. </font><font style="vertical-align: inherit;">Vamos criar uma rotina para isso. </font><font style="vertical-align: inherit;">Em vez de desenhar um dispositivo, definiremos a posi√ß√£o do esquadr√£o. </font><font style="vertical-align: inherit;">Em vez de incrementar, usaremos 0,1 delta de tempo e executaremos o rendimento para cada itera√ß√£o. </font><font style="vertical-align: inherit;">Nesse caso, o esquadr√£o passar√° de uma c√©lula para a pr√≥xima em um segundo.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime) { transform.localPosition = Vector3.Lerp(a, b, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos come√ßar a rotina no final do m√©todo </font></font><code>Travel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas primeiro, pararemos todas as corotinas existentes. </font><font style="vertical-align: inherit;">Portanto, garantimos que duas corotinas n√£o ser√£o iniciadas ao mesmo tempo, caso contr√°rio, isso levaria a resultados muito estranhos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; pathToTravel = path; StopAllCoroutines(); StartCoroutine(TravelPath()); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mover uma c√©lula por segundo √© bem lento. </font><font style="vertical-align: inherit;">O jogador durante o jogo n√£o vai querer esperar tanto tempo. </font><font style="vertical-align: inherit;">Voc√™ pode fazer com que a velocidade de movimento do esquadr√£o seja uma op√ß√£o de configura√ß√£o, mas, por enquanto, vamos usar uma constante. </font><font style="vertical-align: inherit;">Eu atribu√≠ a ela um valor de 4 c√©lulas por segundo; </font><font style="vertical-align: inherit;">√© bem r√°pido, mas vamos notar o que est√° acontecendo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> travelSpeed = <span class="hljs-number"><span class="hljs-number">4f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim como podemos visualizar v√°rios caminhos simultaneamente, tamb√©m podemos fazer com que v√°rias unidades viajem ao mesmo tempo. </font><font style="vertical-align: inherit;">Do ponto de vista do estado do jogo, o movimento ainda √© o teletransporte, as anima√ß√µes s√£o exclusivamente visuais. </font><font style="vertical-align: inherit;">As unidades ocupam instantaneamente a c√©lula final. </font><font style="vertical-align: inherit;">Voc√™ pode at√© encontrar maneiras e iniciar uma nova jogada antes que elas cheguem. </font><font style="vertical-align: inherit;">Nesse caso, eles s√£o teleportados visualmente para o in√≠cio de um novo caminho. </font><font style="vertical-align: inherit;">Isso pode ser evitado atrav√©s do bloqueio de unidades ou mesmo de toda a interface do usu√°rio enquanto elas est√£o em movimento, mas uma rea√ß√£o t√£o r√°pida √© bastante conveniente ao desenvolver e testar movimentos.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unidades m√≥veis. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E a diferen√ßa de altura?</font></font></b> <div class="spoiler_text">        ,      .       ,           .        ,    .   ,      .      ,  Endless Legend,   ,         .     ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posi√ß√£o ap√≥s a compila√ß√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma das desvantagens do corutin √© que eles n√£o "sobrevivem" quando recompilados no modo Play. </font><font style="vertical-align: inherit;">Embora o estado do jogo seja sempre verdadeiro, isso pode fazer com que os esquadr√µes fiquem presos em algum lugar do √∫ltimo caminho, se a recompila√ß√£o for iniciada enquanto eles ainda est√£o em movimento. </font><font style="vertical-align: inherit;">Para mitigar as consequ√™ncias, vamos garantir que, ap√≥s a recompila√ß√£o, as unidades estejam sempre na posi√ß√£o correta. </font><font style="vertical-align: inherit;">Isso pode ser feito atualizando sua posi√ß√£o em </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { transform.localPosition = location.Position; } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimento suave </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O movimento do centro para o centro da c√©lula parece muito mecanicista e cria mudan√ßas bruscas de dire√ß√£o. </font><font style="vertical-align: inherit;">Para muitos jogos, isso ser√° normal, mas inaceit√°vel se voc√™ precisar de pelo menos um movimento levemente realista. </font><font style="vertical-align: inherit;">Ent√£o, vamos mudar o movimento para torn√°-lo um pouco mais org√¢nico.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movendo-se de costela para costela </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O esquadr√£o come√ßa sua jornada a partir do centro da c√©lula. </font><font style="vertical-align: inherit;">Passa para o meio da borda da c√©lula e entra na pr√≥xima c√©lula. </font><font style="vertical-align: inherit;">Em vez de se mover em dire√ß√£o ao centro, ele pode ir direto para a pr√≥xima borda que deve atravessar. </font><font style="vertical-align: inherit;">De fato, a unidade cortar√° o caminho quando precisar mudar de dire√ß√£o. </font><font style="vertical-align: inherit;">Isso √© poss√≠vel para todas as c√©lulas, exceto os pontos finais do caminho.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bc/8f0/1b9/2bc8f01b93b55b7acab8d9f56dd6f4be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tr√™s maneiras de se mover de ponta a ponta</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos nos adaptar </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para exibir os caminhos gerados dessa maneira. </font><font style="vertical-align: inherit;">Ele deve interpolar entre as bordas das c√©lulas, o que pode ser encontrado pela m√©dia das posi√ß√µes das c√©lulas vizinhas. </font><font style="vertical-align: inherit;">√â o suficiente para calcular uma borda por itera√ß√£o, reutilizando o valor da itera√ß√£o anterior. </font><font style="vertical-align: inherit;">Assim, podemos fazer o m√©todo funcionar para a c√©lula inicial, mas, em vez da borda, assumimos sua posi√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 a, b = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 a = pathToTravel[i - 1].Position; // Vector3 b = pathToTravel[i].Position; a = b; b = (pathToTravel[i - 1].Position + pathToTravel[i].Position) * 0.5f; for (float t = 0f; t &lt; 1f; t += 0.1f) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), 2f); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para alcan√ßar o centro da c√©lula final, precisamos usar a posi√ß√£o da c√©lula como o √∫ltimo ponto, n√£o a aresta. </font><font style="vertical-align: inherit;">Voc√™ pode adicionar a verifica√ß√£o desse caso ao loop, mas √© um c√≥digo t√£o simples que ser√° mais √≥bvio duplicar o c√≥digo e alter√°-lo levemente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { ‚Ä¶ } a = b; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/466/4d4/deb4664d4f8bcffcc3839dddfaa0d792.png"></div><br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caminhos </font><i><font style="vertical-align: inherit;">baseados em</font></i><font style="vertical-align: inherit;"> nervuras Os caminhos resultantes s√£o menos parecidos com ziguezagues e o √¢ngulo de viragem m√°ximo √© reduzido de 120 ¬∞ para 90 ¬∞. </font><font style="vertical-align: inherit;">Isso pode ser considerado uma melhoria; portanto, aplicamos as mesmas altera√ß√µes na corotina </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para ver como fica a anima√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 a = pathToTravel[i - 1].Position; // Vector3 b = pathToTravel[i].Position; a = b; b = (pathToTravel[i - 1].Position + pathToTravel[i].Position) * 0.5f; for (float t = 0f; t &lt; 1f; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); yield return null; } } a = b; b = pathToTravel[pathToTravel.Count - 1].Position; for (float t = 0f; t &lt; 1f; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); yield return null; } }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Movendo-se com uma velocidade vari√°vel</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depois de cortar os √¢ngulos, o comprimento dos segmentos do caminho ficou dependente da mudan√ßa de dire√ß√£o. </font><font style="vertical-align: inherit;">Mas ajustamos a velocidade nas c√©lulas por segundo. </font><font style="vertical-align: inherit;">Como resultado, a velocidade do destacamento muda aleatoriamente.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seguindo curvas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mudan√ßas instant√¢neas de dire√ß√£o e velocidade ao cruzar os limites das c√©lulas parecem feias. </font><font style="vertical-align: inherit;">Melhor usar uma mudan√ßa gradual de dire√ß√£o. </font><font style="vertical-align: inherit;">Podemos acrescentar apoio for√ßando as tropas a seguirem curvas, em vez de linhas retas. </font><font style="vertical-align: inherit;">Voc√™ pode usar curvas de Bezier para isso. </font><font style="vertical-align: inherit;">Em particular, podemos fazer curvas quadr√°ticas de Bezier nas quais o centro das c√©lulas ser√° o ponto de controle intermedi√°rio. </font><font style="vertical-align: inherit;">Nesse caso, as tangentes das curvas adjacentes ser√£o imagens em espelho uma da outra, ou seja, todo o caminho se transformar√° em uma curva suave cont√≠nua.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a94/c46/0b8/a94c460b8e7b3fd2ecc3b4ea4e3225a9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curvas de ponta a ponta</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crie uma classe auxiliar </font></font><code>Bezier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com um m√©todo para obter pontos em uma curva quadr√°tica de Bezier. </font><font style="vertical-align: inherit;">Conforme explicado no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tutorial Curvas e splines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a f√≥rmula √© usada para este</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-42"><span class="MJXp-mo" id="MJXp-Span-43" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mn" id="MJXp-Span-44"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-45" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-47"><span class="MJXp-mo" id="MJXp-Span-48" style="margin-left: 0em; margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-49" style="vertical-align: 0.5em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A </font></font></span><span class="MJXp-mo" id="MJXp-Span-51" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-52"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mo" id="MJXp-Span-53" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mn" id="MJXp-Span-54"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-55" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-57" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></span><span class="MJXp-mo" id="MJXp-Span-60" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-61"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-63" style="vertical-align: 0.5em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="29.208ex" height="2.901ex" viewBox="0 -935.7 12575.6 1249" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-31" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-2212" x="1112" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-74" x="2112" y="0"></use><g transform="translate(2474,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-32" x="550" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-41" x="3317" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-2B" x="4290" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-32" x="5291" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-28" x="5791" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-31" x="6181" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-2212" x="6904" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-74" x="7904" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-29" x="8266" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-74" x="8655" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-42" x="9017" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-2B" x="9998" y="0"></use><g transform="translate(10999,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-74" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMAIN-32" x="511" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-43" x="11815" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5">(1 - t)^2 A + 2(1 - t) t B + t^2 C</script>  onde <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-65"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.743ex" height="2.057ex" viewBox="0 -780.1 750.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-41" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> A </script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-67"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-68"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.764ex" height="2.057ex" viewBox="0 -780.1 759.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-42" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> B </script>  e <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-69"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s√£o os pontos de controle e t √© o interpolador.</font></font><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.057ex" viewBox="0 -780.1 760.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/426481/&amp;usg=ALkJrhisIdraL1tWETkaNA3KQYoNPh_l8g#MJMATHI-43" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8">C</script><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bezier</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, Vector3 c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r = <span class="hljs-number"><span class="hljs-number">1f</span></span> - t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r * r * a + <span class="hljs-number"><span class="hljs-number">2f</span></span> * r * t * b + t * t * c; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O GetPoint n√£o deve ser limitado a 0-1?</font></font></b> <div class="spoiler_text">         0-1,    .          .  ,    <code>GetPointClamped</code> ,    <code>t</code> .      ,      <code>GetPointUnclamped</code> . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mostrar o caminho da curva </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, precisamos rastrear n√£o dois, mas tr√™s pontos. </font><font style="vertical-align: inherit;">Um ponto adicional √© o centro da c√©lula com a qual estamos trabalhando na itera√ß√£o atual, que possui um √≠ndice </font></font><code>i - 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque o ciclo come√ßa com 1. Ap√≥s receber todos os pontos, podemos substitu√≠-lo </font></font><code>Vector3.Lerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>Bezier.GetPoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nas c√©lulas inicial e final, em vez dos pontos final e m√©dio, podemos simplesmente usar o centro da c√©lula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { Gizmos.DrawSphere(Bezier.GetPoint(a, b, c, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Bezier.GetPoint(a, b, c, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/79d/cae/14079dcae70b7b2522c137e0af848883.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caminhos criados usando curvas de Bezier Um</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> caminho </font><i><font style="vertical-align: inherit;">curvo</font></i><font style="vertical-align: inherit;"> parece muito melhor. </font><font style="vertical-align: inherit;">Aplicamos as mesmas altera√ß√µes </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e vemos como as unidades s√£o animadas com essa abordagem.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos movemos pelas curvas e a</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> anima√ß√£o tamb√©m se tornou suave, mesmo quando a velocidade do desapego √© inst√°vel. </font><font style="vertical-align: inherit;">Como as tangentes da curva dos segmentos adjacentes coincidem, a velocidade √© cont√≠nua. </font><font style="vertical-align: inherit;">A mudan√ßa na velocidade ocorre gradualmente e acontece quando um desapego passa pela c√©lula, diminuindo a velocidade ao mudar de dire√ß√£o. </font><font style="vertical-align: inherit;">Se ele seguir em frente, a velocidade permanecer√° constante. </font><font style="vertical-align: inherit;">Al√©m disso, o esquadr√£o come√ßa e termina sua jornada na velocidade zero. </font><font style="vertical-align: inherit;">Isso imita o movimento natural, ent√£o deixe assim.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rastreamento de tempo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© esse ponto, come√ßamos a iterar sobre cada um dos segmentos de 0, continuando at√© chegar a 1. Isso funciona bem ao aumentar por um valor constante, mas nossa itera√ß√£o depende do delta do tempo. Quando a itera√ß√£o em um segmento for conclu√≠da, √© prov√°vel que exceda 1 em alguma quantidade, dependendo do tempo delta. Isso √© invis√≠vel em altas taxas de quadros, mas pode levar a movimentos bruscos em baixas taxas de quadros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evitar a perda de tempo, precisamos transferir o tempo restante de um segmento para o pr√≥ximo. Isso pode ser feito rastreando </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o caminho inteiro, e n√£o apenas em cada segmento. Ent√£o, no final de cada segmento, subtrairemos 1 dele.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } t -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * traveSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se j√° estivermos fazendo isso, vamos garantir que o delta do tempo seja levado em considera√ß√£o no in√≠cio do caminho. </font><font style="vertical-align: inherit;">Isso significa que come√ßaremos a nos mover imediatamente e n√£o ficaremos ociosos por um quadro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, n√£o terminamos exatamente no momento em que o caminho deve terminar, mas momentos antes. </font><font style="vertical-align: inherit;">Aqui, a diferen√ßa tamb√©m pode depender da taxa de quadros. </font><font style="vertical-align: inherit;">Portanto, vamos fazer com que o esquadr√£o complete o caminho exatamente no ponto final.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ transform.localPosition = location.Position; }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anima√ß√£o de orienta√ß√£o </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As unidades come√ßaram a se mover ao longo de uma curva suave, mas n√£o mudaram a orienta√ß√£o de acordo com a dire√ß√£o do movimento. </font><font style="vertical-align: inherit;">Como resultado, eles parecem deslizar. </font><font style="vertical-align: inherit;">Para fazer o movimento parecer um movimento real, precisamos rotacion√°-los.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Olhando para frente </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tutorial Curvas e splines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , podemos usar a derivada da curva para determinar a orienta√ß√£o da unidade. </font><font style="vertical-align: inherit;">A f√≥rmula para a derivada de uma curva de Bezier quadr√°tica:</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-71"><span class="MJXp-mn" id="MJXp-Span-72"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mo" id="MJXp-Span-73" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mo" id="MJXp-Span-74" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mn" id="MJXp-Span-75"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-76" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-78" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mo" id="MJXp-Span-79" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-80"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></span><span class="MJXp-mo" id="MJXp-Span-81" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A </font></font></span><span class="MJXp-mo" id="MJXp-Span-83" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mo" id="MJXp-Span-84" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-86" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C </font></font></span><span class="MJXp-mo" id="MJXp-Span-88" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-89"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font></span><span class="MJXp-mo" id="MJXp-Span-90" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mo" id="MJXp-Span-91" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9">2 ((1 - t) (B - A) + t (C - B))</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione ao </font></font><code>Bezier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo para calcul√°-lo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDerivative</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 a, Vector3 b, Vector3 c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2f</span></span> * ((<span class="hljs-number"><span class="hljs-number">1f</span></span> - t) * (b - a) + t * (c - b)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O vetor derivado est√° localizado em uma linha reta com a dire√ß√£o do movimento. </font><font style="vertical-align: inherit;">Podemos usar o m√©todo </font></font><code>Quaternion.LookRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para convert√™-lo em um turno de esquadr√£o. </font><font style="vertical-align: inherit;">Vamos realiz√°-lo a cada passo </font></font><code>HexUnit.TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; ‚Ä¶ transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o h√° erro no in√≠cio do caminho?</font></font></b> <div class="spoiler_text">    ,        .    <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-92"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-93">A</span></span></span><script type="math/tex" id="MathJax-Element-10"> A </script>  e <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-94"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-95">B</span></span></span><script type="math/tex" id="MathJax-Element-11"> B </script>  ,    .   ,   <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-96"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">t</span><span class="MJXp-mo" id="MJXp-Span-98" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-99">0</span></span></span><script type="math/tex" id="MathJax-Element-12">t = 0</script> ,     ,      <code>Quaternion.LookRotation</code> .  ,    ,     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-100"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-101">t</span><span class="MJXp-mo" id="MJXp-Span-102" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-103">0</span></span></span><script type="math/tex" id="MathJax-Element-13">t = 0</script>   .     .       ,  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-104"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-105">t</span><span class="MJXp-mo" id="MJXp-Span-106" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-107">0</span></span></span><script type="math/tex" id="MathJax-Element-14">t > 0</script>    . <br>         ,     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-108"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-109">t</span><span class="MJXp-mo" id="MJXp-Span-110" style="margin-left: 0.333em; margin-right: 0.333em;">&lt;</span><span class="MJXp-mn" id="MJXp-Span-111">1</span></span></span><script type="math/tex" id="MathJax-Element-15">t < 1</script>  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em contraste com a posi√ß√£o do desapego, a n√£o idealidade de sua orienta√ß√£o no final do caminho n√£o √© importante. </font><font style="vertical-align: inherit;">no entanto, precisamos garantir que sua orienta√ß√£o corresponda √† rota√ß√£o final. </font><font style="vertical-align: inherit;">Para fazer isso, ap√≥s a conclus√£o, equiparamos sua orienta√ß√£o √† sua rota√ß√£o em Y.</font></font><br><br><pre> <code class="cs hljs"> transform.localPosition = location.Position; orientation = transform.localRotation.eulerAngles.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, as unidades est√£o olhando exatamente na dire√ß√£o do movimento, horizontal e verticalmente. </font><font style="vertical-align: inherit;">Isso significa que eles se inclinam para frente e para tr√°s, descendo das encostas e subindo nelas. </font><font style="vertical-align: inherit;">Para garantir que eles sempre permane√ßam retos, for√ßamos o componente Y do vetor de dire√ß√£o a zero antes de us√°-lo para determinar a rota√ß√£o da unidade.</font></font><br><br><pre> <code class="cs hljs"> Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d); ‚Ä¶ Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Olhando para a frente enquanto se move</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√≥s olhamos para o ponto </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao longo do caminho, as unidades est√£o olhando para frente, mas antes de come√ßar a se mover, podem olhar na outra dire√ß√£o. Nesse caso, eles instantaneamente mudam de orienta√ß√£o. Ser√° melhor se eles virarem na dire√ß√£o do caminho antes do in√≠cio do movimento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Olhar na dire√ß√£o certa pode ser √∫til em outras situa√ß√µes, ent√£o vamos criar um m√©todo </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que force o esquadr√£o a mudar de orienta√ß√£o para observar um determinado ponto. A rota√ß√£o necess√°ria pode ser definida usando o m√©todo </font></font><code>Transform.LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, primeiro colocando o ponto na mesma posi√ß√£o vertical que o destacamento. Depois disso, podemos recuperar a orienta√ß√£o do esquadr√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { point.y = transform.localPosition.y; transform.LookAt(point); orientation = transform.localRotation.eulerAngles.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que o desapego realmente gire, transformaremos o m√©todo em outro corutin que o girar√° a uma velocidade constante. A velocidade de rota√ß√£o tamb√©m pode ser ajustada, mas usaremos a constante novamente. A rota√ß√£o deve ser r√°pida, cerca de 180 ¬∞ por segundo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationSpeed = <span class="hljs-number"><span class="hljs-number">180f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o √© necess√°rio mexer na acelera√ß√£o do turno, porque √© impercept√≠vel. Basta que interpolemos entre as duas orienta√ß√µes. Infelizmente, isso n√£o √© t√£o simples como no caso de dois n√∫meros, porque os √¢ngulos s√£o circulares. Por exemplo, uma transi√ß√£o de 350 ¬∞ para 10 ¬∞ deve resultar em uma rota√ß√£o de 20 ¬∞ no sentido hor√°rio, mas uma interpola√ß√£o simples for√ßar√° uma rota√ß√£o de 340 ¬∞ no sentido anti-hor√°rio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maneira mais f√°cil de criar uma rota√ß√£o correta √© interpolar entre dois quaternions usando interpola√ß√£o esf√©rica. Isso levar√° ao turno mais curto. Para fazer isso, obtemos os quaternions do come√ßo e do fim e, em seguida, fazemos uma transi√ß√£o entre eles usando </font></font><code>Quaternion.Slerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { point.y = transform.localPosition.y; Quaternion fromRotation = transform.localRotation; Quaternion toRotation = Quaternion.LookRotation(point - transform.localPosition); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime) { transform.localRotation = Quaternion.Slerp(fromRotation, toRotation, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } transform.LookAt(point); orientation = transform.localRotation.eulerAngles.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso funcionar√°, mas a interpola√ß√£o sempre varia de 0 a 1, independentemente do √¢ngulo de rota√ß√£o. </font><font style="vertical-align: inherit;">Para garantir velocidade angular uniforme, precisamos diminuir a interpola√ß√£o √† medida que o √¢ngulo de rota√ß√£o aumenta.</font></font><br><br><pre> <code class="cs hljs"> Quaternion fromRotation = transform.localRotation; Quaternion toRotation = Quaternion.LookRotation(point - transform.localPosition); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Quaternion.Angle(fromRotation, toRotation); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = rotationSpeed / angle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * speed; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * speed ) { transform.localRotation = Quaternion.Slerp(fromRotation, toRotation, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conhecendo o √¢ngulo, podemos pular completamente a curva se ela for zero. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Quaternion.Angle(fromRotation, toRotation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (angle &gt; <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = rotationSpeed / angle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ‚Ä¶ ) { ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos adicionar a rota√ß√£o da unidade </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplesmente executando o rendimento antes de mover a </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">posi√ß√£o da segunda c√©lula. </font><font style="vertical-align: inherit;">O Unity iniciar√° automaticamente a rotina </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aguardar√° sua conclus√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ verificar o c√≥digo, o esquadr√£o se teletransporta para a c√©lula final, vira para l√° e depois se teletransporta de volta para o in√≠cio do caminho e come√ßa a se mover a partir da√≠. </font><font style="vertical-align: inherit;">Isso acontece porque atribu√≠mos um valor a uma propriedade </font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antes do in√≠cio da corotina </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para se livrar do teletransporte, podemos, no in√≠cio, </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retornar a posi√ß√£o do desapego √† c√©lula inicial.</font></font><br><br><pre> <code class="cs hljs"> Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; transform.localPosition = c; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gire antes de mover</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Varrer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tendo recebido o movimento de que precisamos, podemos nos livrar do m√©todo </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Exclua ou comente se precisarmos ver caminhos no futuro.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void OnDrawGizmos () { // ‚Ä¶ // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como n√£o precisamos mais lembrar para onde est√°vamos nos movendo, no final, </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voc√™ pode liberar a lista de c√©lulas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ ListPool&lt;HexCell&gt;.Add(pathToTravel); pathToTravel = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E as anima√ß√µes de esquadr√£o real?</font></font></b> <div class="spoiler_text">         ,   .    3D-       .      .        ,     .       Mecanim,     <code>TravelPath</code> . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt426481/">https://habr.com/ru/post/pt426481/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt426471/index.html">Como os dados de spyware vazam</a></li>
<li><a href="../pt426473/index.html">Arquitetura Redux. Sim ou n√£o?</a></li>
<li><a href="../pt426475/index.html">Miya - assistente do smartphone</a></li>
<li><a href="../pt426477/index.html">Toda a verdade sobre o RTOS. Artigo 15. Parti√ß√µes de mem√≥ria: servi√ßos e estruturas de dados</a></li>
<li><a href="../pt426479/index.html">Banco de teste caseiro para placas-m√£e</a></li>
<li><a href="../pt426483/index.html">Aquele que ultrapassa Tesla. Para mais rent√°vel</a></li>
<li><a href="../pt426485/index.html">Terceiro teste do Qt 5 com o PVS-Studio</a></li>
<li><a href="../pt426487/index.html">Teste a automa√ß√£o do zero. Parte 1</a></li>
<li><a href="../pt426489/index.html">Sobre a rela√ß√£o de n√∫meros primos e irracionais</a></li>
<li><a href="../pt426491/index.html">Semana de Seguran√ßa 39: com a morte do Google+</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>