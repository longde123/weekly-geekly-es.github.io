<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚢 🚆 ⚙️ Das Buch "Arbeiten Sie mit BigData in den Wolken. Verarbeiten und Speichern von Daten anhand von Beispielen aus Microsoft Azure » 🎅🏻 🙍🏽 🚍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hier ist das erste ursprünglich russischsprachige Buch, in dem die Geheimnisse der Verarbeitung von Big Data (Big Data) in den Clouds anhand realer Be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Buch "Arbeiten Sie mit BigData in den Wolken. Verarbeiten und Speichern von Daten anhand von Beispielen aus Microsoft Azure »</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/428375/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/un/xm/vy/unxmvydwj2ybjfabsmi3vbdcnsg.jpeg" align="left" alt="Bild"></a>  Hier ist das erste ursprünglich russischsprachige Buch, in dem die Geheimnisse der Verarbeitung von Big Data (Big Data) in den Clouds anhand realer Beispiele untersucht werden. <br><br>  Der Schwerpunkt liegt auf Microsoft Azure- und AWS-Lösungen.  Alle Arbeitsphasen werden berücksichtigt - das Abrufen von Daten, die für die Verarbeitung in der Cloud vorbereitet wurden, mithilfe von Cloud-Speicher- und Cloud-Datenanalysetools.  Besonderes Augenmerk wird auf SAAS-Services gelegt. Die Vorteile von Cloud-Technologien im Vergleich zu Lösungen, die auf dedizierten Servern oder virtuellen Maschinen bereitgestellt werden, werden demonstriert. <br><br>  Das Buch richtet sich an ein breites Publikum und wird als hervorragende Ressource für die Entwicklung von Azure, Docker und anderen unverzichtbaren Technologien dienen, ohne die moderne Unternehmen undenkbar sind. <br><br>  Wir laden Sie ein, die Passage "Direkter Download von Streaming-Daten" zu lesen. <br><a name="habracut"></a><br><h3>  10.1.  Allgemeine Architektur </h3><br>  Im vorherigen Kapitel haben wir die Situation untersucht, in der viele Clientanwendungen eine große Anzahl von Nachrichten senden müssen, die dynamisch verarbeitet, im Repository abgelegt und dann erneut verarbeitet werden müssen.  Gleichzeitig ist es erforderlich, die Logik des Datenverarbeitungs- und Speicherflusses ändern zu können, ohne den Clientcode ändern zu müssen.  Und schließlich sollten Kunden aus Sicherheitsgründen das Recht haben, nur eines zu tun - Nachrichten zu senden oder zu empfangen, aber in keiner Weise Daten zu lesen oder Datenbanken zu löschen, und sie sollten keine direkten Rechte zum Schreiben dieser Daten haben. <br><br>  Solche Aufgaben sind in Systemen, die mit IoT-Geräten arbeiten, die über eine Internetverbindung verbunden sind, sowie in Online-Protokollanalysesystemen sehr häufig.  Zusätzlich zu den oben aufgeführten Anforderungen an unseren dedizierten Service gibt es zwei weitere Anforderungen, die sich auf die Besonderheiten des „Internet der Dinge“ und die Gewährleistung einer zuverlässigen Nachrichtenverarbeitung beziehen.  Erstens muss das Interaktionsprotokoll zwischen dem Client und dem Dienstempfänger sehr einfach sein, damit es auf einem Gerät mit begrenzten Rechenkapazitäten und sehr begrenztem Speicher implementiert werden kann (z. B. Arduino, Intel Edison, STM32 Discovery und andere „unangemessene“ Plattformen, wie z wie zuvor RaspberryPi).  Die nächste Anforderung ist die zuverlässige Nachrichtenübermittlung unabhängig von möglichen Fehlern bei den Verarbeitungsdiensten.  Dies ist eine stärkere Anforderung als die Anforderung einer hohen Zuverlässigkeit.  Um die allgemeine Zuverlässigkeit des gesamten Systems zu gewährleisten, muss die Zuverlässigkeit aller seiner Komponenten hoch genug sein, und das Hinzufügen einer neuen Komponente führt nicht zu einer spürbaren Zunahme der Anzahl von Fehlern.  Zusätzlich zum Fehler in der Cloud-Infrastruktur kann ein Fehler im vom Benutzer erstellten Dienst auftreten.  Und selbst dann sollte die Nachricht verarbeitet werden, sobald der Benutzerdienst wiederhergestellt ist.  Zu diesem Zweck muss der Nachrichtenfluss-Empfangsdienst die Nachricht zuverlässig speichern, bis sie verarbeitet wird oder bis ihre Lebensdauer abläuft (dies ist erforderlich, um einen Speicherüberlauf während eines kontinuierlichen Nachrichtenflusses zu verhindern).  Ein Dienst mit diesen Eigenschaften wird als Event Hub bezeichnet.  Für IoT-Geräte gibt es spezialisierte Hubs (IoT Hub), die eine Reihe anderer Eigenschaften aufweisen, die für die Verwendung in Verbindung mit Geräten des Internet der Dinge sehr wichtig sind (z. B. bidirektionale Kommunikation von einem Punkt aus, integriertes Nachrichtenrouting, „digitale Doppel“ des Geräts und eine Reihe von andere).  Diese Dienste sind jedoch immer noch spezialisiert, und wir werden sie nicht im Detail betrachten. <br><br>  Bevor wir uns dem Konzept der Nachrichtenkonzentration zuwenden, wenden wir uns den zugrunde liegenden Ideen zu. <br><br>  Angenommen, wir haben eine Nachrichtenquelle (z. B. Anforderungen von einem Client) und einen Dienst, der diese verarbeiten soll.  Die Verarbeitung einer einzelnen Anforderung nimmt Zeit in Anspruch und erfordert Rechenressourcen (CPU, Speicher, IOPS).  Darüber hinaus können während der Verarbeitung einer Anforderung die verbleibenden Anforderungen nicht verarbeitet werden.  Damit Clientanwendungen nicht einfrieren, während auf die Freigabe eines Dienstes gewartet wird, müssen sie mithilfe eines zusätzlichen Dienstes getrennt werden, der für das Speichern von Nachrichten verantwortlich ist, während sie in der Warteschlange auf die Verarbeitung warten.  Diese Trennung ist auch notwendig, um die allgemeine Zuverlässigkeit des Systems zu erhöhen.  In der Tat sendet der Client eine Nachricht an das System, aber der Verarbeitungsdienst kann "fallen", aber die Nachricht sollte nicht verloren gehen. Sie muss in einem Dienst gespeichert werden, der zuverlässiger als der Verarbeitungsdienst ist.  Die einfachste Version eines solchen Dienstes heißt Warteschlange (Abb. 10.1). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ql/8v/vn/ql8vvnkz7cm8mkc0mrgtrdczzae.png" alt="Bild"></div><br>  Der Warteschlangendienst funktioniert wie folgt: Der Client kennt die URL der Warteschlange und verfügt über Zugriffsschlüssel.  Mithilfe des SDK oder der API der Warteschlange platziert der Client eine Nachricht, die den Zeitstempel, die Kennung und den Nachrichtentext mit einer Nutzlast im JSON-, XML- oder Binärformat enthält. <br><br>  Der Programmcode des Dienstes enthält einen Zyklus, der die Warteschlange „abhört“ und bei jedem Schritt die nächste Nachricht abruft. Wenn sich eine Nachricht in der Warteschlange befindet, wird sie extrahiert und verarbeitet.  Wenn der Dienst die Nachricht erfolgreich verarbeitet, wird sie aus der Warteschlange entfernt.  Wenn während der Verarbeitung ein Fehler auftritt, wird dieser nicht gelöscht und kann erneut verarbeitet werden, wenn eine neue Version des Dienstes mit dem korrigierten Code gestartet wird.  Die Warteschlange dient zum Synchronisieren eines Clients (oder einer Gruppe ähnlicher Clients) und genau eines Verarbeitungsdienstes (obwohl sich dieser in einem Servercluster oder in einer Serverfarm befinden kann).  Zu den Cloud-Warteschlangendiensten gehören die Azure-Speicherwarteschlange, die Azure-Dienstbuswarteschlange und AWS SQS.  Zu den auf virtuellen Maschinen gehosteten Diensten gehören RabbitMQ, ZeroMQ, MSMQ, IBM MQ usw. <br><br>  Unterschiedliche Warteschlangendienste garantieren unterschiedliche Arten der Nachrichtenübermittlung: <br><ul><li>  Mindestens einmalige Nachrichtenübermittlung </li><li>  streng einmalige Lieferung; </li><li>  Zustellung von Nachrichten unter Beibehaltung der Bestellung; </li><li>  Zustellung von Nachrichten ohne Aufrechterhaltung der Bestellung. </li></ul><br>  Die Warteschlange bietet eine zuverlässige Zustellung von Nachrichten von einer Quelle an einen Verarbeitungsdienst, dh eine Eins-zu-Eins-Interaktion.  Was aber, wenn mehrere Dienste übermittelt werden müssen?  In diesem Fall müssen Sie einen Dienst namens "topic" (topic) verwenden (Abb. 10.2). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wo/mi/6i/womi6if7bwniohwxjvik1r68v_4.png" alt="Bild"></div><br>  Ein wichtiges Element dieser Architektur sind „Abonnements“.  Dies ist der Pfad, der in dem Abschnitt registriert ist, über den die Nachricht gesendet wird.  Nachrichten werden vom Client im Thema veröffentlicht und an eines der Abonnements übertragen, aus denen sie von einem der Dienste extrahiert und von diesem verarbeitet werden.  Themen bieten eine Eins-zu-Viele-Interaktionsarchitektur für den Kundenservice.  Beispiele für solche Dienste sind das Azure Service Bus-Thema und AWS SNS. <br><br>  Nehmen wir nun an, dass es eine große Anzahl heterogener Clients gibt, die viele Nachrichten an verschiedene Dienste senden müssen, dh wir müssen ein Viele-zu-Viele-Interaktionssystem aufbauen.  Natürlich kann eine solche Architektur aus mehreren Abschnitten erstellt werden, aber eine solche Konstruktion ist nicht skalierbar und erfordert Verwaltungs- und Überwachungsaufwand.  Es gibt jedoch separate Dienste - Nachrichtenkonzentratoren (Abb. 10.3). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5t/na/sg/5tnasgyiet_8zcd0zmtvxj4koeg.png" alt="Bild"></div><br>  Der Hub akzeptiert Nachrichten von vielen Clients.  Alle Clients können Nachrichten an einen gemeinsamen Service-Endpunkt senden oder über spezielle Schlüssel eine separate Verbindung zu verschiedenen Endpunkten herstellen.  Mit diesen Schlüsseln können Sie Clients flexibel verwalten: Trennen Sie einige, trennen Sie neue usw. Innerhalb des Hubs befinden sich auch Partitionen.  In diesem Fall können sie jedoch auf alle Clients verteilt werden, um die Produktivität zu steigern (Round Robin - „mit zyklischer Addition“), oder der Client kann Nachrichten in einem der Abschnitte veröffentlichen.  Auf der anderen Seite werden Verarbeitungsdienste zu Verbrauchergruppen zusammengefasst.  Ein oder mehrere Dienste können mit einer Gruppe verbunden werden.  Somit ist ein Nachrichtenkonzentrator der flexibelste Dienst, der als Warteschlange, Abschnitt oder Gruppe von Warteschlangen oder als Satz von Abschnitten konfiguriert werden kann.  Im Allgemeinen bietet ein Nachrichtenkonzentrator eine Viele-zu-Viele-Beziehung zwischen Clients und Diensten.  Zu diesen Hubs gehören Apache Kafka, Azure Event Hub und AWS Kinesis Stream. <br><br>  Bevor wir uns mit Cloud-basierten PaaS-Diensten befassen, werden wir uns mit einem sehr leistungsstarken und bekannten Dienst befassen - Apache Kafka.  In Cloud-Umgebungen kann auf sie als Distribution zugegriffen werden, die direkt in einem Cluster einer virtuellen Maschine oder über den HDInsight-Dienst bereitgestellt wird.  Apache Kafka ist also ein Dienst, der die folgenden Funktionen bietet: <br><ul><li>  Veröffentlichen und Abonnieren eines Nachrichtenflusses </li><li>  zuverlässige Speicherung von Nachrichten; </li><li>  Anwendung von Streaming-Nachrichtenverarbeitungsdiensten von Drittanbietern. </li></ul><br>  Physisch läuft Kafka in einem Cluster von einem oder mehreren Servern.  Kafka bietet eine API für die Interaktion mit externen Clients (Abb. 10.4). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/50/ug/gz50ugazn-xwectzo--c8pulh4c.png" alt="Bild"></div><br>  Betrachten Sie diese APIs der Reihe nach. <br><ul><li>  Mit Hersteller-APIs können Clientanwendungen Nachrichtenflüsse in einem oder mehreren Kafka-Themen veröffentlichen. </li><li>  Mit Consumer-APIs können Clientanwendungen ein oder mehrere Themen abonnieren und Nachrichtenflüsse verarbeiten, die von Themen an Clients übermittelt werden. </li><li>  Mit den Stream-Prozessor-APIs können Anwendungen als Streaming-Prozessor mit dem Kafka-Cluster interagieren.  Quellen für einen Prozessor können ein oder mehrere Themen sein.  In diesem Fall werden die verarbeiteten Nachrichten auch in einem oder mehreren Themen platziert. </li><li>  Die Connector-APIs helfen dabei, externe Datenquellen (z. B. RDB) als Nachrichtenquellen (z. B. Datenänderungsereignisse in der Datenbank abzufangen) und als Empfänger zu verbinden. </li></ul><br>  In Kafka erfolgt die Interaktion zwischen Clients und Cluster über TCP, was durch die vorhandenen SDKs für verschiedene Programmiersprachen, einschließlich .Net, erleichtert wird.  Die grundlegenden SDK-Sprachen sind jedoch Java und Scala. <br><br>  In einem Cluster erfolgt die Speicherung von Nachrichtenflüssen (in der Kafka-Terminologie auch als Einträge bezeichnet) logisch in Objekten, die als Themen bezeichnet werden (Abb. 10.5).  Jeder Datensatz besteht aus einem Schlüssel, einem Wert und einem Zeitstempel.  Ein Thema ist im Wesentlichen eine Folge von Datensätzen (Nachrichten), die von Kunden veröffentlicht wurden.  Kafka-Themen unterstützen von 0 bis zu mehreren Abonnenten.  Jedes Thema wird physisch als partitioniertes Protokoll dargestellt.  Jeder Abschnitt ist eine geordnete Folge von Datensätzen, zu denen ständig neue hinzugefügt werden, die am Eingang von Kafka ankommen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qn/yi/wu/qnyiwuqtcxijhasj3iz7q8eh4jm.png" alt="Bild"></div><br>  Jeder Eintrag im Abschnitt entspricht einer Nummer in der Sequenz, die auch als Offset bezeichnet wird und diese Nachricht in der Sequenz eindeutig identifiziert.  Im Gegensatz zur Warteschlange löscht Kafka die Nachricht nicht nach der Verarbeitung des Dienstes, sondern nach der Lebensdauer der Nachrichten.  Dies ist eine sehr wichtige Eigenschaft, die es verschiedenen Verbrauchern ermöglicht, von einem Thema zu lesen.  Darüber hinaus ist jedem Verbraucher eine Vorspannung zugeordnet (Abb. 10.6).  Und jeder Lesevorgang führt nur zu einer Wertsteigerung für jeden Kunden und wird vom Kunden genau bestimmt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mj/1b/mk/mj1bmkl7ooowixrdekhfg3-bix8.png" alt="Bild"></div><br>  Im Normalfall erhöht sich dieser Versatz um eins, nachdem eine Nachricht aus dem Thema erfolgreich gelesen wurde.  Bei Bedarf kann der Client diesen Offset verschieben und den Lesevorgang wiederholen. <br><br>  Die Verwendung des Abschnittskonzepts verfolgt die folgenden Ziele. <br><br>  Erstens bieten Abschnitte die Möglichkeit, Themen zu skalieren, wenn ein Thema nicht in denselben Knoten passt.  Gleichzeitig hat jeder Abschnitt einen führenden Knoten (verwechseln Sie ihn nicht mit dem Hauptknoten des gesamten Clusters) und null oder mehrere nachfolgende Knoten.  Der Kopfknoten ist für die Verarbeitung von Lese- / Schreibvorgängen verantwortlich, während die Follower seine passiven Kopien sind.  Wenn der Masterknoten ausfällt, wird einer der Nachfolgeknoten automatisch zum Hauptknoten.  Jeder Clusterknoten ist für einige Abschnitte der Lead und für andere ein Follower.  Zweitens erhöht eine solche Replikation die Leseleistung aufgrund der Möglichkeit paralleler Leseoperationen. <br><br>  Der Produzent kann die Nachricht explizit oder implizit im Round-Robin-Modus (dh mit einheitlicher Füllung) in ein beliebiges Thema seiner Wahl einfügen.  Verbraucher sind in sogenannten Verbrauchergruppen zusammengefasst, und jede im Thema veröffentlichte Nachricht wird an einen Kunden in jeder Verbrauchergruppe übermittelt.  In diesem Fall können Clients physisch auf einem oder mehreren Servern / virtuellen Maschinen gehostet werden.  Im Einzelnen ist die Nachrichtenübermittlung wie folgt.  Für alle Kunden, die derselben Verbrauchergruppe angehören, können Nachrichten zwischen Kunden verteilt werden, um die Auslastung zu optimieren.  Wenn Kunden verschiedenen Verbrauchergruppen angehören, wird jede Nachricht an jede Gruppe gesendet.  Die Trennung von Nachrichten von Abschnitten durch verschiedene Verbrauchergruppen ist in Abb. 2 dargestellt.  10.7. <br><br>  Jetzt werde ich kurz die wichtigsten Parameter für die Zustellung und Speicherung von Nachrichten beschreiben, die von Kafka garantiert werden. <br><ul><li>  Vom Hersteller an ein bestimmtes Thema gesendete Nachrichten werden ausschließlich in der Reihenfolge hinzugefügt, in der sie gesendet wurden. </li><li>  Der Client sieht die Nachrichtenreihenfolge in dem Thema, das beim Speichern der Nachrichten empfangen wurde.  Infolgedessen werden Nachrichten vom Hersteller an den Verbraucher ausschließlich in der Reihenfolge geliefert, in der sie eingehen. </li><li>  Die N-fache Replikation des Themas stellt die Stabilität des Themas gegenüber dem Ausfall von N - 1 Knoten ohne Leistungsverlust sicher. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rf/qp/ms/rfqpmsno04krpiqxhs1qv8agwhu.png" alt="Bild"></div><br>  Daher kann der Apache Kafka-Dienst in den folgenden Modi verwendet werden. <br><br><ul><li>  Dienst - Nachrichtenbroker (Warteschlange) oder Veröffentlichungsdienst - Nachrichtenabonnement (Thema).  In der Tat basiert Kafka auf einer Gruppe von Themen, die mit einem Abonnenten in eine Warteschlange umgewandelt werden können.  (Es sollte beachtet werden: Im Gegensatz zu den üblichen Nachrichtenbrokerdiensten, die auf dem Prinzip der Warteschlangen basieren, werden Kafka-Nachrichten erst nach Ablauf ihrer Lebensdauer gelöscht, während die Broker das Peek-Delete-Prinzip implementieren, dh das Abrufen und Löschen nach erfolgreicher Verarbeitung. ) Das Prinzip der Verbrauchergruppen fasst diese beiden Konzepte zusammen, und die Fähigkeit, Nachrichten in allen Themenbereichen mit der Verteilung von Round Robin zu veröffentlichen, macht Kafka zu einem universellen Multi-Mode-Nachrichtenbroker. </li><li>  Dienst zur Analyse von Streaming-Nachrichten.  Dies ist dank der in Kafka enthaltenen API für Streaming-Prozessoren möglich, mit der Sie komplexe Systeme erstellen können, die auf der Grundlage von Event Driven erstellt wurden, mit Diensten, die Nachrichten filtern oder darauf antworten, sowie Diensten, die Nachrichten aggregieren. </li></ul><br>  All diese Eigenschaften ermöglichen es, Kafka als Schlüsselkomponente einer Plattform zu verwenden, die mit Streaming-Daten arbeitet und über hervorragende Funktionen zum Aufbau komplexer Nachrichtenverarbeitungssysteme verfügt.  Gleichzeitig ist Kafka in Bezug auf die Bereitstellung und Konfiguration eines Clusters aus mehreren Knoten recht kompliziert, was einen erheblichen Verwaltungsaufwand erfordert.  Da die Kafka zugrunde liegenden Ideen jedoch sehr gut zum Erstellen von Systemen, zum Streamen von Nachrichten und zum Empfangen von Nachrichten geeignet sind, bieten Cloud-Anbieter PaaS-Dienste an, die diese Ideen implementieren und alle Schwierigkeiten beim Erstellen und Verwalten eines Kafka-Clusters verbergen.  Da diese Dienste hinsichtlich der Anpassung und Erweiterung über die für Dienste zugewiesenen Grenzen hinaus eine Reihe von Einschränkungen aufweisen, bieten Cloud-Anbieter spezielle IaaS / PaaS-Dienste für die physische Bereitstellung von Kafka in einem Cluster für virtuelle Maschinen an.  In diesem Fall hat der Benutzer nahezu vollständige Konfigurations- und Erweiterungsfreiheit.  Diese Dienste umfassen Azure HDInsight.  Es wurde bereits oben erwähnt.  Es wurde erstellt, um einerseits dem Benutzer selbst Dienste aus dem Hadoop-Ökosystem ohne externe Wrapper bereitzustellen und andererseits die Schwierigkeiten zu beseitigen, die sich aus der direkten Installation, Verwaltung und Konfiguration von IaaS ergeben.  Docker Hosting ist ein wenig auseinander.  Da dies ein äußerst wichtiges Thema ist, werden wir es betrachten, aber zuerst die PaaS-Dienste kennenlernen, die mit den Grundkonzepten von Kafka implementiert wurden. <br><br><h3>  10.2.  Azure-Ereignis-Hub </h3><br>  Betrachten Sie den Azure Event Hub-Nachrichten-Hub-Dienst.  Es ist ein Dienst, der auf dem PaaS-Modell basiert.  Verschiedene Clientgruppen können als Nachrichtenquellen für den Azure Event Hub fungieren (Abbildung 10.8).  Zunächst einmal handelt es sich um eine sehr große Gruppe von Cloud-Diensten, deren Ausgaben oder Trigger so konfiguriert werden können, dass Nachrichten direkt an den Event Hub gesendet werden.  Dies können Stream Analytics-Jobs, Event Grid und eine wichtige Gruppe von Diensten sein, die Ereignisse umleiten - Protokolle im Event Hub (hauptsächlich mithilfe des AppService erstellt: API-App, Web-App, Mobile App und Funktions-App). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/th/wr/-y/thwr-yanwimel2wqzorsolaojxo.png" alt="Bild"></div><br>  An den Hub übermittelte Nachrichten können direkt erfasst und im Blob-Speicher oder im Data Lake-Speicher gespeichert werden. <br><br>  Die nächste Gruppe von Quellen sind externe Software-Clients oder -Geräte, für die es kein Azure Event Hub-SDK gibt und die nicht direkt in Azure-Dienste integriert werden können.  Zu diesen Clients gehören hauptsächlich IoT-Geräte.  Sie können Nachrichten über HTTPS oder AMQP an den Event Hub senden.  Überlegungen zum Anschließen dieser Geräte gehen über den Rahmen unseres Buches hinaus. <br><br>  Schließlich die Software-Clients, die Nachrichten generieren und diese mithilfe des Azure Event Hub SDK an den Event Hub senden.  Diese Gruppe umfasst Azure PowerShell und die Azure-CLI. <br>  Als Nachrichtenempfänger (Verbraucher - „Verbraucher“) vom Event Hub können Stream Analytics Job oder der Event Grid-Integrationsdienst verwendet werden.  Darüber hinaus ist es möglich, Nachrichten von Software-Clients mithilfe des Azure Event Hub SDK zu empfangen.  Verbraucher stellen über das AMQP 1.0-Protokoll eine Verbindung zum Event Hub her. <br><br>  Berücksichtigen Sie die grundlegenden Konzepte des Azure Event Hub, die erforderlich sind, um zu verstehen, wie er verwendet und konfiguriert wird.  Jede Quelle (in der Dokumentation auch als Herausgeber bezeichnet), die eine Nachricht an den Hub sendet, muss das HTTPS- oder AMQP 1.0-Protokoll verwenden.  Die Wahl eines Protokolls wird durch den Client-Typ, das Kommunikationsnetzwerk und die Anforderungen an die Nachrichtenrate bestimmt.  AMQP erfordert eine permanente Verbindung zwischen zwei bidirektionalen TCP-Sockets.  Es wird durch die Verwendung des TLS-Transportschicht-Verschlüsselungsprotokolls oder von SSL / TLS geschützt.   ,  ,       AMQP   ,  HTTPS,          .      HTTPS. <br><br>     ,         SAS (Shared Access Signature) tokens.          SAS-          SAS   .      SAS-,      (  ). <br><br>         256 .  ,                  . <br><br>  ,      Event Hub.      ,        ,      ,     -.   EventHub     (partitions).   EventHub —    ,     «  —  » (FIFO) (. 10.9). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iq/2g/_p/iq2g_p_ldvolfuahy8admgxqhzo.png" alt="Bild"></div><br>   —       Event Hub.  Event Hub    2  32 ,          Event Hub.   ,          . <br><br>    (    )    ,      (    ,     — . ),       (retention period),   .   .           .       ,  Azure Event Hub    (offset).     —    ,      ,  ,  ,      .          . Azure Event Hub SDK    ,     ,     .       -,         . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fe/ab/bc/feabbcymdq52xiddkbp2vcajz-k.png" alt="Bild"></div><br>  ,          ,     ,       ,    .   Azure Event Hub SDK     ,        .  ,     Storage Account.  Azure,     Event Hub,       . <br><br>     Event Hub     (partition key),          .    —   . ,         (    )          .        ,       (round robin). <br><br>       .      ,       (consumer group) (. 10.11).             .             (view) (     ) ,  ,     .        ,       .     — 20,            ,            . <br><br>          .  ,              .    ,     (throughput unit).         : <br><ul><li>    — 1 M    1000    (   ,       ); </li><li>    — 2 M  . </li></ul><br>         .      ,     .           .         .  !  ,     ,    ,       Event Hub. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i_/l0/jc/i_l0jcqwomkuargf-sygdrfufdc.png" alt="Bild"></div><br>        (namespace) (. 10.12). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jf/de/h-/jfdeh-khouxn6olnkxcgw6-w1a4.png" alt="Bild"></div><br><br>  »Weitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br>  20% <b>Rabatt-</b> Gutschein für <b>Straßenhändler</b> - <b>BigData</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428375/">https://habr.com/ru/post/de428375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428365/index.html">Die Geschichte, wie sich die Google-Abrechnung geändert hat oder wie unnötige Kosten vermieden werden können</a></li>
<li><a href="../de428367/index.html">Wir haben das kleinste Sonarmodem der Welt hergestellt</a></li>
<li><a href="../de428369/index.html">Raus aus Sansaras Rad, Extremismus und ein bisschen Grünzeug - eine Analyse der Aufgaben aus dem GridGain-Booklet auf der Joker 2018-Konferenz</a></li>
<li><a href="../de428371/index.html">Altes IBM-Spiel</a></li>
<li><a href="../de428373/index.html">Das iPhone ist unpraktisch zu bedienen</a></li>
<li><a href="../de428377/index.html">Epigenetische Biomarker des Alterns</a></li>
<li><a href="../de428379/index.html">Der eigentliche Designprozess. Eine Schritt-für-Schritt-Geschichte zum Erstellen einer geschäftsorientierten Website</a></li>
<li><a href="../de428381/index.html">Investition in Höhe von 10 Millionen US-Dollar und Lob von Wozniak - ein langer Weg, um einen Computerdesigner für Kinder zu schaffen</a></li>
<li><a href="../de428383/index.html">Sony hat eine vollständige Liste der Spiele für die PlayStation Classic veröffentlicht</a></li>
<li><a href="../de428385/index.html">Mehr Kaffee, weniger Koffein: Intel 9th ​​Gen (Teil 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>