<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙅 🏇🏼 🚾 Angaben zu Steroiden 🥨 👭 🙃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Thema Abstraktionen und allerlei liebliche Muster ist ein guter Grund für die Entwicklung von Holivars und ewigen Streitigkeiten: Einerseits folge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angaben zu Steroiden</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/singularis/blog/485328/">  Das Thema Abstraktionen und allerlei liebliche Muster ist ein guter Grund für die Entwicklung von Holivars und ewigen Streitigkeiten: Einerseits folgen wir dem Mainstream, allerlei modischen Wörtern und sauberem Code, andererseits haben wir Praxis und Realität, die immer ihre eigenen Regeln diktieren. <br><br>  Was tun, wenn Abstraktionen zu "lecken" beginnen, wie man Sprachchips verwendet und was man aus dem "Spezifikationsmuster" herauspressen kann - siehe unter dem Abschnitt. <br><a name="habracut"></a><br>  Kommen wir also zur Sache.  Der Artikel enthält die folgenden Abschnitte: Zunächst werden wir untersuchen, was das "Spezifikationsmuster" ist und warum seine Anwendung auf reine Datenbankbeispiele Schwierigkeiten verursacht. <br><br>  Als nächstes wenden wir uns Ausdrucksbäumen zu, die ein sehr mächtiges Werkzeug sind, und sehen, wie sie uns helfen können. <br><br>  Am Ende werde ich meine Implementierung der „Spezifikation“ für Steroide demonstrieren. <br><br>  Beginnen wir mit den grundlegenden Dingen.  Ich denke, dass jeder von dem „Spezifikationsmuster“ gehört hat, aber für diejenigen, die es nicht gehört haben, ist hier seine Definition aus <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BF%25D0%25B5%25D1%2586%25D0%25B8%25D1%2584%25D0%25B8%25D0%25BA%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Wikipedia</a> : <br><br><blockquote>  Eine „Spezifikation“ in der Programmierung ist ein Entwurfsmuster, mit dem die Darstellung von Geschäftslogikregeln in eine Kette von Objekten umgewandelt werden kann, die durch boolesche Logikoperationen verbunden sind. <br><br>  Diese Vorlage hebt solche Spezifikationen (Regeln) in der Geschäftslogik hervor, die zum „Koppeln“ mit anderen geeignet sind.  Ein Geschäftslogikobjekt erbt seine Funktionalität von der abstrakten Aggregatklasse CompositeSpecification, die nur eine IsSatisfiedBy-Methode enthält, die einen Booleschen Wert zurückgibt.  Nach der Instanziierung wird das Objekt mit anderen Objekten verkettet.  Infolgedessen können wir problemlos neue Regeln hinzufügen, ohne an Flexibilität beim Einrichten der Geschäftslogik zu verlieren. </blockquote><br>  Mit anderen Worten, eine Spezifikation ist ein Objekt, das die folgende Schnittstelle implementiert (Methoden zum Erstellen von Ketten verwerfen): <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISpecification</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSatisfiedBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> candidate</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  Hier ist alles einfach und klar.  Schauen wir uns nun ein Beispiel aus der realen Welt an, in der es neben der Domäne eine Infrastruktur gibt, die auch eine skrupellose Person ist: Wenden wir uns dem Fall der Verwendung von ORM, einem DBMS und Spezifikationen zum Filtern von Daten in einer Datenbank zu. <br><br>  Um nicht unbegründet zu sein und nicht mit den Fingern zu zeigen, nehmen wir als Beispiel den folgenden Themenbereich: Angenommen, wir entwickeln MMORPGs, wir haben Benutzer, jeder Benutzer hat 1 oder mehr Zeichen und jedes Zeichen hat eine Menge von Gegenständen ( Wir gehen davon aus, dass die Gegenstände für jeden Benutzer einzigartig sind, und für jeden Gegenstand können wiederum Verbesserungsrunen angewendet werden.  Insgesamt in Form eines Diagramms (wir werden die ReadCharacter-Klasse etwas später betrachten, wenn wir über verschachtelte Abfragen sprechen): <br><br><img src="https://habrastorage.org/webt/k5/bx/iw/k5bxiwkvgl5vghoog71-9w6vqdo.png" alt="Bild"><br><br>  Dieses Modell ist lose mit der realen Welt verbunden und enthält auch Felder, die eine gewisse Verbindung mit dem verwendeten ORM widerspiegeln. Dies wird jedoch ausreichen, um die Arbeit zu demonstrieren. <br><br>  Angenommen, wir möchten alle Zeichen herausfiltern, die nach dem angegebenen Datum erstellt wurden. <br>  Dazu schreiben wir eine Spezifikation des folgenden Formulars: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CreatedAfter</span></span>: <span class="hljs-title"><span class="hljs-title">ISpecification</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> DateTime _target; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreatedAfter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime target</span></span></span><span class="hljs-function">)</span></span> { _target = target; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSatisfiedBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> candidate</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> character = candidate <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Character; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(character == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> character.CreatedAt &gt; target; } }</code> </pre><br>  Nun, um diese Spezifikation anzuwenden, gehen wir wie folgt vor (im Folgenden werde ich NHibernate-basierten Code betrachten): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> characters = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> session.Query&lt;Character&gt;().ToListAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreatedAfter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2020</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newCharacters = characters.Where(x =&gt; filter.IsSatisfiedBy(x)).ToArray();</code> </pre><br>  Solange unsere Basis klein ist, wird alles wunderbar und schnell funktionieren, aber wenn unser Spiel mehr oder weniger populär wird und ein paar Zehntausende Nutzer gewinnen, wird all dieser Charme Gedächtnis, Zeit und Geld kosten und es ist besser, dieses Biest sofort zu erschießen weil  Er ist kein Mieter.  In diesem traurigen Fall werden wir die Spezifikation verschieben und mich ein wenig meiner Praxis zuwenden. <br><br>  In einem sehr, sehr fernen Projekt hatte ich einmal Klassen in meinem Code, die Logik zum Abrufen von Daten aus der Datenbank enthielten.  Sie sahen ungefähr so ​​aus: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ICharacterDal</span></span> { <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;Character&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCharactersCreatedAfter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime date</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;Character&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCharactersCreatedBefore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime date</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;Character&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCharactersCreatedBetween</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-function"><span class="hljs-params">, DateTime to</span></span></span><span class="hljs-function">)</span></span>; ... }</code> </pre><br>  und ihre Verwendung: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dal = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CharacterDal(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> createdCharacters = dal.GetCharactersCreatedAfter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2020</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><br>  In den Klassen befand sich die Logik für die Arbeit mit dem DBMS (zu dieser Zeit war es ADO.NET). <br><br>  Alles schien schön zu sein, aber mit der Ausweitung des Projekts wuchsen auch diese Klassen und verwandelten sich in schwer zu pflegende Objekte.  Darüber hinaus gab es einen unangenehmen Nachgeschmack - es scheint eine Geschäftsregel zu sein, aber sie wurden auf Infrastrukturebene gespeichert, da sie an eine bestimmte Implementierung gebunden waren. <br><br>  Dieser Ansatz wurde durch das <i>IQueryable-</i> Repository <i>&lt;T&gt; ersetzt</i> , mit dem alle Regeln direkt in die Domänenschicht übernommen werden konnten. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IRepository</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">IQueryable&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">List</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T obj</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T obj</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br>  was so etwas verwendet wurde: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repository = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Repository(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targetDate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2020</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> createdUsers = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> repository.List().Where(x =&gt; x.CreatedAd &gt; targetDate).ToListAsync();</code> </pre><br>  Ein bisschen netter, aber das Problem ist, dass sich die Regeln entlang des Codes schleichen und die gleiche Überprüfung an Hunderten von Stellen stattfinden kann. Man kann sich leicht vorstellen, was daraus resultieren kann, wenn sich die Anforderungen ändern. <br><br>  Dieser Ansatz verbirgt ein weiteres Problem: Wenn Sie die Abfrage nicht materialisieren, besteht die Möglichkeit, dass mehrere Abfragen in der Datenbank ausgeführt werden, anstatt einer, was sich natürlich nachteilig auf die Systemleistung auswirkt. <br><br>  Und hier in einem der Projekte schlug ein Kollege vor, eine <a href="https://github.com/rjperes/DevelopmentWithADot.NHibernateSpecifications">Bibliothek zu verwenden</a> , die die Implementierung des „Spezifikationsmusters“ auf der Grundlage von Ausdrucksbäumen vorschlug. <br><br>  Kurz gesagt, auf der Grundlage dieser Bibliothek haben wir Spezifikationen erstellt, mit denen wir Filter für Entitäten erstellen und komplexere Filter auf der Grundlage von Verkettungen einfacher Regeln erstellen können.  Zum Beispiel haben wir eine Spezifikation für Zeichen, die nach dem neuen Jahr erstellt wurden, und es gibt eine Spezifikation für die Auswahl von Zeichen mit einem bestimmten Element. Durch Kombinieren dieser Regeln können wir eine Anforderung für eine Liste von Zeichen erstellen, die nach dem neuen Jahr erstellt wurden und das angegebene Element aufweisen.  Und wenn wir in Zukunft die Regel zur Bestimmung neuer Zeichen ändern (zum Beispiel das Datum des chinesischen Neujahrs), werden wir dies nur in der Spezifikation selbst korrigieren und müssen nicht nach allen Verwendungen dieser Logik durch Code suchen! <br><br>  Dieses Projekt wurde erfolgreich abgeschlossen und die Erfahrung mit diesem Ansatz war sehr erfolgreich.  Aber ich wollte nicht stehen bleiben und es gab einige Probleme bei der Implementierung, nämlich: <br><br><ul><li>  Klebeoperator ODER hat nicht funktioniert; </li><li>  Die Vereinigung funktioniert nur für Abfragen, die Filter des Typs Where enthalten. Ich wollte jedoch umfassendere Regeln (verschachtelte Abfragen, Überspringen / Nehmen, Abrufen von Projektionen). <br></li><li>  Spezifikationscode abhängig vom gewählten ORM; </li><li>  ORM-Funktionen konnten nicht verwendet werden, da  Dies führte dazu, dass Abhängigkeiten in die Geschäftslogikebene aufgenommen wurden (z. B. war das Abrufen nicht möglich). <br></li></ul><br>  Das Ergebnis der Lösung dieser Probleme war das <i>Singularis.Secification-</i> Mini-Framework, das aus mehreren Assemblys besteht: <br><br><ul><li>  Singularis.Specification.Definition - Definiert das Spezifikationsobjekt und enthält auch die IQuery-Schnittstelle, mit der die Regel gebildet wird. </li><li>  Singularis.Specification.Executor. * - implementiert ein Repository und ein Objekt zum Ausführen von Spezifikationen für bestimmte ORMs (derzeit von ef.core und NHibernate unterstützt, als Teil der Experimente habe ich auch eine Implementierung für mongodb durchgeführt, aber dieser Code wurde nicht in die Produktion aufgenommen). </li></ul><br>  Schauen wir uns die Implementierung genauer an. <br><br>  Die Spezifikationsschnittstelle definiert die öffentliche Eigenschaft, die die Spezifikationsregel enthält: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISpecification</span></span> { IQuery Query { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } Type ResultType { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISpefication</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;: <span class="hljs-title"><span class="hljs-title">ISpecification</span></span> { }</code> </pre><br>  Darüber hinaus enthält die Schnittstelle die <i>ResultType-</i> Eigenschaft, die den als Ergebnis der Abfrage erhaltenen Entitätstyp zurückgibt. <br><br>  Die Implementierung ist in der <i>Specification &lt;T&gt;</i> -Klasse enthalten, die die <i>ResultType-</i> Eigenschaft implementiert und sie basierend auf der in Query gespeicherten Regel sowie zwei Methoden berechnet: <i>Source ()</i> und <i>Source &lt;TSource&gt; ()</i> .  Diese Methoden dienen dazu, die Quelle der Regel zu bilden.  <i>Mit Source ()</i> wird eine Regel mit einem Typ erstellt, der dem Argument der Spezifikationsklasse entspricht, und mit <i>Source &lt;TSource&gt; ()</i> können Sie eine Regel für eine beliebige Klasse erstellen (die beim Generieren verschachtelter Abfragen verwendet wird). <br><br>  Darüber hinaus gibt es die <i>SpecificationExtension-</i> Klasse, die Erweiterungsmethoden zum Verketten von Anforderungen enthält. <br><br>  Es werden zwei Arten von Verknüpfungen unterstützt: Verkettung (kann als Verknüpfung mit der UND-Bedingung betrachtet werden) und Verknüpfung mit der ODER-Bedingung. <br><br>  Kehren wir zu unserem Beispiel zurück und implementieren unsere beiden Regeln: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CreatedAfter</span></span>: <span class="hljs-title"><span class="hljs-title">Specification</span></span>&lt;<span class="hljs-title"><span class="hljs-title">Character</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreatedAfter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime target</span></span></span><span class="hljs-function">)</span></span> { Query = Source().Where(x =&gt; x.CreatedAt &gt; target); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CreatedBefore</span></span>: <span class="hljs-title"><span class="hljs-title">Specification</span></span>&lt;<span class="hljs-title"><span class="hljs-title">Character</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreatedBefore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime target</span></span></span><span class="hljs-function">)</span></span> { Query = Source().Where(x =&gt; x.CreatedAt &lt; target); } }</code> </pre><br>  und finde alle Benutzer, die beide Regeln erfüllen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> specification = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreatedAfter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2019</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).Combine(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreatedBefore(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2020</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> users = repository.List(specification);</code> </pre><br>  Die Kombination mit der <i>Combine-</i> Methode unterstützt beliebige Regeln.  Die Hauptsache ist, dass der resultierende Typ der linken Seite mit dem Eingabetyp der rechten Seite übereinstimmt.  Auf diese Weise können Sie Regeln erstellen, die Projektionen enthalten, Seitenumbrüche überspringen, Regeln sortieren, Abrufen usw. <br><br>  Die Or-Regel ist restriktiver - sie unterstützt nur Ketten, die Where-Filterbedingungen enthalten.  Betrachten Sie die Verwendung eines Beispiels: Wir finden alle Charaktere, die vor 2000 oder nach 2020 erstellt wurden: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> specification = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreatedAfter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2020</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).Or(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreatedBefore(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2000</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> users = repository.List(specification );</code> </pre><br>  Die <i>IQuery-</i> Schnittstelle wiederholt weitgehend die <i>IQueryable-</i> Schnittstelle, sodass keine besonderen Fragen auftreten sollten.  Lassen Sie uns nur auf bestimmte Methoden eingehen: <br><br>  <i>Fetch / ThenFetch</i> - Mit dieser <i>Option</i> können Sie verwandte Daten zu Optimierungszwecken in die generierte Abfrage <i>einbeziehen</i> .  Das ist natürlich ein bisschen schief, wenn wir Merkmale der Implementierung von Infrastruktur haben, die sich auf Geschäftsregeln auswirken, aber wie gesagt, die Realität ist hart und rein abstrahiert - dies ist eine eher theoretische Sache. <br><br>  <i>Wenn</i> - <i>IQuery</i> zwei Überladungen dieser Methode deklariert, verwendet eine nur einen Lambda-Ausdruck zum Filtern in Form von <i>Expression &lt;Func &lt;T, bool &gt;&gt;</i> und die zweite enthält zusätzliche Parameter <i>IQueryContext</i> , mit denen Sie verschachtelte Unterabfragen ausführen können.  Schauen wir uns ein Beispiel an. <br><br>  Wir haben die ReadCharacter-Klasse im Modell - nehmen wir an, dass unser Modell als Leseteil dargestellt wird, der denormalisierte Daten enthält und zur schnellen Rückmeldung dient, und als Schreibteil, der Links, normalisierte Daten usw. enthält.  Wir möchten alle Zeichen anzeigen, für die der Benutzer E-Mails in einer bestimmten Domäne hat. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CharactersForUserWithEmailDomain</span></span>: <span class="hljs-title"><span class="hljs-title">Specification</span></span>&lt;<span class="hljs-title"><span class="hljs-title">ReadCharacter</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CharactersForUserWithEmailDomain</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> domain</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> usersQuery = Source&lt;User&gt;(x =&gt; x.Email.Contains(domain)).Projection(x =&gt; x.Id); Query = Source().Where((x, ctx) =&gt; ctx.GetQueryResult&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(usersQuery).Contains(x.Id)); } }</code> </pre><br>  Als Ergebnis der Ausführung wird die folgende SQL-Abfrage generiert: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> readcharac0_.id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> id1_3_, readcharac0_.UserId <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> userid2_3_, readcharac0_.Name <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> name3_3_ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ReadCharacters readcharac0_ <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> readcharac0_.UserId <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> user1_.Id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Users</span></span> user1_ <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> user1_.Email <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> (<span class="hljs-string"><span class="hljs-string">'%'</span></span>+@p0+<span class="hljs-string"><span class="hljs-string">'%'</span></span>) ); @p0 = '@inmagna.ca' [Type: String (4000:0:0)]</code> </pre><br>  Um all diese wunderbaren Regeln zu erfüllen, ist die <i>IRepository-</i> Schnittstelle <i>definiert</i> , die es Ihnen ermöglicht, Elemente nach Kennung zu empfangen, eines (das erste geeignete) oder eine Liste von Objekten gemäß der Spezifikation zu empfangen sowie Elemente aus dem Repository zu speichern und zu löschen. <br>  Bei der Definition von Abfragen haben wir herausgefunden, dass es jetzt noch wichtig ist, unserem ORM beizubringen, dies zu verstehen. <br>  Dazu analysieren wir die Assembly von <i>Singularis.Infrastructure.NHibernate</i> (für ef.core sieht alles gleich aus, nur mit den Besonderheiten von ef.core). <br><br>  Der Datenzugriffspunkt ist das Repository-Objekt, das die <i>IRepository-</i> Schnittstelle implementiert.  Im Fall des Empfangs eines Objekts nach ID sowie zum Ändern des Speichers (Speichern / Löschen) beendet diese Klasse eine Sitzung und verbirgt eine bestimmte Implementierung vor der Business-Schicht.  <i>Wenn</i> Sie mit Spezifikationen arbeiten, wird ein <i>IQueryable-</i> Objekt erstellt, das unsere Abfrage in Bezug auf <i>IQuery widerspiegelt</i> , und anschließend für das Sitzungsobjekt ausgeführt. <br><br>  Die Hauptmagie und der hässlichste Code liegt in der Klasse, die für die Konvertierung von <i>IQuery</i> in <i>IQueryable</i> - SpecificationExecutor verantwortlich ist.  Diese Klasse enthält viele Überlegungen, die abfragbare Methoden oder Erweiterungsmethoden eines bestimmten ORM (EagerFetchingExtensionsMethods for NHiberante) aufrufen. <br><br>  Diese Bibliothek wird in unseren Projekten aktiv verwendet (um ehrlich zu sein, wird für unsere Projekte eine bereits aktualisierte Bibliothek verwendet, die jedoch nach und nach öffentlich zugänglich gemacht wird).  Erst vor ein paar Wochen wurde die nächste Version veröffentlicht, die auf asynchrone Methoden umstellte, Fehler in executor'e für ef.core wurden behoben, Tests und Beispiele wurden hinzugefügt.  Es ist wahrscheinlich, dass die Bibliothek Fehler und hundert Optimierungsmöglichkeiten enthält - sie wurde als Nebenprojekt im Rahmen der Arbeit an den Hauptprojekten entwickelt, daher schlage ich gerne Verbesserungsvorschläge vor.  Darüber hinaus sollten Sie sich nicht beeilen, es zu verwenden - es ist wahrscheinlich, dass dies in Ihrem speziellen Fall unnötig oder nicht anwendbar ist. <br><br>  Wann lohnt sich die beschriebene Lösung?  Es ist wahrscheinlich einfacher, von der Frage „Wann sollte ich nicht?“ Auszugehen: <br><br><ul><li>  Highload - Wenn Sie eine hohe Leistung benötigen, wirft die Verwendung von ORM selbst eine Frage auf.  Obwohl es natürlich niemand verbietet, einen Executor zu implementieren, der Abfragen in SQL übersetzt und ausführt ... </li><li>  Sehr kleine Projekte - das ist sehr subjektiv, aber Sie müssen zugeben, dass es so aussieht, als würde man Spatzen aus einer Kanone schießen, wenn man den ORM und den gesamten dazugehörigen Zoo in das Projekt „Aufgabenliste“ zieht. </li></ul><br>  Auf jeden Fall wer das Lesen bis zum Ende gemeistert hat - vielen Dank für Ihre Zeit.  Ich hoffe auf Feedback für die zukünftige Entwicklung! <br><br>  Fast hätte ich vergessen - der Projektcode ist auf GitHub'e verfügbar - <a href="https://github.com/SingularisLab/singularis.specification">https://github.com/SingularisLab/singularis.specification</a> <br><br><div class="spoiler">  <b class="spoiler_title">Baugruppen können über Nuget heruntergeladen werden</b> <div class="spoiler_text"><ul><li>  <a href="https://www.nuget.org/packages/Singularis.Specification.Definition/">https://www.nuget.org/packages/Singularis.Specification.Definition/</a> </li><li>  <a href="https://www.nuget.org/packages/Singularis.Specification.Executor.EntityFramework/">https://www.nuget.org/packages/Singularis.Specification.Executor.EntityFramework/</a> </li><li>  <a href="https://www.nuget.org/packages/Singularis.Specification.Executor.Common/">https://www.nuget.org/packages/Singularis.Specification.Executor.Common/</a> </li><li>  <a href="https://www.nuget.org/packages/Singularis.Specification.Executor.Nhibernate/">https://www.nuget.org/packages/Singularis.Specification.Executor.Nhibernate/</a> </li></ul></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485328/">https://habr.com/ru/post/de485328/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485316/index.html">Alle Google-SERPs sehen jetzt wie Anzeigen aus</a></li>
<li><a href="../de485318/index.html">Hinzufügen von Schönheit und Interaktivität zu Jupyter Notebooks</a></li>
<li><a href="../de485322/index.html">Sprechen Sie über PostgreSQL. Interview mit Alexei Lesovsky im Podcast von Zinc Prod. Teil eins</a></li>
<li><a href="../de485324/index.html">Multithreading in Qt-Widgets</a></li>
<li><a href="../de485326/index.html">Erstellen von Micro-Frontends mit Winkelelementen: Ein Leitfaden für Anfänger</a></li>
<li><a href="../de485330/index.html">Wie man seelenlosen Zufall in Roguelike-Spielen besiegt</a></li>
<li><a href="../de485334/index.html">Sitzungsumfrage</a></li>
<li><a href="../de485336/index.html">Was ist an der ITMO-Universität: Vorträge, Workshops, Wettbewerbe und Unterhaltung</a></li>
<li><a href="../de485338/index.html">So überwinden Sie Ängste und beginnen mit der Verwendung von Azure Machine Learning</a></li>
<li><a href="../de485342/index.html">Wie war das Jahr 2019 im Bereich Mathematik und Informatik?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>