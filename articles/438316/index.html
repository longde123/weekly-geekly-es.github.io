<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöç üíÜüèø ü§òüèø Conceptos b√°sicos de campo de distancia firmados en 2D üíΩ üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø üï¥üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aunque las mallas son la forma m√°s simple y vers√°til de renderizar, existen otras opciones para representar formas en 2d y 3d. Un m√©todo com√∫nmente ut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conceptos b√°sicos de campo de distancia firmados en 2D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438316/">  Aunque las mallas son la forma m√°s simple y vers√°til de renderizar, existen otras opciones para representar formas en 2d y 3d.  Un m√©todo com√∫nmente utilizado son los campos de distancia con signo (SDF).  Los campos de distancia firmados proporcionan un trazado de rayos menos costoso, permiten que diferentes formas fluyan suavemente entre s√≠ y ahorran texturas de baja resoluci√≥n para im√°genes de alta calidad. <br><br>  Comenzaremos generando el signo de los campos de distancia usando funciones en dos dimensiones, pero luego continuaremos gener√°ndolos en 3D.  Usar√© las coordenadas del espacio mundial para que tengamos la menor dependencia posible de la escala y las coordenadas UV, por lo que si no comprende c√≥mo funciona, estudie este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tutorial en una superposici√≥n plana</a> , que explica lo que est√° sucediendo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eb/w-/sj/ebw-sjziw5loorrc2yj1wsl1vyu.gif"></div><a name="habracut"></a><br><h2>  Preparaci√≥n de la base </h2><br>  Eliminaremos temporalmente las propiedades del sombreador de superposici√≥n plana base, porque por ahora nos ocuparemos de la base t√©cnica.  Luego, escribimos la posici√≥n del v√©rtice en el mundo directamente en la estructura del fragmento, y no la convertiremos primero a UV.  En la √∫ltima etapa de preparaci√≥n, escribiremos una nueva funci√≥n que calcula la escena y devuelve la distancia a la superficie m√°s cercana.  Luego llamamos a las funciones y usamos el resultado como un color. <br><br><pre><code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics"</span></span>{ SubShader{ <span class="hljs-comment"><span class="hljs-comment">//           Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //         o.position = UnityObjectToClipPos(v.vertex); //     o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { //      return 0; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = fixed4(dist, dist, dist, 1); return col; } ENDCG } } FallBack "Standard" //fallback   ,       }</span></span></code> </pre> <br>  Escribir√© todas las funciones para los campos de distancia firmados en un archivo separado para que podamos usarlos repetidamente.  Para hacer esto, crear√© un nuevo archivo.  No le agregaremos ning√∫n mal, luego lo configuramos y completamos la protecci√≥n de inclusi√≥n condicional, verificando primero si la variable del preprocesador est√° configurada.  Si a√∫n no est√° definido, lo definimos y completamos la construcci√≥n condicional if despu√©s de las funciones que queremos incluir.  La ventaja de esto es que si agregamos el archivo dos veces (por ejemplo, si agregamos dos archivos diferentes, cada uno de los cuales tiene las funciones que necesitamos, y ambos agregan el mismo archivo), esto romper√° el sombreador.  Si est√° seguro de que esto nunca suceder√°, entonces no puede realizar esta verificaci√≥n. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// in include file // include guards that keep the functions from being included more than once #ifndef SDF_2D #define SDF_2D // functions #endif</span></span></code> </pre> <br>  Si el archivo de inclusi√≥n se encuentra en la misma carpeta que el sombreador principal, simplemente podemos incluirlo usando la construcci√≥n pragma. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// in main shader #include "2D_SDF.cginc"</span></span></code> </pre> <br>  Por lo tanto, solo veremos una superficie negra en la superficie renderizada, lista para mostrar la distancia con un letrero. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25b/a3a/188/25ba3a188962c645fc6a12cfb5aed751.png"></div><br><h2>  C√≠rculo </h2><br>  La funci√≥n m√°s simple del campo de distancia con signo es la funci√≥n de c√≠rculo.  La funci√≥n recibir√° solo la posici√≥n de la muestra y el radio del c√≠rculo.  Comenzamos obteniendo la longitud del vector de posici√≥n de la muestra.  Entonces obtenemos un punto en la posici√≥n (0, 0), que es similar a un c√≠rculo con un radio de 0. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(samplePosition); }</code> </pre> <br>  Luego puede llamar a la funci√≥n de c√≠rculo en la funci√≥n de escena y devolver la distancia que devuelve. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = circle(position, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/839/6a8/f87/8396a8f8780b6b30deb88d1009f6f5c7.png"></div><br>  Luego agregamos el radio a los c√°lculos.  Un aspecto importante de las funciones de distancia con signo es que cuando estamos dentro del objeto, obtenemos una distancia negativa a la superficie (esto es lo que significa la palabra con signo en el campo de distancia con signo de expresi√≥n).  Para aumentar el c√≠rculo a un radio, simplemente restamos el radio de la longitud.  As√≠, la superficie, que est√° en todas partes donde la funci√≥n devuelve 0, se mueve hacia afuera.  Lo que est√° en dos unidades de la distancia desde la superficie para un c√≠rculo con un tama√±o de 0, es solo una unidad de un c√≠rculo con un radio de 1, y una unidad dentro del c√≠rculo (el valor es -1) para un c√≠rculo con un radio de 3; <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(samplePosition) - radius; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7a/b83/57f/e7ab8357f4c844bc7bc58dfda6406d9d.png"></div><br>  Ahora lo √∫nico que no podemos hacer es mover el c√≠rculo desde el centro.  Para solucionar esto, puede agregar un nuevo argumento a la funci√≥n de c√≠rculo para calcular la distancia entre la posici√≥n de muestra y el centro del c√≠rculo, y restar el radio de este valor para definir un c√≠rculo.  O bien, puede redefinir el origen moviendo el espacio del punto de muestra y luego obtener un c√≠rculo en ese espacio.  La segunda opci√≥n parece mucho m√°s complicada, pero dado que mover objetos es una operaci√≥n que queremos usar para todas las figuras, es mucho m√°s universal y, por lo tanto, lo explicar√©. <br><br><h2>  En movimiento </h2><br>  "Transformaci√≥n del espacio de un punto" - suena mucho peor de lo que realmente es.  Esto significa que pasamos el punto a la funci√≥n, y la funci√≥n lo cambia para que podamos usarlo en el futuro.  En el caso de una transferencia, simplemente restamos el desplazamiento del punto.  La posici√≥n se resta cuando queremos mover las formas en la direcci√≥n positiva, porque las formas que representamos en el espacio se mueven en la direcci√≥n opuesta a mover el espacio. <br><br>  Por ejemplo, si queremos dibujar una esfera en la posici√≥n <code>(3, 4)</code> , entonces necesitamos cambiar el espacio para que <code>(3, 4)</code> convierta en <code>(0, 0)</code> , y para esto necesitamos restar <code>(3, 4)</code> .  Ahora, si dibujamos una esfera alrededor de un <i>nuevo</i> punto de origen, ser√° un punto <i>antiguo</i> <code>(3, 4)</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// in sdf functions include file float2 translate(float2 samplePosition, float2 offset){ return samplePosition - offset; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = translate(position, float2(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = circle(circlePosition, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/7ca/6cc/7e57ca6cc1b5953b03811fd2d48ac3f1.png"></div><br><h2>  Rect√°ngulo </h2><br>  Otra forma simple es un rect√°ngulo.  Para empezar, consideramos los componentes por separado.  Primero obtenemos la distancia desde el centro, tomando el valor absoluto.  Luego, de manera similar a un c√≠rculo, restamos la mitad del tama√±o (que esencialmente se asemeja al radio de un rect√°ngulo).  Para mostrar c√≥mo se ver√°n los resultados, por ahora solo devolveremos un componente. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rectangle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, float2 halfSize)</span></span></span></span>{ float2 componentWiseEdgeDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(samplePosition) - halfSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> componentWiseEdgeDistance.x; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14d/d5f/62a/14dd5f62af057366f38cdfaa2bc19315.png"></div><br>  Ahora podemos obtener una versi√≥n barata del rect√°ngulo simplemente devolviendo el componente m√°s grande 2. Esto funciona en muchos casos, pero no correctamente, porque no muestra la distancia correcta alrededor de las esquinas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9c/b19/e06/a9cb19e061cb980c3fe8a2d533b2fbfb.png"></div><br>  Los valores correctos para el rect√°ngulo fuera de la figura se pueden obtener primero tomando el m√°ximo entre las distancias a los bordes y 0, y luego tomando su longitud. <br><br>  Si no limitamos la distancia desde abajo a 0, simplemente calculamos la distancia a las esquinas (donde edgeDistances son <code>(0, 0)</code> ), pero las coordenadas entre las esquinas no caer√°n por debajo de 0, por lo que se usar√° todo el borde.  La desventaja de esto es que 0 se usa como la distancia desde el borde para todo el interior de la figura. <br><br>  Para corregir la distancia 0 para toda la parte interna, debe generar la distancia interna, simplemente usando la f√≥rmula barata del rect√°ngulo (tomando el valor m√°ximo del componente xey), y luego garantizando que nunca exceder√° 0, llevando el valor m√≠nimo de este a 0. Luego agregamos la distancia externa, que nunca es inferior a 0, y la distancia interna, que nunca excede de 0, y obtenemos la funci√≥n de distancia final. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rectangle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, float2 halfSize)</span></span></span></span>{ float2 componentWiseEdgeDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(samplePosition) - halfSize; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outsideDistance = length(max(componentWiseEdgeDistance, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outsideDistance + insideDistance; }</code> </pre> <br>  Como previamente grabamos la funci√≥n de transferencia en una forma universal, ahora tambi√©n podemos usarla para mover su centro a cualquier lugar. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = translate(position, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc0/8eb/671/cc08eb671ae5314ae32d3a20cd685b4b.png"></div><br><h2>  Girar </h2><br>  Girar formas es similar a mover.  Antes de calcular la distancia a la figura, rotamos las coordenadas en la direcci√≥n opuesta.  Para simplificar la comprensi√≥n de las rotaciones tanto como sea posible, multiplicamos la rotaci√≥n por 2 * pi para obtener el √°ngulo en radianes.  Por lo tanto, pasamos una rotaci√≥n a la funci√≥n, donde 0.25 es un cuarto de vuelta, 0.5 es media vuelta y 1 es una vuelta completa (puede realizar conversiones de manera diferente si le parece m√°s natural).  Tambi√©n invertimos la rotaci√≥n, porque necesitamos rotar la posici√≥n en la direcci√≥n opuesta a la rotaci√≥n de la figura por la misma raz√≥n que cuando se mueve. <br><br>  Para calcular las coordenadas rotadas, primero calculamos el seno y el coseno en funci√≥n del √°ngulo.  Hlsl tiene una funci√≥n sincos que calcula ambos valores m√°s r√°pido que cuando se calcula por separado. <br><br>  Al construir un nuevo vector para el componente x, tomamos el componente original x multiplicado por coseno y el componente y multiplicado por seno.  Esto se puede recordar f√°cilmente si recuerda que el coseno de 0 es 1, y cuando se gira por 0, queremos que la componente x del nuevo vector sea exactamente la misma que antes (es decir, multiplique por 1).  El componente y, que anteriormente apuntaba hacia arriba, no contribuy√≥ al componente x, gira hacia la derecha y sus valores comienzan en 0, al principio cada vez m√°s grandes, es decir, su movimiento se describe completamente por un seno. <br><br>  Para la componente y del nuevo vector, multiplicamos el coseno por la componente y del viejo vector y restamos el seno multiplicado por la vieja componente x.  Para comprender por qu√© restamos, en lugar de sumar el seno, multiplicado por el componente x, es mejor imaginar c√≥mo cambia el vector <code>(1, 0)</code> cuando se gira en sentido horario.  El componente y del resultado comienza en 0 y luego se convierte en menos de 0. Esto es lo contrario de c√≥mo se comporta el seno, por lo que cambiamos el signo. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotation)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PI = <span class="hljs-number"><span class="hljs-number">3.14159</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = rotation * PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sine, cosine; sincos(angle, sine, cosine); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); }</code> </pre> <br>  Ahora que hemos escrito el m√©todo de rotaci√≥n, podemos usarlo en combinaci√≥n con la transferencia para mover y rotar la figura. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y); circlePosition = translate(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d46/99b/da0/d4699bda0f35c10163998bd22fac5eab.gif"></div><br>  En este caso, primero rotamos el objeto alrededor del centro de toda la escena, de modo que la rotaci√≥n tambi√©n afecta la transferencia.  Para rotar una figura en relaci√≥n con su propio centro, primero debe moverla y luego rotarla.  Debido a este cambio de orden en el momento de la rotaci√≥n, el centro de la figura se convertir√° en el centro del sistema de coordenadas. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = position; circlePosition = translate(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); circlePosition = rotate(circlePosition, _Time.y); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e5/3f3/12d/8e53f312d343fcbe95d000703001da3c.gif"></div><br><h2>  Escalamiento </h2><br>  La escala funciona de manera similar a otras formas de transformar formas.  Dividimos las coordenadas por escala, representando la figura en el espacio con una escala reducida, y en el sistema de coordenadas base se hacen m√°s grandes. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scale</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 samplePosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> samplePosition / scale; }</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = position; circlePosition = translate(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); circlePosition = rotate(circlePosition, <span class="hljs-number"><span class="hljs-number">.125</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pulseScale = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y * <span class="hljs-number"><span class="hljs-number">3.14</span></span>); circlePosition = scale(circlePosition, pulseScale); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e66/043/a58/e66043a5877fbdcbcc38629d70334481.gif"></div><br>  Aunque esto realiza la escala correctamente, la distancia tambi√©n se escala.  La principal ventaja del campo de distancia con signo es que siempre sabemos la distancia a la superficie m√°s cercana, pero el alejamiento destruye por completo esta propiedad.  Esto se puede solucionar f√°cilmente multiplicando el campo de distancia obtenido de la funci√≥n de distancia del signo (en nuestro caso, el <code>rectangle</code> ) por la escala.  Por la misma raz√≥n, no podemos escalar f√°cilmente de manera desigual (con diferentes escalas para los ejes x e y). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position)</span></span></span><span class="hljs-function"> </span></span>{ float2 circlePosition = position; circlePosition = translate(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); circlePosition = rotate(circlePosition, <span class="hljs-number"><span class="hljs-number">.125</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pulseScale = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y * <span class="hljs-number"><span class="hljs-number">3.14</span></span>); circlePosition = scale(circlePosition, pulseScale); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = rectangle(circlePosition, float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) * pulseScale; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sceneDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/1bd/da1/8021bdda196f8300516f04cdf965c8af.gif"></div><br><h2>  Visualizaci√≥n </h2><br>  Los campos de distancia firmados se pueden usar para una variedad de cosas, como crear sombras, renderizar escenas 3D, f√≠sica y renderizar texto.  Pero a√∫n no queremos profundizar en la complejidad, por lo tanto, explicar√© solo dos t√©cnicas de su visualizaci√≥n.  La primera es una forma clara con antialiasing, la segunda es la representaci√≥n de l√≠neas dependiendo de la distancia. <br><br><h3>  Forma clara </h3><br>  Este m√©todo es similar al que se usa a menudo al representar texto, crea una forma clara.  Si queremos generar un campo de distancia no desde una funci√≥n, sino leerlo desde una textura, esto nos permite usar texturas con una resoluci√≥n mucho m√°s baja de lo habitual y obtener buenos resultados.  TextMesh Pro utiliza esta t√©cnica para representar texto. <br><br>  Para aplicar esta t√©cnica, aprovechamos el hecho de que los datos en los campos de distancia est√°n firmados y conocemos el punto de corte.  Comenzamos calculando qu√© tan lejos cambia el campo de distancia al siguiente p√≠xel.  Este deber√≠a ser el mismo valor que la longitud del cambio de coordenadas, pero es m√°s f√°cil y m√°s confiable calcular la distancia con un signo. <br><br>  Habiendo recibido el cambio de distancia, podemos hacer un paso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">suave</a> desde la mitad del cambio de distancia a menos / m√°s la mitad del cambio de distancia.  Esto realizar√° un recorte simple alrededor de 0, pero con suavizado.  Luego puede usar este valor suavizado para cualquier valor binario que necesitemos.  En este ejemplo, cambiar√© el sombreador a un sombreador de transparencia y lo usar√© para el canal alfa.  Doy un paso suave de un valor positivo a uno negativo porque queremos que el valor negativo del campo de distancia sea visible.  Si no comprende bien c√≥mo funciona el procesamiento de transparencias aqu√≠, le recomiendo leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi tutorial sobre</a> procesamiento de transparencias. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//properties Properties{ _Color("Color", Color) = (1,1,1,1) }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in subshader outside of pass Tags{ "RenderType"="Transparent" "Queue"="Transparent"} Blend SrcAlpha OneMinusSrcAlpha ZWrite Off</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = scene(i.worldPos.xz); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(dist) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> antialiasedCutoff = smoothstep(distanceChange, -distanceChange, dist); fixed4 col = fixed4(_Color, antialiasedCutoff); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86d/a08/e1c/86da08e1cfcb25212c6bf3c22dfa1dc8.gif"></div><br><h3>  Lineas de elevacion </h3><br>  Otra t√©cnica com√∫n para visualizar campos de distancia es mostrar distancias como l√≠neas.  En nuestra implementaci√≥n, agregar√© algunas l√≠neas gruesas y algunas l√≠neas finas entre ellas.  Tambi√©n pintar√© el interior y el exterior de la figura en diferentes colores para que pueda ver d√≥nde est√° el objeto. <br><br>  Comenzaremos mostrando la diferencia entre el interior y el exterior de la figura.  Los colores se pueden personalizar en el material, por lo que agregaremos nuevas propiedades, as√≠ como variables de sombreado para los colores internos y externos de la figura. <br><br><pre> <code class="cpp hljs">Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//global shader variables float4 _InsideColor; float4 _OutsideColor;</span></span></code> </pre> <br>  Luego, en el sombreador de fragmentos, verificamos d√≥nde se encuentra el p√≠xel, que representamos comparando la distancia con el signo con 0 usando la funci√≥n de <code>step</code> .  Utilizamos esta variable para interpolar de color interno a externo y representarla en la pantalla. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(<span class="hljs-number"><span class="hljs-number">0</span></span>, dist)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/13c/15b/98913c15b68cb3fcca4b6d1e4a3f70c0.gif"></div><br>  Para renderizar l√≠neas, primero debemos especificar con qu√© frecuencia renderizaremos l√≠neas y qu√© tan gruesas ser√°n, configurando las propiedades y las variables de sombreado correspondientes. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Properties _LineDistance("Mayor Line Distance", Range(0, 2)) = 1 _LineThickness("Mayor Line Thickness", Range(0, 0.1)) = 0.05</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//shader variables float _LineDistance; float _LineThickness;</span></span></code> </pre> <br>  Luego, para representar las l√≠neas, comenzaremos calculando el cambio en la distancia para poder usarlo m√°s tarde para suavizar.  Tambi√©n ya lo dividimos entre 2, porque luego sumamos la mitad y restamos la mitad para cubrir la distancia de cambio de 1 p√≠xel. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(dist) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>;</code> </pre> <br>  Luego tomamos la distancia y la transformamos para que tenga el mismo comportamiento en los puntos repetidos.  Para hacer esto, primero lo dividimos por la distancia entre las l√≠neas, mientras que no obtendremos n√∫meros completos en cada primer paso, sino n√∫meros completos solo en funci√≥n de la distancia que establezcamos. <br><br>  Luego sumamos 0.5 al n√∫mero, tomamos la parte fraccional y restamos 0.5 nuevamente.  La parte fraccionaria y la resta son necesarias aqu√≠ para que la l√≠nea pase por cero en el patr√≥n repetitivo.  Agregamos 0.5 para obtener la parte fraccionaria para neutralizar una substracci√≥n adicional de 0.5; el desplazamiento conducir√° al hecho de que los valores en los que el gr√°fico es 0 est√°n en 0, 1, 2, etc., y no en 0.5, 1.5, etc. <br><br>  Los √∫ltimos pasos para convertir el valor: tomamos el valor absoluto y nuevamente lo multiplicamos por la distancia entre las l√≠neas.  El valor absoluto hace que las √°reas antes y despu√©s de los puntos de la l√≠nea permanezcan iguales, lo que facilita la creaci√≥n de recorte para las l√≠neas.  La √∫ltima operaci√≥n, en la que nuevamente multiplicamos el valor por la distancia entre las l√≠neas, es necesaria para neutralizar la divisi√≥n al comienzo de la ecuaci√≥n, gracias a esto, el cambio en el valor es nuevamente el mismo que al principio, y el cambio calculado previamente en la distancia sigue siendo correcto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a89/db3/de9/a89db3de916eaf871c4525348272a635.png"></div><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLineDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(frac(dist / _LineDistance + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _LineDistance;</code> </pre> <br>  Ahora que hemos calculado la distancia a las l√≠neas en funci√≥n de la distancia a la figura, podemos dibujar las l√≠neas.  Hacemos un paso suave desde el grosor de l√≠nea menos la mitad del cambio en la distancia hasta el grosor de l√≠nea m√°s la mitad del cambio en la distancia y usamos la distancia de la l√≠nea reci√©n calculada como un valor para la comparaci√≥n.  Despu√©s de calcular este valor, lo multiplicamos por color para crear l√≠neas negras (tambi√©n puede cambiar a un color diferente si necesita l√≠neas multicolores). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(<span class="hljs-number"><span class="hljs-number">0</span></span>, dist)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(dist) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLineDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(frac(dist / _LineDistance + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _LineDistance; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col * majorLines; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/890/6b1/452/8906b1452c9d7a05f39b5c3070f2c547.gif"></div><br>  Implementamos l√≠neas delgadas entre gruesas de la misma manera: agregamos una propiedad que determina cu√°ntas l√≠neas delgadas deben estar entre las gruesas, y luego hacemos lo que hicimos con las gruesas, pero debido a la distancia entre l√≠neas delgadas, dividimos la distancia entre las gruesas por el n√∫mero de l√≠neas delgadas entre ellos.  Tambi√©n haremos el n√∫mero de l√≠neas finas <code>IntRange</code> , gracias a esto solo podemos asignar valores enteros y no obtener l√≠neas finas que no <code>IntRange</code> gruesas.  Despu√©s de calcular l√≠neas finas, las multiplicamos por color de la misma manera que las gruesas. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//properties [IntRange]_SubLines("Lines between major lines", Range(1, 10)) = 4 _SubLineThickness("Thickness of inbetween lines", Range(0, 0.05)) = 0.01</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//shader variables float _SubLines; float _SubLineThickness;</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(<span class="hljs-number"><span class="hljs-number">0</span></span>, dist)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(dist) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLineDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(frac(dist / _LineDistance + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _LineDistance; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceBetweenSubLines = _LineDistance / _SubLines; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> subLineDistance = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(frac(dist / distanceBetweenSubLines + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * distanceBetweenSubLines; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> col * majorLines * subLines; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8c/664/bf0/e8c664bf0fb16337f77f242c4f3f5c01.gif"></div><br><h2>  C√≥digo fuente </h2><br><h3>  Caracter√≠sticas 2D SDF </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/2D_SDF.cginc</a> </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SDF_2D #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDF_2D float2 rotate(float2 samplePosition, float rotation){ const float PI = 3.14159; float angle = rotation * PI * 2 * -1; float sine, cosine; sincos(angle, sine, cosine); return float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); } float2 translate(float2 samplePosition, float2 offset){ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//move samplepoint in the opposite direction that we want to move shapes in return samplePosition - offset; } float2 scale(float2 samplePosition, float scale){ return samplePosition / scale; } float circle(float2 samplePosition, float radius){ //get distance from center and grow it according to radius return length(samplePosition) - radius; } float rectangle(float2 samplePosition, float2 halfSize){ float2 componentWiseEdgeDistance = abs(samplePosition) - halfSize; float outsideDistance = length(max(componentWiseEdgeDistance, 0)); float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0); return outsideDistance + insideDistance; } #endif</span></span></span></span></code> </pre> <br><h3>  Ejemplo de c√≠rculo </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/Circle.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics/Rectangle"</span></span>{ SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y * 0.5); circlePosition = translate(circlePosition, float2(2, 0)); float sceneDistance = rectangle(circlePosition, float2(1, 2)); return sceneDistance; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = fixed4(dist, dist, dist, 1); return col; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br><h3>  Ejemplo de rect√°ngulo </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/Rectangle.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics/Rectangle"</span></span>{ SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y * 0.5); circlePosition = translate(circlePosition, float2(2, 0)); float sceneDistance = rectangle(circlePosition, float2(1, 2)); return sceneDistance; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = fixed4(dist, dist, dist, 1); return col; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br><h3>  Corte </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/Cutoff.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics/Cutoff"</span></span>{ Properties{ _Color(<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) } SubShader{ Tags{ <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span>} Blend SrcAlpha OneMinusSrcAlpha ZWrite Off Pass{ CGPROGRAM #include <span class="hljs-string"><span class="hljs-string">"UnityCG.cginc"</span></span> #include <span class="hljs-string"><span class="hljs-string">"2D_SDF.cginc"</span></span> #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2f</span></span></span><span class="hljs-class">{</span></span> float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; fixed3 _Color; <span class="hljs-function"><span class="hljs-function">v2f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(appdata v)</span></span></span></span>{ v2f o; <span class="hljs-comment"><span class="hljs-comment">//calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y * 0.5); circlePosition = translate(circlePosition, float2(2, 0)); float sceneDistance = rectangle(circlePosition, float2(1, 2)); return sceneDistance; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); float distanceChange = fwidth(dist) * 0.5; float antialiasedCutoff = smoothstep(distanceChange, -distanceChange, dist); fixed4 col = fixed4(_Color, antialiasedCutoff); return col; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br><h3>  L√≠neas de distancia </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/DistanceLines.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/034_2D_SDF_Basics/DistanceLines"</span></span>{ Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _LineDistance(<span class="hljs-string"><span class="hljs-string">"Mayor Line Distance"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">1</span></span> _LineThickness(<span class="hljs-string"><span class="hljs-string">"Mayor Line Thickness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.05</span></span> [IntRange]_SubLines(<span class="hljs-string"><span class="hljs-string">"Lines between major lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) = <span class="hljs-number"><span class="hljs-number">4</span></span> _SubLineThickness(<span class="hljs-string"><span class="hljs-string">"Thickness of inbetween lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.05</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.01</span></span> } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float2 circlePosition = position; circlePosition = rotate(circlePosition, _Time.y * 0.2); circlePosition = translate(circlePosition, float2(2, 0)); float sceneDistance = rectangle(circlePosition, float2(1, 2)); return sceneDistance; } float4 _InsideColor; float4 _OutsideColor; float _LineDistance; float _LineThickness; float _SubLines; float _SubLineThickness; fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(0, dist)); float distanceChange = fwidth(dist) * 0.5; float majorLineDistance = abs(frac(dist / _LineDistance + 0.5) - 0.5) * _LineDistance; float majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); float distanceBetweenSubLines = _LineDistance / _SubLines; float subLineDistance = abs(frac(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines; float subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); return col * majorLines * subLines; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br>  Espero haber logrado explicar los conceptos b√°sicos de los campos de distancia con un signo, y ya est√° esperando algunos tutoriales nuevos en los que hablar√© sobre otras formas de usarlos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438316/">https://habr.com/ru/post/438316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438304/index.html">Subcontrataci√≥n? Genial, golpeas</a></li>
<li><a href="../438306/index.html">Radiaci√≥n: Laboratorio radioqu√≠mico de lunes a viernes.</a></li>
<li><a href="../438310/index.html">Instagram utiliza el aprendizaje autom√°tico para eliminar seguidores falsos</a></li>
<li><a href="../438312/index.html">Automatizaci√≥n de red con Ansible: m√≥dulo de comando</a></li>
<li><a href="../438314/index.html">1. Check Point Maestro Hyperscale Network Security - una nueva plataforma de seguridad escalable</a></li>
<li><a href="../438318/index.html">C√≥mo dominar la sintaxis async / await: un ejemplo real</a></li>
<li><a href="../438320/index.html">Ense√±ar a los ni√±os a programar</a></li>
<li><a href="../438322/index.html">VSaaS 2025: tecnolog√≠a de CCTV del futuro</a></li>
<li><a href="../438326/index.html">5G en Rusia: ¬øpor qu√© es necesario, cu√°nto cuesta y cu√°ndo aparecer√°? Brevemente sobre lo principal</a></li>
<li><a href="../438328/index.html">¬øC√≥mo se infl√≥ la burbuja salarial para los programadores?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>