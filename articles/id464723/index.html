<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏥 👧🏾 🤽🏾 Rekayasa kekacauan ♏️ 🚂 🦓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hal terakhir yang ingin Anda lihat selama debugging kode adalah kekacauan . Tetapi bagaimana jika kekacauan ini dikendalikan dan diluncurkan oleh tang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rekayasa kekacauan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/464723/">  <em>Hal terakhir yang ingin Anda lihat selama debugging kode adalah kekacauan</em> <em>.</em>  <em>Tetapi bagaimana jika kekacauan ini dikendalikan dan diluncurkan oleh tangan pengembang sendiri?</em>  <em>Mengapa dengan sengaja mengatur turbulensi dalam kelancaran aplikasi Anda, cara mencapai ketenangan pikiran saat merilis fitur-fitur penting dan di mana tepatnya praktik rekayasa chaos bermanfaat</em> <em>, baca PavelOsipov dalam percakapan antara podcast AppsCast terkemuka dan Pavel Osipov.</em> <br><br><img src="https://habrastorage.org/webt/ux/2a/-7/ux2a-7hlcywounaw27j7qihz6gg.jpeg"><br><a name="habracut"></a><br>  <strong>Alexey Kudryavtsev:</strong> Halo semuanya!  Hari ini, tamu kami adalah Pavel Osipov dari Mail.ru Cloud, yang dengannya kami akan berbicara tentang rekayasa kekacauan. <br><br>  <strong>Pavel Osipov:</strong> Halo semuanya!  Selama enam tahun saya telah mengelola pengembangan Cloud Mail.ru.  Selama ini, kami telah mengumpulkan banyak praktik pengujian ekonomi, dan salah satunya adalah rekayasa chaos.  Praktek ini memungkinkan Anda untuk melakukan serangkaian percobaan terkontrol untuk mengidentifikasi kesehatan sistem Anda di lingkungan yang tidak bersahabat.  Berdasarkan hasil percobaan ini, Anda mendapatkan wawasan yang bermanfaat.  Misalnya, Anda tidak mungkin melihat secara teratur bagaimana sistem berperilaku dalam jaringan yang tidak stabil.  Jika pengguna Anda sering bepergian di kereta bawah tanah atau beristirahat di lingkungan wifi hotel, jaringannya tidak stabil seperti di tempat kerja programmer.  Setelah setiap liburan saya di laut, saya membawa seluruh "portofolio" log tentang apa yang salah dengan aplikasi tersebut. <br><br><blockquote>  Secara pribadi, membiakkan kekacauan manual memungkinkan saya mendapatkan dosis tambahan kepercayaan bahwa semuanya akan berjalan dengan baik, bahkan jika semuanya buruk di luar aplikasi. </blockquote><br>  Ada situasi ketika saya lebih mempercayai kekacauan manual daripada tes otomatis. <br><br><h2>  Melihat akar kekacauan </h2><br>  <strong>Alexei Kudryavtsev:</strong> Dari mana asalnya praktik seperti itu? <br><br>  <strong>Pavel Osipov:</strong> Ini adalah praktik server, di mana ada banyak masalah lagi.  Kita terbiasa dengan konsep utang teknis, dan di Barat juga ada <strong>utang gelap</strong> - utang tersembunyi yang tak terhindarkan muncul dalam sistem yang kompleks.  Tidak seperti utang teknis, di mana kita secara sadar meminjam waktu masa depan dari masa kini, utang tersembunyi tidak terlihat pada tahap menciptakan sistem.  Itu terjadi di persimpangan komponen atau perangkat keras dan perangkat lunak dan dapat menyebabkan kaskade masalah: sesuatu rusak pada satu komponen, tumpang tindih yang lain, dan sekarang seluruh sistem terletak. <br><br>  Misalnya, pada tahun 2016, karena shutdown basis data cascading, 2,5 jam berbaring Facebook.  Kemudian sistem yang memeriksa validitas file konfigurasi mulai menghapusnya secara tidak sengaja, tidak hanya dalam subsistem caching, tetapi juga dalam database yang merupakan sumber utama. <br><br>  Saya sangat suka wawancara dengan Oleg Anastasiev dari Odnoklassniki tentang melakukan latihan untuk mencegah kecelakaan infrastruktur.  Mereka memiliki tiga pusat data, yang harus siaga 24/7, tetapi sekali seperempat jenis kegagalan terjadi.  Mereka melakukan latihan produksi.  Di satu sisi, ini tampak menakutkan, karena jika sesuatu yang tidak terduga terjadi, seluruh pusat data akan jatuh dan tidak akan tersedia di prod.  Tetapi di sisi lain, proses ini dikendalikan dan jika terjadi kesalahan, maka Anda akan segera melihatnya, hentikan, dan semuanya akan dipulihkan.  Jika ini terjadi dalam kondisi kehidupan tempur, maka menyalakannya kembali tidak akan berhasil, dan analisis alasan penutupan akan berlarut-larut untuk waktu yang lama. <br><br><h2>  Manfaat kekacauan dalam pengembangan ponsel </h2><br>  <strong>Daniil Popov:</strong> Sejauh ini, kita berbicara tentang pengembangan server, di mana layanan microser populer dan pemadaman cascading dimungkinkan.  Bisakah Anda memberikan lebih banyak contoh tentang apa yang harus diperiksa melalui rekayasa kekacauan dalam pengembangan seluler? <br><br>  <strong>Pavel Osipov:</strong> Contoh favorit saya adalah pendataan aplikasi.  Dalam kondisi pengujian, tindakan kami dapat menjadi sangat lembut sehubungan dengan aplikasi: kami masuk ke pengaturan akun, mengklik tombol "keluar", aplikasi keluar dan, saat melihat layar masuk, semuanya tampak baik-baik saja.  Pengguna sering memiliki situasi yang lebih eksotis.  Misalnya, klien mengubah kata sandi melalui antarmuka web atau sejumlah besar log terjadi pada perangkat lain dan token penyegaran digantikan.  Pencatatan ini terjadi bukan di jendela dengan akun pengguna, tetapi, misalnya, pada saat penampil foto layar penuh. <br><br>  Kami menemukan banyak situasi ketika masuk ke berbagai tempat aplikasi menyebabkan konsekuensi seperti kebocoran memori.  Penampil yang sama dengan blok penyelesaian dapat mengambil layanan penting, yang akhirnya bocor. <br><br>  Kami mensimulasikan kondisi menggunakan rekayasa kekacauan.  Sistem memiliki layanan yang transparan untuk layanan aplikasi tingkat tinggi memperbarui token akses aplikasi menggunakan token penyegaran aplikasi.  Kami memperkenalkan kekacauan di mana layanan, alih-alih memperbarui token, dengan tingkat probabilitas tertentu merusaknya, dan setiap pengembang menemukan log beberapa kali sehari di tempat yang tidak terduga. <br><br>  Berkat ini, kami menemukan perilaku UIKit yang menarik di iOS: jika, ketika ViewController yang di-root disorot, jendela lain diblokir secara modern dari jendela, maka ViewController yang di-root bocor dan tetap berada dalam sistem selamanya.  Jika pada saat yang sama ViewController memiliki tautan ke layanan yang, menurut logika arsitektur, harus ada dalam sistem dalam satu contoh, maka masalah tidak dapat dihindari.  Misalnya, Cloud memiliki layanan pengisian-otomatis foto, dan jika dua layanan seperti itu tetap ada dalam sistem, mereka akan melakukan banyak pekerjaan yang tidak perlu dan menempatkan baterai perangkat dua kali lebih cepat dari yang seharusnya. <br><br>  Kasus penasaran lain.  Ketika iOS 8 muncul, ada masalah dengan ekstensi: pada beberapa perangkat, ketika semua izin dalam pengaturan aplikasi diberikan, di awal sistem menyatakan bahwa aplikasi tidak memiliki akses ke grup aplikasi bersama. <br><br><h2>  Tipologi kekacauan </h2><br>  <strong>Daniil Popov:</strong> Kekacauan dimasukkan ke dalam sistem secara otomatis berdasarkan minat atau konfigurasi, tetapi apakah seseorang perlu melihat untuk memahami apa yang salah? <br><br>  <strong>Pavel Osipov:</strong> Kekacauan berbeda: baik manual maupun otomatis.  Dalam kasus sistem operasi, yang mengatakan bahwa aplikasi tidak memiliki akses ke grup aplikasi bersama, dan ekstensi tidak dapat mengakses sumber daya bersama dan database, kekacauan manual digunakan, yang dihidupkan menggunakan tanda centang dalam pengaturan sistem aplikasi.  Ini bisa dengan mudah dimodelkan oleh orang-orang dari tim QA. <br><br>  Ada kekacauan otomatis.  Secara khusus, ini adalah kesalahan yang dimodelkan dari layanan microser dari backend kami, dan kekacauan terkait dengan memperbarui token.  Konsekuensinya berbeda.  Tata letak perjalanan dapat ditentukan melalui pengamatan visual.  Ada tempat yang memungkinkan Anda mendeteksi anomali dalam mode otomatis.  Misalnya, dalam aplikasi kami, kebocoran memori secara otomatis terdeteksi.  Ada dua wadah IoC dalam sistem.  Satu manajer adalah masa pakai layanan global, yang bertepatan dengan masa pakai aplikasi itu sendiri, wadah lainnya adalah pengelola layanan yang bertepatan waktu dengan pengguna.  Setiap wadah IoC, membuat layanan, memeriksa apakah ada dalam satu contoh. <br><br>  Mari kita kembali ke contoh dengan log.  Di beberapa tempat, masuk tiba-tiba terjadi dan pengembang memasukkan kembali akun untuk terus bekerja.  Pada titik ini, wadah IoC melaporkan bahwa kebocoran memori telah terjadi, dan layanan, yang secara teori seharusnya ada dalam satu contoh, terdeteksi lagi. <br><br><h2>  Kapan waktu kekacauan? </h2><br>  <strong>Alexei Kudryavtsev:</strong> Apa yang menjadi pemicu implementasi praktik ini? <br><br>  <strong>Pavel Osipov:</strong> Kami sampai pada ini melalui kebutuhan untuk mengurangi biaya pengujian.  Bagaimana kita bisa mengatasi masalah razlogin yang sama?  Anda dapat menulis unit test untuk kebocoran, Anda bisa bingung dan menulis tes UI. <br><br><blockquote>  Rekayasa kekacauan adalah praktik termurah, karena tidak terikat pada kasus pengguna, tetapi bertindak secara otomatis untuk semua kasus pengguna bersama-sama. </blockquote><br>  Pemicu kedua - sebelum praktik diperkenalkan, dalam laporan kerusakan kami, sering terjadi kemacetan serupa dengan akar penyebab yang sama.  Misalnya, kecelakaan itu terjadi bukan karena sistem masuk ke profil, tetapi karena pengguna sedang menelusuri galeri foto pada waktu itu.  Situasinya berbeda, dan tidak mungkin menguji semua kombinasi razlogin.  Jadi saya ingin membuat sesuatu yang mengotomatiskan proses. <br><br>  Rekayasa kekacauan memiliki praktik terkait - <strong>pengujian mutasional</strong> .  Dalam praktik ini, kami memodifikasi potongan kode kecil dan melihat bagaimana ini memengaruhi tes.  Jika, setelah perubahan, tes dilakukan dengan benar, itu berarti bahwa untuk fragmen kode tes tidak cukup. <br><br><blockquote>  Perbedaan antara rekayasa kekacauan dan pengujian mutasi adalah bahwa kita tidak secara otomatis mengubah kode produksi itu sendiri, tetapi lingkungannya. </blockquote><br>  <strong>Alexei Kudryavtsev:</strong> Mungkinkah untuk melokalisasi penyebab dan memperbaikinya tanpa rekayasa kekacauan? <br><br>  <strong>Pavel Osipov:</strong> Tidak ada alasan tunggal yang memancing crash.  Setiap kasing unik dengan caranya sendiri.  Sebagai contoh, tombol modal muncul di atas jendela, dan ini menyebabkan ViewController yang rusak bocor selama razlog.  Tidak mungkin untuk meramalkan semua kombinasi hierarki jendela yang Anda miliki selama pencatatan.  Teknik kekacauan pola lokal di mana kebocoran dan crash terjadi. <br><br>  <strong>Alexei Kudryavtsev:</strong> Berapa lama Anda menggunakan latihan ini? <br><br>  <strong>Pavel Osipov:</strong> Kami mulai menggunakannya pada awal proyek pada 2012, karena itu perlu untuk mengembangkannya dengan cepat, dan tidak ada waktu yang dialokasikan untuk pengujian skala besar.  Selain itu, ini tidak hanya mengesankan, tetapi juga pengalaman yang positif. <br><br>  <strong>Daniil Popov:</strong> Jika ada sesuatu yang gagal pada aplikasi saya dan saya harus memulai tugas di JIRA, apa yang dapat saya perbaiki di masa depan, bagaimana saya dapat mereproduksi situasi ini? <br><br>  <strong>Pavel Osipov:</strong> Tidak ada resep universal.  Rekayasa kekacauan diaktifkan pada saat debugging aplikasi dan dinonaktifkan pada saat pembuatan versi rilis, oleh karena itu situasi seperti itu dapat dilihat melalui log di konsol lingkungan pengembangan, dari mana Anda dapat mengetahui cara menempatkan tugas di JIRA. <br><br>  <strong>Alexei Kudryavtsev:</strong> Apakah Anda mencoba membuat perilaku yang dapat direproduksi sehingga sistem kekacauan Anda memberi tahu Anda tentang masalah dan menyarankan untuk memasukkannya ke dalam konfigurasi di awal untuk mengulangi keadaan ini? <br><br>  <strong>Pavel Osipov:</strong> Kedengarannya kosmik dan mungkin dalam arsitektur seperti Redux.  Jika arsitektur memungkinkan Anda untuk merekam semua tindakan yang mendahului peristiwa penting, maka hal ini dimungkinkan.  Ini tidak terjadi pada kita.  Ini dipraktekkan ketika saya bekerja sebagai programmer serveride di bidang telekomunikasi.  Ada tes yang mengacak pintu masuk ke subsistem dan memeriksa output yang memadai.  Kami mencapai bahwa ketika pengujian dengan input acak menabrak sistem, dan dalam program yang bertanggung jawab untuk pengujian otomatisasi, semua parameter yang diperlukan dari permintaan input ditunda sehingga dapat direproduksi. <br><br><h2>  Terapkan kekacauan dalam aplikasi </h2><br>  <strong>Daniil Popov:</strong> Apakah benar kekacauan seperti itu dimasukkan ke dalam kode dengan tangan? <br><br>  <strong>Pavel Osipov:</strong> Ya, klien jaringan kami memiliki fungsionalitas bawaan di mana Anda dapat mengirim konfigurasi, yang menjelaskan parameter kekacauan yang harus direproduksi.  Berdasarkan konfigurasi, ia memutuskan untuk mem-proxy permintaan klien ke server atau untuk menanggapi omong kosong sendiri.  Lapisan untuk bekerja dengan jaringan sedemikian rupa sehingga Anda dapat menyesuaikan kekacauan yang diperkenalkan oleh layanan mikro di backend.  Tidak masuk akal untuk memodelkan kesalahan dalam validitas data otorisasi jika permintaan layanan mikro tidak memerlukan otorisasi. <br><br><blockquote>  Kami tidak hanya mengacak semuanya, memainkan kode yang sempurna, tetapi juga mengacak apa yang dapat direproduksi oleh pengguna di kehidupan nyata. </blockquote><br>  <strong>Alexei Kudryavtsev:</strong> Apa yang Anda acakkan dari jaringan dan file? <br><br>  <strong>Pavel Osipov:</strong> Kami mendebat praktik pengacakan respons dari titik akhir spesifik untuk memodelkan perilaku dan kekacauan masing-masing layanan mikro secara terpisah.  Kami telah menyelesaikan pekerjaan memindahkan sistem file ke memisahkan subsistem, dan saya mencoba memodelkan berbagai jenis kesalahan ketika aplikasi mencoba menulis atau membaca file.  Akses yang disimulasikan secara manual ke grup aplikasi bersama dalam aplikasi, dan saya benar-benar ingin memulai memodelkan perilaku aplikasi ketika dimulai dengan ruang disk yang sangat kecil, di mana bahkan tidak mungkin untuk membuat database. <br><br>  <strong>Alexei Kudryavtsev:</strong> Apakah hanya itu yang Anda lakukan? <br><br>  <strong>Pavel Osipov:</strong> Pada prinsipnya, ya.  Kami belum membersihkan semua bug yang ditemukan menggunakan kekacauan yang ada.  Tentu saja, menarik untuk meningkatkan kekacauan dan mentransfer ke subsistem lain, tetapi kita tidak akan punya waktu untuk memperbaiki sebanyak kekacauan akan ditemukan. <br><br>  Di mana tempat kekacauan?  Anda selalu dapat menemukan tempat di mana Anda dapat membuat turbulensi lain untuk aplikasi tersebut.  Penting untuk membangun di atas masalah.  Kami membuat kekacauan untuk penebangan karena kami mengamati sejumlah besar masalah serupa. <br><br><blockquote>  Jika pemantauan menunjukkan bahwa dalam subsistem lain tidak ada masalah khusus, maka tidak masuk akal untuk menghabiskan waktu memodelkan keadaan yang tidak terduga. </blockquote><br>  Ini tidak berlaku untuk penagihan, di mana operasi yang benar adalah penting. <br><br>  <strong>Alexei Kudryavtsev:</strong> Di sisi lain, kami tidak tahu apa yang terjadi dengan pengguna - ini adalah kekacauan itu sendiri, karena Anda tidak tahu di mana harus meletakkannya atau tidak, dan Anda hanya perlu mensimulasikannya. <br><br>  <strong>Pavel Osipov:</strong> Anda selalu perlu melihat ROI.  Tentu saja, Anda dapat mereproduksi kasus-kasus yang paling eksotis, tetapi jika mereka lajang, maka mungkin mereka tidak kritis, dan tidak ada gunanya memodelkannya. <br><br><h2>  Tantangan memperkenalkan kekacauan </h2><br>  <strong>Alexei Kudryavtsev:</strong> Manakah dari yang sudah dilakukan itu mudah bagi Anda, dan apa yang menyebabkan kesulitan? <br><br>  <strong>Pavel Osipov:</strong> Membiasakan diri dengan kekacauan bukanlah hal yang biasa bagi seorang pemula, karena ini bukan praktik yang biasa digunakan.  Sulit untuk beradaptasi dengan fakta bahwa Anda memiliki banyak kesalahan.  Di hampir setiap layar, Anda bisa mendapatkan paket "lima ratus" atau "404" yang tidak bisa dipahami, server merespons sekali.  Hanya dengan waktu Anda terbiasa dengan kenyataan bahwa semua ini membosankan, dan tanggapan dari server dimodelkan oleh sistem itu sendiri. <br><br>  Sulit ketika Anda memiliki fitur kritis yang sedang menyala, dan Anda harus menyelesaikannya sesegera mungkin, dan kemudian razlogin tiba-tiba muncul di tempat akumulasi permintaan.  Sebagai contoh, Anda perlu membuat layar dengan benar dan Anda membutuhkan semua permintaan untuk menyelesaikan dengan sukses, dan ini sangat tidak mungkin bahwa Anda harus pergi beberapa lusin kali untuk mencapai keadaan yang diinginkan.  Dalam kasus seperti itu, penonaktifan kekacauan menjadi tindakan balasan, dan penting untuk tidak lupa menyalakannya lagi. <br><br>  Poin lain yang menyebabkan ketidakpuasan adalah penggunaan kekacauan dalam layanan infrastruktur dengan sejumlah besar efek samping. <br><br>  <strong>Daniil Popov:</strong> Jadi, apakah pengembang selalu memiliki kekacauan yang dihidupkan secara default? <br><br>  <strong>Pavel Osipov:</strong> Tentu saja.  Kadang-kadang, ketika Anda bahkan tidak peduli dengan kekacauan dan situasi eksotis yang dapat ia tiru untuk Anda, itu mengganggu.  Anda harus bertahan, tetapi Anda selalu dapat menyesuaikan tingkat kekacauan jika layar Anda bekerja secara intensif dengan jaringan.  Di sisi lain, kekacauan dapat mengungkapkan masalah jauh dari tempat Anda mencarinya, dan bukan dari pengembang yang mengembangkan fitur ini.  Kebetulan fitur Anda, di mana kekacauan ditambahkan, mengarah pada konsekuensi yang memengaruhi fitur rekan Anda.  Anda tidak akan tahu tentang ini jika kekacauan hanya akan dimasukkan pada saat perkembangan tertentu. <br><br><blockquote>  Arti kekacauan adalah untuk mengidentifikasi konsekuensi yang tidak terduga dalam interaksi sejumlah besar komponen. </blockquote><br>  Jika Anda memasukkan kekacauan dengan cara yang terukur dan akurat, maka bidikan langka namun bertujuan baik ini tidak akan terlihat. <br><br>  <strong>Daniil Popov:</strong> Apakah kekacauan mencegah pembacaan kode? <br><br>  <strong>Pavel Osipov:</strong> Ketika kekacauan diperkenalkan di luar sistem, menempel pada yang sudah jadi, maka ya, itu tampak berantakan.  Pada kami, karena pengalaman penggunaan yang lama, kekacauan ditenun secara organik ke dalam sistem dan begitu terisolasi sehingga Anda tidak melihatnya dalam kode. <br><br>  <strong>Alexei Kudryavtsev:</strong> Anda menangkap banyak kasus langka, memperbaikinya, dan kode dikelilingi oleh kruk.  Apakah ini mempersulit logika aplikasi? <br><br>  <strong>Pavel Osipov:</strong> Ini selalu merupakan bagian besar dari kode kami, tetapi sebaliknya aplikasi produksi besar tidak ditulis.  Tentu saja, itu semua tergantung pada keahlian pengembang, siapa yang tahu cara memperbaiki kode sehingga tidak mengganggu mata. <br><br><h2>  Pro memperkenalkan kekacauan </h2><br>  <strong>Daniil Popov:</strong> Apakah ada indikator kuantitatif yang membaik setelah diperkenalkannya rekayasa kekacauan? <br><br>  <strong>Pavel Osipov:</strong> Bagi saya, metrik yang paling penting adalah ketenangan pikiran ketika saya mengirim fitur untuk dirilis. <br><br>  <strong>Alexey Kudryavtsev:</strong> Perdamaian tidak bisa dijual ke bisnis.  Bagaimana memperdebatkan pengenalan rekayasa kekacauan di perusahaan? <br><br>  <strong>Pavel Osipov:</strong> Rekayasa kekacauan membebaskan waktu bagi penguji, karena ada tes otomatis.  Kecelakaan yang sama dengan razlogin setelah pengenalan praktik kekacauan hampir menghilang dari JIRA kami. <br><br>  Rekayasa kekacauan memiliki efek menguntungkan pada siklus rilis, karena Anda mendapatkan umpan balik cepat.  Adalah satu hal ketika fitur yang telah selesai diuji, dan setelah lama Anda diberi tahu tentang jumlah bug yang ditemukan, itu sama sekali berbeda ketika Anda memiliki robot penguji yang berfungsi di seluruh program debug. <br><br>  Saya memiliki perasaan percaya diri dari hasil unit test yang jauh lebih rendah daripada dari kekacauan yang dinyalakan hingga 50% saat mengunduh ribuan file.  Dengan beban seperti itu, semua kombinasi paling luar biasa pasti akan diperbaiki. <br><br><h2>  Siapa yang harus belajar dan mulai dari mana? </h2><br>  <strong>Alexei Kudryavtsev:</strong> Alat apa yang Anda gunakan untuk ini?  Mengambil perpustakaan terbuka atau menulis dan memposting di sumber terbuka? <br><br>  <strong>Pavel Osipov:</strong> Kami telah memposting <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan jaringan</a> dalam sumber terbuka, tetapi tidak ada alat khusus.  Satu-satunya yang saya tahu adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Netflix Chaos Monkey</a> , yang secara acak “berjalan” melalui AWS dan menghentikannya, melihat apakah semuanya berjalan baik jika sejumlah kontainer dipadamkan.  Saya percaya bahwa menulis konfigurasi tempat Anda bersentuhan dengan sistem yang berdekatan tidak memerlukan otomatisasi yang mendalam. <br><br>  <strong>Daniil Popov:</strong> Di mana saya bisa membaca lebih lanjut tentang chaos engineering? <br><br>  <strong>Pavel Osipov:</strong> Pertama, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web Principles of Chaos</a> , yang ditautkan oleh semua sumber daya pada topik ini.  Kedua, buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Learning Chaos Engineering</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chaos Engineering Observability</a> . <br><br>  Secara umum, chaos engineering adalah praktik akal sehat dan pengetahuan fundamental tidak ada.  Anda selalu perlu memahami di mana harus menanamkan kekacauan.  Pada saat yang sama, apakah kekacauan itu unik untuk setiap aplikasi?  dan Anda harus terlebih dahulu memahami apa yang perlu diterapkan bersama Anda. <br><br>  <strong>Alexei Kudryavtsev:</strong> Di mana untuk memulai jika Anda masih memutuskan untuk memperkenalkan kekacauan? <br><br>  <strong>Pavel Osipov:</strong> Mulailah dengan menganalisis masalah dalam sistem, yang macet dan mengapa mereka muncul.  Setelah mengidentifikasi akar kejahatan, Anda harus memahami cara membuat model situasi yang mengarah ke masalah.  Dan langkah ketiga adalah memperkenalkan kekacauan dengan hati-hati dan mengendalikannya. <br><br>  <strong>Alexei Kudryavtsev:</strong> Banyak hal dapat merusak aplikasi, tetapi bagaimana memprioritaskan?  Di mana lebih baik tidak ikut campur? <br><br>  <strong>Pavel Osipov:</strong> Tidak ada hal yang tidak nyata.  Rasio harga dan knalpot penting.  Jika ada API sistem kaya, maka membungkusnya dengan bungkus Anda sendiri mahal.  Jika Anda tidak sepenuhnya memahami sesuatu, maka Anda akan mulai memancing kekacauan, yang pada dasarnya tidak mungkin dan akan mengarah pada perjuangan yang sia-sia.  Misalnya, jika seluruh UIKit atau API belanja dicakup oleh kekacauan. <br><br><blockquote>  Kekacauan bukanlah poke acak, tetapi pemahaman yang jelas tentang situasi yang disimulasikan. </blockquote><br>  <strong>Alexei Kudryavtsev:</strong> Berapa banyak yang Anda rekomendasikan untuk menerapkan praktik ini? <br><br>  <strong>Pavel Osipov:</strong> Saya biasanya merekomendasikan memulai dengan memperkenalkan rekayasa kekacauan, daripada tes unit, karena ini adalah praktik termurah. <br><br><blockquote>  Tertarik dengan chaos engineering?  Tangkap Pavel Osipov di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsConf</a> musim gugur di St. Petersburg pada 21-21 Oktober, tempat ia akan mempresentasikan laporan barunya tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">basis data Nilai-kunci</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464723/">https://habr.com/ru/post/id464723/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464711/index.html">Peri gigi tidak bekerja di sini: struktur enamel gigi buaya dan nenek moyang prasejarah mereka</a></li>
<li><a href="../id464713/index.html">Algoreve: bagaimana programer mengadakan pesta</a></li>
<li><a href="../id464715/index.html">Visualisasi grafik besar untuk yang terkecil</a></li>
<li><a href="../id464719/index.html">Manajemen Sasaran Organisasi: Sasaran dan Insinyur (Bagian 3)</a></li>
<li><a href="../id464721/index.html">Bagaimana Saya Mempersiapkan dan Melewati Sertifikasi SQL Database Oracle (1Z0-071)</a></li>
<li><a href="../id464725/index.html">Memperingati Danny Cohen, Spesialis Ilmu Komputer Memindahkan Era Digital Di Depan</a></li>
<li><a href="../id464727/index.html">Tanya Ethan: seperti apa foto langsung pertama planet ekstrasurya kita yang seperti bumi?</a></li>
<li><a href="../id464729/index.html">Natas Web. Passage dari platform KKP bertujuan untuk mengeksploitasi kerentanan Web. Bagian 3</a></li>
<li><a href="../id464731/index.html">Cara melakukan tugas tes untuk junior java / peserta pelatihan untuk mendapatkan wawancara</a></li>
<li><a href="../id464733/index.html">Mengapa semua game saya terlihat sangat sial</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>