<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüé§ üôéüèº üßíüèº Impl√©mentation de l'analyseur PEG üçü ü¶â üë®üèΩ‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Inspir√© uniquement par une compr√©hension partielle du PEG, j'ai d√©cid√© d'essayer de le mettre en ≈ìuvre. Le r√©sultat n'est peut-√™tre pas le meilleur pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Impl√©mentation de l'analyseur PEG</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471862/"><p>  Inspir√© uniquement par une compr√©hension partielle du PEG, j'ai d√©cid√© d'essayer de le mettre en ≈ìuvre.  Le r√©sultat n'est peut-√™tre pas le meilleur parmi les analyseurs PEG √† usage g√©n√©ral - il y en a d√©j√† beaucoup (par exemple, TatSu est √©crit en Python et g√©n√®re du code Python) - mais c'est un bon moyen de comprendre PEG.  √Ä l'avenir, je veux le remplacer par l'impl√©mentation actuelle de l'analyseur en CPython. </p><br><div class="spoiler">  <b class="spoiler_title">Contenu de la s√©rie Python PEG Parser</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyseurs de cheville</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Impl√©mentation de l'analyseur PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">G√©n√©ration de l'analyseur PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Visualisation de l'analyseur PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Grammaire r√©cursive gauche du PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ajout d'actions √† la grammaire PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">M√©ta grammaire pour l'analyseur PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Impl√©mentation des fonctionnalit√©s restantes de PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PEG sur Core Developer Sprint</a> </li></ul></div></div><br><p>  Dans cette section, je jette les bases de la compr√©hension du travail de l'analyseur, en utilisant un exemple d'une impl√©mentation simple auto-√©crite de la grammaire du jouet d'un article pr√©c√©dent. </p><a name="habracut"></a><br><p>  (Au fait, √† titre exp√©rimental, je ne place pas de liens dans mon texte. Si vous ne comprenez pas quelque chose, vous pouvez simplement le rechercher sur Google. :-) </p><br><p> En r√®gle g√©n√©rale, un PEG utilise un analyseur de descente r√©cursif avec un tampon illimit√© pour revenir.  Voici une grammaire de jouet d'un article pr√©c√©dent: </p><br><pre><code class="plaintext hljs">statement: assignment | expr | if_statement expr: expr '+' term | expr '-' term | term term: term '*' atom | term '/' atom | atom atom: NAME | NUMBER | '(' expr ')' assignment: target '=' expr target: NAME if_statement: 'if' expr ':' statement</code> </pre> <br><p>  L'analyseur super abstrait de la descente r√©cursive pour ce langage d√©finira sa fonction pour chaque r√®gle dans laquelle les alternatives seront comprises.  Par exemple, pour l' <code>statement</code> , nous aurions cette fonction: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">statement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> assignment(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> expr(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> if_statement(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Bien s√ªr, c'est un exemple trop simpliste: il omet des d√©tails importants, par exemple, ce qui est appliqu√© √† l'entr√©e de cette fonction et quel sera le r√©sultat de son ex√©cution. </p><br><p>  Commen√ßons par les arguments.  Les analyseurs classiques utilisent un tokenizer s√©par√©, qui divise l'entr√©e (fichier texte ou ligne) en une s√©rie de tokens, tels que des mots cl√©s, des identifiants (noms), des nombres et des op√©rateurs.  Les analyseurs PEG (comme d'autres analyseurs modernes comme ANTLR) combinent souvent la tokenisation et l'analyse, mais pour mon projet, j'ai d√©cid√© de laisser un tokenizer s√©par√©. </p><br><p>  La tokenisation Python est assez compliqu√©e, donc je ne veux pas l'impl√©menter sur les r√®gles PEG.  Par exemple, vous devez suivre l'indentation (cela n√©cessite une pile √† l'int√©rieur du tokenizer);  Le traitement des sauts de ligne en Python est √©galement int√©ressant (ils sont significatifs, √† l'exception de ceux plac√©s entre crochets correspondants).  De nombreux types de cha√Ænes provoquent √©galement une certaine complexit√©.  En bref, je n'ai rien √† redire sur le tokenizer Python existant, donc je veux le laisser tel quel.  Soit dit en passant, CPython a deux jetons: celui interne, qui est utilis√© par l'analyseur, il est √©crit en C, et celui de la biblioth√®que standard, qui est une copie exacte impl√©ment√©e en Python pur.  Cela sera utile dans mon projet. </p><br><p>  Un tokenizer classique poss√®de g√©n√©ralement une interface simple compos√©e d'une seule fonction <code>get_token()</code> .  √Ä chaque fois, il renvoie le jeton suivant de la s√©quence d'entr√©e, analysant un groupe de caract√®res.  Le module <code>tokenize</code> de CPython ne fait pas exception: son API principale est un g√©n√©rateur qui √©met un jeton √† la fois.  Chaque jeton est un objet de type <code>TypeInfo</code> , qui a plusieurs champs, dont le plus important est le type de jeton (par exemple, <code>NAME</code> , <code>NUMBER</code> , <code>STRING</code> ) et sa valeur de cha√Æne est l'ensemble de caract√®res qui le compose (par exemple, <code>abc</code> , <code>42</code> ou <code>"Hello, world"</code> ).  Il existe √©galement des champs suppl√©mentaires.  Par exemple, pour l'index de jeton dans le flux d'entr√©e, ce qui est utile dans les messages d'erreur. </p><br><p>  Un type sp√©cial de jeton est <code>ENDMARKER</code> , qui indique que la fin du fichier d'entr√©e a √©t√© atteinte.  Le g√©n√©rateur tombera si vous l'ignorez et essayez d'obtenir le prochain jeton. </p><br><p>  Mais j'√©tais distrait.  Comment r√©alisons-nous des retours illimit√©s?  Pour faire reculer la liste des jetons, vous devez pouvoir vous souvenir de la position dans le code source et r√©analyser √† partir de ce point.  L'API tokenizer ne nous permet pas de d√©placer son pointeur, mais vous pouvez capturer le flux de jetons dans un tableau et le lire √† partir de l√†, ce que nous ferons.  Vous pouvez √©galement r√©p√©ter cela avec <code>itertools.tee()</code> , mais cela est probablement moins efficace dans notre cas, si vous regardez les avertissements dans la documentation. </p><br><p>  Je suppose que vous pouvez tout d'abord tokeniser toutes les entr√©es de la liste, puis les utiliser comme entr√©es pour l'analyseur.  Mais s'il y avait un jeton non valide √† la fin du fichier (par exemple, une ligne avec un guillemet de fermeture manquant) et qu'il y avait √©galement une erreur de syntaxe dans le fichier, vous recevrez d'abord un message d'erreur du tokenizer.  Je pense que cela est mauvais pour l'utilisateur, car une erreur de syntaxe peut √™tre la principale cause d'une ligne invalide.  J'ai donc des exigences l√©g√®rement diff√©rentes pour le tokenizer, en particulier, il devrait √™tre impl√©ment√© comme une liste paresseuse. </p><br><p>  L'API principale est tr√®s simple.  L'objet <code>Tokenizer</code> encapsule un tableau de jetons et sa position dans ce tableau.  Il a trois m√©thodes principales: </p><br><ul><li>  <code>get_token()</code> renvoie le prochain jeton, en d√©pla√ßant le pointeur (ou lit le prochain jeton de la source, si nous sommes √† la fin du tampon de jeton); </li><li>  <code>mark()</code> renvoie la position actuelle dans le tampon; </li><li>  <code>reset(pos)</code> d√©finit la position dans le tampon (l'argument doit √™tre obtenu √† partir de <code>mark()</code> ). </li></ul><br><p>  Nous avons ajout√© une fonction d'assistance <code>peek_token()</code> , qui renvoie le jeton suivant sans d√©placer la position dans le tampon. </p><br><p>  Voici √† quoi ressemble la base de la classe <code>Tokenizer</code> : </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tokenizer</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokengen)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Call with tokenize.generate_tokens(...)."""</span></span> self.tokengen = tokengen self.tokens = [] self.pos = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.pos <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, pos)</span></span></span><span class="hljs-function">:</span></span> self.pos = pos <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> token = self.peek_token() self.pos += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> token <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">peek_token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.pos == len(self.tokens): self.tokens.append(next(self.tokengen)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.tokens[self.pos]</code> </pre> <br><p>  Ici, quelque chose est omis pour des raisons de simplicit√© (par exemple, les noms des m√©thodes et des variables d'instance doivent commencer par un trait de soulignement), mais ce n'est qu'un prototype de l'API <code>Tokenizer</code> . </p><br><p>  L'analyseur doit √©galement devenir une classe pour que <code>statement()</code> , <code>expr()</code> , etc.  pourrait √™tre mis en ≈ìuvre comme m√©thodes.  Le tokenizer deviendra une variable d'instance, mais je ne veux pas que les m√©thodes de l'analyseur appellent directement <code>get_token()</code> - √† la place, nous impl√©mentons la m√©thode <code>wait()</code> dans la classe <code>Parser</code> , qui peut r√©ussir ou √©chouer comme la m√©thode de l'analyseur.  L'argument de la fonction <code>wait()</code> est le jeton attendu: soit une cha√Æne (par exemple, <code>+</code> ) ou un type de jeton (par exemple, <code>NAME</code> ).  Le type de la valeur de retour n'est pas encore important, j'y reviendrai apr√®s avoir discut√© du r√©sultat du travail de l'analyseur. </p><br><p>  Laissez les fonctions de r√®gle de grammaire renvoyer uniquement <code>True</code> ou <code>False</code> .  C'est bon pour l'informatique th√©orique (l√†, l'analyseur r√©pond √† la question ¬´Est- <em>ce une</em> cha√Æne valide dans la langue?¬ª), Mais pas pour nous.  Notre t√¢che est de cr√©er un AST.  R√©√©crivons donc ce code afin que chaque m√©thode d'analyse renvoie un objet <code>Node</code> en cas de succ√®s ou <code>None</code> en cas d'√©chec. </p><br><p>  La classe <code>Node</code> peut √™tre tr√®s simple: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, type, children)</span></span></span><span class="hljs-function">:</span></span> self.type = type self.children = children</code> </pre> <br><p>  Ici, <code>type</code> d√©termine le type du n≈ìud AST (par exemple, <code>add</code> ou <code>if</code> ), et les descendants sont une liste de n≈ìuds et de jetons (instances <code>TokenInfo</code> ).  Cela suffit pour que le compilateur g√©n√®re du code ou effectue d'autres analyses, telles que le linting ou la v√©rification de type statique.  Bien qu'√† l'avenir, j'aimerais changer la fa√ßon dont AST est pr√©sent√©. </p><br><p>  Pour tenir dans ce sch√©ma, la m√©thode <code>expect()</code> doit renvoyer un objet <code>TokenInfo</code> en cas de succ√®s et <code>None</code> en cas d'√©chec.  Pour pouvoir revenir aux jetons pr√©c√©dents, j'encapsule les appels aux m√©thodes <code>mark()</code> et <code>reset()</code> du tokenizer (ici l'API ne change pas).  Voici ce qui s'est pass√©: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokenizer)</span></span></span><span class="hljs-function">:</span></span> self.tokenizer = tokenizer <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.tokenizer.mark() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, pos)</span></span></span><span class="hljs-function">:</span></span> self.tokenizer.reset(pos) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, arg)</span></span></span><span class="hljs-function">:</span></span> token = self.tokenizer.peek_token() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> token.type == arg <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> token.string == arg: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.tokenizer.get_token() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br><p>  Encore une fois: j'ai omis certains d√©tails, mais cela fonctionne d√©j√†. </p><br><p>  Maintenant, je dois introduire une exigence importante pour les m√©thodes d'analyse syntaxique.  Chacun doit retourner <code>Node</code> , en pla√ßant le tokenizer apr√®s le dernier token de la r√®gle de grammaire qu'il a reconnu;  soit <code>None</code> et laissez la position du tokenizer inchang√©e.  Si la m√©thode de l'analyseur lit plusieurs jetons puis tombe, elle doit restaurer la position du tokenizer.  Pour ce faire, <code>mark()</code> et <code>reset()</code> sont pr√©vus.  Notez que <code>expect()</code> ob√©it √©galement √† cette r√®gle. </p><br><p>  Voici donc un croquis de l'analyseur r√©el.  Ici, j'utilise l'op√©rateur morse de Python 3.8 ( <code>:=</code> ): </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToyParser</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">statement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a := self.assignment(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e := self.expr(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i := self.if_statement(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t := self.term(): pos = self.mark() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> op := self.expect(<span class="hljs-string"><span class="hljs-string">"+"</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e := self.expr(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">"add"</span></span>, [t, e]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> op := self.expect(<span class="hljs-string"><span class="hljs-string">"-"</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e := self.expr(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">"sub"</span></span>, [t, e]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">term</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Very similar... def atom(self): if token := self.expect(NAME): return token if token := self.expect(NUMBER): return token pos = self.mark() if self.expect("("): if e := self.expr(): if self.expect(")"): return e self.reset(pos) return None</span></span></code> </pre> <br><p>  J'ai omis la mise en ≈ìuvre de certaines m√©thodes afin que le lecteur ait l'occasion de s'exercer lui-m√™me.  C'est vraiment mieux que de simplement lire comment un tel analyseur est impl√©ment√©.  Au final, nous g√©n√©rerons automatiquement ce code √† partir de la grammaire.  Les constantes telles que <code>NAME</code> et <code>NUMBER</code> sont import√©es du module de <code>token</code> de la biblioth√®que standard.  Cela nous lie davantage √† l'impl√©mentation actuelle du tokenizer Python.  Si nous voulons cr√©er un analyseur PEG g√©n√©ralis√©, nous devons trouver des moyens d'√©viter cela. </p><br><p>  Notez √©galement que je suis un peu tromp√©.  La m√©thode <code>expr</code> doit √™tre laiss√©e r√©cursive, mais j'ai rendu le parseur droit r√©cursif car le parseur r√©cursif de descente ne fonctionne pas avec les r√®gles de grammaire r√©cursive gauche.  Cela peut √™tre corrig√©, mais c'est toujours le sujet de certaines recherches scientifiques, et je voudrais en parler s√©par√©ment.  Gardez √† l'esprit que cette impl√©mentation n'est pas 100% coh√©rente avec notre grammaire simplifi√©e. </p><br><p>  Les √©l√©ments cl√©s que je veux que vous compreniez jusqu'√† pr√©sent: </p><br><ul><li>  Les r√®gles de grammaire correspondent aux m√©thodes d'analyse syntaxique et lorsqu'une r√®gle de grammaire se r√©f√®re √† une autre, elle appelle une m√©thode d'une autre r√®gle. </li><li>  Lorsqu'une s√©quence de jetons peut √™tre interpr√©t√©e diff√©remment, les m√©thodes d'analyseur correspondantes sont invoqu√©es les unes apr√®s les autres. </li><li>  Lorsqu'une r√®gle de grammaire fait r√©f√©rence √† un jeton, la m√©thode appelle la fonction <code>expect()</code> . </li><li>  Si l'analyseur reconna√Æt avec succ√®s sa r√®gle de grammaire √† la position actuelle, il renvoie le n≈ìud AST correspondant;  s'il ne peut pas reconna√Ætre sa r√®gle de grammaire, il renvoie <code>None</code> . </li><li>  Les m√©thodes d'analyseur doivent r√©initialiser explicitement la position du tokenizer lorsqu'elles arr√™tent l'analyse apr√®s avoir utilis√© un ou plusieurs jetons (directement ou indirectement, en invoquant une autre m√©thode d'analyse r√©ussie).  Cela s'applique non seulement lorsque l'une des options est rejet√©e afin de passer √† la suivante, mais √©galement lorsque l'analyse est rejet√©e dans son ensemble. </li></ul><br><p>  Si toutes les m√©thodes d'analyse ob√©issent √† ces r√®gles, il n'est pas n√©cessaire d'envelopper chacune dans les appels <code>mark()</code> et <code>reset()</code> .  Cela peut √™tre prouv√© par induction. </p><br><p>  De plus, il est tentant d'essayer de se d√©barrasser des appels explicites √† <code>mark()</code> et <code>reset()</code> √† l'aide du gestionnaire de contexte et de l'instruction <code>with</code> , mais cela ne fonctionnera pas: vous ne devriez pas appeler <code>reset()</code> cas de succ√®s!  Comme autre correction, vous pouvez essayer d'utiliser des exceptions pour le flux de contr√¥le afin que le gestionnaire de contexte sache si le tokenizer doit √™tre r√©initialis√© (je pense que TatSu fait quelque chose de similaire).  Par exemple, quelque chose comme ceci: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">statement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.alt(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.assignment() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.alt(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.expr() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.alt(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.if_statement() <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ParsingFailure</code> </pre> <br><p>  En particulier, une petite √©chelle d' <code>if</code> dans <code>atom()</code> pour reconna√Ætre une expression entre crochets peut s'√©crire: </p><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.alt(): self.expect(<span class="hljs-string"><span class="hljs-string">"("</span></span>) e = self.expr() self.expect(<span class="hljs-string"><span class="hljs-string">")"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e</code> </pre> <br><p>  Mais il me semble trop "magique" - lors de la lecture d'un tel code, vous devez vous rappeler que chaque m√©thode d'analyse (y compris <code>wait()</code> ) peut lever une exception.  Et que cette exception est intercept√©e et ignor√©e par le gestionnaire de contexte dans l'instruction <code>with</code> .  C'est plut√¥t inhabituel, bien que r√©alisable (en retournant <code>True</code> depuis <code>__exit__</code> ).  Cependant, mon objectif ultime est de g√©n√©rer du code en C, pas en Python, et en C il n'y a pas <code>with</code> instruction <code>with</code> pour changer le flux de contr√¥le. </p><br><p>  Quoi qu'il en soit, voici quelques sujets pour les parties suivantes: </p><br><ul><li>  g√©n√©ration de m√©thodes d'analyseur √† partir de la grammaire; </li><li>  packrat-parsing (m√©morisation); </li><li>  Fonctionnalit√©s EBNF telles que <code>(x | y)</code> , <code>[xy ...]</code> , <code>x*</code> , <code>x+</code> ; </li><li>  tra√ßage (pour d√©boguer un analyseur ou une grammaire); </li><li>  Fonctionnalit√©s PEG telles que l'anticipation et la coupe; </li><li>  comment g√©rer les r√®gles r√©cursives gauches; </li><li>  G√©n√©ration de code C </li></ul><br><p>  Licence pour cet article et code cit√©: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471862/">https://habr.com/ru/post/fr471862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471852/index.html">Nouvelles du monde d'OpenStreetMap n ¬∞ 481 (10/01/2019 - 07/10/2019)</a></li>
<li><a href="../fr471854/index.html">Heat Death 5G</a></li>
<li><a href="../fr471856/index.html">Nous r√©solvons les 42 versions du puzzle de potion Harry Potter</a></li>
<li><a href="../fr471858/index.html">RabbitMQ contre Kafka: basculement et haute disponibilit√© dans les clusters</a></li>
<li><a href="../fr471860/index.html">Analyseurs de cheville</a></li>
<li><a href="../fr471864/index.html">G√©n√©ration de l'analyseur PEG</a></li>
<li><a href="../fr471866/index.html">Visualisation de l'analyseur PEG</a></li>
<li><a href="../fr471868/index.html">G√©n√©tique de l'amour: le conflit entre les sexes comme base de coop√©ration dans des couples d'oiseaux monogames</a></li>
<li><a href="../fr471872/index.html">Interfaces en C # 8: hypoth√®ses dangereuses dans l'impl√©mentation par d√©faut</a></li>
<li><a href="../fr471874/index.html">Comment nous avons contourn√© les directives d'examen et lanc√© un serveur par t√©l√©phone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>