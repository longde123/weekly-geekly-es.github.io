<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎨 🌹 🍼 So funktioniert das Rendern von 3D-Spielen: Vertex-Verarbeitung 👌🏼 ♏️ 🎏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Beitrag werden wir die Phase der Arbeit mit Eckpunkten betrachten. Das heißt, wir müssen wieder die Lehrbücher über Mathematik besorgen und ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So funktioniert das Rendern von 3D-Spielen: Vertex-Verarbeitung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472688/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/070/e30/bd5/070e30bd57f6af2d7c1e36abe15f949b.jpg" alt="Bild"></div><br>  In diesem Beitrag werden wir die Phase der Arbeit mit Eckpunkten betrachten.  Das heißt, wir müssen wieder die Lehrbücher über Mathematik besorgen und uns an lineare Algebra, Matrizen und Trigonometrie erinnern.  Hurra! <br><br>  Wir werden herausfinden, wie 3D-Modelle transformiert und Lichtquellen berücksichtigt werden.  Wir werden auch den Unterschied zwischen Scheitelpunkt- und geometrischen Shadern im Detail erklären und Sie werden herausfinden, in welchem ​​Stadium sich die Tessellation befindet.  Zum besseren Verständnis verwenden wir Diagramme und Codebeispiele, die zeigen, wie das Spiel Berechnungen durchführt und Werte verarbeitet. <br><br>  Der Screenshot am Anfang des Beitrags zeigt das Spiel GTA V im Drahtmodell-Anzeigemodus.  Vergleichen Sie es mit dem viel weniger komplexen Half-Life 2-Drahtmodell. Die Bilder wurden von thalixte mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ReShade erstellt</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/562/7ee/4c45627ee9916f0bcdce6858b510b6a6.jpg"></div><a name="habracut"></a><br><h2>  Was ist der Punkt? </h2><br>  In der Welt der Mathematik ist ein Punkt einfach ein Ort im geometrischen Raum.  Es gibt nichts Kleineres als einen Punkt, er hat keine Größe, sodass Punkte verwendet werden können, um die genaue Position von Anfang und Ende von Objekten wie Liniensegmenten, Ebenen und Volumina anzugeben. <br><br>  Für 3D-Grafiken sind solche Informationen von entscheidender Bedeutung. Das Erscheinungsbild hängt davon ab, da alle Objekte als Sätze von Liniensegmenten, Ebenen usw. angezeigt werden.  Das Bild unten zeigt einen Screenshot von Bethesda 2015 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fallout 4</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87b/33c/f82/87b33cf825a8ed9d87b7c8a7cc873e69.jpg"></div><br>  Es ist möglicherweise nicht leicht für Sie zu erkennen, dass dies nur eine große Menge von Punkten und Linien ist. Wir zeigen Ihnen daher, wie dieselbe Szene im Drahtgittermodus aussieht.  In diesem Modus überspringt die 3D-Rendering-Engine Texturen und Effekte, die im Pixelstadium ausgeführt werden, und zeichnet nur mehrfarbige Linien, die die Punkte verbinden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/430/8a0/f67/4308a0f6729ff459c600275d8755f12c.jpg"></div><br>  Jetzt sieht alles ganz anders aus, aber wir sehen, wie alle Linien kombiniert werden, um verschiedene Objekte, Umgebungen und Hintergründe zu bilden.  Einige bestehen nur aus Dutzenden von Linien, zum Beispiel Steinen im Vordergrund, während andere so viele Linien enthalten, dass sie solide aussehen. <br><br>  Jeder Punkt am Anfang und Ende jeder Linie wird verarbeitet, indem eine ganze Reihe von Berechnungen durchgeführt werden.  Einige Berechnungen sind sehr einfach und schnell, andere sind viel komplizierter.  Durch die Verarbeitung von Punkten in Gruppen, insbesondere in Form von Dreiecken, können Sie eine erhebliche Produktivitätssteigerung erzielen. Schauen wir uns diese also genauer an. <br><br><h2>  Was wird für ein Dreieck benötigt? </h2><br>  Das <em>Namensdreieck</em> macht deutlich, dass die Figur drei innere Ecken hat;  Dazu benötigt sie drei Eckpunkte und drei Segmente, die sie verbinden.  Es ist richtig, einen Eckpunkt einen <em>Scheitelpunkt (Scheitelpunkt)</em> (im Plural - Scheitelpunkte) zu nennen;  Jeder Scheitelpunkt wird durch einen Punkt definiert.  Da wir uns in einer dreidimensionalen geometrischen Welt befinden, wird das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kartesische Koordinatensystem</a> für Punkte verwendet.  Normalerweise werden die Koordinaten in Form von drei Werten geschrieben, z. B. (1, 8, -3) oder generisch ( <em>x, y, z</em> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/b9e/77f/64cb9e77ffcc16159b4d201026a4ba04.png"></div><br>  Als nächstes können wir zwei weitere Eckpunkte hinzufügen, um ein Dreieck zu bilden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/732/482/c6b/732482c6b6faef01c7a7281f9b30da31.png"></div><br>  Beachten Sie, dass die angezeigten Linien optional sind. Wir können die Punkte festlegen und dem System mitteilen, dass diese drei Eckpunkte ein Dreieck bilden.  Alle Scheitelpunktdaten werden in einem zusammenhängenden Speicherblock gespeichert, der als <em>Scheitelpunktpuffer bezeichnet wird</em> .  Informationen über die Figur, die sie bilden, werden entweder direkt im Rendering-Programm codiert oder in einem anderen Speicherblock gespeichert, der als <em>Indexpuffer bezeichnet wird</em> . <br><br>  Wenn die Informationen in einem Rendering-Programm codiert sind, werden die verschiedenen Formen, die durch Scheitelpunkte gebildet werden können, als <em>Grundelemente bezeichnet</em> .  Direct3D schlägt vor, eine Liste für sie, Streifen und Lüfter in Form von Punkten, Linien und Dreiecken zu verwenden.  Bei korrekter Verwendung verwenden Dreiecksstreifen Scheitelpunkte für mehr als ein Dreieck, was die Produktivität verbessert.  Im folgenden Beispiel sehen wir, dass zum Erstellen von zwei miteinander verbundenen Dreiecken nur vier Scheitelpunkte benötigt werden. Wenn sie getrennt sind, benötigen wir sechs Scheitelpunkte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41e/9cb/a1e/41e9cba1ee23a0b9787994ef7249d6ff.png"></div><br>  <i>Von links nach rechts: Liste der Punkte, Liste der Linien und Dreiecksstreifen</i> <br><br>  Wenn wir beispielsweise in einem Spiel-NPC-Modell einen größeren Satz von Scheitelpunkten verarbeiten müssen, ist es besser, ein Objekt zu verwenden, das als <em>Netz bezeichnet wird</em> , einen weiteren Speicherblock, der jedoch aus mehreren Puffern (Scheitelpunkte, Indizes usw.) und Modelltexturressourcen besteht .  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Online-Dokumentation von</a> Microsoft wird kurz erläutert, wie diese Puffer verwendet werden. <br><br>  Konzentrieren wir uns zunächst darauf, was mit diesen Scheitelpunkten in einem 3D-Spiel passiert, wenn Sie jeden neuen Frame rendern.  Kurz gesagt, sie führen eine von zwei Operationen aus: <br><br><ul><li>  Der Scheitelpunkt bewegt sich an eine neue Position. </li><li>  Die Scheitelpunktfarbe ändert sich </li></ul><br>  Bereit für Mathe?  Exzellent, weil wir es brauchen. <br><br><h2>  Vektor erscheint auf der Bühne. </h2><br>  Stellen Sie sich vor, Sie haben ein Dreieck auf dem Bildschirm und drücken eine Taste, um es nach links zu verschieben.  Natürlich erwarten wir, dass sich die Zahlen ( <em>x, y, z</em> ) jedes Scheitelpunkts entsprechend ändern.  Das ist, was passiert, aber eine ziemlich unerwartete <em>Art,</em> Änderungen umzusetzen.  Anstatt einfach die Koordinaten zu ändern, verwendet die überwiegende Mehrheit der 3D-Grafik-Rendering-Systeme ein spezielles mathematisches Werkzeug: Wir meinen <em>Vektoren</em> . <br><br>  Ein Vektor kann als Pfeil dargestellt werden, der auf einen bestimmten Punkt im Raum zeigt und die gewünschte Länge hat.  Scheitelpunkte werden normalerweise mithilfe von Vektoren festgelegt, die auf kartesischen Koordinaten basieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c5/5e4/79d/1c55e479dbf4da359cfa6ef7e3d55e8f.png"></div><br>  Beachten Sie, dass der blaue Pfeil an einer Stelle (in diesem Fall am <em>Ursprungspunkt</em> ) beginnt und sich nach oben erstreckt.  Um den Vektor festzulegen, haben wir einen <em>Datensatz in einer Spalte verwendet</em> , aber es ist durchaus möglich, einen <em>Datensatz in einer Zeile zu verwenden</em> .  Möglicherweise haben Sie bemerkt, dass es einen anderen vierten Wert gibt, der üblicherweise als <em>w-Komponente bezeichnet wird</em> .  Es wird verwendet, um zu zeigen, wofür der Vektor steht: Punktposition ( <em>Positionsvektor</em> ) oder allgemeine Richtung ( <em>Richtungsvektor</em> ).  Im Fall eines Richtungsvektors sieht es folgendermaßen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb2/73e/525/bb273e52588aa21666075a11a34ee32d.png"></div><br>  Dieser Vektor zeigt in die gleiche Richtung und hat die gleiche Länge wie der vorherige Positionsvektor, dh die Werte ( <em>x, y, z</em> ) sind gleich.  Die <em>w-</em> Komponente ist jedoch nicht 1, sondern Null.  Wir werden die Verwendung von Richtungsvektoren später erklären, aber denken Sie vorerst daran, dass alle Eckpunkte in der 3D-Szene auf diese Weise beschrieben werden.  Warum?  Weil es in diesem Format viel einfacher ist, sie zu verschieben. <br><br><h2>  Mathe, Mathe und wieder Mathe </h2><br>  Denken Sie daran, dass wir ein einfaches Dreieck haben und es nach links verschieben möchten.  Jeder Scheitelpunkt wird durch einen Positionsvektor beschrieben, daher muss die „Bewegungsmathematik“ ( <em>Transformationen genannt</em> ) mit diesen Vektoren arbeiten.  Ein neues Werkzeug erscheint: <em>Matrizen</em> ( <em>Matrix</em> im Singular).  Dies ist ein Array von Werten, die in einem Format ähnlich einer Excel-Tabelle mit Zeilen und Spalten geschrieben sind. <br><br>  Für jeden Transformationstyp gibt es eine entsprechende Matrix, und für eine Transformation reicht es aus, die Transformationsmatrix und den Positionsvektor einfach zu multiplizieren.  Wir werden nicht näher darauf eingehen, wie und warum dies geschieht, sondern nur sehen, wie es aussieht. <br><br>  Das Verschieben eines Scheitelpunkts im 3D-Raum wird als <em>Übersetzung bezeichnet</em> und erfordert die folgende Berechnung: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/c9b/eca/530c9beca19d9b0c8d61db78ecb8682a.png"></div><br>  Werte <em>x <sub>0</sub></em> usw.  die ursprünglichen Koordinaten des Vektors darstellen;  <em>Delta</em> - <em>x</em> - Werte geben den Betrag an, um den der Scheitelpunkt verschoben werden muss.  Die Multiplikation der Matrix und des Vektors führt dazu, dass sie einfach zusammengefasst werden (beachten Sie, dass die <em>w-</em> Komponente unverändert bleibt, so dass die fertige Antwort wie zuvor der Positionsvektor bleibt). <br><br>  Zusätzlich zum Verschieben müssen wir möglicherweise auch das Dreieck drehen oder seinen Maßstab ändern - für diese Operationen gibt es auch Transformationen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fc/ba4/d0b/1fcba4d0b2a678e94c17c49a09af0591.png"></div><br>  <i>Diese Transformation dreht den Scheitelpunkt um die z-Achse in der XY-Ebene</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5eb/1d5/26e/5eb1d526eb15b522f3fddb0dadffa8cf.png"></div><br>  <em>Und dies wird verwendet, wenn Sie den Maßstab der Figur ändern müssen</em> <br><br>  Wir können das WebGL-basierte Grafiktool von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Real-Time Rendering verwenden</a> , um diese Berechnungen für die gesamte Abbildung zu visualisieren.  Beginnen wir mit der Box in der Standardposition: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/5d7/3d2/2205d73d2920758e3fb11f6829cb924d.jpg"></div><br>  In diesem Online-Tool ist der Modellpunkt der Positionsvektor, die Weltmatrix die Transformationsmatrix und der Weltraumpunkt der Positionsvektor für den transformierten Scheitelpunkt. <br><br>  Wenden wir verschiedene Transformationen auf die Box an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/820/d7b/5d6/820d7b5d618f68de9446d0ee005a50da.jpg"></div><br>  Im obigen Bild wurde die Figur <em>um</em> 5 Einheiten entlang jeder Achse <em>verschoben</em> .  Diese Werte sind in der letzten Spalte der mittleren großen Matrix zu sehen.  Der ursprüngliche Positionsvektor (4, 5, 3, 1) bleibt unverändert, aber der transformierte Scheitelpunkt wird jetzt auf (9, 10, 8, 1) verschoben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a1/8c4/6fd/9a18c46fd6df9936f3632fd4e4b2a287.jpg"></div><br>  Bei dieser Transformation wurde alles um den Faktor 2 skaliert: Jetzt sind die Seiten der Box doppelt so lang geworden.  Schauen Sie sich zum Schluss das Rotationsbeispiel an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21c/beb/340/21cbeb3409b55b736d2dd1322a1d80b0.jpg"></div><br><br>  Das Parallelepiped wurde um einen Winkel von 45 ° gedreht, aber der <em>Sinus</em> und der <em>Cosinus</em> dieses Winkels werden in der Matrix verwendet.  Nach Überprüfung auf einem wissenschaftlichen Taschenrechner können wir sehen, dass <em>sin (45 °)</em> = 0,7071 ... ist, was auf den angezeigten Wert von 0,71 gerundet ist.  Wir erhalten die gleiche Antwort für den <em>Kosinuswert</em> . <br><br>  Matrizen und Vektoren sind optional;  Eine beliebte Alternative für sie, insbesondere bei komplexen Kurven, ist die Verwendung komplexer Zahlen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quaternionen</a> .  Diese Berechnungen unterscheiden sich stark von Vektoren, daher werden wir sie nicht berücksichtigen und weiterhin mit Transformationen arbeiten. <br><br><h2>  Vertex Shader Power </h2><br>  In diesem Stadium müssen wir verstehen, dass all dies von Leuten gemacht wird, die den Rendering-Code programmieren.  Wenn ein Spieleentwickler eine Drittanbieter-Engine verwendet (z. B. Unity oder Unreal), wurde dies alles bereits für ihn erledigt.  Aber wenn jemand seinen Motor von Grund auf neu herstellt, muss er alle diese Berechnungen mit Eckpunkten durchführen. <br><br>  Aber wie sieht das alles in Bezug auf Code aus? <br><br>  Um dies zu verstehen, werden wir Beispiele von der erstaunlichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Braynzar Soft-</a> Website verwenden.  Wenn Sie selbst mit der 3D-Programmierung beginnen möchten, ist dies der richtige Ort, um die Grundlagen sowie komplexere Dinge zu lernen ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/726/99f/664/72699f66423a8f3094cb911bc99a18e2.png"></div><br>  Dies ist ein Beispiel für eine All-in-One-Transformation.  Es erstellt die entsprechenden Transformationsmatrizen basierend auf der Tastatureingabe und wendet sie dann in einer Operation auf den ursprünglichen Positionsvektor an.  Beachten Sie, dass dies immer in der angegebenen Reihenfolge (Skalierung - Rotation - Übertragung) erfolgt, da das Ergebnis auf jede andere Weise vollständig ruiniert wird. <br><br>  Solche Codeblöcke werden als <em>Vertex-Shader bezeichnet</em> . Ihre Komplexität und Größe können sehr unterschiedlich sein.  Das obige Beispiel ist einfach, es ist <em>nur ein</em> Vertex-Shader, der nicht die volle Programmierbarkeit von Shadern nutzt.  Eine komplexere Folge von Shadern könnte Objekte im 3D-Raum transformieren, ihr Erscheinungsbild aus Sicht der Szenenkamera verarbeiten und dann Daten in die nächste Stufe des Renderprozesses übertragen.  In Anbetracht der Reihenfolge der Scheitelpunktverarbeitung werden wir andere Beispiele untersuchen. <br><br>  Natürlich können sie für viel mehr verwendet werden. Vergessen Sie also beim Spielen eines 3D-Spiels nicht, dass alle Bewegungen, die Sie sehen, von einer GPU ausgeführt werden, die Vertex-Shader-Befehle ausführt. <br><br>  Dies war jedoch nicht immer der Fall.  Wenn Sie bis Mitte der neunziger Jahre zurückgehen, dann hatten die Grafikkarten dieser Ära nicht die Fähigkeit, Scheitelpunkte und Grundelemente unabhängig voneinander zu verarbeiten, sondern nur der Zentralprozessor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/954/1d1/c15/9541d1c150a6ef926d98449addf51206.jpg"></div><br>  Einer der ersten Prozessoren mit einer eigenen Hardwarebeschleunigung für diesen Prozess war <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nvidia GeForce, die im Jahr 2000 veröffentlicht</a> wurde. Diese Funktionalität wurde als <em>Hardware-Transformation und Beleuchtung</em> (kurz Hardware-TnL) bezeichnet.  Die Prozesse, mit denen diese Ausrüstung umgehen konnte, waren in Bezug auf die Teams sehr begrenzt, aber mit der Veröffentlichung neuer Chips änderte sich die Situation schnell.  Heutzutage gibt es keine separate Ausrüstung für die Verarbeitung von Scheitelpunkten, und ein Gerät erledigt alles auf einmal: Punkte, Grundelemente, Pixel, Texturen usw. <br><br>  Übrigens zur <em>Beleuchtung</em> : Es ist erwähnenswert, dass wir dank des Lichts alles sehen. Lassen Sie uns also sehen, wie es im Scheitelpunktstadium verarbeitet werden kann.  Dazu müssen wir das nutzen, worüber wir zuvor gesprochen haben. <br><br><h2>  Licht, Kamera, Motor! </h2><br>  Stellen Sie sich dieses Bild vor: Der Spieler steht in einem dunklen Raum, der von einer Lichtquelle rechts beleuchtet wird.  In der Mitte des Raumes steht ein riesiger Wasserkocher.  Möglicherweise benötigen Sie dabei Hilfe. Verwenden Sie also die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Echtzeit-Rendering-</a> Website und sehen Sie, wie sie aussieht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1a/6a4/5f4/b1a6a45f47e81bec587c4f7bda1bf3ae.jpg"></div><br>  Vergessen Sie nicht, dass dieses Objekt eine Reihe von flachen Dreiecken ist, die miteinander verbunden sind.  Das heißt, die Ebene jedes Dreiecks wird in eine bestimmte Richtung gerichtet.  Einige von ihnen sind auf die Kamera gerichtet, andere - andere sind verzerrt.  Licht von der Quelle fällt auf jede Ebene und wird von ihr in einem bestimmten Winkel reflektiert. <br><br>  Je nachdem, wo das Licht reflektiert wird, können sich Farbe und Helligkeit der Ebene ändern. Damit die Farbe des Objekts richtig aussieht, muss dies alles berechnet und berücksichtigt werden. <br><br>  Zunächst müssen wir herausfinden, wohin jede Ebene gerichtet ist, und dazu benötigen wir <em>den Normalenvektor der</em> Ebene.  Dies ist ein weiterer Pfeil, aber im Gegensatz zum Positionsvektor ist seine Größe nicht wichtig (tatsächlich nimmt die Größe der Normalenvektoren nach der Berechnung immer ab, so dass sie eine Länge von 1 haben), und er ist immer <em>senkrecht</em> (im rechten Winkel) zur Ebene gerichtet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/228/84c/836/22884c83697e201f3b00bb7d06f6f95f.png"></div><br>  Die Normale zur Ebene jedes Dreiecks wird berechnet, indem das Vektorprodukt zweier Richtungsvektoren (über <strong>p</strong> und <strong>q gezeigt</strong> ) bestimmt wird, die die Seiten des Dreiecks bilden.  Tatsächlich ist es besser, sie für jeden Scheitelpunkt und nicht für ein Dreieck zu berechnen, aber da es immer mehr von ersteren als von letzteren gibt, ist es schneller, die Normalen für die Dreiecke zu berechnen. <br><br>  Nachdem Sie die Normalen an der Oberfläche erhalten haben, können Sie beginnen, die Lichtquelle und die Kamera zu betrachten.  Beim 3D-Rendering können Lichtquellen unterschiedlichen Typs sein. In diesem Artikel werden jedoch nur <em>Richtungsquellen betrachtet</em> , z. B. Scheinwerfer.  Wie die Ebene des Dreiecks zeigen der Scheinwerfer und die Kamera in eine bestimmte Richtung, ungefähr so: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/f24/b91/3a8f24b915d631a9608faaf106b04300.png"></div><br>  Der Lichtquellenvektor und der Normalenvektor können verwendet werden, um den Winkel zu berechnen, unter dem Licht auf die Oberfläche fällt (unter Verwendung der Beziehung zwischen dem Skalarprodukt der Vektoren und dem Produkt ihrer Größe).  Die Eckpunkte des Dreiecks enthalten zusätzliche Informationen zu Farbe und Material.  Material beschreibt, was mit Licht passiert, wenn es auf die Oberfläche trifft. <br><br>  Eine glatte Metalloberfläche reflektiert fast das gesamte einfallende Licht in dem Winkel, in dem es fällt, und ändert kaum die Farbe des Objekts.  Raues mattes Material streut das Licht weniger vorhersehbar und ändert die Farbe geringfügig.  Um dies zu berücksichtigen, müssen Sie den Scheitelpunkten zusätzliche Werte hinzufügen: <br><br><ul><li>  Original Grundfarbe </li><li>  Umgebungsmaterialattribut - Ein Wert, der bestimmt, wie viel Hintergrundbeleuchtung einen Scheitelpunkt absorbieren und reflektieren kann </li><li>  Das Attribut des diffusen Materials ist ein anderer Wert, aber diesmal wird die „Rauheit“ des Scheitelpunkts bestimmt, was wiederum die Absorptions- und Reflexionsmenge des gestreuten Lichts beeinflusst </li><li>  Spiegelmaterialattribute - Zwei Werte, die den Scheitelpunktglanz angeben </li></ul><br>  Verschiedene Beleuchtungsmodelle verwenden unterschiedliche mathematische Formeln, um alle diese Attribute zu gruppieren. Das Ergebnis der Berechnung ist der ausgehende Beleuchtungsvektor.  In Kombination mit dem Kameravektor können Sie das Gesamterscheinungsbild des Dreiecks bestimmen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/627/648/a21/627648a213ed357982314f7ed7fdd915.jpg"></div><br>  <i>Eine gerichtete Lichtquelle beleuchtet viele verschiedene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nvidia-Demos</a></i> <br><br>  Wir haben viele detaillierte Details aus gutem Grund weggelassen: Öffnen Sie ein 3D-Rendering-Tutorial, und Sie werden sehen, dass ganze Kapitel diesem Prozess gewidmet sind.  In modernen Spielen wird der Großteil aller Berechnungen von Licht- und Materialeffekten jedoch in der Pixelverarbeitungsphase durchgeführt, sodass wir im nächsten Artikel darauf zurückkommen werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7c/8b7/3b0/d7c8b73b0185c20eb23b2a9fdee1cba6.png"></div><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispielcode</a> B. Anguelov zeigt, wie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phong-Lichtreflexionsmodell</a> im Vertex-Shader verarbeitet werden kann.</i> <br><br>  Alles, was wir oben untersucht haben, wird von Vertex-Shadern ausgeführt, und es scheint, dass für sie nichts unmöglich ist.  das ist leider nicht so.  Scheitelpunkt-Shader können keine neuen Scheitelpunkte erstellen, und jeder Shader muss jeden einzelnen Scheitelpunkt verarbeiten.  Es wäre praktisch, wenn Sie den Code verwenden könnten, um neue Dreiecke zwischen den bereits vorhandenen zu erstellen (um die visuelle Qualität zu verbessern) und einen Shader zu haben, der das gesamte Grundelement verarbeitet (um die Verarbeitung zu beschleunigen).  In modernen GPUs können wir <em>das schaffen</em> ! <br><br><h2>  Bitte, Sir, ich möchte mehr (Dreiecke) </h2><br>  Moderne Grafikchips sind extrem leistungsfähig und können jede Sekunde Millionen von Matrixvektorberechnungen durchführen.  Sie können leicht mit einem riesigen Haufen von Gipfeln gleichzeitig fertig werden.  Auf der anderen Seite ist das Erstellen sehr detaillierter Modelle für das Rendern ein sehr langer Prozess. Wenn sich das Modell in einiger Entfernung von der Szene befindet, werden alle diese Details verschwendet. <br><br>  Das heißt, wir müssen dem Prozessor irgendwie befehlen, ein großes Grundelement, beispielsweise ein flaches Dreieck, in eine Reihe kleinerer Dreiecke zu teilen, die sich innerhalb des ursprünglichen Dreiecks befinden.  Ein solcher Prozess wird als <em>Tesselation bezeichnet,</em> und Grafikchips haben bereits gelernt, ihn sehr gut auszuführen.  Im Laufe der Jahre der Entwicklung hat der Grad der Kontrolle, den Programmierer über diesen Prozess haben, zugenommen. <br><br>  Um dies in Aktion zu betrachten, verwenden wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heaven-Benchmark-Tool der Unigine-Engine</a> , da wir damit unterschiedliche Tessellationswerte auf die im Test verwendeten Modelle anwenden können. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d11/630/5fd/d116305fd0fa789635bc3631a4463829.jpg"></div><br>             . ,        —   ,   .     :  Unigine      ,    . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1c/8fb/399/e1c8fb3998d448711164832c4b3af2ff.jpg"></div><br> ,       .   ,    ,   ,         (    wireframe): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c2/691/fec/0c2691fec046708d4c65058ed3cec016.jpg"></div><br>  ,      —   !    ,       . <br><br>  Direct3D          (   <em> (sub-division)</em> ),   .    <i>  (hull shader)</i> —  ,       <em>  (geometry patch)</em> .     ,  ,          . <br><br>  -        .    <em>  (domain shader)</em> ,     .          ,       ,        . <br><br>    ?      : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c0/ca9/5af/3c0ca95af3ce89f1ae854706dfd04adc.jpg"></div><br>  ,      ,     .        ,        — , ,     . <br><br>      wireframe         ,   ,       ,       .             ,      . <br><br>  ,         Direct3D;          -, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RasterTek</a> . <br><br>    ,     … <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13a/3bd/3d4/13a3bd3d482f26404d92d3ab60694fa3.png"></div><br>       (. <a href=""> </a> ):  ,    ,  ,  ,   ,   .   ,     Unigine    ,     . <br><br><h2> «»   ! </h2><br> ,  ,          ?  ,       .     ,       ,       , , , ,    . <br><br>  ,         — <em> </em> .      ,        .             . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/602/97d/f09/60297df09a132ab07b00140fa2a07b77.jpg"></div><br> <i>UL Benchmark's 3DMark Vantage —      </i> <br><br> Direct3D,      API,       .            ( <em></em> ),               .     Microsoft  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Direct3D</a> ,      : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/638/134/de2/638134de2960977f2847aab27c88df84.png"></div><br>  <em>  (stream output)</em> ,  ,            (   ),     ,    .          <em></em>  ,       ,         . <br><br>   —     ,    ,        .          ,      -    . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/760/829/bdd760829e81753b4938fd8ff3076b6d.jpg"></div><br> <i>.  .</i> <br><br>          ,    (GPU)  API      —    ,         . <br><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 3D-</a>        ;          ,        .        3D- —    ,       ,       . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472688/">https://habr.com/ru/post/de472688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472674/index.html">Umgebungsvariablen für Python-Projekte</a></li>
<li><a href="../de472676/index.html">Wir erstellen die Abteilung für Jones, um den Hauptteams zu helfen, indem wir nur Slack, Jira und das blaue Isolierband verwenden</a></li>
<li><a href="../de472682/index.html">Verlangsamung des Alterns mit Arzneimittelsynergien bei C. elegans</a></li>
<li><a href="../de472684/index.html">Überraschen Sie fsync () PostgreSQL</a></li>
<li><a href="../de472686/index.html">Videostudio basierend auf i486</a></li>
<li><a href="../de472690/index.html">Was ist neu in Zabbix 4.4?</a></li>
<li><a href="../de472694/index.html">Mehr als Ceph: MCS Block Cloud Storage</a></li>
<li><a href="../de472702/index.html">JH Regenwasser „Wie man Katzen weidet“: Rassen von Programmierern und Merkmale ihrer Zucht</a></li>
<li><a href="../de472708/index.html">Imperva enthüllte technische Details des Cloud WAF-Hacks</a></li>
<li><a href="../de472714/index.html">Wo kann der Front-End-Mitarbeiter nach Arbeit suchen und nicht darauf hereinfallen: Telegramm, Slack und nicht nur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>