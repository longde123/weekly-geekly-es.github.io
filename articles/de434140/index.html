<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëí üê® üöµüèΩ Eine kurze Geschichte der asynchronen Javascript-Funktionen üåñ ‚úåüèø üëãüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="W√§hrend ich Javascript studierte, stie√ü ich immer wieder auf zahlreiche Artikel √ºber asynchrone Funktionen und Operationen. Trotz der unbestrittenen V...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine kurze Geschichte der asynchronen Javascript-Funktionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434140/"> W√§hrend ich Javascript studierte, stie√ü ich immer wieder auf zahlreiche Artikel √ºber asynchrone Funktionen und Operationen.  Trotz der unbestrittenen Vorteile einer solchen Funktion wurde ich jedes Mal durch die von den Autoren zitierte Auflistung in Schwierigkeiten gebracht.  Die Worte √§nderten sich, die Essenz blieb dieselbe, Brei braute sich in meinem Kopf zusammen.  Under the Cut - ein kleiner Leitfaden zur historischen Entwicklung und zu den Versionen von ECMA. <br><a name="habracut"></a><br><h3>  Warum brauchen wir asynchrone Operationen? </h3><br>  Ein Computerprogramm kann eine unbegrenzte Anzahl von Aufgaben ausf√ºhren.  Es ist kein Geheimnis, dass Webanwendungen mit vielen verschiedenen Aufgaben arbeiten m√ºssen, f√ºr die h√§ufig dieselben Daten verwendet werden m√ºssen.  Eines der h√§ufigsten Beispiele ist das Anzeigen von Benutzerinformationen (UI) und das Abrufen von Informationen mithilfe von Serveranforderungen.  Es √ºberrascht nicht, dass fast jeder Webentwickler damit konfrontiert ist: Arbeiten mit einer bestimmten Datenbank, Bereitstellen einer Benutzeroberfl√§che, Organisieren einer API - all dies ist buchst√§blich in jeder Testaufgabe nicht nur von JS-Programmierern enthalten. <br><br>  <i>Warum nicht Befehle nacheinander ausf√ºhren?</i> <br><br>  Oft k√∂nnen die vom Benutzer ben√∂tigten Informationen erst nach einer betr√§chtlichen Zeitspanne erhalten werden.  Wenn Sie das Programm wie folgt organisieren: <br><br><ol><li>  Abrufen von Informationen von der Website https: / some / api / item / 1 </li><li>  Zeigen Sie Informationen zum ersten Element auf dem Bildschirm an. </li></ol><br>  Es treten ernsthafte Schwierigkeiten beim Rendern der Seite und beim Erzeugen eines angenehmen Eindrucks beim Benutzer auf (die sogenannte Benutzererfahrung).  Stellen Sie sich vor: Eine Seite, beispielsweise Netflix oder Aliexpress, muss Daten aus Hunderten von Datenbanken abrufen, bevor der Benutzer den Inhalt anzeigen kann.  Eine solche Verz√∂gerung √§hnelt dem Laden eines 3D-Spiellevels. Wenn der Spieler bereit ist zu warten, m√∂chte der Benutzer der Website im Moment die meisten Informationen erhalten. <br><br>  Die L√∂sung wurde gefunden: <b>asynchrone Operationen</b> .  W√§hrend der Haupt-Thread des Programms damit besch√§ftigt ist, Website-Elemente auf Leinwand zu initialisieren und anzuzeigen, gibt er auch Aufgaben an die anderen Threads aus, um ‚Äû <i>die Waren f√ºr den Benutzer zu erhalten</i> ‚Äú.  Sobald dieser Thread seine Arbeit abgeschlossen hat, ‚Äûsetzen‚Äú sich die Informationen im Hauptthread ab und werden zur Anzeige verf√ºgbar. Auf der Webseite selbst befindet sich ein bestimmter Platzhalter - ein Objekt, das Platz f√ºr zuk√ºnftige Informationen einnimmt. <br><br><img src="https://habrastorage.org/webt/vy/r4/9o/vyr49os4a1j-sw7sgg3mi9-_gw8.png" alt="Bild" width="320" height="240"><br><br>  Zu diesem Zeitpunkt wird die Seite bereits angezeigt, obwohl einige Anforderungen noch nicht bestanden wurden. <br><br><img src="https://habrastorage.org/webt/uo/aw/vz/uoawvz0tie7t2hpm6zyeojapgu0.png" alt="Bild" width="320" height="240"><br><br>  H√∂chstwahrscheinlich geben einige weitere Anforderungen am Ende der Seite einen Wert zur√ºck, und die Seite wird weiterhin aktualisiert und dynamisch gerendert, ohne dass dies f√ºr den Benutzer unangenehm ist. <br><br><h3>  ES5 und fr√ºher: R√ºckruf </h3><br>  Bevor wir mit der √úberpr√ºfung von R√ºckrufen fortfahren, werfen wir einen Blick auf die <b>Funktionen h√∂herer Ordnung</b> . <br><br>  Eine Funktion h√∂herer Ordnung in JS ist eine <i>Funktion, die eine andere Funktion als Argument verwendet</i> .  Hier ist ein Beispiel: <br><br><pre><code class="javascript hljs">objectIsString(objectRef) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(objectRef) === <span class="hljs-string"><span class="hljs-string">'String'</span></span>; } listOfObjects.filter(objectIsString);</code> </pre> <br>  Daher wurde die Funktion objectIsString an die Funktion h√∂herer Ordnung - filter - √ºbergeben, mit der listOfObjects gefiltert und nur Objekte vom Typ string in der Liste belassen werden k√∂nnen. <br>  R√ºckrufe funktionieren √§hnlich.  Dies ist eine Funktion, die als Argument an eine andere Funktion √ºbergeben wird.  Am h√§ufigsten wird die Funktion setTimeout als Beispiel f√ºr eine Funktion verwendet, die R√ºckrufe verarbeitet.  Im Allgemeinen wird dies als setTimeout (function, timeoutValue) verwendet, wobei function eine R√ºckruffunktion ist, die vom Browser nach einem im Timeout angegebenen Zeitraum ausgef√ºhrt wird. <br><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">2000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><br>  Drucken 2 1. <br><br><h3>  ES 6: Versprechen </h3><br>  In Standard 6 wurde ein neuer Typ eingef√ºhrt - Versprechen (Versprechen, im Folgenden - Versprechen).  Ein Versprechen ist ein Typ, dessen Objekte einen von drei Zust√§nden haben: ausstehend, erf√ºllt, abgelehnt.  Dar√ºber hinaus k√∂nnen Sie mit den letzten beiden Zust√§nden Funktionen - R√ºckrufe - ‚Äûverkn√ºpfen‚Äú.  Sobald der im Rahmen des Versprechens selbst beschriebene asynchrone Prozess zum Erfolg / Misserfolg f√ºhrt, wird die damit verbundene Funktion aufgerufen.  Dieser Prozess wird als "h√§ngende R√ºckrufe" bezeichnet und mit den Methoden "then" und "catch" des Versprechens selbst ausgef√ºhrt.  Der Unterschied besteht darin, dass beim Aufrufen der Argumente zwei Funktionen √ºbertragen werden - bei Erfolg (onFullfillment) und Misserfolg (onRejected), w√§hrend catch, da es nicht schwer zu erraten ist, nur eine Funktion zum Verarbeiten von Fehlern in einem Versprechen akzeptiert.  Um festzustellen, ob ein Versprechen in einem bestimmten Fall erfolgreich ausgef√ºhrt wurde, und um das zur√ºckgegebene Ergebnis zu parametrisieren <br><br>  Lassen Sie uns schrittweise ein Versprechen erstellen und verwenden. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// : let promise; //     Promise. let promise = new Promise((resolve, reject) =&gt; { }); //  ,  . let promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve("result"); }, 1000); });</span></span></code> </pre> <br>  F√ºgen Sie nun Ereignishandler mit der then-Methode hinzu.  Das Argument f√ºr die Funktion, die den Erfolg behandelt, ist das Ergebnis, w√§hrend das Argument f√ºr die Funktion, die den Fehler des Versprechens behandelt, ein Fehler ist. <br><br><pre> <code class="javascript hljs">promise .then( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> { }, error =&gt; { } ); <span class="hljs-comment"><span class="hljs-comment">//     ‚Äì . promise .then( result =&gt; { //  - -    resolve alert("Fulfilled: " + result); // result -  resolve }, error =&gt; { //   -    reject alert("Rejected: " + error); // error -  reject } );</span></span></code> </pre><br>  Fertig! <br><br>  Wir werden also noch einmal kurz den Prozess der Erstellung eines Versprechens beschreiben: <br><br><ol><li>  Initialisieren Sie das Objekt (neues Versprechen) </li><li>  Wir √ºbergeben die Funktion der Aufl√∂sung und / oder Ablehnung als einziges Argument an den Konstruktor.  Eine Funktion muss mindestens 1 asynchronen Betrieb haben </li><li>  Mit den then / catch-Methoden f√ºgen wir Funktionen hinzu - Ergebnishandler. </li></ol><br><h3>  Generatoren.  Ausbeute </h3><br>  Auch im ES6-Standard wurde ein neuer Funktionstyp definiert - Generatoren.  Diese Funktionen k√∂nnen auf den ersten Blick bei identischen Aufrufen mehrmals unterschiedliche Werte zur√ºckgeben.  Mal sehen, wie sie es machen und warum sie es benutzen. <br><br>  Die Standardform des Generators: function * functionName () {}.  Im Hauptteil der Funktionen selbst wird das Wort Ausbeute verwendet, um einen Zwischenwert zur√ºckzugeben. <br><br>  Betrachten Sie als Beispiel den folgenden Generator: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> <br>  Im Moment befindet sich der Generator am Anfang seiner Ausf√ºhrung.  Bei jedem Aufruf der n√§chsten Generatormethode wird der vor der n√§chsten Ausbeute (oder R√ºckgabe) beschriebene Code ausgef√ºhrt, und der in der Zeile mit einem dieser W√∂rter angegebene Wert wird ebenfalls zur√ºckgegeben. <br><br><pre> <code class="javascript hljs">Let one = generateNumber.next(); <span class="hljs-comment"><span class="hljs-comment">// {value: 1, done: false}</span></span></code> </pre> <br>  Der n√§chste Aufruf gibt den Wert 2 auf die gleiche Weise zur√ºck. Der dritte Aufruf gibt den Wert 3 zur√ºck und beendet die Ausf√ºhrung der Funktion. <br><br><pre> <code class="javascript hljs">Let two = generateNumber.next(); <span class="hljs-comment"><span class="hljs-comment">// {value: 2, done: false} Let three = generateNumber.next(); // {value: 3, done: false}</span></span></code> </pre> <br>  Trotzdem kann √ºber die <i>n√§chste</i> Funktion auf den Generator zugegriffen werden.  Es wird jedoch der gleiche Wert zur√ºckgegeben: das Objekt {done: true}. <br><br><h3>  ES7.  Async / warten </h3><br>  Zusammen mit dem Wunsch, OOP-Liebhabern mithilfe syntaktischer Zuckerklassen und Nachahmung der Vererbung zu gefallen, versuchen die Entwickler von ES7, das Verst√§ndnis von Javascript zu erleichtern und Liebhabern das Schreiben von synchronem Code zu erm√∂glichen.  Mit asynchronen / wartenden Konstrukten kann der Benutzer asynchronen Code so √§hnlich wie m√∂glich zu synchron schreiben.  Falls gew√ºnscht, k√∂nnen Sie die k√ºrzlich untersuchten Versprechen loswerden und den Code mit minimalen √Ñnderungen neu schreiben. <br>  Betrachten Sie ein Beispiel: <br><br>  Versprechen verwenden: <br><br><pre> <code class="javascript hljs">requestBook(id) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bookAPIHelper.getBook(id).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(book)}); }</code> </pre> <br>  Verwenden von async / await. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> requestBook(id) { Const book = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> bookAPIHelper.getBook(id); Console.log(book); }</code> </pre> <br>  Beschreiben wir, was wir gesehen haben: <br><br>  1) Async - Schl√ºsselwort, das beim Deklarieren einer asynchronen Funktion hinzugef√ºgt wird <br>  2) Warten - ein Schl√ºsselwort, das beim Aufrufen einer asynchronen Funktion hinzugef√ºgt wird. <br><br><h3>  ES8.  Asynchrone Iteration </h3><br>  Das synchrone Durchlaufen von Daten wurde bereits in ES5 m√∂glich.  Nach zwei Spezifikationen wurde beschlossen, die M√∂glichkeit einer asynchronen Iteration in asynchronen Datenquellen hinzuzuf√ºgen.  Wenn next () aufgerufen wird, gibt es nicht {value, done} zur√ºck, sondern ein Versprechen (siehe ES6). <br><br>  Schauen wir uns die Funktion createAsyncIterable (iterable) an. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAsyncIterable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">iterable</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> elem <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iterable) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> elem; } }</code> </pre> <br>  Wie Sie sehen k√∂nnen, initialisiert die Funktion die Sammlung f√ºr jeden Aufruf der Elemente, f√ºr die ein Versprechen mit dem in iterable angegebenen Wert zur√ºckgegeben wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> asyncIterable = createAsyncIterable([<span class="hljs-string"><span class="hljs-string">'async 1'</span></span>, <span class="hljs-string"><span class="hljs-string">'async 2'</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> asyncIterator = asyncIterable[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.asyncIterator](); asyncIterator.next() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result); <span class="hljs-comment"><span class="hljs-comment">// { // value: 'async 1', // done: false, // } return asyncIterator.next(); }) .then(result =&gt; { console.log(result); // { // value: 'async 2', // done: false, // } return asyncIterator.next(); }) .then(result =&gt; { console.log(result); // { // value: 'undefined', // done: true, // } });</span></span></code> </pre> <br>  Dar√ºber hinaus definiert der neue Standard eine Warteschleife, die f√ºr solche Operationen geeignet ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> createAsyncIterable([<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]))</code> </pre> <br><h3>  TL; DR </h3><br>  Es ist √ºberhaupt nicht notwendig, auswendig zu wissen und sich zu merken, zu welcher Version von ECMAScript diese oder jene Syntax geh√∂rt, insbesondere wenn Sie gerade erst mit dem asynchronen Verhalten in JS vertraut geworden sind.  Gleichzeitig erm√∂glicht das Studium der Asynchronit√§t in genau der Reihenfolge, die in der Geschichte der Entwicklung von Spezifikationen vorgeschlagen wurde, dem Programmierer, die an die JS-Engine √ºbergebene Syntax und Anweisungen perfekt zu verstehen, aber auch der Logik der Verbesserung von ECMAScript als Produkt zu folgen, die von JS-Entwicklern diktierten Trends zu verstehen, sie zu trennen und zu akzeptieren . <br><br>  Kurz gesagt: <br><br>  R√ºckrufe &lt;= ES5 <br>  Versprechen, Ertrag (Generatoren): ES6 <br>  Async / warten: ES7 <br>  Asynchrone Iteratoren: ES8 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434140/">https://habr.com/ru/post/de434140/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434130/index.html">Reaktive Schnittstelle. Vortrag von Artyom Belov auf den FrontTalks 2018</a></li>
<li><a href="../de434132/index.html">Kaufen Sie einen Fernseher und rollen Sie ihn auf: LG plant, im kommenden Jahr mit dem Verkauf flexibler Fernseher zu beginnen</a></li>
<li><a href="../de434134/index.html">Analyse der Ergebnisse der Kaggle ML & DS-Umfrage 2018</a></li>
<li><a href="../de434136/index.html">Unternehmensanatomie</a></li>
<li><a href="../de434138/index.html">Wir schreiben unsere eigene virtuelle Maschine</a></li>
<li><a href="../de434142/index.html">Das QRL-Team hat eine enge Frist f√ºr die Token-Migration festgelegt</a></li>
<li><a href="../de434146/index.html">Top 10 IT-Filme</a></li>
<li><a href="../de434150/index.html">Merkmale der Arbeitssuche in Europa</a></li>
<li><a href="../de434154/index.html">Neujahrsdatensatz 2018: Offene Semantik der russischen Sprache</a></li>
<li><a href="../de434156/index.html">Fraktal von Gerasimov. Ein Muster gefunden. Schwarzer Tisch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>