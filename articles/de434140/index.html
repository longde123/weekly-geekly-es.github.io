<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👒 🐨 🚵🏽 Eine kurze Geschichte der asynchronen Javascript-Funktionen 🌖 ✌🏿 👋🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Während ich Javascript studierte, stieß ich immer wieder auf zahlreiche Artikel über asynchrone Funktionen und Operationen. Trotz der unbestrittenen V...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine kurze Geschichte der asynchronen Javascript-Funktionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434140/"> Während ich Javascript studierte, stieß ich immer wieder auf zahlreiche Artikel über asynchrone Funktionen und Operationen.  Trotz der unbestrittenen Vorteile einer solchen Funktion wurde ich jedes Mal durch die von den Autoren zitierte Auflistung in Schwierigkeiten gebracht.  Die Worte änderten sich, die Essenz blieb dieselbe, Brei braute sich in meinem Kopf zusammen.  Under the Cut - ein kleiner Leitfaden zur historischen Entwicklung und zu den Versionen von ECMA. <br><a name="habracut"></a><br><h3>  Warum brauchen wir asynchrone Operationen? </h3><br>  Ein Computerprogramm kann eine unbegrenzte Anzahl von Aufgaben ausführen.  Es ist kein Geheimnis, dass Webanwendungen mit vielen verschiedenen Aufgaben arbeiten müssen, für die häufig dieselben Daten verwendet werden müssen.  Eines der häufigsten Beispiele ist das Anzeigen von Benutzerinformationen (UI) und das Abrufen von Informationen mithilfe von Serveranforderungen.  Es überrascht nicht, dass fast jeder Webentwickler damit konfrontiert ist: Arbeiten mit einer bestimmten Datenbank, Bereitstellen einer Benutzeroberfläche, Organisieren einer API - all dies ist buchstäblich in jeder Testaufgabe nicht nur von JS-Programmierern enthalten. <br><br>  <i>Warum nicht Befehle nacheinander ausführen?</i> <br><br>  Oft können die vom Benutzer benötigten Informationen erst nach einer beträchtlichen Zeitspanne erhalten werden.  Wenn Sie das Programm wie folgt organisieren: <br><br><ol><li>  Abrufen von Informationen von der Website https: / some / api / item / 1 </li><li>  Zeigen Sie Informationen zum ersten Element auf dem Bildschirm an. </li></ol><br>  Es treten ernsthafte Schwierigkeiten beim Rendern der Seite und beim Erzeugen eines angenehmen Eindrucks beim Benutzer auf (die sogenannte Benutzererfahrung).  Stellen Sie sich vor: Eine Seite, beispielsweise Netflix oder Aliexpress, muss Daten aus Hunderten von Datenbanken abrufen, bevor der Benutzer den Inhalt anzeigen kann.  Eine solche Verzögerung ähnelt dem Laden eines 3D-Spiellevels. Wenn der Spieler bereit ist zu warten, möchte der Benutzer der Website im Moment die meisten Informationen erhalten. <br><br>  Die Lösung wurde gefunden: <b>asynchrone Operationen</b> .  Während der Haupt-Thread des Programms damit beschäftigt ist, Website-Elemente auf Leinwand zu initialisieren und anzuzeigen, gibt er auch Aufgaben an die anderen Threads aus, um „ <i>die Waren für den Benutzer zu erhalten</i> “.  Sobald dieser Thread seine Arbeit abgeschlossen hat, „setzen“ sich die Informationen im Hauptthread ab und werden zur Anzeige verfügbar. Auf der Webseite selbst befindet sich ein bestimmter Platzhalter - ein Objekt, das Platz für zukünftige Informationen einnimmt. <br><br><img src="https://habrastorage.org/webt/vy/r4/9o/vyr49os4a1j-sw7sgg3mi9-_gw8.png" alt="Bild" width="320" height="240"><br><br>  Zu diesem Zeitpunkt wird die Seite bereits angezeigt, obwohl einige Anforderungen noch nicht bestanden wurden. <br><br><img src="https://habrastorage.org/webt/uo/aw/vz/uoawvz0tie7t2hpm6zyeojapgu0.png" alt="Bild" width="320" height="240"><br><br>  Höchstwahrscheinlich geben einige weitere Anforderungen am Ende der Seite einen Wert zurück, und die Seite wird weiterhin aktualisiert und dynamisch gerendert, ohne dass dies für den Benutzer unangenehm ist. <br><br><h3>  ES5 und früher: Rückruf </h3><br>  Bevor wir mit der Überprüfung von Rückrufen fortfahren, werfen wir einen Blick auf die <b>Funktionen höherer Ordnung</b> . <br><br>  Eine Funktion höherer Ordnung in JS ist eine <i>Funktion, die eine andere Funktion als Argument verwendet</i> .  Hier ist ein Beispiel: <br><br><pre><code class="javascript hljs">objectIsString(objectRef) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(objectRef) === <span class="hljs-string"><span class="hljs-string">'String'</span></span>; } listOfObjects.filter(objectIsString);</code> </pre> <br>  Daher wurde die Funktion objectIsString an die Funktion höherer Ordnung - filter - übergeben, mit der listOfObjects gefiltert und nur Objekte vom Typ string in der Liste belassen werden können. <br>  Rückrufe funktionieren ähnlich.  Dies ist eine Funktion, die als Argument an eine andere Funktion übergeben wird.  Am häufigsten wird die Funktion setTimeout als Beispiel für eine Funktion verwendet, die Rückrufe verarbeitet.  Im Allgemeinen wird dies als setTimeout (function, timeoutValue) verwendet, wobei function eine Rückruffunktion ist, die vom Browser nach einem im Timeout angegebenen Zeitraum ausgeführt wird. <br><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">2000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><br>  Drucken 2 1. <br><br><h3>  ES 6: Versprechen </h3><br>  In Standard 6 wurde ein neuer Typ eingeführt - Versprechen (Versprechen, im Folgenden - Versprechen).  Ein Versprechen ist ein Typ, dessen Objekte einen von drei Zuständen haben: ausstehend, erfüllt, abgelehnt.  Darüber hinaus können Sie mit den letzten beiden Zuständen Funktionen - Rückrufe - „verknüpfen“.  Sobald der im Rahmen des Versprechens selbst beschriebene asynchrone Prozess zum Erfolg / Misserfolg führt, wird die damit verbundene Funktion aufgerufen.  Dieser Prozess wird als "hängende Rückrufe" bezeichnet und mit den Methoden "then" und "catch" des Versprechens selbst ausgeführt.  Der Unterschied besteht darin, dass beim Aufrufen der Argumente zwei Funktionen übertragen werden - bei Erfolg (onFullfillment) und Misserfolg (onRejected), während catch, da es nicht schwer zu erraten ist, nur eine Funktion zum Verarbeiten von Fehlern in einem Versprechen akzeptiert.  Um festzustellen, ob ein Versprechen in einem bestimmten Fall erfolgreich ausgeführt wurde, und um das zurückgegebene Ergebnis zu parametrisieren <br><br>  Lassen Sie uns schrittweise ein Versprechen erstellen und verwenden. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// : let promise; //     Promise. let promise = new Promise((resolve, reject) =&gt; { }); //  ,  . let promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve("result"); }, 1000); });</span></span></code> </pre> <br>  Fügen Sie nun Ereignishandler mit der then-Methode hinzu.  Das Argument für die Funktion, die den Erfolg behandelt, ist das Ergebnis, während das Argument für die Funktion, die den Fehler des Versprechens behandelt, ein Fehler ist. <br><br><pre> <code class="javascript hljs">promise .then( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> { }, error =&gt; { } ); <span class="hljs-comment"><span class="hljs-comment">//     – . promise .then( result =&gt; { //  - -    resolve alert("Fulfilled: " + result); // result -  resolve }, error =&gt; { //   -    reject alert("Rejected: " + error); // error -  reject } );</span></span></code> </pre><br>  Fertig! <br><br>  Wir werden also noch einmal kurz den Prozess der Erstellung eines Versprechens beschreiben: <br><br><ol><li>  Initialisieren Sie das Objekt (neues Versprechen) </li><li>  Wir übergeben die Funktion der Auflösung und / oder Ablehnung als einziges Argument an den Konstruktor.  Eine Funktion muss mindestens 1 asynchronen Betrieb haben </li><li>  Mit den then / catch-Methoden fügen wir Funktionen hinzu - Ergebnishandler. </li></ol><br><h3>  Generatoren.  Ausbeute </h3><br>  Auch im ES6-Standard wurde ein neuer Funktionstyp definiert - Generatoren.  Diese Funktionen können auf den ersten Blick bei identischen Aufrufen mehrmals unterschiedliche Werte zurückgeben.  Mal sehen, wie sie es machen und warum sie es benutzen. <br><br>  Die Standardform des Generators: function * functionName () {}.  Im Hauptteil der Funktionen selbst wird das Wort Ausbeute verwendet, um einen Zwischenwert zurückzugeben. <br><br>  Betrachten Sie als Beispiel den folgenden Generator: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> <br>  Im Moment befindet sich der Generator am Anfang seiner Ausführung.  Bei jedem Aufruf der nächsten Generatormethode wird der vor der nächsten Ausbeute (oder Rückgabe) beschriebene Code ausgeführt, und der in der Zeile mit einem dieser Wörter angegebene Wert wird ebenfalls zurückgegeben. <br><br><pre> <code class="javascript hljs">Let one = generateNumber.next(); <span class="hljs-comment"><span class="hljs-comment">// {value: 1, done: false}</span></span></code> </pre> <br>  Der nächste Aufruf gibt den Wert 2 auf die gleiche Weise zurück. Der dritte Aufruf gibt den Wert 3 zurück und beendet die Ausführung der Funktion. <br><br><pre> <code class="javascript hljs">Let two = generateNumber.next(); <span class="hljs-comment"><span class="hljs-comment">// {value: 2, done: false} Let three = generateNumber.next(); // {value: 3, done: false}</span></span></code> </pre> <br>  Trotzdem kann über die <i>nächste</i> Funktion auf den Generator zugegriffen werden.  Es wird jedoch der gleiche Wert zurückgegeben: das Objekt {done: true}. <br><br><h3>  ES7.  Async / warten </h3><br>  Zusammen mit dem Wunsch, OOP-Liebhabern mithilfe syntaktischer Zuckerklassen und Nachahmung der Vererbung zu gefallen, versuchen die Entwickler von ES7, das Verständnis von Javascript zu erleichtern und Liebhabern das Schreiben von synchronem Code zu ermöglichen.  Mit asynchronen / wartenden Konstrukten kann der Benutzer asynchronen Code so ähnlich wie möglich zu synchron schreiben.  Falls gewünscht, können Sie die kürzlich untersuchten Versprechen loswerden und den Code mit minimalen Änderungen neu schreiben. <br>  Betrachten Sie ein Beispiel: <br><br>  Versprechen verwenden: <br><br><pre> <code class="javascript hljs">requestBook(id) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bookAPIHelper.getBook(id).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(book)}); }</code> </pre> <br>  Verwenden von async / await. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> requestBook(id) { Const book = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> bookAPIHelper.getBook(id); Console.log(book); }</code> </pre> <br>  Beschreiben wir, was wir gesehen haben: <br><br>  1) Async - Schlüsselwort, das beim Deklarieren einer asynchronen Funktion hinzugefügt wird <br>  2) Warten - ein Schlüsselwort, das beim Aufrufen einer asynchronen Funktion hinzugefügt wird. <br><br><h3>  ES8.  Asynchrone Iteration </h3><br>  Das synchrone Durchlaufen von Daten wurde bereits in ES5 möglich.  Nach zwei Spezifikationen wurde beschlossen, die Möglichkeit einer asynchronen Iteration in asynchronen Datenquellen hinzuzufügen.  Wenn next () aufgerufen wird, gibt es nicht {value, done} zurück, sondern ein Versprechen (siehe ES6). <br><br>  Schauen wir uns die Funktion createAsyncIterable (iterable) an. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAsyncIterable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">iterable</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> elem <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iterable) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> elem; } }</code> </pre> <br>  Wie Sie sehen können, initialisiert die Funktion die Sammlung für jeden Aufruf der Elemente, für die ein Versprechen mit dem in iterable angegebenen Wert zurückgegeben wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> asyncIterable = createAsyncIterable([<span class="hljs-string"><span class="hljs-string">'async 1'</span></span>, <span class="hljs-string"><span class="hljs-string">'async 2'</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> asyncIterator = asyncIterable[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.asyncIterator](); asyncIterator.next() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result); <span class="hljs-comment"><span class="hljs-comment">// { // value: 'async 1', // done: false, // } return asyncIterator.next(); }) .then(result =&gt; { console.log(result); // { // value: 'async 2', // done: false, // } return asyncIterator.next(); }) .then(result =&gt; { console.log(result); // { // value: 'undefined', // done: true, // } });</span></span></code> </pre> <br>  Darüber hinaus definiert der neue Standard eine Warteschleife, die für solche Operationen geeignet ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> createAsyncIterable([<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]))</code> </pre> <br><h3>  TL; DR </h3><br>  Es ist überhaupt nicht notwendig, auswendig zu wissen und sich zu merken, zu welcher Version von ECMAScript diese oder jene Syntax gehört, insbesondere wenn Sie gerade erst mit dem asynchronen Verhalten in JS vertraut geworden sind.  Gleichzeitig ermöglicht das Studium der Asynchronität in genau der Reihenfolge, die in der Geschichte der Entwicklung von Spezifikationen vorgeschlagen wurde, dem Programmierer, die an die JS-Engine übergebene Syntax und Anweisungen perfekt zu verstehen, aber auch der Logik der Verbesserung von ECMAScript als Produkt zu folgen, die von JS-Entwicklern diktierten Trends zu verstehen, sie zu trennen und zu akzeptieren . <br><br>  Kurz gesagt: <br><br>  Rückrufe &lt;= ES5 <br>  Versprechen, Ertrag (Generatoren): ES6 <br>  Async / warten: ES7 <br>  Asynchrone Iteratoren: ES8 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434140/">https://habr.com/ru/post/de434140/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434130/index.html">Reaktive Schnittstelle. Vortrag von Artyom Belov auf den FrontTalks 2018</a></li>
<li><a href="../de434132/index.html">Kaufen Sie einen Fernseher und rollen Sie ihn auf: LG plant, im kommenden Jahr mit dem Verkauf flexibler Fernseher zu beginnen</a></li>
<li><a href="../de434134/index.html">Analyse der Ergebnisse der Kaggle ML & DS-Umfrage 2018</a></li>
<li><a href="../de434136/index.html">Unternehmensanatomie</a></li>
<li><a href="../de434138/index.html">Wir schreiben unsere eigene virtuelle Maschine</a></li>
<li><a href="../de434142/index.html">Das QRL-Team hat eine enge Frist für die Token-Migration festgelegt</a></li>
<li><a href="../de434146/index.html">Top 10 IT-Filme</a></li>
<li><a href="../de434150/index.html">Merkmale der Arbeitssuche in Europa</a></li>
<li><a href="../de434154/index.html">Neujahrsdatensatz 2018: Offene Semantik der russischen Sprache</a></li>
<li><a href="../de434156/index.html">Fraktal von Gerasimov. Ein Muster gefunden. Schwarzer Tisch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>