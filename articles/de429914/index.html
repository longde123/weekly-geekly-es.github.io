<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👋 👩🏽‍🤝‍👩🏼 👩🏽‍🤝‍👩🏻 OpenSceneGraph: Szenendiagramm und intelligente Zeiger 🌟 👨🏽‍🍳 🥪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 
 In einem früheren Artikel haben wir uns die OpenSceneGraph-Assembly aus dem Quellcode angesehen und ein elementares Beispiel geschrieben,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Szenendiagramm und intelligente Zeiger</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429914/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="Bild"><br><br><h1>  Einführung </h1><br>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Artikel haben</a> wir uns die OpenSceneGraph-Assembly aus dem Quellcode angesehen und ein elementares Beispiel geschrieben, in dem eine graue Ebene in einer leeren lila Welt hängt.  Ich stimme zu, nicht zu beeindruckend.  Wie ich bereits sagte, gibt es in diesem kleinen Beispiel die Hauptkonzepte, auf denen diese Grafik-Engine basiert.  Betrachten wir sie genauer.  Das folgende Material verwendet Illustrationen aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexander Bobkovs Blog über OSG</a> (schade, dass der Autor das Schreiben über OSG aufgegeben hat ...).  Der Artikel basiert auch auf Material und Beispielen aus dem Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenSceneGraph 3.0.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anfängerleitfaden</a> <br><br>  Ich muss sagen, dass die vorherige Veröffentlichung einer Kritik ausgesetzt war, der ich teilweise zustimme - das Material kam unausgesprochen heraus und wurde aus dem Zusammenhang gerissen.  Ich werde versuchen, dieses Versäumnis unter dem Schnitt zu beheben. <br><a name="habracut"></a><br><h1>  1. Kurz über das Diagramm der Szene und ihrer Knoten </h1><br>  Das zentrale Konzept der Engine ist das sogenannte <i>Szenendiagramm</i> (es ist kein Zufall, dass es im Namen des Frameworks hängen geblieben ist) - eine hierarchische Baumstruktur, mit der Sie eine logische und räumliche Darstellung einer dreidimensionalen Szene organisieren können.  Das Szenendiagramm enthält den Wurzelknoten und die zugehörigen Zwischen- und Endknoten oder <i>-knoten</i> . <br><br>  Zum Beispiel <br><br><img src="https://habrastorage.org/webt/va/m7/l4/vam7l4ap2qwqgyev2ofzlcbt-vo.png"><br><br>  Diese Grafik zeigt eine Szene, die aus einem Haus und einem Tisch besteht.  Das Haus hat eine bestimmte geometrische Darstellung und befindet sich auf eine bestimmte Weise im Raum relativ zu einem bestimmten grundlegenden Koordinatensystem, das dem Wurzelknoten (Wurzel) zugeordnet ist.  Die Tabelle wird auch durch eine Geometrie beschrieben, die sich in irgendeiner Weise relativ zum Haus und zusammen mit dem Haus befindet - relativ zum Wurzelknoten.  Alle Knoten, die eine gemeinsame Eigenschaft haben, weil sie von einer osg :: Node-Klasse erben, werden entsprechend ihrem funktionalen Zweck in Typen unterteilt <br><br><ol><li>  Gruppenknoten (osg :: Group) - sind die Basisklasse für alle Zwischenknoten und dienen zum Kombinieren anderer Knoten zu Gruppen </li><li>  Transformationsknoten (osg :: Transform und seine Nachkommen) - zur Beschreibung der Transformation von Objektkoordinaten </li><li>  Geometrische Knoten (osg :: Geode) - Endknoten (Blattknoten) des Szenendiagramms, die Informationen zu einem oder mehreren geometrischen Objekten enthalten. </li></ol><br>  Die Geometrie von Szenenobjekten in OSG wird in einem eigenen lokalen Koordinatensystem des Objekts beschrieben.  Transformationsknoten, die sich zwischen diesem Objekt und dem Wurzelknoten befinden, implementieren Matrixkoordinatentransformationen, um die Position des Objekts im Basiskoordinatensystem zu erhalten. <br><br>  Die Knoten führen viele wichtige Funktionen aus, insbesondere speichern sie den Status der Anzeige von Objekten, und dieser Status wirkt sich nur auf den diesem Knoten zugeordneten Untergraphen aus.  Knoten im Szenendiagramm können mehrere Rückrufe zugeordnet werden, Ereignishandler, mit denen Sie den Status des Knotens und den damit verbundenen Untergraphen ändern können. <br><br>  Alle globalen Operationen im Szenendiagramm, die mit dem Erhalten des Endergebnisses auf dem Bildschirm verbunden sind, werden automatisch von der Engine ausgeführt, indem das Diagramm regelmäßig in der Tiefe durchlaufen wird. <br><br>  In dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuletzt</a> untersuchten Beispiel bestand unsere Szene aus einem einzelnen Objekt - einem Flugzeugmodell, das aus einer Datei geladen wurde.  Mit Blick auf die Zukunft werde ich sagen, dass dieses Modell der Blattknoten des Szenendiagramms ist.  Es ist fest mit dem globalen Basiskoordinatensystem des Motors verschweißt. <br><br><h1>  2. OSG-Speicherverwaltung </h1><br>  Da die Knoten des Szenendiagramms viele Daten über Szenenobjekte und Operationen auf diesen speichern, ist es erforderlich, Speicher zuzuweisen, auch dynamisch, um diese Daten zu speichern.  In diesem Fall müssen Sie beim Bearbeiten des Szenendiagramms und beispielsweise beim Löschen einiger seiner Knoten sorgfältig überwachen, dass die gelöschten Knoten des Diagramms nicht mehr verarbeitet werden.  Dieser Prozess ist immer mit Fehlern und zeitaufwändigem Debuggen verbunden, da es für den Entwickler ziemlich schwierig ist zu verfolgen, welche Zeiger auf Objekte auf vorhandene Daten verweisen und welche gelöscht werden sollten.  Ohne effektive Speicherverwaltung treten eher Segmentierungsfehler und Speicherlecks auf. <br><br>  Die Speicherverwaltung ist eine wichtige Aufgabe in OSG und ihr Konzept basiert auf zwei Punkten: <br><br><ol><li>  Zuweisung von Speicher: Sicherstellen der Zuweisung der zum Speichern eines Objekts erforderlichen Speichermenge. <br></li><li>  Speicher freigeben: Gibt den zugewiesenen Speicher an das System zurück, wenn er nicht benötigt wird. <br></li></ol><br>  Viele moderne Programmiersprachen wie C #, Java, Visual Basic .Net und dergleichen verwenden den sogenannten Garbage Collector, um den zugewiesenen Speicher freizugeben.  Das Konzept der C ++ - Sprache sieht einen solchen Ansatz nicht vor, wir können ihn jedoch mithilfe der sogenannten Smart Pointer nachahmen. <br><br>  Heute hat C ++ intelligente Zeiger in seinem Arsenal, das als "out of the box" bezeichnet wird (und der C ++ 17-Standard hat es bereits geschafft, die Sprache von einigen veralteten Arten intelligenter Zeiger zu befreien), aber dies war nicht immer der Fall.  Die früheste der offiziellen OSG-Versionen mit der Nummer 0.9 wurde 2002 geboren, und es gab noch drei Jahre vor der ersten offiziellen Veröffentlichung.  Zu dieser Zeit sah der C ++ - Standard noch keine intelligenten Zeiger vor, und selbst wenn Sie an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen historischen Exkurs</a> glauben, erlebte die Sprache selbst schwere Zeiten.  Das Erscheinungsbild eines Fahrrads in Form eigener Smart Pointer, die in OSG implementiert sind, ist daher keineswegs überraschend.  Dieser Mechanismus ist tief in die Struktur des Motors integriert, daher ist es von Anfang an unbedingt erforderlich, dessen Funktionsweise zu verstehen. <br><br><h1>  3. Die Klassen osg :: ref_ptr &lt;&gt; und osg :: Referenced </h1><br>  OSG bietet einen eigenen intelligenten Zeigermechanismus, der auf der Vorlagenklasse osg :: ref_ptr &lt;&gt; basiert, um die automatische Speicherbereinigung zu implementieren.  Für den ordnungsgemäßen Betrieb stellt OSG eine weitere osg :: Referenced-Klasse zum Verwalten von Speicherblöcken bereit, für die der Verweis auf diese gezählt wird. <br><br>  Die Klasse osg :: ref_ptr &lt;&gt; bietet mehrere Operatoren und Methoden. <br><br><ul><li>  get () ist eine öffentliche Methode, die einen Rohzeiger zurückgibt. Wenn Sie beispielsweise die Vorlage osg :: Node als Argument verwenden, gibt diese Methode osg :: Node * zurück. <br></li><li>  operator * () ist tatsächlich der Dereferenzierungsoperator. <br></li><li>  Mit operator -&gt; () und operator = () können Sie osg :: ref_ptr &lt;&gt; als klassischen Zeiger verwenden, wenn Sie auf die Methoden und Eigenschaften der durch diesen Zeiger beschriebenen Objekte zugreifen. <br></li><li>  operator == (), operator! = () und operator! () - ermöglichen das Ausführen von Vergleichsoperationen für intelligente Zeiger. <br></li><li>  valid () ist eine öffentliche Methode, die true zurückgibt, wenn der verwaltete Zeiger den richtigen Wert hat (nicht NULL).  Der Ausdruck some_ptr.valid () entspricht dem Ausdruck some_ptr! = NULL, wenn some_ptr ein intelligenter Zeiger ist. <br></li><li>  release () ist eine öffentliche Methode, die nützlich ist, wenn Sie eine verwaltete Adresse von einer Funktion zurückgeben möchten.  Darüber wird später ausführlicher beschrieben. <br></li></ul><br>  Die Klasse osg :: Referenced ist die Basisklasse für alle Elemente des Szenendiagramms, z. B. Knoten, Geometrie, Rendering-Zustände und andere Objekte, die auf der Bühne platziert sind.  Wenn wir also den Wurzelknoten der Szene erstellen, erben wir indirekt alle Funktionen, die von der Klasse osg :: Referenced bereitgestellt werden.  Daher gibt es in unserem Programm eine Ankündigung <br><br><pre><code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; root;</code> </pre> <br>  Die Klasse osg :: Referenced enthält einen Ganzzahlzähler für Verweise auf den zugewiesenen Speicherblock.  Dieser Zähler wird im Klassenkonstruktor auf Null initialisiert.  Sie wird um eins erhöht, wenn das Objekt osg :: ref_ptr &lt;&gt; erstellt wird.  Dieser Zähler nimmt ab, sobald ein Verweis auf das durch diesen Zeiger beschriebene Objekt gelöscht wird.  Ein Objekt wird automatisch zerstört, wenn keine intelligenten Zeiger mehr darauf verweisen. <br><br>  Die Klasse osg :: Referenced verfügt über drei öffentliche Methoden: <br><br><ul><li>  ref () ist eine öffentliche Methode, die um 1 Referenzanzahl erhöht wird. <br></li><li>  unref () ist eine öffentliche Methode, die um 1 Referenzanzahl verringert wird. <br></li><li>  referenceCount () ist eine öffentliche Methode, die den aktuellen Wert des Referenzzählers zurückgibt. Dies ist beim Debuggen von Code hilfreich. <br></li></ul><br>  Diese Methoden sind in allen Klassen verfügbar, die von osg :: Referenced abgeleitet sind.  Es sollte jedoch beachtet werden, dass die manuelle Steuerung des Verbindungszählers zu unvorhersehbaren Konsequenzen führen kann. Wenn Sie dies verwenden, sollten Sie klar verstehen, was Sie tun. <br><br><h1>  4. Wie OSG Müll sammelt und warum er benötigt wird </h1><br>  Es gibt mehrere Gründe, warum intelligente Zeiger und Speicherbereinigung verwendet werden sollten: <br><br><ul><li>  Minimierung kritischer Fehler: Durch die Verwendung intelligenter Zeiger können Sie die Zuweisung und Freigabe von Speicher automatisieren.  Es gibt keine gefährlichen Rohzeiger. <br></li><li>  Effektive Speicherverwaltung: Der für das Objekt zugewiesene Speicher wird sofort freigegeben, sobald das Objekt nicht mehr benötigt wird, was zu einer wirtschaftlichen Nutzung der Systemressourcen führt. <br></li><li>  Erleichterung des Debuggens von Anwendungen: Da wir die Anzahl der Verknüpfungen zu einem Objekt klar verfolgen können, haben wir die Möglichkeit, verschiedene Arten von Optimierungen und Experimenten durchzuführen. <br></li></ul><br>  Angenommen, ein Szenendiagramm besteht aus einem Wurzelknoten und mehreren Ebenen von untergeordneten Knoten.  Wenn der Stammknoten und alle untergeordneten Knoten mit der Klasse osg :: ref_ptr &lt;&gt; verwaltet werden, kann die Anwendung nur den Zeiger auf den Stammknoten verfolgen.  Das Entfernen dieses Knotens führt zu einem sequentiellen, automatischen Entfernen aller untergeordneten Knoten. <br><br><img src="https://habrastorage.org/webt/5r/az/ri/5razrigi8nvg-75jwcm4vhhurda.png"><br><br>  Intelligente Zeiger können als lokale Variablen, globale Variablen und Klassenmitglieder verwendet werden und verringern automatisch die Referenzanzahl, wenn der intelligente Zeiger den Gültigkeitsbereich verlässt. <br><br>  Intelligente Zeiger werden von OSG-Entwicklern für die Verwendung in Projekten dringend empfohlen. Es gibt jedoch einige wichtige Punkte, die Sie beachten sollten: <br><br><ul><li>  Instanzen von osg :: Referenced und seinen Derivaten können ausschließlich auf dem Heap erstellt werden.  Sie können nicht als lokale Variablen auf dem Stapel erstellt werden, da die Destruktoren dieser Klassen als geschützt deklariert sind.  Zum Beispiel <br></li></ul><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; node = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Node; <span class="hljs-comment"><span class="hljs-comment">//  osg::Node node; // </span></span></code> </pre><br><ul><li>  Sie können temporäre Szenenknoten mit regulären C ++ - Zeigern erstellen. Dieser Ansatz ist jedoch nicht sicher.  Es ist besser, intelligente Zeiger zu verwenden, um sicherzustellen, dass das Szenendiagramm korrekt verwaltet wird. <br></li></ul><br><pre> <code class="cpp hljs">osg::Node *tmpNode = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Node; <span class="hljs-comment"><span class="hljs-comment">//  ,  ... osg::ref_ptr&lt;osg::Node&gt; node = tmpNode; //         !</span></span></code> </pre><br><ul><li>  In keinem Fall sollten Sie zyklische Verknüpfungsszenen im Baum verwenden, wenn der Knoten über mehrere Ebenen direkt oder indirekt auf sich selbst verweist <br></li></ul><br><img src="https://habrastorage.org/webt/ds/af/er/dsafertsy4m2doboaeb9cgjdzyk.png"><br><br>  In dem Beispieldiagramm des Szenendiagramms bezieht sich der untergeordnete 1.1-Knoten auf sich selbst, und der untergeordnete 2.2-Knoten bezieht sich auch auf den untergeordneten 1.2-Knoten.  Solche Links können zu einer falschen Berechnung der Anzahl der Links und zu einem unbestimmten Verhalten des Programms führen. <br><br><h1>  5. Verfolgte verwaltete Objekte </h1><br>  Um die Funktionsweise des Smart-Pointer-Mechanismus in OSG zu veranschaulichen, schreiben wir das folgende synthetische Beispiel <br><br>  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/ref_ptr&gt; #include &lt;osg/Referenced&gt; #include &lt;iostream&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> class MonitoringTarget : public osg::Referenced { public: MonitoringTarget(int id) : _id(id) { std::cout </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; "Constructing target " &lt;&lt; _id &lt;&lt; std::endl; } protected: virtual ~MonitoringTarget() { std::cout &lt;&lt; "Dsetroying target " &lt;&lt; _id &lt;&lt; std::endl; } int _id; }; int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;MonitoringTarget&gt; target = new MonitoringTarget(0); std::cout &lt;&lt; "Referenced count before referring: " &lt;&lt; target-&gt;referenceCount() &lt;&lt; std::endl; osg::ref_ptr&lt;MonitoringTarget&gt; anotherTarget = target; std::cout &lt;&lt; "Referenced count after referring: " &lt;&lt; target-&gt;referenceCount() &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre><br>  Wir erstellen eine osg :: Referenced-Nachkommenklasse, die nichts anderes tut als im Konstruktor und Destruktor, der meldet, dass ihre Instanz erstellt wurde, und den Bezeichner anzeigt, der beim Erstellen der Instanz ermittelt wird.  Erstellen Sie eine Instanz der Klasse mit dem Smart-Pointer-Mechanismus <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;MonitoringTarget&gt; target = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MonitoringTarget(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Als nächstes zeigen wir den Referenzzähler für das Zielobjekt an <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Referenced count before referring: "</span></span> &lt;&lt; target-&gt;referenceCount() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Erstellen Sie anschließend einen neuen intelligenten Zeiger und weisen Sie ihm den Wert des vorherigen Zeigers zu <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;MonitoringTarget&gt; anotherTarget = target;</code> </pre><br>  und erneut den Referenzzähler anzeigen <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Referenced count after referring: "</span></span> &lt;&lt; target-&gt;referenceCount() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Mal sehen, was wir durch die Analyse der Ausgabe des Programms erhalten haben <br><br><pre> <code class="plaintext hljs">15:42:39:   Constructing target 0 Referenced count before referring: 1 Referenced count after referring: 2 Dsetroying target 0 15:42:42:  </code> </pre><br>  Wenn der Klassenkonstruktor gestartet wird, wird eine entsprechende Meldung angezeigt, die uns mitteilt, dass der Speicher für das Objekt zugewiesen ist und der Konstruktor ordnungsgemäß funktioniert hat.  Nach dem Erstellen eines intelligenten Zeigers sehen wir außerdem, dass der Referenzzähler für das erstellte Objekt um eins erhöht wurde.  Wenn Sie einen neuen Zeiger erstellen und ihm den Wert des alten Zeigers zuweisen, wird im Wesentlichen eine neue Verknüpfung zu demselben Objekt erstellt, sodass der Referenzzähler um einen anderen erhöht wird.  Beim Beenden des Programms wird der Destruktor der MonitoringTarget-Klasse aufgerufen. <br><br><img src="https://habrastorage.org/webt/oi/hv/gh/oihvghcjfhchgrjkd0wpxm_hmr4.png"><br><br>  Lassen Sie uns ein weiteres Experiment durchführen, indem wir solchen Code am Ende der main () - Funktion hinzufügen <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { osg::ref_ptr&lt;MonitoringTarget&gt; subTarget = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MonitoringTarget(i); }</code> </pre><br>  was zu einem solchen "Auspuff" -Programm führt <br><br><pre> <code class="plaintext hljs">16:04:30:   Constructing target 0 Referenced count before referring: 1 Referenced count after referring: 2 Constructing target 1 Dsetroying target 1 Constructing target 2 Dsetroying target 2 Constructing target 3 Dsetroying target 3 Constructing target 4 Dsetroying target 4 Dsetroying target 0 16:04:32:  </code> </pre><br>  Wir erstellen mehrere Objekte im Hauptteil der Schleife mit einem intelligenten Zeiger.  Da sich der Bereich des Zeigers in diesem Fall nur auf den Körper der Schleife erstreckt, wird der Destruktor beim Beenden automatisch aufgerufen.  Dies würde ganz offensichtlich nicht passieren, wir würden die üblichen Zeiger verwenden. <br><br>  Die automatische Speicherfreigabe ist ein weiteres wichtiges Merkmal der Arbeit mit intelligenten Zeigern.  Da der Destruktor der abgeleiteten Klasse osg :: Referenced geschützt ist, können wir den Löschoperator nicht explizit aufrufen, um das Objekt zu löschen.  Die einzige Möglichkeit, ein Objekt zu löschen, besteht darin, die Anzahl der Links zu diesem Objekt zurückzusetzen.  Aber dann wird unser Code während der Multithread-Datenverarbeitung unsicher - wir können von einem anderen Thread auf ein bereits gelöschtes Objekt zugreifen. <br><br>  Glücklicherweise bietet OSG mithilfe des Objektentfernungsplans eine Lösung für dieses Problem.  Dieser Scheduler basiert auf der Verwendung der Klasse osg :: DeleteHandler.  Es funktioniert so, dass ein Objekt nicht sofort gelöscht wird, sondern nach einer Weile.  Alle zu löschenden Objekte werden vorübergehend gespeichert, bis der Moment zum sicheren Löschen gekommen ist, und dann werden sie alle auf einmal gelöscht.  Der osg :: DeleteHandler-Entfernungsplaner wird vom OSG-Render-Backend gesteuert. <br><br><h1>  6. Rückkehr von der Funktion </h1><br>  Fügen Sie unserem Beispielcode die folgende Funktion hinzu <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MonitoringTarget *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createMonitoringTarget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;MonitoringTarget&gt; target = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MonitoringTarget(id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target.release(); }</code> </pre><br>  und ersetzen Sie den Aufruf des neuen Operators in der Schleife durch den Aufruf dieser Funktion <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { osg::ref_ptr&lt;MonitoringTarget&gt; subTarget = createMonitoringTarget(i); }</code> </pre><br>  Der Aufruf von release () reduziert die Anzahl der Verweise auf das Objekt auf Null. Anstatt den Speicher zu löschen, wird der tatsächliche Zeiger direkt auf den zugewiesenen Speicher zurückgegeben.  Wenn dieser Zeiger einem anderen intelligenten Zeiger zugewiesen wird, treten keine Speicherlecks auf. <br><br><h1>  Schlussfolgerungen </h1><br>  Die Konzepte des Szenendiagramms und der intelligenten Zeiger sind grundlegend für das Verständnis des Funktionsprinzips und damit für die effektive Verwendung von OpenSceneGraph.  Denken Sie bei OSG-Smart-Zeigern daran, dass deren Verwendung unbedingt erforderlich ist, wenn <br><br><ul><li>  Eine langfristige Lagerung der Anlage wird erwartet. </li><li>  Ein Objekt speichert eine Verknüpfung zu einem anderen Objekt </li><li>  Sie müssen einen Zeiger von einer Funktion zurückgeben </li></ul><br>  Der im Artikel bereitgestellte Beispielcode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist hier verfügbar</a> . <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429914/">https://habr.com/ru/post/de429914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429902/index.html">Seitenrang im Web 2.0-Zeitalter - Teil 1</a></li>
<li><a href="../de429904/index.html">Lustige und traurige Geschichten über die Entwicklung von Computerspielen</a></li>
<li><a href="../de429908/index.html">Wie man Coroutinen in Lebensmitteln verwendet und nachts ruhig schläft</a></li>
<li><a href="../de429910/index.html">AppsConf steigt</a></li>
<li><a href="../de429912/index.html">Bibliotheksentwicklung: von der API bis zur Veröffentlichung</a></li>
<li><a href="../de429916/index.html">Wie man baut und baut</a></li>
<li><a href="../de429918/index.html">Virtuelle Welt Intel. Teil 2: SMP</a></li>
<li><a href="../de429920/index.html">Tragikomödie in NaN-Acts: Wie wir ein Spiel auf JS gemacht und auf Steam veröffentlicht haben</a></li>
<li><a href="../de429922/index.html">Wie man aus einem einfachen Projekt eine langfristige Konstruktion macht oder alles Unnötige abschneidet</a></li>
<li><a href="../de429928/index.html">Alles, was Sie über Stress und starke Emotionen wissen müssen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>