<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëã üë©üèΩ‚Äçü§ù‚Äçüë©üèº üë©üèΩ‚Äçü§ù‚Äçüë©üèª OpenSceneGraph: Szenendiagramm und intelligente Zeiger üåü üë®üèΩ‚Äçüç≥ ü•™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 In einem fr√ºheren Artikel haben wir uns die OpenSceneGraph-Assembly aus dem Quellcode angesehen und ein elementares Beispiel geschrieben,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Szenendiagramm und intelligente Zeiger</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429914/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="Bild"><br><br><h1>  Einf√ºhrung </h1><br>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikel haben</a> wir uns die OpenSceneGraph-Assembly aus dem Quellcode angesehen und ein elementares Beispiel geschrieben, in dem eine graue Ebene in einer leeren lila Welt h√§ngt.  Ich stimme zu, nicht zu beeindruckend.  Wie ich bereits sagte, gibt es in diesem kleinen Beispiel die Hauptkonzepte, auf denen diese Grafik-Engine basiert.  Betrachten wir sie genauer.  Das folgende Material verwendet Illustrationen aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexander Bobkovs Blog √ºber OSG</a> (schade, dass der Autor das Schreiben √ºber OSG aufgegeben hat ...).  Der Artikel basiert auch auf Material und Beispielen aus dem Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenSceneGraph 3.0.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anf√§ngerleitfaden</a> <br><br>  Ich muss sagen, dass die vorherige Ver√∂ffentlichung einer Kritik ausgesetzt war, der ich teilweise zustimme - das Material kam unausgesprochen heraus und wurde aus dem Zusammenhang gerissen.  Ich werde versuchen, dieses Vers√§umnis unter dem Schnitt zu beheben. <br><a name="habracut"></a><br><h1>  1. Kurz √ºber das Diagramm der Szene und ihrer Knoten </h1><br>  Das zentrale Konzept der Engine ist das sogenannte <i>Szenendiagramm</i> (es ist kein Zufall, dass es im Namen des Frameworks h√§ngen geblieben ist) - eine hierarchische Baumstruktur, mit der Sie eine logische und r√§umliche Darstellung einer dreidimensionalen Szene organisieren k√∂nnen.  Das Szenendiagramm enth√§lt den Wurzelknoten und die zugeh√∂rigen Zwischen- und Endknoten oder <i>-knoten</i> . <br><br>  Zum Beispiel <br><br><img src="https://habrastorage.org/webt/va/m7/l4/vam7l4ap2qwqgyev2ofzlcbt-vo.png"><br><br>  Diese Grafik zeigt eine Szene, die aus einem Haus und einem Tisch besteht.  Das Haus hat eine bestimmte geometrische Darstellung und befindet sich auf eine bestimmte Weise im Raum relativ zu einem bestimmten grundlegenden Koordinatensystem, das dem Wurzelknoten (Wurzel) zugeordnet ist.  Die Tabelle wird auch durch eine Geometrie beschrieben, die sich in irgendeiner Weise relativ zum Haus und zusammen mit dem Haus befindet - relativ zum Wurzelknoten.  Alle Knoten, die eine gemeinsame Eigenschaft haben, weil sie von einer osg :: Node-Klasse erben, werden entsprechend ihrem funktionalen Zweck in Typen unterteilt <br><br><ol><li>  Gruppenknoten (osg :: Group) - sind die Basisklasse f√ºr alle Zwischenknoten und dienen zum Kombinieren anderer Knoten zu Gruppen </li><li>  Transformationsknoten (osg :: Transform und seine Nachkommen) - zur Beschreibung der Transformation von Objektkoordinaten </li><li>  Geometrische Knoten (osg :: Geode) - Endknoten (Blattknoten) des Szenendiagramms, die Informationen zu einem oder mehreren geometrischen Objekten enthalten. </li></ol><br>  Die Geometrie von Szenenobjekten in OSG wird in einem eigenen lokalen Koordinatensystem des Objekts beschrieben.  Transformationsknoten, die sich zwischen diesem Objekt und dem Wurzelknoten befinden, implementieren Matrixkoordinatentransformationen, um die Position des Objekts im Basiskoordinatensystem zu erhalten. <br><br>  Die Knoten f√ºhren viele wichtige Funktionen aus, insbesondere speichern sie den Status der Anzeige von Objekten, und dieser Status wirkt sich nur auf den diesem Knoten zugeordneten Untergraphen aus.  Knoten im Szenendiagramm k√∂nnen mehrere R√ºckrufe zugeordnet werden, Ereignishandler, mit denen Sie den Status des Knotens und den damit verbundenen Untergraphen √§ndern k√∂nnen. <br><br>  Alle globalen Operationen im Szenendiagramm, die mit dem Erhalten des Endergebnisses auf dem Bildschirm verbunden sind, werden automatisch von der Engine ausgef√ºhrt, indem das Diagramm regelm√§√üig in der Tiefe durchlaufen wird. <br><br>  In dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuletzt</a> untersuchten Beispiel bestand unsere Szene aus einem einzelnen Objekt - einem Flugzeugmodell, das aus einer Datei geladen wurde.  Mit Blick auf die Zukunft werde ich sagen, dass dieses Modell der Blattknoten des Szenendiagramms ist.  Es ist fest mit dem globalen Basiskoordinatensystem des Motors verschwei√üt. <br><br><h1>  2. OSG-Speicherverwaltung </h1><br>  Da die Knoten des Szenendiagramms viele Daten √ºber Szenenobjekte und Operationen auf diesen speichern, ist es erforderlich, Speicher zuzuweisen, auch dynamisch, um diese Daten zu speichern.  In diesem Fall m√ºssen Sie beim Bearbeiten des Szenendiagramms und beispielsweise beim L√∂schen einiger seiner Knoten sorgf√§ltig √ºberwachen, dass die gel√∂schten Knoten des Diagramms nicht mehr verarbeitet werden.  Dieser Prozess ist immer mit Fehlern und zeitaufw√§ndigem Debuggen verbunden, da es f√ºr den Entwickler ziemlich schwierig ist zu verfolgen, welche Zeiger auf Objekte auf vorhandene Daten verweisen und welche gel√∂scht werden sollten.  Ohne effektive Speicherverwaltung treten eher Segmentierungsfehler und Speicherlecks auf. <br><br>  Die Speicherverwaltung ist eine wichtige Aufgabe in OSG und ihr Konzept basiert auf zwei Punkten: <br><br><ol><li>  Zuweisung von Speicher: Sicherstellen der Zuweisung der zum Speichern eines Objekts erforderlichen Speichermenge. <br></li><li>  Speicher freigeben: Gibt den zugewiesenen Speicher an das System zur√ºck, wenn er nicht ben√∂tigt wird. <br></li></ol><br>  Viele moderne Programmiersprachen wie C #, Java, Visual Basic .Net und dergleichen verwenden den sogenannten Garbage Collector, um den zugewiesenen Speicher freizugeben.  Das Konzept der C ++ - Sprache sieht einen solchen Ansatz nicht vor, wir k√∂nnen ihn jedoch mithilfe der sogenannten Smart Pointer nachahmen. <br><br>  Heute hat C ++ intelligente Zeiger in seinem Arsenal, das als "out of the box" bezeichnet wird (und der C ++ 17-Standard hat es bereits geschafft, die Sprache von einigen veralteten Arten intelligenter Zeiger zu befreien), aber dies war nicht immer der Fall.  Die fr√ºheste der offiziellen OSG-Versionen mit der Nummer 0.9 wurde 2002 geboren, und es gab noch drei Jahre vor der ersten offiziellen Ver√∂ffentlichung.  Zu dieser Zeit sah der C ++ - Standard noch keine intelligenten Zeiger vor, und selbst wenn Sie an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen historischen Exkurs</a> glauben, erlebte die Sprache selbst schwere Zeiten.  Das Erscheinungsbild eines Fahrrads in Form eigener Smart Pointer, die in OSG implementiert sind, ist daher keineswegs √ºberraschend.  Dieser Mechanismus ist tief in die Struktur des Motors integriert, daher ist es von Anfang an unbedingt erforderlich, dessen Funktionsweise zu verstehen. <br><br><h1>  3. Die Klassen osg :: ref_ptr &lt;&gt; und osg :: Referenced </h1><br>  OSG bietet einen eigenen intelligenten Zeigermechanismus, der auf der Vorlagenklasse osg :: ref_ptr &lt;&gt; basiert, um die automatische Speicherbereinigung zu implementieren.  F√ºr den ordnungsgem√§√üen Betrieb stellt OSG eine weitere osg :: Referenced-Klasse zum Verwalten von Speicherbl√∂cken bereit, f√ºr die der Verweis auf diese gez√§hlt wird. <br><br>  Die Klasse osg :: ref_ptr &lt;&gt; bietet mehrere Operatoren und Methoden. <br><br><ul><li>  get () ist eine √∂ffentliche Methode, die einen Rohzeiger zur√ºckgibt. Wenn Sie beispielsweise die Vorlage osg :: Node als Argument verwenden, gibt diese Methode osg :: Node * zur√ºck. <br></li><li>  operator * () ist tats√§chlich der Dereferenzierungsoperator. <br></li><li>  Mit operator -&gt; () und operator = () k√∂nnen Sie osg :: ref_ptr &lt;&gt; als klassischen Zeiger verwenden, wenn Sie auf die Methoden und Eigenschaften der durch diesen Zeiger beschriebenen Objekte zugreifen. <br></li><li>  operator == (), operator! = () und operator! () - erm√∂glichen das Ausf√ºhren von Vergleichsoperationen f√ºr intelligente Zeiger. <br></li><li>  valid () ist eine √∂ffentliche Methode, die true zur√ºckgibt, wenn der verwaltete Zeiger den richtigen Wert hat (nicht NULL).  Der Ausdruck some_ptr.valid () entspricht dem Ausdruck some_ptr! = NULL, wenn some_ptr ein intelligenter Zeiger ist. <br></li><li>  release () ist eine √∂ffentliche Methode, die n√ºtzlich ist, wenn Sie eine verwaltete Adresse von einer Funktion zur√ºckgeben m√∂chten.  Dar√ºber wird sp√§ter ausf√ºhrlicher beschrieben. <br></li></ul><br>  Die Klasse osg :: Referenced ist die Basisklasse f√ºr alle Elemente des Szenendiagramms, z. B. Knoten, Geometrie, Rendering-Zust√§nde und andere Objekte, die auf der B√ºhne platziert sind.  Wenn wir also den Wurzelknoten der Szene erstellen, erben wir indirekt alle Funktionen, die von der Klasse osg :: Referenced bereitgestellt werden.  Daher gibt es in unserem Programm eine Ank√ºndigung <br><br><pre><code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; root;</code> </pre> <br>  Die Klasse osg :: Referenced enth√§lt einen Ganzzahlz√§hler f√ºr Verweise auf den zugewiesenen Speicherblock.  Dieser Z√§hler wird im Klassenkonstruktor auf Null initialisiert.  Sie wird um eins erh√∂ht, wenn das Objekt osg :: ref_ptr &lt;&gt; erstellt wird.  Dieser Z√§hler nimmt ab, sobald ein Verweis auf das durch diesen Zeiger beschriebene Objekt gel√∂scht wird.  Ein Objekt wird automatisch zerst√∂rt, wenn keine intelligenten Zeiger mehr darauf verweisen. <br><br>  Die Klasse osg :: Referenced verf√ºgt √ºber drei √∂ffentliche Methoden: <br><br><ul><li>  ref () ist eine √∂ffentliche Methode, die um 1 Referenzanzahl erh√∂ht wird. <br></li><li>  unref () ist eine √∂ffentliche Methode, die um 1 Referenzanzahl verringert wird. <br></li><li>  referenceCount () ist eine √∂ffentliche Methode, die den aktuellen Wert des Referenzz√§hlers zur√ºckgibt. Dies ist beim Debuggen von Code hilfreich. <br></li></ul><br>  Diese Methoden sind in allen Klassen verf√ºgbar, die von osg :: Referenced abgeleitet sind.  Es sollte jedoch beachtet werden, dass die manuelle Steuerung des Verbindungsz√§hlers zu unvorhersehbaren Konsequenzen f√ºhren kann. Wenn Sie dies verwenden, sollten Sie klar verstehen, was Sie tun. <br><br><h1>  4. Wie OSG M√ºll sammelt und warum er ben√∂tigt wird </h1><br>  Es gibt mehrere Gr√ºnde, warum intelligente Zeiger und Speicherbereinigung verwendet werden sollten: <br><br><ul><li>  Minimierung kritischer Fehler: Durch die Verwendung intelligenter Zeiger k√∂nnen Sie die Zuweisung und Freigabe von Speicher automatisieren.  Es gibt keine gef√§hrlichen Rohzeiger. <br></li><li>  Effektive Speicherverwaltung: Der f√ºr das Objekt zugewiesene Speicher wird sofort freigegeben, sobald das Objekt nicht mehr ben√∂tigt wird, was zu einer wirtschaftlichen Nutzung der Systemressourcen f√ºhrt. <br></li><li>  Erleichterung des Debuggens von Anwendungen: Da wir die Anzahl der Verkn√ºpfungen zu einem Objekt klar verfolgen k√∂nnen, haben wir die M√∂glichkeit, verschiedene Arten von Optimierungen und Experimenten durchzuf√ºhren. <br></li></ul><br>  Angenommen, ein Szenendiagramm besteht aus einem Wurzelknoten und mehreren Ebenen von untergeordneten Knoten.  Wenn der Stammknoten und alle untergeordneten Knoten mit der Klasse osg :: ref_ptr &lt;&gt; verwaltet werden, kann die Anwendung nur den Zeiger auf den Stammknoten verfolgen.  Das Entfernen dieses Knotens f√ºhrt zu einem sequentiellen, automatischen Entfernen aller untergeordneten Knoten. <br><br><img src="https://habrastorage.org/webt/5r/az/ri/5razrigi8nvg-75jwcm4vhhurda.png"><br><br>  Intelligente Zeiger k√∂nnen als lokale Variablen, globale Variablen und Klassenmitglieder verwendet werden und verringern automatisch die Referenzanzahl, wenn der intelligente Zeiger den G√ºltigkeitsbereich verl√§sst. <br><br>  Intelligente Zeiger werden von OSG-Entwicklern f√ºr die Verwendung in Projekten dringend empfohlen. Es gibt jedoch einige wichtige Punkte, die Sie beachten sollten: <br><br><ul><li>  Instanzen von osg :: Referenced und seinen Derivaten k√∂nnen ausschlie√ülich auf dem Heap erstellt werden.  Sie k√∂nnen nicht als lokale Variablen auf dem Stapel erstellt werden, da die Destruktoren dieser Klassen als gesch√ºtzt deklariert sind.  Zum Beispiel <br></li></ul><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; node = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Node; <span class="hljs-comment"><span class="hljs-comment">//  osg::Node node; // </span></span></code> </pre><br><ul><li>  Sie k√∂nnen tempor√§re Szenenknoten mit regul√§ren C ++ - Zeigern erstellen. Dieser Ansatz ist jedoch nicht sicher.  Es ist besser, intelligente Zeiger zu verwenden, um sicherzustellen, dass das Szenendiagramm korrekt verwaltet wird. <br></li></ul><br><pre> <code class="cpp hljs">osg::Node *tmpNode = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Node; <span class="hljs-comment"><span class="hljs-comment">//  ,  ... osg::ref_ptr&lt;osg::Node&gt; node = tmpNode; //         !</span></span></code> </pre><br><ul><li>  In keinem Fall sollten Sie zyklische Verkn√ºpfungsszenen im Baum verwenden, wenn der Knoten √ºber mehrere Ebenen direkt oder indirekt auf sich selbst verweist <br></li></ul><br><img src="https://habrastorage.org/webt/ds/af/er/dsafertsy4m2doboaeb9cgjdzyk.png"><br><br>  In dem Beispieldiagramm des Szenendiagramms bezieht sich der untergeordnete 1.1-Knoten auf sich selbst, und der untergeordnete 2.2-Knoten bezieht sich auch auf den untergeordneten 1.2-Knoten.  Solche Links k√∂nnen zu einer falschen Berechnung der Anzahl der Links und zu einem unbestimmten Verhalten des Programms f√ºhren. <br><br><h1>  5. Verfolgte verwaltete Objekte </h1><br>  Um die Funktionsweise des Smart-Pointer-Mechanismus in OSG zu veranschaulichen, schreiben wir das folgende synthetische Beispiel <br><br>  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/ref_ptr&gt; #include &lt;osg/Referenced&gt; #include &lt;iostream&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> class MonitoringTarget : public osg::Referenced { public: MonitoringTarget(int id) : _id(id) { std::cout </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; "Constructing target " &lt;&lt; _id &lt;&lt; std::endl; } protected: virtual ~MonitoringTarget() { std::cout &lt;&lt; "Dsetroying target " &lt;&lt; _id &lt;&lt; std::endl; } int _id; }; int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;MonitoringTarget&gt; target = new MonitoringTarget(0); std::cout &lt;&lt; "Referenced count before referring: " &lt;&lt; target-&gt;referenceCount() &lt;&lt; std::endl; osg::ref_ptr&lt;MonitoringTarget&gt; anotherTarget = target; std::cout &lt;&lt; "Referenced count after referring: " &lt;&lt; target-&gt;referenceCount() &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre><br>  Wir erstellen eine osg :: Referenced-Nachkommenklasse, die nichts anderes tut als im Konstruktor und Destruktor, der meldet, dass ihre Instanz erstellt wurde, und den Bezeichner anzeigt, der beim Erstellen der Instanz ermittelt wird.  Erstellen Sie eine Instanz der Klasse mit dem Smart-Pointer-Mechanismus <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;MonitoringTarget&gt; target = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MonitoringTarget(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Als n√§chstes zeigen wir den Referenzz√§hler f√ºr das Zielobjekt an <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Referenced count before referring: "</span></span> &lt;&lt; target-&gt;referenceCount() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Erstellen Sie anschlie√üend einen neuen intelligenten Zeiger und weisen Sie ihm den Wert des vorherigen Zeigers zu <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;MonitoringTarget&gt; anotherTarget = target;</code> </pre><br>  und erneut den Referenzz√§hler anzeigen <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Referenced count after referring: "</span></span> &lt;&lt; target-&gt;referenceCount() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Mal sehen, was wir durch die Analyse der Ausgabe des Programms erhalten haben <br><br><pre> <code class="plaintext hljs">15:42:39:   Constructing target 0 Referenced count before referring: 1 Referenced count after referring: 2 Dsetroying target 0 15:42:42:  </code> </pre><br>  Wenn der Klassenkonstruktor gestartet wird, wird eine entsprechende Meldung angezeigt, die uns mitteilt, dass der Speicher f√ºr das Objekt zugewiesen ist und der Konstruktor ordnungsgem√§√ü funktioniert hat.  Nach dem Erstellen eines intelligenten Zeigers sehen wir au√üerdem, dass der Referenzz√§hler f√ºr das erstellte Objekt um eins erh√∂ht wurde.  Wenn Sie einen neuen Zeiger erstellen und ihm den Wert des alten Zeigers zuweisen, wird im Wesentlichen eine neue Verkn√ºpfung zu demselben Objekt erstellt, sodass der Referenzz√§hler um einen anderen erh√∂ht wird.  Beim Beenden des Programms wird der Destruktor der MonitoringTarget-Klasse aufgerufen. <br><br><img src="https://habrastorage.org/webt/oi/hv/gh/oihvghcjfhchgrjkd0wpxm_hmr4.png"><br><br>  Lassen Sie uns ein weiteres Experiment durchf√ºhren, indem wir solchen Code am Ende der main () - Funktion hinzuf√ºgen <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { osg::ref_ptr&lt;MonitoringTarget&gt; subTarget = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MonitoringTarget(i); }</code> </pre><br>  was zu einem solchen "Auspuff" -Programm f√ºhrt <br><br><pre> <code class="plaintext hljs">16:04:30:   Constructing target 0 Referenced count before referring: 1 Referenced count after referring: 2 Constructing target 1 Dsetroying target 1 Constructing target 2 Dsetroying target 2 Constructing target 3 Dsetroying target 3 Constructing target 4 Dsetroying target 4 Dsetroying target 0 16:04:32:  </code> </pre><br>  Wir erstellen mehrere Objekte im Hauptteil der Schleife mit einem intelligenten Zeiger.  Da sich der Bereich des Zeigers in diesem Fall nur auf den K√∂rper der Schleife erstreckt, wird der Destruktor beim Beenden automatisch aufgerufen.  Dies w√ºrde ganz offensichtlich nicht passieren, wir w√ºrden die √ºblichen Zeiger verwenden. <br><br>  Die automatische Speicherfreigabe ist ein weiteres wichtiges Merkmal der Arbeit mit intelligenten Zeigern.  Da der Destruktor der abgeleiteten Klasse osg :: Referenced gesch√ºtzt ist, k√∂nnen wir den L√∂schoperator nicht explizit aufrufen, um das Objekt zu l√∂schen.  Die einzige M√∂glichkeit, ein Objekt zu l√∂schen, besteht darin, die Anzahl der Links zu diesem Objekt zur√ºckzusetzen.  Aber dann wird unser Code w√§hrend der Multithread-Datenverarbeitung unsicher - wir k√∂nnen von einem anderen Thread auf ein bereits gel√∂schtes Objekt zugreifen. <br><br>  Gl√ºcklicherweise bietet OSG mithilfe des Objektentfernungsplans eine L√∂sung f√ºr dieses Problem.  Dieser Scheduler basiert auf der Verwendung der Klasse osg :: DeleteHandler.  Es funktioniert so, dass ein Objekt nicht sofort gel√∂scht wird, sondern nach einer Weile.  Alle zu l√∂schenden Objekte werden vor√ºbergehend gespeichert, bis der Moment zum sicheren L√∂schen gekommen ist, und dann werden sie alle auf einmal gel√∂scht.  Der osg :: DeleteHandler-Entfernungsplaner wird vom OSG-Render-Backend gesteuert. <br><br><h1>  6. R√ºckkehr von der Funktion </h1><br>  F√ºgen Sie unserem Beispielcode die folgende Funktion hinzu <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MonitoringTarget *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createMonitoringTarget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;MonitoringTarget&gt; target = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MonitoringTarget(id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target.release(); }</code> </pre><br>  und ersetzen Sie den Aufruf des neuen Operators in der Schleife durch den Aufruf dieser Funktion <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { osg::ref_ptr&lt;MonitoringTarget&gt; subTarget = createMonitoringTarget(i); }</code> </pre><br>  Der Aufruf von release () reduziert die Anzahl der Verweise auf das Objekt auf Null. Anstatt den Speicher zu l√∂schen, wird der tats√§chliche Zeiger direkt auf den zugewiesenen Speicher zur√ºckgegeben.  Wenn dieser Zeiger einem anderen intelligenten Zeiger zugewiesen wird, treten keine Speicherlecks auf. <br><br><h1>  Schlussfolgerungen </h1><br>  Die Konzepte des Szenendiagramms und der intelligenten Zeiger sind grundlegend f√ºr das Verst√§ndnis des Funktionsprinzips und damit f√ºr die effektive Verwendung von OpenSceneGraph.  Denken Sie bei OSG-Smart-Zeigern daran, dass deren Verwendung unbedingt erforderlich ist, wenn <br><br><ul><li>  Eine langfristige Lagerung der Anlage wird erwartet. </li><li>  Ein Objekt speichert eine Verkn√ºpfung zu einem anderen Objekt </li><li>  Sie m√ºssen einen Zeiger von einer Funktion zur√ºckgeben </li></ul><br>  Der im Artikel bereitgestellte Beispielcode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist hier verf√ºgbar</a> . <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429914/">https://habr.com/ru/post/de429914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429902/index.html">Seitenrang im Web 2.0-Zeitalter - Teil 1</a></li>
<li><a href="../de429904/index.html">Lustige und traurige Geschichten √ºber die Entwicklung von Computerspielen</a></li>
<li><a href="../de429908/index.html">Wie man Coroutinen in Lebensmitteln verwendet und nachts ruhig schl√§ft</a></li>
<li><a href="../de429910/index.html">AppsConf steigt</a></li>
<li><a href="../de429912/index.html">Bibliotheksentwicklung: von der API bis zur Ver√∂ffentlichung</a></li>
<li><a href="../de429916/index.html">Wie man baut und baut</a></li>
<li><a href="../de429918/index.html">Virtuelle Welt Intel. Teil 2: SMP</a></li>
<li><a href="../de429920/index.html">Tragikom√∂die in NaN-Acts: Wie wir ein Spiel auf JS gemacht und auf Steam ver√∂ffentlicht haben</a></li>
<li><a href="../de429922/index.html">Wie man aus einem einfachen Projekt eine langfristige Konstruktion macht oder alles Unn√∂tige abschneidet</a></li>
<li><a href="../de429928/index.html">Alles, was Sie √ºber Stress und starke Emotionen wissen m√ºssen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>