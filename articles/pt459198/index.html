<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâüèø üßó üë©‚Äçüë©‚Äçüëß‚Äçüë¶ An√°lise de desempenho de consulta no ClickHouse. Relat√≥rio Yandex üëÇ üëâüèª üßëüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="E se sua consulta ao banco de dados n√£o estiver sendo executada com rapidez suficiente? Como voc√™ sabe se uma consulta usa os recursos de computa√ß√£o d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>An√°lise de desempenho de consulta no ClickHouse. Relat√≥rio Yandex</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/459198/">  E se sua consulta ao banco de dados n√£o estiver sendo executada com rapidez suficiente?  Como voc√™ sabe se uma consulta usa os recursos de computa√ß√£o de maneira ideal ou pode ser acelerada?  Na √∫ltima confer√™ncia HighLoad ++ em Moscou, falei sobre a introspec√ß√£o do desempenho de consultas - e o que o ClickHouse DBMS fornece e sobre os recursos do SO que todos deveriam conhecer. <br><br><img src="https://habrastorage.org/webt/mi/yo/wu/miyowuhgorpfpl9zih8cszids0y.jpeg"><br><br>  Toda vez que fa√ßo uma solicita√ß√£o, me preocupo n√£o apenas com o resultado, mas tamb√©m com o que essa solicita√ß√£o faz.  Por exemplo, funciona por um segundo.  √â muito ou pouco?  Eu sempre penso: por que n√£o meio segundo?  Ent√£o eu otimizo alguma coisa, acelero e funciona por 10 ms.  Eu geralmente estou satisfeito.  Mas ainda assim, neste caso, tento fazer uma express√£o facial descontente e pergunto: "Por que n√£o 5 ms?"  Como posso descobrir quanto tempo √© gasto no processamento da solicita√ß√£o?  Pode ser acelerado em princ√≠pio? <br><br><a name="habracut"></a>  Normalmente, a velocidade de processamento da solicita√ß√£o √© aritm√©tica simples.  N√≥s escrevemos o c√≥digo - provavelmente da melhor maneira - e temos algum dispositivo no sistema.  Os dispositivos t√™m especifica√ß√µes.  Por exemplo, a velocidade de leitura do cache L1.  Ou o n√∫mero de leituras aleat√≥rias que um SSD pode fazer.  Todos n√≥s sabemos disso.  Precisamos pegar essas caracter√≠sticas, adicionar, subtrair, multiplicar, dividir e verificar a resposta.  Mas este √© o caso ideal, isso quase nunca acontece.  Quase.  De fato, isso √†s vezes acontece no ClickHouse. <br><br>  Considere os fatos triviais sobre quais dispositivos e quais recursos existem em nossos servidores. <br><br><img src="https://habrastorage.org/webt/6e/gz/us/6egzusxqlzhg81ledkch36wrld4.jpeg" width="700"><br><br>  Processador, mem√≥ria, disco, rede.  Organizei esses recursos especialmente dessa maneira, come√ßando pelo mais simples e conveniente para revis√£o e otimiza√ß√£o e terminando no mais inconveniente e complexo.  Por exemplo, eu executo uma solicita√ß√£o e vejo que meu programa parece estar na CPU.  O que isso significa?  O que vou descobrir que existe algum tipo de loop interno, uma fun√ß√£o que √© executada com mais freq√º√™ncia, reescreve o c√≥digo, recompila e uma vez - meu programa roda mais r√°pido. <br><br>  Se voc√™ gasta muita RAM, tudo fica um pouco mais complicado.  Voc√™ precisa repensar a estrutura de dados, espremer alguns bits.  De qualquer forma, reinicio meu programa e ele gasta menos RAM.  √â verdade que isso costuma prejudicar o processador. <br><br>  Se tudo depende de discos, isso tamb√©m √© mais dif√≠cil, porque posso alterar a estrutura de dados no disco, mas preciso convert√™-los posteriormente.  Se eu fizer um novo lan√ßamento, as pessoas ter√£o que fazer algum tipo de migra√ß√£o de dados.  Acontece que o disco j√° √© muito mais complicado, e √© melhor pensar com anteced√™ncia. <br><br>  E a rede ... Eu realmente n√£o gosto da rede, porque muitas vezes n√£o est√° claro o que est√° acontecendo nela, especialmente se √© uma rede entre continentes, entre data centers.  Algo est√° diminuindo a velocidade e n√£o √© nem sua rede, nem seu servidor, e voc√™ n√£o pode fazer nada.  A √∫nica coisa que voc√™ pode pensar antecipadamente √© como os dados ser√£o transmitidos e como minimizar a intera√ß√£o na rede. <br><br>  Acontece que nem um √∫nico recurso do sistema √© utilizado, e o programa est√° apenas esperando por algo.  De fato, esse √© um caso muito frequente, porque nosso sistema √© distribu√≠do, e pode haver muitos processos e fluxos diferentes, e algu√©m est√° esperando pelo outro, e tudo isso precisa estar de alguma forma conectado entre si para que seja considerado adequadamente. <br><br><img src="https://habrastorage.org/webt/vq/mk/sa/vqmksaynboi4frop2kzfcvk9q4w.jpeg" width="700"><br><br>  O mais simples √© observar a utiliza√ß√£o de recursos, com algum valor num√©rico.  Por exemplo, voc√™ inicia alguns top e ele escreve: o processador √© 100%.  Ou execute o iostat e ele escreve: os discos s√£o 100%.  √â verdade que isso geralmente n√£o √© suficiente.  Uma pessoa ver√° que o programa se baseia em discos.  O que pode ser feito?  Voc√™ pode simplesmente notar isso e descansar, decidir que tudo, nada pode ser otimizado.  Mas, de fato, cada um dos dispositivos dentro de si √© bastante complicado.  O processador possui v√°rios dispositivos de computa√ß√£o para diferentes tipos de opera√ß√µes.  Os discos podem ter uma matriz RAID.  Se houver um SSD, haver√° dentro de seu pr√≥prio processador, seu pr√≥prio controlador, o que torna claro o que.  E um valor - 50% ou 100% - n√£o √© suficiente.  A regra b√°sica: se voc√™ perceber que algum recurso √© 100% utilizado, n√£o desista.  Muitas vezes, voc√™ ainda pode melhorar alguma coisa.  Mas isso acontece e vice-versa.  Digamos que voc√™ veja que a reciclagem √© de 50%, mas nada pode ser feito. <br><br>  Vamos dar uma olhada mais de perto nisso. <br><br><img src="https://habrastorage.org/webt/pa/wj/uo/pawjuoieudajqc097ysekq30wnc.jpeg" width="700"><br><br>  O recurso mais f√°cil e conveniente √© o processador.  Voc√™ olha para cima, diz que o processador √© 100%.  Mas deve-se ter em mente que este n√£o √© um processador 100%.  O programa superior n√£o sabe o que o processador faz l√°.  Ela olha da perspectiva do planejador do sistema operacional.  Ou seja, agora algum tipo de thread de programa est√° sendo executado no processador.  O processador faz alguma coisa e, em seguida, 100% ser√° mostrado se for calculada a m√©dia ao longo do tempo.  Ao mesmo tempo, o processador est√° fazendo algo, e n√£o est√° claro qu√£o eficaz √©.  Pode executar um n√∫mero diferente de instru√ß√µes por ciclo.  Se houver poucas instru√ß√µes, o pr√≥prio processador pode esperar por algo, por exemplo, carregando dados da mem√≥ria.  Ao mesmo tempo, a mesma coisa ser√° exibida no topo - 100%.  Estamos aguardando o processador seguir nossas instru√ß√µes.  E o que ele faz por dentro n√£o √© claro. <br><br>  Finalmente, h√° apenas um rake quando voc√™ pensa que seu programa repousa no processador.  Isso √© verdade, mas por algum motivo o processador tem uma frequ√™ncia mais baixa.  Pode haver muitas raz√µes: superaquecimento, limita√ß√£o de energia.  Por alguma raz√£o, no data center, h√° uma limita√ß√£o de energia ou a economia de energia pode simplesmente ser ativada.  Em seguida, o processador mudar√° constantemente de uma frequ√™ncia mais alta para uma mais baixa, mas se sua carga for inst√°vel, isso n√£o ser√° suficiente e, em m√©dia, o c√≥digo ser√° executado mais lentamente.  Veja o turbostato para a freq√º√™ncia atual do processador.  Verifique se h√° superaquecimento em dmesg.  Se algo assim acontecesse, diria: ‚ÄúSuperaquecimento.  Frequ√™ncia reduzida. ‚Äù <br><br>  Se voc√™ estiver interessado em quantas falhas de cache estavam dentro, quantas instru√ß√µes s√£o executadas por ciclo, use o registro perf.  Registre algumas amostras do programa.  Al√©m disso, ser√° poss√≠vel analis√°-lo usando perf stat ou perf report. <br><br><img src="https://habrastorage.org/webt/hl/4v/up/hl4vupofzsuha-s7cyxtba-po0c.jpeg" width="600"><br><br>  E vice-versa.  Digamos que voc√™ olhe para o topo e o processador seja menos de 50% reciclado.  Suponha que voc√™ tenha 32 n√∫cleos de processador virtual em seu sistema e 16 n√∫cleos f√≠sicos.Em processadores Intel, isso ocorre porque o hiperencadeamento √© duplo.  Mas isso n√£o significa que n√∫cleos adicionais sejam in√∫teis.  Tudo depende da carga.  Suponha que voc√™ tenha algumas opera√ß√µes de √°lgebra linear bem otimizadas ou tenha hashes para minerar bitcoins.  Ent√£o o c√≥digo ficar√° claro, muitas instru√ß√µes ser√£o executadas por ciclo, n√£o haver√° falhas no cache, previs√µes erradas de ramifica√ß√£o tamb√©m.  E o hyper-threading n√£o ajuda.  Ajuda quando voc√™ tem um n√∫cleo aguardando algo, enquanto o outro pode executar simultaneamente instru√ß√µes de outro encadeamento. <br><br>  ClickHouse tem ambas as situa√ß√µes.  Por exemplo, quando fizermos agrega√ß√£o de dados (GROUP BY) ou filtragem por conjunto (subconsulta IN), teremos uma tabela de hash.  Se a tabela de hash n√£o couber no cache do processador, ocorrer√£o falhas no cache.  Isso dificilmente pode ser evitado.  Nesse caso, o hiperencadeamento nos ajudar√°. <br><br>  Por padr√£o, o ClickHouse usa apenas n√∫cleos f√≠sicos do processador, excluindo o hyperthreading.  Se voc√™ souber que sua solicita√ß√£o pode se beneficiar da hiperencadeamento, basta dobrar o n√∫mero de threads: SET max threads = 32, e sua solicita√ß√£o ser√° mais r√°pida. <br><br>  Acontece que o processador est√° perfeitamente usado, mas voc√™ olha para o gr√°fico e v√™, por exemplo, 10%.  E sua agenda, por exemplo, √© de cinco minutos no pior caso.  Mesmo se for um segundo, ainda h√° algum tipo de valor m√©dio.  De fato, voc√™ sempre teve solicita√ß√µes, elas s√£o executadas rapidamente, em 100 ms a cada segundo, e isso √© normal.  Porque o ClickHouse tenta executar a solicita√ß√£o o mais r√°pido poss√≠vel.  Ele n√£o tenta usar e superaquecer completamente e constantemente seus processadores. <br><br><img src="https://habrastorage.org/webt/39/ka/ei/39kaeie-ngofbbynsnlq4mum_d0.jpeg" width="700"><br><br>  Vamos dar uma olhada, uma op√ß√£o um pouco complicada.  H√° uma consulta com uma express√£o na subconsulta.  Dentro da subconsulta, temos 100 milh√µes de n√∫meros aleat√≥rios.  E n√≥s apenas filtramos esse resultado. <br><br>  Vemos uma foto assim.  A prop√≥sito, quem dir√° com que ferramenta posso ver esta foto maravilhosa?  Absolutamente verdade - perf.  Estou muito feliz que voc√™ saiba disso. <br><br>  Abri o perf, pensando que agora entendo tudo.  Eu abro a listagem do assembler.  L√°, escrevi com que frequ√™ncia a execu√ß√£o do programa estava em uma instru√ß√£o espec√≠fica, ou seja, com que frequ√™ncia havia um ponteiro de instru√ß√£o.  Aqui, os n√∫meros est√£o em porcentagem, e est√° escrito que quase 90% das vezes a instru√ß√£o% edx,% edx foi executada, ou seja, verificando quatro bytes como zero. <br><br>  A quest√£o √©: por que um processador pode demorar tanto para simplesmente comparar quatro bytes com zero?  (respostas da plat√©ia ...) N√£o h√° resto da divis√£o.  H√° mudan√ßas de bits, h√° uma instru√ß√£o crc32q, mas como se o ponteiro da instru√ß√£o nunca acontecesse nela.  E a gera√ß√£o de n√∫meros aleat√≥rios n√£o est√° nesta listagem.  Havia uma fun√ß√£o separada e √© muito bem otimizada, n√£o diminui a velocidade.  Algo mais est√° desacelerando aqui.  A execu√ß√£o do c√≥digo para nesta instru√ß√£o e gasta muito tempo.  Loop ocioso?  N√£o.  Por que devo inserir loops vazios?  Al√©m disso, se eu inserisse o loop Idle, isso tamb√©m seria vis√≠vel em perf.  N√£o h√° divis√£o por zero, h√° simplesmente uma compara√ß√£o com zero. <br><br>  O processador possui um pipeline, ele pode executar v√°rias instru√ß√µes em paralelo.  E quando o ponteiro da instru√ß√£o est√° em algum lugar, isso n√£o significa que esteja executando esta instru√ß√£o.  Talvez ele esteja esperando por outras instru√ß√µes. <br><br>  Temos uma tabela de hash para verificar se algum n√∫mero ocorre em algum conjunto.  Para isso, fazemos uma pesquisa na mem√≥ria.  Quando fazemos uma pesquisa na mem√≥ria, temos uma falta de cache, porque a tabela de hash cont√©m 100 milh√µes de n√∫meros, n√£o √© garantido que caiba em nenhum cache.  Portanto, para executar a instru√ß√£o de verifica√ß√£o zero, esses dados j√° devem estar carregados da mem√≥ria.  E esperamos at√© que eles sejam carregados. <br><br><img src="https://habrastorage.org/webt/w9/7b/ed/w97bediv43zlhfvat95k7qdar3k.jpeg" width="700"><br><br>  Agora, o pr√≥ximo recurso, um pouco mais complexo - drives.  √Äs vezes, os SSDs tamb√©m s√£o chamados de unidades, embora isso n√£o esteja totalmente correto.  SSDs tamb√©m ser√£o inclu√≠dos neste exemplo. <br><br>  Abrimos, por exemplo, o iostat, que mostra uma utiliza√ß√£o de 100%. <br><br>  Nas confer√™ncias, muitas vezes acontece que o orador sobe ao palco e diz com pathos: ‚ÄúOs bancos de dados sempre confinam no disco.  Portanto, criamos um banco de dados na mem√≥ria.  Ela n√£o vai desacelerar. "  Se uma pessoa se aproxima de voc√™ e diz isso, voc√™ pode envi√°-la com seguran√ßa.  Haver√° alguns problemas - voc√™ diz, eu resolvi.  :) <br><br>  Suponha que um programa repouse em discos, a utiliza√ß√£o √© 100. Mas isso, √© claro, n√£o significa que usamos os discos de maneira ideal. <br><br>  Um exemplo t√≠pico √© quando voc√™ tem muito acesso aleat√≥rio.  Mesmo que o acesso seja seq√ºencial, voc√™ simplesmente l√™ o arquivo sequencialmente, mas ainda pode ser mais ou menos ideal. <br><br>  Por exemplo, voc√™ tem uma matriz RAID, v√°rios dispositivos - digamos, 8 discos.  E voc√™ acabou de ler sequencialmente sem ler adiante, com um tamanho de buffer de 1 MB, e o tamanho da parte da sua faixa no RAID tamb√©m √© de 1 MB.  Ent√£o, cada leitura que voc√™ ter√° em um dispositivo.  Ou, se n√£o estiver alinhado, de dois dispositivos.  Meio megabyte vai para algum lugar, outro meio megabyte para algum lugar, e assim por diante - os discos ser√£o usados ‚Äã‚Äãalternadamente: um, depois outro e depois um terceiro. <br><br>  Ele precisa ser lido com anteced√™ncia.  Ou, se voc√™ tiver O_DIRECT, aumente o tamanho do buffer.  Ou seja, a regra √©: 8 discos, tamanho do peda√ßo 1 MB, defina o tamanho do buffer para pelo menos 8 MB.  Mas isso funcionar√° da melhor maneira poss√≠vel se a leitura estiver alinhada.  E se n√£o estiver alinhado, primeiro haver√° pe√ßas extras e voc√™ precisar√° colocar mais, multiplicar por mais algumas. <br><br>  Ou, por exemplo, voc√™ possui o RAID 10. Com que velocidade voc√™ pode ler o RAID 10 - por exemplo, 8 discos?  Qual ser√° a vantagem?  Quatro vezes, porque h√° um espelho, ou oito vezes?  Na verdade, depende de como o RAID √© criado, com que arranjo de peda√ßos em faixas. <br><br>  Se voc√™ usar o mdadm no Linux, poder√° especificar o layout local e o local remoto, sendo quase melhor para grava√ß√£o e distante para leitura. <br><br>  Eu sempre recomendo usar o layout distante, porque quando voc√™ escreve no banco de dados anal√≠tico, geralmente n√£o √© t√£o cr√≠tico a tempo - mesmo que haja muito mais escrita do que leitura.  Isso √© feito por algum processo em segundo plano.  Mas quando voc√™ l√™, precisa conclu√≠-lo o mais r√°pido poss√≠vel.  Portanto, √© melhor otimizar o RAID para leitura, definindo o layout distante. <br><br>  Por sorte, no Linux, o mdadm configurar√° voc√™ para o layout pr√≥ximo por padr√£o, e voc√™ obter√° apenas metade do desempenho.  Existem muitos desses ancinhos. <br><br>  Outro rake terr√≠vel √© o RAID 5 ou o RAID 6. Tudo se adapta bem √†s leituras e grava√ß√µes seq√ºenciais.  No RAID 5, a multiplicidade √© "o n√∫mero de dispositivos menos um".  Isso aumenta bem mesmo com leituras aleat√≥rias, mas n√£o aumenta com leituras aleat√≥rias.  Fa√ßa um registro em qualquer lugar e voc√™ precisar√° ler os dados de todos os outros discos, absorv√™-los (XOR - aprox. Ed.) E gravar em outro local.  Para isso, um certo cache de tiras √© usado, um p√©ssimo rake.  No Linux, √© por padr√£o que voc√™ cria o RAID 5 e fica mais lento para voc√™.  E voc√™ pensar√° que o RAID 5 sempre fica mais lento, porque isso √© compreens√≠vel.  Mas, de fato, o motivo √© a configura√ß√£o errada. <br><br>  Outro exemplo  Voc√™ est√° lendo um SSD e comprou um bom SSD, que diz 300 mil leituras aleat√≥rias por segundo na especifica√ß√£o.  E por algum motivo voc√™ n√£o pode fazer isso.  E voc√™ pensa - sim, todos eles est√£o em suas especifica√ß√µes, n√£o existe.  Mas todas essas leituras devem ser feitas em paralelo, com o m√°ximo grau de paralelismo.  A √∫nica maneira de fazer isso de maneira ideal √© usar E / S ass√≠ncrona, que √© implementada usando o sistema chama io_submit, io_getevents, io_setup, etc. <br><br>  A prop√≥sito, os dados no disco, se voc√™ os armazenar, voc√™ sempre precisar√° compactar.  Vou dar um exemplo da pr√°tica.  Uma pessoa entrou em contato conosco no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">chat de suporte do</a> ClickHouse e disse: <br><br>  - ClickHouse compacta os dados.  Eu vejo que repousa sobre o processador.  Eu tenho SSDs NVMe muito r√°pidos, eles t√™m uma velocidade de leitura de v√°rios gigabytes por segundo.  √â poss√≠vel, de alguma forma, desativar a compacta√ß√£o no ClickHouse? <br>  "N√£o, de jeito nenhum", eu digo.  - Voc√™ precisa manter os dados compactados. <br>  - Vamos parar, vai haver outro algoritmo de compress√£o que n√£o faz nada. <br>  F√°cil.  Digite essas letras nesta linha de c√≥digo. <br>  "De fato, tudo √© muito simples", ele respondeu um dia depois.  Eu fiz. <br>  - Quanto o desempenho mudou? <br>  "Falha no teste", ele escreveu outro dia depois.  - H√° muitos dados.  Eles n√£o se encaixam mais nos SSDs. <br><br>  Vamos agora ver como pode ser a leitura do disco.  Come√ßamos o dstat, ele mostra a velocidade de leitura. <br><br><div class="spoiler">  <b class="spoiler_title">O primeiro exemplo de dstat e iostat</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/tp/bv/hc/tpbvhccpx_oezqb-bl61xfhcrtq.gif"><br></div></div><br>  Aqui est√° a coluna de leitura - 300 MB / s.  Lemos a partir de discos.  √â muito ou pouco - eu n√£o sei. <br><br>  Agora eu corro o iostat para verificar isso.  Aqui voc√™ pode ver a discrimina√ß√£o por dispositivo.  Eu tenho RAID, MD2 e oito discos r√≠gidos.  Cada um deles mostra reciclagem, nem chega a 100% (50-60%).  Mas o mais importante √© que eu li de cada disco apenas a uma velocidade de 20 a 30 MB / s.  E desde a inf√¢ncia me lembrei da regra de que voc√™ pode ler algo em torno de 100 MB / s no disco r√≠gido.  Por alguma raz√£o, isso ainda n√£o mudou muito. <br><br><div class="spoiler">  <b class="spoiler_title">Segundo exemplo de dstat e iostat</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/yv/x-/wf/yvx-wf4ufaglo2ehwozvvh1mj48.gif"><br></div></div><br>  Aqui est√° outro exemplo.  A leitura √© mais ideal.  Eu executo o dstat e tenho uma velocidade de leitura de 1 GB / s neste RAID 5 de oito unidades.  O que mostra o iostat?  Sim, quase 1 GB / s. <br><br>  Agora as unidades est√£o finalmente 100% carregadas.  √â verdade que, por algum motivo, dois s√£o 100% e o restante √© 95%.  Provavelmente, eles ainda s√£o um pouco diferentes.  Mas com cada um deles eu li 150 MB / s, ainda mais legal do que pode ser.  Qual a diferen√ßa?  No primeiro caso, li com tamanho insuficiente do buffer em peda√ßos insuficientes.  √â simples, digo-lhe verdades comuns. <br><br>  A prop√≥sito, se voc√™ acha que os dados ainda n√£o precisam ser compactados para o banco de dados anal√≠tico, ou seja, um relat√≥rio da confer√™ncia HighLoad ++ Siberia ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">habrastaty com base no relat√≥rio</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aprox</a> .).  Os organizadores decidiram fazer os relat√≥rios mais graves em Novosibirsk. <br><br><img src="https://habrastorage.org/webt/pu/6k/kp/pu6kkpnztqtp_elvxpta__ya8f0.jpeg" width="700"><br><br>  O pr√≥ximo exemplo √© a mem√≥ria.  Verdades comuns cont√≠nuas.  Primeiro, no Linux, nunca veja o que os programas gratuitos.  Para quem est√° assistindo, eles criaram especialmente o site linuxatemyram.com.  Entre, haver√° uma explica√ß√£o.  Voc√™ tamb√©m n√£o precisa examinar a quantidade de mem√≥ria virtual, porque qual √© a diferen√ßa, quanto espa√ßo de endere√ßo o programa alocou?  Veja quanta mem√≥ria f√≠sica √© usada. <br><br>  E mais um ancinho com o qual ainda n√£o est√° claro como lutar.  Lembre-se: o fato de que os alocadores geralmente n√£o gostam de dar mem√≥ria ao sistema √© normal.  Eles criaram o mmap, mas o munmap n√£o faz mais.  A mem√≥ria n√£o retornar√° ao sistema.  O programa pensa - eu sei melhor como vou usar a mem√≥ria.  Vou deixar para mim mesma.  Porque as chamadas de sistema mmap e munmap s√£o bem lentas.  Alterando o espa√ßo de endere√ßo, redefinindo os caches TLB do processador - √© melhor n√£o fazer isso.  No entanto, o sistema operacional ainda tem a capacidade de liberar mem√≥ria corretamente usando a chamada do sistema madvise.  O espa√ßo de endere√ßo permanecer√°, mas fisicamente a mem√≥ria pode ser descarregada. <br><br>  E nunca habilite a troca em servidores de produ√ß√£o com bancos de dados.  Voc√™ pensa - n√£o h√° mem√≥ria suficiente, incluirei troca.  Depois disso, a solicita√ß√£o ir√° parar de funcionar.  Vai quebrar um tempo sem fim. <br><br><img src="https://habrastorage.org/webt/mb/0d/2n/mb0d2nmqxl5zq7hu5foyae9ir40.jpeg" width="650"><br><br>  Com uma rede muito t√≠pico ancinho.  Se voc√™ criar uma conex√£o TCP a cada vez, levar√° algum tempo at√© que o tamanho correto da janela seja selecionado, pois o protocolo TCP n√£o sabe com que rapidez ser√° necess√°rio transmitir dados.  Ele se adapta a isso. <br><br>  Ou imagine: voc√™ est√° transferindo um arquivo e possui uma grande lat√™ncia na sua rede e uma perda decente de pacotes.  Ent√£o n√£o √© √≥bvio se √© certo usar o TCP para transferir arquivos.  Eu acho que est√° errado, j√° que o TCP garante consist√™ncia.  Por outro lado, voc√™ pode transferir metade do arquivo e a outra ao mesmo tempo.     TCP-     TCP   . ,   ,    ,  TCP    .    . <br><br>       100- ,   .     10   -,     ,   ,       .  .    . <br><br><img src="https://habrastorage.org/webt/xy/ch/_m/xych_mjdelh5uydffukjrxzbf-k.jpeg" width="800"><br><br>    ?      ‚Äî     .    ,     ,  ,  10  .    ,       . <br><br><img src="https://habrastorage.org/webt/mp/p_/bq/mpp_bqykipgfxtbiu6i8_a4xfpm.jpeg" width="400"><br><br>   : ¬´   -  ¬ª ‚Äî          .      iotop,  ,           ,   iops. <br><br>         ,     .  . <br><br><div class="spoiler"> <b class="spoiler_title">: top  </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/8r/3l/wg/8r3lwg_u4l6bexuezkp-s3kdvno.gif"><br></div></div><br>   top  -,   ,  clickHouse-server  -  , -  .   ,   ,    Shift+H,      .    ,  ClickHouse  .   ParalInputsProc,   .  BackgrProcPool ‚Äî   merges     .   ,            . <br><br>    ?     ClickHouse,  ,     .    BackgroundProcessingPool.     15 . 16  1,  1 ‚Äî   .  16?  ,    Linux ‚Äî   ,  : ¬´16 .  ¬ª.  :) <br><br>        clickhouse-benchmark.        clickhouse-client.    ,    clickhouse-client,  .      -         .             . <br><br><div class="spoiler"> <b class="spoiler_title">: clickhouse-benchmark + perf top</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bu/ol/_g/buol_gwiuvuqmnn3xxxzpkafc6g.gif"><br></div></div><br>         .  clickhouse-benchmark,  ,      ,   ,     ,           .       peft top.   peft top,       .  ,    -     -,      uniq: UniquesHashSet.  .    ,   .      ,   . <br><br>  , ,    .        ‚Äî   -.    ,  , XOR  -  .   -.        -   -.      ,              -. <br><br>     , , crc32q.         ,        ,     -   ,       -   . <br><br>     ,        ClickHouse.            , ,   .       ClickHouse. <br><br><img src="https://habrastorage.org/webt/je/ki/1x/jeki1xaabpztoth-0ixuuq5abny.jpeg" width="700"><br><br>     .  ,    ‚Äî  ,   SHOW PROCESSLIST.   .    ,  SELECT * FROM system processes.       :  , ,   .     ClickHouse top. <br><br>     ClickHouse ?       background-. Background- ‚Äî    merges.   ,  merges ,    SELECT * FROM system.merges. <br><br><div class="spoiler"> <b class="spoiler_title"> c </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/pb/gd/b3/pbgdb3f6o8qyvh6ez81heoo82tu.gif"><br></div></div><br> ,   .  -.    .  ‚Äî  ClickHouse.       .      ,  ,  . ,       . - traf_testing.  ?   ,       ,       .   ClickHouse  . <br><br><img src="https://habrastorage.org/webt/ni/aj/ro/niajrokowxcc2bp1n2ookwy8ljy.jpeg" width="700"><br><br>  .    ,      . ,    ,  ,    ,     .   query_log.        ‚Äî      ,   -    ,  SELECT ,    -  .   query_log     ,    .   -     .    ‚Äî    ,    .     :       . <br><br> ,  ,      ‚Äî merge, inserts,   .      part_log.      ,      . <br><br><img src="https://habrastorage.org/webt/lt/vn/cp/ltvncpwym4jc0qpjpofzygrb9qs.jpeg" width="700"><br><br>   query_log   clickhouse-benchmark.   select  ,    ,      stdin  clickhouse-benchmark. <br><br>     query_log  -   ,       . <br><br><img src="https://habrastorage.org/webt/zh/pm/tt/zhpmttv4oacr3fqnvanjwhrdsdg.jpeg" width="450"><br><br>       ,  ,   .     .     SET send_logs_level = 'trace',       ,    . <br><br><div class="spoiler"> <b class="spoiler_title">:  </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/3z/l0/g9/3zl0g92l6zqdt7gxtqogm-wt-ai.gif"><br></div></div><br> ,   .  ,     98%.   ,       .  √â muito simples  SET send_logs_level = 'trace',  ,    .  - : merging aggregated data,   .       1% .       ,    . <br><br>        ,   ,      query_log. <br><br>  . SELECT * FROM system.query_log    .  . ,   ,     ,      query_log. .      ‚Äî  ,    ,   ,       . . <br><br><img src="https://habrastorage.org/webt/6h/em/o3/6hemo3c8u8d4qv2bwxlt-xa0x_w.jpeg" width="470"><br><br>   ClickHouse   .   ‚Äî           system.events, system.metrics  system.asynchronous_metrics. Events ‚Äî    , ,     . 100 .          ‚Äî 10 .  system.metrics ‚Äî     . ,     10 ,     10  . <br><br>  system.asynchronous_metrics     ,     .  .          ‚Äî   .  , system.asynchronous_metrics ‚Äî  ,     - . ,   . <br><br>       ,     .      SHOW PROCESSLIST       .  query_log,        . <br><br><img src="https://habrastorage.org/webt/0p/cp/1r/0pcp1rjgl8aj4w29tcnj73n5eay.jpeg" width="520"><br><br> ,   .  ,    . ,   .   ,    ,       .   ,     Linux,   .    Linux    .     ,     .  ,    .      . <br><br> , OSReadChars  OSReadBytes.   ?  ,       ,        ,     .   ,        .   ,       ,         ,   .  ,   -      ,      . <br><br><div class="spoiler"> <b class="spoiler_title">  page cache</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ft/zd/z3/ftzdz3ycxppmbghwuxu108y3rcs.gif"><br></div></div><br> ,   .    - .  ,  40    , 6,7 . . ,     ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> . , , . <br><br>      ,    1,3 ,  5  .  Porque ,     ‚Äî      page cache.         ? <br><br><div class="spoiler"> <b class="spoiler_title"> c  </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/hr/cj/as/hrcjasfstnujjgo-fx9ene7t1g0.gif"><br></div></div><br>     .       . ,   ,        .   .     :     3,2 ,    ‚Äî 2,5 . , ,         ,   .  Porque -, :  read ahead.        ,       ‚Äî  ? -,         ‚Äî 4  , , 512 KB.     .    ,     .   ,  - read ahead. <br><br><img src="https://habrastorage.org/webt/dj/nb/kj/djnbkjh9mdniw34_odlupzqigfa.jpeg" width="700"><br><br>      .      .     ,     . , , ReadBytes ‚Äî  ,     .  3 ,     3 .  ,   ,    . <br><br>    ‚Äî IOWait. 87 .    7 ,  IOWait ‚Äî 87. ?  ‚Äî    .     .   ,      ,     87 .       ,  - . <br><br>    ‚Äî CPUWait.     ,  ,       ,       .  -     ‚Äî ,   .      CPU.         CPU.      - ,    .        ‚Äî ,  ,   user space.    ,     - .  Bem, tudo bem. <br><br>  ‚Äî  ,    Linux.         - ,    .    , ,       . <br><br><div class="spoiler"> <b class="spoiler_title">: query_thread_log</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fq/py/tf/fqpytfrrdsz4nxr8179r4pklzkm.gif"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E agora a coisa mais avan√ßada que temos: query_thread_log. </font><font style="vertical-align: inherit;">Com ele, voc√™ pode entender em que cada thread da execu√ß√£o da consulta perdeu tempo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu procuro minha solicita√ß√£o, selecione por query_id e indico a m√©trica "A quantidade de tempo do processador gasto no espa√ßo do usu√°rio". </font><font style="vertical-align: inherit;">Aqui est√£o os nossos fluxos. </font><font style="vertical-align: inherit;">Para processamento paralelo da solicita√ß√£o, 16 threads foram alocados. </font><font style="vertical-align: inherit;">Cada um deles gastou 800 ms. </font><font style="vertical-align: inherit;">E, em seguida, outros 16 encadeamentos foram alocados para a mesclagem do estado das fun√ß√µes agregadas; 0,25 s foram gastos em cada uma delas. </font><font style="vertical-align: inherit;">Agora eu posso entender exatamente o que cada solicita√ß√£o levou tempo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relat√≥rio de v√≠deo no HighLoad ++:</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ondHe_JUyW4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459198/">https://habr.com/ru/post/pt459198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459182/index.html">GitLab: com o lan√ßamento da vers√£o 12.1, paramos de suportar o MySQL</a></li>
<li><a href="../pt459184/index.html">Habilidades b√°sicas da unidade</a></li>
<li><a href="../pt459188/index.html">Lan√ßamento do Debian 10 Buster e Linux 5.2</a></li>
<li><a href="../pt459194/index.html">Como fizemos amigos do SCSS com vari√°veis ‚Äã‚ÄãCSS usando o tema do kit de interface do usu√°rio</a></li>
<li><a href="../pt459196/index.html">Dos mon√≥litos √†s equipes modulares</a></li>
<li><a href="../pt459204/index.html">10 ++ maneiras de trabalhar com registros de hardware em C ++ (por exemplo, IAR e Cortex M)</a></li>
<li><a href="../pt459206/index.html">9 anos em um mon√≥lito no Node.JS</a></li>
<li><a href="../pt459208/index.html">Corrida com pr√≥teses: simula√ß√£o Nekstgen do movimento humano usando m√∫sculos, ossos e uma rede neural</a></li>
<li><a href="../pt459212/index.html">Implementa√ß√£o de propriedade em C ++</a></li>
<li><a href="../pt459214/index.html">Toler√¢ncia a falhas no armazenamento Qsan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>