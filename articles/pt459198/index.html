<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👉🏿 🧗 👩‍👩‍👧‍👦 Análise de desempenho de consulta no ClickHouse. Relatório Yandex 👂 👉🏻 🧑🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="E se sua consulta ao banco de dados não estiver sendo executada com rapidez suficiente? Como você sabe se uma consulta usa os recursos de computação d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Análise de desempenho de consulta no ClickHouse. Relatório Yandex</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/459198/">  E se sua consulta ao banco de dados não estiver sendo executada com rapidez suficiente?  Como você sabe se uma consulta usa os recursos de computação de maneira ideal ou pode ser acelerada?  Na última conferência HighLoad ++ em Moscou, falei sobre a introspecção do desempenho de consultas - e o que o ClickHouse DBMS fornece e sobre os recursos do SO que todos deveriam conhecer. <br><br><img src="https://habrastorage.org/webt/mi/yo/wu/miyowuhgorpfpl9zih8cszids0y.jpeg"><br><br>  Toda vez que faço uma solicitação, me preocupo não apenas com o resultado, mas também com o que essa solicitação faz.  Por exemplo, funciona por um segundo.  É muito ou pouco?  Eu sempre penso: por que não meio segundo?  Então eu otimizo alguma coisa, acelero e funciona por 10 ms.  Eu geralmente estou satisfeito.  Mas ainda assim, neste caso, tento fazer uma expressão facial descontente e pergunto: "Por que não 5 ms?"  Como posso descobrir quanto tempo é gasto no processamento da solicitação?  Pode ser acelerado em princípio? <br><br><a name="habracut"></a>  Normalmente, a velocidade de processamento da solicitação é aritmética simples.  Nós escrevemos o código - provavelmente da melhor maneira - e temos algum dispositivo no sistema.  Os dispositivos têm especificações.  Por exemplo, a velocidade de leitura do cache L1.  Ou o número de leituras aleatórias que um SSD pode fazer.  Todos nós sabemos disso.  Precisamos pegar essas características, adicionar, subtrair, multiplicar, dividir e verificar a resposta.  Mas este é o caso ideal, isso quase nunca acontece.  Quase.  De fato, isso às vezes acontece no ClickHouse. <br><br>  Considere os fatos triviais sobre quais dispositivos e quais recursos existem em nossos servidores. <br><br><img src="https://habrastorage.org/webt/6e/gz/us/6egzusxqlzhg81ledkch36wrld4.jpeg" width="700"><br><br>  Processador, memória, disco, rede.  Organizei esses recursos especialmente dessa maneira, começando pelo mais simples e conveniente para revisão e otimização e terminando no mais inconveniente e complexo.  Por exemplo, eu executo uma solicitação e vejo que meu programa parece estar na CPU.  O que isso significa?  O que vou descobrir que existe algum tipo de loop interno, uma função que é executada com mais freqüência, reescreve o código, recompila e uma vez - meu programa roda mais rápido. <br><br>  Se você gasta muita RAM, tudo fica um pouco mais complicado.  Você precisa repensar a estrutura de dados, espremer alguns bits.  De qualquer forma, reinicio meu programa e ele gasta menos RAM.  É verdade que isso costuma prejudicar o processador. <br><br>  Se tudo depende de discos, isso também é mais difícil, porque posso alterar a estrutura de dados no disco, mas preciso convertê-los posteriormente.  Se eu fizer um novo lançamento, as pessoas terão que fazer algum tipo de migração de dados.  Acontece que o disco já é muito mais complicado, e é melhor pensar com antecedência. <br><br>  E a rede ... Eu realmente não gosto da rede, porque muitas vezes não está claro o que está acontecendo nela, especialmente se é uma rede entre continentes, entre data centers.  Algo está diminuindo a velocidade e não é nem sua rede, nem seu servidor, e você não pode fazer nada.  A única coisa que você pode pensar antecipadamente é como os dados serão transmitidos e como minimizar a interação na rede. <br><br>  Acontece que nem um único recurso do sistema é utilizado, e o programa está apenas esperando por algo.  De fato, esse é um caso muito frequente, porque nosso sistema é distribuído, e pode haver muitos processos e fluxos diferentes, e alguém está esperando pelo outro, e tudo isso precisa estar de alguma forma conectado entre si para que seja considerado adequadamente. <br><br><img src="https://habrastorage.org/webt/vq/mk/sa/vqmksaynboi4frop2kzfcvk9q4w.jpeg" width="700"><br><br>  O mais simples é observar a utilização de recursos, com algum valor numérico.  Por exemplo, você inicia alguns top e ele escreve: o processador é 100%.  Ou execute o iostat e ele escreve: os discos são 100%.  É verdade que isso geralmente não é suficiente.  Uma pessoa verá que o programa se baseia em discos.  O que pode ser feito?  Você pode simplesmente notar isso e descansar, decidir que tudo, nada pode ser otimizado.  Mas, de fato, cada um dos dispositivos dentro de si é bastante complicado.  O processador possui vários dispositivos de computação para diferentes tipos de operações.  Os discos podem ter uma matriz RAID.  Se houver um SSD, haverá dentro de seu próprio processador, seu próprio controlador, o que torna claro o que.  E um valor - 50% ou 100% - não é suficiente.  A regra básica: se você perceber que algum recurso é 100% utilizado, não desista.  Muitas vezes, você ainda pode melhorar alguma coisa.  Mas isso acontece e vice-versa.  Digamos que você veja que a reciclagem é de 50%, mas nada pode ser feito. <br><br>  Vamos dar uma olhada mais de perto nisso. <br><br><img src="https://habrastorage.org/webt/pa/wj/uo/pawjuoieudajqc097ysekq30wnc.jpeg" width="700"><br><br>  O recurso mais fácil e conveniente é o processador.  Você olha para cima, diz que o processador é 100%.  Mas deve-se ter em mente que este não é um processador 100%.  O programa superior não sabe o que o processador faz lá.  Ela olha da perspectiva do planejador do sistema operacional.  Ou seja, agora algum tipo de thread de programa está sendo executado no processador.  O processador faz alguma coisa e, em seguida, 100% será mostrado se for calculada a média ao longo do tempo.  Ao mesmo tempo, o processador está fazendo algo, e não está claro quão eficaz é.  Pode executar um número diferente de instruções por ciclo.  Se houver poucas instruções, o próprio processador pode esperar por algo, por exemplo, carregando dados da memória.  Ao mesmo tempo, a mesma coisa será exibida no topo - 100%.  Estamos aguardando o processador seguir nossas instruções.  E o que ele faz por dentro não é claro. <br><br>  Finalmente, há apenas um rake quando você pensa que seu programa repousa no processador.  Isso é verdade, mas por algum motivo o processador tem uma frequência mais baixa.  Pode haver muitas razões: superaquecimento, limitação de energia.  Por alguma razão, no data center, há uma limitação de energia ou a economia de energia pode simplesmente ser ativada.  Em seguida, o processador mudará constantemente de uma frequência mais alta para uma mais baixa, mas se sua carga for instável, isso não será suficiente e, em média, o código será executado mais lentamente.  Veja o turbostato para a freqüência atual do processador.  Verifique se há superaquecimento em dmesg.  Se algo assim acontecesse, diria: “Superaquecimento.  Frequência reduzida. ” <br><br>  Se você estiver interessado em quantas falhas de cache estavam dentro, quantas instruções são executadas por ciclo, use o registro perf.  Registre algumas amostras do programa.  Além disso, será possível analisá-lo usando perf stat ou perf report. <br><br><img src="https://habrastorage.org/webt/hl/4v/up/hl4vupofzsuha-s7cyxtba-po0c.jpeg" width="600"><br><br>  E vice-versa.  Digamos que você olhe para o topo e o processador seja menos de 50% reciclado.  Suponha que você tenha 32 núcleos de processador virtual em seu sistema e 16 núcleos físicos.Em processadores Intel, isso ocorre porque o hiperencadeamento é duplo.  Mas isso não significa que núcleos adicionais sejam inúteis.  Tudo depende da carga.  Suponha que você tenha algumas operações de álgebra linear bem otimizadas ou tenha hashes para minerar bitcoins.  Então o código ficará claro, muitas instruções serão executadas por ciclo, não haverá falhas no cache, previsões erradas de ramificação também.  E o hyper-threading não ajuda.  Ajuda quando você tem um núcleo aguardando algo, enquanto o outro pode executar simultaneamente instruções de outro encadeamento. <br><br>  ClickHouse tem ambas as situações.  Por exemplo, quando fizermos agregação de dados (GROUP BY) ou filtragem por conjunto (subconsulta IN), teremos uma tabela de hash.  Se a tabela de hash não couber no cache do processador, ocorrerão falhas no cache.  Isso dificilmente pode ser evitado.  Nesse caso, o hiperencadeamento nos ajudará. <br><br>  Por padrão, o ClickHouse usa apenas núcleos físicos do processador, excluindo o hyperthreading.  Se você souber que sua solicitação pode se beneficiar da hiperencadeamento, basta dobrar o número de threads: SET max threads = 32, e sua solicitação será mais rápida. <br><br>  Acontece que o processador está perfeitamente usado, mas você olha para o gráfico e vê, por exemplo, 10%.  E sua agenda, por exemplo, é de cinco minutos no pior caso.  Mesmo se for um segundo, ainda há algum tipo de valor médio.  De fato, você sempre teve solicitações, elas são executadas rapidamente, em 100 ms a cada segundo, e isso é normal.  Porque o ClickHouse tenta executar a solicitação o mais rápido possível.  Ele não tenta usar e superaquecer completamente e constantemente seus processadores. <br><br><img src="https://habrastorage.org/webt/39/ka/ei/39kaeie-ngofbbynsnlq4mum_d0.jpeg" width="700"><br><br>  Vamos dar uma olhada, uma opção um pouco complicada.  Há uma consulta com uma expressão na subconsulta.  Dentro da subconsulta, temos 100 milhões de números aleatórios.  E nós apenas filtramos esse resultado. <br><br>  Vemos uma foto assim.  A propósito, quem dirá com que ferramenta posso ver esta foto maravilhosa?  Absolutamente verdade - perf.  Estou muito feliz que você saiba disso. <br><br>  Abri o perf, pensando que agora entendo tudo.  Eu abro a listagem do assembler.  Lá, escrevi com que frequência a execução do programa estava em uma instrução específica, ou seja, com que frequência havia um ponteiro de instrução.  Aqui, os números estão em porcentagem, e está escrito que quase 90% das vezes a instrução% edx,% edx foi executada, ou seja, verificando quatro bytes como zero. <br><br>  A questão é: por que um processador pode demorar tanto para simplesmente comparar quatro bytes com zero?  (respostas da platéia ...) Não há resto da divisão.  Há mudanças de bits, há uma instrução crc32q, mas como se o ponteiro da instrução nunca acontecesse nela.  E a geração de números aleatórios não está nesta listagem.  Havia uma função separada e é muito bem otimizada, não diminui a velocidade.  Algo mais está desacelerando aqui.  A execução do código para nesta instrução e gasta muito tempo.  Loop ocioso?  Não.  Por que devo inserir loops vazios?  Além disso, se eu inserisse o loop Idle, isso também seria visível em perf.  Não há divisão por zero, há simplesmente uma comparação com zero. <br><br>  O processador possui um pipeline, ele pode executar várias instruções em paralelo.  E quando o ponteiro da instrução está em algum lugar, isso não significa que esteja executando esta instrução.  Talvez ele esteja esperando por outras instruções. <br><br>  Temos uma tabela de hash para verificar se algum número ocorre em algum conjunto.  Para isso, fazemos uma pesquisa na memória.  Quando fazemos uma pesquisa na memória, temos uma falta de cache, porque a tabela de hash contém 100 milhões de números, não é garantido que caiba em nenhum cache.  Portanto, para executar a instrução de verificação zero, esses dados já devem estar carregados da memória.  E esperamos até que eles sejam carregados. <br><br><img src="https://habrastorage.org/webt/w9/7b/ed/w97bediv43zlhfvat95k7qdar3k.jpeg" width="700"><br><br>  Agora, o próximo recurso, um pouco mais complexo - drives.  Às vezes, os SSDs também são chamados de unidades, embora isso não esteja totalmente correto.  SSDs também serão incluídos neste exemplo. <br><br>  Abrimos, por exemplo, o iostat, que mostra uma utilização de 100%. <br><br>  Nas conferências, muitas vezes acontece que o orador sobe ao palco e diz com pathos: “Os bancos de dados sempre confinam no disco.  Portanto, criamos um banco de dados na memória.  Ela não vai desacelerar. "  Se uma pessoa se aproxima de você e diz isso, você pode enviá-la com segurança.  Haverá alguns problemas - você diz, eu resolvi.  :) <br><br>  Suponha que um programa repouse em discos, a utilização é 100. Mas isso, é claro, não significa que usamos os discos de maneira ideal. <br><br>  Um exemplo típico é quando você tem muito acesso aleatório.  Mesmo que o acesso seja seqüencial, você simplesmente lê o arquivo sequencialmente, mas ainda pode ser mais ou menos ideal. <br><br>  Por exemplo, você tem uma matriz RAID, vários dispositivos - digamos, 8 discos.  E você acabou de ler sequencialmente sem ler adiante, com um tamanho de buffer de 1 MB, e o tamanho da parte da sua faixa no RAID também é de 1 MB.  Então, cada leitura que você terá em um dispositivo.  Ou, se não estiver alinhado, de dois dispositivos.  Meio megabyte vai para algum lugar, outro meio megabyte para algum lugar, e assim por diante - os discos serão usados ​​alternadamente: um, depois outro e depois um terceiro. <br><br>  Ele precisa ser lido com antecedência.  Ou, se você tiver O_DIRECT, aumente o tamanho do buffer.  Ou seja, a regra é: 8 discos, tamanho do pedaço 1 MB, defina o tamanho do buffer para pelo menos 8 MB.  Mas isso funcionará da melhor maneira possível se a leitura estiver alinhada.  E se não estiver alinhado, primeiro haverá peças extras e você precisará colocar mais, multiplicar por mais algumas. <br><br>  Ou, por exemplo, você possui o RAID 10. Com que velocidade você pode ler o RAID 10 - por exemplo, 8 discos?  Qual será a vantagem?  Quatro vezes, porque há um espelho, ou oito vezes?  Na verdade, depende de como o RAID é criado, com que arranjo de pedaços em faixas. <br><br>  Se você usar o mdadm no Linux, poderá especificar o layout local e o local remoto, sendo quase melhor para gravação e distante para leitura. <br><br>  Eu sempre recomendo usar o layout distante, porque quando você escreve no banco de dados analítico, geralmente não é tão crítico a tempo - mesmo que haja muito mais escrita do que leitura.  Isso é feito por algum processo em segundo plano.  Mas quando você lê, precisa concluí-lo o mais rápido possível.  Portanto, é melhor otimizar o RAID para leitura, definindo o layout distante. <br><br>  Por sorte, no Linux, o mdadm configurará você para o layout próximo por padrão, e você obterá apenas metade do desempenho.  Existem muitos desses ancinhos. <br><br>  Outro rake terrível é o RAID 5 ou o RAID 6. Tudo se adapta bem às leituras e gravações seqüenciais.  No RAID 5, a multiplicidade é "o número de dispositivos menos um".  Isso aumenta bem mesmo com leituras aleatórias, mas não aumenta com leituras aleatórias.  Faça um registro em qualquer lugar e você precisará ler os dados de todos os outros discos, absorvê-los (XOR - aprox. Ed.) E gravar em outro local.  Para isso, um certo cache de tiras é usado, um péssimo rake.  No Linux, é por padrão que você cria o RAID 5 e fica mais lento para você.  E você pensará que o RAID 5 sempre fica mais lento, porque isso é compreensível.  Mas, de fato, o motivo é a configuração errada. <br><br>  Outro exemplo  Você está lendo um SSD e comprou um bom SSD, que diz 300 mil leituras aleatórias por segundo na especificação.  E por algum motivo você não pode fazer isso.  E você pensa - sim, todos eles estão em suas especificações, não existe.  Mas todas essas leituras devem ser feitas em paralelo, com o máximo grau de paralelismo.  A única maneira de fazer isso de maneira ideal é usar E / S assíncrona, que é implementada usando o sistema chama io_submit, io_getevents, io_setup, etc. <br><br>  A propósito, os dados no disco, se você os armazenar, você sempre precisará compactar.  Vou dar um exemplo da prática.  Uma pessoa entrou em contato conosco no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">chat de suporte do</a> ClickHouse e disse: <br><br>  - ClickHouse compacta os dados.  Eu vejo que repousa sobre o processador.  Eu tenho SSDs NVMe muito rápidos, eles têm uma velocidade de leitura de vários gigabytes por segundo.  É possível, de alguma forma, desativar a compactação no ClickHouse? <br>  "Não, de jeito nenhum", eu digo.  - Você precisa manter os dados compactados. <br>  - Vamos parar, vai haver outro algoritmo de compressão que não faz nada. <br>  Fácil.  Digite essas letras nesta linha de código. <br>  "De fato, tudo é muito simples", ele respondeu um dia depois.  Eu fiz. <br>  - Quanto o desempenho mudou? <br>  "Falha no teste", ele escreveu outro dia depois.  - Há muitos dados.  Eles não se encaixam mais nos SSDs. <br><br>  Vamos agora ver como pode ser a leitura do disco.  Começamos o dstat, ele mostra a velocidade de leitura. <br><br><div class="spoiler">  <b class="spoiler_title">O primeiro exemplo de dstat e iostat</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/tp/bv/hc/tpbvhccpx_oezqb-bl61xfhcrtq.gif"><br></div></div><br>  Aqui está a coluna de leitura - 300 MB / s.  Lemos a partir de discos.  É muito ou pouco - eu não sei. <br><br>  Agora eu corro o iostat para verificar isso.  Aqui você pode ver a discriminação por dispositivo.  Eu tenho RAID, MD2 e oito discos rígidos.  Cada um deles mostra reciclagem, nem chega a 100% (50-60%).  Mas o mais importante é que eu li de cada disco apenas a uma velocidade de 20 a 30 MB / s.  E desde a infância me lembrei da regra de que você pode ler algo em torno de 100 MB / s no disco rígido.  Por alguma razão, isso ainda não mudou muito. <br><br><div class="spoiler">  <b class="spoiler_title">Segundo exemplo de dstat e iostat</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/yv/x-/wf/yvx-wf4ufaglo2ehwozvvh1mj48.gif"><br></div></div><br>  Aqui está outro exemplo.  A leitura é mais ideal.  Eu executo o dstat e tenho uma velocidade de leitura de 1 GB / s neste RAID 5 de oito unidades.  O que mostra o iostat?  Sim, quase 1 GB / s. <br><br>  Agora as unidades estão finalmente 100% carregadas.  É verdade que, por algum motivo, dois são 100% e o restante é 95%.  Provavelmente, eles ainda são um pouco diferentes.  Mas com cada um deles eu li 150 MB / s, ainda mais legal do que pode ser.  Qual a diferença?  No primeiro caso, li com tamanho insuficiente do buffer em pedaços insuficientes.  É simples, digo-lhe verdades comuns. <br><br>  A propósito, se você acha que os dados ainda não precisam ser compactados para o banco de dados analítico, ou seja, um relatório da conferência HighLoad ++ Siberia ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">habrastaty com base no relatório</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aprox</a> .).  Os organizadores decidiram fazer os relatórios mais graves em Novosibirsk. <br><br><img src="https://habrastorage.org/webt/pu/6k/kp/pu6kkpnztqtp_elvxpta__ya8f0.jpeg" width="700"><br><br>  O próximo exemplo é a memória.  Verdades comuns contínuas.  Primeiro, no Linux, nunca veja o que os programas gratuitos.  Para quem está assistindo, eles criaram especialmente o site linuxatemyram.com.  Entre, haverá uma explicação.  Você também não precisa examinar a quantidade de memória virtual, porque qual é a diferença, quanto espaço de endereço o programa alocou?  Veja quanta memória física é usada. <br><br>  E mais um ancinho com o qual ainda não está claro como lutar.  Lembre-se: o fato de que os alocadores geralmente não gostam de dar memória ao sistema é normal.  Eles criaram o mmap, mas o munmap não faz mais.  A memória não retornará ao sistema.  O programa pensa - eu sei melhor como vou usar a memória.  Vou deixar para mim mesma.  Porque as chamadas de sistema mmap e munmap são bem lentas.  Alterando o espaço de endereço, redefinindo os caches TLB do processador - é melhor não fazer isso.  No entanto, o sistema operacional ainda tem a capacidade de liberar memória corretamente usando a chamada do sistema madvise.  O espaço de endereço permanecerá, mas fisicamente a memória pode ser descarregada. <br><br>  E nunca habilite a troca em servidores de produção com bancos de dados.  Você pensa - não há memória suficiente, incluirei troca.  Depois disso, a solicitação irá parar de funcionar.  Vai quebrar um tempo sem fim. <br><br><img src="https://habrastorage.org/webt/mb/0d/2n/mb0d2nmqxl5zq7hu5foyae9ir40.jpeg" width="650"><br><br>  Com uma rede muito típico ancinho.  Se você criar uma conexão TCP a cada vez, levará algum tempo até que o tamanho correto da janela seja selecionado, pois o protocolo TCP não sabe com que rapidez será necessário transmitir dados.  Ele se adapta a isso. <br><br>  Ou imagine: você está transferindo um arquivo e possui uma grande latência na sua rede e uma perda decente de pacotes.  Então não é óbvio se é certo usar o TCP para transferir arquivos.  Eu acho que está errado, já que o TCP garante consistência.  Por outro lado, você pode transferir metade do arquivo e a outra ao mesmo tempo.     TCP-     TCP   . ,   ,    ,  TCP    .    . <br><br>       100- ,   .     10   -,     ,   ,       .  .    . <br><br><img src="https://habrastorage.org/webt/xy/ch/_m/xych_mjdelh5uydffukjrxzbf-k.jpeg" width="800"><br><br>    ?      —     .    ,     ,  ,  10  .    ,       . <br><br><img src="https://habrastorage.org/webt/mp/p_/bq/mpp_bqykipgfxtbiu6i8_a4xfpm.jpeg" width="400"><br><br>   : «   -  » —          .      iotop,  ,           ,   iops. <br><br>         ,     .  . <br><br><div class="spoiler"> <b class="spoiler_title">: top  </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/8r/3l/wg/8r3lwg_u4l6bexuezkp-s3kdvno.gif"><br></div></div><br>   top  -,   ,  clickHouse-server  -  , -  .   ,   ,    Shift+H,      .    ,  ClickHouse  .   ParalInputsProc,   .  BackgrProcPool —   merges     .   ,            . <br><br>    ?     ClickHouse,  ,     .    BackgroundProcessingPool.     15 . 16  1,  1 —   .  16?  ,    Linux —   ,  : «16 .  ».  :) <br><br>        clickhouse-benchmark.        clickhouse-client.    ,    clickhouse-client,  .      -         .             . <br><br><div class="spoiler"> <b class="spoiler_title">: clickhouse-benchmark + perf top</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bu/ol/_g/buol_gwiuvuqmnn3xxxzpkafc6g.gif"><br></div></div><br>         .  clickhouse-benchmark,  ,      ,   ,     ,           .       peft top.   peft top,       .  ,    -     -,      uniq: UniquesHashSet.  .    ,   .      ,   . <br><br>  , ,    .        —   -.    ,  , XOR  -  .   -.        -   -.      ,              -. <br><br>     , , crc32q.         ,        ,     -   ,       -   . <br><br>     ,        ClickHouse.            , ,   .       ClickHouse. <br><br><img src="https://habrastorage.org/webt/je/ki/1x/jeki1xaabpztoth-0ixuuq5abny.jpeg" width="700"><br><br>     .  ,    —  ,   SHOW PROCESSLIST.   .    ,  SELECT * FROM system processes.       :  , ,   .     ClickHouse top. <br><br>     ClickHouse ?       background-. Background- —    merges.   ,  merges ,    SELECT * FROM system.merges. <br><br><div class="spoiler"> <b class="spoiler_title"> c </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/pb/gd/b3/pbgdb3f6o8qyvh6ez81heoo82tu.gif"><br></div></div><br> ,   .  -.    .  —  ClickHouse.       .      ,  ,  . ,       . - traf_testing.  ?   ,       ,       .   ClickHouse  . <br><br><img src="https://habrastorage.org/webt/ni/aj/ro/niajrokowxcc2bp1n2ookwy8ljy.jpeg" width="700"><br><br>  .    ,      . ,    ,  ,    ,     .   query_log.        —      ,   -    ,  SELECT ,    -  .   query_log     ,    .   -     .    —    ,    .     :       . <br><br> ,  ,      — merge, inserts,   .      part_log.      ,      . <br><br><img src="https://habrastorage.org/webt/lt/vn/cp/ltvncpwym4jc0qpjpofzygrb9qs.jpeg" width="700"><br><br>   query_log   clickhouse-benchmark.   select  ,    ,      stdin  clickhouse-benchmark. <br><br>     query_log  -   ,       . <br><br><img src="https://habrastorage.org/webt/zh/pm/tt/zhpmttv4oacr3fqnvanjwhrdsdg.jpeg" width="450"><br><br>       ,  ,   .     .     SET send_logs_level = 'trace',       ,    . <br><br><div class="spoiler"> <b class="spoiler_title">:  </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/3z/l0/g9/3zl0g92l6zqdt7gxtqogm-wt-ai.gif"><br></div></div><br> ,   .  ,     98%.   ,       .  É muito simples  SET send_logs_level = 'trace',  ,    .  - : merging aggregated data,   .       1% .       ,    . <br><br>        ,   ,      query_log. <br><br>  . SELECT * FROM system.query_log    .  . ,   ,     ,      query_log. .      —  ,    ,   ,       . . <br><br><img src="https://habrastorage.org/webt/6h/em/o3/6hemo3c8u8d4qv2bwxlt-xa0x_w.jpeg" width="470"><br><br>   ClickHouse   .   —           system.events, system.metrics  system.asynchronous_metrics. Events —    , ,     . 100 .          — 10 .  system.metrics —     . ,     10 ,     10  . <br><br>  system.asynchronous_metrics     ,     .  .          —   .  , system.asynchronous_metrics —  ,     - . ,   . <br><br>       ,     .      SHOW PROCESSLIST       .  query_log,        . <br><br><img src="https://habrastorage.org/webt/0p/cp/1r/0pcp1rjgl8aj4w29tcnj73n5eay.jpeg" width="520"><br><br> ,   .  ,    . ,   .   ,    ,       .   ,     Linux,   .    Linux    .     ,     .  ,    .      . <br><br> , OSReadChars  OSReadBytes.   ?  ,       ,        ,     .   ,        .   ,       ,         ,   .  ,   -      ,      . <br><br><div class="spoiler"> <b class="spoiler_title">  page cache</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ft/zd/z3/ftzdz3ycxppmbghwuxu108y3rcs.gif"><br></div></div><br> ,   .    - .  ,  40    , 6,7 . . ,     ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> . , , . <br><br>      ,    1,3 ,  5  .  Porque ,     —      page cache.         ? <br><br><div class="spoiler"> <b class="spoiler_title"> c  </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/hr/cj/as/hrcjasfstnujjgo-fx9ene7t1g0.gif"><br></div></div><br>     .       . ,   ,        .   .     :     3,2 ,    — 2,5 . , ,         ,   .  Porque -, :  read ahead.        ,       —  ? -,         — 4  , , 512 KB.     .    ,     .   ,  - read ahead. <br><br><img src="https://habrastorage.org/webt/dj/nb/kj/djnbkjh9mdniw34_odlupzqigfa.jpeg" width="700"><br><br>      .      .     ,     . , , ReadBytes —  ,     .  3 ,     3 .  ,   ,    . <br><br>    — IOWait. 87 .    7 ,  IOWait — 87. ?  —    .     .   ,      ,     87 .       ,  - . <br><br>    — CPUWait.     ,  ,       ,       .  -     — ,   .      CPU.         CPU.      - ,    .        — ,  ,   user space.    ,     - .  Bem, tudo bem. <br><br>  —  ,    Linux.         - ,    .    , ,       . <br><br><div class="spoiler"> <b class="spoiler_title">: query_thread_log</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fq/py/tf/fqpytfrrdsz4nxr8179r4pklzkm.gif"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E agora a coisa mais avançada que temos: query_thread_log. </font><font style="vertical-align: inherit;">Com ele, você pode entender em que cada thread da execução da consulta perdeu tempo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu procuro minha solicitação, selecione por query_id e indico a métrica "A quantidade de tempo do processador gasto no espaço do usuário". </font><font style="vertical-align: inherit;">Aqui estão os nossos fluxos. </font><font style="vertical-align: inherit;">Para processamento paralelo da solicitação, 16 threads foram alocados. </font><font style="vertical-align: inherit;">Cada um deles gastou 800 ms. </font><font style="vertical-align: inherit;">E, em seguida, outros 16 encadeamentos foram alocados para a mesclagem do estado das funções agregadas; 0,25 s foram gastos em cada uma delas. </font><font style="vertical-align: inherit;">Agora eu posso entender exatamente o que cada solicitação levou tempo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relatório de vídeo no HighLoad ++:</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ondHe_JUyW4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459198/">https://habr.com/ru/post/pt459198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459182/index.html">GitLab: com o lançamento da versão 12.1, paramos de suportar o MySQL</a></li>
<li><a href="../pt459184/index.html">Habilidades básicas da unidade</a></li>
<li><a href="../pt459188/index.html">Lançamento do Debian 10 Buster e Linux 5.2</a></li>
<li><a href="../pt459194/index.html">Como fizemos amigos do SCSS com variáveis ​​CSS usando o tema do kit de interface do usuário</a></li>
<li><a href="../pt459196/index.html">Dos monólitos às equipes modulares</a></li>
<li><a href="../pt459204/index.html">10 ++ maneiras de trabalhar com registros de hardware em C ++ (por exemplo, IAR e Cortex M)</a></li>
<li><a href="../pt459206/index.html">9 anos em um monólito no Node.JS</a></li>
<li><a href="../pt459208/index.html">Corrida com próteses: simulação Nekstgen do movimento humano usando músculos, ossos e uma rede neural</a></li>
<li><a href="../pt459212/index.html">Implementação de propriedade em C ++</a></li>
<li><a href="../pt459214/index.html">Tolerância a falhas no armazenamento Qsan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>