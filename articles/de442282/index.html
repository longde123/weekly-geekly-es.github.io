<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏼 😗 👨🏾‍🤝‍👨🏼 Dart 2. Asynchrone Programmierung: Futures 🔀 👩🏾‍🤝‍👨🏽 👩🏻‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Asynchrone Programmierung: Futures 


 Inhalt 


- Einführung 
- Was ist die Zukunft? 
- Async - warte Fehlerbehandlung Sequentielle Ausführung 
- Feh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dart 2. Asynchrone Programmierung: Futures</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442282/"><h1 id="asinhronnoe-programmirovanie-futures">  Asynchrone Programmierung: Futures </h1><br><p>  <strong>Inhalt</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist die Zukunft?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Async - warte</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehlerbehandlung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sequentielle Ausführung</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zukünftige API</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehlerbehandlung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufruf mehrerer Funktionen, die die Zukunft zurückgeben</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was noch zu lesen?</a> </li></ul><br><p>  <strong>Was ist wichtig:</strong> </p><br><ul><li>  Der Code in Dart wird in einer einzelnen Thread-Ausführung ( <em>Note Thread - Thread</em> ) ausgeführt. </li><li>  Aufgrund von Code, der den Thread für eine lange Zeit benötigt (blockiert), kann das Programm einfrieren. </li><li> <code>Future</code> ( <code>futures</code> ) Objekte stellen die Ergebnisse asynchroner Operationen dar - Verarbeitung oder E / A, die später abgeschlossen werden. </li><li>  Um die Ausführung in Zukunft bis zum Abschluss auszusetzen, verwenden Sie <code>await</code> in der asynchronen Funktion (oder <code>then()</code> wenn Sie die <code>Future</code> API verwenden). </li><li>  Verwenden Sie zum Abfangen von Fehlern das <code>try-catch</code> Konstrukt (oder <code>catchError()</code> bei Verwendung der <code>Future</code> API) in der asynchronen Funktion. </li><li>  Erstellen Sie für die gleichzeitige Verarbeitung ein Isolat (oder einen Worker für die Webanwendung). <a name="habracut"></a></li></ul><br><p>  Der Code in Dart wird in einem einzelnen Ausführungsthread ausgeführt.  Wenn der Code mit langen Berechnungen beschäftigt ist oder auf eine E / A-Operation wartet, wird das gesamte Programm angehalten. </p><br><p>  Durch asynchrone Vorgänge kann Ihr Programm andere Aufgaben ausführen, während Sie auf den Abschluss des Vorgangs warten.  Dart verwendet <code>futures</code> , um die Ergebnisse asynchroner Operationen darzustellen.  Sie können auch async and await oder die Future API verwenden, um mit <code>futures</code> zu arbeiten. </p><br><p>  <em>Eine Notiz</em> </p><br><blockquote>  Der gesamte Code wird im Kontext des Isolats ausgeführt, dem der gesamte vom Code verwendete Speicher gehört.  Es kann nicht mehr als eine Codeausführung im selben Isolat gestartet werden. <br><br>  Für die parallele Ausführung von Codeblöcken können Sie diese in separate Isolate aufteilen.  (Webanwendungen verwenden Worker anstelle von Isolaten.) In der Regel wird jedes der Isolate auf einem eigenen Prozessorkern ausgeführt.  Isolate teilen sich nicht den Speicher und können nur interagieren, indem sie sich gegenseitig Nachrichten senden.  Informationen zum Thema finden Sie in der Dokumentation zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isolaten</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeitern</a> . </blockquote><br><h2 id="vvedenie">  Einführung </h2><br><p>  Schauen wir uns ein Beispiel für Code an, der die Programmausführung „einfrieren“ kann: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Synchronous code void printDailyNewsDigest() { var newsDigest = gatherNewsReports(); // Can take a while. print(newsDigest); } main() { printDailyNewsDigest(); printWinningLotteryNumbers(); printWeatherForecast(); printBaseballScore(); }</span></span></code> </pre> <br><p>  Unser Programm liest Nachrichten aus der Tagesdatei, zeigt sie an und zeigt dann Informationen an, die für den Benutzer immer noch von Interesse sind: </p><br><pre> <code class="plaintext hljs">&lt;gathered news goes here&gt; Winning lotto numbers: [23, 63, 87, 26, 2] Tomorrow's forecast: 70F, sunny. Baseball score: Red Sox 10, Yankees 0</code> </pre> <br><p>  In diesem Beispiel besteht das Problem darin, dass alle Vorgänge nach dem Aufruf von <code>gatherNewsReports()</code> warten, bis <code>gatherNewsReports()</code> den Inhalt der Datei <code>gatherNewsReports()</code> , unabhängig davon, wie lange es dauert.  Wenn das Lesen der Datei lange dauert, muss der Benutzer auf die Ergebnisse der Lotterie, die Wettervorhersage und den Gewinner eines kürzlich durchgeführten Spiels warten. </p><br><p>  Um die Reaktionsfähigkeit der Anwendung aufrechtzuerhalten, verwenden Dart-Autoren ein asynchrones Modell, um Funktionen zu identifizieren, die möglicherweise teure Arbeiten ausführen.  Solche Funktionen geben ihren Wert über <code>futures</code> . </p><br><h2 id="chto-takoe-future">  Was ist die Zukunft? </h2><br><p>  <code>future</code> ist eine Instanz der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Future &lt;T&gt;</a> -Klasse, bei der es sich um eine asynchrone Operation handelt, die ein Ergebnis vom Typ T zurückgibt. Wenn das Ergebnis der Operation nicht verwendet wird, wird der <code>Future&lt;void&gt;</code> Typ durch <code>Future&lt;void&gt;</code> .  Beim Aufrufen einer Funktion, die die <code>future</code> zurückgibt, passieren zwei Dinge: </p><br><ol><li>  Die Funktion steht zur Ausführung in der Warteschlange und gibt ein unvollständiges <code>Future</code> Objekt zurück. </li><li>  Später, wenn der Vorgang abgeschlossen ist, wird die <code>future</code> mit einem Wert oder Fehler beendet. </li></ol><br><p>  Um <code>future</code> Code zu schreiben, haben Sie zwei Möglichkeiten: </p><br><ul><li>  Verwenden Sie <code>async</code> - <code>await</code> </li><li>  Verwenden Sie die <code>Future</code> API </li></ul><br><h2 id="async---await">  Async - warte </h2><br><p>  Die Schlüsselwörter <code>async</code> und <code>await</code> sind Teil der <code>async</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterstützung</a> von Dart.  Mit ihnen können Sie asynchronen Code schreiben, der wie synchroner Code aussieht und die <code>Future</code> API nicht verwendet.  <em>Eine asynchrone Funktion</em> ist eine Funktion mit dem Schlüsselwort <code>async</code> vor ihrem Hauptteil.  Das Schlüsselwort <code>await</code> funktioniert nur in asynchronen Funktionen. </p><br><blockquote>  Hinweis: In Dart 1.x verzögern asynchrone Funktionen sofort die Ausführung.  In Dart 2 werden asynchrone Funktionen nicht sofort angehalten, sondern synchron ausgeführt, bis das erste <code>await</code> oder <code>return</code> . </blockquote><p>  Der folgende Code simuliert das Lesen von Nachrichten aus einer Datei mit <code>async</code> - <code>await</code> .  Öffnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DartPad mit der Anwendung</a> , starten Sie und klicken Sie auf KONSOLE, um das Ergebnis anzuzeigen. </p><br><div class="spoiler">  <b class="spoiler_title">Beispielcode</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Copyright (c) 2013, the Dart project authors. Please see the AUTHORS file // for details. All rights reserved. Use of this source code is governed by a // BSD-style license that can be found in the LICENSE file. import 'dart:async'; Future&lt;void&gt; printDailyNewsDigest() async { var newsDigest = await gatherNewsReports(); print(newsDigest); } main() { printDailyNewsDigest(); printWinningLotteryNumbers(); printWeatherForecast(); printBaseballScore(); } printWinningLotteryNumbers() { print('Winning lotto numbers: [23, 63, 87, 26, 2]'); } printWeatherForecast() { print("Tomorrow's forecast: 70F, sunny."); } printBaseballScore() { print('Baseball score: Red Sox 10, Yankees 0'); } const news = '&lt;gathered news goes here&gt;'; const oneSecond = Duration(seconds: 1); // Imagine that this function is more complex and slow. :) Future&lt;String&gt; gatherNewsReports() =&gt; Future.delayed(oneSecond, () =&gt; news); // Alternatively, you can get news from a server using features // from either dart:io or dart:html. For example: // // import 'dart:html'; // // Future&lt;String&gt; gatherNewsReportsFromServer() =&gt; HttpRequest.getString( // 'https://www.dartlang.org/f/dailyNewsDigest.txt', // );</span></span></code> </pre> </div></div><br><p>  Beachten Sie, dass wir zuerst <code>printDailyNewsDigest()</code> aufrufen, die Nachrichten jedoch zuletzt gedruckt werden, selbst wenn die Datei nur eine Zeile enthält.  Dies liegt daran, dass der Code, der die Datei liest und druckt, asynchron ausgeführt wird. </p><br><p>  In diesem Beispiel <code>printDailyNewsDigest()</code> <code>gatherNewsReports()</code> , das nicht blockiert.  Durch Aufrufen der Methode <code>gatherNewsReports()</code> wird <code>gatherNewsReports()</code> Job in die <code>gatherNewsReports()</code> Ausführung des restlichen Codes wird jedoch nicht gestoppt.  Das Programm zeigt die Lotterienummern, Prognosen und Ergebnisse eines Baseballspiels an.  Das Programm druckt die Nachrichten, nachdem die Sammlung von <code>gatherNewsReports()</code> .  Wenn <code>gatherNewsReports()</code> einige Zeit benötigt, um seine Arbeit abzuschließen, passiert nichts Schlimmes: Der Benutzer kann andere Dinge lesen, bevor der tägliche News Digest gedruckt wird. </p><br><p>  Achten Sie auf Rückgabetypen.  Der Rückgabetyp der Funktion <code>gatherNewsReports()</code> ist <code>Future&lt;String&gt;</code> <code>gatherNewsReports()</code> bedeutet, dass eine <code>future</code> , die mit einem Zeichenfolgenwert endet.  Die Funktion <code>printDailyNewsDigest()</code> , die keinen Wert <code>printDailyNewsDigest()</code> , hat den Rückgabetyp <code>Future&lt;void&gt;</code> . </p><br><p>  Das folgende Diagramm zeigt die Schritte zur Codeausführung. </p><br><p><img src="https://habrastorage.org/webt/cs/ez/9h/csez9hgmhhk6r1fyu8c4jryuydi.png"></p><br><ol><li>  Die Anwendung wird gestartet. </li><li>  Die <code>main()</code> Funktion <code>printDailyNewsDigest()</code> asynchrone Funktion <code>printDailyNewsDigest()</code> und wird synchron ausgeführt. </li><li>  <code>printDailyNewsDigest()</code> verwendet <code>await</code> , um die Funktion <code>gatherNewsReports()</code> aufzurufen, die <code>gatherNewsReports()</code> wird. </li><li>  <code>gatherNewsReports()</code> gibt eine unvollendete <code>future</code> (eine Instanz von <code>Future&lt;String&gt;</code> ). </li><li>  Da <code>printDailyNewsDigest()</code> eine asynchrone Funktion ist und einen Wert erwartet, wird die Ausführung <code>printDailyNewsDigest()</code> und die unvollständige <code>future</code> (in diesem Fall <code>Future&lt;void&gt;</code> ) an die aufrufende Funktion <code>main ()</code> . </li><li>  Die restlichen Ausgabefunktionen werden ausgeführt.  Da sie synchron sind, wird jede Funktion vollständig ausgeführt, bevor zur nächsten übergegangen wird.  Beispielsweise werden alle Lottozahlen vor der Wettervorhersage angezeigt. </li><li>  Nach Abschluss von <code>main()</code> asynchrone Funktionen die Ausführung fortsetzen.  Zuerst erhalten wir die <code>future</code> mit Neuigkeiten über die Fertigstellung von <code>gatherNewsReports()</code> .  Anschließend setzt <code>printDailyNewsDigest()</code> die Ausführung fort und zeigt die Nachrichten an. </li><li>  Am Ende der Ausführung von <code>printDailyNewsDigest()</code> ist die ursprünglich empfangene <code>future</code> und die Anwendung wird beendet. </li></ol><br><p>  Beachten Sie, dass die asynchrone Funktion sofort (synchron) gestartet wird.  Die Funktion unterbricht die Ausführung und gibt eine unvollendete <code>future</code> wenn das erste Auftreten eines der folgenden Ereignisse eintritt: </p><br><ul><li>  Der erste <code>await</code> Ausdruck (nachdem die Funktion aus diesem Ausdruck die unvollständige <code>future</code> ). </li><li>  Jede <code>return</code> in einer Funktion. </li><li>  Das Ende des Funktionskörpers. </li></ul><br><h3 id="obrabotka-oshibok">  Fehlerbehandlung </h3><br><p>  Höchstwahrscheinlich möchten Sie einen Fehler bei der Ausführung der Funktion "abfangen", die die <code>future</code> zurückgibt.  In asynchronen Funktionen können Sie Fehler mit <code>try-catch</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDailyNewsDigest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newsDigest = <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gatherNewsReports</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; print(newsDigest); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-comment"><span class="hljs-comment">// Handle error... } }</span></span></code> </pre> <br><p>  Ein <code>try-catch</code> mit asynchronem Code verhält sich genauso wie mit synchronem Code: Wenn der Code im <code>try</code> Block eine Ausnahme <code>try</code> , wird der Code in <code>catch</code> ausgeführt. </p><br><h3 id="posledovatelnoe-vypolnenie">  Sequentielle Ausführung </h3><br><p>  Sie können mehrere <code>await</code> , um sicherzustellen, dass jede Anweisung abgeschlossen ist, bevor Sie Folgendes ausführen: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Sequential processing using async and await. main() async { await expensiveA(); await expensiveB(); doSomethingWith(await expensiveC()); }</span></span></code> </pre> <br><p>  <code>expensiveB()</code> Funktion <code>expensiveB()</code> wird erst ausgeführt, wenn die Funktion <code>expensiveA()</code> abgeschlossen ist, und so weiter. </p><br><h2 id="future-api">  Zukünftige API </h2><br><p>  Bevor <code>async</code> und <code>await</code> in Dart 1.9 hinzugefügt wurden, mussten Sie die <code>Future</code> API verwenden.  Sie können die Verwendung der <code>Future</code> API immer noch in altem Code und in Code sehen, der mehr Funktionen benötigt als <code>async–await</code> zu bieten hat. </p><br><p>  Verwenden Sie die <code>then()</code> -Methode, um asynchronen Code mithilfe der <code>Future</code> API zu schreiben und den Rückruf zu registrieren.  Dieser Rückruf funktioniert, wenn die <code>future</code> abgeschlossen ist. </p><br><p>  Der folgende Code simuliert das Lesen von Nachrichten aus einer Datei mithilfe der <code>Future</code> API.  Öffnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DartPad mit der Anwendung</a> , starten Sie und klicken Sie auf KONSOLE, um das Ergebnis anzuzeigen. </p><br><div class="spoiler">  <b class="spoiler_title">Beispielcode</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Copyright (c) 2013, the Dart project authors. Please see the AUTHORS file // for details. All rights reserved. Use of this source code is governed by a // BSD-style license that can be found in the LICENSE file. import 'dart:async'; Future&lt;void&gt; printDailyNewsDigest() { final future = gatherNewsReports(); return future.then(print); // You don't *have* to return the future here. // But if you don't, callers can't await it. } main() { printDailyNewsDigest(); printWinningLotteryNumbers(); printWeatherForecast(); printBaseballScore(); } printWinningLotteryNumbers() { print('Winning lotto numbers: [23, 63, 87, 26, 2]'); } printWeatherForecast() { print("Tomorrow's forecast: 70F, sunny."); } printBaseballScore() { print('Baseball score: Red Sox 10, Yankees 0'); } const news = '&lt;gathered news goes here&gt;'; const oneSecond = Duration(seconds: 1); // Imagine that this function is more complex and slow. :) Future&lt;String&gt; gatherNewsReports() =&gt; Future.delayed(oneSecond, () =&gt; news); // Alternatively, you can get news from a server using features // from either dart:io or dart:html. For example: // // import 'dart:html'; // // Future&lt;String&gt; gatherNewsReportsFromServer() =&gt; HttpRequest.getString( // 'https://www.dartlang.org/f/dailyNewsDigest.txt', // );</span></span></code> </pre> </div></div><br><p>  Beachten Sie, dass wir zuerst <code>printDailyNewsDigest()</code> aufrufen, die Nachrichten jedoch zuletzt gedruckt werden, selbst wenn die Datei nur eine Zeile enthält.  Dies liegt daran, dass der Code, der die Datei liest und druckt, asynchron ausgeführt wird. </p><br><p>  Diese Anwendung läuft wie folgt ab: </p><br><ol><li>  Die Anwendung wird gestartet. </li><li>  Die Hauptfunktion ruft <code>printDailyNewsDigest()</code> , das das Ergebnis nicht sofort <code>gatherNewsReports()</code> , sondern zuerst <code>gatherNewsReports()</code> . </li><li>  <code>gatherNewsReports()</code> beginnt mit dem Lesen von Nachrichten und gibt die <code>future</code> . </li><li>  <code>printDailyNewsDigest()</code> verwendet <code>then()</code> , um einen Rückruf zu registrieren, der den am Ende der <code>future</code> erhaltenen Wert als Parameter verwendet.  Der Aufruf <code>then()</code> gibt eine neue <code>future</code> , die mit dem Wert endet, den der Rückruf von <code>then()</code> zurückgibt. </li><li>  Die restlichen Ausgabefunktionen werden ausgeführt.  Da sie synchron sind, wird jede Funktion vollständig ausgeführt, bevor zur nächsten übergegangen wird.  Beispielsweise werden alle Lottozahlen vor der Wettervorhersage angezeigt. </li><li>  Wenn alle Nachrichten empfangen wurden, endet die von der Funktion <code>gatherNewsReports()</code> <code>future</code> mit einer Zeichenfolge, die die gesammelten Nachrichten enthält. </li><li>  Der in <code>then()</code> in <code>printDailyNewsDigest()</code> angegebene Code wird ausgeführt, <code>printDailyNewsDigest()</code> Nachrichten zu <code>printDailyNewsDigest()</code> . </li><li>  Die Anwendung wird heruntergefahren. </li></ol><br><blockquote>  Hinweis: In der Funktion <code>printDailyNewsDigest()</code> entspricht der Code <code>future.then(print)</code> dem folgenden: <code>future.then((newsDigest) =&gt; print(newsDigest))</code> . </blockquote><p>  Außerdem kann der Code in <code>then()</code> geschweifte Klammern verwenden: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDailyNewsDigest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> future = gatherNewsReports(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> future.then((newsDigest) { print(newsDigest); <span class="hljs-comment"><span class="hljs-comment">// Do something else... }); }</span></span></code> </pre> <br><p>  Sie müssen das Rückrufargument in <code>then()</code> angeben, auch wenn <code>future</code> vom Typ <code>Future&lt;void&gt;</code> .  Konventionell wird ein nicht verwendetes Argument durch <code>_</code> (Unterstrich) definiert. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> future = printDailyNewsDigest(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> future.then((_) { <span class="hljs-comment"><span class="hljs-comment">// Code that doesn't use the `_` parameter... print('All reports printed.'); });</span></span></code> </pre> <br><h3 id="obrabotka-oshibok-1">  Fehlerbehandlung </h3><br><p>  Mit der <code>Future</code> API können Sie den Fehler mit <code>catchError()</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDailyNewsDigest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; gatherNewsReports().then(print).catchError(handleError);</code> </pre> <br><p>  Wenn die Nachrichten nicht lesbar sind, wird der obige Code wie folgt ausgeführt: </p><br><ol><li>  <code>future</code> von <code>gatherNewsReports()</code> <code>future</code> schlägt fehl. </li><li>  <code>future</code> von <code>then()</code> <code>future</code> schlägt fehl, <code>print()</code> nicht aufgerufen. </li><li>  Der <code>catchError()</code> in <code>catchError()</code> ( <code>handleError()</code> ) fängt den Fehler ab, die von <code>catchError()</code> <code>future</code> wird <code>catchError()</code> abgeschlossen und der Fehler breitet sich nicht weiter aus. </li></ol><br><blockquote>  Die <code>then()</code> -Kette - <code>catchError()</code> ist ein gängiges Muster bei Verwendung der <code>Future</code> API.  Betrachten Sie dieses Paar als das Äquivalent eines <code>try-catch</code> in der <code>Future</code> API. </blockquote><p>  Wie then () gibt catchError () eine neue <code>future</code> , die mit dem Rückgabewert des Rückrufs endet.  Um in das Thema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einzutauchen</a> , lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Futures und Fehlerbehandlung</a> . </p><br><h3 id="vyzov-neskolkih-funkciy-vozvraschayuschih-future">  Aufruf mehrerer Funktionen, die die <code>future</code> </h3><br><p>  Betrachten wir drei Funktionen: <code>expensiveA()</code> , <code>expensiveB()</code> , <code>expensiveC()</code> , die die <code>future</code> .  Sie können sie nacheinander aufrufen (eine Funktion startet nach Abschluss der vorherigen) oder Sie können sie alle gleichzeitig ausführen und etwas tun, sobald alle Werte zurückgegeben werden.  Die Benutzeroberfläche von Future ist flexibel genug, um beide Anwendungsfälle zu implementieren. </p><br><p>  <strong>Eine Funktionskette ruft mit <code>then()</code></strong> <br>  Wenn die Funktionen, die die <code>future</code> zurückgeben, in der richtigen Reihenfolge ausgeführt werden müssen, verwenden Sie die Kette von <code>then()</code> : </p><br><pre> <code class="java hljs">expensiveA() .then((aValue) =&gt; expensiveB()) .then((bValue) =&gt; expensiveC()) .then((cValue) =&gt; doSomethingWith(cValue));</code> </pre> <br><p>  Das Anhängen von Rückrufen funktioniert ebenfalls, ist jedoch schwieriger zu lesen.  ( <em>Hinweis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://callbackhell.com/</a></em> ) </p><br><p>  <strong>Warten auf den Abschluss mehrerer <code>futures</code> mit <code>Future.wait()</code></strong> <br>  Wenn die Ausführungsreihenfolge der Funktionen nicht wichtig ist, können Sie <code>Future.wait()</code> .  Wenn Sie die <code>futures</code> Liste für Parameter für die Future.wait () -Funktion angeben, wird sofort die <code>future</code> .  Diese <code>future</code> endet erst, wenn alle angegebenen <code>futures</code> .  Diese <code>future</code> endet mit einer Liste der Ergebnisse aller angegebenen <code>futures</code> . </p><br><pre> <code class="java hljs">Future.wait([expensiveA(), expensiveB(), expensiveC()]) .then((List responses) =&gt; chooseBestResponse(responses, moreInfo)) .catchError(handleError);</code> </pre> <br><p>  Wenn ein Aufruf einer der Funktionen fehlschlägt, schlägt auch die von <code>Future.wait()</code> <code>future</code> fehl.  Verwenden Sie <code>catchError()</code> , um diesen Fehler <code>catchError()</code> . </p><br><hr><br><h2 id="chto-esche-pochitat">  Was noch zu lesen? </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dart 2. Asynchrone Programmierung: Datenströme</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442282/">https://habr.com/ru/post/de442282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442270/index.html">5 Fehler, die beim Erstellen von 3D-Modellen für den 3D-Druck vermieden werden sollten</a></li>
<li><a href="../de442272/index.html">Go + = Paketversionierung</a></li>
<li><a href="../de442274/index.html">Dart 2. Asynchrone Programmierung: Datenströme</a></li>
<li><a href="../de442278/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 6</a></li>
<li><a href="../de442280/index.html">Maschinelles Lernen in Dodo. So starten Sie eine neue Richtung, wenn Sie Entwickler sind</a></li>
<li><a href="../de442284/index.html">NoVerify: Der Linter für PHP vom VKontakte-Team ist jetzt gemeinfrei</a></li>
<li><a href="../de442286/index.html">Russische Augenärzte sprachen über bionisches Sehen. Die neue mobile Anwendung demonstriert die Arbeit von Cyber</a></li>
<li><a href="../de442288/index.html">Strahlung: Quellen</a></li>
<li><a href="../de442290/index.html">ST-Link V2.1 aus chinesischem ST-Link V2 erstellen</a></li>
<li><a href="../de442292/index.html">Sberseasons-Praktikum: Python, UX / UI, Daten und vieles mehr für Studenten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>