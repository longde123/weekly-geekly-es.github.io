<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úäüèª ‚å®Ô∏è üâë WAL dans PostgreSQL: 4. Configuration du journal üë®üèæ‚Äçüç≥ ü§æüèæ üíÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons donc pris connaissance du p√©riph√©rique du cache tampon et, √† l'aide de son exemple, nous avons r√©alis√© que lorsque le contenu de la RAM dis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL dans PostgreSQL: 4. Configuration du journal</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/461523/">  Nous avons donc pris connaissance du p√©riph√©rique du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cache tampon</a> et, √† l'aide de son exemple, nous avons r√©alis√© que lorsque le contenu de la RAM disparaissait en cas de panne, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">journal de pr√©-enregistrement est</a> n√©cessaire pour la r√©cup√©ration.  La taille des fichiers journaux requis et le temps de r√©cup√©ration sont limit√©s en raison d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">point de contr√¥le</a> ex√©cut√© p√©riodiquement. <br><br>  Dans les articles pr√©c√©dents, nous avons d√©j√† examin√© un assez grand nombre de param√®tres importants, d'une mani√®re ou d'une autre li√©s √† la revue.  Dans cet article (le dernier de cette s√©rie), nous examinerons les probl√®mes de r√©glage qui n'ont pas encore √©t√© abord√©s: les niveaux de journalisation et leur objectif, ainsi que la fiabilit√© et les performances de la journalisation. <br><br><h1>  Niveaux de journalisation </h1><br>  Le principal objectif du journal de pr√©-enregistrement est de fournir la possibilit√© de r√©cup√©rer apr√®s une d√©faillance.  Mais, si vous devez encore tenir un journal, il peut √™tre adapt√© √† d'autres t√¢ches, en y ajoutant une certaine quantit√© d'informations suppl√©mentaires.  Il existe plusieurs niveaux de journalisation.  Ils sont d√©finis par le param√®tre <em>wal_level</em> et sont organis√©s de sorte que le journal de chaque niveau suivant comprenne tout ce qui tombe dans le journal du niveau pr√©c√©dent, plus quelque chose de nouveau. <br><a name="habracut"></a><br><h2>  Minimal </h2><br>  Le niveau minimum possible est d√©fini par la valeur <em>wal_level</em> = minimal et garantit uniquement la r√©cup√©ration apr√®s une panne.  Pour √©conomiser de l'espace, les op√©rations li√©es au traitement de masse des donn√©es (telles que CREATE TABLE AS SELECT ou CREATE INDEX) ne sont pas enregistr√©es.  Au lieu de cela, les donn√©es n√©cessaires sont imm√©diatement √©crites sur le disque et un nouvel objet est ajout√© au r√©pertoire syst√®me et devient visible lorsque la transaction est valid√©e.  Si une d√©faillance se produit pendant l'op√©ration, les donn√©es d√©j√† enregistr√©es restent invisibles et ne violent pas la coh√©rence.  Si l'√©chec se produit une fois l'op√©ration termin√©e, tout le n√©cessaire est d√©j√† arriv√© sur le disque et n'a pas besoin d'√™tre enregistr√©. <br><br>  Voyons voir.  Tout d'abord, d√©finissez le niveau requis (pour cela, vous devrez √©galement modifier un autre param√®tre - <em>max_wal_senders</em> ). <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> wal_level = minimal; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_wal_senders = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Notez que la modification du niveau n√©cessite un red√©marrage du serveur. <br><br>  Rappelez-vous la position actuelle dans le journal: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353927BC (1 row)</code> </pre><br>  Cr√©ons maintenant la table (CREATE TABLE AS SELECT) et r√©√©crivons la position dans le journal.  La quantit√© de donn√©es s√©lectionn√©es par l'instruction SELECT n'a pas d'importance dans ce cas, nous nous limiterons donc √† une seule ligne. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> n; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353A7DFC (1 row)</code> </pre><br>  Avec l'utilitaire pg_waldump familier, regardons les entr√©es du journal. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/353927BC -e 0/353A7DFC</code> </pre><br>  Bien s√ªr, certains d√©tails peuvent diff√©rer d'un lancement √† l'autre, mais dans ce cas, c'est ce qui s'est produit.  L'entr√©e du gestionnaire Heap2 fait r√©f√©rence au nettoyage, il s'agit ici d'un nettoyage en ligne de l'une des tables du catalogue syst√®me (les objets syst√®me se distinguent facilement √† l'≈ìil nu par le nombre ¬´court¬ª en rel): <br><br><pre> <code class="plaintext hljs">rmgr: Heap2 len (rec/tot): 59/ 7587, tx: 0, lsn: 0/353927BC, prev 0/35392788, desc: CLEAN remxid 101126, blkref #0: rel 1663/16386/1247 blk 8 FPW</code> </pre><br>  Ensuite, il y a un enregistrement sur l'obtention du prochain OID pour la table que nous allons cr√©er: <br><br><pre> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 30/ 30, tx: 0, lsn: 0/35394574, prev 0/353927BC, desc: NEXTOID 82295</code> </pre><br>  Maintenant, la cr√©ation r√©elle de la table: <br><br><pre> <code class="plaintext hljs">rmgr: Storage len (rec/tot): 42/ 42, tx: 0, lsn: 0/35394594, prev 0/35394574, desc: CREATE base/16386/74103</code> </pre><br>  Cependant, l'insertion de donn√©es dans une table n'est pas enregistr√©e.  Ensuite, il existe de nombreuses entr√©es sur l'insertion de lignes dans diff√©rentes tables et index - ce PostgreSQL enregistre la table cr√©√©e dans le r√©pertoire syst√®me (je la donne sous forme abr√©g√©e): <br><br><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 203/ 203, tx: 101127, lsn: 0/353945C0, prev 0/35394594, desc: INSERT off 71, blkref #0: rel 1663/16386/1247 blk 8 rmgr: Btree len (rec/tot): 53/ 685, tx: 101127, lsn: 0/3539468C, prev 0/353945C0, desc: INSERT_LEAF off 37, blkref #0: rel 1663/16386/2703 blk 2 FPW ... rmgr: Btree len (rec/tot): 53/ 2393, tx: 101127, lsn: 0/353A747C, prev 0/353A6788, desc: INSERT_LEAF off 10, blkref #0: rel 1664/0/1233 blk 1 FPW</code> </pre><br>  Et enfin, la fixation des transactions: <br><br><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 34/ 34, tx: 101127, lsn: 0/353A7DD8, prev 0/353A747C, desc: COMMIT 2019-07-23 18:59:34.923124 MSK</code> </pre><br><h2>  R√©plique </h2><br>  Lorsque nous restaurons le syst√®me √† partir de la sauvegarde, nous partons d'un √©tat du syst√®me de fichiers et amenons progressivement les donn√©es au point de r√©cup√©ration, en lisant les entr√©es de journal archiv√©es.  Le nombre de ces enregistrements peut √™tre tr√®s important (par exemple, plusieurs jours), c'est-√†-dire que la p√©riode de r√©cup√©ration couvrira non pas un point de contr√¥le, mais plusieurs.  Par cons√©quent, il est clair que le niveau minimum du journal n'est pas suffisant - si une op√©ration n'est pas enregistr√©e, nous ne saurons tout simplement pas qu'elle doit √™tre r√©p√©t√©e.  Pour restaurer √† partir d'une sauvegarde, <em>toutes les</em> op√©rations doivent √™tre enregistr√©es. <br><br>  Il en va de m√™me pour la r√©plication - tout ce qui n'est pas enregistr√© ne sera pas transf√©r√© vers la r√©plique et ne sera pas reproduit.  Mais, si nous voulons ex√©cuter des requ√™tes sur une r√©plique, c'est toujours compliqu√©. <br><br>  Tout d'abord, nous avons besoin d'informations sur les verrous exclusifs qui se produisent sur le serveur principal, car ils peuvent entrer en conflit avec les demandes sur la r√©plique.  Ces verrous sont enregistr√©s et appliqu√©s sur la r√©plique (au nom du processus de d√©marrage). <br><br>  Deuxi√®mement, vous devez pouvoir cr√©er <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des instantan√©s de donn√©es</a> , et pour cela, comme nous nous en souvenons, des informations sur les transactions en cours sont n√©cessaires.  Dans le cas d'une r√©plique, nous parlons non seulement de transactions locales, mais √©galement de transactions sur le serveur principal.  La seule fa√ßon de transmettre ces informations est de les √©crire p√©riodiquement dans le journal (cela se produit toutes les 15 secondes). <br><br>  Le niveau de journalisation, qui garantit √† la fois la possibilit√© de r√©cup√©rer √† partir d'une sauvegarde et la possibilit√© de r√©plication physique, est d√©fini par la valeur wal_level = <em>replica</em> .  (Avant la version 9.6, il y avait deux niveaux distincts d'archive et hot_standby, mais ensuite ils √©taient combin√©s en un seul commun.) <br><br>  √Ä partir de PostgreSQL 10, c'est ce niveau qui est d√©fini par d√©faut (et avant cela, il √©tait minimal).  Par cons√©quent, il suffit de r√©initialiser les param√®tres aux valeurs par d√©faut: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RESET</span></span> wal_level; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RESET</span></span> max_wal_senders;</code> </pre><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Nous supprimons la table et r√©p√©tons exactement la m√™me s√©quence d'actions que la derni√®re fois: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353AF21C (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> n; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353BE51C (1 row)</code> </pre><br>  V√©rifiez maintenant les entr√©es de journal. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/353AF21C -e 0/353BE51C</code> </pre><br>  Nettoyage, obtention de l'OID, cr√©ation d'une table et enregistrement dans le r√©pertoire syst√®me - pour l'instant, tout est comme √ßa: <br><br><pre> <code class="plaintext hljs">rmgr: Heap2 len (rec/tot): 58/ 58, tx: 0, lsn: 0/353AF21C, prev 0/353AF044, desc: CLEAN remxid 101128, blkref #0: rel 1663/16386/1247 blk 8 rmgr: XLOG len (rec/tot): 30/ 30, tx: 0, lsn: 0/353AF258, prev 0/353AF21C, desc: NEXTOID 82298 rmgr: Storage len (rec/tot): 42/ 42, tx: 0, lsn: 0/353AF278, prev 0/353AF258, desc: CREATE base/16386/74106 rmgr: Heap len (rec/tot): 203/ 203, tx: 101129, lsn: 0/353AF2A4, prev 0/353AF278, desc: INSERT off 73, blkref #0: rel 1663/16386/1247 blk 8 rmgr: Btree len (rec/tot): 53/ 717, tx: 101129, lsn: 0/353AF370, prev 0/353AF2A4, ‚Ä¶ rmgr: Btree len (rec/tot): 53/ 2413, tx: 101129, lsn: 0/353BD954, prev 0/353BCC44, desc: INSERT_LEAF off 10, blkref #0: rel 1664/0/1233 blk 1 FPW</code> </pre><br>  Mais quelque chose de nouveau.  L'enregistrement d'un verrou exclusif li√© au gestionnaire de secours - dans ce cas, il bloque le num√©ro de transaction (pourquoi est-il n√©cessaire, nous parlerons en d√©tail dans la prochaine s√©rie d'articles): <br><br><pre> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 42/ 42, tx: 101129, lsn: 0/353BE2D8, prev 0/353BD954, desc: LOCK xid 101129 db 16386 rel 74106</code> </pre><br>  Et ceci est un enregistrement sur l'insertion de lignes dans notre table (comparez le num√©ro de fichier rel avec celui indiqu√© ci-dessus dans l'enregistrement CREATE): <br><br><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 59/ 59, tx: 101129, lsn: 0/353BE304, prev 0/353BE2D8, desc: INSERT+INIT off 1, blkref #0: rel 1663/16386/74106 blk 0</code> </pre><br>  Enregistrement de validation: <br><br><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 421/ 421, tx: 101129, lsn: 0/353BE340, prev 0/353BE304, desc: COMMIT 2019-07-23 18:59:37.870333 MSK; inval msgs: catcache 74 catcache 73 catcache 74 catcache 73 catcache 50 catcache 49 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 snapshot 2608 relcache 74106 snapshot 1214</code> </pre><br>  Et un autre enregistrement, qui se produit p√©riodiquement et n'est pas li√© √† la transaction termin√©e, fait r√©f√©rence au gestionnaire de secours et rend compte des transactions en cours: <br><br><pre> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 50/ 50, tx: 0, lsn: 0/353BE4E8, prev 0/353BE340, desc: RUNNING_XACTS nextXid 101130 latestCompletedXid 101129 oldestRunningXid 101130</code> </pre><br><h2>  Logique </h2><br>  Enfin, le dernier niveau est fix√© par la valeur du param√®tre <em>wal_level</em> = logique et offre la possibilit√© de d√©codage logique et de r√©plication logique.  Il doit √™tre activ√© sur le serveur de publication. <br><br>  Du point de vue des entr√©es de journal, ce niveau n'est pratiquement pas diff√©rent des r√©pliques - les enregistrements li√©s aux origines de r√©plication et les entr√©es logiques arbitraires qui peuvent √™tre ajout√©es au journal des applications sont ajout√©s.  Fondamentalement, le d√©codage logique d√©pend des informations sur les transactions en cours, car vous devez cr√©er un instantan√© des donn√©es pour suivre les modifications dans le catalogue syst√®me. <br><br>  Maintenant, nous n'entrerons pas dans les d√©tails du fonctionnement de la sauvegarde et de la r√©plication - c'est un gros sujet pour une s√©rie d'articles s√©par√©e. <br><br><h1>  Fiabilit√© record </h1><br>  Il est clair que le m√©canisme de journalisation doit √™tre fiable et fournir des garanties de possibilit√© de r√©cup√©ration dans toutes les situations (sans rapport, bien s√ªr, avec des dommages au support de donn√©es).  La fiabilit√© est influenc√©e par de nombreux facteurs, dont nous prendrons en compte la mise en cache, la corruption des donn√©es et l'atomicit√© des enregistrements. <br><br><h2>  Mise en cache </h2><br>  Il existe de nombreux caches sur le chemin de donn√©es vers un stockage non volatile (tel qu'un disque dur). <br><br>  Lorsqu'un programme (n'importe lequel, mais dans notre cas PostgreSQL) demande au syst√®me d'exploitation d'√©crire quelque chose sur le disque, le syst√®me d'exploitation transf√®re les donn√©es vers son cache en RAM.  L'enregistrement r√©el se produit de mani√®re asynchrone, en fonction des param√®tres du planificateur d'E / S du syst√®me d'exploitation. <br><br>  Lorsque le syst√®me d'exploitation d√©cide d'√©crire des donn√©es, elles tombent dans le cache du lecteur (disque dur).  L'√©lectronique du lecteur peut √©galement retarder l'enregistrement, par exemple, la collecte de donn√©es dans des groupes qui sont plus rentables √† enregistrer en m√™me temps.  Et si un contr√¥leur RAID est utilis√©, un autre niveau de mise en cache appara√Æt entre le syst√®me d'exploitation et le lecteur. <br><br>  Ainsi, si vous ne prenez pas de mesures sp√©ciales, il est difficile de savoir quand les donn√©es seront r√©ellement stock√©es en toute s√©curit√©.  Ce n'est g√©n√©ralement pas important, mais il existe des endroits critiques o√π PostgreSQL doit √™tre s√ªr que les donn√©es sont √©crites en toute s√©curit√©.  Tout d'abord, il s'agit de la journalisation (si l'entr√©e de journal n'a pas atteint le disque, elle dispara√Ætra avec le reste du contenu de la RAM) et un point de contr√¥le (il faut √™tre s√ªr que les pages sales sont bien √©crites sur le disque).  Mais il y a d'autres situations, par exemple, l'ex√©cution d'op√©rations non journalis√©es au niveau minimum, etc. <br><br>  Le syst√®me d'exploitation fournit des outils qui doivent garantir l'√©criture imm√©diate des donn√©es dans une m√©moire non volatile.  Il existe plusieurs options, mais elles se r√©sument √† deux principales: soit une commande de synchronisation est donn√©e apr√®s l'enregistrement (fsync, fdatasync), soit lors de l'ouverture d'un fichier (ou de l'√©criture), un indicateur sp√©cial est indiqu√© pour la synchronisation ou m√™me l'enregistrement direct, en contournant le cache du syst√®me d'exploitation. <br><br>  En ce qui concerne le journal, l'utilitaire pg_test_fsync vous permet de choisir la m√©thode la plus appropri√©e pour un syst√®me d'exploitation et un syst√®me de fichiers sp√©cifiques, et il est install√© dans le param√®tre de configuration <em>wal_sync_method</em> .  Les fichiers normaux sont toujours synchronis√©s √† l'aide de fsync. <br><br>  Le point subtil est que lors du choix d'une m√©thode, les caract√©ristiques de l'√©quipement doivent √™tre prises en compte.  Par exemple, si vous utilisez un contr√¥leur pris en charge par une batterie de secours, il n'y a aucune raison de ne pas utiliser son cache, car la batterie enregistre les donn√©es en cas de panne de courant. <br><br><blockquote>  La documentation contient de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nombreux d√©tails</a> √† ce sujet. <br></blockquote><br>  Dans tous les cas, la synchronisation est co√ªteuse et n'a pas lieu plus souvent qu'absolument n√©cessaire (nous reviendrons sur ce probl√®me un peu plus bas lorsque nous parlerons de performances). <br><br>  De mani√®re g√©n√©rale, la synchronisation peut √™tre d√©sactiv√©e (le param√®tre <em>fsync en</em> est responsable), mais dans ce cas, vous devez oublier la fiabilit√© du stockage.  En d√©sactivant <em>fsync</em> , vous acceptez que les donn√©es puissent √™tre irr√©m√©diablement perdues √† tout moment.  La seule option raisonnable pour utiliser cette option est probablement d'augmenter temporairement la productivit√©, lorsque les donn√©es peuvent √™tre facilement restaur√©es √† partir d'une autre source (par exemple, lors de la migration initiale). <br><br><h2>  Corruption des donn√©es </h2><br>  L'√©quipement est imparfait et les donn√©es peuvent √™tre endommag√©es sur le support lors de la transmission de donn√©es via des c√¢bles d'interface, etc. Certaines de ces erreurs sont trait√©es au niveau mat√©riel, mais d'autres ne le sont pas. <br><br>  Afin de d√©tecter le probl√®me √† temps, les √©critures de journal sont toujours fournies avec des sommes de contr√¥le. <br><br>  Les pages de donn√©es peuvent √©galement √™tre prot√©g√©es par des sommes de contr√¥le.  Pour l'instant, cela ne peut √™tre fait que lorsque le cluster est initialis√©, mais dans PostgreSQL 12, il sera possible de les activer et de les d√©sactiver √† l'aide de l'utilitaire pg_checksums (mais pas encore √† la vol√©e, mais uniquement lorsque le serveur est arr√™t√©). <br><br>  Dans un environnement de production, des sommes de contr√¥le doivent √™tre incluses, malgr√© les frais g√©n√©raux de leur calcul et de leur contr√¥le.  Cela r√©duit la probabilit√© qu'une d√©faillance ne soit pas d√©tect√©e √† temps. <br><br><blockquote>  R√©duit, mais n'√©limine pas. <br>  Tout d'abord, les sommes de contr√¥le ne sont v√©rifi√©es que lors de l'acc√®s √† la page - par cons√©quent, les dommages peuvent passer inaper√ßus jusqu'√† ce qu'ils atteignent toutes les sauvegardes.  C'est pourquoi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pg_probackup</a> v√©rifie les sommes de contr√¥le de toutes les pages du cluster pendant la sauvegarde. <br>  Deuxi√®mement, une page remplie de z√©ros est consid√©r√©e comme correcte - si le syst√®me de fichiers "annule" par erreur le fichier, cela peut passer inaper√ßu. <br>  Troisi√®mement, les sommes de contr√¥le ne prot√®gent que la couche principale des fichiers de donn√©es.  Les couches restantes et les autres fichiers (par exemple, les √©tats des transactions XACT) ne sont prot√©g√©s par rien. <br>  H√©las. <br></blockquote><br>  Voyons comment cela fonctionne.  Tout d'abord, assurez-vous que les sommes de contr√¥le sont activ√©es (gardez √† l'esprit que ce n'est pas le cas lors de l'installation d'un paquet sur des syst√®mes de type Debian): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> data_checksums;</code> </pre><pre> <code class="plaintext hljs"> data_checksums ---------------- on (1 row)</code> </pre><br>  Le param√®tre <em>data_checksums</em> est en lecture seule. <br><br>  Voici le fichier dans lequel se trouve notre table: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'wallevel'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/16386/24890 (1 row)</code> </pre><br>  Arr√™tez le serveur et modifiez quelques octets dans la page z√©ro, par exemple, supprimez la derni√®re entr√©e de journal de l'en-t√™te LSN. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop</code> </pre><br><pre> <code class="plaintext hljs">postgres$ dd if=/dev/zero of=/var/lib/postgresql/11/main/base/16386/24890 oflag=dsync conv=notrunc bs=1 count=8</code> </pre><pre> <code class="plaintext hljs">8+0 records in 8+0 records out 8 bytes copied, 0,0083022 s, 1,0 kB/s</code> </pre><br>  En principe, le serveur n'a pas pu √™tre arr√™t√©.  Il suffit que la page ait √©t√© √©crite sur le disque et expuls√©e du cache (sinon le serveur fonctionnera avec la page du cache).  Mais un tel sc√©nario est plus difficile √† reproduire. <br><br>  Maintenant, nous d√©marrons le serveur et essayons de lire le tableau. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> wallevel;</code> </pre><pre> <code class="plaintext hljs">WARNING: page verification failed, calculated checksum 23222 but expected 50884 ERROR: invalid page in block 0 of relation base/16386/24890</code> </pre><br>  Mais que faire si les donn√©es ne peuvent pas √™tre restaur√©es √† partir de la sauvegarde?  Le param√®tre <em>ignore_checksum_failure vous</em> permet d'essayer de lire le tableau, naturellement avec le risque d'obtenir des donn√©es d√©form√©es. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ignore_checksum_failure = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> wallevel;</code> </pre><pre> <code class="plaintext hljs">WARNING: page verification failed, calculated checksum 23222 but expected 50884 n --- 1 (1 row)</code> </pre><br>  Bien s√ªr, dans ce cas, tout se passe bien, car nous avons foir√© uniquement le titre de la page, et non les donn√©es elles-m√™mes. <br><br>  Et encore une chose.  Lorsque les sommes de contr√¥le sont activ√©es, des bits d'invites sont √©crits dans le journal (nous les avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">examin√©s</a> plus t√¥t), car une modification de n'importe quel bit, m√™me non essentiel, entra√Æne √©galement une modification de la somme de contr√¥le.  Lorsque les sommes de contr√¥le sont d√©sactiv√©es, le param√®tre <em>wal_log_hints</em> est responsable de l'√©criture des bits de conseil dans le <em>journal</em> . <br><br>  Les modifications apport√©es aux bits de conseil sont toujours enregistr√©es sous la forme d'une <em>image pleine page</em> (FPI, image pleine page), ce qui augmente la taille du journal dans l'ordre.  Dans ce cas, il est logique d'activer la compression d'images compl√®tes √† l'aide du param√®tre <em>wal_compression</em> (ce param√®tre est apparu dans la version 9.5).  Ci-dessous, nous examinons des chiffres sp√©cifiques. <br><br><h2>  Record d'atomicit√© </h2><br>  Et enfin, il y a le probl√®me de l'atomicit√© du disque.  Une page de base de donn√©es prend au moins 8 Ko (elle peut √™tre de 16 ou 32 Ko) et, √† un faible niveau, l'enregistrement se produit dans des blocs g√©n√©ralement plus petits (g√©n√©ralement 512 octets ou 4 Ko).  Par cons√©quent, en cas de panne de courant, la page de donn√©es peut √™tre partiellement enregistr√©e.  Il est clair que pendant la r√©cup√©ration, cela n'a aucun sens d'appliquer des entr√©es de journal ordinaires √† une telle page. <br><br>  Pour la protection, PostgreSQL vous permet d'√©crire dans le journal l' <em>image compl√®te de la page</em> lors de sa premi√®re modification apr√®s le d√©but du point de contr√¥le (la m√™me image est enregistr√©e lorsque les bits de l'info-bulle changent).  Le param√®tre <em>full_page_writes contr√¥le cela</em> et il est activ√© par d√©faut. <br><br>  Si une image de page est rencontr√©e lors de la restauration dans un journal, elle est inconditionnellement (sans v√©rification LSN) √©crite sur le disque: il y a plus de confiance en elle, car, comme tout enregistrement de journal, elle est prot√©g√©e par une somme de contr√¥le.  Et des entr√©es de journal d√©j√† r√©guli√®res sont appliqu√©es √† cette image correcte garantie. <br><br>  Bien que PostgreSQL exclue l'espace non allou√© de l'image pleine page (nous avons pr√©c√©demment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">examin√©</a> la structure des blocs), le volume des entr√©es de journal g√©n√©r√©es augmente consid√©rablement.  Comme d√©j√† mentionn√©, la situation peut √™tre am√©lior√©e en compressant les images compl√®tes (param√®tre <em>wal_compression</em> ). <br><br>  Afin de ressentir en quelque sorte le changement de la taille du journal, nous allons mener une exp√©rience simple en utilisant l'utilitaire pgbench.  Initialisons: <br><br><pre> <code class="plaintext hljs">student$ pgbench -i test</code> </pre><pre> <code class="plaintext hljs">dropping old tables... creating tables... generating data... 100000 of 100000 tuples (100%) done (elapsed 0.15 s, remaining 0.00 s) vacuuming... creating primary keys... done.</code> </pre><br>  L' <em>option full_page_writes est</em> activ√©e: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> full_page_writes;</code> </pre><pre> <code class="plaintext hljs"> full_page_writes ------------------ on (1 row)</code> </pre><br>  Ex√©cutez le point d'arr√™t et ex√©cutez imm√©diatement le test pendant 30 secondes. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/38E04A08 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 26851 latency average = 1.117 ms tps = 895.006720 (including connections establishing) tps = 895.095229 (excluding connections establishing)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3A69C478 (1 row)</code> </pre><br>  Taille du journal: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3A69C478'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/38E04A08'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 25 MB (1 row)</code> </pre><br>  D√©sactivez maintenant le param√®tre full_page_writes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> full_page_writes = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Et r√©p√©tez l'exp√©rience. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3A69C530 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 27234 latency average = 1.102 ms tps = 907.783080 (including connections establishing) tps = 907.895326 (excluding connections establishing)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3BE87658 (1 row)</code> </pre><br>  Taille du journal: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3BE87658'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/3A69C530'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 24 MB (1 row)</code> </pre><br>  Oui, la taille a diminu√©, mais pas du tout aussi importante qu'on pourrait s'y attendre. <br><br>  La raison en est que le cluster est initialis√© avec des sommes de contr√¥le dans les pages de donn√©es, et que vous devez donc toujours √©crire des images pleine page dans le journal lorsque vous modifiez les bits de l'info-bulle.  Ces donn√©es (dans notre cas) repr√©sentent environ la moiti√© du volume total, ce qui peut √™tre vu en regardant les statistiques: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump --stats -p /var/lib/postgresql/11/main/pg_wal -s 0/3A69C530 -e 0/3BE87658</code> </pre><pre> <code class="plaintext hljs">Type N (%) Record size (%) FPI size (%) ---- - --- ----------- --- -------- --- XLOG 1721 ( 1,03) 84329 ( 0,77) 13916104 (100,00) Transaction 27235 ( 16,32) 926070 ( 8,46) 0 ( 0,00) Storage 1 ( 0,00) 42 ( 0,00) 0 ( 0,00) CLOG 1 ( 0,00) 30 ( 0,00) 0 ( 0,00) Standby 4 ( 0,00) 240 ( 0,00) 0 ( 0,00) Heap2 27522 ( 16,49) 1726352 ( 15,76) 0 ( 0,00) Heap 109691 ( 65,71) 8169121 ( 74,59) 0 ( 0,00) Btree 756 ( 0,45) 45380 ( 0,41) 0 ( 0,00) -------- -------- -------- Total 166931 10951564 [44,04%] 13916104 [55,96%]</code> </pre><br>  Pour des raisons de compacit√©, j'ai supprim√© les lignes nulles du tableau.  Faites attention √† la ligne totale (Total) et comparez la taille des images compl√®tes (taille FPI) avec la taille des enregistrements ordinaires (taille d'enregistrement). <br><br>  Le param√®tre <em>full_page_writes</em> ne peut √™tre d√©sactiv√© que si le syst√®me de fichiers et le mat√©riel utilis√©s par eux-m√™mes garantissent l'enregistrement atomique.  Mais, comme nous pouvons le voir, il n'y a pas de grande raison √† cela (en supposant que les sommes de contr√¥le sont incluses). <br><br>  Voyons maintenant en quoi la compression est utile. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> full_page_writes = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> wal_compression = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  R√©p√©tez la m√™me exp√©rience. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3BE87710 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 26833 latency average = 1.118 ms tps = 894.405027 (including connections establishing) tps = 894.516845 (excluding connections establishing)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3CBD3EA8 (1 row)</code> </pre><br>  Taille du journal: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3CBD3EA8'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/3BE87710'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 13 MB (1 row)</code> </pre><br>  Conclusion: en pr√©sence d'un grand nombre d'images pleine page (en raison de sommes de contr√¥le ou de <em>full_page_writes</em> , c'est-√†-dire presque toujours), il est tr√®s probable d'utiliser la compression malgr√© le fait que cela charge le processeur. <br><br><h1>  Performances </h1><br>  Pendant le fonctionnement normal du serveur, un enregistrement s√©quentiel continu des fichiers journaux se produit.  Puisqu'il n'y a pas d'acc√®s al√©atoire, les disques durs ordinaires font √©galement face √† cette t√¢che.  Mais cette nature de la charge est consid√©rablement diff√©rente de la fa√ßon dont les fichiers de donn√©es sont accessibles. <br><br>  Par cons√©quent, il est g√©n√©ralement avantageux de placer le journal sur un disque physique (ou baie de disques) distinct mont√© sur le syst√®me de fichiers du serveur.  Au lieu du r√©pertoire $ PGDATA / pg_wal, vous devez cr√©er un lien symbolique vers le r√©pertoire correspondant. <br><br><blockquote>  Il existe quelques situations dans lesquelles les fichiers journaux doivent non seulement √™tre √©crits, mais √©galement lus.  Le premier est un cas compr√©hensible de r√©cup√©ration apr√®s une d√©faillance.  Le second est moins trivial.  Il se produit si la r√©plication en continu est utilis√©e et que la r√©plique ne parvient pas √† recevoir des entr√©es de journal alors qu'elles sont encore dans les tampons de RAM du serveur principal.  Ensuite, le processus walsender doit lire les donn√©es n√©cessaires sur le disque.  Nous en parlerons plus en d√©tail lorsque nous arriverons √† la r√©plication. <br></blockquote><br>  La journalisation a lieu dans l'un des deux modes: <br><br><ul><li>  synchrone - lorsqu'une transaction est valid√©e, la poursuite du travail est impossible jusqu'√† ce que toutes les entr√©es de journal concernant cette transaction soient sur le disque; </li><li>  asynchrone - la transaction se termine imm√©diatement et le journal est √©crit en arri√®re-plan. </li></ul><br>  Le mode synchrone est d√©termin√© par le param√®tre <em>synchronous_commit</em> et est activ√© par d√©faut. <br><br>  √âtant donn√© que la synchronisation est associ√©e √† des E / S r√©elles (c'est-√†-dire lentes), il est avantageux de l'ex√©cuter le moins possible.  Pour ce faire, le processus de maintenance qui termine la transaction et √©crit le journal prend une courte pause, d√©termin√©e par le param√®tre <em>commit_delay</em> .       ,       <em>commit_siblings</em>  .     ,                 .    ,     ,  -    . <br><br>    <em>commit_siblings</em> = 5,  <em>commit_delay</em> = 0,      .  <em>commit_delay</em>     ,     OLTP-. <br><br>          LSN (  ,       ).     . <br><br>      ( D   ACID) ‚Äî   ,            .     ,       ( COMMIT      )    . <br><br>    ,  <em>synchronous_commit</em> = off ( local). <br><br>         wal writer,      (   <em>wal_writer_delay</em> = 200ms  ). <br><br>    ,  ,         WAL.  ,    , , ,     . (,    :  ,    ,         .) <br><br>       ,     (  )   ‚Äî    ? <br><br>     ,            ,      . <br><br>     ‚Äî     .   :       ,        3 √ó <em>wal_writer_delay</em>  (        ). <br><br>   ‚Äî    ‚Äî    . <br><br>  :      ( <em>fsync</em> = off),       .         , , ,       . <br><br>  <em>synchronous_commit</em>      .    ,     . ,      ,         . <br><br>       .           ,    WAL.         ,        ,        . <br><br>   -   ,     ,       pgbench. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> synchronous_commit = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 45439 latency average = 0.660 ms tps = 1514.561710 (including connections establishing) tps = 1514.710558 (excluding connections establishing)</code> </pre><br>       900    (tps),   ‚Äî 1500. ,         ,  ,         . <br><br>         .  -    ,       .  Merci √† tous! <br><br>         ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461523/">https://habr.com/ru/post/fr461523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461507/index.html">Pourquoi avons-nous d√©cid√© de lancer l'acc√©l√©rateur d'entreprise Gazprom Neft StartupDrive, et qui l'a d√©j√† adopt√©</a></li>
<li><a href="../fr461509/index.html">Assistants de voyage: une s√©lection de gadgets et accessoires</a></li>
<li><a href="../fr461511/index.html">Gestion des d√©pendances Python: une comparaison des approches</a></li>
<li><a href="../fr461517/index.html">Meilleurs algorithmes de copier-coller pour C et C ++. Haiku OS Cookbook</a></li>
<li><a href="../fr461519/index.html">Meilleurs algorithmes de copier-coller pour C et C ++. Collection de recettes Haiku OS</a></li>
<li><a href="../fr461525/index.html">Comment j'ai fait un curseur vraiment adaptatif (carrousel)</a></li>
<li><a href="../fr461527/index.html">L√©vitation acoustique bricolage</a></li>
<li><a href="../fr461531/index.html">Tic Tac Toe, Partie 6: Flacon et c√©leri / RabbitMQ</a></li>
<li><a href="../fr461533/index.html">Visualisation du sommeil de la premi√®re ann√©e de l'enfant sur les motifs de la couverture</a></li>
<li><a href="../fr461535/index.html">C ++, FIX, Oracle et PL / SQL: ce qu'un informaticien doit savoir pour obtenir un emploi en finance + de r√©elles opportunit√©s d'emploi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>