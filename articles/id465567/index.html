<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎯 🐯 🔨 Menguji kode SQL Server dengan tSQLt 🛷 🥘 📈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="FYI: artikel ini adalah versi perluasan dari ceramah saya di SQA Days # 25. 

 Berdasarkan pengalaman saya dengan kolega, saya dapat menyatakan: pengu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menguji kode SQL Server dengan tSQLt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/arcadia/blog/465567/">  <i>FYI: artikel ini adalah versi perluasan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ceramah</a> saya di SQA Days # 25.</i> <br><br>  Berdasarkan pengalaman saya dengan kolega, saya dapat menyatakan: pengujian kode DB bukan praktik yang tersebar luas.  Ini bisa berpotensi berbahaya.  Logika DB ditulis oleh manusia seperti semua kode "biasa" lainnya.  Jadi, bisa ada kegagalan yang dapat menyebabkan konsekuensi negatif untuk suatu produk, bisnis atau pengguna.  Apakah ini adalah prosedur tersimpan yang membantu backend atau itu adalah ETL memodifikasi data di gudang - selalu ada risiko dan pengujian membantu menguranginya.  Saya ingin memberi tahu Anda apa itu tSQLt dan bagaimana ini membantu kami untuk menguji kode DB. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2e/-h/nx/2e-hnxb3bddbq3ck_8vi4jwah8i.jpeg"></div><a name="habracut"></a><br><h1>  Konteksnya </h1><br>  Ada gudang besar menggunakan SQL Server dan berisi data uji klinis yang berbeda.  Itu diisi dari berbagai sumber (terutama database berorientasi dokumen).  Banyak ETL mengubah data di dalam gudang pada banyak kesempatan.  Data ini dapat dimuat ke dalam DB yang lebih kecil untuk digunakan oleh aplikasi web yang berorientasi pada tugas-tugas spesifik kecil.  Beberapa pelanggan klien diminta untuk mengimplementasikan API untuk kebutuhan mereka.  API semacam itu sering menggunakan prosedur tersimpan dan kueri yang berbeda. <br><br><div style="text-align:center;"><img width="75%" height="75%" src="https://habrastorage.org/webt/iw/vu/rz/iwvurz8sbflhuz3mkj39ipf9rag.png"></div><br>  Secara umum, ada jumlah kode yang cukup besar di sisi DBMS. <br><br><h1>  Mengapa kita membutuhkan ini? </h1><br>  Seperti yang Anda lihat dari pendahuluan, kode DB adalah bagian dari kode aplikasi dan juga mengandung bug. <br><br>  Saya kira banyak dari kita yang akrab dengan Kurva Boehm: bug selalu lebih mahal untuk diperbaiki nanti dalam prosesnya.  Kesalahan yang dibuat pada tahap pengembangan sebelumnya dan dilokalkan pada tahap selanjutnya bisa lebih mahal.  Ini karena perlunya melalui banyak langkah sementara (pengkodean, pengujian unit, pengujian integrasi, pengujian sistem, dll.) Dua kali: untuk debugging dan untuk mengembalikan kode ke tahap di mana ia ditemukan.  Efek ini berlaku untuk kasus gudang juga.  Jika ada kesalahan dalam prosedur ETL dan data dimodifikasi beberapa kali, kita harus: <br><br><ol><li>  pergi melalui semua langkah transformasi data kembali ke sumber masalah </li><li>  perbaiki masalah </li><li>  mendapatkan kembali data yang tepat (suntingan manual tambahan mungkin diperlukan) </li><li>  pastikan tidak ada data rusak lainnya yang disebabkan oleh bug. </li></ol><br>  Jangan lupa bahwa kami tidak menjual mainan lunak.  Kesalahan dalam bidang seperti uji klinis dapat membahayakan tidak hanya bisnis tetapi juga kesehatan manusia. <br><br><h1>  Bagaimana cara menguji? </h1><br>  Karena kita berbicara tentang pengujian kode, yang kami maksud adalah pengujian unit dan integrasi.  Hal-hal ini sangat berulang dan menyiratkan regresi persisten.  Sebenarnya, pengujian semacam itu tidak pernah dilakukan secara manual (yah, kecuali beberapa kasus tunggal mungkin). <br><br>  Bonus bagus: tes dapat menjadi bahan pendukung untuk mendokumentasikan kode.  Misalnya, persyaratan mungkin terlihat seperti ini (dapat diklik): <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/fh/af/xb/fhafxb5yph-tgvy2zhka9jfcvmk.png"></a> </div><br>  File XLS, 2 kolom dengan persyaratan + informasi tambahan terfragmentasi di kolom lain + markup membingungkan.  Mungkin sulit untuk mengembalikan keinginan awal jika perlu.  Tes dapat membantu mencatat nuansa implementasi.  Tentu saja, mereka tidak boleh dianggap sebagai pengganti dokumentasi. <br><br>  Sayangnya, kompleksitas pengujian meningkat dengan meningkatnya kompleksitas kode, jadi, efek ini dapat diperhalus. <br><br>  Tes bisa menjadi lapisan keamanan tambahan terhadap penggabungan spontan.  Tes otomatis CI membantu dengan masalah ini karena formalisme mereka. <br><br>  Jadi, jika kita memutuskan untuk menggunakan otomatisasi, kita perlu memilih alat untuk itu. <br><br><h1>  Apa yang akan digunakan untuk pengujian? </h1><br>  Dalam hal pengujian kode DB, saya melihat 2 pendekatan: SQL-powered (ketika alat berfungsi dalam DBMS secara langsung) dan non-SQL-powered.  Inilah perbedaan utama yang saya temukan: <br><div class="scrollable-table"><table><tbody><tr><th>  Bertenaga SQL <br></th><th>  Bertenaga non-sql <br></th></tr><tr><td>  Membutuhkan instalasi objek DB <br></td><td>  Memerlukan instalasi alat eksternal (terkait DB) <br></td></tr><tr><td>  Tes tidak tergantung pada teknologi yang digunakan di luar DB <br></td><td>  Tes dapat bergantung pada teknologi yang digunakan di luar DB <br></td></tr><tr><td>  Kerangka kerja ini selalu didedikasikan untuk hanya satu DBMS <br></td><td>  Kerangka sering mendukung beberapa DBMS <br></td></tr><tr><td>  Pengetahuan DBMS adalah satu-satunya persyaratan untuk menulis tes;  dimungkinkan untuk menggunakan penguji manual atau DBA <br></td><td>  Pengetahuan tambahan tentang bahasa atau teknologi pemrograman diperlukan untuk menulis tes;  bantuan pengembang sering dibutuhkan <br></td></tr><tr><td>  Eksekusi tingkat DBMS memungkinkan pemalsuan dan pernyataan penggunaan tingkat lanjut. <br></td><td>  Eksekusi di luar DBMS dapat membatasi fitur alat ini <br></td></tr></tbody></table></div>  Dalam hal SQL Server, kami memiliki beberapa pilihan: <br><div class="scrollable-table"><table><tbody><tr><th colspan="6" align="center">  Informasi umum </th></tr><tr><th>  Nama </th><th>  Pendekatan </th><th>  Arsitektur </th><th>  Bahasa / Platform </th><th>  Tes bahasa </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tSQLt</a> </td><td>  Bertenaga SQL </td><td>  xUnit </td><td>  T-SQL + CLR </td><td>  T-sql </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TSQLUnit</a> </td><td>  Bertenaga SQL </td><td>  xUnit </td><td>  T-sql </td><td>  T-sql </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utTSQL</a> </td><td>  Bertenaga SQL </td><td>  xUnit </td><td>  T-sql </td><td>  T-sql </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertama</a> </td><td>  Bertenaga SQL </td><td>  xUnit </td><td>  T-sql </td><td>  T-sql </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dbfit</a> </td><td>  Bertenaga non-sql </td><td>  Kebugaran </td><td>  C # / java </td><td>  Penurunan Wiki </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemalas</a> </td><td>  Bertenaga non-sql </td><td>  RSpec (berorientasi BDD) </td><td>  Ruby </td><td>  Ruby </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NUnit</a> , dll. </td><td>  Bertenaga non-sql </td><td>  xUnit </td><td>  Tidak ada </td><td>  Tidak ada </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><th colspan="4" align="center">  Tanggal </th></tr><tr><th>  Nama </th><th>  Penampilan pertama </th><th>  Komit terbaru </th><th>  Rilis terbaru </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tSQLt</a> </td><td>  2007-07-27 </td><td>  07/07/2019 </td><td>  31/01/2016 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TSQLUnit</a> </td><td>  2006-12-16 (0.9) <br>  2007-07-21 (0.91 rc1) </td><td>  04/26/2018 (GitHub) </td><td>  04/09/2011 (SourceForge) </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utTSQL</a> </td><td>  2003-03-12 </td><td>  2003-03-12 </td><td>  2003-03-12 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertama</a> </td><td>  02-03-2009 (v1.0) </td><td>  Tidak ada </td><td>  30-03-2012 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dbfit</a> </td><td>  12-01-2009 </td><td>  10-09-2018 </td><td>  15/08/2015 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemalas</a> </td><td>  23/06/2011 </td><td>  12-12-2018 </td><td>  12-12-2018 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NUnit</a> , dll. </td><td>  Tidak ada </td><td>  Tidak ada </td><td>  Tidak ada </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><th colspan="7" align="center">  Fitur </th></tr><tr><th>  Nama </th><th>  CLR tidak diperlukan </th><th>  Output XML </th><th>  Tes dalam transaksi terpisah </th><th>  Palsu </th><th>  Penangan kesalahan </th><th>  Penegasan </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tSQLt</a> </td><td>  - </td><td>  + </td><td>  + </td><td>  + </td><td>  + </td><td>  Luar biasa </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TSQLUnit</a> </td><td>  + </td><td>  - </td><td>  + </td><td>  - </td><td>  - </td><td>  Gagal </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utTSQL</a> </td><td>  + </td><td>  - </td><td>  - </td><td>  - </td><td>  - </td><td>  Di bawah rata-rata </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertama</a> </td><td>  + </td><td>  + </td><td>  + (opsional) </td><td>  - </td><td>  + </td><td>  Luar biasa </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dbfit</a> </td><td>  + </td><td>  - </td><td>  + (opsional) </td><td>  - </td><td>  + </td><td>  Sangat bagus;  bernuansa </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemalas</a> </td><td>  + </td><td>  - </td><td>  + (opsional) </td><td>  - </td><td>  - </td><td>  Sangat bagus;  bernuansa </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NUnit</a> , dll. </td><td>  + </td><td>  + </td><td>  Tidak ada </td><td>  Tidak ada </td><td>  Tidak ada </td><td>  Luar biasa;  bernuansa </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><th colspan="3" align="center">  Lainnya </th></tr><tr><th>  Nama </th><th>  Dokumentasi </th><th>  Komunitas </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tSQLt</a> </td><td>  Luar biasa;  bernuansa </td><td>  Luar biasa </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TSQLUnit</a> </td><td>  Di bawah rata-rata </td><td>  Di bawah rata-rata </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utTSQL</a> </td><td>  Luar biasa </td><td>  Di bawah rata-rata </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertama</a> </td><td>  Luar biasa </td><td>  Di bawah rata-rata </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dbfit</a> </td><td>  Luar biasa </td><td>  Rata-rata </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemalas</a> </td><td>  Luar biasa </td><td>  Rata-rata </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NUnit</a> , dll. </td><td>  Luar biasa </td><td>  Luar biasa </td></tr></tbody></table></div>  Skala "Luar Biasa - Gagal" subyektif, maaf, sulit untuk menemukan jalan keluar. <br><br>  "Penampilan pertama" - tanggal paling awal penampilan kerangka yang bisa saya temukan - rilis paling awal atau komit. <br><br>  Seperti yang Anda lihat, alternatif bertenaga SQL ditinggalkan cukup lama, dan tSQLt adalah satu-satunya produk yang saat ini didukung.  Selain itu, tSQLt menang secara fungsional.  Satu-satunya hal adalah, TST menawarkan serangkaian pernyataan yang lebih kaya daripada tSQLt;  Namun, saya ragu ini bisa melebihi semua kontra. <br><br>  Dokumentasi tSQLt memiliki beberapa nuansa, saya akan menjelaskannya nanti. <br><br>  Di dunia yang tidak menggunakan SQL, banyak hal yang tidak begitu jelas.  Alternatif berkembang, meskipun tidak super-aktif.  DbFit adalah alat yang cukup menarik berdasarkan kerangka kerja FitNesse.  Itu menyiratkan menggunakan markup wiki untuk tes menulis.  Slacker juga menarik: pendekatan BDD disarankan untuk pengujian kode DB. <br><br>  Saya harus mengatakan tentang pernyataan dalam solusi non-SQL-powered.  Pada pandangan pertama, jumlah asersi lebih sedikit, dan kita dapat berpikir bahwa alat semacam itu lebih buruk.  Tetapi kita harus ingat bahwa mereka pada dasarnya berbeda dari tSQLt, jadi, pandangan dangkal semacam itu tidak benar. <br><br>  Baris terbaru - "NUnit, dll."  - Lebih seperti pengingat.  Banyak kerangka kerja unit-testing yang biasa dapat diterapkan pada kode DB dengan bantuan pustaka tambahan.  Ada banyak N / A di baris ini karena baris ini, pada kenyataannya, termasuk beberapa alat.  Itu adalah sumber "nuansa" di kolom "pernyataan" - alat yang berbeda dapat menyediakan perangkat yang berbeda dan tidak ada jaminan bahwa semua pernyataan dapat diterapkan ke DB. <br><br>  Sebagai metrik lain yang menarik, kita dapat mempertimbangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tren Google</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/2u/km/ud2ukmcoyjvstvhcu2taegpib34.png"></div><br>  Nuansa: <br><br><ol><li>  Saya memutuskan untuk tidak memasukkan Slacker karena nama ini dapat berarti hal yang berbeda (dan pertanyaan seperti "Kerangka kerja Slacker" hampir tidak terlihat pada grafik). </li><li>  Hanya ingin tahu (dan karena satu slot tetap kosong), saya telah menambahkan tren TST.  Tapi itu hampir tidak menunjukkan kepada kita gambaran nyata karena itu singkatan yang dapat berarti hal yang berbeda juga. </li><li>  Saya belum memasukkan NUnit dan analognya.  Alat-alat ini adalah kerangka kerja untuk pengujian kode "biasa", sehingga tren mereka tidak deskriptif untuk konteks kita. </li></ol><br>  Seperti yang Anda lihat, tSQLt adalah alat yang paling dicari dalam daftar.  Alat lain (kurang) populer adalah DbFit.  Alat lain memiliki popularitas yang terbatas. <br><br>  Secara umum, kita dapat melihat bahwa tSQLt bersinar dengan latar belakang. <br><br><h1>  Apa itu tSQLt? </h1><br>  Sangat mudah untuk menebak bahwa tSQLt adalah kerangka kerja unit-test bertenaga SQL.  Situs resmi adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tsqlt.org</a> . <br><br>  Dijanjikan bahwa tSQLt mendukung SQL Server mulai dari 2005 SP2.  Saya belum memeriksa revisi awal tersebut, tetapi saya tidak melihat masalah dengan 2012 di server-dev kami dan 2017 di komputer lokal saya. <br><br>  Sumber terbuka, lisensi Apache 2.0, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tersedia di GitHub</a> .  Seperti biasa, kita dapat membayar, berkontribusi, menggunakan gratis dalam proyek komersial dan, yang lebih penting, tidak perlu takut spyware di CLR. <br><br><h1>  Mekanika </h1><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/1v/kx/wi/1vkxwixwjyna756vsce7uhwqzw0.png"></div><br>  Kasus uji adalah prosedur tersimpan.  Mereka dapat digabungkan ke dalam kelas uji (suite uji dalam terminologi xUnit). <br><br>  Kelas tes tidak lain adalah skema DB.  tSQLt perlu mendaftarkan mereka dengan prosedur NewTestClass yang menambahkan kelas uji ke tabel khusus. <br><br>  Dimungkinkan untuk menentukan prosedur Penyetelan.  Prosedur seperti itu akan berjalan sebelum setiap test case dijalankan. <br><br>  Prosedur Teardown setelah uji kasus dijalankan tidak diperlukan.  Setiap test case dengan SetUp dijalankan dalam transaksi terpisah yang dibatalkan setelah pengumpulan hasil.  Ini sangat nyaman tetapi memiliki beberapa konsekuensi negatif - saya akan menjelaskannya sedikit nanti. <br><br>  Kerangka kerja ini memungkinkan menjalankan uji kasus satu per satu, seluruh kelas uji sekaligus atau bahkan semua kelas uji terdaftar dengan satu perintah tunggal. <br><br><h1>  Fitur dan contoh </h1><br>  Tidak ingin mengulangi panduan resmi, saya akan menunjukkan fitur tSQLt pada contoh. <br><br>  <i>Penafian:</i> <br><br><ul><li>  <i>contoh disederhanakan</i> </li><li>  <i>kode asli bukan sepenuhnya milikku - itu adalah kreasi kolektif</i> </li><li>  <i>Contoh 2 difiksikan oleh saya untuk menunjukkan fitur lebih lengkap.</i> </li></ul><br><h3>  Contoh # 1: CsvSql </h3><br>  Berikut ini diimplementasikan atas permintaan salah satu pelanggan klien.  Ada SQL-queries yang disimpan di bidang Nvarchar (MAX).  UI minimal dibuat untuk melihatnya.  Set hasil yang dihasilkan oleh query ini digunakan di backend untuk penulisan lebih lanjut sebagai file CSV.  File CSV dapat diminta oleh panggilan API. <br><br><div style="text-align:center;"><img width="75%" height="75%" src="https://habrastorage.org/webt/5q/mu/oy/5qmuoyyjjvlphk79jt-xtawwjn8.png"></div><br>  Kumpulan hasil berukuran besar dan mengandung banyak kolom.  Contoh hipotetis dari rangkaian hasil tersebut: <br><br><div style="text-align:center;"><img width="75%" height="75%" src="https://habrastorage.org/webt/dg/50/bb/dg50bbx25qaw6ycwpfqcsfj5kyk.png"></div><br>  Kumpulan hasil ini merupakan data uji klinis.  Mari kita perhatikan perhitungan [ClinicsNum] lebih dekat.  Kami memiliki 2 tabel: [Uji Coba] dan [Klinik]. <br><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/qo/mu/n-/qomun-gdbdl05teniypbtzi8jio.png"></div><br>  Ada sebuah FK: [Klinik]. [TrialID] -&gt; [Trial]. [TrialID].  Jelas, cukup menggunakan COUNT (*) untuk mendapatkan sejumlah klinik: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*), ...  <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo.Trial  <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> dbo.Clinic    <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> Trial.ID = Clinic.TrialID  <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Trial.Name = @trialName  <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> ...</code> </pre> <br>  Bagaimana kami bisa menguji permintaan seperti itu?  Pertama, mari kita gunakan rintisan FakeTable, yang akan membuat pekerjaan kita lebih mudah. <br><br><pre> <code class="plaintext hljs">EXEC tSQLt.FakeTable 'dbo.Trial'; EXEC tSQLt.FakeTable 'dbo.Clinic';</code> </pre> <br>  FakeTable membuat hal yang sederhana - mengganti nama tabel lama dan membuat yang baru dengan nama yang sama.  Nama yang sama, kolom yang sama, tetapi tanpa kendala dan pemicu. <br><br>  Kami membutuhkan ini karena: <br><br><ol><li>  Tes DB dapat berisi beberapa data yang dapat mencegah jalannya pengujian dengan benar.  FakeTable memungkinkan kita untuk tidak bergantung pada mereka. </li><li>  Biasanya, kita hanya perlu mengisi beberapa kolom untuk keperluan pengujian.  Tabel dapat memuat banyak dari mereka, seringkali mengandung kendala dan pemicu.  Kami membuatnya lebih mudah untuk memasukkan data nanti - kami hanya akan memasukkan informasi tes yang diperlukan, menjaga tes seminimal mungkin. </li><li>  Tidak akan ada pemicu yang tidak diinginkan, jadi, kita tidak perlu khawatir tentang efek pasca. </li></ol><br>  Kemudian kami memasukkan data uji yang diperlukan: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> dbo.Trial ([<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>], [<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,   <span class="hljs-string"><span class="hljs-string">'Valerian'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> dbo.Clinic ([<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>], [TrialID], [<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,   <span class="hljs-number"><span class="hljs-number">1</span></span>,        <span class="hljs-string"><span class="hljs-string">'Clinic1'</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>,   <span class="hljs-number"><span class="hljs-number">1</span></span>,        <span class="hljs-string"><span class="hljs-string">'Clinic2'</span></span>);</code> </pre> <br>  Kami memperoleh kueri dari DB, membuat tabel [Aktual] dan mengisinya dengan hasilnya <br>  atur dari kueri. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @sqlStatement <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>) = (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span>… <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> actual ([TrialID], ...); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> actual EXEC sp_executesql @sqlStatement, ...</code> </pre> <br>  Sekarang, kami mengisi [Diharapkan] - nilai yang kami harapkan: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> expected (   ClinicsNum <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> expected <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Saya ingin menarik perhatian Anda bahwa kami hanya memiliki satu kolom di tabel [Diharapkan], meskipun kami memiliki set lengkap di kolom [Sebenarnya]. <br><br><div style="text-align:center;"><img width="80%" height="80%" src="https://habrastorage.org/webt/qd/gx/ga/qdgxgaqr4cjp2eayoz0eycjs8cg.png"></div><br>  Ini disebabkan oleh salah satu fitur berguna dari prosedur AssertEqualsTable yang akan kami gunakan untuk verifikasi nilai. <br><br><pre> <code class="sql hljs">EXEC tSQLt.AssertEqualsTable   'expected',   'actual',   'incorrect number of clinics';</code> </pre> <br>  Itu hanya membandingkan kolom-kolom yang disajikan di kedua tabel.  Ini sangat nyaman dalam kasus kami karena permintaan yang diuji mengembalikan banyak kolom, masing-masing terhubung dengan logika yang cukup rumit.  Kami tidak ingin mengembang kasus uji, jadi fitur ini sangat membantu.  Tentu saja, fitur ini adalah pedang bermata dua.  Jika [Aktual] diisi melalui SELECT TOP 0 dan pada satu titik kolom yang tidak terduga muncul, kotak uji tersebut tidak akan menangkap ini.  Anda harus menulis cek tambahan untuk meliput ini. <br><br><h3>  Prosedur kembar AssertEqualsTable </h3><br>  Perlu disebutkan bahwa tSQLt berisi 2 prosedur seperti AssertEqualsTable.  Mereka adalah AssertEqualsTableSchema dan AssertResultSetsHaveSameMetaData.  Yang pertama melakukan hal yang sama seperti AssertEqualsTable tetapi pada metadata tabel.  Yang kedua melakukan hal yang sama tetapi pada metadata set hasil. <br><br><h3>  Contoh # 2: Kendala </h3><br>  Contoh sebelumnya telah menunjukkan kepada kita bagaimana kita dapat menghilangkan kendala.  Tetapi bagaimana jika kita perlu memeriksanya?  Secara teknis, kendala juga merupakan bagian dari logika, dan mereka dapat dianggap sebagai kandidat untuk dicakup oleh tes. <br><br>  Pertimbangkan situasi dari contoh sebelumnya.  2 tabel - [Uji Coba] dan [Klinik];  [TrialID] FK: <br><br><div style="text-align:center;"><img width="80%" height="80%" src="https://habrastorage.org/webt/-8/zu/v3/-8zuv3clqoo3ygm9wko5hpibc90.png"></div><br>  Mari kita coba menulis test case untuk memeriksanya.  Pertama, seperti pada kasus sebelumnya, kami memalsukan tabel: <br><br><pre> <code class="sql hljs">EXEC tSQLt.FakeTable '[dbo].[Trial]' EXEC tSQLt.FakeTable '[dbo].[Clinic]'</code> </pre> <br>  Tujuannya sama - menyingkirkan batasan yang tidak perlu.  Kami ingin cek terisolasi tanpa upaya yang tidak semestinya. <br><br>  Selanjutnya, kami mengembalikan batasan yang ingin kami uji menggunakan ApplyConstraint: <br><br><pre> <code class="sql hljs">EXEC tSQLt.ApplyConstraint   '[dbo].[Clinic]',   'Trial_FK';</code> </pre> <br>  Sekarang kami memiliki konfigurasi untuk pemeriksaan.  Pemeriksaan itu sendiri adalah bahwa mencoba memasukkan data akan menyebabkan pengecualian.  Untuk lulus ujian kasus, kita perlu menangkap pengecualian ini.  Penangan pengecualian ExpectException dapat membantu. <br><br><pre> <code class="sql hljs">EXEC tSQLt.ExpectException   @ExpectedMessage = 'The <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span> conflicted...<span class="hljs-string"><span class="hljs-string">',   @ExpectedSeverity = 16,   @ExpectedState = 0;</span></span></code> </pre> <br>  Kami dapat mencoba memasukkan yang tidak dapat dimasukkan setelah pengaturan handler. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> [dbo].[Clinic] ([TrialID])   <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Pengecualian ditangkap.  Tes lulus. <br><br><h3>  Prosedur kembar Terapkan Kendala </h3><br>  Cara pengujian pemicu yang diajukan oleh penulis tSQLt mirip dengan kendala pengujian.  Kita bisa menggunakan prosedur ApplyTrigger untuk mengembalikan pelatuk ke tabel.  Setelah itu, semuanya berjalan seperti pada contoh di atas - mulai pelatuk, periksa hasilnya. <br><br><h3>  ExpectNoException - antonim ExpectException </h3><br>  Ada prosedur ExpectNoException untuk kasus ketika pengecualian tidak boleh terjadi.  Ini bekerja dengan cara yang sama seperti karya ExpectException kecuali bahwa tes gagal jika terjadi pengecualian. <br><br><h3>  Contoh # 3: Semaphore </h3><br>  Ada beberapa prosedur tersimpan dan layanan windows.  Awal eksekusi mereka dapat disebabkan oleh berbagai peristiwa luar.  Namun, urutan eksekusi mereka sudah diperbaiki.  Jadi, diperlukan untuk menerapkan kontrol akses di sisi DB - mis. Semafor.  Dalam kasus kami, semaphore adalah sekelompok prosedur tersimpan yang bekerja bersama. <br><br>  Mari kita lihat prosedur di dalam semaphore.  Kami memiliki 2 tabel - [Proses] dan [ProcStatus]: <br><br><div style="text-align:center;"><img width="80%" height="80%" src="https://habrastorage.org/webt/-m/hz/8-/-mhz8-fm_n1w7njpryiv8z3epiw.png"></div><br>  Tabel [Proses] berisi daftar proses yang diizinkan untuk dieksekusi.  [ProcStatus], jelas, berisi daftar status proses dari tabel sebelumnya. <br><br>  Jadi, apa yang dilakukan prosedur kami?  Pertama, ia melakukan pemeriksaan berikut: <br><br><ol><li>  Kami telah melewati nama proses sebagai salah satu parameter input prosedur.  Nama ini dicari di bidang [Nama] pada tabel [Proses]. </li><li>  Jika nama proses telah ditemukan, itu memeriksa bendera [IsRunable] dari tabel [Proses]. </li><li>  Jika bendera HIDUP, kami menganggap bahwa prosesnya dapat berjalan.  Pemeriksaan terakhir terjadi di tabel [ProcStatus].  Kita perlu memastikan bahwa proses saat ini tidak berjalan, yang berarti tidak adanya catatan tentang proses dengan status "InProg" di tabel [ProcStatus]. </li></ol><br>  Jika semuanya OK dan semua pemeriksaan dilewati, kami menambahkan catatan baru tentang proses kami ke dalam tabel [ProcStatus] dengan status "InProg".  ID dari catatan baru ini dikembalikan dengan parameter output ProcStatusId. <br><br>  Jika ada yang salah, kami mengharapkan yang berikut: <br><br><ol><li>  Email ke administrator sistem dikirim. </li><li>  ProcStatusId = -1 dikembalikan. </li><li>  Tidak ada catatan [ProcStatus] baru ditambahkan. </li></ol><br>  Mari kita buat kasus uji untuk memeriksa kasus tidak adanya proses di tabel [Proses]. <br><br>  Kami menggunakan FakeTable lagi.  Ini tidak begitu kritis di sini, tetapi bisa nyaman karena: <br><br><ol><li>  Dijamin tidak akan ada data yang bisa mengganggu pelaksanaan test case. </li><li>  Pemeriksaan lebih lanjut atas ketidakhadiran data [ProcStatus] baru akan disederhanakan. </li></ol><br><pre> <code class="sql hljs">EXEC tSQLt.FakeTable 'dbo.Process'; EXEC tSQLt.FakeTable 'dbo.ProcStatus';</code> </pre> <br>  Ada prosedur [SendEmail] yang namanya berbicara sendiri.  Kita harus menerima teleponnya.  tSQLt menyarankan menggunakan tiruan SpyProcedure untuk itu. <br><br><pre> <code class="plaintext hljs">EXEC tSQLt.SpyProcedure 'dbo.SendEmail'</code> </pre> <br>  SpyProcedure melakukan hal berikut: <br><br><ol><li>  Membuat tabel dengan nama yang terlihat seperti [dbo]. [ProcedureName_SpyProcedureLog] </li><li>  Sama seperti FakeTable, menggantikan prosedur asli dengan yang dibuat secara otomatis, dengan nama yang sama, tetapi dengan log masuk di dalamnya.  Anda juga dapat menambahkan logika Anda sendiri ke prosedur yang dibuat jika diperlukan. </li></ol><br>  Tidak sulit untuk menebak bahwa log direkam ke tabel [dbo]. [SendEmail_SpyProcedureLog].  Tabel ini berisi kolom [_ID_] yang untuk nomor urut panggilan.  Kolom berikutnya diberi nama setelah parameter dilewatkan ke prosedur dan digunakan untuk mengumpulkan mereka, jadi, nilai parameter dapat diverifikasi juga. <br><br><div style="text-align:center;"><img width="75%" height="75%" src="https://habrastorage.org/webt/ko/gh/4h/kogh4hgcdsxagldk2bmdcfrptzi.png"></div><br>  Hal terakhir yang perlu kita lakukan sebelum pemanggilan semaphore adalah membuat variabel untuk menyimpan nilai [ProcStatusId] (lebih tepatnya, -1, karena catatan tidak akan ditambahkan). <br><br><pre> <code class="plaintext hljs">DECLARE @ProcStatusId BIGINT;</code> </pre> <br>  Kami menyebutnya semafor: <br><br><pre> <code class="plaintext hljs">EXEC dbo.[Semaphore_JobStarter]   'SomeProcess',   @ProcStatusId OUTPUT; -- here we get -1</code> </pre> <br>  Sekarang kami memiliki semua data yang diperlukan untuk pemeriksaan.  Mari kita mulai dari mengecek <br>  bahwa pesan telah dikirim. <br><br><pre> <code class="plaintext hljs">IF NOT EXISTS (   SELECT *   FROM dbo.SendEmail_SpyProcedureLog) EXEC tSQLt.Fail 'SendEmail has not been run.';</code> </pre> <br>  Dalam hal ini, kami tidak memeriksa parameter yang diteruskan dan menguji fakta pengiriman saja.  Saya ingin menarik perhatian Anda pada prosedur Gagal.  Ini memungkinkan kita untuk "secara resmi" gagal ujian.  Jika Anda perlu membangun konstruksi yang canggih, Gagal dapat membantu. <br><br>  Sekarang kami memeriksa tidak adanya catatan di tabel [ProcStatus] dengan prosedur AssertEmptyTable. <br><br><pre> <code class="plaintext hljs">EXEC tSQLt.AssertEmptyTable 'dbo.ProcStatus';</code> </pre> <br>  Di sinilah FakeTable yang kami gunakan di awal membantu kami.  Dengan itu, kita dapat mengharapkan tabel kosong dan menguji menggunakan satu baris kode.  Cara yang benar untuk memeriksanya tanpa pemalsuan tabel adalah membandingkan jumlah baris sebelum dan sesudah eksekusi prosedur, dan itu akan membutuhkan lebih banyak tindakan. <br><br>  Kita dapat dengan mudah memeriksa ProcStatusId = -1 kesetaraan dengan AssertEquals. <br><br><pre> <code class="sql hljs">EXEC tSQLt.AssertEquals   -1,       @ProcStatusId,       'Wrong ProcStatusId.';</code> </pre> <br>  AssertEquals adalah minimalis.  Itu hanya membandingkan 2 nilai, tidak ada yang luar biasa. <br><br><h3>  Prosedur kembar AssertEquals </h3><br>  Kami memiliki prosedur perbandingan nilai berikut: <br><br><ul><li>  AssertEquals </li><li>  AssertNotEquals </li><li>  AssertEqualsString </li><li>  Tegas </li></ul><br>  Nama-nama itu sudah jelas, saya pikir.  Satu-satunya prosedur yang ingin saya tekankan adalah AssertEqualsString.  Ini prosedur yang didedikasikan untuk verifikasi nilai string.  Mengapa kita perlu satu prosedur lagi, mengingat diberikan AssertEquals universal?  Masalahnya adalah, AssertEquals / AssertNotEquals / AssertLike bekerja dengan tipe SQL_VARIANT.  NVARCHAR (MAX) tidak termasuk dalam SQL_VARIANT, jadi pengembang tSQLt harus membuat prosedur tambahan. <br><br><h3>  Fungsi palsu </h3><br>  Dengan cepat, kita dapat memanggil FakeFunction prosedur yang mirip dengan SpyProcedure.  Palsu ini memungkinkan mengganti fungsi apa pun dengan yang lebih sederhana.  Karena fungsi SQL Server berfungsi seperti tabung pasta gigi (hasilnya dikembalikan melalui satu-satunya "lubang"), secara teknis tidak mungkin untuk menerapkan fungsi logging.  Penggantian logika batin adalah satu-satunya cara yang tersedia. <br><br><h1>  Perangkap </h1><br>  Saya ingin memberi tahu Anda tentang beberapa jebakan yang dapat Anda hadapi selama penggunaan tSQLt.  Dalam hal ini "jebakan" berarti beberapa masalah yang disebabkan oleh pembatasan SQL Server dan / atau yang tidak mungkin diselesaikan oleh pengembang kerangka kerja. <br><br><h3>  Rollback dan dooming transaksi </h3><br>  Masalah pertama dan utama yang dihadapi oleh tim kami adalah kemunduran transaksi dan malapetaka.  SQL Server tidak dapat mengembalikan transaksi bersarang secara terpisah.  Itu selalu memutar kembali semua transaksi hingga ke bagian terluar.  Mempertimbangkan bahwa tSQLt membungkus setiap pengujian ke dalam transaksi yang terpisah, ini dapat menjadi masalah karena kemunduran di dalam prosedur yang tersimpan dapat memecah suatu percobaan dengan kesalahan eksekusi non-deskriptif. <br><br>  Sebagai solusinya, kami menggunakan savepoints.  Idenya sederhana.  Pada awalnya, kami memeriksa apakah kami melakukan transaksi atau tidak.  Jika ya, kami mengira itu adalah transaksi tSQLt dan menempatkan savepoint, jadi kami akan memutar kembali jika diperlukan.  Jika tidak, kami memulai transaksi baru.  Bahkan, kami tidak mengizinkan bersarang. <br><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/bu/ih/vl/buihvlf1ffnwuzbotecbqtev09o.png"></div><br>  Masalahnya rumit oleh malapetaka transaksi - itu bisa terjadi jika pengecualian dilemparkan.  Transaksi yang gagal tidak dapat dilakukan seperti halnya digulung kembali ke savepoint, jadi kita harus menggulungnya kembali ke transaksi terluar lagi. <br><br>  Mempertimbangkan poin-poin yang dijelaskan di atas, kita harus menggunakan struktur berikut: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @isNestedTransaction <span class="hljs-built_in"><span class="hljs-built_in">BIT</span></span> =   <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> @@trancount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'true'</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'false'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRY   <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> @isNestedTransaction = <span class="hljs-string"><span class="hljs-string">'false'</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">SAVE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> SavepointName;       <span class="hljs-comment"><span class="hljs-comment">-- something useful   IF @isNestedTransaction = 'false'   COMMIT TRANSACTION; END TRY BEGIN CATCH   DECLARE @isCommitable BIT =       CASE WHEN XACT_STATE() = 1           THEN 'true'           ELSE 'false'   END;   IF @isCommitable = 'true' AND @isNestedTransaction = 'true'       ROLLBACK TRANSACTION SavepointName;   ELSE       ROLLBACK;   THROW; END CATCH;</span></span></code> </pre> <br>  Mari kita tinjau sepotong demi sepotong kode.  Pertama, kita perlu menentukan apakah kita melakukan transaksi atau tidak. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @isNestedTransaction <span class="hljs-built_in"><span class="hljs-built_in">BIT</span></span> =   <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> @@trancount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'true'</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'false'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>;</code> </pre> <br>  Setelah menurunkan flag @isNestedTransaction, kita dapat memulai blok TRY dan mengatur savepoint atau memulai transaksi tergantung pada situasinya. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRY   <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> @isNestedTransaction = <span class="hljs-string"><span class="hljs-string">'false'</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">SAVE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> SavepointName;       <span class="hljs-comment"><span class="hljs-comment">-- something useful</span></span></code> </pre> <br>  Setelah melakukan sesuatu yang bermanfaat, kami berkomitmen hasilnya jika itu adalah prosedur "nyata". <br><br><pre> <code class="sql hljs">       <span class="hljs-comment"><span class="hljs-comment">-- something useful   IF @isNestedTransaction = 'false'   COMMIT TRANSACTION; END TRY</span></span></code> </pre> <br>  Tentu saja, jika ini adalah uji coba, kita tidak perlu melakukan apa pun.  tSQLt akan mengembalikan perubahan pada akhirnya secara otomatis. <br><br>  Jika ada yang tidak beres dan kami masuk ke blok CATCH, kami perlu menentukan apakah transaksi tersebut sesuai atau tidak. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> CATCH   <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @isCommitable <span class="hljs-built_in"><span class="hljs-built_in">BIT</span></span> =       <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> XACT_STATE() = <span class="hljs-number"><span class="hljs-number">1</span></span>           <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'true'</span></span>           <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'false'</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>;</code> </pre> <br>  Kita dapat kembali ke savepoint hanya jika: <br><br><ol><li>  Transaksi berkomitmen </li><li>  Ini adalah uji coba, jadi, savepoint ada. </li></ol><br>  Dalam semua kasus lain, kita harus memutar kembali seluruh transaksi. <br><br><pre> <code class="sql hljs">   IF @isCommitable = 'true' AND @isNestedTransaction = 'true'       <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> SavepointName;   ELSE       <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;   THROW; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> CATCH;</code> </pre> <br>  Ya, sayangnya, jika kami telah mencapai kondisi transaksi yang tidak dapat dilakukan selama uji coba, kami masih mendapatkan kesalahan eksekusi. <br><br><h3>  Faketable dan masalah kunci asing </h3><br>  Mari kita tinjau tabel [Uji Coba] dan [Klinik] yang familier <br><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/fy/k7/nm/fyk7nmhfha_fnezignyxclpflay.png"></div><br>  Kami ingat tentang [TrialID] FK.  Masalah apa yang bisa ditimbulkannya?  Dalam contoh di atas kami menerapkan FakeTable di kedua tabel.  Jika kami menggunakannya hanya di salah satu dari mereka, kami akan mencapai pengaturan berikut: <br><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/og/to/3-/ogto3-drjheieblpi1_gsyup4hs.png"></div><br>  Jadi, upaya untuk memasukkan catatan ke dalam [Klinik] dapat gagal bahkan jika kami telah menyiapkan data dalam versi [Trial] palsu. <br><br><pre> <code class="sql hljs">[dbo].[Test_FK_Problem] failed: (Error) The <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span> conflicted <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">FOREIGN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> <span class="hljs-string"><span class="hljs-string">"Trial_Fk"</span></span>. The conflict occurred <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> <span class="hljs-string"><span class="hljs-string">"HabrDemo"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-string"><span class="hljs-string">"dbo.tSQLt_tempobject_ba8f36353f7a44f6a9176a7d1db02493"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> <span class="hljs-string"><span class="hljs-string">'TrialID'</span></span>.[<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]{Test_FK_Problem,<span class="hljs-number"><span class="hljs-number">14</span></span>}</code> </pre> <br>  Kesimpulan: palsu semua atau tidak ada.  Jika tidak ada, Anda harus menyiapkan DB dengan semua data uji yang diperlukan. <br><br><h3>  SpyProcedure pada prosedur sistem </h3><br>  Sayangnya, kami tidak dapat memata-matai prosedur sistem: <br><br><pre> <code class="sql hljs">[HabrDemo].[test_test] failed: (Error) Cannot <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> SpyProcedure <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> sys.sp_help because the <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exist[<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>] {tSQLt.Private_ValidateProcedureCanBeUsedWithSpyProcedure,<span class="hljs-number"><span class="hljs-number">7</span></span>}</code> </pre> <br>  Dalam contoh semafor, kami melacak panggilan prosedur [SendEmail], yang dibuat oleh pengembang kami.  Dalam hal ini, itu tidak diperlukan hanya dengan pengujian.  Itu perlu untuk membuat prosedur terpisah karena diperlukan untuk menyiapkan beberapa data sebelum mengirim.  Tetapi Anda harus siap secara mental untuk menulis prosedur interlayer untuk memenuhi tujuan pengujian. <br><br><h1>  Pro </h1><br><h3>  Instalasi cepat </h3><br>  Instalasi tSQLt terdiri dari 2 langkah dan membutuhkan waktu sekitar 2 menit.  Anda perlu mengaktifkan CLR jika saat ini tidak aktif dan menjalankan skrip SQL tunggal.  Itu saja: sekarang Anda dapat menambahkan kelas tes pertama Anda dan menulis kasus uji. <br><br><h3>  Belajar cepat </h3><br>  tSQLt mudah dipelajari.  Butuh sedikit lebih dari satu hari kerja untuk saya.  Saya bertanya pada kolega dan sepertinya butuh sekitar 1 hari kerja untuk orang lain juga.  Saya ragu itu bisa memakan waktu lebih lama. <br><br><h3>  Integrasi CI cepat </h3><br>  Butuh sekitar 2 jam untuk mengatur integrasi CI pada proyek kami.  Waktu dapat bervariasi, tentu saja, tetapi itu bukan masalah secara umum, dan dapat dilakukan dengan cepat. <br><br><h3>  Seperangkat instrumen yang luas </h3><br>  Ini subjektif, tetapi dalam pandangan saya fungsionalitas tSQLt kaya dan bagian terbesar dari kebutuhan dapat dicakup olehnya.  Jika itu tidak cukup, Anda selalu dapat menggunakan prosedur Gagal untuk kasus langka dan canggih. <br><br><h3>  Dokumentasi yang mudah </h3><br>  Panduan resmi nyaman dan konsisten.  Anda dapat dengan mudah memahami penggunaan tSQLt dalam waktu singkat meskipun itu merupakan alat pengujian unit pertama Anda. <br><br><h3>  Hapus keluaran </h3><br>  Output tes dapat diambil dalam format teks ilustrasi: <br><br><pre> <code class="plaintext hljs">[tSQLtDemo].[test_error_messages] failed: (Failure) Expected an error to be raised. [tSQLtDemo].[test_tables_comparison] failed: (Failure) useful and descriptive error message Unexpected/missing resultset rows! |_m_|Column1|Column2| +---+-------+-------+ |&lt; |2 |Value2 | |= |1 |Value1 | |= |3 |Value3 | |&gt; |2 |Value3 | +----------------------+ |Test Execution Summary| +----------------------+ |No|Test Case Name |Dur(ms)|Result | +--+------------------------------------+-------+-------+ |1 |[tSQLtDemo].[test_constraint] | 83|Success| |2 |[tSQLtDemo].[test_trial_view] | 83|Success| |3 |[tSQLtDemo].[test_error_messages] | 127|Failure| |4 |[tSQLtDemo].[test_tables_comparison]| 147|Failure| ----------------------------------------------------------------------------- Msg 50000, Level 16, State 10, Line 1 Test Case Summary: 4 test case(s) executed, 2 succeeded, 2 failed, 0 errored. -----------------------------------------------------------------------------</code> </pre><br>  Ini juga dapat diturunkan dari DB (dapat diklik) ... <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/-f/83/la/-f83lajcz1mfcnkhtttz45b0x3g.png"></a> </div><br>  ... atau bahkan sebagai XML. <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testsuites</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testsuite</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLtDemo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">tests</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"3"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">errors</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">failures</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">timestamp</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2019-06-22T16:46:06"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">time</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0.433"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">hostname</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"BLAHBLAHBLAH\SQL2017"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">package</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLt"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">properties</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testcase</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">classname</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLtDemo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"test_constraint"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">time</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0.097"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testcase</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">classname</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLtDemo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"test_error_messages"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">time</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0.153"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">failure</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">message</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Expected an error to be raised."</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLt.Fail"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testcase</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testcase</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">classname</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLtDemo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"test_trial_view"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">time</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0.156"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system-out</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system-err</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testsuite</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testsuites</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Format terakhir memungkinkan integrasi CI tanpa masalah.  Secara khusus, kami menggunakan tSQLt bersama dengan Atlassian Bamboo. <br><br><h3>  Mendukung redgate </h3><br>  Sebagai salah satu pro, saya dapat menyebutkan dukungan dari salah satu penyedia alat DBA terbesar - RedGate.  Plugin SQL Server Management Studio mereka bernama SQL Test bekerja dengan tSQLt dari awal.  Selain itu, RedGate membantu pengembang utama tSQLt dengan dev-environment, menurut kata-katanya dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">grup Google</a> . <br><br><h1>  Cons </h1><br><h3>  Tidak ada meja sementara yang dipalsukan </h3><br>  tSQLt tidak mengizinkan memalsukan tabel sementara.  Pikiran, jika perlu, Anda dapat menggunakan addon tidak resmi.  Sayangnya, addon ini hanya berfungsi dengan SQL Server 2016+. <br><br><h3>  Bekerja dengan DB luar </h3><br>  tSQLt dirancang untuk bekerja dengan kode dalam DB yang sama di mana kerangka kerja diinstal.  Jadi, tidak mungkin untuk menggunakannya dengan DB luar.  Setidaknya, palsu tidak akan bekerja. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> [tSQLtDemo].[test_outer_db] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> [AdventureWorks2017].[Person].[<span class="hljs-keyword"><span class="hljs-keyword">Password</span></span>]   EXEC tSQLt.FakeTable <span class="hljs-string"><span class="hljs-string">'[AdventureWorks2017].[Person].[Password]'</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> [AdventureWorks2017].[Person].[<span class="hljs-keyword"><span class="hljs-keyword">Password</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">END</span></span></code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ga/au/ny/gaaunygdr124sssxhonbb2s0b_0.png"></div><br>  Kelihatannya asersi berfungsi, tetapi kemampuan kerja mereka tidak dijamin, tentu saja. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> [tSQLtDemo].[test_outer_db_assertions] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">1</span></span> *   <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-comment"><span class="hljs-comment">#Actual   FROM [AdventureWorks2017].[Person].[Password]   SELECT *   INTO #Expected   FROM (          SELECT 'bE3XiWw=' AS [PasswordSalt]   ) expectedresult;   EXEC tSQLt.AssertEqualsTable '#Expected', '#Actual', 'The salt is not salty'; END</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cg/dk/ow/cgdkowych69imevqmbirkkgsniq.png"></div><br><h3>  Bug dokumentasi </h3><br>  Meskipun saya sebutkan di atas bahwa panduannya nyaman dan konsisten, dokumentasi memiliki beberapa masalah.  Ini berisi bagian-bagian yang sudah ketinggalan zaman. <br><br>  Contoh 1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Panduan mulai cepat"</a> menyarankan mengunduh kerangka kerja dari SourceForge. <br>  Mereka pindah dari SourceForge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sejauh tahun 2015</a> . <br><br>  Contoh 2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan ApplyConstraint</a> menggunakan desain besar dengan prosedur Gagal di dalam contoh penangkapan pengecualian.  Ini dapat diganti dengan kode sederhana dan jelas menggunakan ExpectException. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> ConstraintTests.[<span class="hljs-keyword"><span class="hljs-keyword">test</span></span> ReferencingTable_ReferencedTable_FK prevents <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> orphaned <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> EXEC tSQLt.FakeTable <span class="hljs-string"><span class="hljs-string">'dbo.ReferencedTable'</span></span>; EXEC tSQLt.FakeTable 'dbo.ReferencingTable'; EXEC tSQLt.ApplyConstraint 'dbo.ReferencingTable','ReferencingTable_ReferencedTable_FK'; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @ErrorMessage <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @ErrorMessage = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* [NB] Why don't we use ExceptException below? */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRY <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> dbo.ReferencingTable ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, ReferencedTableId ) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> ( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span> ) ; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> TRY <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> CATCH <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @ErrorMessage = ERROR_MESSAGE(); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> CATCH <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> @ErrorMessage <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'%ReferencingTable_ReferencedTable_FK%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> EXEC tSQLt.Fail <span class="hljs-string"><span class="hljs-string">'Expected error message containing ''ReferencingTable_ReferencedTable_FK'' but got: '''</span></span>,@ErrorMessage,<span class="hljs-string"><span class="hljs-string">'''!'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span></code> </pre><br>  Dan ini diharapkan, karena ... <br><br><h3>  Pengabaian sebagian </h3><br>  Ada jeda yang berkepanjangan dalam pengembangan dari awal 2016 hingga Juni 2019. Ya, sayangnya, alat ini sebagian ditinggalkan.  Pengembangan perlahan dimulai pada 2019, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menurut GitHub</a> .  Meskipun Grup Google resmi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memiliki utas di</a> mana Sebastian, pengembang tSQLt utama, ditanya tentang masa depan proyek.  Pertanyaan terakhir ditanyakan pada 2 Maret 2019, tanpa jawaban. <br><br><h3>  Masalah SQL Server 2017 </h3><br>  Instalasi tSQLt mungkin memerlukan beberapa tindakan tambahan jika Anda menggunakan SQL Server 2017. Microsoft menerapkan perubahan keamanan pertama sejak 2012 dalam rilis ini.  Bendera tingkat server "CLR ketat keamanan" telah ditambahkan.  Bendera ini melarang pembuatan rakitan yang tidak ditandatangani (bahkan AMAN).  Deskripsi mendetail pantas mendapatkan artikel yang terpisah (dan, untungnya, kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sudah memiliki artikel</a> yang bagus; lihat juga artikel berikut dalam urutan. Bersiaplah secara mental untuk ini. <br><br>  Tentu saja, saya bisa mengaitkan masalah ini dengan "jebakan", tetapi masalah ini dapat diatasi oleh pengembang tSQLt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masalah GitHub telah muncul</a> .  Namun, itu belum terselesaikan sejak Oktober 2017. <br><br><h1>  Alternatif (±) untuk DBMS lainnya </h1><br>  tSQLt bukan sejenis.  Meskipun Anda tidak dapat menggunakannya dalam DBMS lain karena nuansa CLR dan T-SQL, Anda masih dapat menemukan sesuatu yang serupa.  Perlu disebutkan bahwa alternatif ini tidak terlalu dekat dengan tSQLt, jadi maksud saya pendekatan bertenaga SQL. <br><br>  Sebagai contoh, pengguna PostgreSQL dapat mencoba <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pgTAP</a> .  Ini adalah alat yang dikembangkan dengan baik dan secara aktif menggunakan PL / pgSQL asli untuk pengujian dan format output TAP.  Alat serupa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MyTap</a> dapat membantu Anda dengan tes di bawah MySQL.  Kerangka kerja ini sedikit kurang fungsional daripada pgTAP tetapi masih bisa bermanfaat.  Dan itu dalam pengembangan aktif juga.  Jika Anda adalah pengguna Oracle yang bahagia, Anda memiliki kesempatan untuk menggunakan alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utPLSQL yang</a> sangat kuat.  Ini berkembang sangat aktif dan menyediakan sejumlah besar fitur. <br><br><h1>  Kesimpulan </h1><br>  Saya ingin menyampaikan 2 ide: <br><br>  Yang pertama: kegunaan pengujian kode DB.  Tidak penting jika Anda menggunakan SQL Server, Oracle, MySQL, atau yang lainnya.  Jika DB Anda berisi logika yang belum diuji, Anda mengambil risiko.  Karena semua bug lain dalam semua kode lainnya, bug kode DB dapat merusak produk dan perusahaan yang menyediakannya. <br><br>  Yang kedua: pilihan alat.  Bagi mereka yang bekerja dengan SQL Server, tSQLt, bahkan jika itu bukan pemenang 100%, tentu layak mendapat perhatian.  Meskipun perkembangannya lambat dan beberapa masalah, ini masih merupakan kerangka kerja praktis yang bisa membuat pekerjaan Anda jauh lebih mudah. <br><br><div class="spoiler">  <b class="spoiler_title">Sumber yang membantu saya (daftar tidak lengkap)</b> <div class="spoiler_text">  DbFit - Pengujian Basis Data Otomatis Open Source: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.methodsandtools.com/tools/dbfit.php</a> <br><br>  Dokumentasi DbFit: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://dbfit.github.io/dbfit/docs/</a> <br><br>  Slacker wiki: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/vassilvk/slacker/wiki</a> <br><br>  Dokumentasi TST: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://archive.codeplex.com/projects/TST/4e04e281-9f35-4891-809a-15f09d304f4e</a> <br><br>  Pernyataan NUnit: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/nunit/docs/wiki/Assertions</a> <br><br>  kode utTSQL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://sourceforge.net/p/uttsql/code/HEAD/tree/</a> <br><br>  Penegasan Kelas Junit: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://junit.org/junit4/javadoc/latest/org/junit/Assert.html</a> <br><br>  pgTap: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://pgtap.org/</a> <br><br>  utPLSQL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://utplsql.org/</a> <br><br>  MyTap: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/hepabolu/mytap</a> <br><br>  tSQLt Grup Google: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://groups.google.com/forum/#!forum/tsqlt</a> <br><br>  situs web resmi tSQLt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tsqlt.org/</a> <br><br>  tSQLt GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/tSQLt-org/tSQLt</a> <br><br>  Tren Google: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://bit.ly/2x7BQL6</a> <br><br>  Cara ROLLBACK transaksi saat menguji menggunakan tSQLt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://stackoverflow.com/questions/8973138/how-to-rollback-a-transaction-when-testing-using-tsqltt</a> <br><br>  Apa Pro dan Kontra dari Pengujian Unit Manual terhadap Pengujian Unit Otomatis?: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Https://stackoverflow.com/questions/2948337/what-are-the-pros-and-cons-ofual-unit-testing-against -the-automatic-unit-tes # 2948354</a> <br><br>  Yang Baik, yang Buruk, dan yang Buruk: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://sqlquantumleap.com/2017/08/07/sqlclr-vs-sql-server-2017-part-1-clr-strict-security/</a> <br><br>  Rex Black, Erik Van Veenendal, Dorothy Graham, Yayasan Pengujian Perangkat Lunak, edisi ketiga, 2012 Cengage Learning EMEA <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465567/">https://habr.com/ru/post/id465567/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465551/index.html">September Digest Event TI (Bagian Satu)</a></li>
<li><a href="../id465553/index.html">Bahasa pemrograman Ü. Pendahuluan, motivasi untuk menciptakan, tujuan</a></li>
<li><a href="../id465555/index.html">12 Ketrampilan Lunak yang Membuat Manajer Proyek TI tak terbendung</a></li>
<li><a href="../id465557/index.html">Batas Waktu Pengembangan Produk</a></li>
<li><a href="../id465561/index.html">Apa yang saya pelajari dari seorang programmer terkemuka</a></li>
<li><a href="../id465569/index.html">Peta Pengembangan Pengembang Seluler</a></li>
<li><a href="../id465571/index.html">Cara menjual rokok pria untuk wanita dan membuat orang biadab melindungi diri mereka sendiri: copywriter yang bisa</a></li>
<li><a href="../id465573/index.html">Semua kekuatan IntelliJ IDEA pada contoh satu bahasa (dalam gambar)</a></li>
<li><a href="../id465575/index.html">Operasi Perbandingan di C ++ 20</a></li>
<li><a href="../id465577/index.html">Jenis baru penanda mikro untuk cuplikan interaktif lanjutan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>