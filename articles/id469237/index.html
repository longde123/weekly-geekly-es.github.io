<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∂üèæ üí∞ üêÇ Transformasi Kode Android üñ±Ô∏è ‚è∫Ô∏è üôé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Bagian kedua 
 Alih-alih bergabung 


 Semuanya dimulai dengan fakta bahwa saya ingin mempelajari seluk-beluk pengaturan Gradle, untuk memahami kema...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Transformasi Kode Android</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469237/"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kedua</a> </li></ul><br><h2 id="vmesto-vstupleniya">  Alih-alih bergabung </h2><br><p>  Semuanya dimulai dengan fakta bahwa saya ingin mempelajari seluk-beluk pengaturan Gradle, untuk memahami kemampuannya dalam pengembangan Android (dan memang).  Saya mulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">siklus hidup</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku</a> , secara bertahap menulis tugas-tugas sederhana, mencoba membuat plugin Gradle pertama saya (di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buildSrc</a> ) dan kemudian mulai. </p><br><p>  Memutuskan untuk melakukan sesuatu yang dekat dengan dunia nyata pengembangan Android, ia menulis sebuah plugin yang mem-parsing tata letak file markup xml dan membuat objek Java pada mereka dengan tautan ke tampilan.  Kemudian ia terlibat dalam transformasi manifes aplikasi (ini diperlukan oleh tugas nyata pada draft kerja), karena setelah transformasi manifes mengambil sekitar 5k baris, dan bekerja dalam IDE dengan file xml seperti itu cukup sulit. </p><br><p>  Jadi saya menemukan cara menghasilkan kode dan sumber daya untuk proyek Android, tetapi seiring waktu saya menginginkan sesuatu yang lebih.  Ada gagasan bahwa itu akan keren untuk mengubah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AST</a> (Pohon Sintaks Abstrak) menjadi waktu kompilasi seperti yang dilakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Groovy di luar kotak</a> .  Pemrograman seperti itu membuka banyak kemungkinan, akan ada fantasi. </p><br><p>  Agar teorinya bukan hanya teori, saya memutuskan untuk memperkuat studi tentang topik tersebut dengan menciptakan sesuatu yang berguna untuk pengembangan Android.  Hal pertama yang terlintas dalam pikiran adalah pelestarian negara ketika membuat ulang komponen sistem.  Secara kasar, menyimpan variabel dalam Bundle sesederhana mungkin dengan boilerplate minimal. </p><a name="habracut"></a><br><h2 id="s-chego-nachat">  Di mana untuk memulai? </h2><br><ol><li>  Pertama, Anda perlu memahami cara mendapatkan akses ke file yang diperlukan dalam siklus hidup Gradle di proyek Android, yang akan kami transformasikan nanti. </li><li>  Kedua, ketika kita mendapatkan file yang diperlukan, kita perlu memahami cara mengubahnya dengan benar. </li></ol><br><p>  Mari kita mulai dengan urutan: </p><br><h3 id="poluchaem-dostup-k-faylam-v-moment-kompilyacii">  Akses file pada waktu kompilasi </h3><br><p> Karena kita akan menerima file pada waktu kompilasi, kita memerlukan plugin Gradle yang akan mencegat file dan menangani transformasi.  Plugin dalam hal ini sesederhana mungkin.  Tapi pertama-tama, saya akan menunjukkan kepada Anda bagaimana file modul <code>build.gradle</code> dengan plugin terlihat seperti: </p><br><pre> <code class="plaintext hljs">apply plugin: 'java-gradle-plugin' apply plugin: 'groovy' dependencies { implementation gradleApi() implementation 'com.android.tools.build:gradle:3.5.0' implementation 'com.android.tools.build:gradle-api:3.5.0' implementation 'org.ow2.asm:asm:7.1' }</code> </pre> <br><ol><li>  <code>apply plugin: 'java-gradle-plugin'</code> mengatakan bahwa ini adalah modul dengan plugin grad. </li><li>  <code>apply plugin: 'groovy'</code> diperlukan plugin ini untuk dapat menulis di grooves (tidak masalah di sini, Anda dapat menulis setidaknya Groovy, setidaknya Java, setidaknya Kotlin, sesuka Anda).  Saya awalnya terbiasa menulis plugin pada alur, karena ini memiliki pengetikan dinamis dan kadang-kadang bisa bermanfaat, dan jika tidak diperlukan, Anda cukup meletakkan anotasi <code>@TypeChecked</code> . </li><li>  <code>implementation gradleApi()</code> - hubungkan ketergantungan Gradle API sehingga ada akses ke <code>org.gradle.api.Plugin</code> , <code>org.gradle.api.Project</code> , dll. </li><li>  <code>'com.android.tools.build:gradle:3.5.0'</code> dan <code>'com.android.tools.build:gradle-api:3.5.0'</code> diperlukan untuk mengakses entitas plugin android. </li><li>  Pustaka <code>'com.android.tools.build:gradle-api:3.5.0'</code> untuk mentransformasikan bytecode, kita akan membicarakannya nanti. </li></ol><br><p>  Mari beralih ke plugin itu sendiri, seperti yang saya katakan, ini cukup sederhana: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">YourPlugin</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Project</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Project project)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isAndroidApp = project.plugins.findPlugin(<span class="hljs-string"><span class="hljs-string">'com.android.application'</span></span>) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isAndroidLib = project.plugins.findPlugin(<span class="hljs-string"><span class="hljs-string">'com.android.library'</span></span>) != <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">null</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(!isAndroidApp &amp;&amp; !isAndroidLib)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GradleException( <span class="hljs-string"><span class="hljs-string">"'com.android.application' or 'com.android.library' plugin required."</span></span> ) } BaseExtension androidExtension = project.extensions.findByType(BaseExtension.class) androidExtension.registerTransform(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> YourTransform()) } }</code> </pre> <br><p>  Mari kita mulai dengan <code>isAndroidApp</code> dan <code>isAndroidLib</code> , di sini kita hanya memeriksa bahwa ini adalah proyek / perpustakaan Android, jika tidak, berikan pengecualian.  Selanjutnya, daftarkan <code>YourTransform</code> dalam plugin android melalui <code>androidExtension</code> .  <code>YourTransform</code> adalah suatu entitas untuk memperoleh set file yang diperlukan dan kemungkinan transformasi mereka, ia harus mewarisi kelas abstrak <code>com.android.build.api.transform.Transform</code> . </p><br><p>  Mari kita langsung menuju <code>YourTransform</code> , pertama-tama pertimbangkan metode utama yang perlu didefinisikan ulang: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">YourTransform</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Transform</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> YourTransform.simpleName } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> Set&lt;QualifiedContent.ContentType&gt; getInputTypes() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TransformManager.CONTENT_CLASS } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> Set&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> QualifiedContent.Scope&gt; getScopes() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TransformManager.PROJECT_ONLY } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIncremental</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } }</code> </pre> <br><ul><li>  <code>getName</code> - di sini Anda perlu mengembalikan nama yang akan digunakan untuk tugas transformasi, misalnya, untuk perakitan debug, dalam hal ini tugas akan dipanggil seperti ini: <code>transformClassesWithYourTransformForDebug</code> . </li><li>  <code>getInputTypes</code> - menunjukkan jenis yang kami minati: kelas, sumber daya, atau keduanya (lihat <code>com.android.build.api.transform.QualifiedContent.DefaultContentType</code> ).  Jika Anda menentukan CLASSES maka untuk transformasi kami hanya akan mendapatkan file kelas, dalam hal ini mereka menarik bagi kami. </li><li>  <code>getScopes</code> - menunjukkan cakupan yang akan kita ubah (lihat <code>com.android.build.api.transform.QualifiedContent.Scope</code> ).  Lingkup adalah ruang lingkup file.  Misalnya, dalam kasus saya, ini PROJECT_ONLY, yang berarti kami hanya akan mengubah file-file yang terkait dengan modul proyek.  Di sini Anda juga dapat menyertakan sub-modul, perpustakaan, dll. </li><li>  <code>isIncremental</code> - di sini kami memberi tahu plug-in android apakah transformasi kami mendukung rakitan tambahan: jika benar, maka kita perlu menyelesaikan semua file yang diubah, ditambahkan dan dihapus dengan benar, dan jika salah, maka semua file akan terbang ke transformasi, namun, jika tidak ada perubahan dalam proyek , maka transformasi tidak akan dipanggil. </li></ul><br><p>  Tetap yang paling dasar dan paling <del>  manis </del>  metode di mana transformasi file transform <code>transform(TransformInvocation transformInvocation)</code> akan berlangsung.  Sayangnya, saya tidak dapat menemukan penjelasan normal tentang cara bekerja dengan benar dengan metode ini, saya hanya menemukan artikel berbahasa Mandarin dan beberapa contoh tanpa penjelasan khusus, <a href="">berikut adalah</a> salah satu opsi. </p><br><p>  Apa yang saya pahami saat mempelajari cara bekerja dengan transformator: </p><br><ol><li>  Semua transformer terhubung ke proses perakitan rantai.  Artinya, Anda menulis logika yang akan terjadi <del>  diperas </del>  menjadi proses yang sudah mapan.  Setelah trafo Anda, yang lain akan bekerja, dll. </li><li>  <strong>SANGAT PENTING:</strong> bahkan jika Anda tidak berencana mengubah file apa pun, misalnya, Anda tidak ingin mengubah file jar yang akan sampai kepada Anda, mereka masih perlu disalin ke direktori output Anda tanpa mengubah.  Item ini mengikuti dari yang pertama.  Jika Anda tidak mentransfer file lebih jauh di sepanjang rantai ke transformator lain, maka pada akhirnya file tidak akan ada. </li></ol><br><p>  Pertimbangkan seperti apa bentuk transformasi itu: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TransformInvocation transformInvocation )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> TransformException, InterruptedException, IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.transform(transformInvocation) transformInvocation.outputProvider.deleteAll() transformInvocation.inputs.each { transformInput -&gt; transformInput.directoryInputs.each { directoryInput -&gt; File inputFile = directoryInput.getFile() File destFolder = transformInvocation.outputProvider.getContentLocation( directoryInput.getName(), directoryInput.getContentTypes(), directoryInput.getScopes(), Format.DIRECTORY ) transformDir(inputFile, destFolder) } transformInput.jarInputs.each { jarInput -&gt; File inputFile = jarInput.getFile() File destFolder = transformInvocation.outputProvider.getContentLocation( jarInput.getName(), jarInput.getContentTypes(), jarInput.getScopes(), Format.JAR ) FileUtils.copyFile(inputFile, destFolder) } } }</code> </pre> <br><p>  Di pintu masuk kami, hadir <code>TransformInvocation</code> , yang berisi semua informasi yang diperlukan untuk transformasi lebih lanjut.  Pertama, kita membersihkan direktori tempat file <code>transformInvocation.outputProvider.deleteAll()</code> akan direkam, ini dilakukan, karena transformer tidak mendukung rakitan tambahan dan Anda harus menghapus file lama sebelum transformasi. </p><br><p>  Selanjutnya, kita melihat semua input dan di setiap input kita melihat direktori dan file jar.  Anda mungkin memperhatikan bahwa semua file jar hanya disalin untuk melangkah lebih jauh ke transformator berikutnya.  Selain itu, penyalinan harus terjadi pada direktori <code>build/intermediates/transforms/YourTransform/...</code>  Direktori yang benar dapat diperoleh dengan menggunakan <code>transformInvocation.outputProvider.getContentLocation</code> . </p><br><p>  Pertimbangkan metode yang sudah mengekstraksi file tertentu untuk modifikasi: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transformDir</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File input, File dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dest.exists()) { FileUtils.forceDelete(dest) } FileUtils.forceMkdir(dest) String srcDirPath = input.getAbsolutePath() String destDirPath = dest.getAbsolutePath() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (File file : input.listFiles()) { String destFilePath = file.absolutePath.replace(srcDirPath, destDirPath) File destFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(destFilePath) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.isDirectory()) { transformDir(file, destFile) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.isFile()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.name.endsWith(<span class="hljs-string"><span class="hljs-string">".class"</span></span>) &amp;&amp; !file.name.endsWith(<span class="hljs-string"><span class="hljs-string">"R.class"</span></span>) &amp;&amp; !file.name.endsWith(<span class="hljs-string"><span class="hljs-string">"BuildConfig.class"</span></span>) &amp;&amp; !file.name.contains(<span class="hljs-string"><span class="hljs-string">"R\$"</span></span>)) { transformSingleFile(file, destFile) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { FileUtils.copyFile(file, destFile) } } } }</code> </pre> <br><p>  Di pintu masuk kita mendapatkan direktori dengan kode sumber dan direktori tempat Anda ingin menulis file yang dimodifikasi.  Kami secara rekursif menelusuri semua direktori dan mendapatkan file kelas.  Sebelum transformasi, masih ada pemeriksaan kecil yang memungkinkan Anda untuk menyingkirkan kelas tambahan. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.name.endsWith(<span class="hljs-string"><span class="hljs-string">".class"</span></span>) &amp;&amp; !file.name.endsWith(<span class="hljs-string"><span class="hljs-string">"R.class"</span></span>) &amp;&amp; !file.name.endsWith(<span class="hljs-string"><span class="hljs-string">"BuildConfig.class"</span></span>) &amp;&amp; !file.name.contains(<span class="hljs-string"><span class="hljs-string">"R\$"</span></span>)) { transformSingleFile(file, destFile) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { FileUtils.copyFile(file, destFile) }</code> </pre> <br><p>  Jadi kami sampai pada metode <code>transformSingleFile</code> , yang sudah mengalir ke paragraf kedua dari rencana awal kami </p><br><blockquote>  Kedua, ketika kita mendapatkan file yang diperlukan, kita perlu memahami cara mengubahnya dengan benar. </blockquote><br><h3 id="transformaciya-vo-vsey-ee-krase">  Transformasi dengan segala kejayaannya </h3><br><p>  Untuk transformasi yang kurang nyaman dari file kelas yang dihasilkan, ada beberapa perpustakaan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">javassist</a> , yang memungkinkan Anda untuk memodifikasi bytecode dan kode sumber (tidak perlu untuk mempelajari studi bytecode) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ASM</a> , yang memungkinkan Anda untuk memodifikasi hanya bytecode dan memiliki 2 API yang berbeda. </p><br><p>  Saya memilih ASM, karena menarik untuk menyelami struktur bytecode dan, di samping itu, API Inti mem-parsing file berdasarkan prinsip parser SAX, yang memastikan kinerja tinggi. </p><br><p>  Metode <code>transformSingleFile</code> dapat bervariasi tergantung pada alat modifikasi file yang dipilih.  Dalam kasus saya, tampilannya cukup sederhana: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transformClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String inputPath, String outputPath)</span></span></span><span class="hljs-function"> </span></span>{ FileInputStream is = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(inputPath) ClassReader classReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassReader(is) ClassWriter classWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassWriter(ClassWriter.COMPUTE_FRAMES) StaterClassVisitor adapter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaterClassVisitor(classWriter) classReader.accept(adapter, ClassReader.EXPAND_FRAMES) <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> [] newBytes = classWriter.toByteArray() FileOutputStream fos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(outputPath) fos.write(newBytes) fos.close() }</code> </pre> <br><p>  Kami membuat <code>ClassReader</code> untuk membaca file, kami membuat <code>ClassWriter</code> untuk menulis file baru.  Saya menggunakan ClassWriter.COMPUTE_FRAMES untuk secara otomatis menghitung frame stack, karena saya kurang lebih telah berurusan dengan Lokal dan Args_size (terminologi bytecode), tetapi saya belum melakukan banyak hal dengan frame.  Menghitung frame secara otomatis sedikit lebih lambat daripada melakukannya secara manual. <br>  Kemudian buat <code>StaterClassVisitor</code> Anda yang mewarisi dari <code>ClassVisitor</code> dan melewati classWriter.  Ternyata logika modifikasi file kita ditumpangkan di atas ClassWriter standar.  Di perpustakaan ASM, semua entitas <code>Visitor</code> dibangun dengan cara ini.  Selanjutnya, kami membentuk array byte untuk file baru dan menghasilkan file. </p><br><p>  Rincian lebih lanjut dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi praktis</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari</a> teori yang dipelajari akan masuk. </p><br><h4 id="sohranenie-sostoyaniya-v-bundle-s-pomoschyu-annotacii">  Menyimpan Status dalam Bundel Menggunakan Anotasi </h4><br><p>  Jadi, saya mengatur sendiri tugas untuk menyingkirkan boilerplate penyimpanan data dalam bundel sebanyak mungkin saat membuat ulang Activity.  Saya ingin melakukan semuanya seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivityJava</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@State</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> savedInt = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Tetapi untuk sekarang, untuk memaksimalkan efisiensi, saya melakukan ini (saya akan memberi tahu Anda alasannya nanti): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Stater</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivityJava</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(StateType.INT) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> savedInt = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Dan itu benar-benar berfungsi!  Setelah transformasi, kode <code>MainActivityJava</code> terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Stater</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivityJava</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(StateType.INT) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> savedInt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.savedInt = savedInstanceState.getInt(<span class="hljs-string"><span class="hljs-string">"com/example/stater/MainActivityJava_savedInt"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSaveInstanceState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Bundle outState)</span></span></span><span class="hljs-function"> </span></span>{ outState.putInt(<span class="hljs-string"><span class="hljs-string">"com/example/stater/MainActivityJava_savedInt"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.savedInt); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onSaveInstanceState(outState); }</code> </pre> <br><p>  Idenya sangat sederhana, mari beralih ke implementasi. <br>  API Inti tidak memungkinkan Anda untuk memiliki struktur penuh dari seluruh file kelas, kami perlu mendapatkan semua data yang diperlukan dalam metode tertentu.  Jika Anda melihat <code>StaterClassVisitor</code> , Anda dapat melihat bahwa dalam metode <code>visit</code> kami mendapatkan informasi tentang kelas, di <code>StaterClassVisitor</code> kami memeriksa apakah kelas kami ditandai dengan anotasi <code>@Stater</code> . </p><br><p>  Kemudian <code>ClassVisitor</code> kami berjalan melalui semua bidang kelas, memanggil metode <code>visitField</code> , jika kelas perlu diubah, <code>StaterFieldVisitor</code> kami <code>StaterFieldVisitor</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">FieldVisitor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> access, String name, String descriptor, String signature, Object value)</span></span></span><span class="hljs-function"> </span></span>{ FieldVisitor fv = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.visitField(access, name, descriptor, signature, value) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needTransform) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaterFieldVisitor(fv, name, descriptor, owner) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fv }</code> </pre> <br><p>  <code>StaterFieldVisitor</code> memeriksa anotasi <code>@State</code> dan, pada gilirannya, mengembalikan <code>StateAnnotationVisitor</code> dalam metode <code>visitAnnotation</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">AnnotationVisitor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitAnnotation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String descriptor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible)</span></span></span><span class="hljs-function"> </span></span>{ AnnotationVisitor av = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.visitAnnotation(descriptor, visible) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (descriptor == Descriptors.STATE) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StateAnnotationVisitor(av, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.descriptor, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.owner) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> av }</code> </pre> <br><p>  Yang sudah membentuk daftar bidang yang diperlukan untuk menyimpan / memulihkan: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitEnum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, String descriptor, String value)</span></span></span><span class="hljs-function"> </span></span>{ String typeString = (String) value SaverField field = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SaverField(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.descriptor, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.owner, StateType.valueOf(typeString)) Const.stateFields.add(field) <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.visitEnum(name, descriptor, value) }</code> </pre> <br><p>  Ternyata struktur seperti pohon dari pengunjung kami, yang, sebagai akibatnya, membentuk daftar <code>SaverField</code> SaverField dengan semua informasi yang kami butuhkan untuk menghasilkan kondisi penyimpanan. <br>  Selanjutnya, <code>ClassVisitor</code> kami mulai dijalankan melalui metode dan mentransformasikan <code>onCreate</code> dan <code>onSaveInstanceState</code> .  Jika tidak ada metode yang ditemukan, maka di <code>visitEnd</code> (dipanggil setelah melewati seluruh kelas) mereka dihasilkan dari awal. </p><br><h4 id="gde-zhe-baytkod">  Dimana bytecode-nya? </h4><br><p>  Bagian yang paling menarik dimulai di kelas <code>OnCreateVisitor</code> dan <code>OnSavedInstanceStateVisitor</code> .  Untuk modifikasi bytecode yang benar, perlu setidaknya mewakili sedikit strukturnya.  Semua metode dan opcode ASM sangat mirip dengan instruksi sebenarnya dari batcode, ini memungkinkan Anda untuk beroperasi dengan konsep yang sama. <br>  Pertimbangkan contoh memodifikasi metode <code>onCreate</code> dan membandingkannya dengan kode yang dihasilkan: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.savedInt = savedInstanceState.getInt(<span class="hljs-string"><span class="hljs-string">"com/example/stater/MainActivityJava_savedInt"</span></span>); }</code> </pre> <br><p>  Memeriksa bundel untuk nol terkait dengan instruksi berikut: </p><br><pre> <code class="java hljs">Label l1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Label() mv.visitVarInsn(Opcodes.ALOAD, <span class="hljs-number"><span class="hljs-number">1</span></span>) mv.visitJumpInsn(Opcodes.IFNULL, l1) <span class="hljs-comment"><span class="hljs-comment">//...      mv.visitLabel(l1)</span></span></code> </pre> <br><p>  Dengan kata sederhana: </p><br><ol><li>  Buat label l1 (hanya label yang bisa Anda tuju). </li><li>  Kami memuat ke dalam memori variabel referensi dengan indeks 1. Karena indeks 0 selalu sesuai dengan referensi ini, dalam hal ini 1 adalah referensi ke <code>Bundle</code> dalam argumen. </li><li>  Tanda nol memeriksa dirinya sendiri dan pernyataan goto pada label l1.  <code>visitLabel(l1)</code> ditentukan setelah bekerja dengan bundel. </li></ol><br><p>  Saat bekerja dengan bundel, kami memeriksa daftar bidang yang dihasilkan dan memanggil instruksi <code>PUTFIELD</code> - penugasan ke variabel.  Mari kita lihat kodenya: </p><br><pre> <code class="java hljs">mv.visitVarInsn(Opcodes.ALOAD, <span class="hljs-number"><span class="hljs-number">0</span></span>) mv.visitVarInsn(Opcodes.ALOAD, <span class="hljs-number"><span class="hljs-number">1</span></span>) mv.visitLdcInsn(field.key) <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> StateType type = MethodDescriptorUtils.primitiveIsObject(field.descriptor) ? StateType.SERIALIZABLE : field.type MethodDescriptor methodDescriptor = MethodDescriptorUtils.getDescriptorByType(type, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodDescriptor == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !methodDescriptor.isValid()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"StateType for ${field.name} in ${field.owner} is unknown!"</span></span>) } mv.visitMethodInsn( Opcodes.INVOKEVIRTUAL, Types.BUNDLE, methodDescriptor.method, <span class="hljs-string"><span class="hljs-string">"(${Descriptors.STRING})${methodDescriptor.descriptor}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// cast if (type == StateType.SERIALIZABLE || type == StateType.PARCELABLE || type == StateType.PARCELABLE_ARRAY || type == StateType.IBINDER ) { mv.visitTypeInsn(Opcodes.CHECKCAST, Type.getType(field.descriptor).internalName) } mv.visitFieldInsn(Opcodes.PUTFIELD, field.owner, field.name, field.descriptor)</span></span></code> </pre> <br><p>  <code>MethodDescriptorUtils.primitiveIsObject</code> - di sini kami memeriksa bahwa variabel memiliki tipe wrapper, jika demikian, pertimbangkan tipe variabel sebagai <code>Serializable</code> .  Kemudian pengambil dari bundel dipanggil, dicor jika perlu dan ditugaskan ke variabel. </p><br><p>  Itu saja, pembuatan kode dalam metode <code>onSavedInstanceState</code> terjadi dengan cara yang sama, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">misalnya</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Masalah apa yang Anda temui</b> <div class="spoiler_text"><ol><li>  <code>@Stater</code> pertama yang <code>@Stater</code> anotasi <code>@Stater</code> ditambahkan.  Aktivitas / fragmen Anda dapat diwarisi dari beberapa <code>BaseActivity</code> , yang sangat menyulitkan pemahaman apakah akan menyelamatkan negara atau tidak.  Anda harus memeriksa semua orang tua di kelas ini untuk mengetahui bahwa ini benar-benar sebuah Aktivitas.  Itu juga dapat mengurangi kinerja kompiler (di masa depan ada ide untuk menghilangkan penjelasan <code>@Stater</code> paling efektif). </li><li>  Alasan untuk menetapkan <code>StateType</code> secara eksplisit sama dengan alasan untuk halangan pertama.  Anda perlu mem-parsing kelas lebih lanjut untuk memahami bahwa itu <code>Parcelable</code> atau <code>Serializable</code> .  Tapi rencana sudah punya ide untuk menyingkirkan <code>StateType</code> :). </li></ol></div></div><br><h4 id="nemnogo-o-proizvoditelnosti">  Sedikit tentang kinerja </h4><br><p>  Untuk verifikasi, saya membuat 10 aktivasi, masing-masing dengan 46 bidang tersimpan dari jenis yang berbeda, diperiksa pada perintah <code>./gradlew :app:clean :app:assembleDebug</code> .  Waktu yang dibutuhkan oleh transformasi saya berkisar dari 108 hingga 200 ms. </p><br><h4 id="sovety">  Kiat </h4><br><ul><li><p>  Jika Anda tertarik melihat bytecode yang dihasilkan, Anda dapat menghubungkan <code>TraceClassVisitor</code> (disediakan oleh ASM) ke proses transformasi Anda: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transformClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String inputPath, String outputPath)</span></span></span><span class="hljs-function"> </span></span>{ ... TraceClassVisitor traceClassVisitor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TraceClassVisitor(classWriter, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintWriter(System.out)) StaterClassVisitor adapter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaterClassVisitor(traceClassVisitor) ... }</code> </pre> <br><p>  <code>TraceClassVisitor</code> dalam hal ini akan menulis ke konsol seluruh bytecode dari kelas yang melewatinya, utilitas yang sangat nyaman pada tahap debugging. </p><br></li><li><p>  Jika bytecode dimodifikasi secara tidak benar, kesalahan yang sangat tidak dapat dipahami terbang keluar, jadi jika mungkin ada baiknya untuk mencatat bagian yang berpotensi berbahaya dari kode atau untuk menghasilkan pengecualian Anda. </p><br></li></ul><br><h2 id="podytozhim">  Untuk meringkas </h2><br><p>  Modifikasi kode sumber adalah alat yang ampuh.  Dengan itu, Anda dapat menerapkan banyak ide.  Proguard, ranah, robolectric, dan kerangka kerja lainnya bekerja berdasarkan prinsip ini.  AOP juga dimungkinkan berkat transformasi kode. <br>  Dan pengetahuan tentang struktur bytecode memungkinkan pengembang untuk memahami kode apa yang ditulisnya dikompilasi pada akhirnya.  Dan ketika memodifikasi tidak perlu berpikir dalam bahasa apa kode tersebut ditulis, di Jawa atau di Kotlin, tetapi untuk memodifikasi bytecode secara langsung. </p><br><p>  Topik ini tampak sangat menarik bagi saya, kesulitan utama adalah ketika mengembangkan Transform API dari Google, karena mereka tidak suka dengan dokumentasi dan contoh khusus.  ASM, tidak seperti Transform API, memiliki dokumentasi yang sangat baik, memiliki panduan yang sangat rinci dalam bentuk file pdf dengan 150 halaman.  Dan, karena metode kerangka kerja sangat mirip dengan instruksi bytecode nyata, panduan ini sangat berguna. </p><br><p>  Saya berpikir tentang ini perendaman saya dalam transformasi, bytecode, dan ini belum berakhir, saya akan terus belajar dan, mungkin, menulis sesuatu yang lain. </p><br><h2 id="ssylki">  Referensi </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh Github</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ASM</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel Habr tentang bytecode</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sedikit lagi tentang bytecode</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Transform API</a> <br>  Nah, baca dokumentasinya </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469237/">https://habr.com/ru/post/id469237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469223/index.html">Lampu latar LED sebagai backdoor</a></li>
<li><a href="../id469229/index.html">Proyek klub robotika "GoROBO" - sebuah startup dari akselerator Universitas ITMO membuatnya</a></li>
<li><a href="../id469231/index.html">Malam Ceramah Desain Game</a></li>
<li><a href="../id469233/index.html">Otentikasi Habr Weekly # 20 / 2FA bukanlah obat mujarab, Android 10 Go untuk yang paling lemah, kisah jQuery, film Gates</a></li>
<li><a href="../id469235/index.html">Troldesh dalam topeng baru: gelombang distribusi massa berikutnya dari virus ransomware</a></li>
<li><a href="../id469245/index.html">Solstice mengembangkan ide proyek kelompok untuk mendapatkan energi matahari dari atap rumah</a></li>
<li><a href="../id469249/index.html">Nitter, antarmuka alternatif untuk Twitter</a></li>
<li><a href="../id469253/index.html">Berapa biaya aplikasi untuk membangun</a></li>
<li><a href="../id469257/index.html">Kami mengintegrasikan perintah Linux di Windows menggunakan PowerShell dan WSL</a></li>
<li><a href="../id469259/index.html">Perubahan iklim: kami menganalisis suhu di berbagai kota selama 100 tahun terakhir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>