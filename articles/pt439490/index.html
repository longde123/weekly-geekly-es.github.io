<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèê üë®üèø‚Äçüè´ ü§ß Tipos de refer√™ncia do .NET vs tipos de valor. Parte 2 üèüÔ∏è üë®üèº‚Äçüè≠ üëßüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O tipo de base do objeto e implementa√ß√£o de interfaces. Boxe 


 Parece que chegamos ao inferno e √† mar√© alta e podemos acertar qualquer entrevista, m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tipos de refer√™ncia do .NET vs tipos de valor. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/439490/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a> </p><br><h2 id="the-object-base-type-and-implementation-of-interfaces-boxing">  O tipo de base do objeto e implementa√ß√£o de interfaces.  Boxe </h2><br><p>  Parece que chegamos ao inferno e √† mar√© alta e podemos acertar qualquer entrevista, mesmo a da equipe .NET CLR.  No entanto, n√£o vamos correr para o microsoft.com e procurar vagas.  Agora, precisamos entender como os tipos de valor herdam um objeto se eles n√£o cont√™m uma refer√™ncia ao SyncBlockIndex, n√£o um ponteiro para uma tabela de m√©todos virtuais.  Isso explicar√° completamente nosso sistema de tipos e todas as pe√ßas de um quebra-cabe√ßa encontrar√£o seus lugares.  No entanto, precisaremos de mais de uma frase. </p><br><p>  Agora, lembremos novamente como os tipos de valor s√£o alocados na mem√≥ria.  Eles conseguem o lugar na mem√≥ria exatamente onde est√£o.  Os tipos de refer√™ncia obt√™m aloca√ß√£o no monte de objetos pequenos e grandes.  Eles sempre d√£o uma refer√™ncia ao local na pilha onde o objeto est√°.  Cada tipo de valor possui m√©todos como ToString, Equals e GetHashCode.  Eles s√£o virtuais e substitu√≠veis, mas n√£o permitem herdar um tipo de valor substituindo m√©todos.  Se os tipos de valor usassem m√©todos substitu√≠veis, eles precisariam de uma tabela de m√©todos virtuais para rotear chamadas.  Isso levaria aos problemas de passar estruturas para o mundo n√£o gerenciado: campos extras iriam para l√°.  Como resultado, h√° descri√ß√µes de m√©todos de tipo de valor em algum lugar, mas voc√™ n√£o pode acess√°-los diretamente atrav√©s de uma tabela de m√©todos virtuais. </p><br><p>  Isso pode trazer a ideia de que a falta de heran√ßa √© artificial </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este cap√≠tulo foi traduzido do russo em conjunto pelo autor e por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradutores profissionais</a> .  Voc√™ pode nos ajudar com a tradu√ß√£o do russo ou do ingl√™s para qualquer outro idioma, principalmente para chin√™s ou alem√£o. <br><br>  Al√©m disso, se voc√™ quiser nos agradecer, a melhor maneira de fazer isso √© nos dar uma estrela no github ou no fork do reposit√≥rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><p>  Isso pode trazer a ideia de que a falta de heran√ßa √© artificial: </p><br><ul><li>  h√° heran√ßa de um objeto, mas n√£o √© direta; </li><li> existem ToString, Equals e GetHashCode dentro de um tipo base.  Nos tipos de valor, esses m√©todos t√™m seu pr√≥prio comportamento.  Isso significa que os m√©todos s√£o substitu√≠dos em rela√ß√£o a um <code>object</code> ; </li><li>  al√©m disso, se voc√™ converter um tipo em um <code>object</code> , ter√° todo o direito de chamar ToString, Equals e GetHashCode; </li><li>  ao chamar um m√©todo de inst√¢ncia para um tipo de valor, o m√©todo obt√©m outra estrutura que √© uma c√≥pia de um original.  Isso significa que chamar um m√©todo de inst√¢ncia √© como chamar um m√©todo est√°tico: <code>Method(ref structInstance, newInternalFieldValue)</code> .  De fato, essa chamada passa por <code>this</code> , com uma exce√ß√£o, no entanto.  Uma JIT deve compilar o corpo de um m√©todo, portanto, seria desnecess√°rio compensar os campos da estrutura, saltando sobre o ponteiro para uma tabela de m√©todos virtuais, que n√£o existe na estrutura.  <em>Existe para tipos de valor em outro local</em> . </li></ul><br><p>  Os tipos s√£o diferentes no comportamento, mas essa diferen√ßa n√£o √© t√£o grande no n√≠vel de implementa√ß√£o no CLR.  Falaremos sobre isso um pouco mais tarde. </p><br><p>  Vamos escrever a seguinte linha em nosso programa: </p><br><pre> <code class="plaintext hljs">var obj = (object)10;</code> </pre> <br><p>  Isso nos permitir√° lidar com o n√∫mero 10 usando uma classe base.  Isso √© chamado de boxe.  Isso significa que temos uma VMT para chamar m√©todos virtuais como ToString (), Equals e GetHashCode.  Na realidade, o boxe cria uma c√≥pia de um tipo de valor, mas n√£o um ponteiro para um original.  Isso ocorre porque podemos armazenar o valor original em qualquer lugar: na pilha ou como um campo de uma classe.  Se o convertermos em um tipo de objeto, podemos armazenar uma refer√™ncia a esse valor pelo tempo que desejarmos.  Quando o boxe acontece: </p><br><ul><li>  o CLR aloca espa√ßo no heap para uma estrutura + SyncBlockIndex + VMT de um tipo de valor (para chamar ToString, GetHashCode, Equals); </li><li>  copia uma inst√¢ncia de um tipo de valor l√°. </li></ul><br><p>  Agora, temos uma variante de refer√™ncia de um tipo de valor.  Uma estrutura possui <strong>absolutamente o mesmo conjunto de campos do sistema que um tipo de refer√™ncia</strong> , <br>  tornando-se um tipo de refer√™ncia completo ap√≥s o boxe.  A estrutura se tornou uma classe.  Vamos chamar de cambalhota .NET.  Este √© um nome justo. </p><br><p>  Veja o que acontece se voc√™ usar uma estrutura que implementa uma interface usando a mesma interface. </p><br><pre> <code class="plaintext hljs">struct Foo : IBoo { int x; void Boo() { x = 666; } } IBoo boo = new Foo(); boo.Boo();</code> </pre> <br><p>  Quando criamos a inst√¢ncia Foo, seu valor vai para a pilha de fato.  Em seguida, colocamos essa vari√°vel em uma vari√°vel do tipo de interface e a estrutura em uma vari√°vel do tipo de refer√™ncia.  Em seguida, h√° o boxe e temos o tipo de objeto como sa√≠da.  Mas √© uma vari√°vel do tipo de interface.  Isso significa que precisamos de convers√£o de tipo.  Portanto, a chamada acontece da seguinte maneira: </p><br><pre> <code class="plaintext hljs">IBoo boo = (IBoo)(box_to_object)new Foo(); boo.Boo();</code> </pre> <br><p>  Escrever esse c√≥digo n√£o √© eficaz.  Voc√™ precisar√° alterar uma c√≥pia em vez de um original: </p><br><pre> <code class="plaintext hljs">void Main() { var foo = new Foo(); foo.a = 1; Console.WriteLite(foo.a); // -&gt; 1 IBoo boo = foo; boo.Boo(); // looks like changing foo.a to 10 Console.WriteLite(foo.a); // -&gt; 1 } struct Foo: IBoo { public int a; public void Boo() { a = 10; } } interface IBoo { void Boo(); }</code> </pre> <br><p>  Na primeira vez em que analisamos o c√≥digo, n√£o precisamos saber com o que lidamos no c√≥digo <em>que n√£o seja o nosso</em> e ver uma interface para a interface do IBoo.  Isso nos faz pensar que Foo √© uma classe e n√£o uma estrutura.  Ent√£o n√£o h√° divis√£o visual em estruturas e classes, o que nos faz pensar o <br>  os resultados da modifica√ß√£o da interface devem entrar no foo, o que n√£o acontece, pois boo √© uma c√≥pia do foo.  Isso √© enganoso.  Na minha opini√£o, esse c√≥digo deve receber coment√°rios, para que outros desenvolvedores possam lidar com ele. </p><br><p>  A segunda coisa diz respeito aos pensamentos anteriores de que podemos converter um tipo de um objeto para o IBoo.  Essa √© outra prova de que um tipo de valor em caixa √© uma variante de refer√™ncia de um tipo de valor.  Ou, todos os tipos em um sistema de tipos s√£o tipos de refer√™ncia.  Podemos apenas trabalhar com estruturas como com tipos de valor, passando seu valor inteiramente.  Desreferenciando um ponteiro para um objeto, como voc√™ diria no mundo do C ++. </p><br><p>  Voc√™ pode objetar que, se fosse verdade, ficaria assim: </p><br><pre> <code class="plaintext hljs">var referenceToInteger = (IInt32)10;</code> </pre> <br><p>  Obter√≠amos n√£o apenas um objeto, mas uma refer√™ncia digitada para um tipo de valor em caixa.  Isso destruiria toda a id√©ia dos tipos de valor (isto √©, integridade do valor), permitindo uma √≥tima otimiza√ß√£o, com base em suas propriedades.  Vamos derrubar essa id√©ia! </p><br><pre> <code class="plaintext hljs">public sealed class Boxed&lt;T&gt; { public T Value; [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) { return Value.Equals(obj); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() { return Value.ToString(); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() { return Value.GetHashCode(); } }</code> </pre> <br><p>  Temos um an√°logo completo do boxe.  No entanto, podemos alterar seu conte√∫do chamando m√©todos de inst√¢ncia.  Essas altera√ß√µes afetar√£o todas as partes com uma refer√™ncia a essa estrutura de dados. </p><br><pre> <code class="plaintext hljs">var typedBoxing = new Boxed&lt;int&gt; { Value = 10 }; var pureBoxing = (object)10;</code> </pre> <br><p>  A primeira variante n√£o √© muito atraente.  Em vez de lan√ßar um tipo, criamos bobagens.  A segunda linha √© muito melhor, mas as duas linhas s√£o quase id√™nticas.  A √∫nica diferen√ßa √© que n√£o h√° limpeza de mem√≥ria com zeros durante o encaixe usual ap√≥s alocar mem√≥ria no heap.  A estrutura necess√°ria retira a mem√≥ria imediatamente, enquanto a primeira variante precisa de limpeza.  Isso faz com que ele trabalhe mais do que o boxe usual em 10%. </p><br><p>  Em vez disso, podemos chamar alguns m√©todos para o nosso valor em caixa. </p><br><pre> <code class="plaintext hljs">struct Foo { public int x; public void ChangeTo(int newx) { x = newx; } } var boxed = new Boxed&lt;Foo&gt; { Value = new Foo { x = 5 } }; boxed.Value.ChangeTo(10); var unboxed = boxed.Value;</code> </pre> <br><p>  Temos um novo instrumento.  Vamos pensar no que podemos fazer com isso. </p><br><ul><li>  Nosso tipo <code>Boxed&lt;T&gt;</code> faz o mesmo que o tipo usual: aloca mem√≥ria na pilha, passa um valor para l√° e permite obt√™-lo, fazendo uma esp√©cie de unbox; </li><li>  Se voc√™ perder uma refer√™ncia a uma estrutura em caixa, o GC a coletar√°; </li><li>  No entanto, agora podemos trabalhar com um tipo de caixa, ou seja, chamando seus m√©todos; </li><li>  Al√©m disso, podemos substituir uma inst√¢ncia de um tipo de valor no SOH / LOH por outra.  N√£o pod√≠amos fazer isso antes, pois ter√≠amos que desembalar, mudar a estrutura para outra e voltar ao boxe, dando uma nova refer√™ncia aos clientes. </li></ul><br><p>  O principal problema do boxe √© criar tr√°fego na mem√≥ria.  O tr√°fego de um n√∫mero desconhecido de objetos, cuja parte pode sobreviver at√© a gera√ß√£o um, onde temos problemas com a coleta de lixo.  Haver√° muito lixo e poder√≠amos ter evitado.  Mas quando temos o tr√°fego de objetos de vida curta, a primeira solu√ß√£o √© o pool.  Esse √© o fim ideal do salto mortal do .NET. </p><br><pre> <code class="plaintext hljs">var pool = new Pool&lt;Boxed&lt;Foo&gt;&gt;(maxCount:1000); var boxed = pool.Box(10); boxed.Value=70; // use boxed value here pool.Free(boxed);</code> </pre> <br><p>  Agora o boxe pode funcionar usando um pool, o que elimina o tr√°fego de mem√≥ria durante o boxe.  Podemos at√© fazer os objetos voltarem √† vida no m√©todo de finaliza√ß√£o e se colocar de volta na piscina.  Isso pode ser √∫til quando uma estrutura em caixa passa para c√≥digo ass√≠ncrono que n√£o seja o seu e voc√™ n√£o consegue entender quando se tornou desnecess√°rio.  Nesse caso, ele retornar√° ao pool durante o GC. </p><br><p>  Vamos concluir: </p><br><ul><li>  Se o boxe for acidental e n√£o acontecer, n√£o fa√ßa acontecer.  Isso pode levar a problemas com o desempenho. </li><li>  Se o boxe for necess√°rio para a arquitetura de um sistema, pode haver variantes.  Se o tr√°fego de estruturas em caixas for pequeno e quase invis√≠vel, voc√™ poder√° usar o boxe.  Se o tr√°fego estiver vis√≠vel, conv√©m fazer o agrupamento do boxe, usando uma das solu√ß√µes mencionadas acima.  Ele gasta alguns recursos, mas faz o GC funcionar sem sobrecarga; </li></ul><br><p>  Por fim, vejamos um c√≥digo totalmente impratic√°vel: </p><br><pre> <code class="plaintext hljs">static unsafe void Main() { // here we create boxed int object boxed = 10; // here we get the address of a pointer to a VMT var address = (void**)EntityPtr.ToPointerWithOffset(boxed); unsafe { // here we get a Virtual Methods Table address var structVmt = typeof(SimpleIntHolder).TypeHandle.Value.ToPointer(); // change the VMT address of the integer passed to Heap into a VMT SimpleIntHolder, turning Int into a structure *address = structVmt; } var structure = (IGetterByInterface)boxed; Console.WriteLine(structure.GetByInterface()); } interface IGetterByInterface { int GetByInterface(); } struct SimpleIntHolder : IGetterByInterface { public int value; int IGetterByInterface.GetByInterface() { return value; } }</code> </pre> <br><p>  O c√≥digo usa uma fun√ß√£o pequena, que pode obter um ponteiro de uma refer√™ncia a um objeto.  A biblioteca est√° dispon√≠vel no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">endere√ßo do github</a> .  Este exemplo mostra que o boxe usual transforma int em um tipo de refer√™ncia digitado.  Vamos l√° <br>  veja as etapas do processo: </p><br><ol><li>  Fa√ßa boxe para um n√∫mero inteiro. </li><li>  Obter o endere√ßo de um objeto obtido (o endere√ßo do Int32 VMT) </li><li>  Obter a VMT de um SimpleIntHolder </li><li>  Substitua a VMT de um n√∫mero inteiro em caixa pela VMT de uma estrutura. </li><li>  Transforme unboxing em um tipo de estrutura </li><li>  Exiba o valor do campo na tela, obtendo o Int32, que foi <br>  encaixotado. </li></ol><br><p>  Fa√ßo-o atrav√©s da interface de prop√≥sito, pois quero mostrar que funcionar√° <br>  dessa maneira. </p><br><h3 id="nullablet">  Anul√°vel \ &lt;T&gt; </h3><br><p>  Vale mencionar sobre o comportamento do boxe com tipos de valor Nullable.  Esse recurso dos tipos de valor Nullable √© muito atraente, pois o boxe de um tipo de valor que √© uma esp√©cie de nulo retorna nulo. </p><br><pre> <code class="plaintext hljs">int? x = 5; int? y = null; var boxedX = (object)x; // -&gt; 5 var boxedY = (object)y; // -&gt; null</code> </pre> <br><p>  Isso nos leva a uma conclus√£o peculiar: como null n√£o tem um tipo, o <br>  A √∫nica maneira de obter um tipo diferente do in a box √© o seguinte: </p><br><pre> <code class="plaintext hljs">int? x = null; var pseudoBoxed = (object)x; double? y = (double?)pseudoBoxed;</code> </pre> <br><p>  O c√≥digo funciona apenas porque voc√™ pode converter um tipo para o que quiser <br>  com nulo. </p><br><h2 id="going-deeper-in-boxing">  Aprofundando no boxe </h2><br><p>  Como parte final, gostaria de falar sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tipo System.Enum</a> .  Logicamente, esse deve ser um tipo de valor, pois √© uma enumera√ß√£o usual: alternar n√∫meros para nomes em uma linguagem de programa√ß√£o.  No entanto, System.Enum √© um tipo de refer√™ncia.  Todos os tipos de dados enum, definidos em seu campo e no .NET Framework, s√£o herdados de System.Enum.  √â um tipo de dados de classe.  Al√©m disso, √© uma classe abstrata, herdada de <code>System.ValueType</code> . </p><br><pre> <code class="plaintext hljs"> [Serializable] [System.Runtime.InteropServices.ComVisible(true)] public abstract class Enum : ValueType, IComparable, IFormattable, IConvertible { // ... }</code> </pre> <br><p>  Isso significa que todas as enumera√ß√µes s√£o alocadas no SOH e, quando as usamos, sobrecarregamos o heap e o GC?  Na verdade n√£o, pois apenas as usamos.  Ent√£o, supomos que haja um conjunto de enumera√ß√µes em algum lugar e apenas obtemos suas inst√¢ncias.  N√£o de novo  Voc√™ pode usar enumera√ß√µes em estruturas durante o empacotamento.  Enumera√ß√µes s√£o n√∫meros comuns. </p><br><p>  A verdade √© que o CLR corta a estrutura do tipo de dados ao form√°-la se houver enum <a href="">transformando uma classe em um tipo de valor</a> : </p><br><pre> <code class="plaintext hljs">// Check to see if the class is a valuetype; but we don't want to mark System.Enum // as a ValueType. To accomplish this, the check takes advantage of the fact // that System.ValueType and System.Enum are loaded one immediately after the // other in that order, and so if the parent MethodTable is System.ValueType and // the System.Enum MethodTable is unset, then we must be building System.Enum and // so we don't mark it as a ValueType. if(HasParent() &amp;&amp; ((g_pEnumClass != NULL &amp;&amp; GetParentMethodTable() == g_pValueTypeClass) || GetParentMethodTable() == g_pEnumClass)) { bmtProp-&gt;fIsValueClass = true; HRESULT hr = GetMDImport()-&gt;GetCustomAttributeByName(bmtInternal-&gt;pType-&gt;GetTypeDefToken(), g_CompilerServicesUnsafeValueTypeAttribute, NULL, NULL); IfFailThrow(hr); if (hr == S_OK) { SetUnsafeValueClass(); } }</code> </pre> <br><p>  Por que fazer isso?  Em particular, como a id√©ia de heran√ßa - para fazer uma enum personalizada, voc√™, por exemplo, precisa especificar os nomes dos poss√≠veis valores.  No entanto, √© imposs√≠vel herdar tipos de valor.  Assim, os desenvolvedores o projetaram para ser um tipo de refer√™ncia que pode transform√°-lo em um tipo de valor quando compilado. </p><br><h2 id="what-if-you-want-to-see-boxing-personally">  E se voc√™ quiser ver o boxe pessoalmente? </h2><br><p>  Felizmente, voc√™ n√£o precisa usar um desmontador e entrar na selva de c√≥digos.  Temos os textos de todo o n√∫cleo da plataforma .NET e muitos deles s√£o id√™nticos em termos do .NET Framework CLR e CoreCLR.  Voc√™ pode clicar nos links abaixo e ver a implementa√ß√£o do boxe imediatamente: </p><br><ul><li>  H√° um grupo separado de otimiza√ß√µes, cada uma das quais utiliza um <br>  tipo espec√≠fico de processador: <br><ul><li>  <em><a href="">JIT_BoxFastMP_InlineGetThread</a></em> <br>  (AMD64 - multiprocessador ou GC do servidor, armazenamento local de threads impl√≠cito) </li><li>  <em><a href="">JIT_BoxFastMP</a></em> <br>  (AMD64 - multiprocessador ou GC do servidor) </li><li>  <em><a href="">JIT_BoxFastUP</a></em> <br>  (AMD64 - processador √∫nico ou GC da esta√ß√£o de trabalho) </li><li>  <em><a href="">JIT_TrialAlloc :: GenBox (..)</a></em> <br>  (x86) conectado atrav√©s do JitHelpers </li></ul></li><li>  Em casos gerais, um JIT alinha uma chamada de uma fun√ß√£o auxiliar <br>  <a href="">Compiler :: impImportAndPushBox (..)</a> </li><li>  Vers√£o gen√©rica usa menos otimizado <br>  <a href="">MethodTable :: Box (..)</a> <br><ul><li>  Por fim, [CopyValueClassUnchecked (..)] √© chamado <br>  ( <a href="">https://github.com/dotnet/coreclr/blob/master/src/vm/object.cpp#L1514-L1581</a> ). <br>  Seu c√≥digo mostra por que √© melhor escolher estruturas com o tamanho de at√© 8 bytes inclu√≠do. </li></ul></li></ul><br><p>  Aqui, o √∫nico m√©todo √© usado para descompactar: <br>  <em><a href="">JIT_Unbox (..)</a></em> , que √© um inv√≥lucro em torno de <em><a href="">JIT_Unbox_Helper (..)</a></em> . </p><br><p>  Al√©m disso, √© interessante que ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://stackoverflow.com/questions/3743762/unboxing-does-not-create-a-copy-of-the-value-is-this-right</a> ), unboxing n√£o significa copiar dados para a pilha.  Boxe significa passar um ponteiro para a pilha enquanto testa a compatibilidade dos tipos.  O c√≥digo de opera√ß√£o da IL ap√≥s o unboxing definir√° as a√ß√µes com esse endere√ßo.  Os dados podem ser copiados para uma vari√°vel local ou a pilha para chamar um m√©todo.  Caso contr√°rio, ter√≠amos uma c√≥pia dupla;  primeiro ao copiar do heap para algum lugar e depois para o local de destino. </p><br><h2 id="questions">  Perguntas </h2><br><h3 id="why-net-clr-cant-do-pooling-for-boxing-itself">  Por que o .NET CLR n√£o pode fazer pool para o boxe em si? </h3><br><p>  Se conversarmos com qualquer desenvolvedor Java, saberemos duas coisas: </p><br><ul><li>  Todos os tipos de valor em Java s√£o em caixa, o que significa que n√£o s√£o essencialmente tipos de valor.  Inteiros tamb√©m s√£o in a box. </li><li>  Por motivos de otimiza√ß√£o, todos os n√∫meros inteiros de -128 a 127 s√£o obtidos do conjunto de objetos. </li></ul><br><p>  Ent√£o, por que isso n√£o acontece no .NET CLR durante o boxe?  √â simples  Como podemos alterar o conte√∫do de um tipo de valor em caixa, √© poss√≠vel fazer o seguinte: </p><br><pre> <code class="plaintext hljs">object x = 1; x.GetType().GetField("m_value", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(x, 138); Console.WriteLine(x); // -&gt; 138</code> </pre> <br><p>  Ou assim (C ++ / CLI): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object^ obj)</span></span></span><span class="hljs-function"> </span></span>{ Int32^ i = (Int32^)obj; *i = <span class="hljs-number"><span class="hljs-number">138</span></span>; }</code> </pre> <br><p>  Se lid√°ssemos com o pool, alterar√≠amos todos os aplicativos em 138 para 138, o que n√£o √© bom. </p><br><p>  O pr√≥ximo √© a ess√™ncia dos tipos de valor no .NET.  Eles lidam com valor, o que significa que trabalham mais r√°pido.  O boxe √© raro e a adi√ß√£o de n√∫meros em caixas pertence ao mundo da fantasia e da arquitetura ruim.  Isso n√£o √© de todo √∫til. </p><br><h3 id="why-it-is-not-possible-to-do-boxing-on-stack-instead-of-the-heap-when-you-call-a-method-that-takes-an-object-type-which-is-a-value-type-in-fact">  Por que n√£o √© poss√≠vel fazer boxe na pilha em vez da pilha, quando voc√™ chama um m√©todo que usa um tipo de objeto, que √© realmente um tipo de valor? </h3><br><p>  Se o boxe do tipo de valor for feito na pilha e a refer√™ncia for para o heap, a refer√™ncia dentro do m√©todo poder√° ir para outro lugar, por exemplo, um m√©todo pode colocar a refer√™ncia no campo de uma classe.  O m√©todo ser√° interrompido e o m√©todo que criou o boxe tamb√©m ser√° interrompido.  Como resultado, a refer√™ncia apontar√° para um espa√ßo morto na pilha. </p><br><h3 id="why-it-is-not-possible-to-use-value-type-as-a-field">  Por que n√£o √© poss√≠vel usar o Tipo de valor como um campo? </h3><br><p>  √Äs vezes, queremos usar uma estrutura como um campo de outra estrutura que use a primeira.  Ou mais simples: use a estrutura como um campo de estrutura.  N√£o me pergunte por que isso pode ser √∫til.  N√£o pode.  Se voc√™ usar uma estrutura como seu campo ou atrav√©s da depend√™ncia de outra estrutura, criar√° recurs√£o, o que significa estrutura de tamanho infinito.  No entanto, o .NET Framework tem alguns lugares onde voc√™ pode fazer isso.  Um exemplo √© <code>System.Char</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">que cont√©m a si mesmo</a> : </p><br><pre> <code class="plaintext hljs">public struct Char : IComparable, IConvertible { // Member Variables internal char m_value; //... }</code> </pre> <br><p>  Todos os tipos primitivos do CLR s√£o projetados dessa maneira.  N√≥s, meros mortais, n√£o podemos implementar esse comportamento.  Al√©m disso, n√£o precisamos disso: isso √© feito para dar aos tipos primitivos um esp√≠rito de OOP no CLR. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este charper traduzido do russo como idioma do autor por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradutores profissionais</a> .  Voc√™ pode nos ajudar a criar a vers√£o traduzida deste texto para qualquer outro idioma, incluindo chin√™s ou alem√£o, usando as vers√µes russa e inglesa do texto como fonte. <br><br>  Al√©m disso, se voc√™ quiser dizer "obrigado", a melhor maneira de escolher √© dar uma estrela no reposit√≥rio do github ou do fork <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/sidristij/dotnetbook</a> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt439490/">https://habr.com/ru/post/pt439490/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt439480/index.html">Desista, ou por que seu CRM (e CRM) fica mais lento?</a></li>
<li><a href="../pt439482/index.html">devleads - (des) motiva√ß√£o financeira</a></li>
<li><a href="../pt439484/index.html">Obtendo dados de enumera√ß√£o em uma perspectiva do Automapper</a></li>
<li><a href="../pt439486/index.html">Tipos de refer√™ncia do .NET vs tipos de valor. Parte 1</a></li>
<li><a href="../pt439488/index.html">Grava√ß√£o de v√≠deo de controle de qualidade Meetup</a></li>
<li><a href="../pt439492/index.html">10 dicas para ser um bom l√≠der t√©cnico</a></li>
<li><a href="../pt439496/index.html">Como o faturamento √© feito l√°: quando o cliente e o desenvolvedor falam idiomas diferentes</a></li>
<li><a href="../pt439498/index.html">Em qual hardware analisar uma enorme quantidade de informa√ß√µes?</a></li>
<li><a href="../pt439500/index.html">Por que os captchas se tornam t√£o complicados</a></li>
<li><a href="../pt439502/index.html">Comportamento indefinido e verdade n√£o definida</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>