<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßôüèΩ üìê üë©üèº‚Äçüíº Plantilla arquitect√≥nica "Transacciones macro compartidas para microservicios" ‚õπÔ∏è ü§¶üèª üë©üèº‚Äçü§ù‚Äçüë©üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Publicado por Denis Tsyplakov , arquitecto de soluciones, DataArt 

 Declaraci√≥n del problema. 
 Uno de los problemas al construir arquitecturas de mi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plantilla arquitect√≥nica "Transacciones macro compartidas para microservicios"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dataart/blog/446288/"><img src="https://habrastorage.org/webt/wn/ge/nc/wngencs0zvmck2rkwblk1hxldms.png"><br><br>  <i>Publicado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Denis Tsyplakov</a> , arquitecto de soluciones, DataArt</i> <br><br><h2>  Declaraci√≥n del problema. </h2><br>  Uno de los problemas al construir arquitecturas de microservicios y especialmente al migrar una arquitectura monol√≠tica a microservicios es a menudo las transacciones.  Cada microservicio es responsable de su propio grupo de funciones, posiblemente controla los datos asociados con este grupo y puede atender las solicitudes de los usuarios de manera aut√≥noma o enviando solicitudes a otros microservicios.  Todo esto funciona bien hasta que necesitemos garantizar la coherencia de los datos controlados por diferentes microservicios. <a name="habracut"></a><br><br>  Por ejemplo, nuestra aplicaci√≥n funciona en una gran tienda en l√≠nea.  Entre otras cosas, tenemos tres √°reas de negocio separadas, d√©bilmente interconectadas: <br><br><ol><li>  Almac√©n: qu√©, d√≥nde, c√≥mo y durante cu√°nto tiempo se ha almacenado, cu√°ntos productos de cierto tipo est√°n actualmente en stock, etc. </li><li>  Env√≠o de productos: embalaje, env√≠o, seguimiento de la entrega, an√°lisis de quejas sobre su retraso, etc. </li><li>  Realizaci√≥n de informes de aduanas sobre el movimiento de mercanc√≠as si las mercanc√≠as se env√≠an al extranjero (de hecho, no s√© si en este caso es necesario elaborar algo especialmente, pero aun as√≠ conectar√© los servicios estatales al proceso para agregar drama). </li></ol><br>  Cada una de estas tres √°reas incluye muchas funciones disjuntas y puede representarse como varios microservicios. <br><br>  Hay un problema  Supongamos que una persona compra un producto, lo empaca y lo env√≠a por mensajer√≠a.  Entre otras cosas, debemos indicar que hay una unidad menos de bienes en el almac√©n, observar que el proceso de entrega de bienes ha comenzado, y si los bienes se env√≠an, por ejemplo, a China, para encargarse de los documentos de aduanas.  Si la aplicaci√≥n se bloquea (por ejemplo, un nodo se bloquea) en la segunda o tercera etapa del proceso, nuestros datos llegar√°n a un estado inconsistente, y solo unas pocas fallas pueden provocar problemas bastante desagradables para el negocio (por ejemplo, una visita de los funcionarios de aduanas). <br><br>  En una arquitectura monol√≠tica cl√°sica de este tipo, el problema se resuelve de manera simple y elegante mediante transacciones en la base de datos.  Pero, ¬øy si usamos microservicios?  Incluso si usamos la misma base de datos de todos los servicios (que no es muy elegante, pero en nuestro caso es posible), trabajar con esta base de datos proviene de diferentes procesos, y no podremos extender la transacci√≥n entre los procesos. <br><br><h2>  Soluciones </h2><br>  El problema tiene varias soluciones: <br><br><ol><li>  Por extra√±o que parezca, a veces el problema puede ser ignorado.  Si sabemos que una falla no ocurre m√°s de una vez al mes, y la eliminaci√≥n manual de las consecuencias cuesta dinero aceptable para el negocio, no puede prestar atenci√≥n al problema, por feo que parezca.  No s√© si es posible ignorar las reclamaciones del servicio de aduanas, pero se puede suponer que, en ciertas circunstancias, incluso esto es posible. </li><li> La compensaci√≥n (no se trata de una compensaci√≥n monetaria a la aduana, por ejemplo, pag√≥ una multa) es un grupo de varios pasos que complican la secuencia de procesamiento, pero le permiten detectar y procesar un proceso fallido.  Por ejemplo, antes de comenzar la operaci√≥n, le escribimos a un servicio especial que estamos comenzando la operaci√≥n de env√≠o, y al final marcamos que todo termin√≥ bien.  Luego verificamos peri√≥dicamente para ver si hay operaciones pendientes, y si hay alguna, mirando las tres bases de datos, tratamos de llevar los datos a un estado consistente.  Este es un m√©todo completamente funcional, pero complica significativamente la l√≥gica de procesamiento, y hacerlo para cada operaci√≥n es bastante doloroso. </li><li>  Las transacciones de dos fases, estrictamente hablando, la especificaci√≥n XA +, que le permite crear transacciones que se distribuyen en relaci√≥n con las aplicaciones, es un mecanismo muy pesado que a pocas personas les gusta y, lo que es m√°s importante, pocas personas pueden configurar.  Adem√°s, con microservicios ligeros, es ideol√≥gicamente d√©bilmente compatible. </li><li>  En principio, una transacci√≥n es un caso especial del problema de consenso, y se pueden utilizar numerosos sistemas de consenso distribuidos para resolver el problema (en t√©rminos generales, todo lo que es google con las palabras clave paxos, balsa, zookeeper, etcd, c√≥nsul).  Pero en la aplicaci√≥n pr√°ctica de datos extensos y ramificados de la actividad del almac√©n, todo esto parece a√∫n m√°s complicado que las transacciones en dos fases. </li><li>  Colas y coherencia eventual (coherencia a largo plazo): dividimos la tarea en tres tareas asincr√≥nicas, procesamos secuencialmente los datos, los pasamos entre los servicios de la cola a la cola y utilizamos el mecanismo de confirmaci√≥n de entrega.  En este caso, el c√≥digo no es muy complicado, pero hay algunos puntos a tener en cuenta: <br><ul><li>  La cola garantiza la entrega "una o m√°s veces", es decir, cuando se vuelve a entregar el mismo mensaje, el servicio debe manejar correctamente esta situaci√≥n y no enviar las mercanc√≠as dos veces.  Esto se puede hacer, por ejemplo, a trav√©s del UUID √∫nico del pedido. </li><li>  Los datos en cualquier momento ser√°n ligeramente inconsistentes.  Es decir, los productos primero desaparecer√°n del almac√©n y solo entonces, con un ligero retraso, se crear√° un pedido para su env√≠o.  M√°s tarde, se procesar√°n los datos de aduanas.  En nuestro ejemplo, esto es completamente normal y no causa problemas para el negocio, pero hay casos en que dicho comportamiento de los datos puede ser muy desagradable. </li><li>  Si, como resultado, el primer servicio tiene que devolver algunos datos al usuario, la secuencia de llamadas que finalmente entrega los datos al navegador del usuario puede ser bastante trivial.  El principal problema es que el navegador env√≠a solicitudes sincr√≥nicamente y generalmente espera una respuesta sincr√≥nica.  Si realiza un procesamiento de solicitud asincr√≥nico, debe generar una entrega asincr√≥nica de la respuesta al navegador.  Cl√°sicamente, esto se realiza mediante sockets web o mediante solicitudes peri√≥dicas de nuevos eventos desde el navegador al servidor.  Existen mecanismos, como SocksJS, por ejemplo, que simplifican algunos aspectos de la construcci√≥n de este enlace, pero a√∫n habr√° una complejidad adicional. </li></ul></li></ol><br>  En la mayor√≠a de los casos, la √∫ltima opci√≥n es la m√°s aceptable.  No complica mucho la solicitud de procesamiento, aunque funciona varias veces m√°s, pero, por regla general, esto es aceptable para este tipo de operaci√≥n.  Tambi√©n requiere una organizaci√≥n de datos un poco m√°s compleja para cortar las solicitudes repetidas, pero esto tampoco tiene nada de complicado. <br><br>  Esquem√°ticamente, una de las opciones para procesar transacciones usando colas y Consistencia eventual puede verse as√≠: <br><br><ol><li>  El usuario realiz√≥ una compra, se env√≠a un mensaje al respecto a la cola (por ejemplo, el cl√∫ster RabbitMQ o, si trabajamos en Google Cloud Platform - Pub / Sub).  La cola es persistente, garantiza la entrega una o m√°s veces y es transaccional, es decir, si el servicio que procesa el mensaje cae repentinamente, el mensaje no se perder√°, sino que se entregar√° nuevamente a una nueva instancia del servicio. </li><li>  El mensaje llega al servicio, que marca las mercanc√≠as en el almac√©n como preparadas para el env√≠o y, a su vez, env√≠a el mensaje "Las mercanc√≠as est√°n listas para el env√≠o" a la cola. </li><li>  En el siguiente paso, el servicio responsable del despacho recibe un mensaje sobre la preparaci√≥n para el despacho, crea una tarea de despacho y luego env√≠a un mensaje "se planea el despacho de mercanc√≠as". </li><li>  El siguiente servicio, despu√©s de haber recibido un mensaje de que el env√≠o est√° planeado, comienza el proceso de tr√°mites para la aduana. </li></ol><br>  Adem√°s, se verifica la unicidad de cada mensaje recibido por el servicio, y si un mensaje con tal UUID ya ha sido procesado, se ignora. <br><br>  Aqu√≠, la (s) base (s) de la base de datos en cada momento est√° en un estado ligeramente inconsistente, es decir, las mercanc√≠as en el almac√©n ya est√°n marcadas como en proceso de entrega, pero la tarea de entrega en s√≠ a√∫n no est√° all√≠, aparecer√° en un segundo o dos.  Pero al mismo tiempo, tenemos el 99.999% (de hecho, este n√∫mero es igual al nivel de confiabilidad del servicio de cola) garantiza que aparecer√° la tarea de env√≠o.  Para la mayor√≠a de las empresas, esto es aceptable. <br><br><h2>  ¬øDe qu√© trata el art√≠culo entonces? </h2><br>  En el art√≠culo quiero hablar sobre otra forma de resolver el problema de transaccionalidad en aplicaciones de microservicio.  A pesar del hecho de que los microservicios funcionan mejor cuando cada servicio tiene su propia base de datos, para sistemas peque√±os y medianos, todos los datos, por regla general, encajan f√°cilmente en una base de datos relacional moderna.  Esto es cierto para casi cualquier sistema empresarial interno.  Es decir, a menudo no tenemos una necesidad estricta de compartir datos entre diferentes m√°quinas f√≠sicas.  Podemos almacenar datos de diferentes microservicios en grupos no relacionados de tablas de la misma base de datos.  Esto es especialmente conveniente si est√° dividiendo una aplicaci√≥n antigua y monol√≠tica en servicios y ya ha dividido el c√≥digo, pero los datos a√∫n viven en la misma base de datos.  Sin embargo, el problema de la divisi√≥n de transacciones a√∫n persiste: la transacci√≥n est√° r√≠gidamente vinculada a la conexi√≥n de red y, en consecuencia, al proceso que abri√≥ esta conexi√≥n, y tenemos procesos separados.  Como ser <br><br>  M√°s arriba, describ√≠ varias formas comunes de resolver el problema, pero adem√°s quiero ofrecer otra forma para un caso especial, cuando todos los datos est√°n en la misma base de datos.  No <b>recomiendo intentar implementar</b> este m√©todo <b>en este proyecto</b> , pero es lo suficientemente curioso como para <b>presentarlo</b> en el art√≠culo.  Bueno, de repente ser√° √∫til en alg√∫n caso especial. <br><br>  Su esencia es muy simple.  Una transacci√≥n est√° asociada con una conexi√≥n de red, y la base de datos realmente no sabe qui√©n est√° sentado en ese extremo de la conexi√≥n de red abierta.  A ella no le importa, lo principal es que los comandos correctos se env√≠an al socket.  Est√° claro que generalmente un socket pertenece exclusivamente a un proceso en el lado del cliente, pero veo al menos tres formas de solucionarlo. <br><br><h3>  1. Cambiar el c√≥digo de la base de datos </h3><br>  A nivel de c√≥digo de base de datos para bases de datos, cuyo c√≥digo podemos cambiar, haciendo nuestro propio ensamblaje de base de datos, implementamos el mecanismo para transferir transacciones entre conexiones.  C√≥mo puede funcionar desde el punto de vista del cliente: <br><br><ol><li>  Comenzamos la transacci√≥n, hacemos algunos cambios, es hora de transferir la transacci√≥n al siguiente servicio. </li><li>  Le decimos al DB que nos d√© el UUID de la transacci√≥n y esperemos N segundos.  Si durante este tiempo no llega otra conexi√≥n con este UUID, revierta la transacci√≥n, si es as√≠, transfiera todas las estructuras de datos asociadas con la transacci√≥n a la nueva conexi√≥n y contin√∫e trabajando con ella. </li><li>  Pasamos el UUID al siguiente servicio (es decir, a otro proceso, posiblemente a otra VM). </li><li>  En √©l, abra una conexi√≥n y d√© el comando DB: contin√∫e la transacci√≥n con el UUID especificado. </li><li>  Continuamos trabajando con la base de datos como parte de una transacci√≥n iniciada por otro proceso. </li></ol><br>  Este m√©todo es el m√°s liviano de usar, pero requiere la modificaci√≥n del c√≥digo de la base de datos, los programadores de aplicaciones generalmente no lo hacen, requiere muchas habilidades especiales.  Lo m√°s probable es que sea necesario transferir datos entre los procesos de la base de datos y las bases de datos, cuyo c√≥digo podemos cambiar de manera segura en general, uno: PostgreSQL.  Adem√°s, esto funcionar√° solo para servidores no administrados, no lo utilizar√° en RDS o Cloud SQL. <br><br>  Esquem√°ticamente, se ve as√≠: <br><br><img src="https://habrastorage.org/webt/lc/ok/ia/lcokianx0usjlvmfjo9wnlc1vhy.png"><br><br><h3>  2. Manipulaci√≥n de enchufes </h3><br>  La segunda cosa que viene a la mente es la manipulaci√≥n sutil de las conexiones de la base de datos por sockets.  Podemos hacer un "proxy de socket inverso", que dirige los comandos procedentes de varios clientes a un puerto espec√≠fico en un flujo de comandos a la base de datos. <br><br>  De hecho, esta aplicaci√≥n es muy similar a pgBouncer, solo que, adem√°s de su funcionalidad est√°ndar, realiza algunas manipulaciones con el flujo de bytes de los clientes y puede sustituir a un cliente en lugar de otro por comando. <br><br>  No me gusta mucho este m√©todo, para su implementaci√≥n es necesario limpiar los paquetes binarios que circulan entre el servidor y los clientes.  Y todav√≠a requiere mucha programaci√≥n del sistema.  Lo traje √∫nicamente para completar. <br><br><h3>  3. Gateway JDBC </h3><br>  Podemos hacer un controlador JDBC de puerta de enlace: tomamos el controlador JDBC est√°ndar para una base de datos espec√≠fica, dejemos que sea PostgreSQL.  Ajustamos la clase y hacemos interfaces HTTP a todos sus m√©todos externos (no HTTP, pero la diferencia es peque√±a).  A continuaci√≥n, creamos otro controlador JDBC: una fachada, que redirige todas las llamadas a m√©todos a la puerta de enlace JDBC.  Es decir, de hecho, estamos cortando el controlador existente en dos mitades y conectando estas mitades a trav√©s de la red.  Obtenemos el siguiente diagrama de componentes: <br><br><img src="https://habrastorage.org/webt/zo/f4/z9/zof4z9dt8p2segieoslko79fc_0.png"><br><br>  <i>¬°NOTA!: Como podemos ver, las tres opciones son similares, la √∫nica diferencia es a qu√© nivel transferimos la conexi√≥n y qu√© herramientas usamos para esto.</i> <i><br></i> <br><br>  Despu√©s de eso, le ense√±amos a nuestro controlador a hacer esencialmente el mismo truco con la transacci√≥n UUID que se describe en el m√©todo 1. <br><br>  En el c√≥digo de la aplicaci√≥n Java, el uso de este m√©todo podr√≠a verse as√≠. <br><br><h3>  Servicio A - inicio de transacci√≥n </h3><br>  A continuaci√≥n se muestra el c√≥digo de alg√∫n servicio que inicia una transacci√≥n, realiza cambios en la base de datos y la pasa a otro servicio para completarla.  En el c√≥digo, usamos trabajo directo con clases JDBC.  Por supuesto, nadie hace esto en 2019, pero por simplicidad, el c√≥digo se simplifica. <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    , ,  ‚Äú‚Äù //   Class.forName("org.postgresql.FacadeDriver"); var connection = DriverManager.getConnection( "jdbc:postgresqlfacade://hostname:port/dbname","username", "password"); //  -    statement = dbConnection.createStatement(); var statement.executeUpdate(‚Äúinsert ...‚Äù); /* ,        . transactionUUID(int)  -,     ,   JDBC gateway-.  ResultSet        Varchar,  UUID.            .   ,         UUID.  60 ‚Äî  ,    .        , , JDBCTemplate.      ResultSet */ var rs = statement.executeQuery(‚Äúselect transactionUUID(60)‚Äù); String uuid = extractUUIDFromResultSet(rs); //      remoteServiceProxy.continueProcessing(uuid, otherParams); //          //     . closeEverything(); return;</span></span></code> </pre> <br><h3>  Servicio B - finalizaci√≥n de transacci√≥n </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,     // remoteServiceProxy.continueProcessing(...) //     . Class.forName("org.postgresql.FacadeDriver"); var connection = DriverManager.getConnection( "jdbc:postgresqlfacade://hostname:port/dbname","username", "password"); //     Gateway JDBC,    // .  continue transaction    ,   // gateway JDBC statement = dbConnection.createStatement(); statement.executeUpdate(‚Äúcontinue transaction ‚Äù+uuid); // ,    ,      //      statement.executeUpdate(‚Äúupdate ..."); //   connection.commit(); return;</span></span></code> </pre> <br><h2>  Interacci√≥n con otros componentes y marcos. </h2><br>  Considere los posibles efectos secundarios de tal soluci√≥n arquitect√≥nica. <br><br><h3>  Pool de conexiones </h3><br>  Dado que en realidad tendremos un grupo de conexiones real dentro de la puerta de enlace JDBC, es mejor desactivar los grupos de conexiones en los servicios, ya que capturar√°n y mantendr√°n una conexi√≥n dentro del servicio que podr√≠a ser utilizada por otro servicio. <br><br>  Adem√°s, despu√©s de recibir el UUID y esperar la transferencia a otro proceso, la conexi√≥n esencialmente no funciona, y desde el punto de vista de la interfaz JDBC, se cierra autom√°ticamente, y desde el punto de vista de la puerta de enlace JDBC, debe mantenerse sin dar a nadie m√°s que a qui√©n vendr√° con el UUID deseado. <br><br>  En otras palabras, la gesti√≥n dual del grupo de conexiones en Gateway JDBC y dentro de cada uno de los servicios puede producir errores sutiles y desagradables. <br><br><h3>  Jpa </h3><br>  Con JPA, veo dos posibles problemas: <br><br><ol><li>  Gesti√≥n de transacciones.  Al cometer un JPA, el motor puede pensar que ha guardado todos los datos, mientras que no se ha guardado.  Lo m√°s probable es que la gesti√≥n manual de transacciones y flush () antes de transferir la transacci√≥n resuelvan el problema. </li><li>  Es probable que el cach√© de segundo nivel funcione incorrectamente, pero en sistemas distribuidos su uso es limitado en cualquier caso. </li></ol><br><h3>  Transacciones de primavera </h3><br>  El mecanismo de administraci√≥n de transacciones de Spring, tal vez, no se puede activar, y tendr√° que administrarlos manualmente.  Estoy casi seguro de que se puede expandir, por ejemplo, para escribir un alcance personalizado, pero para decirlo con certeza, necesitamos estudiar c√≥mo se organiza la extensi√≥n Spring Transactions all√≠, pero a√∫n no he buscado all√≠. <br><br><h2>  Pros y contras </h2><br><h3>  Pros </h3><br><ul><li>  Pr√°cticamente no requiere modificaci√≥n del c√≥digo monol√≠tico existente al aserrar. </li><li>  Puede escribir transacciones complejas entre servidores pr√°cticamente sin complejidad de c√≥digo. </li><li>  Le permite hacer un seguimiento de la ejecuci√≥n de transacciones entre servicios. </li><li>  La soluci√≥n es bastante flexible, puede usar transacciones cl√°sicas donde no se requiere distribuci√≥n y compartir la transacci√≥n solo para aquellas operaciones donde se requiere interacci√≥n entre servicios. </li><li>  El equipo del proyecto no est√° obligado a dominar por la fuerza las nuevas tecnolog√≠as.  Las nuevas tecnolog√≠as son, por supuesto, buenas, pero la tarea - es imperativa y urgente (¬°hasta ayer!) Ense√±ar a 20 desarrolladores el concepto de construir sistemas reactivos - puede ser muy poco trivial.  Sin embargo, no hay garant√≠a de que las 20 personas completar√°n la capacitaci√≥n a tiempo. </li></ul><br><h3>  Contras </h3><br><ul><li>  No escalable y, de hecho, no modular a nivel de base de datos, en contraste con una soluci√≥n en cola.  Todav√≠a tiene una base de datos en la que convergen todas las consultas y toda la carga.  En este sentido, la soluci√≥n es un callej√≥n sin salida: si luego desea aumentar la carga o hacer que la soluci√≥n sea modular de acuerdo con los datos, tendr√° que rehacer todo. </li><li>  Debe tener mucho cuidado al transferir una transacci√≥n entre procesos, especialmente procesos escritos en marcos.  Las sesiones tienen su propia configuraci√≥n, y para varios marcos, un cambio repentino en la conexi√≥n con la base de datos puede conducir a una operaci√≥n incorrecta.  Consulte, por ejemplo, la configuraci√≥n de sesi√≥n y las transacciones para PostgreSQL. </li><li>  Cuando dije la idea en el chat de nuestro arquitecto local en DataArt, lo primero que me preguntaron mis colegas fue si estaba bebiendo (¬°no, no bebiendo!).  Pero admito que la idea, digamos, no es la m√°s extendida, y si la implementa en su proyecto, ser√° muy inusual para sus otros participantes. </li><li>  Requiere un controlador JDBC personalizado.  Escribirlo lleva tiempo, debe depurarlo, buscar errores en √©l, incluidos los causados ‚Äã‚Äãpor errores de comunicaci√≥n de red, etc. </li></ul><br><h2>  Advertencia </h2><br>  Te lo advierto una vez m√°s: <b>no intentes repetir este truco</b> <s>en casa</s> en este proyecto, a menos que tengas una explicaci√≥n muy clara de por qu√© lo necesitas, y pruebas convincentes de que no hay otra manera. <br><br>  Todo desde el primero de abril! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446288/">https://habr.com/ru/post/446288/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446278/index.html">El papel del sistema IGF-1 en la modulaci√≥n de la longevidad: contradicciones y una nueva comprensi√≥n desde la perspectiva de los centenarios</a></li>
<li><a href="../446280/index.html">Secci√≥n de Ciencias en DUMP: expande tus horizontes</a></li>
<li><a href="../446282/index.html">¬øC√≥mo implementar r√°pidamente HotSpot con los requisitos de las leyes de la Federaci√≥n Rusa?</a></li>
<li><a href="../446284/index.html">¬øQu√© es ser un l√≠der de equipo?</a></li>
<li><a href="../446286/index.html">Hacking en griego antiguo: resultados de la etapa en l√≠nea de NeoQUEST-2019</a></li>
<li><a href="../446292/index.html">Simplemente no estaba buscando all√≠: c√≥mo encontrar empleados para el proyecto en soporte t√©cnico</a></li>
<li><a href="../446296/index.html">Inmortalidad biol√≥gica, colonizaci√≥n de Marte, Amish, EC1863 y copyrasty. Cap√≠tulo 1. Y el coraz√≥n del cyborg late</a></li>
<li><a href="../446298/index.html">Una herramienta simple para comenzar a usar IA para la toma de decisiones</a></li>
<li><a href="../446300/index.html">C√≥mo coordinar el vuelo de la sonda hacia la estratosfera (lo que encontraremos en la pr√°ctica en el lanzamiento)</a></li>
<li><a href="../446302/index.html">9 citas de Habraseminar 2019 para bloggers, emprendedores y RRHH</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>