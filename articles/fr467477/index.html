<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛈️ 👩🏽‍🎓 🚶🏾 Kubernetes 1.16: Aperçu des faits saillants 🧙🏿 🥇 👨🏿‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, mercredi, la prochaine version de Kubernetes aura lieu - 1.16. Selon la tradition qui s'est développée pour notre blog, pour le dixième a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes 1.16: Aperçu des faits saillants</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/467477/"><img src="https://habrastorage.org/webt/6b/oi/xq/6boixq7wqypazw43aysbw8y9xty.png"><br><br>  Aujourd'hui, mercredi, la prochaine version de Kubernetes <a href="">aura lieu</a> - 1.16.  Selon la tradition qui s'est développée pour notre blog, pour le dixième anniversaire, nous parlons des changements les plus importants de la nouvelle version. <br><br>  Les informations utilisées pour préparer ce matériel sont tirées du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tableau de suivi des améliorations de Kubernetes</a> , de <a href="">CHANGELOG-1.16</a> et des problèmes connexes, des demandes d'extraction, ainsi que des propositions d'amélioration de Kubernetes (KEP).  Alors allons-y! .. <a name="habracut"></a><br><br><h2>  Noeuds </h2><br>  Un très grand nombre d'innovations notables (dans l'état de la version alpha) sont présentées du côté des nœuds des clusters K8s (Kubelet). <br><br>  Tout d'abord, les soi-disant <b>« <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conteneurs éphémères</a> » <i>(conteneurs éphémères) sont</i></b> présentés <b>, conçus pour simplifier le processus de débogage dans les pods</b> .  Le nouveau mécanisme vous permet d'exécuter des conteneurs spéciaux qui démarrent dans l'espace de noms des pods existants et vivent pendant une courte période.  Leur but est d'interagir avec d'autres pods et conteneurs afin de résoudre tout problème et débogage.  Pour cette fonctionnalité, une nouvelle commande de <code>kubectl debug</code> est <code>kubectl debug</code> , similaire en substance à <code>kubectl exec</code> : seulement au lieu de démarrer le processus dans le conteneur (comme dans le cas de <code>exec</code> ), il démarre le conteneur dans pod.  Par exemple, une telle commande connectera un nouveau conteneur au pod: <br><br><pre> <code class="bash hljs">kubectl debug -c debug-shell --image=debian target-pod -- bash</code> </pre> <br>  Des détails sur les conteneurs éphémères (et des exemples de leur utilisation) peuvent être trouvés dans le <a href="">KEP correspondant</a> .  L'implémentation actuelle (dans K8s 1.16) est la version alpha, et parmi les critères pour son transfert vers la version bêta, il y a "tester l'API Ephemeral Containers pour au moins 2 versions [Kubernetes]". <br><br>  <i><b>NB</b> : En substance et même le nom de la fonctionnalité ressemble au plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">kubectl-debug</a> déjà existant, dont nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">déjà parlé</a> .</i>  <i>On suppose qu'avec l'avènement des conteneurs éphémères, le développement d'un plug-in externe séparé s'arrêtera.</i> <br><br>  Une autre innovation, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>PodOverhead</code></a> est conçue pour fournir un <b>mécanisme de calcul des frais généraux des pods</b> , qui peuvent varier considérablement en fonction du temps d'exécution utilisé.  À titre d'exemple, les auteurs de <a href="">ce KEP</a> citent les conteneurs Kata, qui nécessitent le lancement du noyau invité, de l'agent kata, du système init, etc.  Lorsque les frais généraux deviennent si importants, ils ne peuvent pas être ignorés, ce qui signifie qu'un moyen est nécessaire pour les prendre en compte pour d'autres quotas, la planification, etc.  Pour l'implémenter, le champ <code>Overhead *ResourceList</code> a été ajouté à <code>PodSpec</code> (par rapport aux données de <code>RuntimeClass</code> , le cas échéant). <br><br>  Une autre innovation notable est le <i>Node Topology Manager</i> , conçu pour unifier l'approche permettant d'affiner l'allocation des ressources matérielles pour divers composants dans Kubernetes.  Cette initiative est causée par la demande croissante de divers systèmes modernes (du domaine des télécommunications, de l'apprentissage automatique, des services financiers, etc.) pour le calcul parallèle haute performance et la minimisation des retards dans l'exécution des opérations, pour lesquels ils utilisent les capacités avancées d'accélération CPU et matérielle.  De telles optimisations dans Kubernetes ont été réalisées jusqu'à présent grâce à des composants disparates (gestionnaire de CPU, gestionnaire de périphériques, CNI), et maintenant elles ajouteront une interface interne unique qui unifie l'approche et simplifie la connexion de nouveaux composants similaires - appelés soi-disant topologiques - côté Kubelet.  Les détails sont dans le <a href="">KEP correspondant</a> . <br><br><img src="https://habrastorage.org/webt/tq/bs/vr/tqbsvryzr9tnxv_9uldn-ofx1es.png"><br>  <i>Diagramme des composants du gestionnaire de topologie</i> <br><br>  La fonctionnalité suivante <b>vérifie les conteneurs lors du démarrage <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sonde de démarrage</a> )</i></b> .  Comme vous le savez, pour les conteneurs qui fonctionnent longtemps, il est difficile d'obtenir l'état actuel: ils sont soit "tués" avant le début réel de l'opération, soit ils se retrouvent dans une impasse pendant longtemps.  Une nouvelle vérification (activée via la porte de fonctionnalité appelée <code>StartupProbeEnabled</code> ) annule - ou plutôt <code>StartupProbeEnabled</code> - l'action de toute autre vérification jusqu'au moment où le pod a terminé son lancement.  Pour cette raison, la fonctionnalité était à l'origine appelée <a href="">holdoff de sonde de vie de pod-startup</a> .  Pour les pods dont le démarrage est long, vous pouvez interroger l'état à des intervalles de temps relativement courts. <br><br>  De plus, immédiatement en version bêta, une amélioration de RuntimeClass est ajoutée, ajoutant la prise en charge des «clusters hétérogènes».  Avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RuntimeClass Scheduling,</a> il n'est plus nécessaire que chaque nœud prenne en charge chaque RuntimeClass: pour les pods, vous pouvez choisir RuntimeClass sans penser à la topologie du cluster.  Auparavant, pour y parvenir - afin que les pods apparaissent sur les nœuds avec la prise en charge de tout ce dont ils avaient besoin - ils devaient attribuer des règles appropriées à NodeSelector et des tolérances.  <a href="">KEP</a> parle d'exemples d'utilisation et, bien sûr, de détails d'implémentation. <br><br><h2>  Réseau </h2><br>  Deux fonctionnalités réseau importantes qui sont apparues pour la première fois (dans la version alpha) dans Kubernetes 1.16 sont: <br><br><ul><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prise en charge d'une</a> double pile réseau - IPv4 / IPv6</b> - et sa "compréhension" correspondante au niveau des pods, nœuds, services.  Il comprend l'interaction d'IPv4 à IPv4 et d'IPv6 à IPv6 entre les pods, des pods aux services externes, les implémentations de référence (dans le cadre des ponts Bridge CNI, PTP CNI et Host-Local IPAM), ainsi que l'inverse Compatible avec les clusters Kubernetes qui fonctionnent uniquement sur IPv4 ou IPv6.  Les détails d'implémentation sont dans <a href="">KEP</a> . <br><br>  Un exemple de la sortie de deux types d'adresses IP (IPv4 et IPv6) dans la liste des pods: <br><br><pre> <code class="bash hljs">kube-master<span class="hljs-comment"><span class="hljs-comment"># kubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE nginx-controller 1/1 Running 0 20m fd00:db8:1::2,192.168.1.3 kube-minion-1 kube-master#</span></span></code> </pre> <br></li><li>  <b>La nouvelle API pour Endpoint</b> est l' <a href="">API EndpointSlice</a> .  Il résout les problèmes de l'API Endpoint existante avec des performances / évolutivité qui affectent divers composants dans le plan de contrôle (apiserver, etcd, endpoints-controller, kube-proxy).  La nouvelle API sera ajoutée au groupe Discovery API et pourra servir des dizaines de milliers de points de terminaison principaux sur chaque service dans un cluster composé d'un millier de nœuds.  Pour ce faire, chaque service est mappé à N objets <code>EndpointSlice</code> , dont chacun par défaut n'a pas plus de 100 points de terminaison (la valeur est configurable).  L'API EndpointSlice offrira également des opportunités pour son développement futur: prise en charge de nombreuses adresses IP pour chaque module, nouveaux états pour les points de terminaison (non seulement <code>Ready</code> et <code>NotReady</code> ), sous-ensemble dynamique pour les points de terminaison. </li></ul><br>  Le <a href="">finaliseur</a> présenté dans la dernière version appelée <code>service.kubernetes.io/load-balancer-cleanup</code> et attaché à chaque service avec le type <code>LoadBalancer</code> passé à la version bêta.  Au moment de la suppression d'un tel service, il empêche la suppression effective de la ressource jusqu'à ce que le "nettoyage" de toutes les ressources correspondantes de l'équilibreur soit terminé. <br><br><h2>  Machines API </h2><br>  Le véritable «jalon de stabilisation» est fixé dans la zone du serveur API Kubernetes et l'interaction avec lui.  À bien des égards, cela s'est produit en raison du <b>transfert au statut stable de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CustomResourceDefinitions</a> (CRD)</b> qui <b>n'avait pas besoin d'une présentation spéciale</b> , qui avait un statut bêta depuis le lointain Kubernetes 1.7 (et c'est juin 2017!).  La même stabilisation est venue aux caractéristiques qui leur sont liées: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Sous-ressources"</a> avec <code>/status</code> et <code>/scale</code> pour CustomResources; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conversion de</a> version pour CRD, basée sur un webhook externe; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">récemment introduit</a> (dans K8s 1.15) les valeurs par défaut <i>(par défaut)</i> et la suppression automatique des champs <i>(élagage)</i> pour CustomResources; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la possibilité d'</a> utiliser le schéma OpenAPI v3 pour créer et publier la documentation OpenAPI utilisée pour valider les ressources CRD côté serveur. </li></ul><br>  Un autre mécanisme qui est depuis longtemps familier aux administrateurs de Kubernetes: l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>admission webhook</b></a> - est également en version bêta depuis longtemps (depuis K8s 1.9) et a maintenant été déclaré stable. <br><br>  Deux autres fonctionnalités ont atteint la version bêta: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">appliquer côté serveur</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">regarder les signets</a> . <br><br>  Et la seule innovation significative dans la version alpha a été le <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rejet</a> de <code>SelfLink</code></b> - un URI spécial qui représente l'objet spécifié et fait partie d' <code>ListMeta</code> et de <code>ListMeta</code> (c'est-à-dire une partie de tout objet dans Kubernetes).  Pourquoi le refuser?  La motivation «simple» <a href="">sonne</a> comme l'absence de raisons réelles (insurmontables) pour que ce domaine continue d'exister.  Des raisons plus formelles sont d'optimiser les performances (supprimer un champ inutile) et de simplifier le travail de generic-apiserver, qui est obligé de traiter un tel champ d'une manière spéciale (c'est le seul champ qui est défini juste avant la sérialisation de l'objet).  La véritable «obsolescence» (dans la version bêta) de <code>SelfLink</code> arrivera à la version 1.20 de Kubernetes, et la dernière - 1.21. <br><br><h2>  Stockage de données </h2><br>  Le travail principal dans le domaine du stockage, comme dans les versions précédentes, est observé dans le domaine du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">support pour CSI</a> .  Les principaux changements sont les suivants: <br><br><ul><li>  pour la première fois (dans la version alpha) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">, la</a> <b>prise en charge des plug-ins CSI pour les nœuds de travail Windows est apparue</b> : la manière actuelle de travailler avec les référentiels remplacera les plug-ins dans l'arborescence du noyau Kubernetes et les plug-ins FlexVolume basés sur Powershell de Microsoft; <br><br><img src="https://habrastorage.org/webt/4_/6o/h2/4_6oh2zuutje1tcvwqwzhi385m0.png"><br>  <i>Schéma d'implémentation du plug-in CSI Windows Kubernetes</i> <br></li><li>  la possibilité <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de redimensionner les volumes CSI</a> , introduite dans K8s 1.12, est devenue une version bêta; </li><li>  la possibilité d'utiliser CSI pour créer des volumes éphémères locaux ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CSI Inline Volume Support</a> ) a atteint une «augmentation» similaire (de l'alpha à la bêta). </li></ul><br>  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonction de clonage de volumes</a> apparue dans la version précédente de Kubernetes (utilisant des PVC existants comme <code>DataSource</code> pour créer de nouveaux PVC) a également reçu le statut bêta. <br><br><h2>  Planificateur </h2><br>  Deux changements notables dans la planification (tous deux en version alpha): <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>EvenPodsSpreading</code></a> est la possibilité d' <b>utiliser des</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>EvenPodsSpreading</code></a> <b>pour "répartir équitablement" des charges de charges au lieu d'unités logiques d'application</b> (comme Deployment et ReplicaSet) et d'ajuster cette distribution (comme une exigence stricte ou comme une condition modérée, c'est-à-dire une priorité).  Cette fonctionnalité étendra les capacités de distribution existantes des pods prévus, désormais limitées par les <code>PodAntiAffinity</code> <code>PodAffinity</code> et <code>PodAntiAffinity</code> , offrant aux administrateurs un contrôle plus fin dans ce domaine, ce qui signifie une meilleure accessibilité et une consommation de ressources optimisée.  Les détails sont dans le <a href="">KEP</a> . </li><li>  Utilisation de la <i>stratégie BestFit</i> dans la <i>fonction de priorité RequestedToCapacityRatio</i> lors de la planification des pods, qui permet à l' <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">emballage bin</a></b> («emballage dans des conteneurs») d'être utilisé à la fois pour les ressources de base (processeur, mémoire) et étendues (comme le GPU).  Voir <a href="">KEP pour</a> plus de détails. <br><br><img src="https://habrastorage.org/webt/4z/gx/zm/4zgxzmdtmhyg-mmjnw-cccyw8wq.gif"><br>  <i>Planification des pods: avant d'utiliser la politique de meilleur ajustement (directement via le planificateur par défaut) et de l'utiliser (via l'extension du planificateur)</i> </li></ul><br>  De plus, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'</a> opportunité <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est présentée</a> de créer vos propres plugins pour le planificateur en dehors de l'arbre de développement principal de Kubernetes (hors arborescence). <br><br><h2>  Autres changements </h2><br>  Également dans la version Kubernetes 1.16, vous pouvez noter l' <b>initiative visant à <a href="">mettre</a> les métriques existantes en ordre complet</b> , ou plus précisément, conformément aux <a href="">exigences officielles</a> pour l'instrumentation K8.  Ils s'appuient essentiellement sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation Prometheus</a> pertinente.  Les incohérences ont été formulées pour diverses raisons (par exemple, certaines mesures ont été simplement créées avant que les instructions actuelles n'apparaissent), et les développeurs ont décidé qu'il était temps de tout mettre à un seul standard, "en ligne avec le reste de l'écosystème Prometheus".  La mise en œuvre actuelle de cette initiative a le statut de la version alpha, qui augmentera progressivement dans les futures versions de Kubernetes en beta (1.17) et stable (1.18). <br><br>  De plus, les changements suivants peuvent être notés: <br><br><ul><li>  <b>Développement de la prise</b> en <b>charge de Windows</b> avec l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">avènement</a> de l'utilitaire Kubeadm pour ce système d'exploitation (version alpha), la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">possibilité de</a> <code>RunAsUserName</code> pour les conteneurs Windows (version alpha), l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">amélioration de la</a> prise en charge du compte de service géré de groupe (gMSA) vers la version bêta, le support de montage / attachement pour les volumes vSphere. </li><li>  <b>Mécanisme de compression des données repensé dans les réponses API</b> .  Auparavant, un filtre HTTP était utilisé à ces fins, ce qui imposait un certain nombre de restrictions qui empêchaient son inclusion par défaut.  Maintenant, la "compression transparente des requêtes" fonctionne: les clients qui envoient <code>Accept-Encoding: gzip</code> dans l'en-tête reçoivent une réponse compressée dans GZIP si sa taille dépasse 128 Ko.  Les clients en déplacement prennent automatiquement en charge la compression (envoient l'en-tête souhaité), de sorte qu'ils remarquent immédiatement une diminution du trafic.  (Pour d'autres langues, des modifications mineures peuvent être nécessaires.) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Il est devenu possible de faire</a> <b>évoluer HPA de / vers zéro pods sur la base de mesures externes</b> .  Si la mise à l'échelle est basée sur des objets / mesures externes, alors lorsque les charges de travail sont inactives, vous pouvez automatiquement mettre à l'échelle 0 répliques pour économiser les ressources.  Cette fonctionnalité devrait être particulièrement utile dans les cas où les travailleurs demandent des ressources GPU et que le nombre de types différents de travailleurs inactifs dépasse le nombre de GPU disponibles. </li><li>  Un nouveau client - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>k8s.io/client-go/metadata.Client</code></a> - pour un accès "généralisé" aux objets.  Il est conçu pour obtenir facilement des métadonnées (c'est-à-dire la sous-section des <code>metadata</code> ) à partir des ressources du cluster et effectuer des opérations avec elles dans la catégorie de collecte de déchets et des quotas. </li><li>  Kubernetes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peut désormais être construit</a> sans fournisseurs de cloud obsolètes (dans l'arborescence «intégrée») (version alpha). </li><li>  La capacité expérimentale (version alpha) d'appliquer des correctifs kustomize pendant les opérations d' <code>init</code> , de <code>join</code> et de <code>upgrade</code> a été <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ajoutée à l'</a> utilitaire kubeadm.  Pour plus de détails sur l'utilisation de l' <code>--experimental-kustomize</code> , voir <a href="">KEP</a> . </li><li>  Le nouveau noeud final pour apiserver est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>readyz</code></a> , ce qui vous permet d'exporter des informations de préparation.  Le serveur API a également un indicateur <code>--maximum-startup-sequence-duration</code> , qui vous permet d'ajuster ses redémarrages. </li><li>  Deux <b>fonctionnalités pour Azure sont</b> déclarées stables: la prise en charge des zones de disponibilité et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">groupe de ressources croisées</a> (RG).  De plus, Azure a ajouté: <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prise en charge de l'authentification</a> AAD et ADFS </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">annotation</a> <code>service.beta.kubernetes.io/azure-pip-name</code> pour spécifier l'IP publique de l'équilibreur de charge; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Possibilité de</a> configurer <code>LoadBalancerName</code> et <code>LoadBalancerResourceGroup</code> . </li></ul></li><li>  AWS prend en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">charge</a> EBS sur Windows et l'API EC2 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">optimisée</a> appelle <code>DescribeInstances</code> . </li><li>  Kubeadm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">migre</a> désormais lui-même <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sa</a> configuration CoreDNS lors de la mise à niveau vers CoreDNS. </li><li>  Les fichiers binaires <b>etcd</b> dans l'image Docker correspondante sont exécutables dans le monde entier, ce qui vous permet d'exécuter cette image sans avoir besoin des privilèges root.  De plus, l'image de migration etcd a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">supprimé la</a> prise en charge de la version etcd2. </li><li>  <a href="">Cluster Autoscaler 1.16.0 est</a> passé à l'utilisation de l'image sans distraction comme image de base, a amélioré les performances et a ajouté de nouveaux fournisseurs de cloud (DigitalOcean, Magnum, Packet). </li><li>  Mises à jour du logiciel utilisé / dépendant: Go 1.12.9, etcd 3.3.15, CoreDNS 1.6.2. </li></ul><br><h2>  PS </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kubernetes 1.15: un aperçu des principales innovations</a> »; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kubernetes 1.14: un aperçu des principales innovations</a> »; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kubernetes 1.13: un aperçu des principales innovations</a> »; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kubernetes 1.12: un aperçu des principales innovations</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467477/">https://habr.com/ru/post/fr467477/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467463/index.html">Juste la division, ou comment créer une théorie mathématique et y gagner 400 000 $. Troisième série, finale</a></li>
<li><a href="../fr467465/index.html">Le cloud sauvera-t-il les smartphones ultra-économiques</a></li>
<li><a href="../fr467471/index.html">Soul Mikrotik contre ILV sans âme et le même fournisseur</a></li>
<li><a href="../fr467473/index.html">Et plus sur les sortes</a></li>
<li><a href="../fr467475/index.html">Renvoyez Thread.Abort () à .NET Core. Livraison d'applications avec sa version de CoreCLR et CoreFX</a></li>
<li><a href="../fr467479/index.html">Kir Shatrov: Shopify a commencé avec Rails et ici, ils aiment sincèrement ce cadre.</a></li>
<li><a href="../fr467485/index.html">Résolution de problèmes avec pwnable.kr 23 - calculatrice md5. Nous traitons avec Stack Canary. Connexion des bibliothèques C en python</a></li>
<li><a href="../fr467487/index.html">À propos de l'avenir des paiements par blockchain et crypto-monnaie</a></li>
<li><a href="../fr467489/index.html">Ce sont des variables statiques étranges en PHP</a></li>
<li><a href="../fr467493/index.html">Comment devenir moins accessible à un attaquant potentiel sur Internet. Expérience personnelle et observations</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>