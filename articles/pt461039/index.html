<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏾 😀 💐 O livro “Algoritmo Perfeito. Algoritmos de grafos e estruturas de dados " 👋🏾 🕺🏿 😇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi, habrozhiteli! Algoritmos são o coração e a alma da ciência da computação. Você não pode ficar sem eles, eles estão por toda parte - desde roteamen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O livro “Algoritmo Perfeito. Algoritmos de grafos e estruturas de dados "</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/461039/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/e5/2z/76/e52z769bpr1nib4vz_bij_xvkgo.jpeg" align="left" alt="imagem"></a>  Oi, habrozhiteli!  Algoritmos são o coração e a alma da ciência da computação.  Você não pode ficar sem eles, eles estão por toda parte - desde roteamento de rede e cálculos genômicos até criptografia e aprendizado de máquina.  O "Algoritmo Perfeito" o transformará em um verdadeiro profissional que definirá tarefas e as solucionará com maestria na vida e em uma entrevista ao contratar qualquer empresa de TI. <br><br>  No segundo livro, Tim Rafgarden, o guru dos algoritmos, fala sobre a pesquisa de gráficos e sua aplicação, o algoritmo de pesquisa de caminho mais curto e o uso e implementação de algumas estruturas de dados: pilhas, árvores de pesquisa, tabelas de hash e o filtro Bloom. <br><br>  Este post apresenta um trecho de Bloom Filters: The Basics. <br><a name="habracut"></a><br><h3>  Sobre o que é este livro </h3><br>  A segunda parte do livro “Algoritmo Perfeito” é um curso introdutório sobre os fundamentos da alfabetização nos três tópicos a seguir. <br><br>  <b>Pesquisa e aplicações gráficas</b> .  Os gráficos modelam vários tipos diferentes de redes, incluindo estradas, comunicação, redes sociais e redes de dependências entre tarefas.  Os gráficos podem ser complexos, mas existem algumas primitivas incrivelmente rápidas para falar sobre a estrutura dos gráficos.  Começaremos com algoritmos de busca de gráfico em tempo linear, desde aplicativos que vão da análise de rede até a construção de uma sequência de operações. <br><br>  <b>Os caminhos mais curtos</b> .  No problema do caminho mais curto, o objetivo é calcular a melhor rota da rede do ponto A ao ponto B. Essa tarefa tem aplicações óbvias, como o cálculo de rotas de tráfego, e também aparece mascarada em muitas outras tarefas universais.  Generalizaremos um de nossos algoritmos de busca de gráficos e chegaremos ao famoso algoritmo de busca de caminho mais curto da Dijkstra. <br><br>  <b>Estruturas de dados</b> .  Este livro fará de você um usuário altamente instruído de várias estruturas de dados diferentes projetadas para oferecer suporte a um conjunto de objetos em evolução com suas chaves associadas.  O objetivo principal é desenvolver uma intuição sobre qual estrutura de dados é adequada para seu aplicativo.  Seções adicionais fornecem diretrizes para implementar essas estruturas de dados do zero. <br><br>  Primeiro, discutimos pilhas que podem identificar rapidamente o objeto armazenado com a menor chave e também são úteis para classificar, implementar uma fila de prioridade e implementar o algoritmo quase linear-temporal de Dijkstra.  As árvores de pesquisa mantêm a ordem completa das chaves nos objetos armazenados e suportam uma gama ainda maior de operações.  As tabelas de hash são otimizadas para operações de pesquisa ultra-rápidas e são difundidas em programas modernos.  Também observamos o filtro Bloom, um parente próximo da tabela de hash, que usa menos espaço devido a erros aleatórios. <br><br>  Você pode se familiarizar com o conteúdo do livro em mais detalhes nas seções “Conclusões”, que completam cada capítulo e identificam os pontos mais importantes.  As seções do livro, marcadas com um asterisco, são as mais avançadas em termos do nível de informação apresentado.  Se o livro for projetado para uma familiarização superficial com o tópico, o leitor poderá ignorá-los sem perder a integridade dos escritos. <br><br>  <b>Tópicos abordados em três outras partes</b> .  A primeira parte do livro “Perfect Algorithm.  Fundamentos ”abrange notações assintóticas (a notação O-large e seus parentes próximos), algoritmos de“ dividir e conquistar ”e o principal teorema da relação de recorrência - o método principal, classificação rápida aleatória e sua análise e algoritmos de seleção linear-temporal.  A terceira parte trata de algoritmos gananciosos (planejamento, árvores abrangentes mínimas, clustering, códigos de Huffman) e programação dinâmica (problema de mochila, alinhamento de sequência, caminhos mais curtos, árvores de pesquisa ideais).  A quarta parte é dedicada à integridade do NP, o que significa para um projetista de algoritmos e estratégias para resolver problemas insolúveis em computação, incluindo análise heurística e pesquisa local. <br><br><h3>  12.5  Filtros Bloom: O básico </h3><br>  Os filtros Bloom são parentes próximos de tabelas de hash.  Eles são muito compactos, mas cometem erros periodicamente.  Esta seção descreve como os filtros Bloom são bons e como eles são implementados, enquanto a seção 12.6 estabelece uma curva de compromisso entre a quantidade de espaço usado pelo filtro e sua taxa de erro. <br><br><h3>  12.5.1  Operações Suportadas </h3><br>  O motivo da existência de filtros Bloom é essencialmente o mesmo de uma tabela de hash: operações de inserção e exibição super rápidas, graças às quais você pode se lembrar rapidamente do que viu e do que não viu.  Por que deveríamos ser incomodados por uma estrutura de dados diferente com o mesmo conjunto de operações?  Como os filtros Bloom são preferíveis às tabelas de hash em aplicativos em que o espaço vale seu peso em ouro, e um erro aleatório não é um obstáculo para a transação. <br><br>  Como tabelas de hash com endereçamento aberto, os filtros Bloom são muito mais fáceis de implementar e imaginar quando suportam apenas as operações Insert e View (e sem a operação Delete).  Vamos nos concentrar neste caso. <br><br><blockquote>  FILTROS DE FLOR: OPERAÇÕES SUPORTADAS <br><br>  Visualização: com a tecla k, retorne “yes” se k tiver sido inserido anteriormente no filtro Bloom e “no” caso contrário. <br>  Colar: adicione uma nova chave k ao filtro Bloom. </blockquote><br>  Os filtros Bloom são muito eficientes espacialmente;  normalmente, eles podem exigir apenas 8 bits por inserção.  Isso é inacreditável, pois 8 bits é completamente insuficiente para lembrar até mesmo uma chave de 32 bits ou um ponteiro para um objeto!  Por esse motivo, a operação View no filtro Bloom retorna apenas a resposta “yes” / “no”, enquanto na tabela de hash, essa operação retorna um ponteiro para o objeto desejado (se for encontrado).  É por isso que a operação Inserir agora aceita apenas a chave, e não o (ponteiro para) o objeto. <br><br>  Ao contrário de todas as outras estruturas de dados que estudamos, os filtros Bloom podem estar errados.  Existem dois tipos de erros: negativos negativos quando a operação View retorna "false", mesmo que a chave solicitada já tenha sido inserida anteriormente, e declarações falsas (ou disparam) quando a operação View retorna "true", embora a chave solicitada ainda não tenha sido inserida no passado .  Na seção 12.5.3, veremos que os filtros Bloom básicos nunca sofrem com falsos negativos, mas podem ter "elementos fantasmas" na forma de declarações falsas.  A Seção 12.6 mostra que a frequência de declarações falsas pode ser controlada ajustando adequadamente o uso do espaço.  Uma implementação típica de um filtro Bloom pode ter uma taxa de erro de cerca de 1% ou 0,1%. <br><br>  Os tempos de execução para as operações Insert e View são tão rápidos quanto na tabela de hash.  E melhor ainda, é garantido que essas operações sejam executadas em tempo constante, independentemente da implementação do filtro Bloom e do conjunto de dados1.  No entanto, a implementação e o conjunto de dados afetam a taxa de erro do filtro. <br><br>  Para resumir as vantagens e desvantagens dos filtros Bloom sobre tabelas de hash: <br><br><blockquote>  FILTRO DE FLOR CONTRA MESAS DE HASH <br><br>  1. Prós: mais espacialmente eficazes. <br><br>  2. Prós: operações de tempo permanente garantidas para cada conjunto de dados. <br><br>  3. Contras: não é possível armazenar ponteiros para objetos. <br><br>  4. Contras: exclusões mais complexas em comparação com uma tabela de hash com uma embreagem. <br><br>  5. Contras: probabilidade diferente de zero de uma declaração falsa. </blockquote><br>  A lista de indicadores para os filtros Bloom básicos é a seguinte. <br><br>  Quadro 12.4  Filtros Bloom básicos: operações suportadas e seu tempo de execução.  O sinal da adaga (†) indica que a operação View tem uma probabilidade controlável, mas diferente de zero, de declarações falsas <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j2/s0/bc/j2s0bcwhevqsy2-scnfyznyywpi.png" alt="imagem"></div><br>  Os filtros Bloom devem ser usados ​​em vez de tabelas de hash em aplicativos em que suas vantagens são importantes e suas desvantagens não são um obstáculo para a transação. <br><br><blockquote>  QUANDO USAR O FILTRO DE FLOR <br><br>  Se um aplicativo requer uma pesquisa rápida com um conjunto de objetos em evolução dinâmica, o espaço vale seu peso em ouro e um pequeno número aceitável de declarações falsas, então o filtro Bloom geralmente é a estrutura de dados preferida. </blockquote><br><h3>  12.5.2  Aplicações </h3><br>  A seguir, há três usos com verificações repetidas, nas quais economizar espaço pode ser importante e declarações falsas não são um obstáculo para a transação. <br><br>  Corretor ortográfico.  Na década de 1970, os filtros Bloom eram usados ​​para implementar verificadores ortográficos - verificadores ortográficos.  No estágio de pré-processamento, cada palavra no dicionário é inserida no filtro Bloom.  A ortografia de um documento se resume a uma operação: observe uma palavra em um documento, marcando as palavras para as quais essa operação retorne "não". <br><br>  Neste apêndice, uma declaração falsa corresponde a uma palavra inválida que o verificador ortográfico aceita inadvertidamente.  Tais erros não tornaram ideal o corretor ortográfico.  No entanto, no início da década de 1970, o espaço valia seu peso em ouro; portanto, o uso de filtros Bloom naquela época era uma estratégia em que todos ganhavam. <br><br>  <b>Senhas proibidas</b> .  Um aplicativo antigo que permanece válido até hoje controla senhas proibidas - senhas muito comuns ou fáceis de adivinhar.  Inicialmente, todas as senhas proibidas são inseridas no filtro Bloom;  senhas proibidas adicionais podem ser inseridas posteriormente, conforme necessário.  Quando um usuário tenta definir ou redefinir sua senha, o sistema procura a senha proposta no filtro Bloom.  Se a pesquisa retornar "yes", o usuário será solicitado a tentar novamente com uma senha diferente.  Aqui, uma declaração falsa é traduzida em uma senha forte, que o sistema rejeita. <br><br>  Desde que a taxa de erro não seja muito alta, diga não mais que 1% ou 0,1%, isso não importa muito.  De tempos em tempos, alguns usuários precisarão de uma tentativa adicional para encontrar uma senha aceitável pelo sistema. <br><br>  <b>Roteadores da Internet</b> .  Um número de aplicativos impressionantes de hoje dos filtros Bloom ocorre na Internet, onde os pacotes de dados passam por roteadores com velocidade de streaming.  Há muitas razões pelas quais um roteador pode querer se lembrar rapidamente do que viu no passado.  Por exemplo, um roteador pode querer encontrar o endereço IP de origem de um pacote na lista de endereços IP bloqueados, rastrear o conteúdo do cache para evitar visualizações espúrias do cache ou manter estatísticas que ajudem a identificar um ataque à rede de negação de serviço.  A taxa de chegada de pacotes requer visualizações super rápidas, e a memória limitada do roteador faz com que o espaço valha seu peso em ouro.  Esses aplicativos são gerenciados diretamente pelo filtro Bloom. <br><br><h3>  12.5.3  Implementação </h3><br>  Olhando dentro do filtro Bloom, você pode ver uma implementação elegante.  A estrutura de dados suporta uma seqüência de n bits ou, da mesma forma, uma matriz A de comprimento n na qual cada elemento é 0 ou 1. (Todos os elementos são inicializados em zero.) Essa estrutura também usa m funções de hash h1, h2, ..., hm , enquanto cada um mapeia o universo U de todas as chaves possíveis para o conjunto {0, 1, 2, ..., n - 1} de posições na matriz.  O parâmetro m é proporcional ao número de bits usado pelo filtro Bloom para inserção e, como regra, é uma pequena constante (por exemplo, 5). <br><br>  Sempre que uma chave é inserida em um filtro Bloom, cada uma das funções de m hash define um sinalizador, configurando o bit correspondente da matriz A como 1. <br><br><blockquote>  FILTRO DE FLOR: INSERIR (NA CHAVE) <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> to m <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> A[hi(k)] := <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </blockquote><br>  Por exemplo, se m = 3 e h1 (k) = 23, h2 (k) = 17 e h3 (k) = 5, inserir k faz com que os 5º, 17º e 23º bits da matriz sejam definidos iguais 1 (Fig. 12.5). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ma/-d/zf/ma-dzftjbgtmytk1uoelbb0q17o.png" alt="imagem"></div><br>  Na operação Exibir, o filtro Bloom procura a impressão digital que pode ter permanecido na inserção k. <br><br><blockquote>  FILTRO DE FLOR: VISTA (CHAVE CHAVE) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> to m <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> A [hi (k)] = <span class="hljs-number"><span class="hljs-number">0</span></span> then <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> «» <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> «»</code> </pre> </blockquote><br>  Agora podemos ver por que os filtros Bloom não podem sofrer falsos negativos.  Quando a tecla k é inserida, os m bits correspondentes são definidos como 1. Durante a vida útil do filtro Bloom, os bits podem alterar seu valor de 0 para 1, mas não vice-versa.  Assim, esses m bits permanecem 1 para sempre.  É garantido que cada operação subsequente do View k retorne a resposta correta. <br><br>  Também podemos ver como surgem afirmações falsas.  Suponha que m = 3 e as quatro chaves k1, k2, k3, k4 tenham os seguintes valores de hash: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m0/uo/7r/m0uo7rbq7ewvpqhhmpvdmx8pfs4.png" alt="imagem"></div><br>  Suponha que inserimos k1, k2, k3 e k4 em um filtro Bloom (Figura 12.6).  Essas três inserções levam a um total de nove bits sendo definido como 1, incluindo três bits na impressão digital da chave k1 (5, 17 e 23).  Nesse ponto, o filtro Bloom não pode mais distinguir se a chave k1 foi inserida ou não.  Mesmo que k1 não tenha sido inserido no filtro, a pesquisa retornará "yes", que é uma declaração falsa. <br><br>  Intuitivamente, podemos supor que, com um aumento no tamanho n do filtro Bloom, o número de sobreposições entre as impressões digitais de chaves diferentes diminua, o que, por sua vez, leva a um número menor de declarações falsas.  Mas o objetivo principal do filtro Bloom é economizar espaço.  Existe um meio termo onde n e a frequência de declarações falsas são simultaneamente pequenas?  A resposta não é óbvia e requer algumas análises matemáticas realizadas na próxima seção. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/ib/_o/gzib_oomyz17bbrtney0kyxiru4.png" alt="imagem"></div><br><br>  »Mais informações sobre o livro podem ser encontradas no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site do editor</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conteúdo</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trecho</a> <br><br>  Para Khabrozhiteley 20% de desconto no cupom - <b>Algoritmos</b> <br>  Após o pagamento da versão impressa do livro, um livro eletrônico é enviado por e-mail. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461039/">https://habr.com/ru/post/pt461039/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461029/index.html">Um lago de dados de marketing - de tabelas monstruosas a relatórios e visualizações</a></li>
<li><a href="../pt461031/index.html">Conectamos mapas on-line ao navegador no smartphone. Parte 1 - mapas rasterizados padrão</a></li>
<li><a href="../pt461033/index.html">De onde vem essa configuração? [Debian / Ubuntu]</a></li>
<li><a href="../pt461035/index.html">Episódios instrutivos da série Silicon Valley (Temporada 1)</a></li>
<li><a href="../pt461037/index.html">E aqui estou eu "real"</a></li>
<li><a href="../pt461041/index.html">Arredondado ou com ângulo agudo?</a></li>
<li><a href="../pt461043/index.html">Gerenciamento de conflitos em um ato de equilíbrio de equipe ou uma necessidade vital?</a></li>
<li><a href="../pt461045/index.html">Obtenha uma extração do Rosreestr através do FSIS USRN e python. Parte 1</a></li>
<li><a href="../pt461047/index.html">Escrever ou não escrever. Cartas às autoridades durante os eventos</a></li>
<li><a href="../pt461049/index.html">ONYX BOOX Faust - Quem procura não é obrigado a passear</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>