<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☎️ 🧡 💲 Pelacakan Ray GPU dalam Persatuan - Bagian 3 🆖 👭 ☦️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Bagian pertama dan kedua .] 


 Hari ini kita akan melakukan lompatan besar. Kami akan menjauh dari struktur bola yang eksklusif dan bidang tak terb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pelacakan Ray GPU dalam Persatuan - Bagian 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450308/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian pertama</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua</a> .] <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9f/a8a/4f2/f9fa8a4f2a79b8c394636de6a128d0d5.png"></div><br>  Hari ini kita akan melakukan lompatan besar.  Kami akan menjauh dari struktur bola yang eksklusif dan bidang tak terbatas yang kami lacak sebelumnya, dan menambahkan segitiga - seluruh esensi grafik komputer modern, sebuah elemen yang terdiri dari semua dunia virtual.  Jika Anda ingin melanjutkan dengan apa yang kami selesaikan terakhir kali, maka gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode dari bagian 2</a> .  Kode yang sudah jadi untuk apa yang akan kita lakukan hari ini tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Ayo mulai! <br><br><h2>  Segitiga </h2><br>  <em>Segitiga</em> hanyalah daftar dari tiga <em>simpul yang</em> terhubung, masing-masing menyimpan posisinya sendiri, dan kadang-kadang normal.  Urutan traversal dari sudut dari sudut pandang Anda menentukan apa yang kita lihat - bagian depan atau belakang segitiga.  Secara tradisional, "depan" dianggap sebagai urutan traversal berlawanan arah jarum jam. <br><br>  Pertama, kita harus dapat menentukan apakah sinar memotong sebuah segitiga, dan jika demikian, pada titik apa.  Algoritma yang sangat populer (tapi jelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bukan satu-satunya</a> ) untuk menentukan perpotongan sinar dengan segitiga diusulkan pada tahun 1997 oleh tuan-tuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Thomas Akenin-Meller</a> dan Ben Trembor.  Anda dapat membaca lebih lanjut tentang hal ini di artikel mereka “Fast, Minimum Storage Ray-Triangle Intersection” di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><a name="habracut"></a><br>  Kode dari artikel dapat dengan mudah dipindahkan ke kode shader HLSL: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> EPSILON = <span class="hljs-number"><span class="hljs-number">1e-8</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntersectTriangle_MT97</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ray ray, float3 vert0, float3 vert1, float3 vert2, inout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t, inout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u, inout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// find vectors for two edges sharing vert0 float3 edge1 = vert1 - vert0; float3 edge2 = vert2 - vert0; // begin calculating determinant - also used to calculate U parameter float3 pvec = cross(ray.direction, edge2); // if determinant is near zero, ray lies in plane of triangle float det = dot(edge1, pvec); // use backface culling if (det &lt; EPSILON) return false; float inv_det = 1.0f / det; // calculate distance from vert0 to ray origin float3 tvec = ray.origin - vert0; // calculate U parameter and test bounds u = dot(tvec, pvec) * inv_det; if (u &lt; 0.0 || u &gt; 1.0f) return false; // prepare to test V parameter float3 qvec = cross(tvec, edge1); // calculate V parameter and test bounds v = dot(ray.direction, qvec) * inv_det; if (v &lt; 0.0 || u + v &gt; 1.0f) return false; // calculate t, ray intersects triangle t = dot(edge2, qvec) * inv_det; return true; }</span></span></code> </pre> <br>  Untuk menggunakan fungsi ini, kita membutuhkan sinar dan tiga simpul segitiga.  Nilai kembali memberitahu kita jika segitiga berpotongan.  Dalam kasus persimpangan, tiga nilai tambahan dihitung: <code>t</code> menggambarkan jarak sepanjang balok ke titik persimpangan, dan <code>u</code> / <code>v</code> adalah dua dari tiga koordinat barycentric yang menentukan lokasi titik persimpangan pada segitiga (koordinat terakhir dapat dihitung sebagai <code>w = 1 - u - v</code> ).  Jika Anda belum terbiasa dengan koordinat barycentric, bacalah penjelasannya yang bagus tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Scratchapixel</a> . <br><br>  Tanpa terlalu banyak penundaan, mari kita lacak satu segitiga dengan simpul yang ditunjukkan dalam kode!  Temukan fungsi <code>Trace</code> di shader dan tambahkan fragmen kode berikut ke dalamnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Trace single triangle float3 v0 = float3(-150, 0, -150); float3 v1 = float3(150, 0, -150); float3 v2 = float3(0, 150 * sqrt(2), -150); float t, u, v; if (IntersectTriangle_MT97(ray, v0, v1, v2, t, u, v)) { if (t &gt; 0 &amp;&amp; t &lt; bestHit.distance) { bestHit.distance = t; bestHit.position = ray.origin + t * ray.direction; bestHit.normal = normalize(cross(v1 - v0, v2 - v0)); bestHit.albedo = 0.00f; bestHit.specular = 0.65f * float3(1, 0.4f, 0.2f); bestHit.smoothness = 0.9f; bestHit.emission = 0.0f; } }</span></span></code> </pre> <br>  Seperti yang saya katakan, <code>t</code> menyimpan jarak sepanjang balok, dan kita bisa langsung menggunakan nilai ini untuk menghitung titik persimpangan.  Normal, yang penting untuk menghitung refleksi yang benar, dapat dihitung menggunakan produk vektor dari setiap dua sisi segitiga.  Luncurkan mode permainan dan kagumi segitiga yang Anda telusuri: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b29/65a/a84/b2965aa84ae9d882e6c26f7f44da2af7.png"></div><br>  <strong>Latihan:</strong> Cobalah untuk menghitung posisi menggunakan koordinat barycentric daripada jarak.  Jika Anda melakukan semuanya dengan benar, maka segitiga mengkilap akan terlihat persis seperti sebelumnya. <br><br><h2>  Jerat Segitiga </h2><br>  Kami mengatasi hambatan pertama, tetapi melacak seluruh jerat dari segitiga adalah cerita yang sama sekali berbeda.  Pertama kita perlu mempelajari beberapa informasi dasar tentang jerat.  Jika Anda mengenal mereka, Anda dapat dengan aman melewati paragraf berikutnya. <br><br>  Dalam grafik komputer, mesh didefinisikan oleh beberapa buffer, yang paling penting adalah buffer <em>vertex</em> dan <em>indeks</em> .  <em>Buffer vertex</em> adalah daftar vektor 3D yang menggambarkan posisi setiap verteks dalam <em>ruang objek</em> (ini berarti bahwa nilai-nilai tersebut tidak perlu diubah ketika memindahkan, memutar atau menskalakan objek - mereka dikonversi dari <em>ruang objek</em> ke <em>ruang dunia</em> dengan menggunakan penggandaan matriks) .  <em>Buffer indeks</em> adalah daftar nilai integer yang merupakan <em>indeks</em> yang mengarah ke buffer verteks.  Setiap tiga indeks membentuk segitiga.  Misalnya, jika buffer indeks memiliki bentuk [0, 1, 2, 0, 2, 3], maka ia memiliki dua segitiga: segitiga pertama terdiri dari simpul pertama, kedua dan ketiga dalam buffer verteks, dan segitiga kedua terdiri dari yang pertama, ketiga dan puncak keempat.  Oleh karena itu, buffer indeks juga menentukan urutan traversal yang disebutkan di atas.  Selain buffer verteks dan indeks, mungkin ada buffer tambahan yang menambahkan informasi lain untuk setiap vertex.  Buffer tambahan yang paling umum menyimpan <em>normals</em> , <em>koordinat tekstur</em> (disebut <em>texcoords</em> atau hanya <em>UV</em> ), serta <em>warna vertex</em> . <br><br><h2>  Menggunakan GameObjects </h2><br>  Pertama-tama, kita perlu mencari tahu GameObject mana yang harus menjadi bagian dari proses penelusuran ray.  Solusi naif adalah dengan menggunakan <code>FindObjectOfType&lt;MeshRenderer&gt;()</code> , tetapi lakukan sesuatu yang lebih fleksibel dan lebih cepat.  Mari kita tambahkan komponen <code>RayTracingObject</code> baru: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshRenderer))] [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshFilter))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RayTracingObject</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RayTracingMaster.RegisterObject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDisable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RayTracingMaster.UnregisterObject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br>  Komponen ini ditambahkan ke setiap objek yang ingin kita gunakan untuk pelacakan ray dan terlibat dalam pendaftaran mereka menggunakan <code>RayTracingMaster</code> .  Tambahkan fungsi berikut ke wizard: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;RayTracingObject&gt; _rayTracingObjects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;RayTracingObject&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RayTracingObject obj</span></span></span><span class="hljs-function">)</span></span> { _rayTracingObjects.Add(obj); _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnregisterObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RayTracingObject obj</span></span></span><span class="hljs-function">)</span></span> { _rayTracingObjects.Remove(obj); _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Semuanya berjalan dengan baik - sekarang kita tahu benda apa yang harus dilacak.  Tetapi bagian yang sulit berlanjut: kita akan mengumpulkan semua data dari jerat Persatuan (matriks, buffer verteks dan indeks - ingat?), Tuliskan ke struktur data kita sendiri dan muatkan ke dalam GPU sehingga shader dapat menggunakannya.  Mari kita mulai dengan mendefinisikan struktur data dan buffer di sisi C #, di panduan: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> MeshObject { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Matrix4x4 localToWorldMatrix; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_offset; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_count; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;MeshObject&gt; _meshObjects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;MeshObject&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Vector3&gt; _vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _meshObjectBuffer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _vertexBuffer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _indexBuffer;</code> </pre> <br>  ... dan sekarang mari kita lakukan hal yang sama di shader.  Apakah Anda terbiasa dengan hal itu? <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MeshObject</span></span></span><span class="hljs-class"> {</span></span> float4x4 localToWorldMatrix; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_offset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_count; }; StructuredBuffer&lt;MeshObject&gt; _MeshObjects; StructuredBuffer&lt;float3&gt; _Vertices; StructuredBuffer&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _Indices;</code> </pre> <br>  Struktur data sudah siap, dan kita bisa mengisinya dengan data nyata.  Kami mengumpulkan semua simpul semua jerat menjadi satu <code>List&lt;Vector3&gt;</code> besar <code>List&lt;Vector3&gt;</code> , dan semua indeks menjadi <code>List&lt;int&gt;</code> besar <code>List&lt;int&gt;</code> .  Tidak ada masalah dengan simpul, tetapi indeks perlu diubah sehingga mereka terus menunjuk ke simpul yang benar di buffer besar kami.  Bayangkan bahwa kita telah menambahkan objek dari 1000 simpul, dan sekarang kita menambahkan kubus jala sederhana.  Segitiga pertama dapat terdiri dari indeks [0, 1, 2], tetapi karena kita sudah memiliki 1000 simpul dalam buffer, kita perlu menggeser indeks sebelum menambahkan simpul ke kubus.  Artinya, mereka akan berubah menjadi [1000, 1001, 1002].  Begini tampilannya dalam kode: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RebuildMeshObjectBuffers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_meshObjectsNeedRebuilding) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _currentSample = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Clear all lists _meshObjects.Clear(); _vertices.Clear(); _indices.Clear(); // Loop over all objects and gather their data foreach (RayTracingObject obj in _rayTracingObjects) { Mesh mesh = obj.GetComponent&lt;MeshFilter&gt;().sharedMesh; // Add vertex data int firstVertex = _vertices.Count; _vertices.AddRange(mesh.vertices); // Add index data - if the vertex buffer wasn't empty before, the // indices need to be offset int firstIndex = _indices.Count; var indices = mesh.GetIndices(0); _indices.AddRange(indices.Select(index =&gt; index + firstVertex)); // Add the object itself _meshObjects.Add(new MeshObject() { localToWorldMatrix = obj.transform.localToWorldMatrix, indices_offset = firstIndex, indices_count = indices.Length }); } CreateComputeBuffer(ref _meshObjectBuffer, _meshObjects, 72); CreateComputeBuffer(ref _vertexBuffer, _vertices, 12); CreateComputeBuffer(ref _indexBuffer, _indices, 4); }</span></span></code> </pre> <br>  Kami memanggil <code>RebuildMeshObjectBuffers</code> di fungsi <code>OnRenderImage</code> , dan jangan lupa untuk membebaskan buffer baru di <code>OnDisable</code> .  Berikut adalah dua fungsi pembantu yang saya gunakan dalam kode di atas untuk menyederhanakan penanganan buffer sedikit: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreateComputeBuffer&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> ComputeBuffer buffer, List&lt;T&gt; data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stride) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Do we already have a compute buffer? if (buffer != null) { // If no data or buffer doesn't match the given criteria, release it if (data.Count == 0 || buffer.count != data.Count || buffer.stride != stride) { buffer.Release(); buffer = null; } } if (data.Count != 0) { // If the buffer has been released or wasn't there to // begin with, create it if (buffer == null) { buffer = new ComputeBuffer(data.Count, stride); } // Set data on the buffer buffer.SetData(data); } } private void SetComputeBuffer(string name, ComputeBuffer buffer) { if (buffer != null) { RayTracingShader.SetBuffer(0, name, buffer); } }</span></span></code> </pre> <br>  Hebat, kami membuat buffer dan mereka diisi dengan data yang diperlukan!  Sekarang kita hanya perlu melaporkan ini ke shader.  Tambahkan kode berikut ke <code>SetShaderParameters</code> (dan berkat fungsi pembantu baru, kami dapat mengurangi kode buffer bola): <br><br><pre> <code class="cs hljs">SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_Spheres"</span></span>, _sphereBuffer); SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_MeshObjects"</span></span>, _meshObjectBuffer); SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_Vertices"</span></span>, _vertexBuffer); SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_Indices"</span></span>, _indexBuffer);</code> </pre> <br>  Jadi, pekerjaannya membosankan, tapi mari kita lihat apa yang baru saja kita lakukan: kami mengumpulkan semua data internal jerat (matriks, simpul dan indeks), menempatkannya dalam struktur yang mudah dan sederhana, dan kemudian mengirimnya ke GPU, yang sekarang menanti saat mereka bisa digunakan. <br><br><h2>  Jaring tracing </h2><br>  Jangan memaksanya menunggu.  Dalam shader, kita sudah memiliki kode jejak dari sebuah segitiga individu, dan jaringnya, pada kenyataannya, hanyalah banyak segitiga.  Satu-satunya aspek baru di sini adalah kita menggunakan matriks untuk mengubah simpul dari ruang objek ke ruang dunia menggunakan fungsi <code>mul</code> built-in (kependekan dari multiply).  Matriks berisi terjemahan, rotasi, dan skala objek.  Ini memiliki ukuran 4 × 4, jadi untuk perkalian kita membutuhkan vektor 4d.  Tiga komponen pertama (x, y, z) diambil dari vertex buffer.  Kami mengatur komponen keempat (w) menjadi 1 karena kami berhadapan dengan suatu poin.  Jika ini adalah arahnya, maka kita akan menulis 0 di dalamnya untuk mengabaikan semua terjemahan dan skala dalam matriks.  Apakah ini membingungkan bagi Anda?  Kemudian baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial ini</a> setidaknya delapan kali.  Berikut adalah kode shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntersectMeshObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ray ray, inout RayHit bestHit, MeshObject meshObject)</span></span></span><span class="hljs-function"> </span></span>{ uint offset = meshObject.indices_offset; uint count = offset + meshObject.indices_count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i = offset; i &lt; count; i += <span class="hljs-number"><span class="hljs-number">3</span></span>) { float3 v0 = (mul(meshObject.localToWorldMatrix, float4(_Vertices[_Indices[i]], <span class="hljs-number"><span class="hljs-number">1</span></span>))).xyz; float3 v1 = (mul(meshObject.localToWorldMatrix, float4(_Vertices[_Indices[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]], <span class="hljs-number"><span class="hljs-number">1</span></span>))).xyz; float3 v2 = (mul(meshObject.localToWorldMatrix, float4(_Vertices[_Indices[i + <span class="hljs-number"><span class="hljs-number">2</span></span>]], <span class="hljs-number"><span class="hljs-number">1</span></span>))).xyz; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t, u, v; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IntersectTriangle_MT97(ray, v0, v1, v2, t, u, v)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; t &lt; bestHit.distance) { bestHit.distance = t; bestHit.position = ray.origin + t * ray.direction; bestHit.normal = normalize(cross(v1 - v0, v2 - v0)); bestHit.albedo = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; bestHit.specular = <span class="hljs-number"><span class="hljs-number">0.65f</span></span>; bestHit.smoothness = <span class="hljs-number"><span class="hljs-number">0.99f</span></span>; bestHit.emission = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } } } }</code> </pre> <br>  Kami hanya satu langkah lagi dari melihat semuanya beraksi.  Mari kita merestrukturisasi fungsi <code>Trace</code> sedikit dan menambahkan jejak objek mesh: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">RayHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ray ray)</span></span></span><span class="hljs-function"> </span></span>{ RayHit bestHit = CreateRayHit(); uint count, stride, i; <span class="hljs-comment"><span class="hljs-comment">// Trace ground plane IntersectGroundPlane(ray, bestHit); // Trace spheres _Spheres.GetDimensions(count, stride); for (i = 0; i &lt; count; i++) { IntersectSphere(ray, bestHit, _Spheres[i]); } // Trace mesh objects _MeshObjects.GetDimensions(count, stride); for (i = 0; i &lt; count; i++) { IntersectMeshObject(ray, bestHit, _MeshObjects[i]); } return bestHit; }</span></span></code> </pre> <br><h2>  Hasil </h2><br>  Itu saja!  Mari kita tambahkan beberapa jerat sederhana (Unity primitif baik-baik saja), berikan mereka komponen <code>RayTracingObject</code> dan amati keajaibannya.  <strong>Jangan menggunakan</strong> jerat terinci (lebih dari beberapa ratus segitiga)!  Shader kami tidak memiliki optimalisasi, dan jika Anda melakukannya secara berlebihan, maka diperlukan beberapa detik atau bahkan menit untuk melacak setidaknya satu sampel per piksel.  Akibatnya, sistem akan menghentikan driver GPU, mesin Unity mungkin macet, dan komputer harus dihidupkan ulang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c80/1d4/40e/c801d440e5a0a21f660b5a7e82e1b368.png"></div><br>  Perhatikan bahwa jerat kami tidak memiliki bayangan yang halus, tetapi rata.  Karena kita belum memuat normals dari simpul ke buffer, untuk mendapatkan normal dari simpul masing-masing segitiga, kita perlu melakukan produk vektor.  Selain itu, kami tidak dapat menginterpolasi area segitiga.  Kami akan mengatasi masalah ini di bagian tutorial selanjutnya. <br><br>  Demi kepentingan, saya mengunduh Stanford Bunny dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arsip Morgan McGwire</a> dan menggunakan pengubah decimate dari paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blender,</a> saya mengurangi jumlah simpul menjadi 431. Anda dapat bereksperimen dengan parameter pencahayaan dan materi kode keras dalam fungsi shader <code>IntersectMeshObject</code> .  Inilah kelinci dielektrik dengan bayang-bayang lembut yang indah dan sedikit pencahayaan global yang tersebar di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grafitti Shelter</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0da/860/bb4/0da860bb41d9465f2dc21d649a509a66.png"></div><br>  ... dan inilah kelinci logam di bawah cahaya arah yang kuat dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cape Hill</a> , melemparkan sorot disko ke lantai pesawat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a76/bb1/a64/a76bb1a642d620929ecd250f92e1ef1f.jpg"></div><br>  ... dan di sini ada dua kelinci kecil yang bersembunyi di bawah batu besar Suzanne di bawah langit biru <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kiara 9 Dusk</a> (saya meresepkan bahan alternatif untuk objek kedua, memeriksa apakah indeks bergeser nol): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ef/196/a4f/7ef196a4f818b366b4838f2b1e4148f5.png"></div><br><h2>  Apa selanjutnya </h2><br>  Sangat menyenangkan melihat jaring nyata di pelacak Anda sendiri untuk pertama kalinya, bukan?  Hari ini kami memproses beberapa data, menemukan persimpangan dengan menggunakan algoritma Meller-Trambor, dan mengumpulkan semuanya sehingga kami bisa segera menggunakan mesin GameObjects mesin Unity.  Selain itu, kami melihat salah satu keunggulan penelusuran sinar: segera setelah Anda menambahkan persimpangan baru ke kode, semua efek yang indah (bayangan lembut, pencahayaan global yang dipantulkan dan disebarkan, dan sebagainya) segera mulai bekerja. <br><br>  Membawa kelinci yang mengkilap membutuhkan banyak waktu, dan saya masih harus menggunakan sedikit penyaringan untuk menghilangkan suara yang paling jelas.  Untuk mengatasi masalah ini, adegan biasanya ditulis dalam struktur spasial, misalnya, dalam kotak, pohon dimensi-K atau hierarki volume pembatas, yang secara signifikan meningkatkan kecepatan rendering adegan besar. <br><br>  Tetapi kita perlu bergerak secara berurutan: lebih jauh kita akan menghilangkan masalah dengan normal sehingga jerat kita (bahkan yang rendah poli) terlihat lebih halus dari sekarang.  Akan lebih baik jika secara otomatis memperbarui matriks ketika memindahkan objek dan langsung merujuk ke materi Unity, dan tidak hanya menuliskannya dalam kode.  Inilah yang akan kita lakukan di bagian selanjutnya dari seri tutorial ini.  Terima kasih sudah membaca, dan sampai jumpa di bagian 4! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450308/">https://habr.com/ru/post/id450308/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450294/index.html">Racun paling menakutkan</a></li>
<li><a href="../id450298/index.html">Quantum Future (lanjutan)</a></li>
<li><a href="../id450300/index.html">Berhentilah berdebat tentang pemrograman fungsional dan OOP</a></li>
<li><a href="../id450302/index.html">Teknologi Radio Amatir: pembuatan papan sirkuit prototipe di sebuah pabrik Cina</a></li>
<li><a href="../id450304/index.html">Carapuzik mengendarai seekor semut: 100 juta tahun myrmecophilia</a></li>
<li><a href="../id450310/index.html">Cara kerja Philips VideoWRITER. Gambar pertama dari besi, lalu sedikit kebosanan</a></li>
<li><a href="../id450312/index.html">Docker Compose Starter Guide</a></li>
<li><a href="../id450314/index.html">TensorFlow untuk pemula. Bagian 1: informasi umum, menginstal perpustakaan</a></li>
<li><a href="../id450316/index.html">TDD: metodologi pengembangan yang mengubah hidup saya</a></li>
<li><a href="../id450318/index.html">Pola desain dalam pengembangan JavaScript modern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>