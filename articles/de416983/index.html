<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßîüèø üêÖ üßù Erstellen Sie einen Cartoon-Water-Shader f√ºr das Web. Teil 2 üë®üèæ‚Äçüíº üë®üèø‚Äçüîß ü¶ç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Teil haben wir uns mit der Einrichtung der Umgebung und der Wasseroberfl√§che befasst. In diesem Teil geben wir Objekten Auftrieb, f√ºgen Wass...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie einen Cartoon-Water-Shader f√ºr das Web. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416983/"> Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil haben</a> wir uns mit der Einrichtung der Umgebung und der Wasseroberfl√§che befasst.  In diesem Teil geben wir Objekten Auftrieb, f√ºgen Wasserlinien auf der Oberfl√§che hinzu und erstellen Schaumlinien mit einem Tiefenpuffer um die Grenzen von Objekten, die sich mit der Oberfl√§che schneiden. <br><br>  Um die Szene ein wenig besser aussehen zu lassen, habe ich kleinere √Ñnderungen daran vorgenommen.  Sie k√∂nnen Ihre Szene nach Ihren W√ºnschen anpassen, aber ich habe Folgendes getan: <br><br><ul><li>  Modelle eines Leuchtturms und eines Oktopus hinzugef√ºgt. </li><li> Ein Grundmodell mit der Farbe <code>#FFA457</code> . </li><li>  <code>#6CC8FF</code> eine Himmelsfarbe von <code>#6CC8FF</code> . </li><li>  <code>#FFC480</code> Hintergrundbeleuchtung Farbe zur Szene hinzugef√ºgt (diese Parameter finden Sie in den Szeneneinstellungen). </li></ul><br>  Meine urspr√ºngliche Szene sieht jetzt so aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/2fa/0d5/bc22fa0d57b5120e75cced6f105bebd2.png"></div><a name="habracut"></a><br><h2>  Auftrieb </h2><br>  Der einfachste Weg, Auftrieb zu erzeugen, besteht darin, Objekte mithilfe eines Skripts nach oben und unten zu verschieben.  Erstellen Sie ein neues <strong>Buoyancy.js-</strong> Skript und legen Sie bei der Initialisierung Folgendes fest: <br><br><pre> <code class="javascript hljs">Buoyancy.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initialPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.getPosition().clone(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initialRotation = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.getEulerAngles().clone(); <span class="hljs-comment"><span class="hljs-comment">//     ,  //        //     this.time = Math.random() * 2 * Math.PI; };</span></span></code> </pre> <br>  Jetzt im Update f√ºhren wir das Zeitinkrement aus und drehen das Objekt: <br><br><pre> <code class="javascript hljs">Buoyancy.prototype.update = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time += <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      var pos = this.entity.getPosition().clone(); pos.y = this.initialPosition.y + Math.cos(this.time) * 0.07; this.entity.setPosition(pos.x,pos.y,pos.z); //    var rot = this.entity.getEulerAngles().clone(); rot.x = this.initialRotation.x + Math.cos(this.time * 0.25) * 1; rot.z = this.initialRotation.z + Math.sin(this.time * 0.5) * 2; this.entity.setLocalEulerAngles(rot.x,rot.y,rot.z); };</span></span></code> </pre> <br>  Wenden Sie dieses Skript auf das Boot an und sehen Sie, wie es im Wasser auf und ab springt!  Sie k√∂nnen dieses Skript auf mehrere Objekte anwenden (einschlie√ülich der Kamera - probieren Sie es aus)! <br><br><h2>  Oberfl√§chentextur </h2><br>  W√§hrend wir die Wellen sehen k√∂nnen, schauen wir auf die R√§nder der Wasseroberfl√§che.  Durch Hinzuf√ºgen von Textur wird die Oberfl√§chenbewegung deutlicher.  Dar√ºber hinaus ist es eine kosteng√ºnstige M√∂glichkeit, Reflexionen und √Ñtzungen zu simulieren. <br><br>  Sie k√∂nnen versuchen, einige √§tzende Texturen zu finden oder selbst eine zu erstellen.  Ich habe <a href="" rel="external">eine Textur</a> in Gimp gezeichnet, die Sie frei verwenden k√∂nnen.  Jede Textur ist geeignet, sofern sie ohne erkennbare Fugen gekachelt werden kann. <br><br>  Nachdem Sie die gew√ºnschte Textur ausgew√§hlt haben, ziehen Sie sie in das Assets-Fenster Ihres Projekts.  Wir m√ºssen diese Textur aus dem Water.js-Skript referenzieren, also erstellen wir ein Attribut daf√ºr: <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'surfaceTexture'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'texture'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Surface Texture'</span></span> });</code> </pre> <br>  Und dann im Editor zuweisen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/672/61e/32f/67261e32f145eda9dab99d1866181ced.png"></div><br>  Jetzt m√ºssen wir es an den Shader weitergeben.  Gehen Sie zu <strong>Water.js</strong> und setzen Sie die <code>CreateWaterMaterial</code> Funktion <code>CreateWaterMaterial</code> neuen Parameter: <br><br><pre> <code class="javascript hljs">material.setParameter(<span class="hljs-string"><span class="hljs-string">'uSurfaceTexture'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.surfaceTexture.resource);</code> </pre> <br>  Gehen Sie jetzt zur√ºck zu <strong>Water.frag</strong> und erkl√§ren Sie eine neue Uniform: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture;</code> </pre> <br>  Wir sind fast fertig.  Um eine Textur in einer Ebene zu rendern, m√ºssen wir wissen, wo sich jedes Pixel im Netz befindet.  Das hei√üt, wir m√ºssen Daten vom Vertex-Shader zum Fragment One √ºbertragen. <br><br><h3>  Unterschiedliche Variablen </h3><br>  <em>Mit unterschiedlichen</em> Variablen k√∂nnen Sie Daten vom Vertex-Shader zum Fragment-Shader √ºbertragen.  Dies ist der dritte Typ von speziellen Variablen, die im Shader verwendet werden k√∂nnen (die ersten beiden sind <em>einheitlich</em> und <em>Attribut</em> ).  F√ºr jeden Scheitelpunkt wird eine Variable festgelegt, auf die jedes Pixel zugreifen kann.  Da es viel mehr Pixel als Scheitelpunkte gibt, wird der Wert zwischen den Scheitelpunkten interpoliert (daher der Name "variierend" - er weicht von den an ihn √ºbergebenen Werten ab). <br><br>  Um es im Betrieb zu testen, deklarieren Sie eine neue Variable in <strong>Water.vert</strong> als variierend: <br><br><pre> <code class="javascript hljs">varying vec2 ScreenPosition;</code> </pre> <br>  Und weisen Sie <code>gl_Position</code> nach der Berechnung den Wert <code>gl_Position</code> : <br><br><pre> <code class="javascript hljs">ScreenPosition = gl_Position.xyz;</code> </pre> <br>  <strong>Kehren Sie</strong> nun zu <strong>Water.frag zur√ºck</strong> und deklarieren Sie dieselbe Variable.  Wir k√∂nnen die Ausgabe von Debugging-Daten nicht vom Shader abrufen, aber wir k√∂nnen Farbe f√ºr das visuelle Debugging verwenden.  So geht's: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec3 ScreenPosition; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    varying- color = vec4(vec3(ScreenPosition.x),1.0); gl_FragColor = color; }</span></span></code> </pre> <br>  Die Ebene sollte jetzt schwarzwei√ü aussehen, und die <code>ScreenPosition.x</code> verl√§uft dort, wo <code>ScreenPosition.x</code> = 0 ist. Die Farbwerte √§ndern sich nur von 0 auf 1, die Werte in <code>ScreenPosition</code> k√∂nnen jedoch au√üerhalb dieses Bereichs liegen.  Sie werden automatisch begrenzt. Wenn Sie also Schwarz sehen, kann dies 0 oder eine negative Zahl sein. <br><br>  Was wir gerade getan haben, ist, die Bildschirmposition jedes Scheitelpunkts an jedes Pixel zu √ºbergeben.  Sie k√∂nnen sehen, dass die Linie zwischen der schwarzen und der wei√üen Seite immer in der Mitte des Bildschirms verl√§uft, unabh√§ngig davon, wo sich die Oberfl√§che tats√§chlich auf der Welt befindet. <br><br><blockquote>  <em>Aufgabe 1: Erstellen Sie eine neue variierende Variable, um die Position in der Welt anstelle der Bildschirmposition zu √ºbertragen.</em>  <em>Visualisieren Sie es auf die gleiche Weise.</em>  <em>Wenn sich die Farbe mit der Bewegung der Kamera nicht √§ndert, ist alles korrekt.</em> </blockquote><br><h3>  Mit UV </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">UV</a> sind die 2D-Koordinaten jedes Scheitelpunkts im Netz, normalisiert von 0 bis 1. Sie sind f√ºr die korrekte Abtastung der Textur in der Ebene erforderlich, und wir haben sie bereits im vorherigen Teil konfiguriert. <br><br>  <strong>Wir</strong> deklarieren ein neues Attribut in <strong>Water.vert</strong> (dieser Name stammt aus der Definition eines Shaders in Water.js): <br><br><pre> <code class="javascript hljs">attribute vec2 aUv0;</code> </pre> <br>  Und jetzt m√ºssen wir es nur noch an den Fragment-Shader √ºbergeben, also einfach variieren und ihm den Attributwert zuweisen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Water.vert //        varying vec2 vUv0; // .. //        //  varying,        vUv0 = aUv0;</span></span></code> </pre> <br>  Jetzt deklarieren wir dieselbe variierende Variable im Fragment-Shader.  Um sicherzustellen, dass alles funktioniert, k√∂nnen wir das Debuggen wie zuvor visualisieren, und dann sieht Water.frag folgenderma√üen aus: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  UV color = vec4(vec3(vUv0.x),1.0); gl_FragColor = color; }</span></span></code> </pre> <br>  Sie sollten einen Farbverlauf sehen, der best√§tigt, dass wir an einem Ende den Wert 0 und am anderen Ende den Wert 1 haben.  Um die Textur wirklich zu testen, m√ºssen wir nur noch Folgendes tun: <br><br><pre> <code class="javascript hljs">color = texture2D(uSurfaceTexture,vUv0);</code> </pre> <br>  Danach sehen wir die Textur auf der Oberfl√§che: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f49/9bf/ae2/f499bfae266b0aa16709bbea0280df6f.png"></div><br><h3>  Textur-Styling </h3><br>  Anstatt nur die Textur als neue Farbe festzulegen, kombinieren wir sie mit dem vorhandenen Blau: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec4 WaterLines = texture2D(uSurfaceTexture,vUv0); color.rgba += WaterLines.r; gl_FragColor = color; }</code> </pre> <br>  Dies funktioniert, weil die Texturfarbe √ºberall au√üer Wasserlinien schwarz (0) ist.  Wenn Sie es hinzuf√ºgen, √§ndern wir die anf√§ngliche blaue Farbe nicht, mit Ausnahme von Stellen mit Linien, an denen es heller wird. <br><br>  Dies ist jedoch nicht die einzige M√∂glichkeit, Farben zu kombinieren. <br><br><blockquote>  <em>Aufgabe 2: K√∂nnen Sie die Farben kombinieren, um den unten gezeigten schw√§cheren Effekt zu erzielen?</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3d/e18/22a/a3de1822a348656f47e5bd6cfa6cbed5.png"></div><br><h3>  Textur bewegen </h3><br>  Als letzten Effekt m√∂chten wir, dass sich die Linien entlang der Oberfl√§che bewegen und sie nicht so statisch aussehen.  Dazu nutzen wir die Tatsache, dass jeder Wert au√üerhalb des Intervalls von 0 bis 1, der an die Funktion <code>texture2D</code> wird, √ºbertragen wird (z. B. werden sowohl 1,5 als auch 2,5 gleich 0,5).  Daher k√∂nnen wir unsere Position um die einheitliche Zeitvariable erh√∂hen, die wir bereits festgelegt haben, um die Liniendichte auf der Oberfl√§che zu erh√∂hen oder zu verringern, wodurch der endg√ºltige Fragment-Shader diese Form erh√§lt: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; uniform float uTime; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec2 pos = vUv0; <span class="hljs-comment"><span class="hljs-comment">//      1 //     pos *= 2.0; //   ,      pos.y += uTime * 0.02; vec4 WaterLines = texture2D(uSurfaceTexture,pos); color.rgba += WaterLines.r; gl_FragColor = color; }</span></span></code> </pre> <br><h2>  Schaumlinien und Tiefenpuffer </h2><br>  Durch das Rendern von Schaumstofflinien um Objekte im Wasser ist es viel einfacher zu erkennen, wie eingetaucht die Objekte sind und wo sie die Oberfl√§che √ºberqueren.  Au√üerdem wird unser Wasser auf diese Weise viel glaubw√ºrdiger.  Um die Schaumlinien zu erkennen, m√ºssen wir irgendwie herausfinden, wo sich die Grenzen jedes Objekts befinden, und dies effektiv tun. <br><br><h3>  Trick </h3><br>  Wir m√ºssen lernen zu bestimmen, ob sich ein Pixel auf der Wasseroberfl√§che in der N√§he des Objekts befindet.  Wenn ja, dann k√∂nnen wir es in der Farbe des Schaums malen.  Es gibt keine einfachen M√∂glichkeiten, dieses Problem zu l√∂sen (soweit ich wei√ü).  Um es zu l√∂sen, verwende ich daher eine n√ºtzliche Technik zur L√∂sung von Problemen: Ich werde ein Beispiel nehmen, f√ºr das wir die Antwort kennen und sehen, ob wir sie verallgemeinern k√∂nnen. <br><br>  Schauen Sie sich das Bild unten an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d0/0e7/eec/4d00e7eec8714a365c110aea67df9fab.png"></div><br>  Welche Pixel sollten Teil des Schaums sein?  Wir wissen, dass es ungef√§hr so ‚Äã‚Äãaussehen sollte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a8/541/c4f/1a8541c4f8fdd65879966b909805c484.png"></div><br>  Schauen wir uns also zwei bestimmte Pixel an.  Unten habe ich sie mit Sternchen markiert.  Schwarz wird auf dem Schaum sein und Rot nicht.  Wie unterscheiden wir sie in einem Shader? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/d35/fb2/012d35fb25d42c19a86adaa081048237.png"></div><br>  Wir wissen, dass diese beiden Pixel im Bildschirmbereich zwar nahe beieinander liegen (beide werden auf dem Leuchtturm gerendert), aber im Weltraum der Welt tats√§chlich sehr weit entfernt sind.  Wir k√∂nnen dies √ºberpr√ºfen, indem wir dieselbe Szene aus einem anderen Blickwinkel betrachten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd3/5a0/31b/cd35a031bbd18805128ebd44ed1c1279.png"></div><br>  Beachten Sie, dass sich der rote Stern nicht auf dem Leuchtturm befindet, wie es uns schien, sondern der schwarze tats√§chlich.  Wir k√∂nnen von der Entfernung zur Kamera unterscheiden, die normalerweise als "Tiefe" bezeichnet wird.  Tiefe 1 bedeutet, dass der Punkt sehr nahe an der Kamera liegt, Tiefe 0 bedeutet, dass er sehr weit entfernt ist.  Dabei geht es aber nicht nur um absolute Entfernungen in der Welt, Tiefe oder Kamera.  Die Tiefe <em>relativ zum Pixel dahinter ist</em> wichtig. <br><br>  Schauen Sie sich noch einmal die erste Ansicht an.  Nehmen wir an, der Rumpf des Leuchtturms hat einen Tiefenwert von 0,5.  Die Tiefe des schwarzen Sterns liegt sehr nahe bei 0,5.  Das hei√üt, es und das Pixel darunter haben sehr enge Tiefenwerte.  Auf der anderen Seite hat das rote Sternchen eine viel gr√∂√üere Tiefe, da es n√§her an der Kamera liegt, z. B. 0,7.  Und obwohl sich das Pixel dahinter noch auf dem Leuchtturm befindet, hat es einen Tiefenwert von 0,5, das hei√üt, es gibt mehr Unterschiede. <br><br>  Das ist der Trick.  <em>Wenn die Tiefe eines Pixels auf der Wasseroberfl√§che nahe genug an der Tiefe des Pixels liegt, √ºber das es gezeichnet wird, befinden wir uns ziemlich nahe am Rand eines Objekts</em> und k√∂nnen das Pixel wie Schaum rendern. <br><br>  Das hei√üt, wir brauchen mehr Informationen als in jedem Pixel.  Wir m√ºssen irgendwie die Tiefe des Pixels herausfinden, √ºber das es gezeichnet werden soll.  Und hier ist der Tiefenpuffer f√ºr uns n√ºtzlich. <br><br><h3>  Tiefenpuffer </h3><br>  Sie k√∂nnen sich einen Frame-Puffer oder Frame-Buffer als Ziel-Rendering oder Textur au√üerhalb des Bildschirms vorstellen.  Wenn wir Daten lesen m√ºssen, m√ºssen wir au√üerhalb des Bildschirms rendern.  Diese Technik wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">beim Raucheffekt eingesetzt</a> . <br><br>  Der Tiefenpuffer ist ein spezielles Ziel-Rendering, das Informationen zu den Tiefenwerten jedes Pixels enth√§lt.  Vergessen Sie nicht, dass der im Vertex-Shader berechnete Wert in <code>gl_Position</code> der Bildschirmraumwert war, aber auch eine dritte Koordinate hat - den Z-Wert. Dieser Z-Wert wird zur Berechnung der Tiefe verwendet, die in den Tiefenpuffer geschrieben wird. <br><br>  Der Tiefenpuffer dient zum korrekten Rendern der Szene, ohne dass Objekte von hinten nach vorne sortiert werden m√ºssen.  Jedes zuerst zu zeichnende Pixel √ºberpr√ºft den Tiefenpuffer.  Wenn sein Tiefenwert gr√∂√üer als der Wert im Puffer ist, wird er gezeichnet und sein eigener Wert √ºberschreibt den Wert des Puffers.  Andernfalls wird es verworfen (weil es bedeutet, dass sich ein anderes Objekt davor befindet). <br><br>  Tats√§chlich k√∂nnen Sie das Schreiben in den Tiefenpuffer deaktivieren, um zu sehen, wie alles ohne ihn aussehen w√ºrde.  Versuchen wir es in Water.js: <br><br><pre> <code class="javascript hljs">material.depthTest = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Sie werden feststellen, dass Wasser jetzt immer von oben gezogen wird, auch wenn es sich hinter undurchsichtigen Objekten befindet. <br><br><h3>  Tiefenpuffer-Visualisierung </h3><br>  F√ºgen wir eine M√∂glichkeit hinzu, den Tiefenpuffer f√ºr Debugging-Zwecke zu rendern.  Erstellen Sie ein neues <strong>DepthVisualize.js-</strong> Skript.  Befestigen Sie es an der Kamera. <br><br>  Um auf den Tiefenpuffer in PlayCanvas zuzugreifen, schreiben Sie einfach Folgendes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.camera.camera.requestDepthMap();</code> </pre> <br>  Daher f√ºgen wir die einheitliche Variable automatisch in alle unsere Shader ein, die wir verwenden k√∂nnen, indem wir sie wie folgt deklarieren: <br><br><pre> <code class="javascript hljs">uniform sampler2D uDepthMap;</code> </pre> <br>  Unten finden Sie ein Beispielskript, das eine Tiefenkarte anfordert und √ºber einer Szene rendert.  Er hat einen Hot-Neustart konfiguriert. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DepthVisualize = pc.createScript(<span class="hljs-string"><span class="hljs-string">'depthVisualize'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  initialize,       DepthVisualize.prototype.initialize = function() { this.entity.camera.camera.requestDepthMap(); this.antiCacheCount = 0; //    ,         this.SetupDepthViz(); }; DepthVisualize.prototype.SetupDepthViz = function(){ var device = this.app.graphicsDevice; var chunks = pc.shaderChunks; this.fs = ''; this.fs += 'varying vec2 vUv0;'; this.fs += 'uniform sampler2D uDepthMap;'; this.fs += ''; this.fs += 'float unpackFloat(vec4 rgbaDepth) {'; this.fs += ' const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);'; this.fs += ' float depth = dot(rgbaDepth, bitShift);'; this.fs += ' return depth;'; this.fs += '}'; this.fs += ''; this.fs += 'void main(void) {'; this.fs += ' float depth = unpackFloat(texture2D(uDepthMap, vUv0)) * 30.0; '; this.fs += ' gl_FragColor = vec4(vec3(depth),1.0);'; this.fs += '}'; this.shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, this.fs, "renderDepth" + this.antiCacheCount); this.antiCacheCount ++; //     ,        this.command = new pc.Command(pc.LAYER_FX, pc.BLEND_NONE, function () { pc.drawQuadWithShader(device, null, this.shader); }.bind(this)); this.command.isDepthViz = true; //    ,      this.app.scene.drawCalls.push(this.command); }; //  update,     DepthVisualize.prototype.update = function(dt) { }; //  swap,      //      DepthVisualize.prototype.swap = function(old) { this.antiCacheCount = old.antiCacheCount; //      for(var i=0;i&lt;this.app.scene.drawCalls.length;i++){ if(this.app.scene.drawCalls[i].isDepthViz){ this.app.scene.drawCalls.splice(i,1); break; } } //    this.SetupDepthViz(); }; //      ,  : // http://developer.playcanvas.com/en/user-manual/scripting/</span></span></code> </pre> <br>  Versuchen Sie, den Code zu kopieren und die Zeile <code>this.app.scene.drawCalls.push(this.command);</code> kommentieren / zu kommentieren <code>this.app.scene.drawCalls.push(this.command);</code>  zum Aktivieren / Deaktivieren des Tiefen-Renderings.  Dies sollte wie im Bild unten aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c09/93a/c4f/c0993ac4f8ed7a4c739658bbff69e455.png"></div><br><blockquote>  <em>Aufgabe 3: Die Wasseroberfl√§che wird nicht in den Tiefenpuffer gezogen.</em>  <em>Die PlayCanvas-Engine tut dies absichtlich.</em>  <em>K√∂nnen Sie herausfinden warum?</em>  <em>Was ist das Besondere am Wassermaterial?</em>  <em>Mit anderen Worten, was w√ºrde angesichts unserer Regeln zur √úberpr√ºfung der Tiefe passieren, wenn Pixel Wasser in den Tiefenpuffer geschrieben w√ºrden?</em> </blockquote><br>  <em>Hinweis: Sie k√∂nnen eine Zeile in Water.js √§ndern, wodurch Sie Wasser in den Tiefenpuffer schreiben k√∂nnen.</em> <br><br>  Es sollte auch beachtet werden, dass ich in der Initialisierungsfunktion den Tiefenwert mit 30 multipliziere. Dies ist notwendig, um ihn klar zu sehen, da sonst der Wertebereich zu klein w√§re, um Farbt√∂ne anzuzeigen. <br><br><h3>  Trick-Implementierung </h3><br>  In der PlayCanvas-Engine gibt es mehrere Zusatzfunktionen f√ºr die Arbeit mit Tiefenwerten. Zum Zeitpunkt des Schreibens waren sie jedoch noch nicht in der Produktion freigegeben, sodass wir sie selbst konfigurieren m√ºssen. <br><br>  Wir <strong>definieren die</strong> folgenden einheitlichen Variablen in <strong>Water.frag</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   uniform-    PlayCanvas uniform sampler2D uDepthMap; uniform vec4 uScreenSize; uniform mat4 matrix_view; //      uniform vec4 camera_params;</span></span></code> </pre> <br>  Wir definieren diese Hilfsfunktionen √ºber die Hauptfunktion: <br><br><pre> <code class="javascript hljs">#ifdef GL2 float linearizeDepth(float z) { z = z * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> / (camera_params.z * z + camera_params.w); } #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #ifndef UNPACKFLOAT #define UNPACKFLOAT float unpackFloat(vec4 rgbaDepth) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec4 bitShift = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span> / (<span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / (<span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-number"><span class="hljs-number">256.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dot(rgbaDepth, bitShift); } #endif #endif float getLinearScreenDepth(vec2 uv) { #ifdef GL2 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y; #endif } float getLinearDepth(vec3 pos) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -(matrix_view * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)).z; } float getLinearScreenDepth() { vec2 uv = gl_FragCoord.xy * uScreenSize.zw; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getLinearScreenDepth(uv); }</code> </pre> <br>  Wir werden die Shader-Informationen √ºber die Kamera in <strong>Water.js weitergeben</strong> .  F√ºgen Sie dies dort ein, wo Sie die anderen einheitlichen Variablen wie uTime √ºbergeben: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.root.findByName(<span class="hljs-string"><span class="hljs-string">"Camera"</span></span>).camera; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = camera.nearClip; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = camera.farClip; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera_params = [ <span class="hljs-number"><span class="hljs-number">1</span></span>/f, f, (<span class="hljs-number"><span class="hljs-number">1</span></span>-f / n) / <span class="hljs-number"><span class="hljs-number">2</span></span>, (<span class="hljs-number"><span class="hljs-number">1</span></span> + f / n) / <span class="hljs-number"><span class="hljs-number">2</span></span> ]; material.setParameter(<span class="hljs-string"><span class="hljs-string">'camera_params'</span></span>, camera_params);</code> </pre> <br>  Schlie√ülich ben√∂tigen wir f√ºr unseren Fragment-Shader eine Position in der Welt jedes Pixels.  Wir m√ºssen es vom Vertex-Shader bekommen.  Daher definieren wir in <strong>Water.frag</strong> eine variierende Variable: <br><br><pre> <code class="javascript hljs">varying vec3 WorldPosition;</code> </pre> <br>  Definieren Sie dieselbe variierende Variable in <strong>Water.vert</strong> .  Dann weisen wir ihm eine verzerrte Position vom Vertex-Shader zu, sodass der vollst√§ndige Code folgenderma√üen aussieht: <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; attribute vec2 aUv0; varying vec2 vUv0; varying vec3 WorldPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; uniform float uTime; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vUv0 = aUv0; vec3 pos = aPosition; pos.y += cos(pos.z*<span class="hljs-number"><span class="hljs-number">5.0</span></span>+uTime) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> * sin(pos.x * <span class="hljs-number"><span class="hljs-number">5.0</span></span> + uTime); gl_Position = matrix_viewProjection * matrix_model * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); WorldPosition = pos; }</code> </pre> <br><h3>  Wir erkennen den Trick wirklich </h3><br>  Jetzt sind wir endlich bereit, die am Anfang dieses Abschnitts beschriebene Technik zu implementieren.  Wir wollen die Tiefe des Pixels, in dem wir uns befinden, mit der Tiefe des Pixels darunter vergleichen.  Das Pixel, in dem wir uns befinden, wird von einer Position in der Welt genommen, und das Pixel darunter wird von der Bildschirmposition erhalten.  Deshalb nehmen wir diese beiden Tiefen: <br><br><pre> <code class="javascript hljs">float worldDepth = getLinearDepth(WorldPosition); float screenDepth = getLinearScreenDepth();</code> </pre> <br><blockquote>  <em>Aufgabe 4: Einer dieser Werte wird niemals gr√∂√üer als der andere sein (vorausgesetzt, depthTest = true).</em>  <em>K√∂nnen Sie feststellen, welche?</em> </blockquote><br>  Wir wissen, dass Schaum dort ist, wo der Abstand zwischen den beiden Werten gering ist.  Lassen Sie uns diesen Unterschied daher f√ºr jedes Pixel rendern.  F√ºgen Sie dies am Ende des Shaders ein (und deaktivieren Sie das Tiefenvisualisierungsskript aus dem vorherigen Abschnitt): <br><br><pre> <code class="javascript hljs">color = vec4(vec3(screenDepth - worldDepth),<span class="hljs-number"><span class="hljs-number">1.0</span></span>); gl_FragColor = color;</code> </pre> <br>  Und es sollte ungef√§hr so ‚Äã‚Äãaussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/173/883/ad2173883ebe214bbec6c97921810755.png"></div><br>  Das hei√üt, wir w√§hlen die Grenzen jedes in Wasser getauchten Objekts in Echtzeit richtig aus!  Nat√ºrlich k√∂nnen Sie den Unterschied skalieren, um den Schaum dicker oder weniger h√§ufig zu machen. <br><br>  Wir haben jetzt viele M√∂glichkeiten, diese Ausgabe mit der Wasseroberfl√§che zu kombinieren, um sch√∂ne Schaumlinien zu erzeugen.  Sie k√∂nnen sie mit einem Farbverlauf belassen, zum Abtasten aus einer anderen Textur verwenden oder ihnen eine bestimmte Farbe zuweisen, wenn der Unterschied kleiner oder gleich einem bestimmten Grenzwert ist. <br><br>  Was mir am besten gefallen hat, war die Zuweisung einer Farbe, die den Linien des statischen Wassers √§hnelt, sodass meine fertige Hauptfunktion folgenderma√üen aussieht: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec2 pos = vUv0 * <span class="hljs-number"><span class="hljs-number">2.0</span></span>; pos.y += uTime * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; vec4 WaterLines = texture2D(uSurfaceTexture,pos); color.rgba += WaterLines.r * <span class="hljs-number"><span class="hljs-number">0.1</span></span>; float worldDepth = getLinearDepth(WorldPosition); float screenDepth = getLinearScreenDepth(); float foamLine = clamp((screenDepth - worldDepth),<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(foamLine &lt; <span class="hljs-number"><span class="hljs-number">0.7</span></span>){ color.rgba += <span class="hljs-number"><span class="hljs-number">0.2</span></span>; } gl_FragColor = color; }</code> </pre> <br><h2>  Zusammenfassend </h2><br>  Wir haben den Auftrieb von in Wasser getauchten Objekten erzeugt, eine sich bewegende Textur auf die Oberfl√§che aufgebracht, um √Ñtzmittel zu simulieren, und gelernt, wie man mit dem Tiefenpuffer dynamische Schaumstreifen erzeugt. <br><br>  Im dritten und letzten Teil werden wir die Effekte der Nachbearbeitung hinzuf√ºgen und lernen, wie man sie verwendet, um den Effekt der Unterwasserverzerrung zu erzeugen. <br><br><h2>  Quellcode </h2><br>  Das fertige PlayCanvas-Projekt finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">hier</a> .  Unser Repository hat auch einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Projektport unter Three.js</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416983/">https://habr.com/ru/post/de416983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416967/index.html">Wie wir BelAZ gemacht haben. Teil 3 - Teilinbetriebnahme</a></li>
<li><a href="../de416969/index.html">Pythagoreische mathematische Begr√ºndung der musikalischen Skala</a></li>
<li><a href="../de416977/index.html">Smart Home Software # 2</a></li>
<li><a href="../de416979/index.html">Scrum zu gro√üen Teams: LeSS Day 2018</a></li>
<li><a href="../de416981/index.html">Wie acht Personen ein Hochlastprojekt skalieren. Unsplash-Erfahrung</a></li>
<li><a href="../de416985/index.html">Auf das n√§chste Hundertstel: Top 10 SmartData 2017-Berichte</a></li>
<li><a href="../de416987/index.html">Gartner: Die Hauptsache auf dem IaaS-Markt im Jahr 2018</a></li>
<li><a href="../de416989/index.html">Festo bionische Roboter: Spinnen und Tintenfische in den Fabriken der Zukunft?</a></li>
<li><a href="../de416991/index.html">Das Aufnehmen von Videos von Ihrem Bildschirm ist nicht so geheim. King Burger Versionen und Appsee</a></li>
<li><a href="../de416993/index.html">Lernen Sie Sofia kennen: einen Roboter, der kaum von Menschen zu unterscheiden ist</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>