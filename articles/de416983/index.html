<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏿 🐅 🧝 Erstellen Sie einen Cartoon-Water-Shader für das Web. Teil 2 👨🏾‍💼 👨🏿‍🔧 🦍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Teil haben wir uns mit der Einrichtung der Umgebung und der Wasseroberfläche befasst. In diesem Teil geben wir Objekten Auftrieb, fügen Wass...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie einen Cartoon-Water-Shader für das Web. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416983/"> Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil haben</a> wir uns mit der Einrichtung der Umgebung und der Wasseroberfläche befasst.  In diesem Teil geben wir Objekten Auftrieb, fügen Wasserlinien auf der Oberfläche hinzu und erstellen Schaumlinien mit einem Tiefenpuffer um die Grenzen von Objekten, die sich mit der Oberfläche schneiden. <br><br>  Um die Szene ein wenig besser aussehen zu lassen, habe ich kleinere Änderungen daran vorgenommen.  Sie können Ihre Szene nach Ihren Wünschen anpassen, aber ich habe Folgendes getan: <br><br><ul><li>  Modelle eines Leuchtturms und eines Oktopus hinzugefügt. </li><li> Ein Grundmodell mit der Farbe <code>#FFA457</code> . </li><li>  <code>#6CC8FF</code> eine Himmelsfarbe von <code>#6CC8FF</code> . </li><li>  <code>#FFC480</code> Hintergrundbeleuchtung Farbe zur Szene hinzugefügt (diese Parameter finden Sie in den Szeneneinstellungen). </li></ul><br>  Meine ursprüngliche Szene sieht jetzt so aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/2fa/0d5/bc22fa0d57b5120e75cced6f105bebd2.png"></div><a name="habracut"></a><br><h2>  Auftrieb </h2><br>  Der einfachste Weg, Auftrieb zu erzeugen, besteht darin, Objekte mithilfe eines Skripts nach oben und unten zu verschieben.  Erstellen Sie ein neues <strong>Buoyancy.js-</strong> Skript und legen Sie bei der Initialisierung Folgendes fest: <br><br><pre> <code class="javascript hljs">Buoyancy.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initialPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.getPosition().clone(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initialRotation = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.getEulerAngles().clone(); <span class="hljs-comment"><span class="hljs-comment">//     ,  //        //     this.time = Math.random() * 2 * Math.PI; };</span></span></code> </pre> <br>  Jetzt im Update führen wir das Zeitinkrement aus und drehen das Objekt: <br><br><pre> <code class="javascript hljs">Buoyancy.prototype.update = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time += <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      var pos = this.entity.getPosition().clone(); pos.y = this.initialPosition.y + Math.cos(this.time) * 0.07; this.entity.setPosition(pos.x,pos.y,pos.z); //    var rot = this.entity.getEulerAngles().clone(); rot.x = this.initialRotation.x + Math.cos(this.time * 0.25) * 1; rot.z = this.initialRotation.z + Math.sin(this.time * 0.5) * 2; this.entity.setLocalEulerAngles(rot.x,rot.y,rot.z); };</span></span></code> </pre> <br>  Wenden Sie dieses Skript auf das Boot an und sehen Sie, wie es im Wasser auf und ab springt!  Sie können dieses Skript auf mehrere Objekte anwenden (einschließlich der Kamera - probieren Sie es aus)! <br><br><h2>  Oberflächentextur </h2><br>  Während wir die Wellen sehen können, schauen wir auf die Ränder der Wasseroberfläche.  Durch Hinzufügen von Textur wird die Oberflächenbewegung deutlicher.  Darüber hinaus ist es eine kostengünstige Möglichkeit, Reflexionen und Ätzungen zu simulieren. <br><br>  Sie können versuchen, einige ätzende Texturen zu finden oder selbst eine zu erstellen.  Ich habe <a href="" rel="external">eine Textur</a> in Gimp gezeichnet, die Sie frei verwenden können.  Jede Textur ist geeignet, sofern sie ohne erkennbare Fugen gekachelt werden kann. <br><br>  Nachdem Sie die gewünschte Textur ausgewählt haben, ziehen Sie sie in das Assets-Fenster Ihres Projekts.  Wir müssen diese Textur aus dem Water.js-Skript referenzieren, also erstellen wir ein Attribut dafür: <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'surfaceTexture'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'texture'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Surface Texture'</span></span> });</code> </pre> <br>  Und dann im Editor zuweisen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/672/61e/32f/67261e32f145eda9dab99d1866181ced.png"></div><br>  Jetzt müssen wir es an den Shader weitergeben.  Gehen Sie zu <strong>Water.js</strong> und setzen Sie die <code>CreateWaterMaterial</code> Funktion <code>CreateWaterMaterial</code> neuen Parameter: <br><br><pre> <code class="javascript hljs">material.setParameter(<span class="hljs-string"><span class="hljs-string">'uSurfaceTexture'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.surfaceTexture.resource);</code> </pre> <br>  Gehen Sie jetzt zurück zu <strong>Water.frag</strong> und erklären Sie eine neue Uniform: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture;</code> </pre> <br>  Wir sind fast fertig.  Um eine Textur in einer Ebene zu rendern, müssen wir wissen, wo sich jedes Pixel im Netz befindet.  Das heißt, wir müssen Daten vom Vertex-Shader zum Fragment One übertragen. <br><br><h3>  Unterschiedliche Variablen </h3><br>  <em>Mit unterschiedlichen</em> Variablen können Sie Daten vom Vertex-Shader zum Fragment-Shader übertragen.  Dies ist der dritte Typ von speziellen Variablen, die im Shader verwendet werden können (die ersten beiden sind <em>einheitlich</em> und <em>Attribut</em> ).  Für jeden Scheitelpunkt wird eine Variable festgelegt, auf die jedes Pixel zugreifen kann.  Da es viel mehr Pixel als Scheitelpunkte gibt, wird der Wert zwischen den Scheitelpunkten interpoliert (daher der Name "variierend" - er weicht von den an ihn übergebenen Werten ab). <br><br>  Um es im Betrieb zu testen, deklarieren Sie eine neue Variable in <strong>Water.vert</strong> als variierend: <br><br><pre> <code class="javascript hljs">varying vec2 ScreenPosition;</code> </pre> <br>  Und weisen Sie <code>gl_Position</code> nach der Berechnung den Wert <code>gl_Position</code> : <br><br><pre> <code class="javascript hljs">ScreenPosition = gl_Position.xyz;</code> </pre> <br>  <strong>Kehren Sie</strong> nun zu <strong>Water.frag zurück</strong> und deklarieren Sie dieselbe Variable.  Wir können die Ausgabe von Debugging-Daten nicht vom Shader abrufen, aber wir können Farbe für das visuelle Debugging verwenden.  So geht's: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec3 ScreenPosition; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    varying- color = vec4(vec3(ScreenPosition.x),1.0); gl_FragColor = color; }</span></span></code> </pre> <br>  Die Ebene sollte jetzt schwarzweiß aussehen, und die <code>ScreenPosition.x</code> verläuft dort, wo <code>ScreenPosition.x</code> = 0 ist. Die Farbwerte ändern sich nur von 0 auf 1, die Werte in <code>ScreenPosition</code> können jedoch außerhalb dieses Bereichs liegen.  Sie werden automatisch begrenzt. Wenn Sie also Schwarz sehen, kann dies 0 oder eine negative Zahl sein. <br><br>  Was wir gerade getan haben, ist, die Bildschirmposition jedes Scheitelpunkts an jedes Pixel zu übergeben.  Sie können sehen, dass die Linie zwischen der schwarzen und der weißen Seite immer in der Mitte des Bildschirms verläuft, unabhängig davon, wo sich die Oberfläche tatsächlich auf der Welt befindet. <br><br><blockquote>  <em>Aufgabe 1: Erstellen Sie eine neue variierende Variable, um die Position in der Welt anstelle der Bildschirmposition zu übertragen.</em>  <em>Visualisieren Sie es auf die gleiche Weise.</em>  <em>Wenn sich die Farbe mit der Bewegung der Kamera nicht ändert, ist alles korrekt.</em> </blockquote><br><h3>  Mit UV </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">UV</a> sind die 2D-Koordinaten jedes Scheitelpunkts im Netz, normalisiert von 0 bis 1. Sie sind für die korrekte Abtastung der Textur in der Ebene erforderlich, und wir haben sie bereits im vorherigen Teil konfiguriert. <br><br>  <strong>Wir</strong> deklarieren ein neues Attribut in <strong>Water.vert</strong> (dieser Name stammt aus der Definition eines Shaders in Water.js): <br><br><pre> <code class="javascript hljs">attribute vec2 aUv0;</code> </pre> <br>  Und jetzt müssen wir es nur noch an den Fragment-Shader übergeben, also einfach variieren und ihm den Attributwert zuweisen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Water.vert //        varying vec2 vUv0; // .. //        //  varying,        vUv0 = aUv0;</span></span></code> </pre> <br>  Jetzt deklarieren wir dieselbe variierende Variable im Fragment-Shader.  Um sicherzustellen, dass alles funktioniert, können wir das Debuggen wie zuvor visualisieren, und dann sieht Water.frag folgendermaßen aus: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  UV color = vec4(vec3(vUv0.x),1.0); gl_FragColor = color; }</span></span></code> </pre> <br>  Sie sollten einen Farbverlauf sehen, der bestätigt, dass wir an einem Ende den Wert 0 und am anderen Ende den Wert 1 haben.  Um die Textur wirklich zu testen, müssen wir nur noch Folgendes tun: <br><br><pre> <code class="javascript hljs">color = texture2D(uSurfaceTexture,vUv0);</code> </pre> <br>  Danach sehen wir die Textur auf der Oberfläche: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f49/9bf/ae2/f499bfae266b0aa16709bbea0280df6f.png"></div><br><h3>  Textur-Styling </h3><br>  Anstatt nur die Textur als neue Farbe festzulegen, kombinieren wir sie mit dem vorhandenen Blau: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec4 WaterLines = texture2D(uSurfaceTexture,vUv0); color.rgba += WaterLines.r; gl_FragColor = color; }</code> </pre> <br>  Dies funktioniert, weil die Texturfarbe überall außer Wasserlinien schwarz (0) ist.  Wenn Sie es hinzufügen, ändern wir die anfängliche blaue Farbe nicht, mit Ausnahme von Stellen mit Linien, an denen es heller wird. <br><br>  Dies ist jedoch nicht die einzige Möglichkeit, Farben zu kombinieren. <br><br><blockquote>  <em>Aufgabe 2: Können Sie die Farben kombinieren, um den unten gezeigten schwächeren Effekt zu erzielen?</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3d/e18/22a/a3de1822a348656f47e5bd6cfa6cbed5.png"></div><br><h3>  Textur bewegen </h3><br>  Als letzten Effekt möchten wir, dass sich die Linien entlang der Oberfläche bewegen und sie nicht so statisch aussehen.  Dazu nutzen wir die Tatsache, dass jeder Wert außerhalb des Intervalls von 0 bis 1, der an die Funktion <code>texture2D</code> wird, übertragen wird (z. B. werden sowohl 1,5 als auch 2,5 gleich 0,5).  Daher können wir unsere Position um die einheitliche Zeitvariable erhöhen, die wir bereits festgelegt haben, um die Liniendichte auf der Oberfläche zu erhöhen oder zu verringern, wodurch der endgültige Fragment-Shader diese Form erhält: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; uniform float uTime; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec2 pos = vUv0; <span class="hljs-comment"><span class="hljs-comment">//      1 //     pos *= 2.0; //   ,      pos.y += uTime * 0.02; vec4 WaterLines = texture2D(uSurfaceTexture,pos); color.rgba += WaterLines.r; gl_FragColor = color; }</span></span></code> </pre> <br><h2>  Schaumlinien und Tiefenpuffer </h2><br>  Durch das Rendern von Schaumstofflinien um Objekte im Wasser ist es viel einfacher zu erkennen, wie eingetaucht die Objekte sind und wo sie die Oberfläche überqueren.  Außerdem wird unser Wasser auf diese Weise viel glaubwürdiger.  Um die Schaumlinien zu erkennen, müssen wir irgendwie herausfinden, wo sich die Grenzen jedes Objekts befinden, und dies effektiv tun. <br><br><h3>  Trick </h3><br>  Wir müssen lernen zu bestimmen, ob sich ein Pixel auf der Wasseroberfläche in der Nähe des Objekts befindet.  Wenn ja, dann können wir es in der Farbe des Schaums malen.  Es gibt keine einfachen Möglichkeiten, dieses Problem zu lösen (soweit ich weiß).  Um es zu lösen, verwende ich daher eine nützliche Technik zur Lösung von Problemen: Ich werde ein Beispiel nehmen, für das wir die Antwort kennen und sehen, ob wir sie verallgemeinern können. <br><br>  Schauen Sie sich das Bild unten an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d0/0e7/eec/4d00e7eec8714a365c110aea67df9fab.png"></div><br>  Welche Pixel sollten Teil des Schaums sein?  Wir wissen, dass es ungefähr so ​​aussehen sollte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a8/541/c4f/1a8541c4f8fdd65879966b909805c484.png"></div><br>  Schauen wir uns also zwei bestimmte Pixel an.  Unten habe ich sie mit Sternchen markiert.  Schwarz wird auf dem Schaum sein und Rot nicht.  Wie unterscheiden wir sie in einem Shader? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/d35/fb2/012d35fb25d42c19a86adaa081048237.png"></div><br>  Wir wissen, dass diese beiden Pixel im Bildschirmbereich zwar nahe beieinander liegen (beide werden auf dem Leuchtturm gerendert), aber im Weltraum der Welt tatsächlich sehr weit entfernt sind.  Wir können dies überprüfen, indem wir dieselbe Szene aus einem anderen Blickwinkel betrachten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd3/5a0/31b/cd35a031bbd18805128ebd44ed1c1279.png"></div><br>  Beachten Sie, dass sich der rote Stern nicht auf dem Leuchtturm befindet, wie es uns schien, sondern der schwarze tatsächlich.  Wir können von der Entfernung zur Kamera unterscheiden, die normalerweise als "Tiefe" bezeichnet wird.  Tiefe 1 bedeutet, dass der Punkt sehr nahe an der Kamera liegt, Tiefe 0 bedeutet, dass er sehr weit entfernt ist.  Dabei geht es aber nicht nur um absolute Entfernungen in der Welt, Tiefe oder Kamera.  Die Tiefe <em>relativ zum Pixel dahinter ist</em> wichtig. <br><br>  Schauen Sie sich noch einmal die erste Ansicht an.  Nehmen wir an, der Rumpf des Leuchtturms hat einen Tiefenwert von 0,5.  Die Tiefe des schwarzen Sterns liegt sehr nahe bei 0,5.  Das heißt, es und das Pixel darunter haben sehr enge Tiefenwerte.  Auf der anderen Seite hat das rote Sternchen eine viel größere Tiefe, da es näher an der Kamera liegt, z. B. 0,7.  Und obwohl sich das Pixel dahinter noch auf dem Leuchtturm befindet, hat es einen Tiefenwert von 0,5, das heißt, es gibt mehr Unterschiede. <br><br>  Das ist der Trick.  <em>Wenn die Tiefe eines Pixels auf der Wasseroberfläche nahe genug an der Tiefe des Pixels liegt, über das es gezeichnet wird, befinden wir uns ziemlich nahe am Rand eines Objekts</em> und können das Pixel wie Schaum rendern. <br><br>  Das heißt, wir brauchen mehr Informationen als in jedem Pixel.  Wir müssen irgendwie die Tiefe des Pixels herausfinden, über das es gezeichnet werden soll.  Und hier ist der Tiefenpuffer für uns nützlich. <br><br><h3>  Tiefenpuffer </h3><br>  Sie können sich einen Frame-Puffer oder Frame-Buffer als Ziel-Rendering oder Textur außerhalb des Bildschirms vorstellen.  Wenn wir Daten lesen müssen, müssen wir außerhalb des Bildschirms rendern.  Diese Technik wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">beim Raucheffekt eingesetzt</a> . <br><br>  Der Tiefenpuffer ist ein spezielles Ziel-Rendering, das Informationen zu den Tiefenwerten jedes Pixels enthält.  Vergessen Sie nicht, dass der im Vertex-Shader berechnete Wert in <code>gl_Position</code> der Bildschirmraumwert war, aber auch eine dritte Koordinate hat - den Z-Wert. Dieser Z-Wert wird zur Berechnung der Tiefe verwendet, die in den Tiefenpuffer geschrieben wird. <br><br>  Der Tiefenpuffer dient zum korrekten Rendern der Szene, ohne dass Objekte von hinten nach vorne sortiert werden müssen.  Jedes zuerst zu zeichnende Pixel überprüft den Tiefenpuffer.  Wenn sein Tiefenwert größer als der Wert im Puffer ist, wird er gezeichnet und sein eigener Wert überschreibt den Wert des Puffers.  Andernfalls wird es verworfen (weil es bedeutet, dass sich ein anderes Objekt davor befindet). <br><br>  Tatsächlich können Sie das Schreiben in den Tiefenpuffer deaktivieren, um zu sehen, wie alles ohne ihn aussehen würde.  Versuchen wir es in Water.js: <br><br><pre> <code class="javascript hljs">material.depthTest = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Sie werden feststellen, dass Wasser jetzt immer von oben gezogen wird, auch wenn es sich hinter undurchsichtigen Objekten befindet. <br><br><h3>  Tiefenpuffer-Visualisierung </h3><br>  Fügen wir eine Möglichkeit hinzu, den Tiefenpuffer für Debugging-Zwecke zu rendern.  Erstellen Sie ein neues <strong>DepthVisualize.js-</strong> Skript.  Befestigen Sie es an der Kamera. <br><br>  Um auf den Tiefenpuffer in PlayCanvas zuzugreifen, schreiben Sie einfach Folgendes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.camera.camera.requestDepthMap();</code> </pre> <br>  Daher fügen wir die einheitliche Variable automatisch in alle unsere Shader ein, die wir verwenden können, indem wir sie wie folgt deklarieren: <br><br><pre> <code class="javascript hljs">uniform sampler2D uDepthMap;</code> </pre> <br>  Unten finden Sie ein Beispielskript, das eine Tiefenkarte anfordert und über einer Szene rendert.  Er hat einen Hot-Neustart konfiguriert. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DepthVisualize = pc.createScript(<span class="hljs-string"><span class="hljs-string">'depthVisualize'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  initialize,       DepthVisualize.prototype.initialize = function() { this.entity.camera.camera.requestDepthMap(); this.antiCacheCount = 0; //    ,         this.SetupDepthViz(); }; DepthVisualize.prototype.SetupDepthViz = function(){ var device = this.app.graphicsDevice; var chunks = pc.shaderChunks; this.fs = ''; this.fs += 'varying vec2 vUv0;'; this.fs += 'uniform sampler2D uDepthMap;'; this.fs += ''; this.fs += 'float unpackFloat(vec4 rgbaDepth) {'; this.fs += ' const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);'; this.fs += ' float depth = dot(rgbaDepth, bitShift);'; this.fs += ' return depth;'; this.fs += '}'; this.fs += ''; this.fs += 'void main(void) {'; this.fs += ' float depth = unpackFloat(texture2D(uDepthMap, vUv0)) * 30.0; '; this.fs += ' gl_FragColor = vec4(vec3(depth),1.0);'; this.fs += '}'; this.shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, this.fs, "renderDepth" + this.antiCacheCount); this.antiCacheCount ++; //     ,        this.command = new pc.Command(pc.LAYER_FX, pc.BLEND_NONE, function () { pc.drawQuadWithShader(device, null, this.shader); }.bind(this)); this.command.isDepthViz = true; //    ,      this.app.scene.drawCalls.push(this.command); }; //  update,     DepthVisualize.prototype.update = function(dt) { }; //  swap,      //      DepthVisualize.prototype.swap = function(old) { this.antiCacheCount = old.antiCacheCount; //      for(var i=0;i&lt;this.app.scene.drawCalls.length;i++){ if(this.app.scene.drawCalls[i].isDepthViz){ this.app.scene.drawCalls.splice(i,1); break; } } //    this.SetupDepthViz(); }; //      ,  : // http://developer.playcanvas.com/en/user-manual/scripting/</span></span></code> </pre> <br>  Versuchen Sie, den Code zu kopieren und die Zeile <code>this.app.scene.drawCalls.push(this.command);</code> kommentieren / zu kommentieren <code>this.app.scene.drawCalls.push(this.command);</code>  zum Aktivieren / Deaktivieren des Tiefen-Renderings.  Dies sollte wie im Bild unten aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c09/93a/c4f/c0993ac4f8ed7a4c739658bbff69e455.png"></div><br><blockquote>  <em>Aufgabe 3: Die Wasseroberfläche wird nicht in den Tiefenpuffer gezogen.</em>  <em>Die PlayCanvas-Engine tut dies absichtlich.</em>  <em>Können Sie herausfinden warum?</em>  <em>Was ist das Besondere am Wassermaterial?</em>  <em>Mit anderen Worten, was würde angesichts unserer Regeln zur Überprüfung der Tiefe passieren, wenn Pixel Wasser in den Tiefenpuffer geschrieben würden?</em> </blockquote><br>  <em>Hinweis: Sie können eine Zeile in Water.js ändern, wodurch Sie Wasser in den Tiefenpuffer schreiben können.</em> <br><br>  Es sollte auch beachtet werden, dass ich in der Initialisierungsfunktion den Tiefenwert mit 30 multipliziere. Dies ist notwendig, um ihn klar zu sehen, da sonst der Wertebereich zu klein wäre, um Farbtöne anzuzeigen. <br><br><h3>  Trick-Implementierung </h3><br>  In der PlayCanvas-Engine gibt es mehrere Zusatzfunktionen für die Arbeit mit Tiefenwerten. Zum Zeitpunkt des Schreibens waren sie jedoch noch nicht in der Produktion freigegeben, sodass wir sie selbst konfigurieren müssen. <br><br>  Wir <strong>definieren die</strong> folgenden einheitlichen Variablen in <strong>Water.frag</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   uniform-    PlayCanvas uniform sampler2D uDepthMap; uniform vec4 uScreenSize; uniform mat4 matrix_view; //      uniform vec4 camera_params;</span></span></code> </pre> <br>  Wir definieren diese Hilfsfunktionen über die Hauptfunktion: <br><br><pre> <code class="javascript hljs">#ifdef GL2 float linearizeDepth(float z) { z = z * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> / (camera_params.z * z + camera_params.w); } #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #ifndef UNPACKFLOAT #define UNPACKFLOAT float unpackFloat(vec4 rgbaDepth) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec4 bitShift = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span> / (<span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / (<span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-number"><span class="hljs-number">256.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dot(rgbaDepth, bitShift); } #endif #endif float getLinearScreenDepth(vec2 uv) { #ifdef GL2 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y; #endif } float getLinearDepth(vec3 pos) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -(matrix_view * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)).z; } float getLinearScreenDepth() { vec2 uv = gl_FragCoord.xy * uScreenSize.zw; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getLinearScreenDepth(uv); }</code> </pre> <br>  Wir werden die Shader-Informationen über die Kamera in <strong>Water.js weitergeben</strong> .  Fügen Sie dies dort ein, wo Sie die anderen einheitlichen Variablen wie uTime übergeben: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.root.findByName(<span class="hljs-string"><span class="hljs-string">"Camera"</span></span>).camera; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = camera.nearClip; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = camera.farClip; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera_params = [ <span class="hljs-number"><span class="hljs-number">1</span></span>/f, f, (<span class="hljs-number"><span class="hljs-number">1</span></span>-f / n) / <span class="hljs-number"><span class="hljs-number">2</span></span>, (<span class="hljs-number"><span class="hljs-number">1</span></span> + f / n) / <span class="hljs-number"><span class="hljs-number">2</span></span> ]; material.setParameter(<span class="hljs-string"><span class="hljs-string">'camera_params'</span></span>, camera_params);</code> </pre> <br>  Schließlich benötigen wir für unseren Fragment-Shader eine Position in der Welt jedes Pixels.  Wir müssen es vom Vertex-Shader bekommen.  Daher definieren wir in <strong>Water.frag</strong> eine variierende Variable: <br><br><pre> <code class="javascript hljs">varying vec3 WorldPosition;</code> </pre> <br>  Definieren Sie dieselbe variierende Variable in <strong>Water.vert</strong> .  Dann weisen wir ihm eine verzerrte Position vom Vertex-Shader zu, sodass der vollständige Code folgendermaßen aussieht: <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; attribute vec2 aUv0; varying vec2 vUv0; varying vec3 WorldPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; uniform float uTime; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vUv0 = aUv0; vec3 pos = aPosition; pos.y += cos(pos.z*<span class="hljs-number"><span class="hljs-number">5.0</span></span>+uTime) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> * sin(pos.x * <span class="hljs-number"><span class="hljs-number">5.0</span></span> + uTime); gl_Position = matrix_viewProjection * matrix_model * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); WorldPosition = pos; }</code> </pre> <br><h3>  Wir erkennen den Trick wirklich </h3><br>  Jetzt sind wir endlich bereit, die am Anfang dieses Abschnitts beschriebene Technik zu implementieren.  Wir wollen die Tiefe des Pixels, in dem wir uns befinden, mit der Tiefe des Pixels darunter vergleichen.  Das Pixel, in dem wir uns befinden, wird von einer Position in der Welt genommen, und das Pixel darunter wird von der Bildschirmposition erhalten.  Deshalb nehmen wir diese beiden Tiefen: <br><br><pre> <code class="javascript hljs">float worldDepth = getLinearDepth(WorldPosition); float screenDepth = getLinearScreenDepth();</code> </pre> <br><blockquote>  <em>Aufgabe 4: Einer dieser Werte wird niemals größer als der andere sein (vorausgesetzt, depthTest = true).</em>  <em>Können Sie feststellen, welche?</em> </blockquote><br>  Wir wissen, dass Schaum dort ist, wo der Abstand zwischen den beiden Werten gering ist.  Lassen Sie uns diesen Unterschied daher für jedes Pixel rendern.  Fügen Sie dies am Ende des Shaders ein (und deaktivieren Sie das Tiefenvisualisierungsskript aus dem vorherigen Abschnitt): <br><br><pre> <code class="javascript hljs">color = vec4(vec3(screenDepth - worldDepth),<span class="hljs-number"><span class="hljs-number">1.0</span></span>); gl_FragColor = color;</code> </pre> <br>  Und es sollte ungefähr so ​​aussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/173/883/ad2173883ebe214bbec6c97921810755.png"></div><br>  Das heißt, wir wählen die Grenzen jedes in Wasser getauchten Objekts in Echtzeit richtig aus!  Natürlich können Sie den Unterschied skalieren, um den Schaum dicker oder weniger häufig zu machen. <br><br>  Wir haben jetzt viele Möglichkeiten, diese Ausgabe mit der Wasseroberfläche zu kombinieren, um schöne Schaumlinien zu erzeugen.  Sie können sie mit einem Farbverlauf belassen, zum Abtasten aus einer anderen Textur verwenden oder ihnen eine bestimmte Farbe zuweisen, wenn der Unterschied kleiner oder gleich einem bestimmten Grenzwert ist. <br><br>  Was mir am besten gefallen hat, war die Zuweisung einer Farbe, die den Linien des statischen Wassers ähnelt, sodass meine fertige Hauptfunktion folgendermaßen aussieht: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec2 pos = vUv0 * <span class="hljs-number"><span class="hljs-number">2.0</span></span>; pos.y += uTime * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; vec4 WaterLines = texture2D(uSurfaceTexture,pos); color.rgba += WaterLines.r * <span class="hljs-number"><span class="hljs-number">0.1</span></span>; float worldDepth = getLinearDepth(WorldPosition); float screenDepth = getLinearScreenDepth(); float foamLine = clamp((screenDepth - worldDepth),<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(foamLine &lt; <span class="hljs-number"><span class="hljs-number">0.7</span></span>){ color.rgba += <span class="hljs-number"><span class="hljs-number">0.2</span></span>; } gl_FragColor = color; }</code> </pre> <br><h2>  Zusammenfassend </h2><br>  Wir haben den Auftrieb von in Wasser getauchten Objekten erzeugt, eine sich bewegende Textur auf die Oberfläche aufgebracht, um Ätzmittel zu simulieren, und gelernt, wie man mit dem Tiefenpuffer dynamische Schaumstreifen erzeugt. <br><br>  Im dritten und letzten Teil werden wir die Effekte der Nachbearbeitung hinzufügen und lernen, wie man sie verwendet, um den Effekt der Unterwasserverzerrung zu erzeugen. <br><br><h2>  Quellcode </h2><br>  Das fertige PlayCanvas-Projekt finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">hier</a> .  Unser Repository hat auch einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Projektport unter Three.js</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416983/">https://habr.com/ru/post/de416983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416967/index.html">Wie wir BelAZ gemacht haben. Teil 3 - Teilinbetriebnahme</a></li>
<li><a href="../de416969/index.html">Pythagoreische mathematische Begründung der musikalischen Skala</a></li>
<li><a href="../de416977/index.html">Smart Home Software # 2</a></li>
<li><a href="../de416979/index.html">Scrum zu großen Teams: LeSS Day 2018</a></li>
<li><a href="../de416981/index.html">Wie acht Personen ein Hochlastprojekt skalieren. Unsplash-Erfahrung</a></li>
<li><a href="../de416985/index.html">Auf das nächste Hundertstel: Top 10 SmartData 2017-Berichte</a></li>
<li><a href="../de416987/index.html">Gartner: Die Hauptsache auf dem IaaS-Markt im Jahr 2018</a></li>
<li><a href="../de416989/index.html">Festo bionische Roboter: Spinnen und Tintenfische in den Fabriken der Zukunft?</a></li>
<li><a href="../de416991/index.html">Das Aufnehmen von Videos von Ihrem Bildschirm ist nicht so geheim. King Burger Versionen und Appsee</a></li>
<li><a href="../de416993/index.html">Lernen Sie Sofia kennen: einen Roboter, der kaum von Menschen zu unterscheiden ist</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>