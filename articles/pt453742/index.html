<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéæ üêê ü•† Plugin Memcached: NoSQL no MySQL üôá üíí ‚ôàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Meu nome √© Maxim Matyukhin, sou programador de PHP no Badoo . Em nosso trabalho, usamos ativamente o MySQL. Mas, √†s vezes, n√£o temos seu desempenh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plugin Memcached: NoSQL no MySQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/453742/"><img src="https://habrastorage.org/webt/1v/q0/h5/1vq0h5tev1qw1ivnheyxg7jfiqm.jpeg"><br><br>  Ol√°  Meu nome √© Maxim Matyukhin, sou programador de PHP no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Badoo</a> .  Em nosso trabalho, usamos ativamente o MySQL.  Mas, √†s vezes, n√£o temos seu desempenho, por isso estamos constantemente procurando maneiras de acelerar seu trabalho. <br><br>  Em 2010, Yoshinori Matsunobu introduziu o plug-in NoSQL MySQL chamado HandlerSocket.  Foi alegado que este plug-in permite executar mais de 750.000 solicita√ß√µes por segundo.  Ficamos curiosos e quase imediatamente come√ßamos a usar esta solu√ß√£o.  Gostamos tanto do resultado que come√ßamos a fazer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">apresenta√ß√µes</a> e a escrever <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigos</a> promovendo o HandlerSocket. <br><br>  Aparentemente, √©ramos um dos poucos usu√°rios deste plugin - desde o MySQL 5.7 ele parou de funcionar.  Mas nesta vers√£o apareceu outro plug-in da Oracle - o plugin InnoDB memcached, que prometia funcionalidade semelhante. <br><br>  Apesar do fato de o plugin memcached ter aparecido no MySQL 5.6 em 2013, n√£o h√° muitos artigos sobre o assunto e, na maioria das vezes, eles repetem a documenta√ß√£o: um r√≥tulo simples √© criado e solicita√ß√µes s√£o feitas atrav√©s do cliente memcached. <br><br>  Temos uma vasta experi√™ncia com o Memcached e estamos acostumados √† facilidade de interagir com ele.  No plugin memcached do InnoDB, esper√°vamos a mesma simplicidade.  Por√©m, na verdade, se os padr√µes de uso do plug-in forem pelo menos um pouco diferentes dos descritos na documenta√ß√£o e nos artigos, muitas nuances e limita√ß√µes aparecer√£o, o que definitivamente vale a pena considerar se voc√™ usar√° o plug-in. <br><a name="habracut"></a><br><h1>  MySQL HandlerSocket </h1><br>  Neste artigo, compararemos, de uma forma ou de outra, o novo plugin do memcached com o antigo HandlerSocket.  Portanto, lembro que foi o √∫ltimo. <br><br>  Ap√≥s instalar o plugin HandlerSocket, o MySQL come√ßou a ouvir duas portas adicionais: <br><br><ol><li>  A primeira porta recebeu solicita√ß√µes do cliente para leitura de dados. <br></li><li>  A segunda porta recebeu solicita√ß√µes do cliente para grava√ß√£o de dados. <br></li></ol><br>  O cliente teve que estabelecer uma conex√£o TCP regular em uma dessas portas (nenhuma autentica√ß√£o foi suportada) e, depois disso, foi necess√°rio enviar o comando ‚Äúopen index‚Äù (um comando especial com o qual o cliente informou qual tabela de qual √≠ndice de quais campos est√°vamos indo) leia (ou escreva)). <br><br>  Se o comando "√≠ndice aberto" funcionou com √™xito, voc√™ pode enviar comandos GETs ou INSERT / UPDATE / DELETE, dependendo da porta em que a conex√£o foi estabelecida. <br><br>  O HandlerSocket permitiu executar n√£o apenas GETs na chave prim√°ria, mas tamb√©m amostras simples de um √≠ndice n√£o exclusivo, amostras de intervalo, multigets suportados e LIMIT.  Ao mesmo tempo, foi poss√≠vel trabalhar com a tabela a partir do SQL comum e atrav√©s do plug-in.  Isso, por exemplo, permitiu fazer algumas altera√ß√µes nas transa√ß√µes atrav√©s do SQL e, em seguida, ler esses dados atrav√©s do HandlerSocket. <br><br>  √â importante que o HandlerSocket manipule todas as conex√µes com um pool limitado de threads atrav√©s do epoll, por isso foi f√°cil suportar dezenas de milhares de conex√µes, enquanto no MySQL foi criado um thread para cada conex√£o e seu n√∫mero era muito limitado. <br><br>  Ao mesmo tempo, ainda √© um servidor MySQL comum - uma tecnologia familiar para n√≥s.  N√≥s sabemos como replic√°-lo e monitor√°-lo.  Monitorar HandlerSocket √© dif√≠cil porque n√£o fornece nenhuma m√©trica espec√≠fica;  no entanto, algumas das m√©tricas padr√£o do MySQL e InnoDB s√£o √∫teis. <br><br>  Obviamente, havia inconvenientes, em particular, este plug-in n√£o suportava o trabalho com o tipo de carimbo de data / hora.  Bem, o protocolo HandlerSocket √© mais dif√≠cil de ler e, portanto, mais dif√≠cil de depurar. <br><br>  Leia mais sobre HandlerSocket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Voc√™ tamb√©m pode assistir a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma de nossas apresenta√ß√µes</a> . <br><br><h1>  Plugin memcached do InnoDB </h1><br>  O que o novo plugin do memcached nos oferece? <br><br>  Como o nome indica, sua id√©ia √© usar o cliente memcached para trabalhar com o MySQL e receber e salvar dados atrav√©s de comandos memcached. <br><br>  Voc√™ pode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ler</a> sobre as principais vantagens do plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Estamos mais interessados ‚Äã‚Äãno seguinte: <br><br><ol><li>  Baixo consumo de CPU. <br></li><li>  Os dados s√£o armazenados no InnoDB, o que d√° certas garantias. <br></li><li>  Voc√™ pode trabalhar com dados por meio do Memcached e do SQL;  eles podem ser replicados usando as ferramentas internas do MySQL. <br></li></ol><br>  Voc√™ pode adicionar vantagens a esta lista como: <br><br><ol><li>  Conex√£o r√°pida e barata.  Uma conex√£o MySQL regular √© processada por um thread, e o n√∫mero de threads √© limitado e, no plugin memcached, um thread processa todas as conex√µes no loop de eventos. <br></li><li>  A capacidade de solicitar v√°rias chaves com uma solicita√ß√£o GET. <br></li><li>  Se comparar com o MySQL HandlerSocket, no plugin memcached n√£o √© necess√°rio usar o comando ‚ÄúOpen Table‚Äù e todas as opera√ß√µes de leitura e grava√ß√£o ocorrem na mesma porta. <br></li></ol><br><br>  Mais detalhes sobre o plugin podem ser encontrados na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> oficial.  Para n√≥s, as p√°ginas mais √∫teis foram: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Arquitetura memcached do InnoDB</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Interno de plug-in armazenado em mem√≥ria do InnoDB</a> . <br></li></ol><br>  Depois de instalar o plugin, o MySQL come√ßa a aceitar conex√µes na porta 11211 (porta memcached padr√£o).  Um banco de dados especial (esquema) innodb_memcache tamb√©m aparece, no qual voc√™ configurar√° o acesso √†s suas tabelas. <br><br><h1>  Exemplo simples </h1><br>  Suponha que voc√™ j√° tenha uma tabela com a qual deseja trabalhar atrav√©s do protocolo memcached: <br><br><pre><code class="plaintext hljs">CREATE TABLE `auth` (  `email` varchar(96) NOT NULL,  `password` varchar(64) NOT NULL,  `type` varchar(32) NOT NULL DEFAULT '',  PRIMARY KEY (`email`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci</code> </pre> <br>  e voc√™ deseja receber e modificar dados na chave prim√°ria. <br><br>  Voc√™ precisa primeiro descrever a correspond√™ncia entre a chave memcached e a tabela SQL na tabela innodb_memcache.containers.  Esta tabela √© mais ou menos assim (removi a descri√ß√£o da codifica√ß√£o para facilitar a leitura): <br><br><pre> <code class="plaintext hljs">CREATE TABLE `containers` ( `name` varchar(50) NOT NULL, `db_schema` varchar(250) NOT NULL, `db_table` varchar(250) NOT NULL, `key_columns` varchar(250) NOT NULL, `value_columns` varchar(250) DEFAULT NULL, `flags` varchar(250) NOT NULL DEFAULT '0', `cas_column` varchar(250) DEFAULT NULL, `expire_time_column` varchar(250) DEFAULT NULL, `unique_idx_name_on_key` varchar(250) NOT NULL, PRIMARY KEY (`name`) ) ENGINE=InnoDB DEFAULT</code> </pre> <br>  Os campos mais importantes: <br><br><ul><li>  nome - prefixo da sua chave do Memcached; <br></li><li>  db_schema - nome da base (circuito); <br></li><li>  db_table √© sua mesa; <br></li><li>  key_columns - o nome do campo na tabela pela qual procuraremos (geralmente essa √© sua chave prim√°ria); <br></li><li>  value_columns - uma lista de campos da tabela que estar√£o dispon√≠veis para o plugin memcached; <br></li><li>  unique_idx_name_on_key √© o √≠ndice a ser pesquisado (embora voc√™ j√° tenha especificado key_columns, eles podem estar em √≠ndices diferentes e voc√™ precisa especificar o √≠ndice explicitamente). <br></li></ul><br>  Os campos restantes n√£o s√£o muito importantes para come√ßar. <br><br>  Adicione uma descri√ß√£o da nossa tabela ao innodb_memcache.containers: <br><br><pre> <code class="plaintext hljs">INSERT INTO innodb_memcache.containers SET   name='auth',   db_schema='test',   db_table='auth',   key_columns='email',   value_columns='password|type',   flags='0',   cas_column='0',   expire_time_column='0',   unique_idx_name_on_key='PRIMARY';</code> </pre> <br>  Neste exemplo, name = 'auth' √© o prefixo da nossa chave do memcached.  Na documenta√ß√£o, geralmente √© chamado table_id e, posteriormente, neste artigo, usarei esse termo. <br><br>  Agora, o TELNET conecta-se ao plug-in memcached e tenta salvar e obter os dados: <br><br><pre> <code class="plaintext hljs">[21:26:22] maxm@localhost: ~&gt; telnet memchached-mysql.dev 11211 Trying 127.0.0.1... Connected to memchached-mysql.dev. Escape character is '^]'. get @@auth.max@example.com END set @@auth.max@example.com 0 0 10 1234567|89 STORED get @@auth.max@example.com VALUE @@auth.max@example.com 0 10 1234567|89 END</code> </pre> <br>  Primeiro, enviamos uma solicita√ß√£o GET, ela n√£o retornou nada para n√≥s.  Em seguida, salvamos os dados com uma solicita√ß√£o SET, ap√≥s a qual recuperamos com um GET. <br><br>  GET retornou a seguinte linha: 1234567 | 89.  Esses s√£o os valores dos campos "senha" e "tipo", separados pelo s√≠mbolo "|".  Os campos s√£o retornados na ordem em que foram descritos em innodb_memcache.containers.value_columns. <br><br>  Talvez voc√™ esteja se perguntando agora: "O que acontecer√° se o s√≠mbolo" | "for encontrado na" senha "?"  Vou falar sobre isso abaixo. <br><br>  Atrav√©s do SQL, esses dados tamb√©m est√£o dispon√≠veis: <br><br><pre> <code class="plaintext hljs">MySQL [(none)]&gt; select * from auth where email='max@example.com'; +-----------------+----------+------+ | email      | password | type | +-----------------+----------+------+ | max@example.com | 1234567  | 89 | +-----------------+----------+------+ 1 row in set (0.00 sec)</code> </pre> <br><h2>  Table_id padr√£o </h2><br>  H√° tamb√©m esse modo de opera√ß√£o: <br><br><pre> <code class="plaintext hljs">get @@auth VALUE @@auth 0 21 test/auth END get max@example.com VALUE max@example.com 0 10 1234567|99 END set ivan@example.com 0 0 10 qwerty|xxx STORED get ivan@example.com VALUE ivan@example.com 0 10 qwerty|xxx END</code> </pre> <br>  Neste exemplo, com get @@ auth, tornamos table_id auth o prefixo padr√£o para esta conex√£o.  Depois disso, todas as consultas subseq√ºentes podem ser feitas sem especificar table_id. <br><br>  At√© agora, tudo √© simples e l√≥gico.  Mas se voc√™ come√ßar a entender, h√° muitas nuances.  Vou te contar o que encontramos. <br><br><h1>  Nuances </h1><br><h2>  Armazenando em cache a tabela innodb_memcache.containers </h2><br>  O plug-in memcached l√™ a tabela innodb_memcache.containers uma vez na inicializa√ß√£o.  Al√©m disso, se um table_id desconhecido chegar atrav√©s do protocolo Memcached, o plug-in procurar√° por ele na tabela.  Portanto, voc√™ pode adicionar facilmente novas chaves (id_tabela), mas se desejar alterar as configura√ß√µes de um id_tabela existente, precisar√° reiniciar o plug-in memcached: <br><br><pre> <code class="plaintext hljs">mysql&gt; UNINSTALL PLUGIN daemon_memcached; mysql&gt; INSTALL PLUGIN daemon_memcached soname "libmemcached.so";</code> </pre> <br>  Entre esses dois pedidos, a interface do Memcached n√£o funcionar√°.  Por isso, geralmente √© mais f√°cil criar um novo table_id do que alterar o existente e reiniciar o plug-in. <br><br>  Foi uma surpresa para n√≥s que uma nuance t√£o importante da opera√ß√£o de plug-in seja descrita na p√°gina <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Adaptando um Aplicativo Memcached para o InnoDB</a> , o que n√£o √© um lugar muito l√≥gico para essas informa√ß√µes. <br><br><h2>  Sinalizadores, cas_column, expire_time_column </h2><br>  Esses campos s√£o necess√°rios para simular alguns recursos do Memcached.  A documenta√ß√£o para eles √© inconsistente.  A maioria dos exemplos ilustra o trabalho com tabelas nas quais esses campos est√£o.  Pode haver uma preocupa√ß√£o de que voc√™ precisar√° adicion√°-los √†s suas tabelas (e esses s√£o pelo menos tr√™s campos INT).  Mas n√£o.  Se voc√™ n√£o tiver esses campos nas tabelas e n√£o usar√° a funcionalidade Memcached como CAS, expira√ß√£o ou sinalizadores, n√£o ser√° necess√°rio adicionar esses campos √†s tabelas. <br><br>  Ao configurar a tabela em innodb_memcache.containers, √© necess√°rio inserir '0' nesses campos, fazer exatamente a linha com zero: <br><br><pre> <code class="plaintext hljs">INSERT INTO innodb_memcache.containers SET   name='auth',   db_schema='test',   db_table='auth',   key_columns='email',   value_columns='password|type',   flags='0',   cas_column='0',   expire_time_column='0',   unique_idx_name_on_key='PRIMARY';</code> </pre> <br>  √â irritante que cas_column e expire_time_column tenham um valor padr√£o NULL, e se voc√™ executar INSERT INTO innodb_memcache.containers sem especificar o valor '0' para esses campos, NULL ser√° armazenado neles e esse prefixo de memcache simplesmente n√£o funcionar√°. <br><br><h2>  Tipos de dados </h2><br>  Na documenta√ß√£o, n√£o est√° muito claro quais tipos de dados podem ser usados ‚Äã‚Äãao trabalhar com o plug-in.  Em v√°rios lugares, diz-se que o plugin s√≥ pode funcionar com campos de texto (CHAR, VARCHAR, BLOB).  Aqui: A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">adapta√ß√£o de um esquema MySQL existente para o plug-in memcached do InnoDB</a> oferece o armazenamento de n√∫meros em campos de string e, se voc√™ precisar trabalhar com esses campos num√©ricos do SQL, crie uma VIEW na qual os campos VARCHAR com n√∫meros ser√£o convertidos em campos INTEGER : <br><br><pre> <code class="plaintext hljs">CREATE VIEW numbers AS SELECT c1 KEY, CAST(c2 AS UNSIGNED INTEGER) val FROM demo_test WHERE c2 BETWEEN '0' and '9999999999';</code> </pre> <br>  No entanto, em alguns lugares, a documenta√ß√£o ainda diz que voc√™ pode trabalhar com n√∫meros.  At√© agora, temos apenas uma experi√™ncia real de produ√ß√£o com campos de texto, mas os resultados experimentais mostram que o plug-in tamb√©m funciona com n√∫meros: <br><br><pre> <code class="plaintext hljs">CREATE TABLE `numbers` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `counter` int(10) unsigned NOT NULL DEFAULT '0', PRIMARY KEY (`id`) ) ENGINE=InnoDB INSERT INTO innodb_memcache.containers SET name='numbers', db_schema='test', db_table='numbers', key_columns='id', value_columns='counter', flags='0', cas_column='0',expire_time_column='0',unique_idx_name_on_key='PRIMARY';</code> </pre> <br>  Depois disso, atrav√©s do protocolo Memcached: <br><br><pre> <code class="plaintext hljs">get @@numbers.1 END set @@numbers.1 0 0 2 12 STORED get @@numbers.1 VALUE @@numbers.1 0 2 12 END</code> </pre> <br>  Vemos que o plugin memcached pode retornar qualquer tipo de dados.  Mas ele os retorna na forma em que est√£o no InnoDB; portanto, por exemplo, no caso de carimbo de data / hora / data / hora / flutua√ß√£o / decimal / JSON, uma string bin√°ria √© retornada.  Mas n√∫meros inteiros s√£o retornados como os vemos atrav√©s do SQL. <br><br><h2>  Multiget </h2><br>  O protocolo memcached permite solicitar v√°rias chaves com uma √∫nica solicita√ß√£o: <br><br><pre> <code class="plaintext hljs">get @@numbers.2 @@numbers.1 VALUE @@numbers.2 0 2 12 VALUE @@numbers.1 0 2 13 END</code> </pre> <br>  O fato de o multiget funcionar j√° √© bom.  Mas funciona dentro da estrutura de um table_id: <br><br><pre> <code class="plaintext hljs">get @@auth.ivan@example.com @@numbers.2 VALUE @@auth.ivan@example.com 0 10 qwerty|xxx END</code> </pre> <br>  Este ponto est√° descrito na documenta√ß√£o aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://dev.mysql.com/doc/refman/8.0/en/innodb-memcached-multiple-get-range-query.html</a> .  Acontece que no multiget voc√™ pode especificar table_id apenas para a primeira chave, se todas as outras chaves forem obtidas do table_id padr√£o (exemplo da documenta√ß√£o): <br><br><pre> <code class="plaintext hljs">get @@aaa.AA BB VALUE @@aaa.AA 8 12 HELLO, HELLO VALUE BB 10 16 GOODBYE, GOODBYE END</code> </pre> <br>  Neste exemplo, a segunda chave √© retirada do table_id padr√£o.  Poder√≠amos especificar muito mais chaves do table_id padr√£o e, para a primeira chave, especificamos um table_id separado, e isso s√≥ √© poss√≠vel no caso da primeira chave. <br><br>  Podemos dizer que o multiget funciona na estrutura de uma tabela, porque voc√™ n√£o deseja confiar nessa l√≥gica no c√≥digo de produ√ß√£o: n√£o √© √≥bvio, √© f√°cil esquec√™-lo, cometer um erro. <br><br>  Se comparado com HandlerSocket, tamb√©m haver√° multiget na mesma tabela.  Mas essa restri√ß√£o parecia natural: o cliente abre o √≠ndice na tabela e solicita um ou mais valores.  Por√©m, ao trabalhar com o plug-in memcached multiget em v√°rias chaves com prefixos diferentes, essa √© uma pr√°tica normal.  E voc√™ espera o mesmo do plugin memcached do MySQL.  Mas n√£o :( <br><br><h2>  INCR, DEL </h2><br>  Eu j√° dei exemplos de solicita√ß√µes GET / SET.  As consultas INCR e DEL t√™m um recurso.  Est√° no fato de que eles s√≥ funcionam ao usar o table_id padr√£o: <br><br><pre> <code class="plaintext hljs">DELETE @@numbers.1 ERROR get @@numbers VALUE @@numbers 0 24 test/numbers END delete 1 DELETED</code> </pre> <br><h2>  Limita√ß√µes do protocolo Memcached </h2><br>  O Memcached possui um protocolo de texto, que imp√µe algumas limita√ß√µes.  Por exemplo, chaves com cache de mem√≥rias n√£o devem conter caracteres de espa√ßo em branco (espa√ßo, avan√ßo de linha).  Se voc√™ olhar novamente para a descri√ß√£o da tabela do nosso exemplo: <br><br><pre> <code class="plaintext hljs">CREATE TABLE `auth` ( `email` varchar(96) NOT NULL, `password` varchar(64) NOT NULL, `type` varchar(32) NOT NULL DEFAULT '', PRIMARY KEY (`email`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci</code> </pre> <br>  isso significa que no campo "email" n√£o devem existir esses caracteres. <br><br>  Al√©m disso, as chaves em cache do memcached devem ter menos de 250 bytes (bytes, n√£o caracteres).  Se voc√™ enviar mais, voc√™ receber√° um erro: <br><br><pre> <code class="plaintext hljs">"CLIENT_ERROR bad command line format"</code> </pre> <br>  Al√©m disso, √© preciso levar em considera√ß√£o o fato de que o plugin memcached adiciona sua pr√≥pria sintaxe ao protocolo memcached.  Por exemplo, ele usa o caractere "|"  como um separador de campo na resposta.  Voc√™ precisa garantir que esse s√≠mbolo n√£o seja usado na sua tabela.  O separador pode ser configurado, mas as configura√ß√µes ser√£o aplicadas a todas as tabelas em todo o servidor MySQL. <br><br><h2>  Delimitador de campo value_columns </h2><br>  Se voc√™ precisar retornar v√°rias colunas atrav√©s do protocolo memcached, como em nosso primeiro exemplo: <br><br><pre> <code class="plaintext hljs">get @@auth.max@example.com VALUE @@auth.max@example.com 0 10 1234567|89 END</code> </pre> <br>  os valores da coluna s√£o separados pelo separador padr√£o "|".  Surge a pergunta: "O que acontecer√° se, por exemplo, o caractere" | "estiver no primeiro campo da linha?"  O plugin memcached nesse caso retornar√° a string como est√°, algo como isto: 1234 | 567 | 89.  No caso geral, √© imposs√≠vel entender onde h√° um campo. <br><br>  Portanto, √© importante escolher o separador certo imediatamente.  E como ser√° usado para todas as chaves de todas as tabelas, deve ser um caractere universal que n√£o ser√° encontrado em nenhum campo com o qual voc√™ trabalhar√° atrav√©s do protocolo memcached. <br><br><h1>  Sum√°rio </h1><br>  Isso n√£o quer dizer que o plugin do memcached esteja incorreto.  Mas parece que foi escrito para um esquema de trabalho espec√≠fico: um servidor MySQL com uma tabela que pode ser acessada usando o protocolo memcached, e este table_id √© padronizado.  Os clientes estabelecem uma conex√£o persistente com o plugin Memcached e fazem solicita√ß√µes para o table_id padr√£o.  Provavelmente, nesse esquema, tudo funcionar√° perfeitamente.  Se voc√™ se afastar, voc√™ encontrar√° v√°rios inconvenientes. <br><br>  Voc√™ pode esperar ver alguns relat√≥rios de desempenho do plug-in.  Mas ainda n√£o decidimos us√°-lo em locais altamente carregados.  N√≥s o usamos apenas em alguns sistemas n√£o muito carregados e l√° funciona aproximadamente na mesma velocidade que o HandlerSocket, mas n√£o fizemos benchmarks honestos.  Mas, no entanto, o plug-in fornece uma interface com a qual o programador pode facilmente cometer um erro - voc√™ precisa manter muitas nuances em mente.  Portanto, ainda n√£o estamos prontos para usar esse plug-in em massa. <br><br>  Fizemos algumas solicita√ß√µes de recursos no rastreador de erros do MySQL: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://bugs.mysql.com/bug.php?id=95091</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://bugs.mysql.com/bug.php?id=95092</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://bugs.mysql.com/bug.php?id=95093</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://bugs.mysql.com/bug.php?id=95094</a> <br><br>  Esperamos que a equipe de desenvolvimento de plugins do memcached melhore seu produto. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453742/">https://habr.com/ru/post/pt453742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453722/index.html">Sobre pesquisa de processos n√£o estacion√°rios</a></li>
<li><a href="../pt453728/index.html">Batalha dos Hyperstars</a></li>
<li><a href="../pt453730/index.html">Odontologia moderna: implanta√ß√£o dent√°ria simult√¢nea e extens√£o do osso maxilar atrav√©s dos olhos do diretor t√©cnico</a></li>
<li><a href="../pt453732/index.html">Eu sou de Moreinis. Opini√µes obl√≠quas ou respeito?</a></li>
<li><a href="../pt453734/index.html">Apresentando o Helm 3</a></li>
<li><a href="../pt453744/index.html">Estudamos o princ√≠pio da pseudo-classe: not () usando o exemplo da tarefa "Destacando a linha ativa de uma tabela em CSS puro"</a></li>
<li><a href="../pt453748/index.html">Prototipar um jogo para celular, por onde come√ßar e como faz√™-lo. Parte 3 (final)</a></li>
<li><a href="../pt453750/index.html">Sobre o recente ataque cibern√©tico de Baltimore</a></li>
<li><a href="../pt453756/index.html">Problemas da metodologia atual para determinar amea√ßas atuais do FSTEC</a></li>
<li><a href="../pt453760/index.html">Campo de treinamento em circuito para tanques e processadores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>