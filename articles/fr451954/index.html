<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚍 👩🏻‍⚕️ 🌲 Plus de télégrammes secrets 👨🏿‍🤝‍👨🏾 👩🏼‍🏭 🕛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tout le monde est habitué à considérer les télégrammes comme un moyen fiable et sûr d'envoyer des messages de toute nature. Cependant, sous le capot, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plus de télégrammes secrets</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451954/"><p>  Tout le monde est habitué à considérer les télégrammes comme un moyen fiable et sûr d'envoyer des messages de toute nature.  Cependant, sous le capot, il a une combinaison tout à fait ordinaire de cryptage a et symétrique, ce qui n'est pas du tout intéressant.  Et à la fin, pourquoi devriez-vous confier explicitement vos messages à un tiers? <br><img src="https://habrastorage.org/webt/fj/xl/ka/fjxlkasq2yqy1vfjle83rlnc4js.png" alt="CAPA par Antonio Prohías"><br>  TL; DR - inventez un canal caché privé grâce au blocage mutuel des utilisateurs. </p><a name="habracut"></a><br><h2 id="skrytyy-kanal">  Chaîne cachée </h2><br><p> Il existe de nombreuses solutions de contournement pour le transfert de données entre deux utilisateurs, en évitant les contacts explicites.  Vous pouvez utiliser des intermédiaires, la cryptographie et la stéganographie, des réseaux de relais de diffusion et d'autres modules complémentaires sur les protocoles existants.  Mais il est parfois utile de pouvoir prendre contact en utilisant uniquement les capacités officielles déclarées.  Autrement dit, organiser une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chaîne secrète</a> . </p><br><p>  Un exemple simple et compréhensible d'un canal caché pour un lecteur russophone est une fleur dans la fenêtre d'apparition de dix-sept moments du printemps.  En soi, il peut se tenir debout ou ne pas se tenir debout sur la fenêtre - une telle symbiose est tout à fait normale et ne parle que de l'amour du propriétaire de l'appartement pour les fleurs.  Seule une interprétation prédéterminée distingue les informations transmises par un éclaireur de celles obtenues par un passant aléatoire. </p><br><p><img src="https://habrastorage.org/webt/xq/z2/bs/xqz2bs06a68qp9m11r-fpqgy6fo.jpeg" alt="Fleur dans la fenêtre"></p><br><h2 id="cvetochno-okonnye-kanaly-telegrama">  Télégramme de canaux de fenêtre </h2><br><p>  Pour organiser votre chaîne cachée selon un tel exemple, seulement deux choses sont conceptuellement nécessaires: une fenêtre et une fleur.  La fenêtre décrit l'objet disponible pour changer et déterminer l'état, et la fleur décrit les valeurs possibles et la méthode pour les changer. </p><br><p>  Qu'est-ce qu'une Alice peut changer dans un télégramme, qui peut être consulté par un certain Bob?  Oui, beaucoup de choses: avatars, noms d'utilisateur, heure de la dernière visite et bien plus encore.  Cependant, ils sont généralement disponibles pour tout le monde immédiatement, ce qui limite la confidentialité d'un éventuel dialogue - toute personne connaissant la méthode de transmission pourra écouter les messages envoyés.  Curieusement, cette restriction peut être contournée sans recourir à la cryptographie. </p><br><h3 id="v-chernom-chernom-spiske">  Liste noire </h3><br><p>  Chaque utilisateur a sa propre liste noire unique, et si le lecteur y est allé au moins une fois, il aurait dû remarquer que la date de la dernière visite du délinquant est passée à "vue pour la dernière fois il y a longtemps" avec un avatar vide.  En fait, l'utilisateur pouvait être en ligne il y a au moins une seconde et changer une centaine de scellés dans son profil, mais l'API Telegram ne renvoie tout simplement pas ces données à l'application.  Ainsi, il protège votre vie personnelle des personnes indésirables, en retour leur faisant comprendre qu'elles sont bloquées. </p><br><p>  Alors, quel est le résultat de la chose commune entre la fleur dans la fenêtre et être dans la liste de blocage?  Cela et un autre peuvent être vérifiés à un certain moment, après avoir reçu un bit d'information selon que vous êtes dans la liste noire ou non.  Un bonus supplémentaire est le fait que les télégrammes ne stockent probablement pas dans leurs journaux (et s'ils le font, alors pas longtemps uniquement à des fins de journalisation) l'historique des blocages des utilisateurs. </p><br><h2 id="organizovyvaem-bity">  Organisez les battements </h2><br><p>  La capacité de transmettre et de recevoir des bits est, bien sûr, bonne, mais vous devez toujours décrire un mécanisme à part entière pour son fonctionnement.  Telegram n'envoie pas de notifications aux utilisateurs lorsqu'ils sont ajoutés à la liste noire, la réception de chaque bit doit donc être initiée par le destinataire (Bob) et ne pas dépendre de l'expéditeur (Alice).  Il s'ensuit également qu'Alice et Bob doivent répondre aux demandes avec la même fréquence, de sorte que chaque cycle d'horloge de l'expéditeur correspond à un cycle d'horloge du destinataire. </p><br><p>  L'algorithme d'échange lui-même sur chaque mesure ressemble à ceci: </p><br><ul><li>  A vérifie le bit envoyé et, s'il est nécessaire d'envoyer un signal, alors, en fonction de sa valeur: <br><ul><li>  A -&gt; T: bloc B; </li><li>  A -&gt; T: déverrouillez B. </li></ul></li><li>  B obtient un peu: <br><ul><li>  B -&gt; T: demande de l'utilisateur A; </li><li>  T -&gt; B: informations disponibles sur A; </li><li>  B: vérifie si les informations reçues ont le statut: <br><ul><li>  B: s'il y a -&gt; il n'est pas bloqué et a reçu 0 </li><li>  B: sinon -&gt; il est bloqué et reçu 1 </li></ul></li></ul></li></ul><br><p>  La plupart des processeurs utilisateur modernes ont de bons générateurs de fréquence intégrés (au moins l'horloge système), de sorte que les horloges peuvent être synchronisées avec elles sans utiliser le canal de données lui-même.  Il convient de noter que les demandes à l'API de télégramme sont réseau et ne se précipitent pas pour fonctionner rapidement, ce qui n'aide pas le fait de son blocage en Fédération de Russie et la nécessité d'utiliser des procurations.  Mais la durée du cycle devrait en moyenne dépasser le temps nécessaire pour répondre à ces demandes, de sorte que la fréquence et la vitesse de transfert des données sont extrêmement faibles. </p><br><h3 id="kodiruem-soobscheniya">  Nous encodons des messages </h3><br><p>  Les textes en langage naturel ont une redondance assez élevée, donc les messages reçus avec des erreurs seront toujours souvent compréhensibles pour les humains.  Et comme le télégramme est toujours un messager, malgré les tentatives de lui attacher toutes sortes de gadgets graphiques-audio-vidéo, la correction d'erreur peut être négligée, limitant les données transmises aux messages texte. </p><br><p>  En raison du faible débit du canal caché, vous devez utiliser le codage le plus efficace pour les messages possibles.  Heureusement, le nom du messager nous rappelle l'époque où de tels problèmes étaient monnaie courante. </p><br><p>  Par conséquent, alors qu'au XXIe siècle, nous coderons les textes avec l'une des méthodes les plus efficaces à la disposition des télégraphistes il y a un siècle - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le code Bodo</a> .  Plus précisément, sa dernière variation de ITA-2 a été écrite par Murray pour effectuer moins d'appels API sur les personnages courants.  Vous pouvez vous plaindre du manque de la langue russe, mais à mon avis, la translittération est un moyen plus simple que le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sacrifice de caractères supplémentaires à n'importe quel Yu et Sch</a> . </p><br><p>  Il ne reste plus qu'à déterminer le début et la fin de chaque session de transfert de données, afin que le côté récepteur parmi le grand flux puisse mettre en évidence les messages qui lui sont transmis.  Avant le début du transfert, Bob est sur liste noire ou à l'extérieur.  Puis Alice signale le début du transfert, changeant cet état d'un battement à l'opposé.  À la fin du programme, elle déverrouille simplement Bob.  Il continue de recevoir des caractères nuls jusqu'à ce qu'il se soit accumulé suffisamment pour indiquer de manière fiable la fin de la transmission. </p><br><p><img src="https://habrastorage.org/webt/ci/pw/2a/cipw2arrv1vwonj6r0iyzwgkzda.png" alt="Sur la chronologie"></p><br><p>  L'inconvénient de cette approche est l'impossibilité pratique de se connecter (plus précisément, vous pouvez vous connecter, mais vous devez bricoler avec une correction d'erreur manuelle) à la diffusion et à la séparation en cours des caractères zéro reçus par erreur des caractères réellement transmis.  Cependant, c'est déjà un problème d'implémentation. </p><br><h2 id="vysokie-tehnologii">  Haute technologie </h2><br><p>  Après plusieurs heures à essayer d'utiliser la bibliothèque officielle pour interagir avec l'API, j'ai craché et écrit tout ce dont j'avais besoin en python en utilisant un téléthon plus humain.  L'auteur présente même l'API dans un style synchrone, qui pour une raison quelconque est devenu une terrible rareté.  J'ai dû écrire l'encodage des messages en utilisant ITA-2 moi-même sur mon genou, car je n'ai vraiment rien trouvé de prêt. </p><br><p>  La synchronisation des fréquences se produit sur l'horloge système (et oui, le programme s'endort! À intervalles), ce qui est assez précis si vous prenez en compte le temps nécessaire pour terminer les requêtes API, qui est stable pendant plus d'un dixième de seconde.  L'utilisateur peut régler la vitesse de transmission comme il le souhaite, cependant, j'utilise le principe «plus de requêtes par seconde» pour éviter à la fois les erreurs et le gel des spams avec le même type de requête.  Telegram, en général, s'est avéré très difficile à utiliser son API, gelant l'accès au compte via un jour, même avec seulement trois autorisations (en outre, réussies) d'affilée, ainsi que des verrous aléatoires à court terme pour des raisons inconnues. </p><br><p>  Si les utilisateurs échangent des télégrammes via un canal caché, ils n'ont pas vraiment besoin d'une interface graphique.  Oui et pas partout où il se trouve, il a donc écrit l'utilitaire de console habituel.  Il vous permet d'attendre et de recevoir un message à l'ID utilisateur spécifié en une seule fois, ou de l'envoyer en lisant les arguments de la ligne de commande.  Personne, bien sûr, n'interdit d'utiliser plusieurs canaux à la fois, et aussi de recevoir et de transmettre des messages en parallèle, il vous suffit d'exécuter plusieurs instances en parallèle. </p><br><h3 id="primer-ispolzovaniya">  Exemple d'utilisation </h3><br><p>  Pour l'utiliser, vous devez obtenir votre api_id et api_hash du télégramme conformément à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette instruction</a> et définir les valeurs reçues dans le fichier 'covertele.py'.  Les arguments de la ligne de commande indiquent l'action souhaitée, son identifiant, l'identifiant du destinataire, ainsi que le message à transmettre s'il s'agit de l'expéditeur.  Tout ressemble à ceci: </p><br><pre><code class="plaintext hljs"> :  : Enter your phone number: XXX | Enter your phone number: XXX Enter auth code: YYY | Enter auth code: YYY Started message transmission... | Listening for the message... ---++ ('O', '9') | ---++ ('O', '9') --+-+ ('H', '#') | --+-+ ('H', '#') +++++ (1, 1) | +++++ (1, 1) --++- ('N', ',') | --++- ('N', ',') --+-- (' ', ' ') | --+-- (' ', ' ') ++-++ (0, 0) | ++-++ (0, 0) --+-+ ('H', '#') | --+-+ ('H', '#') -++-- ('I', '8') | -++-- ('I', '8') --+-- (' ', ' ') | --+-- (' ', ' ') --+++ ('M', '.') | --+++ ('M', '.') ++--- ('A', '-') | ++--- ('A', '-') -+-+- ('R', "'") | -+-+- ('R', "'") ++++- ('K', '(') | ++++- ('K', '(') +++++ (1, 1) | +++++ (1, 1) +-++- ('F', '!') | +-++- ('F', '!') --+++ ('M', '.') | --+++ ('M', '.') --+++ ('M', '.') | --+++ ('M', '.') Done, exiting... | ----- ('', '') | ----- ('', '') | Automatically decoded: OH, HI MARK!..</code> </pre> <br><p>  Le texte est décodé automatiquement, mais les fans qui recherchent des erreurs à la main, lisent en déplacement et suivent la progression peuvent tout faire en utilisant la sortie des codes envoyés et reçus. </p><br><p>  Si quelqu'un le souhaite, vous pouvez également utiliser l'API simple fournie: </p><br><pre> <code class="plaintext hljs">from covertele import TelegramBlockingAPI from cochannel import CovertChannel friend = input("     :") #           #  ,     -,      id = input("  :") api = TelegramBlockingAPI(id) #        friend = input("Enter your friend's id:") channel = CovertChannel(api, friend) #    channel.receive()  channel.send()     channel.send("Bork, bork!") print(channel.receive) #       ,       _raw codes = channel.receive_raw() for code in codes: check(code) channel.send_raw([19, 24, 24, 13])</code> </pre> <br><h2 id="za-predelami-telegrama">  Au-delà du télégramme </h2><br><p>  Il est clair qu'un tel canal peut être organisé au-dessus de n'importe quel messager dans lequel il existe une méthode pour déterminer si d'autres utilisateurs se bloquent.  Dans le même temps, des interfaces similaires sont facilement implémentées et remplacées de manière similaire dans le code.  Donc, s'il y a un désir - vous pouvez utiliser le codage fini, et non pas écrire à partir de zéro.  Heureusement, un python lent est peu susceptible d'interférer avec la transmission bit par bit à de telles vitesses. </p><br><p>  PS Un merci spécial à ma passion pour l'amour de me jeter en cas d'urgence. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La version anglaise sur Habr</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Version anglaise sur support</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Github</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451954/">https://habr.com/ru/post/fr451954/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451938/index.html">Go Bitmap Indexes: Recherche sauvage</a></li>
<li><a href="../fr451942/index.html">Comment le bourdonnement en Afrique sauve des milliers de vies</a></li>
<li><a href="../fr451944/index.html">2019: année de DEX (échanges décentralisés)</a></li>
<li><a href="../fr451948/index.html">L'histoire des trois cartouches</a></li>
<li><a href="../fr451950/index.html">Centrales virtuelles. Est-il possible de gérer les sources d'énergie "verte"?</a></li>
<li><a href="../fr451956/index.html">Utilisation d'AppDynamics avec Red Hat OpenShift v3</a></li>
<li><a href="../fr451958/index.html">Nous regardons des torrents sur smart TV sans SMS ni inscription</a></li>
<li><a href="../fr451960/index.html">90 vulnérabilités d'exécution de code à distance dans la mise à jour de mai mardi</a></li>
<li><a href="../fr451962/index.html">Créer des outils dans des projets d'apprentissage automatique, un aperçu</a></li>
<li><a href="../fr451966/index.html">Les périphériques d'E / S modernes sont plus rapides que les processeurs. Présentation de l'article</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>