<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📚 👎🏿 🚶🏿 CI / CD tanpa server di AWS 🚎 🕌 🤥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Akan lebih keren jika penyebaran copy-paste adalah sesuatu dari masa lalu, tetapi, sayangnya, semuanya berbeda. Kebetulan pengembang lebih suka metode...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CI / CD tanpa server di AWS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/440756/"><p><img src="https://habrastorage.org/webt/pr/ok/p2/prokp20fn2bwrkeqzq4ojxzx9gi.jpeg"><br><br>  Akan lebih keren jika penyebaran copy-paste adalah sesuatu dari masa lalu, tetapi, sayangnya, semuanya berbeda.  Kebetulan pengembang lebih suka metode pengiriman seperti itu.  Meski sekarang menulis artikel tentang mengapa ini tidak ramai, tetapi Anda tahu segalanya tanpa saya.  Dengan kecenderungan arsitektur tanpa server, jaringan pipa CI / CD memainkan peran penting dalam pengiriman aplikasi.  Saya juga menulis tentang mereka di artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3 tips terbaik untuk proyek serverless Anda berikutnya</a> ." </p><br><p>  Saya sudah lama tertarik dengan topik CI dan CD, dan untuk pertama kalinya saya menemukannya beberapa tahun yang lalu - terima kasih kepada TeamCity.  Saat ini, TeamCity masih digunakan untuk sebagian besar pipa CI / CD kami.  TeamCity bekerja dengan baik, saya tidak menentangnya, tetapi saya selalu berusaha untuk meningkatkan pekerjaan.  Sebagai contoh, akan lebih baik untuk mengumpulkan pipa dalam bentuk kode - ini adalah salah satu area di mana TeamCity tidak begitu baik. </p><br><p>  Saya mempelajari alat integrasi dan pengiriman pada AWS beberapa waktu yang lalu, dan meskipun kami menggunakan CodeDeploy untuk proyek lain yang bekerja pada EC2, saya belum menggunakan proyek tanpa server dengan mereka.  Setelah meninjau alat-alat lagi, saya perhatikan ini: sekarang ada fungsi integrasi built-in untuk menggunakan CloudFormation dan Lambda, mungkin berdasarkan SAM AWS;  kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kerangka serverless</a> - ini menghasilkan template CloudFormation, tetapi tidak bekerja di luar kotak dengan alat AWS. </p><a name="habracut"></a><br><h3 id="podgotovka">  Persiapan </h3><br><p>  Saya menggunakan layanan AWS berikut: EC2, Docker, ECR, S3, IAM, CodeBuild, CodePipeline, CloudWatch, CloudTrail.  Untuk tetap mengikuti, Anda harus setidaknya pada tingkat dasar memahami apa yang dilakukan masing-masing layanan ini. </p><br><p>  Pada dasarnya, saya menulis kode sisi server dalam .NET, dan panduan ini juga bergantung pada platform ini.  Tidak ada gambar CodeBuild yang sudah jadi yang memiliki .NET runtime dan NodeJS secara bersamaan (NodeJS diperlukan untuk kerangka serverless).  Jika fungsi Lambda Anda ditulis dalam NodeJS, mengonfigurasi pipa penyebaran jauh lebih sederhana, karena ini adalah satu-satunya lingkungan runtime yang diperlukan untuk menginstal gambar Docker (jika kasus Anda, jangan ragu untuk melewatkan sebagian besar manual).  Untuk sesaat, ini adalah pengalaman pertama saya dengan wadah, dan saya senang mempelajari sesuatu yang baru. </p><br><p>  Saya berani berasumsi bahwa kode Anda ada di repositori tertentu, misalnya, git.  Untuk panduan, kami cukup mengunggah ke S3 file yang berisi paket kode untuk penerapan;  bagaimana Anda mendapatkannya terserah Anda.  Berdasarkan pekerjaan saya, Anda selalu dapat melangkah lebih jauh dengan menghubungkan pipa Anda ke repositori seperti github atau CodeCommit. </p><br><h3 id="1-sozdayte-ekzemplyar-ec2-i-ustanovite-docker">  1. Buat instance EC2 dan instal Docker </h3><br><p>  Jalankan instance standar AWS Linux 2 EC2 - ini harus jelas tanpa penjelasan.  Masuk dan instal Docker menggunakan perintah: </p><br><pre><code class="plaintext hljs">sudo yum update -y sudo amazon-linux-extras install docker sudo service docker start</code> </pre> <br><p>  Anda juga perlu menambahkan pengguna ec2 ke grup buruh pelabuhan untuk mengeksekusi perintah Docker tanpa menggunakan sudo: </p><br><pre> <code class="plaintext hljs">sudo usermod -a -G docker ec2-user</code> </pre> <br><p>  Ketika perintah selesai, keluar dan masuk kembali ke instance EC2 Anda sehingga pengguna ec2 menerima izin baru.  Pastikan pengguna ec2 menjalankan perintah Docker tanpa sudo: </p><br><pre> <code class="plaintext hljs">docker info</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/i-/aq/r_/i-aqr_g3enpgmdd4clpawaaykmu.png"></a> <br>  <em>Output <code>docker info</code></em> </p><br><h3 id="2-sozdayte-obraz-docker-i-pomestite-v-ecr">  2. Buat gambar Docker dan letakkan di ECR </h3><br><p>  Misalkan langkah sebelumnya berhasil;  Langkah selanjutnya adalah membuat gambar Docker yang sesuai dengan ECR.  AWS menawarkan gambar dasar untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CodeBuild di github</a> , dan ini membuatnya mudah untuk membuat gambar Anda sendiri. </p><br><p>  Saya juga memposting gambar di github - jika Anda tidak ingin mengikuti langkah-langkah ini untuk membuat sendiri: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/effectivedigital/serverless-deployment-image</a> </p><br><p>  Salin gambar dan pergi ke direktori .NET Core 2.1: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/aws/aws-codebuild-docker-images.git cd aws-codebuild-docker-images cd ubuntu/dot-net/core-2.1/</code> </pre> <br><p>  Buka Dockerfile di editor teks pilihan Anda: </p><br><pre> <code class="plaintext hljs">nano Dockerfile</code> </pre> <br><p>  Tambahkan perintah untuk menginstal NodeJS dan kerangka tanpa server di akhir perintah lain yang sudah tersedia di Dockerfile.  Saya mendapat sebagian besar perintah ini dari gambar NodeJS Docker di repositori AWS yang sama: </p><br><pre> <code class="plaintext hljs"># Install Node Dependencies ENV NODE_VERSION="10.14.1" # gpg keys listed at https://github.com/nodejs/node#release-team RUN set -ex \ &amp;&amp; for key in \ 94AE36675C464D64BAFA68DD7434390BDBE9B9C5 \ B9AE9905FFD7803F25714661B63B535A4C206CA9 \ 77984A986EBC2AA786BC0F66B01FBB92821C587A \ 56730D5401028683275BD23C23EFEFE93C4CFFFE \ 71DCFD284A79C3B38668286BC97EC7A07EDE3FC1 \ FD3A5288F042B6850C66B31F09FE44734EB7990E \ 8FCCA13FEF1D0C2E91008E09770F7A9A5AE15600 \ C4F0DFFF4E8C1A8236409D08E73BC641CC11F4C8 \ DD8F2338BAE7501E3DD5AC78C273792F7D83545D \ 4ED778F539E3634C779C87C6D7062848A1AB005C \ A48C2BEE680E841632CD4E44F07496B3EB3C1762 \ ; do \ gpg - keyserver hkp://p80.pool.sks-keyservers.net:80 - recv-keys "$key" || \ gpg - keyserver hkp://ipv4.pool.sks-keyservers.net - recv-keys "$key" || \ gpg - keyserver hkp://pgp.mit.edu:80 - recv-keys "$key" ; \ done RUN set -ex \ &amp;&amp; wget "https://nodejs.org/download/release/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.gz" -O node-v$NODE_VER$ &amp;&amp; wget "https://nodejs.org/download/release/v$NODE_VERSION/SHASUMS256.txt.asc" -O SHASUMS256.txt.asc \ &amp;&amp; gpg - batch - decrypt - output SHASUMS256.txt SHASUMS256.txt.asc \ &amp;&amp; grep " node-v$NODE_VERSION-linux-x64.tar.gz\$" SHASUMS256.txt | sha256sum -c - \ &amp;&amp; tar -xzf "node-v$NODE_VERSION-linux-x64.tar.gz" -C /usr/local - strip-components=1 \ &amp;&amp; rm "node-v$NODE_VERSION-linux-x64.tar.gz" SHASUMS256.txt.asc SHASUMS256.txt \ &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs \ &amp;&amp; rm -fr /var/lib/apt/lists/* /tmp/* /var/tmp/* RUN npm set unsafe-perm true CMD [ "node" ] # Install Serverless Framework RUN set -ex \ &amp;&amp; npm install -g serverless</code> </pre> <br><p>  Sekarang kami mengumpulkan dan memberi tag pada gambar: </p><br><pre> <code class="plaintext hljs">docker build -t aws/codebuild/dot-net .</code> </pre> <br><p>  Setelah menyelesaikan perakitan, jalankan gambar - pastikan semuanya bekerja dan kerangka kerja server diinstal dengan benar: </p><br><pre> <code class="plaintext hljs">docker run -it --entrypoint sh aws/codebuild/dot-net -c bash sls -v</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/ji/vh/da/jivhda2vzvu3vwc4uyltgyz0mza.png"></a> <br>  <em>Menjalankan <code>sls -v</code> di dalam sebuah wadah baru</em> </p><br><p>  Kemudian buat repositori dalam ECR menggunakan AWS CLI.  Setelah menjalankan perintah, repositori baru akan ditampilkan di konsol AWS: </p><br><pre> <code class="plaintext hljs">aws ecr create-repository --repository-name codebuild-dotnet-node</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/qc/bq/-g/qcbq-gsw-afhdbp2q9meo1nsqrk.png"></a> <br>  <em>AWS CLI Respon untuk Membuat Repositori di ECR</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/2q/sf/_v/2qsf_v-jbgorara_qbzwi2lavoc.png"></a> </p><br><p>  Sekarang tandai gambar <em>aws / codebuild / dot-net yang</em> dibuat sebelumnya <em>dengan</em> value repositoryUri dari langkah sebelumnya: </p><br><pre> <code class="plaintext hljs">docker tag aws/codebuild/dot-net &lt;ACCOUNTID&gt;.dkr.ecr.ap-southeast-2.amazonaws.com/codebuild-dotnet-node</code> </pre> <br><p>  Jalankan perintah get-login untuk mendapatkan baris perintah otentikasi login buruh pelabuhan untuk registri kontainer: </p><br><pre> <code class="plaintext hljs">aws ecr get-login --no-include-email</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/6l/w9/2d/6lw92dgbv2c7fvicbjvoz-afxwo.png"></a> </p><br><p>  Jalankan perintah login buruh pelabuhan yang dikeluarkan oleh perintah get-login selama langkah terakhir. </p><br><pre> <code class="plaintext hljs">docker login -u AWS -p eyJwYXlsb2FkIjoiNGZnd0dSaXM1L2svWWRLMmhJT1c0WWpOZEcxamJFeFJOK2VvT0Y5[...] https://&lt;ACCOUNTID&gt;.dkr.ecr.ap-southeast-2.amazonaws.com</code> </pre> <br><p>  Jika login berhasil, letakkan gambar buruh pelabuhan di repositori yang dibuat di ECR.  Ini mungkin memakan waktu beberapa menit (tergantung pada ukuran gambar yang selesai). </p><br><pre> <code class="plaintext hljs">docker push &lt;ACCOUNTID&gt;.dkr.ecr.ap-southeast-2.amazonaws.com/codebuild-dotnet-node</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/qc/bq/-g/qcbq-gsw-afhdbp2q9meo1nsqrk.png"></a> <br>  <em>Docker di EC2 menciptakan gambar kami</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/k-/me/2l/k-me2lgrhindh4_2p9tl24e0qau.png"></a> <br>  <em>Gambar buruh pelabuhan di ECR</em> </p><br><p>  Kemudian kita dapat membuka akses ke gambar dari ECR ke siapa pun.  Izin harus diblokir di lingkungan kerja, tetapi dalam contoh ini kita akan membukanya.  Buka tab izin di konsol AWS, pilih "Ubah kebijakan JSON" dan masukkan elemen berikut ke dalam kebijakan: </p><br><pre> <code class="plaintext hljs">{ "Version": "2008-10-17", "Statement": [ { "Sid": "EnableAccountAccess", "Effect": "Allow", "Principal": "*", "Action": [ "ecr:BatchCheckLayerAvailability", "ecr:BatchGetImage", "ecr:DescribeImages", "ecr:DescribeRepositories", "ecr:GetAuthorizationToken", "ecr:GetDownloadUrlForLayer", "ecr:GetRepositoryPolicy", "ecr:ListImages" ] } ] }</code> </pre> <br><h3 id="3-sozdayte-payplayn">  3. Buat saluran pipa </h3><br><p>  Sudah waktunya untuk mengumpulkan pipa.  Untuk menyederhanakan proses, membuatnya multi-deployable, dan tetap berpegang pada bentuk arsitektur serverless yang membawa malapetaka, saya membangun sebuah pipa menggunakan kerangka serverless.  Anda dapat mencapai hasil yang sama dengan membangun di CloudFormation. </p><br><p>  Saya tidak akan menyalin seluruh sumber dari file serverless.yml saya - menyalinnya dari github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/effectivedigital/serverless-deployment-pipeline</a> </p><br><p>  Lihat templat tanpa server untuk melihat apa yang akan dilakukan, tetapi, singkatnya, ia mengatur item berikut: </p><br><ul><li>  3 segmen S3 </li><li>  Kebijakan 1 segmen </li><li>  3 peran IAM </li><li>  1 proyek CodeBuild </li><li>  1 pipeline CodePipeline </li><li>  1 acara CloudWatch </li><li>  1 jejak CloudTrail </li></ul><br><p>  Kemudian perbarui <em>DockerImageArn</em> untuk gambar Anda di ECR.  Jika Anda ingin membuat paket penempatan dengan nama selain <em>Deployment.zip</em> , maka perbarui <em>DeploymentFilename</em> : </p><br><pre> <code class="plaintext hljs">DockerImageArn: &lt;ACCOUNTID&gt;.dkr.ecr.ap-southeast-2.amazonaws.com/codebuild-dotnet-node:latest DeploymentFilename: Deployment.zip</code> </pre> <br><p>  Itu saja, pipa siap untuk ditempatkan.  Jalankan perintah penyebaran tanpa server dan tunggu sampai dikonfigurasi: </p><br><pre> <code class="plaintext hljs">sls deploy -v</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/hi/wk/ys/hiwkysbgka2zessqrdqkb4nir1g.png"></a> <br>  <em>Membuat kerangka kerja serverless menumpuk CloudFormation</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/hc/r6/yr/hcr6yrezormgpobpu2bdu-_tvj4.png"></a> <br>  <em>Dibuat oleh pipeline kerangka kerja serverless CodePipeline</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ef/ax/ad/efaxaddb_yspsbdxrl1azf5e1oo.png"></a> <br>  <em>Dibuat oleh proyek kerangka serverless proyek CodeBuild</em> </p><br><h3 id="4-dobavte-buildspecyml-v-svoe-prilozhenie">  4. Tambahkan buildSpec.yml ke aplikasi Anda </h3><br><p>  Ketika CodePipeline mendeteksi perubahan pada file penyebaran di S3, itu memberitahu CodeBuild untuk memulai dan mencoba membangun dan menggunakan aplikasi.  Namun, CodeBuild juga harus tahu perintah apa yang harus dijalankan untuk membangun dan menyebarkan aplikasi, dan buildSpec.yml berisi instruksi yang akan diikuti CodeBuild. </p><br><p>  Saya membuat aplikasi "Hello world" yang sangat sederhana yang mencakup contoh file buildSpec.yml yang dapat Anda gunakan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/effectivedigital/serverless-deployment-app</a> <br>  Atau buat file buildSpec.yml di aplikasi yang ada dan isi sesuai dengan instruksi di bawah ini: </p><br><pre> <code class="plaintext hljs">version: 0.2 phases: pre_build: commands: - chmod a+x * build: commands: - ./build.sh post_build: commands: - sls deploy -v -s $STAGE</code> </pre> <br><h3 id="5-proverka-payplayna">  5. Pemeriksaan saluran pipa </h3><br><p>  Sekarang semuanya siap untuk peluncuran pertama pipa Anda.  Buat paket yang disebut <em>Deployment.zip</em> , itu harus mencakup semua file untuk aplikasi tanpa server Anda dan file buildSpec.yml. </p><br><p>  Setelah beberapa saat, CloudTrail harus mendaftarkan acara PutObject dan mengaktifkan aturan acara CloudWatch, yang kemudian mengaktifkan pemicu CodePipeline. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/zg/r4/ii/zgr4iikop3ujbabsgtsfbyjex4o.png"></a> <br>  <em>Deployment.zip boot ke S3</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ak/xd/iz/akxdizdzjomaespfhmnygedoqia.png"></a> <br>  <em>CodePipeline diluncurkan, build aktif</em> </p><br><p>  Jika kita beralih ke detail langkah AWS CodeBuild, kita dapat melihat proses pembuatan dan penerapan: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/gv/sx/cb/gvsxcbcpmbcnj18k9rwbqbm_bhu.png"></a> <br>  <em>CodeBuild akan menerima output dari build dan deploy image Docker</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/l3/ec/xm/l3ecxm5cjedmhtpxne0nklzdzlm.png"></a> <br>  <em>Penempatan berhasil!</em> </p><br><p>  Aplikasi baru yang digunakan oleh pipeline kami juga muncul di CloudFormation: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/r6/2s/xl/r62sxlivtmrg8vn3yze2xe0ez3y.png"></a> </p><br><p>  Anda dapat menguji titik akhir API yang dibuat dalam aplikasi sederhana kami (URL dalam output CodeBuild atau di Gateway API) dan pastikan bahwa aplikasi tersebut berhasil bekerja: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/h4/s3/gh/h4s3ghrxxwlpxaf3ssdwhfx30sy.png"></a> <br>  <em>Tukang pos untuk menelepon API</em> </p><br><h3 id="kratkie-vyvody">  Kesimpulan singkat </h3><br><p>  CodePipeline memungkinkan Anda untuk membuat pipa CI / CD yang skalabel, fleksibel, dan murah.Ini membantu untuk memecahkan beberapa masalah yang terkait dengan saluran pipa tradisional yang dibuat di server. <br>  Saya ingin melangkah lebih jauh dan menambahkan pengujian unit setelah penyebaran ke dalam campuran, tetapi topik ini layak mendapatkan artikel terpisah - dan ini adalah kesempatan untuk membaca kami di masa depan! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440756/">https://habr.com/ru/post/id440756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440744/index.html">PHP untuk pemula. Menangani kesalahan</a></li>
<li><a href="../id440746/index.html">Siklus Teknologi Manajemen Pengetahuan Gartner Menggunakan Studi Kasus di KnowledgeConf</a></li>
<li><a href="../id440748/index.html">Superkomputer tercepat di dunia memecahkan rekor AI</a></li>
<li><a href="../id440752/index.html">Pemilihan prioritas permintaan pengguna</a></li>
<li><a href="../id440754/index.html">Utilitas bahasa Inggris lintas platform untuk melihat sertifikat berkualifikasi Rusia x509</a></li>
<li><a href="../id440758/index.html">Go Meetup di Acronis! (Moskow, Fiztehpark)</a></li>
<li><a href="../id440760/index.html">Zaman Keemasan Baru untuk Arsitektur Komputer</a></li>
<li><a href="../id440762/index.html">Ulasan perusahaan: sifat dan ketidakberartian ulasan anonim</a></li>
<li><a href="../id440766/index.html">Dari Geeks ke Geeks: hadiah untuk 23 Februari</a></li>
<li><a href="../id440772/index.html">Desain berbasis domain: resep untuk seorang pragmatis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>