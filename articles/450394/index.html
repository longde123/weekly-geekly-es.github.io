<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰🏼 📨 🧔 Investigación de un archivo desconocido 👦 ♋️ ⭐️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Reubicación Nueva ciudad. Búsqueda de empleo. Incluso para un profesional de TI, esto puede llevar mucho tiempo. Una serie de entrevistas, que, en gen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Investigación de un archivo desconocido</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450394/">  Reubicación  Nueva ciudad.  Búsqueda de empleo.  Incluso para un profesional de TI, esto puede llevar mucho tiempo.  Una serie de entrevistas, que, en general, son muy similares entre sí.  Y como suele suceder cuando ya ha encontrado un trabajo, después de un tiempo, se anuncia una oficina interesante. <br><br>  Era difícil entender lo que estaba haciendo específicamente, sin embargo, su área de interés era el estudio del software de otras personas.  Suena intrigante, aunque cuando te das cuenta de que este no parece ser un proveedor que lanza software para seguridad cibernética, te detienes por un segundo y comienzas a rascarte los nabos. <br><br><img src="https://lh3.googleusercontent.com/Wm2cSc19nc9XsapzlEW-eGMZBZCEgSbZFCSj6hdNNlkqCa40ksCXrYv8ual-VfYF3rcn5OoM9X2OwIJY07u_dD5Lo_7mzZU4D7rQuu164GIDE2_IjBu_J1dIMsjD4uDgyep3yipN"><br><a name="habracut"></a><br>  En resumen: desecharon el archivo y se ofrecieron a examinarlo como una tarea de prueba e intentar calcular una determinada firma en función de los datos de entrada presentados.  Vale la pena señalar que tenía muy poca experiencia en tales actividades y, probablemente, es por eso que en la primera iteración de la solución solo tuve un par de horas, luego la motivación para hacer esto fue nula.  Y sí, por supuesto, lo primero que intenté ejecutar en el teléfono / emulador: esta aplicación no es válida. <br><br>  <b>Lo que tenemos: un</b> archivo con la extensión <b>".apk"</b> .  Puse la tarea en sí misma bajo el spoiler para que no sea indexada por los motores de búsqueda: ¿qué pasa si a los chicos no les gusta, que pongo la solución en Habr? <br><br><div class="spoiler">  <b class="spoiler_title">Tarea misma</b> <div class="spoiler_text">  El APK contiene funcionalidades para generar firmas para una matriz asociativa. <br>  Intente obtener una firma para el siguiente conjunto de datos: <br><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"user"</span></span> : <span class="hljs-string"><span class="hljs-string">"LeetD3vM4st3R"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"__s33cr$$tV4lu3__"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"hash"</span></span>: <span class="hljs-string"><span class="hljs-string">"34765983265937875692356935636464"</span></span> }</code> </pre> <br></div></div><br><h2>  Enrollar las mangas </h2><br>  Se dice que el archivo contiene la funcionalidad de firmar una matriz asociativa.  Por la extensión del archivo, entendemos de inmediato que estamos tratando con una aplicación escrita para Android.  Primero desempaquetamos el archivo.  De hecho, este es un archivo ZIP normal, y cualquier archivador lo manejará a la ligera.  Utilicé la utilidad apktool y, como resultó, accidentalmente evité un par de rastrillos.  Sí, sucede (generalmente lo contrario, ¿sí?).  El hechizo es bastante simple: <br><br><pre> <code class="bash hljs">apktool d task.zip</code> </pre> <br>  Resulta que el código y los recursos en el archivo apk también se almacenan empaquetados en binarios separados, y se necesitará otro software para extraerlos.  apktool extrajo implícitamente bytes de clase, recursos y lo descompuso todo en una jerarquía de archivos natural.  Puedes proceder. <br><br><pre> <code class="bash hljs">├── AndroidManifest.xml ├── apktool.yml ├── lib │   └── arm64-v8a ├── original │   ├── AndroidManifest.xml │   └── META-INF ├── res │   ├── anim │   ├── color │   ├── drawable │   ├── layout │   ├── layout-watch-v20 │   ├── mipmap-anydpi-v26 │   ├── values │   └── values-af ├── smali │   ├── android │   ├── butterknife │   ├── com │   ├── net │   └── org └── unknown   └── org</code> </pre> <br>  Vemos una jerarquía similar (dejó su versión simplificada) y estamos tratando de averiguar por dónde empezar.  Vale la pena señalar que todavía una vez escribí un par de pequeñas aplicaciones para Android, por lo que la esencia de la parte de los directorios y, en general, los principios de las aplicaciones de Android del dispositivo, estoy bastante claro. <br><br>  Para empezar, decido simplemente "caminar" a través de los archivos.  Abro AndroidManifest.xml y empiezo a leer de manera significativa.  Mi atención es atraída por un atributo extraño <br><br><pre> <code class="xml hljs">android:supportsRtl="true"</code> </pre> <br>  Resulta que él es responsable de admitir idiomas con la letra "de derecha a izquierda" en la aplicación.  Comenzamos a esforzarnos.  No bueno <br><br>  Además, mi mirada se aferra a la carpeta desconocida.  Debajo hay una jerarquía de la forma: <b>org.apache.commons.codec.language.bm</b> y una gran cantidad de archivos de texto con contenido oscuro.  Busca en Google el nombre completo del paquete y resulta lo que está almacenado aquí, algo relacionado con el algoritmo de búsqueda de palabras fonéticamente similares al dado.  Francamente, aquí comencé a esforzarme más.  Después de hurgar un poco en los directorios, en realidad encontré el código en sí, y luego comenzó la diversión.  No me encontré con el código de bytes de Java habitual, con el que una vez pude jugar, sino con otra cosa.  Muy similar, pero diferente. <br><br>  Al final resultó que, Android tiene su propia máquina virtual: Dalvik.  Y, como todas las máquinas virtuales respetadas, tiene su propio código de bytes.  Parece que en el primer intento de resolver este problema, fue en esta triste nota que anuncié el intermedio, hice una reverencia, bajé el telón y lo tiré todo durante 4 meses hasta que mi curiosidad me terminó por completo. <br><br><h2>  Enrollar las mangas [2] </h2><br>  "¿Pero no puede ser para que todo sea más fácil?"  - Esta es la pregunta que me hice cuando comencé la tarea por segunda vez.  Comencé a buscar en Internet un descompilador desde smali hasta Java.  Solo vi que es imposible llevar a cabo este proceso sin ambigüedades.  Frunciendo un poco el ceño, fue a Github y metió un par de frases clave en la línea de búsqueda.  El primero llegó <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">smali2java</a> . <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> gradle build java -jar smali2java.jar ..</code> </pre> <br>  Errores  Veo un gran seguimiento de pila y errores en varias páginas del terminal.  Después de leer un poco sobre la esencia del contenido (y contener las emociones sobre el tamaño de la traza de la pila), encuentro que esta herramienta funciona sobre la base de una cierta gramática descrita y el código de bytes que conoció claramente no corresponde a él.  Abro el pequeño bytecode y veo anotaciones, métodos sintéticos y otras construcciones extrañas en él.  ¡No había tal cosa en el código de bytes de Java!  Cuanto tiempo  Eliminar <br><br><div class="spoiler">  <b class="spoiler_title">Más detalles</b> <div class="spoiler_text">  Resultó que la máquina virtual Dalvik (así como la JVM) no es consciente de la existencia de conceptos tales como clases internas / externas (leer clases anidadas), y el compilador genera los llamados métodos "sintéticos" para proporcionar acceso desde la clase anidada a campos externos, por ejemplo. <br><br><h4>  Como un ejemplo: </h4><br>  Si la clase externa (OuterClass) tiene un campo <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OuterClass</span></span></span><span class="hljs-class"> </span></span>{ List a; ... }</code> </pre> <br>  Para que la clase privada pueda acceder al campo de la clase externa, el compilador generará implícitamente el siguiente método: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> synthetic java.util.<span class="hljs-function"><span class="hljs-function">List </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OuterClass p1)</span></span></span><span class="hljs-function"> </span></span>{ p1 = p1.a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; }</code> </pre> <br>  Además, debido a la cocina del "compartimento del motor", se logra el trabajo de algunos otros mecanismos que proporciona el lenguaje. <br><br>  Puede comenzar a estudiar esta pregunta con más detalle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desde aquí</a> . </div></div><br>  No ayuda  Incluso jura por un código de bytes aparentemente no sospechoso.  Abro el código fuente del descompilador, leo y veo algo muy extraño: incluso los programadores hindúes (con el debido respeto) no habrían escrito esto.  Un pensamiento se arrastra: no es realmente el código generado.  Rechazo la idea durante unos 30 minutos, tratando de entender cuál es el error.  COMPLICADO  Abro Github nuevamente, y realmente, un analizador de gramática generado.  Y aquí está el generador en sí.  Guardando todo y tratando de acercarse desde el otro lado. <br><br>  <i>Vale la pena señalar que un poco más tarde aún intenté cambiar la gramática y en algunos lugares incluso el código de bytes para que el descompilador aún pudiera digerirlo.</i>  <i>Pero incluso cuando el código de bytes se hizo válido en términos de gramática del descompilador, el programa simplemente no me devolvió nada.</i>  <i>Código abierto ...</i> <br><br>  Hojeo el código de bytes y me encuentro con constantes desconocidas para mí.  En Google, me encuentro con lo mismo en el libro sobre las aplicaciones de Android inversas.  Recuerdo que esta es solo la ID asignada por el preprocesador del compilador, que se asigna a los recursos de la aplicación de Android (la constante de tiempo de escritura del código es R. *).  La próxima media hora - hora, examinaré brevemente qué registros son responsables de qué, en qué orden se pasan los argumentos, y generalmente profundizaré en la sintaxis. <br><br><h2>  ¿Cómo se ve? </h2><br><img src="https://lh4.googleusercontent.com/6vy-LnmhLmjl2TnDiAoA632c026jlrPG7zFlclZNXJRdpethXv_iFjRtzwyvQWrqkd1LUKixzHfzXAyDj4c28JAzqVYTmP9uqJTmUYgjJd8Yx5pEDkd0cad34bNg9LYDf3r2jFVj" width="350" height="496" align="left">  Encontré el diseño de la ventana principal de la aplicación, y desde allí ya entendí lo que estaba sucediendo en la aplicación: en la pantalla principal (Actividad) hay un RecyclerView (condicionalmente, una Vista que puede reutilizar objetos de la interfaz de usuario que no se muestran actualmente para la utilización de la memoria) con campos de entrada pares clave / valor, un par de botones que son responsables de agregar un nuevo par clave / valor a un contenedor abstracto determinado y un botón que genera una firma (firma) para este contenedor. <br><br>  Al observar las anotaciones y observar una cierta cantidad de código sospechosamente similar al generado, empiezo a buscar en Google.  El proyecto utiliza la biblioteca ButterKnife, que permite usar anotaciones para <b>inflar () -&gt; bind ()</b> elementos de la interfaz de usuario automáticamente.  Si hay anotaciones en la clase, el procesador de anotaciones ButterKnife crea implícitamente otra clase de carpeta de la forma <b>&lt;original_class&gt; __ViewBinding</b> , que hace todo el trabajo sucio bajo el capó.  En realidad, obtuve toda esta información de un solo archivo MainActivity después de recrear manualmente la similitud de la fuente de Java.  Después de media hora, me di cuenta de que las anotaciones de esta biblioteca también pueden establecer una devolución de llamada en las acciones de los botones y encontré aquellas funciones clave que en realidad eran responsables de agregar un par clave / valor al contenedor y generar una firma. <br><br>  <i>Por supuesto, durante el estudio, tuve que entrar en los "menudillos" de varias bibliotecas y complementos, porque incluso los hermosos landos con cookies no cubren todos los casos de uso y detalles, lo que para cualquier "reversa", creo, es una práctica común.</i> <br><br><h2>  La pereza es amiga de un programador </h2><br>  Después de pasar más tiempo en la segunda fuente, estaba completamente cansado y me di cuenta de que no era posible cocinar gachas.  Estoy subiendo a Github nuevamente, y esta vez estoy mirando más de cerca.  Encuentro el proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Smali2PsuedoJava</a> , un descompilador en "código pseudo-Java".  Incluso si esta utilidad, al menos algo puede conducir a una apariencia humana, entonces para mí el autor es una jarra de su cerveza favorita (bueno, o al menos poner un asterisco en Github, para empezar). <br><br>  ¡Y realmente funciona!  Efecto en la cara: <br><br><img src="https://lh6.googleusercontent.com/4yxBPy1Wt7_J7uLey66rp_qHwomfvAW_B1C6g3CsrS0DR73J_U42t4JgobNaGIUXVstTEVIaHriawFfRVZL4IqUEObjCL8RdLUv5VCGKiv_jeAxBclaXZlsMvmFUzFuuuuxfshw7"><br><br><h2>  Conoce a Cipher.so </h2><br>  Un poco más tarde, al estudiar el pseudocódigo de Java del proyecto y compararlo incrédulamente con el código de bytes más pequeño, encuentro una biblioteca extraña en el código: Cipher.so.  Buscando en Google, descubro que es el cifrado de un conjunto de valores de tiempo de compilación dentro del archivo APK.  Esto generalmente es necesario cuando la aplicación usa constantes de la forma: direcciones IP, credenciales para una base de datos externa, tokens para autorización, etc.  - lo que se puede obtener con la ayuda de ingeniería inversa de la aplicación.  Es cierto, el autor escribe claramente que este proyecto está abandonado, dicen, vete.  Esto se está poniendo interesante. <br><br>  Esta biblioteca proporciona acceso a los valores a través de la biblioteca Java, donde el método específico es la clave que nos interesa.  Solo alimenta mi interés, y comienzo a escalar más profundo. <br><br>  En resumen, qué hace Cipher.so y cómo funciona: <br><br><ul><li>  en el archivo Gradle de nuestro proyecto se registran las claves y los valores correspondientes <br></li><li>  Todos los valores clave se empaquetarán automáticamente en una biblioteca dinámica separada (.so), que se generará en tiempo de compilación.  Sí, sí, SERÁ generado. <br></li><li>  entonces estas claves se pueden obtener de los métodos Java generados por Cipher.so <br></li><li>  después de crear el APK, los nombres de las claves son codificados por MD5 (para mayor seguridad, por supuesto) <br></li></ul><br>  Después de encontrar la biblioteca dinámica que necesito en la carpeta de archivo, procedo a elegirla.  Para comenzar, como un reverso experimentado (no), trato de comenzar con uno simple: decido mirar la sección con constantes y líneas interesantes en un binario tipo ELF.  Desafortunadamente, faltan usuarios de Mac readelf listos para usar, y antes del comienzo decimos lo que apreciamos: <br><br><pre> <code class="bash hljs">brew install binuitls</code> </pre> <br>  Y no olvides escribir la ruta a <b>/ usr / local</b> en PATH, porque <i>brew</i> te protege de todo de una manera caballerosa ... <br><br><pre> <code class="bash hljs">greadelf -p .rodata lib/arm64-v8a/libcipher-lib.so | head -n 15</code> </pre> <br>  Limitamos la salida a las primeras 15 líneas, de lo contrario, esto puede generar un shock para un ingeniero no preparado. <br><br><img src="https://lh6.googleusercontent.com/-ka6awAjaQ6zTDJ4sogEHaqBEG2QL3il5HTS1M-HchKGBg4hK5qe__lAtEKtcL7CT0i_lhqtiEZYYRsnTpLmbc10hdpVTMcAeRP0bGJE87jUBvtkncNMJ3s5YtjgGXk0duZeHIrY"><br><br>  En las direcciones inferiores notamos líneas sospechosas.  Como descubrí, al estudiar las fuentes de Cipher.so, las claves y los valores se colocan en el <b>std :: map</b> habitual <b>:</b> esto proporciona poca información, pero sabemos que en el binario en sí, junto con las contraseñas cifradas, también hay claves ofuscadas. <br><br>  ¿Cómo es el cifrado de valores?  Al estudiar la fuente, descubrí que el cifrado se produce utilizando AES, el sistema de cifrado simétrico estándar.  Entonces, si hay valores cifrados, entonces la clave debería estar cerca ... Después de estudiarla por un tiempo, me encontré con un problema en el mismo proyecto con el título provocativo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Almacenamiento de claves inseguras: los secretos son muy fáciles de recuperar"</a> .  En él, de hecho, descubrí que la clave se almacena en forma clara en el binario, y encontré el algoritmo de descifrado.  En el ejemplo, la clave estaba en la dirección cero, y aunque entendí que el compilador podría ponerla en otro lugar en la sección .rodata del archivo binario, decidí que esta unidad sospechosa en la dirección cero es la clave. <br><br>  <b>Intento n. ° 1:</b> procedo a descifrar los valores y creo que la clave de cifrado es la misma.  El error  OpenSSL sugiere que algo no está bien.  Después de leer un poco las fuentes de Cipher.so, entiendo que si el usuario no especifica una clave durante el ensamblaje, se utiliza la clave predeterminada: <i>Cipher.so@DEFAULT</i> . <br><br>  <b>Intento n. ° 2:</b> error nuevamente.  Hmm ... ¿Está realmente redefinido por esta constante?  Es bastante simple cometer un error: código confuso escrito en Gradle, con formato "desaparecido".  Lo reviso de nuevo.  Todo parece ser así. <br><br>  En lugar de las claves están sus hashes MD5, y luego trato de probar suerte y abrir un servicio con tablas de arcoiris.  Voila: una de las claves es la palabra "contraseña".  No hay segundo  Nos da, por supuesto, no mucho.  Ambas claves están en las direcciones 240 y 2a2, respectivamente.  En principio, reconocerlos de inmediato es fácil: 32 caracteres (MD5). <br><br>  Lo revisé todo nuevamente e intenté hacer el descifrado con todas las otras líneas (que están en las direcciones más bajas) como clave para el descifrado: todo es en vano. <br>  Entonces, hay otra clave secreta, el algoritmo de acciones parece ser correcto.  Dejo de lado esta tarea e intento no enterrarme. <br><br>  Habiendo hurgado un poco en el algoritmo de firma del contenedor, todavía veo llamadas a la biblioteca Cipher.so y al código que también usa las funciones criptográficas de la biblioteca Java. <br><br><h2>  Un acertijo (que nunca resolví) </h2><br>  En la función responsable del cifrado, al principio hay una comprobación de claves en el contenedor. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] a(java/util/Map p1) { v0 = p1.size() v1 = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v0 != <span class="hljs-number"><span class="hljs-number">0</span></span>) goto :cond_0 p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[v1]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; :cond_0 v0 = <span class="hljs-string"><span class="hljs-string">"user"</span></span>; v0 = p1.containsKey(v0) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v0 == <span class="hljs-number"><span class="hljs-number">0</span></span>) goto :cond_1 p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[v1]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; ...</code> </pre><br>  Literalmente: si hay una clave de "usuario", este contenedor no está firmado (se devuelve una firma cero).  Un sentimiento extraño: parece que el problema está resuelto, pero de alguna manera parece sospechosamente simple.  Entonces, ¿por qué inventar todo lo demás?  Para llevar por mal camino?  Entonces, ¿por qué no he estudiado este código con fluidez antes?  Hmm ... <br><br>  No, no es verdad  Especifiqué la respuesta de un determinado usuario en un mensajero azul, cuyos contactos se me proporcionaron al asignar la tarea.  Excavando más.  ¿Quizás el valor / clave de entrada establecido de alguna manera cambia a medida que se agrega al contenedor?  Leí el código cuidadosamente. <br><br>  Tenga en cuenta que el descompilador eliminó las anotaciones del código smali.  ¿Y si se quita algo importante?  Compruebo los archivos principales, parece que nada significativo.  Todo lo importante está en su lugar, pero el significado no se pierde.  Compruebo las funciones de devolución de llamada que son responsables de escribir un par clave / valor desde TextBox condicional a contenedores internos.  No encontré nada criminal. <br><br>  Me volví lo más escéptico posible sobre cada línea de código: ya no puedo confiar en nadie. <br><br>  Solución simple # 2: Noté que el procedimiento de firma comienza al verificar la presencia de algún valor (subcadena en la cadena) en la firma del certificado con el que se firmó la solicitud. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@OnClick</span></span> <span class="hljs-comment"><span class="hljs-comment">//   protected void huvot324yo873yvo837yvo() { String signature = "no data"; boolean result = some_packages.isKeyInSignature(this); if result { Map map = new HashMap(); ...</span></span></code> </pre> <br>  El significado en sí, por supuesto, se encuentra encriptado en ese binario desafortunado.  Y, de hecho, si este valor no está en la firma, entonces el algoritmo no firmará nada, sino que simplemente devolverá la cadena "sin datos", como la firma ... Nuevamente, somos tomados para Cipher ... <br><br><h2>  Pelea final de descifrado clave </h2><br>  Para entender la magnitud de la tragedia, me confundí así: <br><br>  Hice un volcado hexadecimal de esta sección y escudriñé las dos primeras líneas, cuyas sospechas no disminuyeron desde el principio. <br><br><img src="https://lh4.googleusercontent.com/J4lmChj6kk0lWWy23D8QngSgnJlNfd-xDP1XyBnw1wyQ_U1NBRLYyx2BFZ4y9D1HXEjcSeCKVvZC3xgVCpx-VSV0bIHD5dcmsfdaX4jrmH-uRFsRMc9VJrqpUEMDEEaijeSTPRbk"><br><br>  Si presta atención, el carácter que separa las líneas aquí es '0x00'.  También es comúnmente utilizado por la biblioteca estándar de C, en funciones de cadena.  A partir de eso, no es menos interesante, ¿qué tipo de personaje espacial está en el medio de la primera línea?  A continuación, comienzan los intentos locos, donde la clave es: <br><br><ul><li>  toda la primera fila <br></li><li>  primera línea antes del espacio <br></li><li>  primera línea desde el espacio hasta el final <br></li><li>  ... <br></li></ul><br>  El grado de paranoia ya se puede estimar.  Cuando no entiendes lo difícil y astuta que debería ser la tarea, entonces comienzas a conducir.  Y sin embargo, eso no.  Entonces se me ocurrió la idea: "¿Funciona correctamente el algoritmo debido a un problema en mi máquina?".  En general, la secuencia de acciones allí es lógica y no planteó preguntas, pero la pregunta es: ¿los comandos en mi máquina hacen lo que se requiere de ellos?  Entonces que piensas? <br><br>  Habiendo verificado todos los pasos manualmente, resultó que <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"some_base64_input"</span></span> | openssl base64 -d</code> </pre> <br>  en algunos argumentos de entrada, de repente devuelve una cadena vacía.  Hmm <br><br>  Reemplazándolo con el primer decodificador base64 en la máquina y clasificando los principales candidatos, se encontró inmediatamente una clave adecuada y las claves se descifraron en consecuencia. <br><br><h2>  Obtener una firma de un certificado </h2><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isKeyInSignature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(android.content.Context p1)</span></span></span><span class="hljs-function"> </span></span>{ v0 = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> TRY_0{ v1 = p1.getPackageManager() p0 = p1.getPackageName() v2 = <span class="hljs-number"><span class="hljs-number">0x40</span></span>; <span class="hljs-comment"><span class="hljs-comment">// GET_SIGNATURES PackageInfo p0 = v1.getPackageInfo(p0, v2) android.content.pm.Signature[] p0 = p0.signatures; // Order are not guaranteed v1 = p0.length; v2 = 0x0; :goto_0 if (v2 &gt;= v1) goto :cond_1 v3 = p0[v2]; String v3 = v3.toCharsString() String v4 = net.idik.lib.cipher.so.CipherClient.a() v3 = v3.contains(v4) }TRY_0 catch TRY_0 (android/content/pm/PackageManager$NameNotFoundException) goto :catch_0; if (v3 == 0) goto :cond_0 p1 = 0x1; return p1; :cond_0 v2 = v2 + 0x1; goto :goto_0 :catch_0 p0 = Thrown Exception p1.printStackTrace() :cond_1 return v0; }</span></span></code> </pre> <br>  Así es como se ve el pseudocódigo generado después de mis ediciones menores.  Confunde un par de cosas: <br><br><ul><li>  poco conocimiento de la criptografía y la "cocina" de los certificados del dispositivo <br></li><li>  De acuerdo con la documentación, este método no garantiza el orden de los certificados en la colección devuelta y, en consecuencia, no sería posible realizar un ciclo en el mismo orden: ¿qué sucede si la solicitud se firmó con más de un certificado? <br></li><li>  falta de conocimiento sobre cómo extraer el certificado del APK, dado que no está claro qué hace Android Runtime en este caso <br></li></ul><br>  Tuve que profundizar en todos estos problemas y el resultado fue el siguiente: <br><br><ul><li>  el certificado en sí está en el directorio <i>original / META-INF / CERT.RSA</i> <i><br></i> <br>  en este directorio solo hay un archivo con esta extensión, lo que significa que la aplicación está firmada con un solo certificado <br></li><li>  En el sitio sobre ingeniería de investigación de aplicaciones de Android, se encontró una lista que puede extraer la firma que necesitamos como lo hace Android.  Según el autor, al menos. <br></li></ul><br>  Al ejecutar este código, puedo descubrir la firma y, en realidad, la clave que necesitamos es una subcadena.  Adelante  La solución simple # 2 está siendo barrida. <br><br>  De hecho, la clave está en el certificado, solo queda entender lo que sigue, porque si tenemos la clave de "usuario", todos también obtendremos una firma cero, y como aprendimos anteriormente, esta es la respuesta incorrecta. <br><br><h2>  ¡Escriba la documentación con cuidado! </h2><br>  La investigación adicional sobre el hecho de que los datos ingresados ​​desde los campos de texto se modifican se descarta por falta de evidencia.  La paranoia rueda con renovado vigor: ¿tal vez el código que extrajo la firma del certificado es incorrecto o es una implementación de código para versiones antiguas de Android?  Abro la documentación nuevamente y veo lo siguiente: ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://developer.android.com/reference/android/content/pm/Signature.html#toChars ()</a> ): <br><br><img src="https://lh5.googleusercontent.com/1TZ3rj6hzTEWw5YHEl1EWnANjsiqpzGR-tTrXP_Nc6jt42ANPf1QW-fmP-mh7Y2MhgMcZF0Z8CpskzT_ge65C0YCcryiWjjpG0UuPeqkUCsde1qcQgm5NbeqFj4KO3QkdtvHM3v2"><br><br>  <b>Nota: la</b> función codifica la firma como texto ASCII.  El resultado que recibí arriba fue una representación hexadecimal de los datos.  Esta API me pareció extraña, pero si crees en la documentación, resulta que volví a detenerme y la clave cifrada no es una subcadena de la firma.  Después de sentarme pensativamente en el código por un tiempo, no pude soportarlo y abrí el código fuente de esta clase.  <a href="">https://android.googlesource.com/platform/frameworks/base/+/e639da7/core/java/android/content/pm/Signature.java</a> <br><br>  La respuesta no se hizo esperar.  Y en realidad, en el código mismo, una pintura al óleo: el formato de salida es una cadena hexadecimal ordinaria.  Y ahora piense: o no entiendo algo, o la documentación está escrita "ligeramente" incorrectamente.  No habiendo regañado de ninguna manera, me puse a trabajar de nuevo. <br><br><h2>  Resumen </h2><br>  Han pasado las siguientes n horas: <br><br><ul><li>       RecyclerView        ..  ,           StackOverflow <br></li><li>    ,    ,   Java.    ,    -       («user»)     .       . <br></li></ul><br>  ,        (             ). <br><br>  No ,     .  ,    ,  ,       ,     .  .  —      ,     ,    ,  . <br><br>  ,       ,        .    .       ,           . , -   ,      ,      « »,    ,      . <br><br>  -    c        –      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">arturbrsg</a> . <br><br> Stay tuned. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/450394/">https://habr.com/ru/post/450394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450374/index.html">Tarjeta de expansión RAM para Apple IIgs</a></li>
<li><a href="../450376/index.html">Cómo Yandex.Taxi busca autos cuando no están</a></li>
<li><a href="../450378/index.html">GitLab 11.10</a></li>
<li><a href="../450384/index.html">La historia de un pequeño estudio de código heredado</a></li>
<li><a href="../450386/index.html">Interfaces como tipos de datos abstractos en Go</a></li>
<li><a href="../450396/index.html">Cómo mejorar tu inglés escrito: consejos prácticos y herramientas útiles</a></li>
<li><a href="../450398/index.html">Los venenos más valientes</a></li>
<li><a href="../450410/index.html">Terraformer - Infraestructura para codificar</a></li>
<li><a href="../450416/index.html">Cómo los proveedores de shareware VPN venden sus datos</a></li>
<li><a href="../450418/index.html">El arte de crear modelos 3D orgánicos: sombreadores subdérmicos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>