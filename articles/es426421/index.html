<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèß üëãüèª ‚òùüèæ EHCI humanamente en ruso ü§∂üèΩ üèº üë®üèø‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Doy la bienvenida a todos. Hoy quiero compartir mi experiencia y a√∫n, en mi opini√≥n, explicar claramente sobre, a primera vista, un est...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EHCI humanamente en ruso</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426421/"><img src="https://habrastorage.org/webt/kk/0o/he/kk0ohepnkx9kfrbmht7mtec5pr4.jpeg" alt="imagen"><br><br><h3>  <b>Introduccion</b> </h3><br>  Doy la bienvenida a todos.  Hoy quiero compartir mi experiencia y a√∫n, en mi opini√≥n, explicar claramente sobre, a primera vista, un est√°ndar simple para el controlador de host USB 2.0. <br><br>  Inicialmente, puede imaginar que un puerto USB 2.0 tiene solo 4 pines, dos de los cuales simplemente transmiten datos (como, por ejemplo, un puerto COM), pero de hecho, no todo es as√≠, e incluso todo lo contrario.  El controlador USB, en principio, no nos permite transferir datos como a trav√©s de un puerto COM normal.  EHCI es un est√°ndar bastante complejo que permite la transferencia de datos confiable y r√°pida del software al dispositivo en s√≠, y en la direcci√≥n opuesta. <br><br>  Puede encontrar este art√≠culo √∫til si, por ejemplo, no tiene suficientes habilidades de escritura para los controladores y la lectura de la documentaci√≥n de un hardware.  Un ejemplo simple: desea escribir su sistema operativo para una mini PC, de modo que alguna distribuci√≥n de Windows u otra distribuci√≥n de Linux no descargue hardware, y use toda su potencia exclusivamente para sus propios fines. <br><a name="habracut"></a><br><h3>  <b>¬øQu√© es el EHCI?</b> </h3><br>  Bueno, empecemos.  EHCI - Interfaz de controlador de host mejorada, est√° dise√±ada para transferir datos y controlar solicitudes a dispositivos USB, y en la otra direcci√≥n, y en el 99% de los casos es un enlace entre cualquier software y un dispositivo f√≠sico.  EHCI funciona como un dispositivo PCI y, en consecuencia, utiliza MMIO (Memory-Mapped-IO) para controlar el controlador (s√≠, s√© que algunos dispositivos PCI usan puertos, pero aqu√≠ generalic√© todo).  La documentaci√≥n de Intel describe solo el principio de funcionamiento, y no hay pistas sobre todos los algoritmos escritos al menos en pseudoc√≥digo.  EHCI tiene 2 tipos de registros MMIO: Capacidad y Operativo.  Los primeros sirven para obtener las caracter√≠sticas del controlador, mientras que los segundos sirven para controlarlo.  En realidad, adjuntar√© la esencia misma de la conexi√≥n entre el software y el controlador EHCI: <br><br><img src="https://habrastorage.org/webt/rh/px/zr/rhpxzre1s167jv51xhcz_shffsu.jpeg" alt="imagen"><br><br>  Cada controlador EHCI tiene varios puertos, cada uno de los cuales se puede conectar a cualquier dispositivo USB.  Adem√°s, tenga en cuenta que EHCI es una versi√≥n mejorada de UHCI, que tambi√©n fue desarrollada por Intel unos a√±os antes.  Por compatibilidad con versiones anteriores, cualquier controlador UHCI / OHCI que tenga una versi√≥n inferior a EHCI ser√° un compa√±ero de EHCI.  Por ejemplo, tiene un teclado USB (y la mayor√≠a de los teclados del a√±o hasta ahora han sido as√≠) que funciona en USB 1.1 (tenga en cuenta que la velocidad m√°xima de USB 1.1 es de 12 megabits por segundo, y FullSpeed ‚Äã‚ÄãUSB 2.0 tiene ancho de banda tanto como 480 Mbps), y tiene una computadora con un puerto USB 2.0, cuando conecta el teclado a la computadora, el controlador host EHCI funcionar√° de cualquier manera con USB 1.1.  Este modelo se muestra en el siguiente diagrama: <br><br><img src="https://habrastorage.org/webt/61/mg/lf/61mglfeajk5ivpcqmwjkazxniwy.jpeg" alt="imagen"><br><br>  Adem√°s, para el futuro quiero advertirle de inmediato que su controlador puede no funcionar correctamente debido a una situaci√≥n tan absurda: inicializ√≥ UHCI y luego EHCI, mientras agregaba dos dispositivos id√©nticos, establezca el bit de Control del propietario del puerto en el registro del puerto y UHCI dej√≥ de funcionar, debido a que EHCI arrastra autom√°ticamente el puerto sobre s√≠ mismo, y el puerto en UHCI deja de responder, esta situaci√≥n necesita ser monitoreada. <br><br>  Adem√°s, veamos un diagrama que muestra la propia arquitectura EHCI: <br><br><img src="https://habrastorage.org/webt/vq/t-/nt/vqt-ntbqnrcrz4k8he1uzngwyyo.jpeg" alt="imagen"><br><br>  A la derecha est√° escrito sobre la cola, sobre ellos un poco m√°s tarde. <br><br><h2>  Registros del controlador EHCI </h2><br>  Para empezar, quiero aclarar una vez m√°s que a trav√©s de estos registros controlar√°s tu dispositivo, por lo tanto, son muy importantes, y sin ellos la programaci√≥n EHCI es imposible. <br><br>  Primero debe obtener la direcci√≥n MMIO que se le da a este controlador, en el desplazamiento + 0x10 ser√° la direcci√≥n de nuestros registros tan esperados.  Hay una cosa: primero, los registros de capacidad van, y solo despu√©s de ellos: operativos, por lo tanto, en el desplazamiento 0 (de la direcci√≥n anterior, que recibimos en el desplazamiento 0x10 en relaci√≥n con el inicio de nuestro MMIO de EHCI), hay un byte: la longitud de los registros de capacidad. <br><br><h3>  <b>Registros de capacidad</b> </h3><br>  En el desplazamiento 2, se encuentra el registro <b>HCIVERSION</b> : el n√∫mero de revisi√≥n de este HC, que toma 2 bytes y contiene la versi√≥n BCD de la revisi√≥n (qu√© BCD se puede encontrar en Wikipedia). <br>  En el desplazamiento +4, se encuentra el registro <b>HCSPARAMS</b> , su tama√±o es de 2 palabras, contiene los par√°metros estructurales del dispositivo y sus bits muestran lo siguiente: <br><br><ul><li>  Bit 16 - Indicadores de puerto - LED disponibles para dispositivos USB conectados. </li><li>  Bits 15:12: el n√∫mero del controlador complementario asignado a este controlador </li><li>  Bits 11: 8: la cantidad de puertos en el controlador complementario </li><li>  Bit 7: reglas de enrutamiento de puertos: muestra c√≥mo estos puertos se asignan a puertos complementarios </li><li>  Bit 4: control de alimentaci√≥n del puerto: indica si es necesario encender la alimentaci√≥n de cada puerto; 0: la alimentaci√≥n se suministra autom√°ticamente </li><li>  Bits 3: 0: el n√∫mero de puertos para este controlador. </li><li>  En el desplazamiento +8 se encuentra el registro HCCPARAMS: muestra los par√°metros de compatibilidad, sus bits significan lo siguiente: </li><li>  Bit 2: disponibilidad de cola as√≠ncrona, </li><li>  Bit 1: disponibilidad de cola peri√≥dica (secuencial) </li><li>  Bit 0 - compatibilidad de 64 bits </li></ul><br><h3>  <b>Registros de operaciones</b> </h3><br>  En el desplazamiento 0, el registro <b>USBCMD</b> es el registro de comando del controlador, sus bits significan lo siguiente: <br><br><ul><li>  Bits 23:16 - Control de umbral de interrupci√≥n: muestra cu√°ntos micro cuadros se usar√°n para un cuadro normal.  Cuanto m√°s grande, m√°s r√°pido, pero si es m√°s de 8, los micro-cuadros se procesar√°n a la misma velocidad que para 8. </li><li>  Bit 6: interrupci√≥n despu√©s de cada transacci√≥n en la cola as√≠ncrona, </li><li>  Bit 5: es la cola asincr√≥nica utilizada </li><li>  Bit 4 - uso de cola secuencial, </li><li>  Bits 3: 2: el tama√±o de FrameList'a (m√°s sobre eso m√°s adelante).  0 significa 1024 elementos, 1 - 512, 2 - 256, 3 - reservado </li><li>  Bit 1: se establece para restablecer el controlador de host. </li><li>  Bit 0 - Ejecutar / Parar </li></ul>  . <br>  A continuaci√≥n, en el desplazamiento +4, est√° el registro <b>USBSTS</b> : el estado del controlador host, <br><br><ul><li>  El bit 15 indica si se est√° utilizando una cola asincr√≥nica. </li><li>  El bit 14 indica si se est√° utilizando una cola secuencial, </li><li>  Bit 13: indica que se ha detectado una cola as√≠ncrona vac√≠a, </li><li>  El bit 12 se establece en 1, si se produjo un error al procesar la transacci√≥n, el controlador host detendr√° todas las colas. </li><li>  El bit 4 se establece en 1, si se produce un error grave, el controlador host detiene todas las colas. </li><li>  Bit 3 FrameList (Registro) Rollover: se establece en 1 cuando el controlador host proces√≥ toda la FrameList. </li><li>  Bit 1 - Interrupci√≥n de error USB - ¬øGenero una interrupci√≥n de error? </li><li>  Bit 0: interrupci√≥n de USB: se establece despu√©s del procesamiento exitoso de la transacci√≥n, si IOC se instal√≥ en TD </li></ul><br>  No cansado?  Puedes servirte una gaviota fuerte y traer el h√≠gado, ¬°estamos al principio! <br><br>  En el desplazamiento +8, hay un registro <b>USBINTR</b> : el registro de habilitaci√≥n de interrupci√≥n <br>  Para no escribir durante mucho tiempo, y a√∫n m√°s, para que no lea durante mucho tiempo, los valores de los bits de este registro se pueden encontrar en la especificaci√≥n, se dejar√° un enlace a continuaci√≥n.  Aqu√≠ solo escribo 0, porque  No tengo ning√∫n deseo de escribir controladores, interrupciones de mapas, etc., por lo que creo que esto es casi completamente in√∫til. <br><br>  En el desplazamiento +12 (0x0C) se encuentra el registro <b>FRINDEX</b> , en el que simplemente se encuentra el n√∫mero de cuadro actual, y quiero se√±alar que los √∫ltimos 4 bits muestran el n√∫mero de micro-cuadro, en los 28 bits superiores el n√∫mero de cuadro (el mismo valor no es necesariamente menor que el tama√±o de la lista de cuadros Pero si necesita un √≠ndice, es mejor tomarlo con una m√°scara de 0x3FF (o 0x1FF, etc.). <br><br>  El registro <b>CTRLDSSEGMENT</b> est√° en offset + 0x10; muestra al controlador host los 32 bits m√°s significativos de la direcci√≥n de la hoja de cuadro. <br><br>  El registro <b>PERIODICLISTBASE</b> tiene un desplazamiento de + 0x14, puede colocar los 32 bits inferiores de la hoja de marco, tenga en cuenta que la direcci√≥n debe estar alineada con el tama√±o de la p√°gina de memoria (4096). <br><br>  El registro <b>ASYNCLISTADDR</b> tiene un desplazamiento de + 0x18, puede poner la direcci√≥n de la cola asincr√≥nica en √©l, tenga en cuenta que debe estar alineado en el l√≠mite de 32 bytes, mientras que debe estar en los primeros cuatro gigabytes de memoria f√≠sica. <br><br>  El registro <b>CONFIGFLAG</b> indica si el dispositivo est√° configurado.  Debe establecer el bit 0 despu√©s de completar la configuraci√≥n del dispositivo, tiene un desplazamiento de + 0x40. <br><br>  Pasemos a los registros de puertos.  Cada puerto tiene su propio registro de estado de comando, cada registro de puerto est√° desplazado <b>+ 0x44 + (PortNumber - 1) * 4</b> , sus bits significan lo siguiente: <br><br><ul><li>  Bit 12 - alimentaci√≥n de puerto, 1 - se suministra alimentaci√≥n, 0 - no. </li><li>  El Bit 8 - Port Rest - est√° configurado para restablecer el dispositivo. </li><li>  Bit 3: cambio de activaci√≥n / desactivaci√≥n de puerto: se establece al cambiar el estado de la "inclusi√≥n" del puerto. </li><li>  Bit 2 - puerto activado / desactivado. </li><li>  Bit 1: cambie el estado de la conexi√≥n; se establece en 1, por ejemplo, si conect√≥ o desconect√≥ un dispositivo USB. </li><li>  Bit 0 - estado de conexi√≥n, 1 - conectado, 0 - no. </li></ul><br>  Ahora pasemos al jugo mismo. <br><br><h2>  Transferencia de datos y estructuras de consulta </h2><br>  Organizar una estructura para procesar solicitudes incluye colas y descriptores de transferencia (TD). <br><br>  Por el momento, consideraremos solo 3 estructuras. <br><br><h3>  Lista secuencial </h3><br>  La lista secuencial (peri√≥dica, pere√≥dica) se organiza de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/hv/2h/23/hv2h23mnmv5uks1ffugte6ycpcu.jpeg" alt="imagen"><br><br>  Como puede ver en el diagrama, el procesamiento comienza con la obtenci√≥n del marco deseado del marco de la hoja, cada uno de sus elementos ocupa 4 bytes y tiene la siguiente estructura: <br><br><img src="https://habrastorage.org/webt/o_/m7/ic/o_m7icnqm0ifgvnfpfycwahilwy.jpeg" alt="imagen"><br><br>  Como puede ver en la imagen, la transferencia de la direcci√≥n / descriptor de la cola est√° alineada en el l√≠mite de 32 bytes, el bit 0 significa que el controlador del host no procesar√° este elemento, los bits 3: 1 indican el tipo de lo que procesar√° el controlador del host: 0 - TD isos√≠ncrono (iTD), 1 - turno, 2 y 3 en este art√≠culo que no considerar√©. <br><br><h3>  Cola asincr√≥nica </h3><br>  El controlador de host procesa esta cola solo cuando el marco secuencial est√° vac√≠o o el controlador de host ha procesado toda la lista de serie. <br><br>  Una cola as√≠ncrona es un puntero a una cola que contiene otras colas que necesitan procesamiento.  Esquema: <br><br><img src="https://habrastorage.org/webt/rz/sv/4s/rzsv4sqoyqegzwqoij9vl7qpt14.jpeg" alt="imagen"><br><br><h3>  qTD (Descriptor de transferencia de elemento de cola) </h3><br>  Este TD tiene la siguiente estructura: <br><br><img src="https://habrastorage.org/webt/hf/gq/g5/hfgqg5fvujkx2bv8piy6i3gijyu.jpeg" alt="imagen"><br><br>  <b>Siguiente puntero qTD</b> : un puntero a la continuaci√≥n de la cola para el procesamiento (para ejecuci√≥n horizontal), bit 0 Siguiente puntero qTD indica que no hay m√°s colas. <br>  <b>Token qTD: token</b> TD, muestra los par√°metros de transferencia de datos: <br><br><ul><li>  Bit 31 - Alternar datos (m√°s sobre eso m√°s adelante) </li><li>  Bits 30:16: la cantidad de datos a transferir, despu√©s de la finalizaci√≥n de la transacci√≥n, su valor disminuye en la cantidad de datos transferidos. </li><li>  Bit 15 - IOC - Interrupci√≥n al finalizar - causa la interrupci√≥n despu√©s de completar el procesamiento del descriptor. </li><li>  Los bits 14:12 muestran el n√∫mero del b√∫fer actual con el que se intercambian datos, m√°s sobre esto m√°s adelante. </li><li>  Bits 11:10: la cantidad de errores permitidos.  Esta tabla muestra cu√°ndo disminuye el recuento de errores: <br><br><img src="https://habrastorage.org/webt/ko/hz/ia/kohzia9y2vxtrd1tepp-h5qokgm.jpeg" alt="imagen"><br><br>  Nota 1: la detecci√≥n de Babble o Stall detiene autom√°ticamente la ejecuci√≥n del encabezado de la cola.  Nota al pie 3: los errores del b√∫fer de datos son problemas con el host.  No tienen en cuenta los reintentos del dispositivo. </li><li>  9: 8 - C√≥digo PID - tipo de token: 0 - token a la entrada (del host al dispositivo), 1 - token a la salida (del dispositivo al host), 2 - token "SETUP" </li><li>  Los bits 7: 0 indican el estado de TD: <br>  El bit 7 indica que el TD est√° en un estado activo (es decir, el controlador host procesa este TD) <br>  Bit 6 - Detenido - indica que ha ocurrido un error y que la ejecuci√≥n de TD se ha detenido. <br>  Bit 4: balbuceo detectado: la cantidad de datos que enviamos al dispositivo, o por revoluci√≥n, es inferior a la que transmitimos, es decir, por ejemplo, el dispositivo nos envi√≥ 100 bytes de datos, y leemos solo 50 bytes, y luego otros 50 El bit detenido tambi√©n se establecer√° si este bit se establece en 1. <br>  Bit 3: error de transacci√≥n: se produjo un error durante la transacci√≥n. </li></ul><br>  <b>Lista de punteros de la p√°gina de b√∫fer qTD</b> : cualquiera de los 5 b√∫feres.  Contiene un enlace a donde en la memoria se debe realizar la transacci√≥n (enviar datos al dispositivo / recibir datos del dispositivo), todas las direcciones en los buffers, excepto la primera, deben estar alineadas con el tama√±o de la p√°gina (4096 bytes). <br><br><h3>  Jefe de l√≠nea </h3><br>  La cola de la cola tiene la siguiente estructura: <br><br><img src="https://habrastorage.org/webt/9m/ob/l7/9mobl76mr1drsddxbgndgbgoneo.jpeg" alt="imagen"><br><br>  <b>Puntero de enlace horizontal del encabezado</b> de la cola: puntero a la siguiente cola, los bits 2: 1 tienen los siguientes valores seg√∫n el tipo de cola: <br><br><img src="https://habrastorage.org/webt/bu/gw/sa/bugwsap9snr11blm5ifggvhei60.jpeg" alt="imagen"><br><br>  <b>Capacidades / caracter√≠sticas de punto final</b> - caracter√≠sticas de la cola: <br><br><ul><li>  Los bits 26:16 contienen el tama√±o m√°ximo de paquete para la transmisi√≥n </li><li>  Bit 14: Control de alternancia de datos: muestra d√≥nde el controlador del host debe tomar el valor de alternancia de datos inicial, 0: ignora el bit DT en qTD, guarda el bit DT para la cabeza de la cola. </li><li>  Bit 13:12 - caracter√≠sticas de velocidad de transmisi√≥n: <img src="https://habrastorage.org/webt/gk/tb/sd/gktbsdm7kys5kcgk6e3uewkgf1q.jpeg" alt="imagen"></li><li>  Bits 11: 8: el n√∫mero del punto final al que se realiza la solicitud </li><li>  Bits 6: 0 - direcci√≥n del dispositivo </li></ul><br>  <b>Capacidades de punto final: Queue Head DWord 2</b> - continuaci√≥n de la palabra doble anterior: <br><br><ul><li>  Bits 29:23 - N√∫mero de concentrador </li><li>  Bits 22:16 - Direcci√≥n del concentrador </li></ul><br>  <b>Puntero de enlace qTD actual</b> : puntero al qTD actual. <br><br>  Pasamos a lo m√°s interesante. <br><br><h2>  Conductor EHCI </h2><br>  Comencemos con las consultas que el EHCI puede cumplir.  Hay 2 tipos de solicitudes: Control - a la orden, y Bulk - a puntos finales, para el intercambio de datos, por ejemplo, la gran mayor√≠a de las unidades flash USB (USB MassStorage) usan el tipo de transferencia de datos Bulk / Bulk / Bulk.  El mouse y el teclado tambi√©n usan solicitudes masivas para la transferencia de datos. <br><br>  Inicialice EHCI y configure colas as√≠ncronas y secuenciales: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Base I/O Address PciBar bar; PciGetBar(&amp;bar, id, 0); EhciController *hc = VMAlloc(sizeof(EhciController)); hc-&gt;capRegs = (EhciCapRegs *)(uintptr_t)bar.u.address; hc-&gt;opRegs = (EhciOpRegs *)(uintptr_t)(bar.u.address + hc-&gt;capRegs-&gt;capLength); // Read the Command register //    uint cmd = ROR(usbCmdO); // Write it back, setting bit 2 (the Reset bit) //   ,   2(Reset) // and making sure the two schedule Enable bits are clear. //  ,  2   WOR(usbCmdO, 2 | cmd &amp; ~(CMD_ASE | CMD_PSE)); // A small delay here would be good. You don't want to read //     ,     // the register before it has a chance to actually set the bit //   ,         ROR(usbCmdO); // Now wait for the controller to clear the reset bit. //      Reset while (ROR(usbCmdO) &amp; 2); // Again, a small delay here would be good to allow the // reset to actually become complete. //   ROR(usbCmdO); // wait for the halted bit to become set //    Halted    while (!(ROR(usbStsO) &amp; STS_HCHALTED)); //     ,        // ,           128  hc-&gt;frameList = (u32 *)VMAlloc(1024 * sizeof(u32) + 8192 * 4); hc-&gt;frameList = (((uint)hc-&gt;frameList) / 16384) * 16384 + 16384; hc-&gt;qhPool = (EhciQH *)VMAlloc(sizeof(EhciQH) * MAX_QH + 8192 * 4); hc-&gt;tdPool = (EhciTD *)VMAlloc(sizeof(EhciTD) * MAX_TD + 8192 * 4); hc-&gt;qhPool = (((uint)hc-&gt;qhPool) / 16384) * 16384 + 16384; hc-&gt;tdPool = (((uint)hc-&gt;tdPool) / 16384) * 16384 + 16384; // Asynchronous queue setup //    EhciQH *qh = EhciAllocQH(hc); //     ,      // ,    qh-&gt;qhlp = (u32)(uintptr_t)qh | PTR_QH; //  ,  ,     qh-&gt;ch = QH_CH_H; qh-&gt;caps = 0; qh-&gt;curLink = 0; qh-&gt;nextLink = PTR_TERMINATE; qh-&gt;altLink = 0; qh-&gt;token = 0; //    for (uint i = 0; i &lt; 5; ++i) { qh-&gt;buffer[i] = 0; qh-&gt;extBuffer[i] = 0; } hc-&gt;asyncQH = qh; // Periodic list queue setup //    qh = EhciAllocQH(hc); //     qh-&gt;qhlp = PTR_TERMINATE; qh-&gt;ch = 0; qh-&gt;caps = 0; qh-&gt;curLink = 0; qh-&gt;nextLink = PTR_TERMINATE; qh-&gt;altLink = 0; qh-&gt;token = 0; //   for (uint i = 0; i &lt; 5; ++i) { qh-&gt;buffer[i] = 0; qh-&gt;extBuffer[i] = 0; } qh-&gt;transfer = 0; qh-&gt;qhLink.prev = &amp;qh-&gt;qhLink; qh-&gt;qhLink.next = &amp;qh-&gt;qhLink; hc-&gt;periodicQH = qh; //        for (uint i = 0; i &lt; 1024; ++i) hc-&gt;frameList[i] = PTR_QH | (u32)(uintptr_t)qh; kprintf("FrameList filled. Turning off Legacy BIOS support..."); // Check extended capabilities //  BIOS Legacy support uint eecp = (RCR(hccParamsO) &amp; HCCPARAMS_EECP_MASK) &gt;&gt; HCCPARAMS_EECP_SHIFT; if (eecp &gt;= 0x40) { // Disable BIOS legacy support uint legsup = PciRead32(id, eecp + USBLEGSUP); kprintf("."); if (legsup &amp; USBLEGSUP_HC_BIOS) { PciWrite32(id, eecp + USBLEGSUP, legsup | USBLEGSUP_HC_OS); kprintf("."); for (;;) { legsup = PciRead32(id, eecp + USBLEGSUP); kprintf("."); if (~legsup &amp; USBLEGSUP_HC_BIOS &amp;&amp; legsup &amp; USBLEGSUP_HC_OS) { break; } } } } kprintf("Done\n"); // Disable interrupts //   //hc-&gt;opRegs-&gt;usbIntr = 0; MWIR(ehcibase, usbIntrO, 0); // Setup frame list //     //hc-&gt;opRegs-&gt;frameIndex = 0; WOR(frameIndexO, 0); //hc-&gt;opRegs-&gt;periodicListBase = (u32)(uintptr_t)hc-&gt;frameList; WOR(periodicListBaseO, (u32)(uintptr_t)hc-&gt;frameList); //       //hc-&gt;opRegs-&gt;asyncListAddr = (u32)(uintptr_t)hc-&gt;asyncQH; WOR(asyncListAddrO, (u32)(uintptr_t)hc-&gt;asyncQH); //    0 //hc-&gt;opRegs-&gt;ctrlDsSegment = 0; WOR(ctrlDsSegmentO, 0); // Clear status //   //hc-&gt;opRegs-&gt;usbSts = ~0; WOR(usbStsO, ~0); // Enable controller //  , 8 -,  //     //hc-&gt;opRegs-&gt;usbCmd = (8 &lt;&lt; CMD_ITC_SHIFT) | CMD_PSE | CMD_ASE | CMD_RS; WOR(usbCmdO, (8 &lt;&lt; CMD_ITC_SHIFT) | CMD_PSE | CMD_ASE | CMD_RS); while (ROR(usbStsO)&amp;STS_HCHALTED); // Configure all devices to be managed by the EHCI // ,   //hc-&gt;opRegs-&gt;configFlag = 1; WOR(configFlagO, 1);\ // Probe devices //   EhciProbe(hc);</span></span></code> </pre> <br>  En realidad, el c√≥digo para restablecer el puerto a su estado original: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> u32 *reg = &amp;hc-&gt;opRegs-&gt;ports[port]; <span class="hljs-comment"><span class="hljs-comment">//    ,  100 *reg|=(1&lt;&lt;12)|(1&lt;&lt;20); Wait(100); //  ,  50  EhciPortSet(reg, PORT_RESET | (1&lt;&lt;12) | (1&lt;&lt;20) | (1&lt;&lt;6)); Wait(50); EhciPortClr(reg, PORT_RESET); // Wait 100ms for port to enable (TODO - what is appropriate length of time?) //  100    ,   , //  100    uint status = 0; for (uint i = 0; i &lt; 10; ++i) { // Delay Wait(10); // Get current status //    status = *reg; // Check if device is attached to port //      if (~status &amp; PORT_CONNECTION) break; // Acknowledge change in status //    -    if (status &amp; (PORT_ENABLE_CHANGE | PORT_CONNECTION_CHANGE)) { EhciPortClr(reg, PORT_ENABLE_CHANGE | PORT_CONNECTION_CHANGE); continue; } // Check if device is enabled //    ,    if (status &amp; PORT_ENABLE) break; } return status;</span></span></code> </pre><br>  Solicitud de control al dispositivo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EhciDevControl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UsbDevice *dev, UsbTransfer *t)</span></span></span><span class="hljs-function"> </span></span>{ EhciController *hc = (EhciController *)dev-&gt;hc; UsbDevReq *req = t-&gt;req; <span class="hljs-comment"><span class="hljs-comment">// Determine transfer properties //    uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint maxSize = dev-&gt;maxPacketSize; uint type = req-&gt;type; uint len = req-&gt;len; // Create queue of transfer descriptors //   TDs EhciTD *td = EhciAllocTD(hc); if (!td) return; EhciTD *head = td; EhciTD *prev = 0; // Setup packet //   uint toggle = 0; uint packetType = USB_PACKET_SETUP; uint packetSize = sizeof(UsbDevReq); EhciInitTD(td, prev, toggle, packetType, packetSize, req); prev = td; // Data in/out packets packetType = type &amp; RT_DEV_TO_HOST ? USB_PACKET_IN : USB_PACKET_OUT; u8 *it = (u8 *)t-&gt;data; u8 *end = it + len; //EhciPrintTD(td); while (it &lt; end) { td = EhciAllocTD(hc); if (!td) return; toggle ^= 1; packetSize = end - it; if (packetSize &gt; maxSize) packetSize = maxSize; EhciInitTD(td, prev, toggle, packetType, packetSize, it); it += packetSize; prev = td; } // Status packet //   td = EhciAllocTD(hc); if (!td) return; toggle = 1; packetType = type &amp; RT_DEV_TO_HOST ? USB_PACKET_OUT : USB_PACKET_IN; EhciInitTD(td, prev, toggle, packetType, 0, 0); // Initialize queue head //   : EhciQH *qh = EhciAllocQH(hc); EhciInitQH(qh, t, head, dev-&gt;parent, false, speed, addr, 0, maxSize); // Wait until queue has been processed //       EhciInsertAsyncQH(hc-&gt;asyncQH, qh); EhciWaitForQH(hc, qh); }</span></span></code> </pre><br>  C√≥digo de procesamiento de cola: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_HALTED) { t-&gt;success = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; t-&gt;complete = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;nextLink &amp; PTR_TERMINATE) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~qh-&gt;token &amp; TD_TOK_ACTIVE) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_DATABUFFER) kprintf(<span class="hljs-string"><span class="hljs-string">" Data Buffer Error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_BABBLE) kprintf(<span class="hljs-string"><span class="hljs-string">" Babble Detected\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_XACT) kprintf(<span class="hljs-string"><span class="hljs-string">" Transaction Error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_MMF) kprintf(<span class="hljs-string"><span class="hljs-string">" Missed Micro-Frame\n"</span></span>); t-&gt;success = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; t-&gt;complete = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t-&gt;complete) ....</code> </pre><br>  Y ahora la solicitud de punto final (solicitud masiva) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EhciDevIntr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UsbDevice *dev, UsbTransfer *t)</span></span></span><span class="hljs-function"> </span></span>{ EhciController *hc = (EhciController *)dev-&gt;hc; <span class="hljs-comment"><span class="hljs-comment">// Determine transfer properties //    uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint maxSize = t-&gt;endp-&gt;desc-&gt;maxPacketSize; uint endp = t-&gt;endp-&gt;desc-&gt;addr &amp; 0xf; EhciTD *td = EhciAllocTD(hc); if (!td) { t-&gt;success = false; t-&gt;complete = true; return; } EhciTD *head = td; EhciTD *prev = 0; // Data in/out packets uint toggle = t-&gt;endp-&gt;toggle; uint packetType = t-&gt;endp-&gt;desc-&gt;addr &amp; 0x80 ? USB_PACKET_IN : USB_PACKET_OUT; uint packetSize = t-&gt;len; EhciInitTD(td, prev, toggle, packetType, packetSize, t-&gt;data); // Initialize queue head //    EhciQH *qh = EhciAllocQH(hc); EhciInitQH(qh, t, head, dev-&gt;parent, true, speed, addr, endp, maxSize); //printQh(qh); // Schedule queue //    EhciInsertPeriodicQH(hc-&gt;periodicQH, qh); }</span></span></code> </pre><br>  Creo que el tema es bastante interesante, en Internet en ruso casi no hay documentos, descripciones y art√≠culos sobre este tema, y ‚Äã‚Äãsi lo hay, es muy borroso.  Si el tema de trabajar con el desarrollo de hardware y sistema operativo es interesante, entonces hay mucho que contar. <br><br>  Muelles: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificaci√≥n</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426421/">https://habr.com/ru/post/es426421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426411/index.html">Desarrollo de clases de descriptor C ++ / CLI</a></li>
<li><a href="../es426413/index.html">Principios S√ìLIDOS que todo desarrollador debe conocer</a></li>
<li><a href="../es426415/index.html">Fintech-digest: control de digitalizaci√≥n por parte del Banco Central, salario de criptomonedas, tarjeta Mir en forma de pulseras y llaveros</a></li>
<li><a href="../es426417/index.html">Pavel 2.0: consultor reptiloide en JS, node.js con sockets y telefon√≠a</a></li>
<li><a href="../es426419/index.html">M√©todos de sobrecarga o puente prohibidos en Java</a></li>
<li><a href="../es426423/index.html">mmWave en tel√©fonos inteligentes: c√≥mo Qualcomm hizo posible lo imposible</a></li>
<li><a href="../es426425/index.html">Toda la verdad sobre RTOS. Art√≠culo # 14. Secciones de memoria: introducci√≥n y servicios b√°sicos.</a></li>
<li><a href="../es426427/index.html">Cosas √∫tiles para "cosas": una peque√±a selecci√≥n con precios bajos</a></li>
<li><a href="../es426429/index.html">Instalaci√≥n de FreeSWITCH 1.8 en Debian 9 (Raspbian Stretch, la imagen b√°sica del sistema MajorDoMo Smart Home en Rasbperri Pi)</a></li>
<li><a href="../es426431/index.html">Desmontaje del motor de novela visual Qlie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>