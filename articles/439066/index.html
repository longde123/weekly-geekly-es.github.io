<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüëß‚Äçüë¶ ‚õπüèª üë≤üèæ Sistema operativo en √≥xido. Memoria de p√°gina: avanzada üé¢ üßöüèΩ üëè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo explica c√≥mo el n√∫cleo del sistema operativo puede acceder a los marcos de memoria f√≠sica. Estudiaremos la funci√≥n para convertir direcc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistema operativo en √≥xido. Memoria de p√°gina: avanzada</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439066/">  Este art√≠culo explica c√≥mo el n√∫cleo del sistema operativo puede acceder a los marcos de memoria f√≠sica.  Estudiaremos la funci√≥n para convertir direcciones virtuales en f√≠sicas.  Tambi√©n descubriremos c√≥mo crear nuevas asignaciones en las tablas de p√°ginas. <br><br>  Este blog est√° publicado en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> .  Si tiene alguna pregunta o problema, abra el ticket correspondiente all√≠.  Todas las fuentes para el art√≠culo est√°n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h1>  Introduccion </h1><br>  Desde el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√∫ltimo art√≠culo,</a> aprendimos sobre los principios de la memoria de paginaci√≥n y c√≥mo funcionan las tablas de p√°ginas de cuatro niveles en x86_64.  Tambi√©n encontramos que el cargador ya configur√≥ la jerarqu√≠a de la tabla de p√°ginas para nuestro n√∫cleo, por lo que el n√∫cleo se ejecuta en direcciones virtuales.  Esto mejora la seguridad, pero surge el problema: ¬øc√≥mo acceder a las direcciones f√≠sicas reales que se almacenan en las entradas de la tabla de p√°ginas o en el <code>CR3</code> ? <br><a name="habracut"></a><br>  En la primera secci√≥n del art√≠culo, discutiremos el problema y los diferentes enfoques para resolverlo.  Luego implementamos una funci√≥n que se cuela a trav√©s de la jerarqu√≠a de las tablas de p√°ginas para convertir las direcciones virtuales en f√≠sicas.  Finalmente, aprenda a crear nuevas asignaciones en tablas de p√°ginas y encuentre marcos de memoria no utilizados para crear nuevas tablas. <br><br><h2>  Actualizaciones de dependencia </h2><br>  Para trabajar, necesita <code>x86_64</code> versi√≥n 0.4.0 o posterior.  Actualice la dependencia en nuestro <code>Cargo.toml</code> : <br><br><pre> <code class="rust hljs">[dependencies] x86_64 = <span class="hljs-string"><span class="hljs-string">"0.4.0"</span></span> # or later</code> </pre> <br><h1>  Acceso a tablas de p√°ginas. </h1><br>  Acceder a las tablas de p√°ginas desde el n√∫cleo no es tan f√°cil como parece.  Para comprender el problema, eche otro vistazo a la jerarqu√≠a de tablas de cuatro niveles del art√≠culo anterior: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/5e8/a14/9c85e8a145a9078cfcfd92e204f69a5b.svg"></div><br><br>  Lo importante es que cada entrada de p√°gina almacena la direcci√≥n <i>f√≠sica</i> de la siguiente tabla.  Esto evita la traducci√≥n de estas direcciones, lo que reduce el rendimiento y conduce f√°cilmente a bucles sin fin. <br><br>  El problema es que no podemos acceder directamente a las direcciones f√≠sicas desde el n√∫cleo, ya que tambi√©n funciona en direcciones virtuales.  Por ejemplo, cuando vamos a la direcci√≥n <code>4 KiB</code> , tenemos acceso a la direcci√≥n <i>virtual</i> <code>4 KiB</code> , y no a la direcci√≥n <i>f√≠sica</i> donde se almacena la tabla de p√°ginas del 4to nivel.  Si queremos acceder a la direcci√≥n f√≠sica de <code>4 KiB</code> , entonces necesitamos usar alguna direcci√≥n virtual, que se traduce en ella. <br><br>  Por lo tanto, para acceder a los marcos de las tablas de p√°ginas, debe asignar algunas p√°ginas virtuales a estos marcos.  Hay diferentes formas de crear tales asignaciones. <br><br>  1. Una soluci√≥n simple es la <b>visualizaci√≥n id√©ntica de todas las tablas de p√°ginas</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/813/916/8f3813916cd0a5b5174c8d14dabedb7a.svg"></div><br><br>  En este ejemplo, vemos la visualizaci√≥n id√©ntica de cuadros.  Las direcciones f√≠sicas de las tablas de p√°ginas son al mismo tiempo direcciones virtuales v√°lidas, por lo que podemos acceder f√°cilmente a las tablas de p√°ginas de todos los niveles, comenzando con el registro CR3. <br><br>  Sin embargo, este enfoque satura el espacio de direcciones virtuales y hace que sea dif√≠cil encontrar grandes √°reas contiguas de memoria libre.  Digamos que queremos crear un √°rea de memoria virtual de 1000 KiB en la figura anterior, por ejemplo, para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mostrar un archivo en la memoria</a> .  No podemos comenzar con la regi√≥n <code>28  KiB</code> , porque descansa en una p√°gina ya ocupada en <code>1004  KiB</code> .  Por lo tanto, tendr√° que buscar m√°s hasta encontrar un fragmento grande adecuado, por ejemplo, con <code>1008  KiB</code> .  Existe el mismo problema de fragmentaci√≥n que en la memoria segmentada. <br><br>  Adem√°s, la creaci√≥n de nuevas tablas de p√°ginas es mucho m√°s complicada, ya que necesitamos encontrar marcos f√≠sicos cuyas p√°ginas correspondientes a√∫n no se utilizan.  Por ejemplo, para nuestro archivo, reservamos un √°rea de 1000 KiB de memoria <i>virtual</i> , comenzando en la direcci√≥n <code>1008  KiB</code> .  Ahora ya no podemos usar ning√∫n marco con una direcci√≥n f√≠sica entre <code>1000  KiB</code> y <code>2008  KiB</code> , porque no se puede mostrar de forma id√©ntica. <br><br>  2. Otra opci√≥n es <b>transmitir tablas de p√°ginas solo temporalmente</b> cuando necesite acceder a ellas.  Para comparaciones temporales, se requiere una visualizaci√≥n id√©ntica de solo la tabla de primer nivel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84e/177/978/84e177978079c02224d4032fa02f053b.png"></div><br><br>  En esta figura, una tabla de nivel 1 gestiona los primeros 2 MiB de espacio de direcciones virtuales.  Esto es posible porque el acceso se realiza desde el registro CR3 a trav√©s de entradas nulas en las tablas de los niveles 4, 3 y 2. El registro con el √≠ndice <b>8</b> traduce la p√°gina virtual a <code>32 KiB</code> en un marco f√≠sico a <code>32 KiB</code> , identificando as√≠ la tabla de nivel 1. En la figura, esto se muestra con una flecha horizontal. <br><br>  Al escribir en la tabla de nivel 1 asignada de forma id√©ntica, nuestro n√∫cleo puede crear hasta 511 comparaciones de tiempo (512 menos el registro necesario para el mapeo de identidad).  En el ejemplo anterior, el n√∫cleo coincide con el registro nulo de una tabla de nivel 1 con un marco a <code>24 KiB</code> .  Esto cre√≥ un mapeo temporal de la p√°gina virtual en <code>0 KiB</code> al marco f√≠sico de la tabla de nivel de p√°gina 2 indicada por la flecha punteada.  Ahora el n√∫cleo puede acceder a la tabla de nivel 2 escribiendo en una p√°gina que comienza en <code>0 KiB</code> . <br><br>  Por lo tanto, el acceso a un marco arbitrario de la tabla de p√°ginas con asignaciones temporales consta de las siguientes acciones: <br><br><ul><li>  Encuentre una entrada gratuita en la tabla de nivel 1 que se muestra id√©nticamente. <br></li><li>  Asigne esta entrada al marco f√≠sico de la tabla de p√°ginas a la que queremos acceder. <br></li><li>  Acceda a este marco a trav√©s de la p√°gina virtual asociada con la entrada. <br></li><li>  Vuelva a establecer el registro como no utilizado, eliminando as√≠ la asignaci√≥n temporal. </li></ul><br>  Con este enfoque, el espacio de direcciones virtuales permanece limpio, ya que las mismas 512 p√°ginas virtuales se usan constantemente.  La desventaja es algo engorroso, especialmente porque una nueva comparaci√≥n puede requerir cambiar varios niveles de la tabla, es decir, necesitamos repetir el proceso descrito varias veces. <br><br>  3. Aunque los dos enfoques anteriores funcionan, hay un tercer m√©todo: <b>tablas de p√°ginas recursivas</b> .  Combina las ventajas de ambos enfoques: compara constantemente todos los marcos de las tablas de p√°ginas sin requerir comparaciones temporales, y tambi√©n mantiene las p√°ginas asignadas una al lado de la otra, evitando la fragmentaci√≥n del espacio de direcciones virtuales.  Este es el m√©todo que usaremos. <br><br><h2>  Tablas de p√°gina recursivas </h2><br>  La idea es traducir algunos registros de la tabla de cuarto nivel en ella misma.  Por lo tanto, en realidad reservamos una parte del espacio de direcciones virtuales y asignamos todos los marcos de tabla actuales y futuros a este espacio. <br><br>  Veamos un ejemplo para entender c√≥mo funciona todo esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/ee6/d9b/779ee6d9bf771dec8e6d22c0440e503d.png"></div><br><br>  La √∫nica diferencia con el ejemplo al principio del art√≠culo es un registro adicional con el √≠ndice <code>511</code> en la tabla de nivel 4, que se asigna al marco f√≠sico <code>4 KiB</code> , que se encuentra en esta tabla. <br><br>  Cuando la CPU pasa a este registro, no se refiere a la tabla de nivel 3, sino que nuevamente se refiere a la tabla de nivel 4. Esto es similar a una funci√≥n recursiva que se llama a s√≠ misma.  Es importante que el procesador asuma que cada entrada en la tabla de nivel 4 apunta a una tabla de nivel 3, por lo que ahora trata la tabla de nivel 4 como una tabla de nivel 3. Esto funciona porque las tablas de todos los niveles en x86_64 tienen la misma estructura. <br><br>  Al seguir un registro recursivo una o m√°s veces antes de comenzar la conversi√≥n real, podemos reducir efectivamente el n√∫mero de niveles por los que pasa el procesador.  Por ejemplo, si seguimos el registro recursivo una vez, y luego vamos a la tabla de nivel 3, el procesador piensa que la tabla de nivel 3 es una tabla de nivel 2. Continuando, considera la tabla de nivel 2 como una tabla de nivel 1, y la tabla de nivel 1 como asignada marco en la memoria f√≠sica.  Esto significa que ahora podemos leer y escribir en la tabla de nivel de p√°gina 1 porque el procesador piensa que este es un marco mapeado.  La siguiente figura muestra los cinco pasos de dicha traducci√≥n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/ac7/191/bdaac719103c574c655efa3604d0b842.png"></div><br><br>  Del mismo modo, podemos seguir una entrada recursiva dos veces antes de comenzar la conversi√≥n para reducir el n√∫mero de niveles pasados ‚Äã‚Äãa dos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/b9a/c47/7f4b9ac47fce9552dead4e551b804256.png"></div><br><br>  Veamos este procedimiento paso a paso.  Primero, la CPU sigue una entrada recursiva en la tabla de nivel 4 y piensa que ha alcanzado la tabla de nivel 3. Luego sigue el registro recursivo nuevamente y piensa que ha alcanzado el nivel 2. Pero en realidad todav√≠a est√° en el nivel 4. Luego la CPU va a la nueva direcci√≥n y entra en la tabla de nivel 3, pero cree que ya est√° en la tabla de nivel 1. Finalmente, en el siguiente punto de entrada en la tabla de nivel 2, el procesador cree que ha accedido al marco de memoria f√≠sica.  Esto nos permite leer y escribir en una tabla de nivel 2. <br><br>  Tambi√©n se accede a las tablas de los niveles 3 y 4. Para acceder a la tabla del nivel 3, seguimos un registro recursivo tres veces: el procesador cree que ya est√° en la tabla del nivel 1, y en el siguiente paso llegamos al nivel 3, que la CPU considera como un marco mapeado.  Para acceder a la tabla de nivel 4, simplemente seguimos el registro recursivo cuatro veces hasta que el procesador procese la tabla de nivel 4 como un marco mapeado (en azul en la figura a continuaci√≥n). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/487/a82/92c/487a8292cf8fe673f1914f5f198c0956.png"></div><br><br>  El concepto es dif√≠cil de entender al principio, pero en la pr√°ctica funciona bastante bien. <br><br><h4>  C√°lculo de direcci√≥n </h4><br>  Por lo tanto, podemos acceder a las tablas de todos los niveles siguiendo un registro recursivo una o m√°s veces.  Dado que los √≠ndices en tablas de cuatro niveles se derivan directamente de la direcci√≥n virtual, se deben crear direcciones virtuales especiales para este m√©todo.  Como recordamos, los √≠ndices de la tabla de p√°ginas se extraen de la direcci√≥n de la siguiente manera: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  Supongamos que queremos acceder a una tabla de nivel 1 que muestra una p√°gina espec√≠fica.  Como aprendimos anteriormente, debe pasar por un registro recursivo una vez, y luego a trav√©s de los √≠ndices de los niveles 4¬∫, 3¬∫ y 2¬∫.  Para hacer esto, movemos todos los bloques de direcciones un bloque a la derecha y establecemos el √≠ndice del registro recursivo en el lugar del √≠ndice inicial del nivel 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/d82/b54/62ad82b54b233a37e40b964953a16bf8.svg"></div><br><br>  Para acceder a la tabla de nivel 2 de esta p√°gina, movemos todos los bloques de √≠ndice dos bloques a la derecha y establecemos el √≠ndice recursivo en el lugar de ambos bloques de origen: nivel 4 y nivel 3: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/ae5/7c8/1d9ae57c8c68a0b239e5b37397a4d0f7.svg"></div><br><br>  Para acceder a la tabla de nivel 3, hacemos lo mismo, solo nos desplazamos a la derecha con tres bloques de direcciones. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6ee/c9f/4b86eec9fd1df3445718ed8246fd4473.svg"></div><br><br>  Finalmente, para acceder a la tabla de nivel 4, mueva todo cuatro bloques a la derecha. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36b/6b0/29b/36b6b029b31578b143ff1e7605e358fb.svg"></div><br><br>  Ahora puede calcular direcciones virtuales para tablas de p√°ginas de los cuatro niveles.  Incluso podemos calcular una direcci√≥n que apunta exactamente a una entrada espec√≠fica de la tabla de p√°ginas multiplicando su √≠ndice por 8, el tama√±o de la entrada de la tabla de p√°ginas. <br><br>  La siguiente tabla muestra la estructura de direcciones para acceder a varios tipos de marcos: <br><br><table><thead><tr><th>  Direcci√≥n virtual para </th><th>  Estructura de direcciones ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">octal</a> ) </th></tr></thead><tbody><tr><td>  Pagina </td><td> <code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code> </td> </tr><tr><td>  Entrada en la mesa de nivel 1 </td><td> <code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code> </td> </tr><tr><td>  Entrada en una mesa de nivel 2 </td><td> <code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code> </td> </tr><tr><td>  Entrada en una mesa de nivel 3 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code> </td> </tr><tr><td>  Entrada en la mesa del nivel 4 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code> </td> </tr></tbody></table><br>  Aqu√≠ <code></code> es el √≠ndice de nivel 4, <code></code> es el nivel 3, <code></code> es el nivel 2 y <code>DDD</code> es el √≠ndice de nivel 1 para el cuadro visualizado, <code>EEEE</code> es su desplazamiento.  <code>RRR</code> es el √≠ndice del registro recursivo.  Un √≠ndice (tres d√≠gitos) se convierte en un desplazamiento (cuatro d√≠gitos) al multiplicar por 8 (el tama√±o de la entrada de la tabla de p√°ginas).  Con este desplazamiento, la direcci√≥n resultante apunta directamente a la entrada de la tabla de p√°ginas correspondiente. <br><br>  <code>SSSS</code> son bits de expansi√≥n del d√≠gito firmado, es decir, son todas copias del bit 47. Este es un requisito especial para direcciones v√°lidas en la arquitectura x86_64, que discutimos en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior</a> . <br><br>  Las direcciones son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">octales</a> , ya que cada car√°cter octal representa tres bits, lo que le permite separar claramente los √≠ndices de tablas de 9 bits en diferentes niveles.  Esto no es posible en el sistema hexadecimal, donde cada car√°cter representa cuatro bits. <br><br><h2>  Implementaci√≥n </h2><br>  Despu√©s de toda esta teor√≠a, finalmente podemos proceder con la implementaci√≥n.  Convenientemente, el cargador gener√≥ no solo tablas de p√°ginas, sino tambi√©n una visualizaci√≥n recursiva en el √∫ltimo registro de la tabla de nivel 4. El cargador hizo esto porque de lo contrario habr√≠a un problema de huevo o gallina: necesitamos acceder a la tabla de nivel 4 para crear un mapa recursivo pero no podemos acceder a √©l sin ninguna pantalla. <br><br>  Ya utilizamos esta asignaci√≥n recursiva al final del art√≠culo anterior para acceder a la tabla de nivel 4 a trav√©s de la direcci√≥n codificada <code>0xffff_ffff_ffff_f000</code> .  Si convertimos esta direcci√≥n a octal y la comparamos con la tabla anterior, veremos que corresponde exactamente a la estructura del registro en la tabla de nivel 4 con <code>RRR</code> = <code>0o777</code> , <code>AAAA</code> = <code>0</code> y los bits de extensi√≥n del signo <code>1</code> : <br><br><pre>  estructura: 0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA
 direcci√≥n: 0o_177777_777_777_777_777_0000 </pre><br>  Gracias al conocimiento de las tablas recursivas, ahora podemos crear direcciones virtuales para acceder a todas las tablas activas.  Y hacer que la transmisi√≥n funcione. <br><br><h3>  Traducci√≥n de direcciones </h3><br>  Como primer paso, cree una funci√≥n que convierta una direcci√≥n virtual en una direcci√≥n f√≠sica, pasando por la jerarqu√≠a de las tablas de p√°ginas: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/lib.rs pub mod memory;</span></span></code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::PhysAddr; use x86_64::structures::paging::PageTable; /// Returns the physical address for the given virtual address, or `None` if the /// virtual address is not mapped. pub fn translate_addr(addr: usize) -&gt; Option&lt;PhysAddr&gt; { // introduce variables for the recursive index and the sign extension bits // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Don't hardcode these values let r = 0o777; // recursive index let sign = 0o177777 &lt;&lt; 48; // sign extension // retrieve the page table indices of the address that we want to translate let l4_idx = (addr &gt;&gt; 39) &amp; 0o777; // level 4 index let l3_idx = (addr &gt;&gt; 30) &amp; 0o777; // level 3 index let l2_idx = (addr &gt;&gt; 21) &amp; 0o777; // level 2 index let l1_idx = (addr &gt;&gt; 12) &amp; 0o777; // level 1 index let page_offset = addr &amp; 0o7777; // calculate the table addresses let level_4_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (r &lt;&lt; 12); let level_3_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (l4_idx &lt;&lt; 12); let level_2_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (l4_idx &lt;&lt; 21) | (l3_idx &lt;&lt; 12); let level_1_table_addr = sign | (r &lt;&lt; 39) | (l4_idx &lt;&lt; 30) | (l3_idx &lt;&lt; 21) | (l2_idx &lt;&lt; 12); // check that level 4 entry is mapped let level_4_table = unsafe { &amp;*(level_4_table_addr as *const PageTable) }; if level_4_table[l4_idx].addr().is_null() { return None; } // check that level 3 entry is mapped let level_3_table = unsafe { &amp;*(level_3_table_addr as *const PageTable) }; if level_3_table[l3_idx].addr().is_null() { return None; } // check that level 2 entry is mapped let level_2_table = unsafe { &amp;*(level_2_table_addr as *const PageTable) }; if level_2_table[l2_idx].addr().is_null() { return None; } // check that level 1 entry is mapped and retrieve physical address from it let level_1_table = unsafe { &amp;*(level_1_table_addr as *const PageTable) }; let phys_addr = level_1_table[l1_idx].addr(); if phys_addr.is_null() { return None; } Some(phys_addr + page_offset) }</span></span></code> </pre> <br>  Primero, introducimos variables para el √≠ndice recursivo (511 = <code>0o777</code> ) y los bits de extensi√≥n de signo (cada uno es 1).  Luego calculamos los √≠ndices de las tablas de p√°ginas y el desplazamiento mediante operaciones bit a bit, como se indica en la ilustraci√≥n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  El siguiente paso es calcular las direcciones virtuales de las tablas de cuatro p√°ginas, como se describe en la secci√≥n anterior.  Luego, en la funci√≥n, convertimos cada una de estas direcciones a enlaces de <code>PageTable</code> .  Estas son operaciones inseguras porque el compilador no puede saber que estas direcciones son v√°lidas. <br><br>  Despu√©s de calcular la direcci√≥n, utilizamos el operador de indexaci√≥n para ver el registro en la tabla de nivel 4. Si este registro es cero, entonces no hay una tabla de nivel 3 para este registro de nivel 4. Esto significa que <code>addr</code> no <code>addr</code> asignado a ninguna memoria f√≠sica.  Entonces devolvemos <code>None</code> .  De lo contrario, sabemos que existe una tabla de nivel 3.  Luego repetimos el procedimiento, como en el nivel anterior. <br><br>  Despu√©s de verificar tres p√°ginas de un nivel superior, finalmente podemos leer el registro de la tabla de nivel 1, que nos dice el marco f√≠sico con el que se asigna la direcci√≥n.  Como √∫ltimo paso, agregue el desplazamiento de p√°gina y devuelva la direcci√≥n. <br><br>  Si supi√©ramos con certeza que la direcci√≥n estaba asignada, podr√≠amos acceder directamente a la tabla de nivel 1 sin mirar las p√°ginas de un nivel superior.  Pero como no sabemos esto, primero debemos verificar si existe una tabla de nivel 1, de lo contrario, nuestra funci√≥n devolver√° un error de p√°gina faltante para direcciones no coincidentes. <br><br><h4>  Prueba </h4><br>  Intentemos usar la funci√≥n de traducci√≥n para direcciones virtuales en nuestra funci√≥n <code>_start</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::translate_addr; // the identity-mapped vga buffer page println!("0xb8000 -&gt; {:?}", translate_addr(0xb8000)); // some code page println!("0x20010a -&gt; {:?}", translate_addr(0x20010a)); // some stack page println!("0x57ac001ffe48 -&gt; {:?}", translate_addr(0x57ac001ffe48)); println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><br>  Despu√©s de comenzar, vemos el siguiente resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bd/e62/054/1bde620549428279e6c1f1647d88a062.png"></div><br><br>  Como se esperaba, la direcci√≥n 0xb8000 asociada con el identificador se traduce en la misma direcci√≥n f√≠sica.  La p√°gina de c√≥digos y la p√°gina de la pila se convierten en algunas direcciones f√≠sicas arbitrarias, que dependen de c√≥mo el cargador cre√≥ la asignaci√≥n inicial para nuestro n√∫cleo. <br><br><h4> <code> RecursivePageTable</code> </h4> <br>  x86_64 proporciona un tipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>RecursivePageTable</code></a> que implementa abstracciones seguras para varias operaciones de tabla de p√°ginas.  Con este tipo, puede implementar la funci√≥n <code>translate_addr</code> mucho m√°s sucintamente: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable}; use x86_64::{VirtAddr, PhysAddr}; /// Creates a RecursivePageTable instance from the level 4 address. /// /// This function is unsafe because it can break memory safety if an invalid /// address is passed. pub unsafe fn init(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { let level_4_table_ptr = level_4_table_addr as *mut PageTable; let level_4_table = &amp;mut *level_4_table_ptr; RecursivePageTable::new(level_4_table).unwrap() } /// Returns the physical address for the given virtual address, or `None` if /// the virtual address is not mapped. pub fn translate_addr(addr: u64, recursive_page_table: &amp;RecursivePageTable) -&gt; Option&lt;PhysAddr&gt; { let addr = VirtAddr::new(addr); let page: Page = Page::containing_address(addr); // perform the translation let frame = recursive_page_table.translate_page(page); frame.map(|frame| frame.start_address() + u64::from(addr.page_offset())) }</span></span></code> </pre> <br>  El tipo <code>RecursivePageTable</code> encapsula completamente los rastreos de tablas de p√°ginas inseguras, por lo que ya no se necesita el c√≥digo <code>unsafe</code> en la funci√≥n <code>translate_addr</code> .  La funci√≥n <code>init</code> permanece insegura debido a la necesidad de garantizar la correcci√≥n del nivel <code>level_4_table_addr</code> . <br><br>  Nuestra funci√≥n <code>_start</code> debe actualizarse para volver a firmar la funci√≥n de la siguiente manera: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::{self, translate_addr}; const LEVEL_4_TABLE_ADDR: usize = 0o_177777_777_777_777_777_0000; let recursive_page_table = unsafe { memory::init(LEVEL_4_TABLE_ADDR) }; // the identity-mapped vga buffer page println!("0xb8000 -&gt; {:?}", translate_addr(0xb8000, &amp;recursive_page_table)); // some code page println!("0x20010a -&gt; {:?}", translate_addr(0x20010a, &amp;recursive_page_table)); // some stack page println!("0x57ac001ffe48 -&gt; {:?}", translate_addr(0x57ac001ffe48, &amp;recursive_page_table)); println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>  Ahora, en lugar de pasar <code>LEVEL_4_TABLE_ADDR</code> para <code>translate_addr</code> y acceder a las tablas de p√°gina a trav√©s de punteros sin <code>LEVEL_4_TABLE_ADDR</code> seguros, pasamos referencias al tipo <code>RecursivePageTable</code> .  Por lo tanto, ahora tenemos una abstracci√≥n segura y una sem√°ntica clara de propiedad.  Esto asegura que no podremos cambiar accidentalmente la tabla de p√°ginas en acceso compartido, porque para cambiarla, debemos tomar posesi√≥n de <code>RecursivePageTable</code> exclusivamente. <br><br>  Esta funci√≥n da el mismo resultado que la funci√≥n de traducci√≥n original escrita manualmente. <br><br><h4>  Hacer que las caracter√≠sticas inseguras sean m√°s seguras </h4><br> <code>memory::init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es una funci√≥n insegura: requiere un bloque para llamarlo </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque la persona que llama debe garantizar que se cumplan ciertos requisitos. En nuestro caso, el requisito es que la direcci√≥n transmitida se asigne con precisi√≥n al marco f√≠sico de la tabla de p√°ginas de nivel 4. </font><font style="vertical-align: inherit;">Todo el cuerpo de la funci√≥n insegura se coloca </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el bloque </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que todo tipo de operaciones se realicen sin crear bloques adicionales </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por lo tanto, no necesitamos un bloque inseguro para desreferenciar </font></font><code>level_4_table_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span>(level_4_table_addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; RecursivePageTable&lt;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> level_4_table_ptr = level_4_table_addr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PageTable; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> level_4_table = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *level_4_table_ptr; <span class="hljs-comment"><span class="hljs-comment">// &lt;- this operation is unsafe RecursivePageTable::new(level_4_table).unwrap() }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El problema es que no vemos de inmediato qu√© partes son inseguras. </font><font style="vertical-align: inherit;">Por ejemplo, sin mirar la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definici√≥n de una funci√≥n,</font></font></a> <code>RecursivePageTable::new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no podemos decir si es segura o no. </font><font style="vertical-align: inherit;">Por lo tanto, es muy f√°cil omitir accidentalmente alg√∫n c√≥digo inseguro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evitar este problema, puede agregar una funci√≥n incorporada segura:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub unsafe fn init(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { /// Rust currently treats the whole body of unsafe functions as an unsafe /// block, which makes it difficult to see which operations are unsafe. To /// limit the scope of unsafe we use a safe inner function. fn init_inner(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { let level_4_table_ptr = level_4_table_addr as *mut PageTable; let level_4_table = unsafe { &amp;mut *level_4_table_ptr }; RecursivePageTable::new(level_4_table).unwrap() } init_inner(level_4_table_addr) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora se </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requiere nuevamente </font><font style="vertical-align: inherit;">el bloqueo </font><font style="vertical-align: inherit;">para desreferenciar </font></font><code>level_4_table_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e inmediatamente vemos que estas son las √∫nicas operaciones inseguras. </font><font style="vertical-align: inherit;">Rust actualmente tiene un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abierto </font><font style="vertical-align: inherit;">para cambiar esta propiedad fallida de funciones inseguras.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crea un nuevo mapeo </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando leemos las tablas de p√°ginas y creamos la funci√≥n de conversi√≥n, el siguiente paso es crear una nueva asignaci√≥n en la jerarqu√≠a de tablas de p√°ginas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La complejidad de esta operaci√≥n depende de la p√°gina virtual que queremos mostrar. En el caso m√°s simple, ya existe una tabla de p√°ginas de nivel 1 para esta p√°gina, y solo tenemos que hacer una entrada. En el caso m√°s dif√≠cil, la p√°gina est√° en el √°rea de memoria para la cual el nivel 3 a√∫n no existe, por lo que primero debe crear nuevas tablas de nivel 3, nivel 2 y nivel 1.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos con un caso simple cuando no necesite crear nuevas tablas. El cargador se carga en el primer megabyte del espacio de direcciones virtuales, por lo que sabemos que para esta regi√≥n hay una tabla v√°lida de nivel 1. Para nuestro ejemplo, podemos seleccionar cualquier p√°gina no utilizada en esta √°rea de memoria, por ejemplo, la p√°gina en la direcci√≥n </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Utilizamos el </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">marco del b√∫fer de texto VGA </font><font style="vertical-align: inherit;">como el marco deseado </font><font style="vertical-align: inherit;">. Es muy f√°cil comprobar c√≥mo funciona nuestra traducci√≥n de direcciones. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo implementamos en una nueva funci√≥n </font></font><code>create_maping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el m√≥dulo </font></font><code>memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{FrameAllocator, PhysFrame, Size4KiB}; pub fn create_example_mapping( recursive_page_table: &amp;mut RecursivePageTable, frame_allocator: &amp;mut impl FrameAllocator&lt;Size4KiB&gt;, ) { use x86_64::structures::paging::PageTableFlags as Flags; let page: Page = Page::containing_address(VirtAddr::new(0x1000)); let frame = PhysFrame::containing_address(PhysAddr::new(0xb8000)); let flags = Flags::PRESENT | Flags::WRITABLE; let map_to_result = unsafe { recursive_page_table.map_to(page, frame, flags, frame_allocator) }; map_to_result.expect("map_to failed").flush(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci√≥n acepta una referencia mutable a </font></font><code>RecursivePageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(la cambiar√°) y </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que se explica a continuaci√≥n. Luego aplica la funci√≥n </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>map_to</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la bandeja </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Mapper</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para mapear la p√°gina en la direcci√≥n </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con el marco f√≠sico en la direcci√≥n </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La funci√≥n no es segura, porque es posible violar la seguridad de la memoria con argumentos no v√°lidos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s de los argumentos </font></font><code>page</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la funci√≥n </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toma dos argumentos m√°s. El tercer argumento es el conjunto de banderas para la tabla de p√°ginas. Establecemos la bandera </font></font><code>PRESENT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necesaria para todas las entradas v√°lidas y la bandera </font></font><code>WRITABLE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para la escritura. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El cuarto argumento deber√≠a ser alguna estructura que implemente el rasgo </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este argumento es necesario por el m√©todo.</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">porque crear nuevas tablas de p√°ginas puede requerir marcos no utilizados. La aplicaci√≥n requiere el rasgo argumento </font></font><code>Size4KiB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como los tipos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Page</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>PhysFrame</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">son </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">universales</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para el rasgo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>PageSize</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, trabajando con 4 p√°ginas est√°ndar KiB y con enormes p√°ginas 2 MiB / 1 GIB. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci√≥n </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede fallar, por lo que vuelve </font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dado que este es solo un ejemplo de c√≥digo que no deber√≠a ser confiable, simplemente lo usamos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>expect</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con p√°nico cuando se produce un error. Si tiene √©xito, la funci√≥n devuelve un tipo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>MapperFlush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que proporciona una manera f√°cil de borrar la p√°gina recientemente emparejada del m√©todo del b√∫fer de traducci√≥n asociativa (TLB) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>flush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Me gusta</font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, el tipo usa el atributo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>#[must_use]</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y emite una advertencia si accidentalmente olvidamos aplicarlo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como sabemos que la direcci√≥n </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no requiere nuevas tablas de p√°ginas, </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siempre puede volver </font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para probar la funci√≥n, cree esto </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// A FrameAllocator that always returns `None`. pub struct EmptyFrameAllocator; impl FrameAllocator&lt;Size4KiB&gt; for EmptyFrameAllocator { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { None } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Si aparece el error 'el m√©todo </font></font><code>allocate_frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no es miembro del rasgo </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">', debe actualizar </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la versi√≥n 0.4.0.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos probar la nueva funci√≥n de traducci√≥n:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::{create_example_mapping, EmptyFrameAllocator}; const LEVEL_4_TABLE_ADDR: usize = 0o_177777_777_777_777_777_0000; let mut recursive_page_table = unsafe { memory::init(LEVEL_4_TABLE_ADDR) }; create_example_mapping(&amp;mut recursive_page_table, &amp;mut EmptyFrameAllocator); unsafe { (0x1900 as *mut u64).write_volatile(0xf021f077f065f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, creamos una asignaci√≥n para la p√°gina en la direcci√≥n </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, llamando a la funci√≥n </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con un enlace mutable a la instancia </font></font><code>RecursivePageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto traduce la p√°gina </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a un b√∫fer de texto VGA, por lo que veremos algunos resultados en la pantalla. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego escribimos un valor en esta p√°gina </font></font><code>0xf021f077f065f04e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que corresponde a la l√≠nea </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"¬°Nuevo!" </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sobre un fondo blanco </font><font style="vertical-align: inherit;">Simplemente no es necesario que escriba este valor inmediatamente en la parte superior de la p√°gina </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque la l√≠nea superior se mover√° a continuaci√≥n de la pantalla </font></font><code>println</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y lo escribir√° en un desplazamiento </font></font><code>0x900</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que se encuentra aproximadamente en el medio de la pantalla. </font><font style="vertical-align: inherit;">Como sabemos por el art√≠culo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Modo de texto VGA"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , escribir en el b√∫fer VGA debe ser vol√°til, por lo que utilizamos el m√©todo </font></font><code>write_volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cuando lo ejecutamos en QEMU, vemos esto: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef9/1bc/672/ef91bc672e33cbec8847b77028b7624e.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La inscripci√≥n en la pantalla. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El c√≥digo funcion√≥ porque ya hab√≠a una tabla de nivel 1 para mostrar la p√°gina </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si intentamos traducir una p√°gina para la que a√∫n no existe dicha tabla, la funci√≥n </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devolver√° un error, ya que intentar√° seleccionar marcos para crear nuevas tablas de p√°ginas </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lo veremos si intentamos traducir la p√°gina en </font></font><code>0xdeadbeaf000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lugar de </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub fn create_example_mapping(‚Ä¶) { [‚Ä¶] let page: Page = Page::containing_address(VirtAddr::new(0xdeadbeaf000)); [‚Ä¶] } // in src/main.rs #[no_mangle] pub extern "C" fn _start() -&gt; ! { [‚Ä¶] unsafe { (0xdeadbeaf900 as *mut u64).write_volatile(0xf021f077f065f04e)}; [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al comenzar, un p√°nico comienza con el siguiente mensaje de error: </font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entr√≥ en p√°nico en 'map_to fall√≥: FrameAllocationFailed', /.../result.rs:999haps </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mostrar p√°ginas que a√∫n no tienen una tabla de nivel de p√°gina 1, debe crear la correcta </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pero, ¬øc√≥mo saber qu√© cuadros son gratuitos y cu√°nta memoria f√≠sica est√° disponible?</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Informaci√≥n de arranque </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las diferentes computadoras tienen diferentes cantidades de memoria f√≠sica y las diferentes √°reas reservadas por dispositivos como VGA difieren. Solo el BIOS o el firmware UEFI saben exactamente qu√© √°reas de memoria se pueden usar y cu√°les est√°n reservadas. Ambos est√°ndares de firmware proporcionan funciones para obtener una tarjeta de asignaci√≥n de memoria, pero solo se pueden llamar al comienzo de la descarga. Por lo tanto, nuestro gestor de arranque ya ha solicitado esta (y otra) informaci√≥n del BIOS. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para pasar informaci√≥n al n√∫cleo del sistema operativo, el cargador como argumento al llamar a la funci√≥n </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proporciona un enlace a la estructura de informaci√≥n del arranque. Agregue este argumento a nuestra funci√≥n:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::bootinfo::BootInfo; #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start(boot_info: &amp;'static BootInfo) -&gt; ! { // new argument [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La estructura </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>BootInfo</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a√∫n se est√° finalizando, as√≠ que no se sorprenda cuando se cuelgue al actualizar a futuras versiones del gestor de arranque que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">compatibles con semver</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por el momento se cuenta con tres campos </font></font><code>p4_table_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>package</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El campo </font></font><code>p4_table_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contiene una direcci√≥n virtual recursiva de la tabla de p√°ginas de nivel 4. Gracias a esto, no es necesario registrar la direcci√≥n de forma r√≠gida </font></font><code>0o_177777_777_777_777_777_0000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El campo </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es de mayor inter√©s, ya que contiene una lista de todas las √°reas de memoria y su tipo (no utilizado, reservado u otros).</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El campo </font></font><code>package</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es la funci√≥n actual para asociar datos adicionales con el cargador. </font><font style="vertical-align: inherit;">La implementaci√≥n no est√° completa, por lo que podemos ignorarla por ahora.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de usar el campo </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para crear el correcto </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, queremos garantizar el tipo correcto de argumento </font></font><code>boot_info</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Macro </font></font><code>entry_point</code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como se </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llama externamente, no se verifica la firma de la funci√≥n. </font><font style="vertical-align: inherit;">Esto significa que los argumentos arbitrarios no conducir√°n a errores de compilaci√≥n, pero pueden causar un bloqueo o un comportamiento de tiempo de ejecuci√≥n indefinido. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para verificar la firma, la caja </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para definir la funci√≥n Rust como punto de entrada utiliza una macro </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>entry_point</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con tipos validados. </font><font style="vertical-align: inherit;">Reescribimos nuestra funci√≥n para esta macro:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::{bootinfo::BootInfo, entry_point}; entry_point!(kernel_main); #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS let mut recursive_page_table = unsafe { memory::init(boot_info.p4_table_addr as usize) }; [‚Ä¶] // create and test example mapping println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para el punto de entrada, ya no necesita usar </font></font><code>extern "C"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>no_mangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ya que la macro establece el punto de entrada real de bajo nivel </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La funci√≥n </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ahora se </font><font style="vertical-align: inherit;">ha </font><font style="vertical-align: inherit;">convertido en una funci√≥n Rust completamente normal, por lo que podemos elegir un nombre arbitrario para ella. </font><font style="vertical-align: inherit;">Es importante que ya est√© escrito, de modo que se produzca un error de compilaci√≥n si cambia la firma de la funci√≥n, por ejemplo, agregando un argumento o cambiando su tipo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que ahora estamos enviando a una </font></font><code>memory::init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direcci√≥n codificada, pero </font></font><code>boot_info.p4_table_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por lo tanto, el c√≥digo funcionar√° incluso si la versi√≥n futura del gestor de arranque selecciona otra entrada en la tabla de tabla de nivel de p√°gina 4 para la visualizaci√≥n recursiva.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selecci√≥n de marco </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, gracias a la informaci√≥n del BIOS, tenemos acceso a la tarjeta de asignaci√≥n de memoria, para que pueda hacer un distribuidor de trama normal. </font><font style="vertical-align: inherit;">Comencemos con el esqueleto general:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub struct BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { frames: I, } impl&lt;I&gt; FrameAllocator&lt;Size4KiB&gt; for BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { self.frames.next() } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El campo se </font></font><code>frames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicializa mediante un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iterador de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> marco </font><font style="vertical-align: inherit;">arbitrario </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto le permite simplemente delegar llamadas </font></font><code>alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al m√©todo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator :: next</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La inicializaci√≥n </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiene lugar en una nueva funci√≥n </font></font><code>init_frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use bootloader::bootinfo::{MemoryMap, MemoryRegionType}; /// Create a FrameAllocator from the passed memory map pub fn init_frame_allocator( memory_map: &amp;'static MemoryMap, ) -&gt; BootInfoFrameAllocator&lt;impl Iterator&lt;Item = PhysFrame&gt;&gt; { // get usable regions from memory map let regions = memory_map .iter() .filter(|r| r.region_type == MemoryRegionType::Usable); // map each region to its address range let addr_ranges = regions.map(|r| r.range.start_addr()..r.range.end_addr()); // transform to an iterator of frame start addresses let frame_addresses = addr_ranges.flat_map(|r| r.into_iter().step_by(4096)); // create `PhysFrame` types from the start addresses let frames = frame_addresses.map(|addr| { PhysFrame::containing_address(PhysAddr::new(addr)) }); BootInfoFrameAllocator { frames } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esta funci√≥n, utilizando un combinador, convierte el mapa de asignaci√≥n de memoria original en un iterador de las tramas f√≠sicas utilizadas: </font></font><br><br><ul><li>    <code>iter</code>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>MemoryRegion</code></a> .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>filter</code></a> ,      .          ,  ,    (,   )     ,    <code>InUse</code>  .  ,    ,      - . <br></li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>map</code></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> range</a> Rust          . <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El tercer paso es el m√°s dif√≠cil: convertimos cada rango en un iterador usando el m√©todo </font></font><code>into_iter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y luego seleccionamos cada 4096a direcci√≥n con </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>step_by</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como el tama√±o de la p√°gina es de 4096 bytes (4 KiB), obtenemos la direcci√≥n del comienzo de cada marco. </font><font style="vertical-align: inherit;">La p√°gina del cargador alinea todas las √°reas de memoria utilizadas, por lo que no necesitamos un c√≥digo de alineaci√≥n o redondeo. </font><font style="vertical-align: inherit;">Reemplazando </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>flat_map</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, obtenemos en su </font></font><code>Iterator&lt;Item = u64&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lugar </font></font><code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la etapa final, convertiremos las direcciones iniciales a tipos </font></font><code>PhysFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para construir la requerida </font></font><code>Iterator&lt;Item = PhysFrame&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Luego use este iterador para crear y devolver uno nuevo </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos cambiar nuestra funci√≥n </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que pase la instancia en su </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lugar </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use x86_64::structures::paging::{PageTable, RecursivePageTable}; let mut recursive_page_table = unsafe { memory::init(boot_info.p4_table_addr as usize) }; // new let mut frame_allocator = memory::init_frame_allocator(&amp;boot_info.memory_map); blog_os::memory::create_mapping(&amp;mut recursive_page_table, &amp;mut frame_allocator); unsafe { (0xdeadbeaf900 as *mut u64).write_volatile(0xf021f077f065f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora la traducci√≥n de la direcci√≥n es exitosa, y nuevamente vemos el mensaje en blanco y negro </font><i><font style="vertical-align: inherit;">"¬°Nuevo!"</font></i><font style="vertical-align: inherit;"> En la pantalla</font></font><i><font style="vertical-align: inherit;"></font></i>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detr√°s de escena, el m√©todo </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crea tablas de p√°ginas faltantes de la siguiente manera:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extrae un marco no utilizado de </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coincide con una entrada de tabla de nivel superior con este marco. </font><font style="vertical-align: inherit;">Ahora se puede acceder al marco a trav√©s de una tabla de p√°ginas recursivas.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cero el marco para crear una nueva tabla de p√°ginas vac√≠a. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Va a la tabla del siguiente nivel. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque nuestra funci√≥n </font></font><code>create_maping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es solo un ejemplo, ahora podemos crear nuevas asignaciones para p√°ginas arbitrarias. </font><font style="vertical-align: inherit;">Esto es muy √∫til al asignar memoria e implementar m√∫ltiples subprocesos en futuros art√≠culos.</font></font><br><br><h1>  Resumen </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este art√≠culo, aprendi√≥ a usar una tabla recursiva de nivel 4 para traducir todos los marcos a direcciones virtuales computables. </font><font style="vertical-align: inherit;">Utilizamos este m√©todo para implementar la funci√≥n de traducci√≥n de direcciones y crear una nueva asignaci√≥n en las tablas de p√°ginas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vimos que crear nuevas asignaciones requiere marcos no utilizados para nuevas tablas. </font><font style="vertical-align: inherit;">Tal distribuidor de trama puede implementarse en base a la informaci√≥n del BIOS que el gestor de arranque pasa a nuestro n√∫cleo.</font></font><br><br><h1>  Que sigue </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el siguiente art√≠culo, crearemos un √°rea de memoria de almacenamiento din√°mico para nuestro kernel, que nos permitir√° </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asignar memoria</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y usar diferentes </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipos de colecciones</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439066/">https://habr.com/ru/post/439066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439050/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. Especialista certificado en redes de Cisco (CCNA). D√≠a 2. Modelos OSI y TCP-IP</a></li>
<li><a href="../439056/index.html">Integraci√≥n de la marca de cemento</a></li>
<li><a href="../439060/index.html">7 tipos de clientes</a></li>
<li><a href="../439062/index.html">Anisoprint Composer: impresi√≥n 3D de alta resistencia</a></li>
<li><a href="../439064/index.html">Un error de cuadr√≠cula t√≠pico (Bootstrap Grid), o por qu√© el dise√±ador y el dise√±ador de dise√±o no se entienden</a></li>
<li><a href="../439068/index.html">La campa√±a de spam "Te amo" redirigida a Jap√≥n</a></li>
<li><a href="../439070/index.html">China abandonar√° el sistema de IA anticorrupci√≥n Zero Trust debido a su alta eficiencia</a></li>
<li><a href="../439072/index.html">Manifiesto del desarrollador de casas inteligentes: 15 principios</a></li>
<li><a href="../439076/index.html">¬øEn qu√© aplicaciones esperar un c√≥digo malicioso desconocido?</a></li>
<li><a href="../439078/index.html">Programador permanente arrestado por crear una aplicaci√≥n m√≥vil a trav√©s de la cual actu√≥ el ped√≥filo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>