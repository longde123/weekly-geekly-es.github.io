<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦 🤬 💩 بحجم بطاقة بريدية فك تشفير التتبع 🍊 👨🏽‍🍳 🧛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""لقد فعل ذلك مرة أخرى!" - هذا هو ما حدث لي أول شيء عندما نظرت إلى الجزء الخلفي من نشرة Pixar [1] ، المليئة بالكامل بالكود. تم توقيع مجموعة من الإنشاءا...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>بحجم بطاقة بريدية فك تشفير التتبع</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434528/" style=";text-align:right;direction:rtl"><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/cr/xz/vj/crxzvjqqbw5gl4mv3wxxx2zw6wa.png"></div><br>  "لقد فعل ذلك مرة أخرى!" - هذا هو ما حدث لي أول شيء عندما نظرت إلى الجزء الخلفي من نشرة Pixar <sup>[1]</sup> ، المليئة بالكامل بالكود.  تم توقيع مجموعة من الإنشاءات والعبارات في الزاوية اليمنى السفلى من قبل أندرو كينسلر.  بالنسبة لأولئك الذين لا يعرفونه ، سأقول: أندرو هو مبرمج اخترع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">جهاز تتبع بحجم</a> 1337 بايت <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بحجم بطاقة العمل</a> في عام 2009. <br><br>  هذه المرة ، توصل أندرو إلى شيء أكثر ضخامة ، ولكن بنتيجة مرئية أكثر إثارة للاهتمام.  منذ أن أنهيت كتابتي Game Engine Black Books عن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Wolf3D</a> و <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">DOOM</a> ، كان لدي وقت لتعلم الدواوين الشفرة المشفرة.  وعلى الفور تقريبًا ، كنت مفتونًا حقًا بالتقنيات المكتشفة فيه.  كانت مختلفة تمامًا عن عمل أندرو السابق ، بناءً على جهاز تتبع شعاع "قياسي".  لقد كنت مهتمًا بالتعرف على مسيرة الشعاع ، وخصائص الهندسة الحجرية البنّاءة ، وتقديم / مسار مونت كارلو ، بالإضافة إلى العديد من الحيل الأخرى التي استخدمها للضغط على الكود في قطعة صغيرة من الورق. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/yc/z4/nt/ycz4ntg3qh91i6m2wymfccaekvk.png"></div><a name="habracut"></a><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/lf/2o/qv/lf2oqvd5d39pyfwxyixvjnrmlqq.png"></div><br><h2 style=";text-align:right;direction:rtl">  شفرة المصدر </h2><br><hr><br>  الجزء الأمامي من المنشور هو إعلان لقسم التوظيف في بيكسار.  على الجانب العكسي ، تتم طباعة 2037 بايت من رمز C ++ ، معتمًا بحيث تشغل أصغر سطح ممكن. <br><br><pre style=";text-align:right;direction:rtl"><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; // card &gt; pixar.ppm #include &lt;stdio.h&gt; #include &lt;math.h&gt; #define R return #define O operator typedef float F;typedef int I;struct V{F x,y,z;V(F v=0){x=y=z=v;}V(F a,F b,F c=0){x=a;y=b;z=c;}V O+(V r){RV(x+rx,y+ry,z+rz);}VO*(V r){RV(x*rx,y*r. y,z*rz);}FO%(V r){R x*r.x+y*r.y+z*rz;}VO!(){R*this*(1/sqrtf(*this%*this) );}};FL(F l,F r){R l&lt;r?l:r;}FU(){R(F)rand()/RAND_MAX;}FB(V p,V l,V h){l=p +l*-1;h=h+p*-1;RL(L(L(lx,hx),L(ly,hy)),L(lz,hz));}FS(V p,I&amp;m){F d=1\ e9;V f=p;fz=0;char l[]="5O5_5W9W5_9_COC_AOEOA_E_IOQ_I_QOUOY_Y_]OWW[WaOa_aW\ eWa_e_cWiO";for(I i=0;i&lt;60;i+=4){V b=V(l[i]-79,l[i+1]-79)*.5,e=V(l[i+2]-79,l [i+3]-79)*.5+b*-1,o=f+(b+e*L(-L((b+f*-1)%e/(e%e),0),1))*-1;d=L(d,o%o);}d=sq\ rtf(d);V a[]={V(-11,6),V(11,6)};for(I i=2;i--;){V o=f+a[i]*-1;d=L(d,ox&gt;0?f\ absf(sqrtf(o%o)-2):(o.y+=oy&gt;0?-2:2,sqrtf(o%o)));}d=powf(powf(d,8)+powf(pz, 8),.125)-.5;m=1;F r=L(-L(B(p,V(-30,-.5,-30),V(30,18,30)),B(p,V(-25,17,-25),V (25,20,25))),B(V(fmodf(fabsf(px),8),py,pz),V(1.5,18.5,-25),V(6.5,20,25))) ;if(r&lt;d)d=r,m=2;F s=19.9-py;if(s&lt;d)d=s,m=3;R d;}IM(V o,V d,V&amp;h,V&amp;n){I m,s= 0;F t=0,c;for(;t&lt;100;t+=c)if((c=S(h=o+d*t,m))&lt;.01||++s&gt;99)R n=!V(S(h+V(.01,0 ),s)-c,S(h+V(0,.01),s)-c,S(h+V(0,0,.01),s)-c),m;R 0;}VT(V o,V d){V h,n,r,t= 1,l(!V(.6,.6,1));for(I b=3;b--;){I m=M(o,d,h,n);if(!m)break;if(m==1){d=d+n*( n%d*-2);o=h+d*.1;t=t*.2;}if(m==2){F i=n%l,p=6.283185*U(),c=U(),s=sqrtf(1-c), g=nz&lt;0?-1:1,u=-1/(g+nz),v=nx*ny*u;d=V(v,g+ny*ny*u,-ny)*(cosf(p)*s)+V( 1+g*nx*nx*u,g*v,-g*nx)*(sinf(p)*s)+n*sqrtf(c);o=h+d*.1;t=t*.2;if(i&gt;0&amp;&amp;M(h +n*.1,l,h,n)==3)r=r+t*V(500,400,100)*i;}if(m==3){r=r+t*V(50,80,100);break;}} R r;}I main(){I w=960,h=540,s=16;V e(-22,5,25),g=!(V(-3,4,0)+e*-1),l=!V(gz, 0,-gx)*(1./w),u(gy*lz-gz*ly,gz*lx-gx*lz,gx*ly-gy*lx);printf("P\ 6 %d %d 255 ",w,h);for(I y=h;y--;)for(I x=w;x--;){V c;for(I p=s;p--;)c=c+T(e ,!(g+l*(xw/2+U())+u*(yh/2+U())));c=c*(1./s)+14./241;V o=c+1;c=V(cx/ox,c. y/oy,cz/oz)*255;printf("%c%c%c",(I)cx,(I)cy,(I)cz);}}// Andrew Kensler</span></span></span></span></code> </pre> <br><h2 style=";text-align:right;direction:rtl">  هل هو حتى العمل؟ </h2><br><hr><br>  مع رمز هناك تعليمات لإطلاقها.  الفكرة هي إعادة توجيه الإخراج القياسي إلى ملف.  بالامتداد ، يمكننا أن نفترض أن تنسيق الإخراج هو تنسيق صورة نصية يسمى NetPBM <sup>[2]</sup> . <br><br><pre style=";text-align:right;direction:rtl">  $ clang -o card2 -O3 raytracer.cpp
 $ time ./card&gt; pixar.ppm<font></font>
<font></font>
 2m58.524s الحقيقي
 المستخدم 2m57.567s
 تميز الكلية 0m0.415s </pre><br>  بعد دقيقتين وثمانية وخمسين ثانية <sup>[3]</sup> ، يتم إنشاء الصورة التالية.  إنه لأمر مدهش كم هو مطلوب رمز لذلك. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/cae/b34/b5c/caeb34b5c6c57c4598adc8f6b3f28f38.webp"></div><br>  يمكنك استخراج الكثير من الصورة أعلاه.  حصى هو علامة واضحة على "مسار التتبع".  هذا النوع من العارض يختلف عن التصوير الشعاعي لأنه لا يتم تتبع الأشعة مرة أخرى إلى مصادر الضوء.  في هذه الطريقة ، تنبعث آلاف الأشعة لكل بكسل من المصادر ويقوم البرنامج بمراقبتها ، على أمل أن يعثروا على مصدر الضوء.  هذه تقنية مثيرة للاهتمام ، أفضل بكثير من تتبع الشعاع ، والتي يمكنها التعامل مع التجسيد المحيط ، والظلال الناعمة ، والمواد الكاوية ، والإشعاع. <br><br><h2 style=";text-align:right;direction:rtl">  سنقوم بتقسيم الكود إلى أجزاء </h2><br><hr><br>  يؤدي تمرير الإدخال إلى CLion إلى تهيئة الرمز (انظر الإخراج <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا</a> ) ويقسمه إلى أجزاء / مهام أصغر. <br><br><pre style=";text-align:right;direction:rtl">  <font color="grey">#include &lt;stdlib.h&gt; // card&gt; pixar.ppm</font> <font color="grey">
</font>  <font color="grey"># تضمين &lt;stdio.h&gt;</font> <font color="grey">
</font>  <font color="grey"># تتضمن &lt;math.h&gt;</font> </pre><br><pre style=";text-align:right;direction:rtl">  <font color="fuchsia"># حدد عودة R</font> <font color="fuchsia">
</font>  <font color="fuchsia"># تعريف عامل التشغيل O</font> <font color="fuchsia">
</font>  <font color="fuchsia">typedef تعويم F ؛ typedef int I؛</font> </pre><pre style=";text-align:right;direction:rtl">  <font color="blue">البنية V {F x، y، z؛ V (F v = 0) {x = y = z = v؛} V (F a، F b، F</font> <font color="blue">
</font>  <font color="blue">c = 0) {x = a؛ y = b؛ z = c؛} V O + (V r) {RV (x + rx، y + ry، z + rz)؛} VO * (V r) {RV ( س * ص ، ص * ص.</font> <font color="blue">
</font>  <font color="blue">y، z * rz)؛} FO٪ (V r) {R x * r.x + y * r.y + z * rz؛} VO! () {R * this * (1 / sqrtf (* this٪ * هذا)</font> <font color="blue">
</font>  <font color="blue">) ؛}} ؛</font> </pre><pre style=";text-align:right;direction:rtl">  <font color="orange">FL (F l، F r) {R l &lt;r؟ L: r؛} FU () {R (F) rand () / RAND_MAX؛} FB (V p، V l، V h) {l = p</font> <font color="orange">
</font>  <font color="orange">+ l * -1 ؛ h = h + p * -1 ؛ RL (L (L (L (L (lx، hx) و L (ly، hy))، L (lz، hz))؛}</font> </pre><pre style=";text-align:right;direction:rtl">  <font color="LimeGreen">FS (V p ، I &amp; m) {F d = 1 \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">e9 ؛ V f = p ؛ fz = 0؛ char l [] = "5O5_5W9W5_9_COC_AOEOA_E_IOQ_I_QOUOY_Y_] OWW [WaOa_aW \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">eWa_e_cWiO "؛ لـ (I i = 0؛ i &lt;60؛ i + = 4) {V b = V (l [i] -79، l [i + 1] -79) *. 5، e = V (l [ i + 2] -79 ، ل</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">[i + 3] -79) *. 5 + b * -1 ، o = f + (b + e * L (-L ((b + f * -1)٪ e / (e٪ e) ، 0) ، 1)) * - 1 ؛ d = L (d ، o٪ o) ؛} d = sq \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">rtf (d) ؛ V a [] = {V (-11.6) ، V (11.6)} ؛ من أجل (I i = 2 ؛ i - ؛) {V o = f + a [i] * -1 ؛ د = L (د ، ثور&gt; 0؟ F \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">absf (sqrtf (o٪ o) -2) :( o.y + = oy&gt; 0؟ -2: 2، sqrtf (o٪ o)))؛} d = powf (powf (d، 8) + powf (pz ،</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">8) ، 125) - .5 ؛ م = 1 ؛ F r = L (-L (B (p ، V (-30 ، -. 5 ، -30) ، V (30،18،30)) ، B (ص ، الخامس (-25.17 ، -25) ، الخامس</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">(25،20،25))) ، B (V (fmodf (fabsf (px) ، 8) ، py ، pz) ، V (1.5،18.5، -25)، V (6.5،20،25)))</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">؛ إذا (r &lt;d) d = r ، m = 2 ؛ F s = 19.9-py ؛ إذا (s &lt;d) d = s، m = 3؛ R d؛}</font> </pre><pre style=";text-align:right;direction:rtl">  <font color="black">IM (V o و V d و V &amp; h و V &amp; n) {I m، s =</font> <font color="black">
</font>  <font color="black">0 ؛ F t = 0 ، c ؛ لـ (؛ t &lt;100 ؛ t + = c) if ((c = S (h = o + d * t، m)) &lt;. 01 || ++ s&gt; 99) R n =! V (S (h + V (.01،0</font> <font color="black">
</font>  <font color="black">)، s) -c، S (h + V (0، .01)، s) -c، S (h + V (0،0، .01)، s) -c)، m؛ R 0؛}</font> </pre><pre style=";text-align:right;direction:rtl">  <font color="SkyBlue">VT (V o، V d) {V h، n، r، t =</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">1 ، l (! V (.6 ، .6 ، 1)) ؛ من أجل (I b = 3 ؛ b - ؛) {I m = M (o ، d ، h ، n) ؛ إذا كسر (! M) ؛ إذا (م == 1) {د = د + ن * (</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">n٪ d * -2) ؛ o = h + d * .1 ؛ t = t * .2؛} إذا (m == 2) {F i = n٪ l، p = 6.283185 * U ()، c = U () ، s = sqrtf (1-c) ،</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">g = nz &lt;0؟ -1: 1، u = -1 / (g + nz)، v = nx * ny * u؛ d = V (v، g + ny * ny * u، -ny) * (cosf (ع) * s) + V (</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">1 + g * nx * nx * u، g * v، -g * nx) * (sinf (p) * s) + n * sqrtf (c)؛ o = h + d * .1؛ t = t *. 2 ؛ إذا (i&gt; 0 &amp;&amp; M (h</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">+ n * .1 ، l ، h ، n) == 3) r = r + t * V (500،400،100) * i؛} إذا (m == 3) {r = r + t * V (50،80،100) ؛ break ؛}}</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">ص ص ؛}</font> </pre><pre style=";text-align:right;direction:rtl">  <font color="red">I main () {I w = 960، h = 540، s = 16؛ V e (-22،5،25)، g =! (V (-3،4،0) + e * -1)، l =! V (gz ،</font> <font color="red">
</font>  <font color="red">0، -xx) * (1./w) ، u (gy * lz-gz * ly ، gz * lx-gx * lz ، gx * ly-gy * lx) ؛ printf ("P \</font> <font color="red">
</font>  <font color="red">6٪ d٪ d 255 "، w ، h) ؛ من أجل (I y = h ؛ y - ؛) لـ (I x = w ؛ x - ؛) {V c ؛ من أجل (I p = s؛ p- - ؛) ج = ج + T (ه</font> <font color="red">
</font>  <font color="red">،! (g + l * (xw / 2 + U ()) + u * (yh / 2 + U ()))) ؛ c = c * (1./s) + 14. / 241 ؛ V o = c + 1 ؛ c = V (cx / ox ، c.</font> <font color="red">
</font>  <font color="red">y / o، cz / oz) * 255؛ printf ("٪ c٪ c٪ c"، (I) cx، (I) cy، (I) cz)؛}}</font> </pre><pre style=";text-align:right;direction:rtl">  <font color="LightGray">// أندرو كينسلر</font> </pre><br>  يوصف كل قسم بالتفصيل في بقية المقال: <br>  <font color="fuchsia">t</font> - الحيل العادية ، <font color="blue">■</font> - فئة المتجهات ، code - التعليمات البرمجية المساعدة ، database - قاعدة البيانات ، <font color="black">mar</font> - مسيرة راي ، <font color="SkyBlue">■</font> - أخذ العينات ، main - الكود الرئيسي. <br><br><h2 style=";text-align:right;direction:rtl">  الحيل المشتركة مع #define و typedef </h2><br><hr><br>  تستخدم الحيل الشائعة #define و typedef لتقليل مقدار التعليمات البرمجية بشكل ملحوظ.  هنا نشير إلى F = float و I = int و R = return و O = عامل التشغيل.  الهندسة العكسية تافهة. <br><br><h2 style=";text-align:right;direction:rtl">  الدرجة الخامسة </h2><br><hr><br>  بعد ذلك تأتي الفئة V ، التي قمت بإعادة تسميتها إلى Vec (على الرغم من ذلك ، كما سنرى أدناه ، يتم استخدامه أيضًا لتخزين قنوات RGB بتنسيق عائم). <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y, z; Vec(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = y = z = v; } Vec(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = a; y = b; z = c;} Vec <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(Vec r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec(x + rx, y + ry, z + rz); } Vec <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*(Vec r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec(x * rx, y * ry, z * rz); } <span class="hljs-comment"><span class="hljs-comment">// dot product float operator%(Vec r) { return x * rx + y * ry + z * rz; } // inverse square root Vec operator!() {return *this * (1 / sqrtf(*this % *this) );} };</span></span></code> </pre> <br>  لاحظ أنه لا يوجد عامل طرح (-) ، لذا بدلاً من كتابة "X = A - B" ، يتم استخدام "X = A + B * -1".  يأتي الجذر التربيعي العكسي مفيدًا في وقت لاحق لتطبيع المتجهات. <br><br><h2 style=";text-align:right;direction:rtl">  الوظيفة الرئيسية </h2><br><hr><br>  main () هو الحرف الوحيد الذي لا يمكن حجبه لأنه يتم استدعاؤه بواسطة الدالة _start لمكتبة libc.  عادةً ما يستحق البدء به ، لأنه سيكون من الأسهل العمل بهذه الطريقة.  استغرق الأمر مني بعض الوقت لمعرفة معاني الحروف الأولى ، ولكن لا يزال بإمكاني إنشاء شيء يمكن قراءته. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = <span class="hljs-number"><span class="hljs-number">960</span></span>, h = <span class="hljs-number"><span class="hljs-number">540</span></span>, samplesCount = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">position</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-22</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">25</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Vec goal = !(Vec(<span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + position * <span class="hljs-number"><span class="hljs-number">-1</span></span>); Vec left = !Vec(goal.z, <span class="hljs-number"><span class="hljs-number">0</span></span>, -goal.x) * (<span class="hljs-number"><span class="hljs-number">1.</span></span> / w); <span class="hljs-comment"><span class="hljs-comment">// Cross-product to get the up vector Vec up(goal.y * left.z - goal.z * left.y, goal.z * left.x - goal.x * left.z, goal.x * left.y - goal.y * left.x); printf("P6 %d %d 255 ", w, h); for (int y = h; y--;) for (int x = w; x--;) { Vec color; for (int p = samplesCount; p--;) color = color + Trace(position, !(goal + left * (x - w / 2 + randomVal())+ up * (y - h / 2 + randomVal()))); // Reinhard tone mapping color = color * (1. / samplesCount) + 14. / 241; Vec o = color + 1; color = Vec(color.x / ox, color.y / oy, color.z / oz) * 255; printf("%c%c%c", (int) color.x, (int) color.y, (int) color.z); } }</span></span></code> </pre> <br>  لاحظ أن القيم الحرفية العائمة لا تحتوي على الحرف "f" ، ويتم تجاهل الجزء الكسري لتوفير المساحة.  يتم استخدام نفس الخدعة أدناه ، حيث يتم إسقاط الجزء الصحيح (تعويم x = 0.5).  من غير المألوف أيضًا إنشاء "for" مع تعبير التكرار الذي يتم إدراجه داخل شرط الاستراحة. <br><br>  هذه هي الوظيفة الرئيسية القياسية جدا لتتبع الأشعة / المسار.  يتم تعيين متجهات الكاميرا هنا وتنبعث الأشعة لكل بكسل.  الفرق بين جهاز تتبع الشعاع وجهاز تتبع المسار هو أن العديد من الأشعة تنبعث لكل بكسل في TP ، والتي تحولت بشكل عشوائي قليلاً.  ثم يتم تجميع اللون الناتج لكل شعاع في البيكسل في ثلاث قنوات عائمة R و B و G.  في النهاية ، يتم إجراء تصحيح الدرجة اللونية لنتائج طريقة راينهارت. <br><br>  الجزء الأكثر أهمية هو sampleCount ، والذي يمكن من الناحية النظرية تعيينه على 1 لتسريع التقديم والتكرار.  فيما يلي نماذج للنتائج مع قيم عينة من 1 إلى 2048. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">المفسد العنوان</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/550/e66/b2b/550e66b2b1347f8cafdf18c50d89e40d.png"><br><br>  1 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f49/724/1f0/f497241f0e3bb43fcc9913d8a2745419.png"><br><br>  2 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f71/3f3/35c/f713f335c2842b995936db1499e307e5.png"><br><br>  4 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4f/6d4/f56/b4f6d4f56198a64b8e569a62f7159e8a.png"><br><br>  8 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a70/200/3c6/a702003c61d4080c2f92fe84844238cd.png"><br><br>  16 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bcf/0d6/43c/bcf0d643c501839c2506c7c026bc445c.png"><br><br>  32 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f0/5cf/569/8f05cf5690fa3265a1a4fa6f60a35749.png"><br><br>  64 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ebd/c87/660/ebdc87660263ff14eb6bf03a95865f34.png"><br><br>  128 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d17/0d3/1ae/d170d31aed20aeafc54d877ed447a1cc.png"><br><br>  256 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb9/52c/4df/fb952c4dfd0a4cb14245cedd060dcf05.png"><br><br>  512 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/460/50f/715/46050f71582834ddebbeb29dd86940fc.png"><br><br>  1024 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/947/ea8/88b/947ea888b63c32f0892cc1e25b187bf8.png"><br><br>  2048 </div></div><br><h2 style=";text-align:right;direction:rtl">  كود المساعد </h2><br><hr><br>  آخر قطعة بسيطة من التعليمات البرمجية هي وظائف المساعد.  في هذه الحالة ، لدينا دالة تافهة min () ، ومولد قيمة عشوائية في الفاصل الزمني [0،1] و boxTest () الأكثر إثارة للاهتمام ، وهو جزء من نظام Constructive Solid Geometry (CSG) المستخدم لقطع العالم.  تمت مناقشة CSG في القسم التالي. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l &lt; r ? l : r; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomVal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) rand() / RAND_MAX; } <span class="hljs-comment"><span class="hljs-comment">// Rectangle CSG equation. Returns minimum signed distance from // space carved by lowerLeft vertex and opposite rectangle // vertex upperRight. float BoxTest(Vec position, Vec lowerLeft, Vec upperRight) { lowerLeft = position + lowerLeft * -1; upperRight = upperRight + position * -1; return -min( min( min(lowerLeft.x, upperRight.x), min(lowerLeft.y, upperRight.y) ), min(lowerLeft.z, upperRight.z)); }</span></span></code> </pre> <br><h2 style=";text-align:right;direction:rtl">  وظائف الهندسة الحجرية البناءة </h2><br><hr><br>  لا توجد رؤوس في الكود.  كل شيء يتم باستخدام وظائف CSG.  إذا كنت غير معتادًا عليها ، فقل ببساطة أن هذه وظائف تصف ما إذا كان الإحداثي داخل الكائن أم خارجه.  إذا أرجعت الدالة مسافة موجبة ، فستكون النقطة داخل الكائن.  تشير المسافة السالبة إلى أن النقطة تقع خارج الكائن.  هناك العديد من الوظائف لوصف الكائنات المختلفة ، ولكن من أجل التبسيط ، لنأخذ على سبيل المثال كرة ونقطتين ، A و B. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/56f/424/13a/56f42413a77c51a3d06e12fd4b4b385e.svg" alt="الصورة"></div><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to sphere(c,r) float testSphere(Vec p, Vec c, float r) { Vec delta = c - p; float distance = sqrtf(delta%delta); return radius - distance; } Vec A {4, 6}; Vec B {3, 2}; Vec C {4, 2}; float r = 2.; testSphere(A, C, r); // == -1 (outside) testSphere(B, C, r); // == 1 (inside)</span></span></code> </pre> <br>  ترجع الدالة testSphere () -1 للنقطة A (أي ، هي خارج) و 1 لـ B (أي ، هي داخل).  تعتبر العلامات على المسافات مجرد خدعة ، حيث تتيح لك الحصول على قسمين من المعلومات بدلاً من واحدة في حالة قيمة واحدة.  يمكن أيضًا كتابة نوع مماثل من الوظائف لوصف متوازي الاضلاع (هذا هو بالضبط ما يتم تنفيذه في الدالة BoxTest). <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/757/1cd/25b/7571cd25baa7d2f9cfbd01f62e84aef1.svg"></div><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to Box(c1,c2) float testRectangle(Vec p, Vec c1, Vec c2) { c1 = p + c1 * -1; c2 = c2 + position * -1; return min( min( min(c1.x, c2.x), min(c1.y, c2.y)), min(c1.z, c2.z)); } Vec A {3, 3}; Vec B {4, 6}; Vec C1 {2, 2}; Vec C2 {5, 4}; testRectangle(A, C1, C2); // 1.41 (inside) testRectangle(B, C1, C2); // -2.23 (outside)</span></span></code> </pre> <br>  الآن دعونا نرى ما يحدث إذا قلبت علامة القيمة المرجعة. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/017/bd8/dcd017bd89a9e9d3955c94be3645aa20.svg"></div><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to carved box(c1,c2) float testCarveBox(Vec p, Vec c1, Vec c2) { c1 = p + c1 * -1; c2 = c2 + position * -1; return -min( min( min(c1.x, c2.x), min(c1.y, c2.y)), min(c1.z, c2.z)); } Vec A {3, 3}; Vec B {4, 6}; Vec C1 {2, 2}; Vec C2 {5, 4}; testCarveBox(A, C1, C2); // == -1.41 (outside) testCarveBox(B, C1, C2); // == 2.23 (inside)</span></span></code> </pre> <br>  الآن نحن لا نصف كائنًا صلبًا ، ولكننا أعلنا العالم كله صلبًا ونقطع مساحة فارغة فيه.  يمكن استخدام الوظائف كطوب بناء ، والتي يمكن عند الجمع بينها وصف أشكال أكثر تعقيدًا.  باستخدام عامل الإضافة المنطقية (دالة دقيقة) ، يمكننا قطع زوج من المستطيلات واحدًا فوق الآخر وستبدو النتيجة هكذا. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/48b/f78/615/48bf786150f9d37af1f51fd12987162e.svg"></div><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point to room float testRoom(Vec p) { Vec C1 {2, 4}; Vec C2 {5, 2}; // Lower room Vec C3 {3, 5}; Vec C4 {4, 4}; // Upper room // min() is the union of the two carved volumes. return min(testCarvedBox(p, C1, C2), testCarvedBox(p, C3, C4)); } Vec A {3, 3}; Vec B {4, 6}; testRoom(A, C1, C2); // == -1.41 (outside) testRoom(B, C1, C2); // == 1.00 (inside)</span></span></code> </pre> <br>  إذا كنت تفكر في الأمر ، فإنه يبدو وكأنه الغرفة التي ندرسها ، لأنه يتم التعبير عن الغرفة السفلية بهذه الطريقة بالضبط - بمساعدة اثنين من متوازي الأضلاع. <br><br>  الآن ، بعد إتقان المعرفة القوية لـ CSG ، يمكننا العودة إلى الكود والنظر في وظيفة قاعدة البيانات ، والتي هي الأصعب في التعامل معها. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_NONE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_LETTER 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_WALL 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_SUN 3 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Sample the world using Signed Distance Fields. float QueryDatabase(Vec position, int &amp;hitType) { float distance = 1e9; Vec f = position; // Flattened position (z=0) fz = 0; char letters[15*4+1] = // 15 two points lines "5O5_" "5W9W" "5_9_" // P (without curve) "AOEO" "COC_" "A_E_" // I "IOQ_" "I_QO" // X "UOY_" "Y_]O" "WW[W" // A "aOa_" "aWeW" "a_e_" "cWiO"; // R (without curve) for (int i = 0; i &lt; sizeof(letters); i += 4) { Vec begin = Vec(letters[i] - 79, letters[i + 1] - 79) * .5; Vec e = Vec(letters[i + 2] - 79, letters[i + 3] - 79) * .5 + begin * -1; Vec o = f + (begin + e * min(-min((begin + f * -1) % e / (e % e), 0), 1) ) * -1; distance = min(distance, o % o); // compare squared distance. } distance = sqrtf(distance); // Get real distance, not square distance. // Two curves (for P and R in PixaR) with hard-coded locations. Vec curves[] = {Vec(-11, 6), Vec(11, 6)}; for (int i = 2; i--;) { Vec o = f + curves[i] * -1; distance = min(distance, ox &gt; 0 ? fabsf(sqrtf(o % o) - 2) : (oy += oy &gt; 0 ? -2 : 2, sqrtf(o % o)) ); } distance = powf(powf(distance, 8) + powf(position.z, 8), .125) - .5; hitType = HIT_LETTER; float roomDist ; roomDist = min(// min(A,B) = Union with Constructive solid geometry //-min carves an empty space -min(// Lower room BoxTest(position, Vec(-30, -.5, -30), Vec(30, 18, 30)), // Upper room BoxTest(position, Vec(-25, 17, -25), Vec(25, 20, 25)) ), BoxTest( // Ceiling "planks" spaced 8 units apart. Vec(fmodf(fabsf(position.x), 8), position.y, position.z), Vec(1.5, 18.5, -25), Vec(6.5, 20, 25) ) ); if (roomDist &lt; distance) distance = roomDist, hitType = HIT_WALL; float sun = 19.9 - position.y ; // Everything above 19.9 is light source. if (sun &lt; distance)distance = sun, hitType = HIT_SUN; return distance; }</span></span></span></span></code> </pre> <br>  يمكنك أن ترى هنا وظيفة "الاستغناء" عن متوازي الاضلاع ، حيث يتم استخدام مستطيلين فقط لبناء الغرفة بأكملها (يعمل عقولنا بالباقي ، ويمثل الجدران).  السلم الأفقي عبارة عن وظيفة CSG أكثر تعقيدًا باستخدام تقسيم الباقي.  وأخيرًا ، تتكون أحرف كلمة PIXAR من 15 سطرًا مع زوج "أصل / دلتا" وحالتين خاصتين لمنحنيات في الحرفين P و R. <br><br><h2 style=";text-align:right;direction:rtl">  راي يسير </h2><br><hr><br>  امتلاك قاعدة بيانات لوظائف CSG التي تصف العالم ، يكفي أن نتخطى جميع الأشعة المنبعثة في الوظيفة الرئيسية ().  راي مسيرة يستخدم وظيفة المسافة.  هذا يعني أن موضع أخذ العينات ينتقل للأمام مسافة إلى أقرب عقبة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Perform signed sphere marching // Returns hitType 0, 1, 2, or 3 and update hit position/normal int RayMarching(Vec origin, Vec direction, Vec &amp;hitPos, Vec &amp;hitNorm) { int hitType = HIT_NONE; int noHitCount = 0; float d; // distance from closest object in world. // Signed distance marching for (float total_d=0; total_d &lt; 100; total_d += d) if ((d = QueryDatabase(hitPos = origin + direction * total_d, hitType)) &lt; .01 || ++noHitCount &gt; 99) return hitNorm = !Vec(QueryDatabase(hitPos + Vec(.01, 0), noHitCount) - d, QueryDatabase(hitPos + Vec(0, .01), noHitCount) - d, QueryDatabase(hitPos + Vec(0, 0, .01), noHitCount) - d) , hitType; // Weird return statement where a variable is also updated. return 0; }</span></span></code> </pre> <br>  إن فكرة مسيرة الشعاع على أساس المسافة هي المضي قدمًا إلى أقرب كائن.  في النهاية ، ستقترب الحزمة من السطح لدرجة أنه يمكن اعتبارها نقطة وقوع. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/e99/774/398/e997743989aa1cb22fb65e6d5d8e93f2.svg"></div><br>  لاحظ أن مسيرة الشعاع لا تُرجع تقاطعًا حقيقيًا مع السطح ، ولكن تقريبًا.  هذا هو السبب في توقف المسيرة في الكود عند d &lt;0.01f. <br><br><h2 style=";text-align:right;direction:rtl">  وضع كل ذلك معا: أخذ العينات </h2><br><hr><br>  التحقيق في مسار التتبع قد اكتمل تقريبًا.  نحن نفتقد الجسر الذي يربط الوظيفة الرئيسية () بمسيرة الشعاع.  هذا الجزء الأخير ، الذي قمت بتسميته "تتبع" ، هو "الدماغ" الذي ترتد فيه الأشعة أو تتوقف ، حسب ما تواجهه. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vec origin, Vec direction)</span></span></span><span class="hljs-function"> </span></span>{ Vec sampledPosition, normal, color, attenuation = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lightDirection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(!Vec(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.6</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.6</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Directional light for (int bounceCount = 3; bounceCount--;) { int hitType = RayMarching(origin, direction, sampledPosition, normal); if (hitType == HIT_NONE) break; // No hit. This is over, return color. if (hitType == HIT_LETTER) { // Specular bounce on a letter. No color acc. direction = direction + normal * ( normal % direction * -2); origin = sampledPosition + direction * 0.1; attenuation = attenuation * 0.2; // Attenuation via distance traveled. } if (hitType == HIT_WALL) { // Wall hit uses color yellow? float incidence = normal % lightDirection; float p = 6.283185 * randomVal(); float c = randomVal(); float s = sqrtf(1 - c); float g = normal.z &lt; 0 ? -1 : 1; float u = -1 / (g + normal.z); float v = normal.x * normal.y * u; direction = Vec(v, g + normal.y * normal.y * u, -normal.y) * (cosf(p) * s) + Vec(1 + g * normal.x * normal.x * u, g * v, -g * normal.x) * (sinf(p) * s) + normal * sqrtf(c); origin = sampledPosition + direction * .1; attenuation = attenuation * 0.2; if (incidence &gt; 0 &amp;&amp; RayMarching(sampledPosition + normal * .1, lightDirection, sampledPosition, normal) == HIT_SUN) color = color + attenuation * Vec(500, 400, 100) * incidence; } if (hitType == HIT_SUN) { // color = color + attenuation * Vec(50, 80, 100); break; // Sun Color } } return color; }</span></span></code> </pre> <br>  لقد جربت قليلاً مع هذه الوظيفة لتغيير الحد الأقصى لعدد انعكاسات الحزمة المسموح بها.  القيمة "2" تعطي الحروف لون Vantablack المطلي بشكل جميل بشكل مدهش <sup>[4]</sup> . <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/d10/940/a3e/d10940a3ed7efab3271097904ce50d77.png"></div><br>  <i>1</i> <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/e0c/8b2/c3b/e0c8b2c3b249057b1f5fd0d166e12014.png"></div><br>  <i>2</i> <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/fb9/52c/4df/fb952c4dfd0a4cb14245cedd060dcf05.png"></div><br>  <i>3</i> <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/65c/2f5/716/65c2f5716578caaa2fcc454a49376578.png"></div><br>  <i>4</i> <br><br><h2 style=";text-align:right;direction:rtl">  تنظيفها تماما شفرة المصدر </h2><br><hr><br>  لوضع كل شيء معًا ، قمت بإنشاء <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">شفرة مصدر</a> نظيفة تمامًا. <br><br><h2 style=";text-align:right;direction:rtl">  المراجع </h2><br><hr><br>  [1] المصدر: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">منشور Twitter lexfrench في 8 أكتوبر 2018.</a> <br><br>  [2] المصدر: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تنسيق صورة NetPBM</a> <br><br>  [3] المصدر: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">أداء التصور على أقوى جهاز MacBook Pro ، 2017</a> <br><br>  [4] المصدر: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ويكيبيديا: فانتابلاك</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar434528/">https://habr.com/ru/post/ar434528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar434514/index.html">"الأسرار" DPAPI أو DPAPI لـ Pentesters</a></li>
<li><a href="../ar434516/index.html">طريقة سهلة للتعامل مع طموحاتك المهنية.</a></li>
<li><a href="../ar434518/index.html">التصفيق والهتافات: الدراما التي تسيطر عليها بعناية في متاجر أبل</a></li>
<li><a href="../ar434522/index.html">أنماط تبرير المهام و antipatterns</a></li>
<li><a href="../ar434524/index.html">Kubernetes تدخل من خلال عيون المبتدئين</a></li>
<li><a href="../ar434530/index.html">التقويم الافتراضي ، إصلاحات في LDAP والابتكارات الأخرى في Zimbra 8.8.11</a></li>
<li><a href="../ar434532/index.html">قصة مشروع واحد: عندما لا يكون لدى فريق مطور كبير</a></li>
<li><a href="../ar434534/index.html">ONYX BOOX "كتابي الأول": قراءة غير مؤذية لأمي والطفل</a></li>
<li><a href="../ar434538/index.html">الكفاح من أجل الفضاء: ما يحدث في سوق الإنترنت عبر الأقمار الصناعية</a></li>
<li><a href="../ar434540/index.html">ماذا تفعل مع الأشخاص الذين سيتم استبدالهم بالروبوتات؟</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>