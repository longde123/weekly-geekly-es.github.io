<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧖🏾 🚘 ⏏️ Streaming vidéo via un navigateur à très faible latence (et WebRTC!) 🥋 😆 👨‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alors que les premiers premiers adoptants essaient nos nouvelles vidéoconférences (jusqu'à 100 personnes!) Dans leurs projets, nous continuons à parle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Streaming vidéo via un navigateur à très faible latence (et WebRTC!)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/421121/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/oa/hu/kv/oahukvx05phesrj7ttv_qg9o3pq.gif"></div><br>  Alors que les premiers premiers adoptants essaient nos nouvelles vidéoconférences (jusqu'à 100 personnes!) Dans leurs projets, nous continuons à parler de choses intéressantes du monde de la transmission vocale et vidéo avec un navigateur.  Nous parlerons également de visioconférence, mais plus tard - lorsqu'une masse critique d'utilisateurs s'accumule et que des statistiques intéressantes sont collectées.  Et maintenant, j'ai traduit et adapté pour nous l'histoire du Dr  Alex sur la place des différents protocoles lors de la transmission vidéo à faible latence.  L'histoire est essentiellement une réponse à un autre article, et l'auteur, avec l'histoire, souligne les erreurs et les inexactitudes que ses collègues de l'atelier ont faites. <br><a name="habracut"></a><br><h2>  Données réseau: alarme séparément, vidéo séparément </h2><br>  Dans les systèmes modernes, si vous voyez de la vidéo dans un navigateur, le flux vidéo et l'alarme seront très probablement traités par différents serveurs.  Si tout est clair avec la vidéo, le «serveur d'alarme» fournit deux choses: «découverte» et «poignée de main».  La première, la «découverte», est le choix de la méthode de transfert des données: adresses IP, un serveur intermédiaire (si nécessaire).  «Poignée de main» - sur la négociation entre les participants à la transmission vidéo et sonore: codecs, résolution, fréquence d'images, qualité.  Fait intéressant, dans Flash ancien, la signalisation et la transmission multimédia n'étaient pas séparées comme dans VoxIP ou WebRTC et étaient fournies par un protocole: RTMP. <br><br><h2>  La différence entre le protocole de signalisation et le transport de signalisation </h2><br>  Le protocole de signalisation définit la langue avec laquelle le navigateur et les autres participants à la transmission vidéo se mettront d'accord sur la découverte et la prise de contact.  Cela peut être SIP pour la découverte en VoIP ou WebRTC, et c'est avec une offre / réponse pour une poignée de main.  Il y a longtemps, Flash utilisait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTMP / AMF</a> .  Et si vous le souhaitez, pour WebRTC, vous pouvez utiliser non pas SIP, mais JSEP inhabituel. <br><br>  Le protocole de transport de signalisation de la même pile, mais inférieur: c'est ainsi que les paquets de protocole de signalisation seront physiquement transmis.  Traditionnellement, pour Flash + SIP, TCP ou UDP était utilisé, mais maintenant dans le bundle WebRTC + SIP, les WebSockets sont de plus en plus présents.  Le protocole de transport WebSockets occupe la niche TCP des navigateurs où vous ne pouvez pas utiliser de sockets TCP et UDP «purs». <br><br>  Une pile de signalisation complète est désormais couramment décrite avec des expressions comme «SIP au-dessus des sockets Web», «JSEP au-dessus des sockets Web», obsolète «SIP au-dessus de TCP / UDP» ou l'ancienne «partie de RTMP». <br><br><h2>  Programmeur anglicisme: Media Codec </h2><br>  La plupart des protocoles de streaming vidéo sont liés à un ou plusieurs codecs.  La vidéo reçue de la caméra est traitée image par image.  Et les problèmes de réseau, tels que la réduction de la bande passante, la perte de paquets ou le retard entre eux, sont résolus par les paramètres du codec pour chaque trame.  Pour en savoir plus sur les problèmes de réseau dans le temps, nous utilisons des mécanismes de protocole de transport (RTP / RTCP) et des mécanismes d'estimation de bande passante (REMB, Transport-CC, TIMBR).  L'un des problèmes fondamentaux avec la vidéo Flash était que RTMP ne pouvait pas faire non plus, donc la vidéo s'arrêtait simplement lorsque la bande passante du canal diminuait. <br><br><h2>  Un autre anglicisme: le protocole de streaming multimédia </h2><br>  Détermine comment diviser le flux vidéo en petits paquets qui sont envoyés sur le réseau par le protocole de transport.  En règle générale, le protocole de streaming fournit toujours des mécanismes pour gérer les problèmes de réseau: perte et retard de paquets.  Tampon de gigue, retransmission (RTC), redondance (RED) et correction d'erreur directe (FEC). <br><br><h2>  Protocole de transfert de média </h2><br>  Une fois la vidéo reçue de la caméra divisée en petits paquets, ils doivent être transmis sur le réseau.  Le protocole de transport utilisé pour cela est similaire à celui de signalisation, mais comme la «charge utile» est complètement différente, certains protocoles sont meilleurs que d'autres.  Par exemple, TCP fournit l'accessibilité des paquets, mais il n'ajoute pas de valeur à la pile, car des mécanismes similaires (RTX / RED / FEC) sont déjà dans le protocole de streaming.  Mais les retards dans la retransmission vers TCP sont une faille évidente que UDP n'a pas.  Mais il y a la pratique de bloquer UDP comme «protocole pour les torrents». <br><br>  Le choix du protocole et des ports réseau était précédemment décidé par «hardcoding», mais maintenant nous utilisons des protocoles tels que ICE dans WebRTC, ce qui nous permet de nous mettre d'accord sur les ports et le transport dans chaque connexion spécifique.  Dans un avenir proche, il est possible d'utiliser le protocole QUIC (rétrocompatible avec UDP), qui est activement discuté par l'IETF et présente des avantages par rapport à TCP et UDP en termes de vitesse et de fiabilité.  Enfin, nous pouvons mentionner les protocoles de streaming multimédia tels que MPEG-DASH et HLS, qui utilisent HTTP comme transport et bénéficieront de l'introduction de HTTP / 2.0. <br><br><h2>  Sécurité de transmission des médias </h2><br>  Certains moteurs protègent les données lors de leur transmission sur le réseau: soit le flux multimédia lui-même, soit les paquets de la couche transport.  Le processus comprend le transfert même de clés de chiffrement, pour lesquelles des protocoles distincts sont utilisés: SDES en VoIP et DTLS en WebRTC.  Ce dernier a un avantage, car en plus des données, il protège également la transmission des clés de chiffrement. <br><br><h2>  Ce qui me dérange dans tout ça </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/od/pd/xx/odpdxx5jrsjgoo8xu22boycell4.png"></div><br>  Certains développeurs, tels que les auteurs de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> , placent les protocoles purement WebSocket et QUIC au même niveau que WebRTC, Flash ou HLS.  Pour moi, un tel regroupement semble étrange, car les trois derniers protocoles sont une histoire de streaming multimédia.  L'encodage et la mise en paquets ont lieu avant d'utiliser WebSocket ou QUIC.  L'implémentation WebRTC de référence de Google (libwebrtc / chrome) et l'ORTC de Microsoft utilisent QUIC comme protocole de transport. <br><br>  Tout aussi surprenant est le manque de mention de HTTP / 2.0 comme optimisation pour les protocoles basés sur HTTP tels que HLS et MPEG-DASH.  Et le CMAF mentionné n'est rien de plus qu'un format de fichier pour HLS et MPEG-DASH, mais pas leur remplacement du tout. <br><br>  Enfin, SRT n'est qu'un protocole de transport.  Bien sûr, il ajoute un certain nombre de puces par rapport à celles basées sur les fichiers HLS et MPEG-DASH, mais toutes ces puces sont déjà à un niveau de pile différent et sont implémentées dans RTMP ou WebRTC.  SRT partage également l'encodage du flux multimédia et des statistiques, ce qui ne permet pas au codec de garder ces informations aussi proches que possible les unes des autres.  Une telle décision peut nuire à la capacité d'adapter la vidéo transférée à l'évolution de la bande passante du réseau. <br><br>  Les protocoles basés sur des fichiers, tels que HLS, codent plusieurs flux et sélectionnent ceux nécessaires pour s'adapter à la largeur du canal.  WebRTC vous permet d'adapter l'encodage de chaque trame en temps réel: c'est beaucoup plus rapide que de sélectionner un autre flux en HLS, ce qui nécessite de compter jusqu'à 10 secondes de données déjà envoyées. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr421121/">https://habr.com/ru/post/fr421121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr421109/index.html">(Mise à jour) Intel interdit la publication de références pour les mises à jour du microcode</a></li>
<li><a href="../fr421111/index.html">Système de conception à Figma. Un regard sur l'interface à travers les composants</a></li>
<li><a href="../fr421113/index.html">Présentation de DJI Mavic 2 Pro / Zoom</a></li>
<li><a href="../fr421115/index.html">Contexte dans une application Android</a></li>
<li><a href="../fr421119/index.html">Développement SmartTV de râteau sous-marin</a></li>
<li><a href="../fr421123/index.html">Résumé des événements informatiques de septembre</a></li>
<li><a href="../fr421125/index.html">Nous segmentons 600 millions d'utilisateurs en temps réel chaque jour</a></li>
<li><a href="../fr421127/index.html">Webinaires Skillbox Friday: Design & Developers</a></li>
<li><a href="../fr421129/index.html">Comment réduire la révision du code de deux semaines à plusieurs heures. L'expérience de l'équipe Yandex.Market</a></li>
<li><a href="../fr421131/index.html">Vulnérabilité critique des serveurs 1Cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>