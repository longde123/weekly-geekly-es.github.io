<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÜïÔ∏è üìò ü§æüèº Leistungsoptimierung f√ºr .NET (C #) -Anwendungen üôã üí™üèø üé≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt viele Artikel mit einer √§hnlichen √úberschrift, daher werde ich versuchen, allt√§gliche Themen zu vermeiden. Ich hoffe, dass auch ein sehr erfah...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Leistungsoptimierung f√ºr .NET (C #) -Anwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466931/"><img src="https://habrastorage.org/webt/gs/yu/jc/gsyujcvzccxootdcxkywpaida0k.jpeg" alt="Bild"><br><br>  Es gibt viele Artikel mit einer √§hnlichen √úberschrift, daher werde ich versuchen, allt√§gliche Themen zu vermeiden.  Ich hoffe, dass auch ein sehr erfahrener Entwickler hier etwas N√ºtzliches findet.  In diesem Artikel werden nur einfache Optimierungsmechanismen und -ans√§tze behandelt, mit denen sie mit minimalem Aufwand angewendet werden k√∂nnen.  Und diese √Ñnderungen erh√∂hen nicht die Entropie Ihres Codes.  In diesem Artikel wird nicht darauf geachtet, was und wann optimiert werden soll. In diesem Artikel geht es mehr um den Ansatz zum Schreiben von Code im Allgemeinen. <br><a name="habracut"></a><br><h4>  1. ToArray vs ToList </h4><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItems</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _storage.Items.Where(...).ToList(); }</code> </pre> <br>  Zustimmen, ein sehr typischer Code f√ºr Industrieprojekte.  Aber was ist los mit ihm?  Die IEnumerable-Schnittstelle gibt eine Sammlung zur√ºck, die Sie "durchgehen" k√∂nnen. Diese Schnittstelle bedeutet nicht, dass wir Elemente hinzuf√ºgen / entfernen k√∂nnen.  Dementsprechend muss der LINQ-Ausdruck nicht durch Umwandeln in eine Liste (ToList) beendet werden.  In diesem Fall ist das Casting in Array (ToArray) vorzuziehen.  Da List ein Wrapper √ºber Array ist und alle zus√§tzlichen Funktionen dieses Wrappers zur Verf√ºgung stehen, haben wir die Schnittstelle abgeschnitten.  Ein Array verbraucht weniger Speicher und der Zugriff auf seine Werte ist schneller.  Warum also mehr bezahlen?  Einerseits ist diese Optimierung nicht signifikant, da sie "Optimierung bei Spielen" sagt, aber dies ist nicht ganz richtig.  Tatsache ist, dass in einer typischen Anwendung, in der Dienste Modelle f√ºr die Pr√§sentationsschicht zur√ºckgeben, eine Vielzahl solcher ToList-Aufrufe vorhanden sein kann.  In dem oben beschriebenen Beispiel wird die IEnumerable-Schnittstelle nur zur Veranschaulichung eingef√ºhrt.  Dieser Ansatz ist f√ºr alle F√§lle relevant, in denen Sie eine Sammlung zur√ºckgeben m√ºssen, die Sie sp√§ter nicht mehr √§ndern werden. <br><br>  Ich sehe einen Kommentar voraus, dass Array und Liste im Fall eines Multithread-Zugriffs auf die Sammlung nicht gleichwertig funktionieren.  Das ist tats√§chlich so.  Wenn Sie als Entwickler jedoch die M√∂glichkeit eines Multithread-Zugriffs auf eine solche Sammlung mit der M√∂glichkeit einer √Ñnderung in Betracht ziehen, sind mit hoher Wahrscheinlichkeit weder Array noch List f√ºr Sie geeignet. <br><br><h4>  2. Der Parameter ‚ÄûDateipfad‚Äú ist nicht immer die beste Wahl f√ºr Ihre Methode </h4><br>  Vermeiden Sie bei der Entwicklung einer API Methodensignaturen, die einen Dateipfad als Eingabe erhalten (f√ºr die sp√§tere Verarbeitung durch Ihre Methode).  Stellen Sie stattdessen die M√∂glichkeit bereit, ein Array von Bytes an die Eingabe oder <b>als letzten Ausweg f√ºr einen</b> Stream zu √ºbergeben.  Tatsache ist, dass Ihre Methode im Laufe der Zeit nicht nur auf eine Datei von der Festplatte angewendet werden kann, sondern auch auf eine Datei, die √ºber das Netzwerk √ºbertragen wird, auf eine Datei aus einem Archiv, auf eine Datei aus einer Datenbank, auf eine Datei, deren Inhalt dynamisch im Speicher generiert wird usw. Indem Sie eine Methode mit dem Eingabeparameter "Dateipfad" bereitstellen, verpflichten Sie den Benutzer Ihrer API, die Daten auf der Festplatte zu speichern, bevor Sie sie erneut lesen.  Diese bedeutungslose Operation wirkt sich kritisch auf die Leistung aus.  Eine Fahrt ist eine extrem langsame Sache.  Der Einfachheit halber k√∂nnen Sie eine Methode mit einem Eingabeparameter "Pfad zu einer Datei" bereitstellen. Verwenden Sie jedoch im Inneren immer eine √∂ffentliche √ºberladene Methode mit einem Array von Bytes oder Streams an der Eingabe.  Es gibt einen ‚ÄûMarker‚Äú, mit dem Sie zus√§tzliche Schreib- / <code>Path.GetTempPath()</code> Datentr√§ger finden k√∂nnen. Versuchen Sie, diese in Ihrem Projekt mithilfe der Standardmethoden zu finden: <code>Path.GetTempPath()</code> und <code>Path.GetRandomFileName()</code> (von System.IO).  Mit hoher Wahrscheinlichkeit werden Sie eine Problemumgehung f√ºr das oben genannte Problem oder √§hnliches finden. <br><br>  Ein aufmerksamer und erfahrener Leser wird feststellen, dass das Schreiben auf die Festplatte in einigen F√§llen im Gegenteil die Leistung verbessern kann, beispielsweise wenn es sich um sehr gro√üe Dateien handelt.  Dies ist wahr, es muss ber√ºcksichtigt werden, aber ich gehe davon aus, dass dies eine sehr seltene Situation mit einer bestimmten Implementierung ist. <br><br><h4>  3. Vermeiden Sie die Verwendung von Threads als Parameter und das R√ºckgabeergebnis Ihrer Methoden </h4><br>  Was ist das Problem hier ... Wenn wir einen Stream von einer ‚ÄûBlack Box‚Äú erhalten, m√ºssen wir dessen Zustand ber√ºcksichtigen.  Das hei√üt,  Ist der Stream offen?  Wo ist der Lese- / Schreibmarker?  Kann sich sein Status unabh√§ngig von unserem Code √§ndern?  Wenn ein Stream als Basisklasse von Stream deklariert ist, haben wir nicht einmal Informationen dar√ºber, welche Operationen darauf verf√ºgbar sind.  All dies wird durch zus√§tzliche √úberpr√ºfungen gel√∂st, und dies ist zus√§tzlicher Code und zus√§tzliche Kosten.  Au√üerdem stie√ü ich wiederholt auf eine Situation, in der der Entwickler beim Empfang von Streams von einer ‚Äûobskuren‚Äú Methode lieber auf Nummer sicher ging und Daten von diesem auf einen vollst√§ndig kontrollierten neuen lokalen MemoryStream ‚Äû√ºbertrug‚Äú.  Der Quelldatenstrom k√∂nnte jedoch ziemlich sicher sein.  Vielleicht war sogar dies bereits freundlicherweise f√ºr das Lesen von MemoryStream vorbereitet.  Manchmal kann es den Punkt der Absurdit√§t erreichen - innerhalb einer Methode wird ein Array von Bytes in einen MemoryStream eingef√ºgt, und dieser MemoryStream wird als Ergebnis einer als Basis-Stream deklarierten Methode zur√ºckgegeben.  Drau√üen verwandelt sich dieser Stream in einen neuen MemoryStream, und dann gibt ToArray () ein Array von Bytes zur√ºck, das wir urspr√ºnglich hatten.  Genauer gesagt wird es das n√§chste Exemplar sein.  Die Ironie ist, dass innerhalb und au√üerhalb unserer Methode der Code v√∂llig korrekt ist.  Meiner Meinung nach ist dieses Beispiel nicht verr√ºckt, sondern wurde irgendwo im Handelsgesetzbuch gefunden. <br><br>  Wenn Sie in der Lage sind, "saubere" Daten zu senden / zu empfangen, verwenden Sie daher keine Streams - erstellen Sie keine Traps f√ºr diejenigen, die sie verwenden werden.  Wenn Ihre Anwendung bereits √ºber √úbertragungs- / R√ºckgabestreams verf√ºgt, analysieren Sie deren Verwendung auf der Grundlage des Vorstehenden. <br><br><h4>  4. Vererbung von Aufz√§hlungen </h4><br>  Diese Optimierung ist allt√§glich, jeder wei√ü es, auch Studenten.  Aber meiner Erfahrung nach wird es √§u√üerst selten verwendet.  Enum erbt also standardm√§√üig von int.  Es kann jedoch von einem Byte geerbt werden, das 256 Werte (oder 8 "markierbare" Werte) enth√§lt.  Was fast immer die Funktionalit√§t der "mittleren" Aufz√§hlung abdeckt.  Eine minimale √Ñnderung des Codes und aller Werte Ihrer Aufz√§hlung beansprucht f√ºr immer weniger Speicher.  Unten sehen Sie eine Abbildung eines Benchmarks zum F√ºllen einer Sammlung mit Enum-Werten, die von int und byte geerbt wurden. <br><br><img src="https://habrastorage.org/webt/e-/ir/q2/e-irq2g_r9iorxjbadfqyxuc9ei.png"><br><br><div class="spoiler">  <b class="spoiler_title">Benchmark-Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CollectEnums</span></span> { [Params(<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-number"><span class="hljs-number">100000</span></span>, <span class="hljs-number"><span class="hljs-number">1000000</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N; [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> EnumFromInt[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnumOfInt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { EnumFromInt[] results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnumFromInt[N]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) { results[i] = EnumFromInt.Value1; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> results; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> EnumFromByte[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnumOfByte</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { EnumFromByte[] results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnumFromByte[N]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) { results[i] = EnumFromByte.Value1; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> results; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EnumFromInt { Value1, Value2 } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EnumFromByte: <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> { Value1, Value2 }</code> </pre> <br></div></div><br><h4>  5. Noch ein paar Worte zu den Klassen Array und List </h4><br>  Nach der Logik ist das Iterieren √ºber ein Array immer effizienter als das Iterieren √ºber ein "Blatt", da ein "Blatt" ein Wrapper √ºber ein Array ist.  Nach der Logik ist "for" immer schneller als "foreach", da "foreach" viele der Aktionen ausf√ºhrt, die f√ºr die Implementierung der IEnumerable-Schnittstelle erforderlich sind.  Hier ist alles logisch, aber falsch!  Werfen wir einen Blick auf die Benchmark-Ergebnisse: <br><br><img src="https://habrastorage.org/webt/p7/7z/ih/p77zihj1drhzs84wcik9vtyq4qg.png"><br><br><div class="spoiler">  <b class="spoiler_title">Benchmark-Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IterationBenchmark</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _list; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] _array; [Params(<span class="hljs-number"><span class="hljs-number">100000</span></span>, <span class="hljs-number"><span class="hljs-number">10000000</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N; [GlobalSetup] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MIN = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MAX = <span class="hljs-number"><span class="hljs-number">10</span></span>; Random rnd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); _list = Enumerable.Repeat(<span class="hljs-number"><span class="hljs-number">0</span></span>, N).Select(i =&gt; rnd.Next(MIN, MAX)).ToList(); _array = _list.ToArray(); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _list.Count; i++) { total += _list[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForeachList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _list) { total += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForeachArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _array) { total += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _array.Length; i++) { total += _array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } }</code> </pre> <br></div></div><br>  Tatsache ist, dass "foreach" f√ºr die Iteration √ºber ein Array keine IEnumerable-Implementierung verwendet.  In diesem speziellen Fall wird die am besten optimierte Iteration nach Index durchgef√ºhrt, ohne auf Grenzen au√üerhalb des Arrays zu pr√ºfen, da das Konstrukt "foreach" nicht mit Indizes arbeitet, sodass der Entwickler nicht die M√∂glichkeit hat, den Code "durcheinander zu bringen".  Dies ist die Ausnahme von der Regel.  Wenn Sie in einem kritischen Abschnitt des Codes aus Optimierungsgr√ºnden die Verwendung von "foreach" durch "for" ersetzt haben, haben Sie sich selbst in den Fu√ü geschossen.  Bitte beachten Sie, dass dies <b>nur f√ºr Arrays</b> relevant ist.  Es gibt mehrere Zweige in StackOverflow, in denen diese Funktion erl√§utert wird. <br><br><h4>  6. Ist das Durchsuchen einer Hash-Tabelle immer gerechtfertigt? </h4><br>  Jeder wei√ü, dass Hash-Tabellen f√ºr die Suche sehr effektiv sind.  Aber sie vergessen oft, dass der Preis f√ºr eine schnelle Suche eine langsame Erg√§nzung der Hash-Tabelle ist.  Was folgt daraus?  Damit die Verwendung der Hash-Tabelle gerechtfertigt ist, muss die Anzahl der Hash-Tabellenelemente mindestens 8 (ungef√§hr) betragen.  Und so war die Anzahl der Suchoperationen mindestens eine Gr√∂√üenordnung gr√∂√üer als die Anzahl der Additionsoperationen.  Verwenden Sie andernfalls eine einfachere Sammlung.  Die Qualit√§t der Hash-Funktion nimmt eigene Anpassungen an der Effizienz vor, die Bedeutung √§ndert sich jedoch nicht.  In meiner Praxis gab es einen Fall, in dem der gr√∂√üte Engpass im geladenen Code darin bestand, die Dictionary.Add () -Methode aufzurufen.  Der Schl√ºssel war eine normale Saite von kurzer L√§nge.  Sich daran zu erinnern und wurde ein Ausl√∂ser f√ºr das Schreiben dieses Absatzes.  Zur Veranschaulichung ein Beispiel f√ºr sehr schlechten Code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numberStr</span></span></span><span class="hljs-function">)</span></span> { Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; dictionary = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; { {<span class="hljs-string"><span class="hljs-string">"One"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Two"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Three"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} }; dictionary.TryGetValue(numberStr, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  Vielleicht passiert etwas √Ñhnliches in Ihrem Projekt? <br><br><h4>  7. Einbettungsmethoden </h4><br>  Der Code wird aus zwei Gr√ºnden am h√§ufigsten in Methoden unterteilt.  Stellen Sie die Wiederverwendung und Zerlegung von Code sicher, wenn eine Aufgabe in mehrere Unteraufgaben unterteilt ist.  F√ºr eine Person ist es einfacher.  Inlining ist der umgekehrte Zersetzungsprozess, d.h.  Der Methodencode ist an der Stelle eingebettet, an der die Methode aufgerufen werden soll. Infolgedessen speichern wir den Aufrufstapel und √ºbergeben Parameter.  Ich empfehle in keiner Weise, alles in eine Methode zu schieben.  Aber jene Methoden, die wir theoretisch "inline" machen k√∂nnten, k√∂nnen mit dem entsprechenden Attribut markiert werden: <br><br><pre> <code class="plaintext hljs">[MethodImpl(MethodImplOptions.AggressiveInlining)]</code> </pre> <br>  Dieses Attribut teilt dem System mit, dass diese Methode eingebettet werden kann.  Dies bedeutet nicht, dass die mit diesem Attribut gekennzeichnete Methode unbedingt integriert sein muss.  Beispielsweise ist es nicht m√∂glich, rekursive oder virtuelle Methoden einzubetten.  Es ist auch erw√§hnenswert, dass der Einbettungsmechanismus √§u√üerst ‚Äûempfindlich‚Äú ist.  Es gibt viele andere Gr√ºnde, warum das System die Einbettung Ihrer Methode verweigert.  Das Microsoft-Team, das an .NET Core arbeitet, verwendet dieses Attribut jedoch aktiv.  Der Quellcode f√ºr .NET Core enth√§lt viele Beispiele f√ºr seine Verwendung. <br><br><h4>  8. Gesch√§tzte Kapazit√§t </h4><br>  Ich (und ich hoffe, die meisten Entwickler auch) haben einen Reflex entwickelt: Ich habe die Sammlung initialisiert - ich habe dar√ºber nachgedacht, ob es m√∂glich ist, die Kapazit√§t daf√ºr festzulegen.  Die genaue Anzahl der Sammlungselemente ist jedoch nicht immer im Voraus bekannt.  Dies ist jedoch kein Grund, diesen Parameter zu ignorieren.  Wenn Sie beispielsweise davon ausgehen, wie viele Elemente in Ihrer Sammlung enthalten sein werden, nehmen Sie an, dass die Anzahl der Elemente verschwommen ist. Dies ist eine Gelegenheit, die Kapazit√§t auf 1000 zu setzen. Eine kleine Theorie, z. B. f√ºr Liste standardm√§√üig, Kapazit√§t = 16, also nur Bei Erreichen von 1000 erstellt das System 1008 (16 + 32 + 64 + 128 + 256 + 512) zus√§tzliche Kopien der Elemente und erstellt 7 tempor√§re Arrays, die dem n√§chsten GC-Aufruf ausgeliefert sind.  Das hei√üt,  all diese Arbeit wird verschwendet.  Als Kapazit√§t verbietet niemand die Verwendung der Formel.  Wenn die Gr√∂√üe Ihrer Sammlung auf ein Drittel der anderen Sammlung gesch√§tzt wird, k√∂nnen Sie die Kapazit√§t auf otherCollection.Count / 3 setzen. Wenn Sie die Kapazit√§t festlegen, sollten Sie den Bereich der m√∂glichen Gr√∂√üe der Sammlung und die Verteilung ihres Werts verstehen.  Es besteht immer die M√∂glichkeit eines Schadens, aber bei richtiger Verwendung bringt Ihnen eine gesch√§tzte Kapazit√§t einen guten Gewinn. <br><br><h4>  9. Geben Sie immer Ihren Code an. </h4><br>  Verwenden Sie aktiv (auf den ersten Blick optional) C # -Schl√ºsselw√∂rter wie statisch, const, schreibgesch√ºtzt, versiegelt, abstrakt usw.  Nat√ºrlich, wo sie Sinn machen.  Und hier ist die Leistung?  Tatsache ist, dass der Code, den er generieren kann, umso optimaler ist, je detaillierter Sie dem Compiler Ihr System beschreiben.  Ein aufmerksamer und erfahrener Leser kann feststellen, dass beispielsweise das versiegelte Schl√ºsselwort keinen Einfluss auf die Leistung hat.  Das stimmt, aber in zuk√ºnftigen Versionen kann sich alles √§ndern.  Geben Sie dem Compiler und der virtuellen Maschine eine Chance!  Holen Sie sich einen Bonus, der viele Fehler bei der missbr√§uchlichen Verwendung Ihres Codes in der Kompilierungsphase identifiziert.  Allgemeine Regel: Je klarer das System beschrieben wird, desto optimaler ist das Ergebnis.  Anscheinend auch mit Menschen. <br><br><div class="spoiler">  <b class="spoiler_title">Die wahre Geschichte best√§tigt diese Regel, aber wenn Sie Faulheit lesen, k√∂nnen Sie √ºberspringen</b> <div class="spoiler_text">  Eines Nachts, als er sich mit seinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Hobbyprojekt besch√§ftigte</a> , stellte er sich die Aufgabe, die Leistung eines Codeabschnitts √ºber ein bestimmtes Niveau zu steigern.  Aber diese Seite war kurz und es gab nur wenige M√∂glichkeiten, was man damit machen sollte.  In der Dokumentation habe ich festgestellt, dass ab Version C # 7.2 das Schl√ºsselwort "readonly" f√ºr Strukturen verwendet werden kann.  Und in meinem Fall wurden unver√§nderliche Strukturen verwendet, indem ich ein einzelnes Wort "schreibgesch√ºtzt" hinzuf√ºgte. Ich bekam, was ich wollte, sogar mit einem Rand!  Das System, das wusste, dass meine Strukturen nicht ge√§ndert werden sollen, konnte besseren Code f√ºr meinen Fall generieren. <br></div></div><br><h4>  10. Verwenden Sie nach M√∂glichkeit eine Version von .NET f√ºr alle L√∂sungsprojekte </h4><br>  Sie sollten sich bem√ºhen, sicherzustellen, dass alle Assemblys in Ihrer Anwendung zur selben Version von .NET geh√∂ren.  Dies gilt sowohl f√ºr NuGet-Pakete (bearbeitet in packages.config / json) als auch f√ºr Ihre eigenen Assemblys (bearbeitet in den Projekteigenschaften).  Dies spart RAM und beschleunigt den "Kaltstart", da im Speicher Ihrer Anwendung keine Kopien derselben Bibliotheken f√ºr verschiedene Versionen von .NET vorhanden sind.  Es ist anzumerken, dass nicht in allen F√§llen verschiedene Versionen von .NET Kopien im Speicher generieren.  Angenommen, eine Anwendung, die auf derselben Version von .NET basiert, ist immer besser.  Dadurch werden auch eine Reihe potenzieller Probleme beseitigt, die au√üerhalb des Geltungsbereichs dieses Artikels liegen.  Die Konsolidierung von Versionen aller von Ihnen verwendeten NuGet-Pakete tr√§gt auch zur Verbesserung der Leistung Ihrer Anwendung bei. <br><br><h4>  Einige n√ºtzliche Werkzeuge </h4><br>  <b>ILSpy</b> ist ein kostenloses Tool, mit dem Sie den wiederhergestellten Assembly-Quellcode anzeigen k√∂nnen.  Wenn ich eine Frage dazu habe, welcher .NET-Mechanismus effizienter ist, √∂ffne ich zuerst ILSpy (und nicht Google oder StackOverflow) und sehe dort bereits, wie es implementiert ist.  Um beispielsweise herauszufinden, was hinsichtlich der Leistung f√ºr den Empfang von Daten √ºber HTTP, die HttpWebRequest- oder die WebClient-Klasse am besten verwendet wird, sehen Sie sich einfach deren Implementierung √ºber ILSpy an.  In diesem speziellen Fall ist WebClient ein Wrapper √ºber HttpWebRequest. Die Antwort liegt auf der Hand.  .NET-Quellcodes sind keine Angst wert, sie werden von denselben normalen Programmierern geschrieben. <br><br>  <b>BenchmarkDotNet</b> ist eine kostenlose Bibliothek von Benchmarks.  Es gibt eine einfache und intuitive StopWatch (von System.Diagnostics).  Aber manchmal reicht es nicht.  Da in guter Weise nicht ein einziges Ergebnis, sondern der Durchschnitt mehrerer Vergleiche ber√ºcksichtigt werden muss, ist es besser, deren Median zu vergleichen, um den Einfluss des Betriebssystems zu minimieren.  Au√üerdem m√ºssen Sie den "Kaltstart" und die Menge des zugewiesenen Speichers ber√ºcksichtigen.  F√ºr solch komplexe Tests wurde BenchmarkDotNet erstellt.  Diese Bibliothek verwenden .NET Core-Entwickler in offiziellen Tests.  Die Bibliothek ist einfach zu bedienen, aber wenn die Autoren diesen Beitrag pl√∂tzlich lesen, geben Sie bitte eine bequemere Gelegenheit, die Struktur der Ergebnistabelle zu beeinflussen. <br><br>  <b>U2U Consult Performance Analyzers</b> ist ein kostenloses Plug-In f√ºr Visual Studio, das Tipps zur Verbesserung des Codes in Bezug auf die Leistung bietet.  100% verlassen sich auf den Rat dieses Analysators lohnt sich nicht.  Da ich auf eine Situation gesto√üen bin, in der mich ein Ratschlag ein wenig √ºberrascht hat und sich nach einer detaillierten Analyse wirklich als falsch herausgestellt hat.  Leider geht dieses Beispiel verloren, nehmen Sie also ein Wort.  Wenn Sie es jedoch nachdenklich verwenden, ist es ein sehr n√ºtzliches Werkzeug.  Zum Beispiel wird er vorschlagen, dass es anstelle von <code>myStr.Replace("*", "-")</code> effizienter ist, <code>myStr.Replace('*', '-')</code> .  Und die beiden Where-Ausdr√ºcke in LINQ lassen sich besser zu einem kombinieren.  Dies sind alles ‚ÄûOptimierungen f√ºr √úbereinstimmungen‚Äú, aber sie sind einfach anzuwenden und f√ºhren nicht zu einer Erh√∂hung des Codes / der Komplexit√§t. <br><br><h4>  Abschlie√üend </h4><br>  Wenn jede zehnte Person, die den Artikel liest, die oben genannten Ans√§tze auf ihr aktuelles Projekt (oder einen kritischen Teil davon) anwendet und diese Ans√§tze auch in Zukunft einh√§lt, k√∂nnen wir gemeinsam den gesamten Wald retten!  Wald ???  Das hei√üt,  Die eingesparten Ressourcen von Computersystemen in Form von Strom aus der Verbrennung von Holz bleiben ungenutzt.  In diesem Fall ist der ‚ÄûWald‚Äú nur eine Art √Ñquivalent.  Wahrscheinlich kam eine seltsame Schlussfolgerung heraus, aber ich hoffe, Sie sind von dem Gedanken inspiriert. <br><br><h4>  PS Update basierend auf Post-Kommentaren </h4><br>  Der Vorteil von ToArray gegen√ºber ToList ist f√ºr .NET Core relevant.  Wenn Sie jedoch das alte .NET Framework verwenden, ist ToList wahrscheinlich f√ºr Sie vorzuziehen.  Das Problem ist, dass in .NET Framework der ToArray-Aufruf selbst erheblich langsamer ist als der ToList-Aufruf.  Und diese Verluste k√∂nnen m√∂glicherweise nicht durch schnellere Zugriffe auf Elemente und weniger Array-Speicher ausgeglichen werden.  Im Allgemeinen stellte sich dieses Problem als komplizierter heraus, da verschiedene Klassen, die IEnumerable implementieren, unterschiedliche Implementierungen von ToArray und ToList mit unterschiedlichen Effizienzstufen aufweisen k√∂nnen. <br><br>  Wenn die vom Byte geerbte Aufz√§hlung als Mitglied einer Klasse (Struktur) und nicht separat verwendet wird, wird m√∂glicherweise kein Speicher gespart.  Aufgrund der Ausrichtung des belegten Speichers aller Mitglieder der Klasse (Struktur).  Dieser Punkt fehlt im Artikel.  Trotzdem ist der potenzielle Gewinn besser als sein Fehlen, da neben dem belegten Speicher auch Aufz√§hlungen verwendet werden.  Daher ist Absatz 4 immer noch relevant, jedoch mit diesem wichtigen Vorbehalt. <br><br>  Vielen Dank an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">KvanTTT</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">epetrukhin</a> f√ºr konstruktive Kommentare zu diesen Themen. <br><br>  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Taritsyn</a> bemerkte, besteht in der JIT-Kompilierungsphase noch eine Optimierung f√ºr das Schl√ºsselwort "versiegelt".  Dies best√§tigt jedoch nur alle Thesen des 9. Absatzes. <br><br>  Es scheint, dass alle konstruktiven Kommentare ber√ºcksichtigt wurden.  Ich bin sehr zufrieden mit diesen Kommentaren.  Da ich selbst als Autor ein Feedback erhalten habe und auch etwas Neues f√ºr mich gelernt habe. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466931/">https://habr.com/ru/post/de466931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466917/index.html">Wenn der HTTP-Standard nicht ausreicht. Mikronaut begehen</a></li>
<li><a href="../de466921/index.html">5 Probleme eines Serviceunternehmens und deren L√∂sung mithilfe der Automatisierungsplattform</a></li>
<li><a href="../de466923/index.html">Wie IT-Profis in einer ausl√§ndischen Bank die Herkunft von Geldern nachweisen k√∂nnen</a></li>
<li><a href="../de466925/index.html">Wie man Hi-CPU VDS f√ºr Bitrix ausf√ºhrt, Papageien zerstreut und nicht pleite geht</a></li>
<li><a href="../de466929/index.html">Aktualisierungstoken hinzuf√ºgen</a></li>
<li><a href="../de466933/index.html">Wie man Freunde Industrie und Big Data macht</a></li>
<li><a href="../de466937/index.html">Wie wir die Allrussische Online-Olympiade in Englisch, Mathematik und Informatik durchf√ºhren</a></li>
<li><a href="../de466941/index.html">Warum liest Windows eine Datei hunderttausend Mal, um ein Men√º zu √∂ffnen?</a></li>
<li><a href="../de466949/index.html">Perspektiven f√ºr Quantennetzwerke: Wer engagiert sich daf√ºr und warum?</a></li>
<li><a href="../de466955/index.html">R√§tsel des Lebenslaufs. Teil 3. Der Schleier der Geheimnisse entfernt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>