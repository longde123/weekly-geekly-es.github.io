<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍙 🤲🏽 💇🏿 "20.000 IOPS per node adalah kinerja yang baik dengan latensi 5 ms." Untuk OLTP - no 🍀 📢 👼🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alasan penulisan artikel ini adalah ulasan yang sangat layak tentang Bagaimana kami menguji VMware vSAN ... CROC. Ulasan ini layak, tetapi memiliki fr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"20.000 IOPS per node adalah kinerja yang baik dengan latensi 5 ms." Untuk OLTP - no</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414269/"><p><img src="https://habrastorage.org/webt/fq/yy/2k/fqyy2kbw4iqx5ikqy7v-o60jfce.jpeg" alt="KDPV"></p><br><p>  Alasan penulisan artikel ini adalah ulasan yang sangat layak tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana kami menguji VMware vSAN ...</a> CROC.  Ulasan ini layak, tetapi memiliki frasa yang telah saya perjuangkan selama lebih dari satu dekade.  Administrator penyimpanan, virtualizer, dan integrator berulang-ulang: "Penundaan 5 ms adalah indikator yang sangat baik."  Bahkan angka 5 ms selama sepuluh tahun tidak berubah.  Saya mendengar ini langsung dari admin yang sangat dihormati tidak kurang dari selusin kali.  Dari yang kurang dihormati - lusinan, dan berapa kali saya membaca di Internet ... Tidak, tidak, tidak.  Untuk beban OLTP 5 ms, terutama karena biasanya diukur, ini gagal epik.  Saya harus menjelaskan alasan ini berkali-kali, kali ini saya memutuskan untuk mengumpulkan pikiran saya dalam bentuk yang dapat digunakan kembali. </p><br><p>  Saya harus segera mengatakan bahwa tidak ada kesalahan seperti itu dalam artikel yang disebutkan di atas, tetapi frasa tersebut berfungsi sebagai pemicu. </p><a name="habracut"></a><br><h2 id="tipichnoe-nachalo">  Mulai yang khas </h2><br><p>  Segala sesuatu yang dijelaskan dalam artikel ini berlaku untuk DBMS umum yang digunakan untuk OLTP bisnis biasa.  Sebagian besar dari semua saya memiliki pengalaman dengan MS SQL Server, tetapi, setidaknya untuk PostgeSQL, Oracle dan Sybase, banyak poin dan kesimpulan juga akan tetap benar. </p><br><p>  Kinerja DBMS biasanya tidak senang dengan semua orang.  Jika ada DBMS dalam sistem besar - dan tiba-tiba hampir selalu ada - maka DBMS ini menjadi hambatan.  Nah, atau itu akan segera menjadi hambatan jika Anda mulai mengoptimalkan yang lainnya.  Jadi, pelanggan datang dan berkata dengan suara manusia: "Tolong! Simpan! Mereka membayar $ NNNNNNNNN untuk server dan penyimpanan, tetapi kecepatannya tidak meningkat! Oh, dan administrator mengatur dan vendor berkonsultasi, tetapi masih tidak bergerak."  Jika pengembang sistem sesuai dengan definisi Lavrov (kita dapat melakukannya tanpa penawaran harga yang tepat), dan spesialis operasi dan pemeliharaan "berjuang dengan insiden dengan me-reboot server", maka masalahnya sering kali sederhana dan bersahaja: tidak ada indeks, pertanyaan bengkok, kesalahan fatal konfigurasi (tentang dokumentasi yang dicetak tebal) ia mengatakan <strong>"Anda tidak bisa melakukan ini !!!"</strong> ), kunci berlebihan, kebuntuan dan omong kosong sederhana dan jelas lainnya.  Ada banyak kasus seperti itu, sebagian besar, tetapi tidak semua.  Jika sistem, dalam kompleksitas atau beban, telah melewati batas tak terlihat, maka ia akan mati karena masalah ini atau naik ke tingkat berikutnya. </p><br><div class="spoiler">  <b class="spoiler_title">Tips Diagnostik SQL Server</b> <div class="spoiler_text"><p> IMHO, alat terbaik saat ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SQL Server First Responder Kit</a> , yang dipromosikan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Brent Ozar</a> .  Alat ini berkembang sangat aktif.  Masih ada satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">set yang</a> layak dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Glenn Berry</a> , dia juga tidak meninggalkan proyeknya.  Kedua set itu indah dengan caranya sendiri, membaca komentar dan pertanyaan untuk pertama kalinya membuka banyak hal baru.  Saya sendiri selalu mulai mencari-cari dengan <code>sys.dm_os_waitsats</code> , sekilas melihat log Kesalahan dan mencari tahu apakah ada setidaknya beberapa sistem cadangan yang berfungsi. </p></div></div><br><p>  Pada tingkat ini, server tidak lagi di bawah tabel direktur, disk tidak lagi di dalam server, tetapi dalam sistem penyimpanan, pengembang tahu tentang indeks, dan administrator sudah tahu PowerShell, dan manajer TI mulai mengatakan kata-kata pintar seperti SLA dan RPO / RTO.  Situasi menarik muncul pada level ini: </p><br><ul><li>  DBMS adalah hambatan. </li><li>  Server tampaknya mencukupi dalam segala hal. </li><li>  DBMS dapat ditingkatkan lebih lanjut secara programatik, tetapi sulit (beralih ke lisensi yang lebih mahal atau beralih ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"zona merah kurva Shipilev"</a> untuk optimisasi) </li><li>  Sistem disk dibeli mahal dan, tampaknya, bahkan entah bagaimana dikonfigurasi. </li></ul><br><p>  Tapi tidak.  Buaya tidak ditangkap, kelapa tidak tumbuh, dan kinerja sistemnya sama atau lebih rendah dari pada server lama.  Saya mencari di <code>sys.dm_os_waitsats</code> dan melihat <code>WRITELOG</code> , <code>PAGEIOLATCH_SH</code> dan <code>PAGEIOLATCH_EX</code> di atas, waktu tunggu rata-rata adalah 5+ ms.  Biasanya, cho: "Hei, admin dan DBA, di sini Anda memiliki sistem disk - bottleneck" dan di sini dimulai lagu lama sekitar 5 ms: </p><br><ul><li>  Kami memiliki 5 ms untuk SLA </li><li>  Ya, kami memiliki resimen 20.000 IOPS </li><li>  Vendor memberi tahu kami bahwa semua file database bisa berada di satu partisi </li><li>  Kami memiliki virtualisasi dan hyperconvergence dan kami tidak dapat mengalokasikan disk terpisah di bawah basis data </li><li>  Menurut data kami, pemanfaatan server 5% </li><li>  Semuanya dikonfigurasi sesuai dengan rekomendasi </li><li>  Basis data Anda tidak membutuhkan banyak kinerja, ia tidak melakukan lebih dari 300 IOPS (dan kami memiliki rak untuk 20.000 IOPS) </li></ul><br><p>  By the way, semua hal di atas, tidak hanya tentang server "mereka", tetapi juga tentang layanan cloud dan virtualisasi.  Ada banyak spesifikasinya sendiri, tetapi gambaran klinis tipikal hampir sama: basis data yang dioptimalkan secara moderat, staf pengembangan dan pemeliharaan yang cerdas, ada cadangan untuk prosesor dan memori, "pembuangan" dari investasi lebih lanjut hampir nol. </p><br><p>  Jadi disini.  Seluruh lagu ini tentang "5 ms" adalah omong kosong dan omong kosong.  Jika Anda sendiri mengatakan ini, baca artikel ini.  Dan jika mereka mengatakan ini kepada Anda, siapkan argumen.  Sebelumnya, ketika saya mendengar kata-kata ini, saya marah, tetapi saya tidak lagi marah.  Saya, seperti pot dengan petunia dari Hitchhiker's Guide to the Galaxy, hanya punya satu pemikiran: "Baiklah, sekali lagi ...". </p><br><h2 id="kto-vinovat">  Siapa yang harus disalahkan? </h2><br><p>  Mengapa database sangat lambat?  Nah, tampaknya server tipikal dengan 20-64 core pada frekuensi 2-3 GHz mampu melakukan 50-150 miliar operasi sederhana, dan tes basis data maksimum (sintetis) menunjukkan pada mesin tersebut hanya 10.000-50000 transaksi per detik.  Hai!  Nah ini dari satu juta hingga selusin kemungkinan jutaan transaksi per transaksi.  Ini tidak hanya banyak, sangat masuk akal. <br>  Biaya overhead seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ACID -</a> persyaratan untuk transaksi. </p><br><ul><li>  <strong>Sebuah</strong> keganjilan - baik seluruh transaksi selesai, atau keseluruhan tidak selesai. </li><li>  <strong>C</strong> onsistancy - di pintu masuk dan keluar transaksi, sistem berada dalam kondisi yang konsisten </li><li>  <strong>I</strong> solation - transaksi tidak melihat status perantara masing-masing </li><li>  <strong>D</strong> urability - jika transaksi telah berhasil diselesaikan (dilakukan), maka, terlepas dari keadaan, perubahan yang dibuat harus tetap dalam sistem. </li></ul><br><p>  Omong-omong, huruf-demi-huruf, persyaratan ini tidak dipenuhi hampir di mana saja dan tidak pernah, tetapi tidak pernah dalam sistem terdistribusi (teorema CAP mengganggu).  Untuk situasi kami, persyaratan "D" kemungkinan besar lebih mahal daripada yang lain, persyaratan ini disediakan oleh mekanisme kunci semua DBMSs OLTP yang umum: WAL, log write-ahead (PostgeSQL), juga merupakan log transaksi (SQL Server), alias log REDO (Oracle).  Ini dia - batu di leher produktivitas, dan itu adalah dasar dari transaksi Daya Tahan. </p><br><h3 id="chto-takoe-wal">  Apa itu WAL? </h3><br><p>  Mari kita lupakan sejenak tentang SSD modern, tentang sistem penyimpanan yang keren.  Misalkan kita memiliki server, ia memiliki satu atau lebih disk. <br>  Setiap transaksi, bahkan penyisipan satu catatan, setidaknya berpotensi, tetapi pada kenyataannya hampir selalu dan secara realistis tindakan non-atom.  Kita hampir selalu perlu mengubah tidak hanya halaman tempat catatan itu berada, tetapi juga halaman indeks, mungkin halaman layanan.  Selain itu, dalam transaksi yang sama halaman yang sama dapat berubah berkali-kali.  Plus, transaksi lain dapat dilakukan secara paralel dengan kami.  Selain itu - transaksi yang bertepatan waktu secara konstan "menarik" halaman yang sama.  Jika kita menunggu setiap halaman dituliskan ke disk sebelum melanjutkan, yang pada dasarnya diperlukan oleh Daya Tahan, kita harus menulis berkali-kali lebih banyak dan menunggu setiap rekaman diselesaikan pada media yang tidak mudah menguap.  Tidak ada cache, tidak ada pengaturan ulang operasi dalam antrian, jika tidak maka tidak akan ada integritas!  Selain itu, kita perlu mencatat data mana yang sudah pada transaksi tetap dan mana yang belum (dan data mana yang sebelumnya).  Untuk memahami - hard disk tunggal khas (HDD) dalam mode ini akan memberikan 50-100 IOPS dan ini telah konstan selama 20 tahun.  Satu transaksi kecil akan membutuhkan 5-10 operasi penulisan.  Ah, ya, untuk tahu apa yang harus direkam, Anda harus membacanya.  Bahkan sistem OLTP yang sangat-sangat bisa ditulis membaca 3 kali lebih banyak daripada yang mereka tulis.  Dengan demikian, biaya transaksi kami 20-40 IO, yang berarti 0,2-0,8 detik per disk. <br>  2 transaksi per detik.  Tidak cukup?  Mari mencoba menyebarkan disk?  Oh, tapi kita masih harus menunggu sampai yang sebelumnya direkam dan tidak ada paralelisme pada akhirnya.  Bagaimana menjadi  Dan mari kita mulai file log di mana kita akan secara berurutan merekam semua operasi penulisan dalam database dan tanda transaksi!  Pro: </p><br><ul><li>  Informasi tentang operasi bisa jauh lebih ringkas daripada merekam seluruh halaman (ukuran halaman khas adalah 8 KiB, informasi yang ditulis ke log sering 0,5-1 KiB). </li><li>  Alih-alih menulis tentang apakah transaksi dicatat atau tidak langsung ke halaman, ada cukup label tentang awal dan perbaikan transaksi dalam log. </li><li>  Halaman tidak dapat ditulis setelah setiap transaksi - beberapa kali lebih sedikit.  Proses membaca / menulis data sepenuhnya "tidak terikat" dari log. </li><li>  Hal utama.  Jika kita meletakkan jurnal kita pada disk terpisah dan menulis catatan secara berurutan, maka karena fakta bahwa Anda tidak perlu terus-menerus memposisikan ulang kepala disk, bahkan HDD rumah tangga dalam mode ini meremas hingga 1000 IOPS, mengingat bahwa transaksi kecil “biaya” 2-4 entri jurnal, maka Anda dapat memeras 200-400 TPS </li><li>  Dalam hal terjadi kegagalan, keadaan file data dapat dipulihkan dengan menggunakan log seperti itu, dan jika transaksi dibatalkan, perubahan dapat dibatalkan. </li></ul><br><p>  Log semacam itu disebut log write-ahead / log transaksi / REDO log. </p><br><p>  Hore!  Hebat!  Ada 2 transaksi per detik, menjadi 300 - meningkat 150 kali.  Dan berapa biayanya?  Ternyata, harganya signifikan: </p><br><ul><li>  Dalam semua DBMS umum, logging sangat konsisten.  Satu utas bertanggung jawab untuk menulis ke log.  Apakah Anda memiliki 100 prosesor?  Keren  Dan log masih akan menulis satu utas.  Kedalaman antrian tepat satu. </li><li>  Tetap - tidak ada cache OS, tidak ada permutasi operasi.  Persyaratan daya tahan tetap ada.  Operasi Write-through: sampai disk menjawab "Saya menulis, saya menulisnya langsung ke permukaan, bukan ke cache, pasti" DBMS tidak terus bekerja. </li><li>  Jika Anda meletakkan file log pada disk data, maka hampir semua manfaat perekaman berurutan akan hilang.  Selain itu - untuk selamanya, jika ada beberapa database di server, maka beberapa disk untuk majalah. </li><li>  Rollback transaksi (setidaknya dalam MS SQL Server) - baca log dan kembalikan status darinya.  Ini adalah sebanyak atau bahkan lebih operasi tulis karena ada operasi tulis dalam transaksi.  Kembalikan mahal! </li></ul><br><p>  Penjelasan ini sangat disederhanakan, "di jari."  Ini cukup untuk topik kita.  WAL adalah kunci, mekanisme fundamental untuk memastikan transaksionalitas, itu harus ditulisi, akses hanya berulir tunggal untuk rekaman berurutan, dari sudut pandang penyimpanan, kedalaman antrian adalah 1. </p><br><div class="spoiler">  <b class="spoiler_title">Jika Anda tertarik dengan topik ini</b> <div class="spoiler_text"><ul><li>  Artikel yang sangat perkenalan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana Databases Dirancang</a> </li><li>  Ada serangkaian artikel yang sangat baik untuk SQL Server. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara berhenti memanggil transaksi SQL Server log file log dan berhenti berjuang untuk ukurannya.</a> </li><li>  Sangat menarik untuk melihat sedikit dari sisi lain, misalnya, transkrip laporan yang sangat baik tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tarantool</a> DBMS dalam memori </li><li>  Setiap DBMS memiliki bagian luas yang menjelaskan cara kerja WAL. </li></ul></div></div><br><p>  Topik log-forward logging dalam database harus minimal diketahui siapa pun yang entah bagaimana mengelola DBMS, atau infrastruktur DBMS, atau mengembangkan database. </p><br><h3 id="wal-i-shd">  WAL dan SHD </h3><br><p>  "Dari lahir" produsen penyimpanan dihadapkan dengan DBMS.  Untuk basis data bisnis membeli kompleks yang sangat mahal ini: dari penyimpanan harga jalan Dell-EMC, HP, Hitachi, NetApp, ketika memaksakan anggaran, mata dipenuhi dengan air mata bagi sebagian besar manajer puncak, kecuali, tentu saja, mereka mendapatkan persentase dari harga ini.  Tetapi ada konflik teknik dan pemasaran.  Saya akan menjelaskannya menggunakan Dell-EMC sebagai contoh, tetapi hanya karena saya ingat di mana mereka memiliki dokumentasi. </p><br><p>  Jadi: </p><br><ol><li>  Jurnal berulir tunggal </li><li>  Log write-through, yaitu latensi, "abadi" dibandingkan dengan kinerja CPU </li><li>  Beban OLTP adalah banyak transaksi yang relatif kecil, </li><li>  Sebagian besar beban DBMS lainnya paralel dengan satu atau lain cara. </li></ol><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hukum Amdahl</a> tanpa ampun memberi tahu kita bahwa beban kinerja tunggal berulir tunggal akan membuat prosesor tambahan tidak berguna, dan kinerja akan ditentukan oleh log.  Selain itu, saat ini kami tidak akan peduli tentang kinerja penyimpanan di IOPS, dan hanya latensi yang akan menjadi penting. <br>  Tetapi jangan mengabaikan operasi disk lain - membaca dan menulis ke file data dan <code>tempdb</code> .  Membaca juga merupakan operasi "menunggu".  Hingga halaman data dibaca dari disk ke memori, prosesor tidak dapat memprosesnya.  Tetapi untuk operasi ini, antrian besar dan permutasi operasi dalam antrian ini dimungkinkan: DBMS sering tahu halaman mana yang akan dimuat ke dalam memori, halaman mana yang akan dibuang dan menempatkan banyak antrian untuk membaca sekaligus.  Karena dalam skenario ini, penting ketika operasi terakhir dari bundel berakhir, dalam beban ini, sebaliknya, IOPS lebih penting bagi kami daripada latensi operasi tunggal.  Untuk memahami ruang lingkup: operasi baca dalam sistem OLTP khas adalah 85% -95%.  Ya, ya, ya, operasi tulis adalah urutan besarnya kurang. </p><br><p>  Insinyur penyimpanan vendor bekerja erat dengan vendor DBMS, dan sangat menyadari semua nuansa teknis tentang bagaimana DBMS bekerja dengan subsistem disk.  Perencanaan, partisi, dan alokasi sumber daya disk yang tepat untuk DBMS adalah kompetensi yang kompleks dan penting dari <strong>administrator sistem penyimpanan</strong> .  Dell-EMC yang sama bahkan memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">H14621</a> white-paper <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dasar</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">H12341</a> untuk rekomendasi pemartisian untuk SQL Server - lebih dari seratus halaman.  Hai!  Ini bukan dermaga terperinci, ini adalah kertas putih paling umum!  Masih ada banyak yang spesifik ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">h15142</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">h16389</a> ... ada kegelapan di sana).  "Adjacents" dari VMware - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Merancang Microsoft SQL Server di VMware vSphere</a> tidak jauh di belakang.  Harap dicatat bahwa dokumen-dokumen ini tidak hanya dan tidak begitu banyak untuk DBA maupun untuk administrator infrastruktur dan penyimpanan. <br>  Saya juga mencatat bahwa dalam semua dokumen ini LUN terpisah untuk data, untuk log, dan untuk <code>tempdb</code> .  Ya, di suatu tempat di dokumen terbaru mereka dengan rapi mengatakan bahwa untuk solusi All-Flash tidak masuk akal untuk memisahkan log menjadi media yang terpisah secara fisik, tetapi LUN masih menawarkan untuk memotongnya secara terpisah.  Jika Anda membuang data dan log ke dalam satu LUN, maka dari sudut pandang OS itu akan menjadi satu antrian IO.  Dan akan ada masalah.  Operasi latensi akan segera memiliki urutan yang lebih besar.  Dan karena fakta bahwa operasi log yang tidak dapat dipindahkan akan muncul dalam antrian, IOPS akan tergelincir pada file data dan <code>tempdb</code> .  Ini bukan "penemuan abad ini", ini adalah kebenaran dasar bekerja dengan database.  Itu tidak ketinggalan jaman atau dibatalkan dengan munculnya All-Flash.  Ya, keterlambatan operasi dengan SSD lebih cepat dengan urutan besarnya daripada dalam operasi dengan HDD, tetapi masih ada beberapa urutan besarnya lebih lambat daripada operasi dengan memori.  IO masih menjadi hambatan bagi DBMS. <br>  Dan dokumen teknis dengan benar menekankan bahwa dalam log transaksi jumlah IOPS tidak penting, tetapi penting bahwa latensi minimal (di zaman modern ini ditulis kurang dari 1 ms). </p><br><p>  Tetapi pemasar perlu menjual.  Hyperconvergence!  Virtualisasi!  Fleksibilitas Penempatan!  Deduplikasi!  Pengaturan mudah!  Banyak, banyak IOPS!  Presentasi yang indah, suara percaya diri, kostum formal.  Tapi bagaimana lagi menjual solusi dengan label harga 6-7 digit dalam dolar?  Untuk ini, entah bagaimana dilupakan bahwa baik latensi atau throughput dapat diperoleh dari sistem penyimpanan, tetapi tidak keduanya sekaligus, bahwa beberapa jenis lisensi untuk penyeimbang beban seperti rak lain, bahwa jika rekaman intensif berlangsung lebih dari satu jam, maka RAM dari pengontrol itu tidak cukup dan produktivitas akan turun ke "seolah-olah tidak ada cache", bahwa pelatihan karyawan pelanggan biaya 100.000 rubel lain untuk tahun pertama, well, trik seperti ... </p><br><h3 id="5-ms">  5 ms </h3><br><p>  Entah telah mendengar banyak dari membaca marketer, atau dari kemalasan, atau karena beberapa jenis kecoak, tetapi untuk beberapa alasan sering administrator penyimpanan melakukan sesuatu seperti ini.  Kami mengambil rak besar, menggabungkan semuanya menjadi sesuatu yang rata, memotongnya menjadi LUN yang tipis dan mendistribusikannya dengan LUN ke server.  Atau dua, karena "partisi sistem terduplikasi dengan baik."  Dan ketika, saya melihat bahwa dengan subsistem disk dari sisi SQL hell-hell-hell, maka lagu dimulai bahwa "5 ms adalah indikator yang sangat baik", "100000 IOPS", "Beban penyimpanan Anda kurang dari 5%" </p><br><p>  <strong>TIDAK</strong> . </p><br><ul><li>  Untuk sistem OLTP pada partisi dengan log WAL / transaksi 5 ms, ini adalah indikator yang tidak valid.  Pada potongan "hampir-komoditas" besi dengan harga 1000 (dalam kata: seribu) kali lebih murah, indikator normal sekarang adalah 0,1-0,3 ms.  Dan besok - 0,01 ms.  Kecepatan, seperti pada HDD 2008, dengan harga seluruh pintu masuk apartemen di Moskow, tidak diperlukan.  Tidak ada “kemudahan servis” yang sepadan. </li><li>  Apakah vendor menulis bahwa log transaksi tidak menuntut IOPS dan bisakah mereka dimasukkan ke dalam HDD?  Ya itu.  Tetapi untuk ini perlu bahwa tidak ada disk ini <del>  penularan </del>  Selain menulis log, DBMS tidak menyentuh tugas.  Dan agar sistem penyimpanan merespons ke server bahwa data ditulis, segera setelah data masuk ke memori non-volatil (ini jauh lebih awal daripada yang akan ditulis) </li><li>  Disk tipis untuk database OLTP nyata adalah jahat. </li><li>  Untuk WAL, sama sekali tidak menarik berapa banyak IOPS dapat diperas di sana pada kedalaman antrian 10 atau 20. Tidak ada kedalaman di sana. </li><li>  Untuk WAL, itu sama sekali bukan indikator bahwa antrian IO di OS adalah "hanya sekitar 1".  Dia tidak akan lagi. </li><li>  Tidak, pengembang DBA dan DB bukanlah "pelatuk engkol yang tidak dapat mengonfigurasi dengan benar untuk menulis ke paralel WAL" <em>(pendapat nyata dari administrator)</em> </li><li>  Logika penggemar untuk mempertimbangkan daur ulang "karena sistem Anda yang <em>kami konfigurasikan secara bengkok dalam satu partisi</em> tidak menghasilkan 10.000 IOPS, maka itu harus dipindahkan dari array kelas atas ke kelas menengah" - ini adalah logika yang salah. </li><li>  Jika server 40-core memiliki beban prosesor 2,5 persen, ini tidak berarti tidak ada hubungannya, tetapi, kemungkinan besar, berarti ada beberapa jenis tugas yang menghalangi semua orang. </li></ul><br><p>  Ketika beberapa pemuatan data pada laptop pengembang membutuhkan waktu 5 menit, dan pada server nuklir ke-40 dengan 1 TiB RAM dan penyimpanan selama setengah juta dolar, tugas yang sama dilakukan selama satu jam, bahkan pelanggan yang paling sabar pun akan memiliki pertanyaan tentang kelayakan biaya. </p><br><table><thead><tr><th>  Rata-rata latensi partisi WAL </th><th>  tidak akan ada lebih banyak transaksi per detik dari: </th></tr></thead><tbody><tr><td>  5 ms </td><td>  200 </td></tr><tr><td>  1 ms </td><td>  1000 </td></tr><tr><td>  0,5 ms </td><td>  2000 </td></tr><tr><td>  0,1 ms </td><td>  10.000 </td></tr><tr><td>  0,05 ms </td><td>  20000 </td></tr></tbody></table><br><h2 id="chto-delat">  Apa yang harus dilakukan </h2><br><h3 id="sovety-administratoram-i-dba">  Kiat Admin dan DBA </h3><br><p>  Untuk OLTP, berhentilah menghitung "daur ulang" dan IOPS.  Secara terpisah, saya perhatikan - jangan melihat IOPS dengan kedalaman antrian yang besar sama sekali: bahkan pada partisi data, antrian besar biasanya memiliki ledakan pendek atau sesuatu yang tidak mempengaruhi kinerja aktual OLTP. </p><br><p>  Berbagi ruang disk oleh LUN bukan keinginan DBA.  Basis data memiliki beberapa profil beban subsistem disk yang berbeda.  Minimal, berikut ini dapat dibedakan: </p><br><ul><li>  Bekerja dengan file data.  Biasanya ini membaca dan menulis dengan blok acak 8/64 KiB.  Bacaan 80-95%.  Antrian muncul: selama periode layanan, selama periode pemuatan massal, pada permintaan massal atau tidak efisien, dan selama pos pemeriksaan.  Kinerja dipengaruhi oleh responsif terhadap membaca.  Adalah penting bahwa penjajaran blok KiB 8/64 “through” melewati seluruh sistem penyimpanan. </li><li>  Bekerja dengan <code>tempdb</code> sama dengan bekerja dengan file data, tetapi pembacaan biasanya 40-75% dan responsif terhadap penulisan bisa menjadi penting.  Dalam sistem MS SQL modern, basis data ini dapat dimuat beberapa kali lebih kuat daripada basis data.  Dalam konfigurasi DBMS yang tidak berkerumun, bagian ini harus dikecualikan dari replikasi penyimpanan apa pun.  Isinya setelah me-reboot layanan masih akan dihancurkan. </li><li>  Bekerja dengan data yang diarsipkan / DWH.  Bacaan mendekati 100%.  Ukuran satu blok bacaan biasanya 64 KiB.  Permintaan banyak dibaca dan berturut-turut, sehingga antrean dapat melonjak hingga 1000 atau lebih. </li><li>  Bekerja dengan log transaksi.  Membaca hanya untuk pemeliharaan (cadangan, replikasi, dll.), Kinerja aplikasi hanya dipengaruhi oleh penulisan.  Merekam dalam blok 0,5-64 KiB.  Tanpa antrian, dalam satu utas.  Keterlambatan sangat penting untuk aplikasi. </li><li>  Cadangkan dan pulihkan.  Dari sudut pandang database membaca dalam blok besar (sering 1 MiB).  Penting bahwa beban ini dapat berada di atas saluran / bus (baik FC dan Ethernet) dan kinerja prosesor penyimpanan dalam beberapa kasus.  Mencadangkan satu server dapat memengaruhi kinerja server lain dari SAN / SHD yang sama. </li><li>  Bekerja dengan file aplikasi: ini adalah log, jejak default, file biner, dll.  Beban ini jarang signifikan dan hanya penting pada awal sistem. </li></ul><br><p>  Ada jenis beban lainnya, tetapi sedikit eksotis (misalnya, mungkin ada repositori file yang disimpan dalam database dalam bentuk direktori FileStream).  Semua jenis beban ini memiliki persyaratan disk yang berbeda, seringkali saling bertentangan.  Jika mereka semua ditumpuk di satu partisi, maka Anda tidak hanya menurunkan kinerja, tetapi sangat penting bahwa Anda kehilangan kemampuan untuk memahami mengapa sistem melambat, dan Anda juga kehilangan kesempatan untuk meningkatkan hanya bagian yang membutuhkan perbaikan tanpa peningkatan global / peningkatan penyimpanan.  Oleh karena itu, rekomendasi utama: </p><br><p> <strong>      ,   "   "        .        .</strong> </p><br><p>     </p><br><ul><li>    ,   .  Dell/EMC  SQL Server     . </li><li>    .      ""  (, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> NUC c SSD,  , </a> ).    --,    . </li><li>      <strong></strong>     DBA,    -   ( 200   ). </li><li>        (etrolaster   ), ,     ,  .      +0,5 ,    0,2,     0,7     3 . </li><li>   ,          .      <code>tempdb</code>  , , ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RCSI</a>   12      . </li><li> Latency    throughput.         ,   " ",   .    throughput  latency,    .      . </li></ul><br><h3 id="ms-sql-server"> MS SQL Server </h3><br><p>    MS SQL,            bottleneck  ,  - : </p><br><ol><li>        .  Ini benar        . 1000          5-30      1000 <code>INSERT</code> . , , ,       ,      "  —  ". </li><li>  <code>tempdb</code>   " ".    . ,     ,       . </li><li>     ,    BULK INSERT      .            ,      "Simple"  "Bulk logged". , ,         Simple/Bulk logged  Full  .         — <a href="">The Data Loading Performance Guide</a> ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> .   (  ETL,   OLTP)       <a href="">We Loaded 1TB in 30 Minutes with SSIS, and So Can You</a> </li><li>    SQL Server  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Delayed Transaction Durability</a> — ,       . </li><li>    SQL Server  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">In-Memory OLTP</a> .    ,        . </li><li> ,     ,   AlwaysOn . </li></ol><br><h2>  *** </h2><br><p>  Itu saja.   . 20000 IOPS  5  latency    4-16         OLTP.  OLTP    ,        . </p><br><div class="spoiler"> <b class="spoiler_title">PS:    SSD.</b> <div class="spoiler_text"><p>              .  Intel Optane.   SSD ""       4,       .            SSD, ,     ,      .    SSD  . ,      ""   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,    </a> .      Intel Optane:      ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> )        1     20 .     ,  . SSD        100-300 .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>     SSD. <br>  , .         OLTP "",  in-memory     ACID.     latency 20      "" .  low-latency        Optane ( <em>    ?</em> ). <br>          ( ) Optane. </p></div></div><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">eugeneb0</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">apatyukov</a>     . </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414269/">https://habr.com/ru/post/id414269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414255/index.html">Mimpi Yang Dipatenkan Programmer - Bagian II</a></li>
<li><a href="../id414261/index.html">Di mana Anda menyimpan data?</a></li>
<li><a href="../id414263/index.html">Apakah ada kehidupan di luar Roscosmos? Tinjauan eksplorasi ruang angkasa pribadi Rusia</a></li>
<li><a href="../id414265/index.html">Richard Hamming: Bab 7. Kecerdasan Buatan - II</a></li>
<li><a href="../id414267/index.html">Bagaimana cara mengganti akuntan dengan robot?</a></li>
<li><a href="../id414271/index.html">Cara menjinakkan hard drive di laptop dan mencegah parkir dalam 8 detik downtime</a></li>
<li><a href="../id414273/index.html">Apa yang perlu Anda ketahui sebelum mengembangkan backtester untuk strategi perdagangan: masalah khas, jenis sistem dan parameternya</a></li>
<li><a href="../id414277/index.html">Manusia, lingkungannya dan internet hal-hal</a></li>
<li><a href="../id414279/index.html">Voting untuk laporan pada pertemuan DIY kedelapan di Grup Mail.Ru (07.07.2018)</a></li>
<li><a href="../id414281/index.html">Pengembangan speedometer sepeda berdasarkan tampilan dari Nokia 3310</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>