<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëéüèæ üë©‚Äçüíª ü•ê Sistemas operativos: tres piezas f√°ciles. Parte 4: Introducci√≥n al Programador (traducci√≥n) üß° üë®‚Äçüëß‚Äçüë¶ üñïüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introducci√≥n a los sistemas operativos 
 Hola Habr! Quiero llamar su atenci√≥n sobre una serie de art√≠culos-traducciones de una literatura interesante ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistemas operativos: tres piezas f√°ciles. Parte 4: Introducci√≥n al Programador (traducci√≥n)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449026/"><h1>  Introducci√≥n a los sistemas operativos </h1><br>  Hola Habr!  Quiero llamar su atenci√≥n sobre una serie de art√≠culos-traducciones de una literatura interesante en mi opini√≥n: OSTEP.  Este art√≠culo analiza en profundidad el trabajo de los sistemas operativos tipo Unix, a saber, el trabajo con procesos, varios programadores, memoria y otros componentes similares que componen el sistema operativo moderno.  El original de todos los materiales que puedes ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Tenga en cuenta que la traducci√≥n se realiz√≥ de manera no profesional (con bastante libertad), pero espero haber conservado el significado general. <br><br>  El trabajo de laboratorio sobre este tema se puede encontrar aqu√≠: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el original</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el original</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi adaptaci√≥n personal</a> </li></ul><br>  Otras partes: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1: Introducci√≥n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2: Abstracci√≥n: el proceso</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3: Introducci√≥n a la API de proceso</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 4: Introducci√≥n al Programador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 5: Programador MLFQ</a> </li></ul><br>  Y puedes mirar mi canal en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">telegram</a> =) <br><a name="habracut"></a><br><h2>  Introducci√≥n al programador </h2><br>  <u>La esencia del problema: c√≥mo desarrollar una pol√≠tica de planificaci√≥n</u> <u><br></u>  <u>¬øC√≥mo deben desarrollarse los marcos de pol√≠ticas b√°sicas del planificador?</u>  <u>¬øCu√°les deber√≠an ser los supuestos clave?</u>  <u>¬øQu√© m√©tricas son importantes?</u>  <u>¬øQu√© t√©cnicas b√°sicas se utilizaron en la inform√°tica temprana?</u> <br><br><h3>  Supuestos de carga de trabajo </h3><br>  Antes de discutir posibles pol√≠ticas, para comenzar haremos algunas digresi√≥n simplificadoras sobre los procesos que se ejecutan en el sistema, que colectivamente se denominan <b>carga de trabajo</b> .  Al definir una carga de trabajo como una parte cr√≠tica de las pol√≠ticas de construcci√≥n y cuanto m√°s sepa sobre la carga de trabajo, mejor pol√≠tica podr√° escribir. <br><br>  Hacemos los siguientes supuestos sobre los procesos que se ejecutan en el sistema, a veces tambi√©n llamados <b>trabajos</b> (tareas).  Casi todas estas suposiciones no son realistas, sino necesarias para el desarrollo del pensamiento. <br><br><ol><li>  Cada tarea ejecuta la misma cantidad de tiempo, </li><li>  Todas las tareas se establecen al mismo tiempo, </li><li>  La tarea en cuesti√≥n hasta su finalizaci√≥n, </li><li>  Todas las tareas usan solo la CPU, </li><li>  Se conoce el tiempo de ejecuci√≥n de cada tarea. </li></ol><br><h3>  M√©tricas del programador </h3><br>  Adem√°s de algunos supuestos sobre la carga, necesita alguna herramienta m√°s para comparar diferentes pol√≠ticas de planificaci√≥n: las m√©tricas del planificador.  Una m√©trica es solo una medida de algo.  Hay una serie de m√©tricas que se pueden usar para comparar planificadores. <br><br>  Por ejemplo, utilizaremos una m√©trica llamada tiempo de respuesta.  El tiempo de respuesta de una tarea se define como la diferencia entre el tiempo que lleva completar la tarea y el tiempo que la tarea ingresa al sistema. <br><br>  <u>Tturnaround = Tcompletion - Tarrival</u> <br><br>  Como asumimos que todas las tareas llegaron al mismo tiempo, entonces Ta = 0 y, por lo tanto, Tt = Tc.  Este valor cambiar√° naturalmente cuando cambiemos los supuestos anteriores. <br><br>  Otra m√©trica es la <b>justicia</b> (equidad, honestidad).  La productividad y la honestidad a menudo son caracter√≠sticas opuestas en la planificaci√≥n.  Por ejemplo, un planificador puede optimizar el rendimiento, pero a costa de esperar a que se ejecuten otras tareas, reduciendo as√≠ la integridad. <br><br><h3>  PRIMERO EN PRIMERA SALIDA (FIFO) </h3><br>  El algoritmo m√°s b√°sico que podemos implementar se llama FIFO o <b>first come (in), first serve (out)</b> .  Este algoritmo tiene varias ventajas: es muy simple de implementar y se ajusta a todos nuestros supuestos, haciendo el trabajo bastante bien. <br><br>  Considere un ejemplo simple.  Supongamos que se establecieron 3 tareas al mismo tiempo.  Pero suponga que la tarea A lleg√≥ un poco antes que todos los dem√°s, por lo que estar√° en la lista de ejecuci√≥n antes que las dem√°s, al igual que B en relaci√≥n con C. Suponga que cada una de ellas tarda 10 segundos en completarse.  ¬øCu√°l ser√° el tiempo promedio para completar estas tareas? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1b4/a43/acd/1b4a43acd8a0f18c24bbdd831529bbda.jpg" alt="imagen"><br><br>  Contando los valores: 10 + 20 + 30 y dividiendo entre 3, obtenemos el tiempo de ejecuci√≥n promedio del programa igual a 20 segundos. <br><br>  Ahora intentemos cambiar nuestras suposiciones.  En particular, el supuesto 1 y, por lo tanto, ya no asumiremos que cada tarea lleva la misma cantidad de tiempo.  ¬øC√≥mo se mostrar√° FIFO esta vez? <br><br>  Como resultado, los diferentes tiempos de ejecuci√≥n de las tareas tienen un impacto extremadamente negativo en la productividad del algoritmo FIFO.  Suponga que la tarea A se ejecutar√° durante 100 segundos, mientras que B y C seguir√°n siendo 10 cada uno. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7a/bee/3fe/a7abee3fefd7a0cf481d0322f40e732f.jpg" alt="imagen"><br><br>  Como se puede ver en la figura, el tiempo promedio para el sistema es (100 + 110 + 120) / 3 = 110.  Este efecto se llama <b>efecto convoy</b> , cuando algunos consumidores a corto plazo de un recurso estar√°n en l√≠nea despu√©s de un consumidor pesado.  Parece una l√≠nea de supermercado cuando un cliente con un carrito lleno est√° frente a usted.  La mejor soluci√≥n al problema es intentar cambiar el cajero o relajarse y respirar profundamente. <br><br><h3>  El trabajo m√°s corto primero </h3><br>  ¬øEs posible de alguna manera resolver una situaci√≥n similar con procesos pesados?  Por supuesto  Otro tipo de programaci√≥n se llama <b>Shortest Job First</b> (SJF).  Su algoritmo tambi√©n es bastante primitivo: como su nombre lo indica, las tareas m√°s cortas se lanzar√°n primero una tras otra. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/778/feb/207/778feb20723fa2d019620b97d27f2830.jpg" alt="imagen"><br><br>  En este ejemplo, el resultado de iniciar los mismos procesos ser√° una mejora en el tiempo de respuesta promedio de los programas y ser√° <b>50 en lugar de 110</b> , que es casi 2 veces mejor. <br><br>  Por lo tanto, dado el supuesto de que todas las tareas llegan al mismo tiempo, el algoritmo SJF parece ser el algoritmo m√°s √≥ptimo.  Sin embargo, nuestras suposiciones a√∫n no parecen realistas.  Esta vez, cambiamos el supuesto 2 y esta vez imaginamos que las tareas pueden permanecer en cualquier momento, y no todas al mismo tiempo.  ¬øA qu√© problemas puede conducir esto? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/484/6df/332/4846df332de36b42bf891e167ef3f751.jpg" alt="imagen"><br><br>  Imagine que la tarea A (100s) llega primero y comienza a ejecutarse.  En el tiempo t = 10, llegan las tareas B, C, cada una de las cuales tomar√° 10 segundos.  Por lo tanto, el tiempo de ejecuci√≥n promedio es (100+ (110-10) + (120-10)) \ 3 = 103. ¬øQu√© podr√≠a hacer el planificador para mejorar la situaci√≥n? <br><br><h3>  El tiempo de finalizaci√≥n m√°s corto primero (STCF) </h3><br>  Para mejorar la situaci√≥n, omitimos el supuesto 3 de que el programa est√° en funcionamiento hasta su finalizaci√≥n.  Adem√°s, necesitaremos soporte de hardware y, como habr√°s adivinado, utilizaremos un <b>temporizador</b> para interrumpir una tarea de trabajo y <b>cambiar de contexto</b> .  Por lo tanto, el planificador puede hacer algo en el momento en que llegan las tareas B y C: detener la ejecuci√≥n de la tarea A y poner las tareas B y C en proceso y, despu√©s de que terminen, continuar el proceso A. Este planificador se llama <b>STCF</b> o <b>trabajo preventivo primero</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0eb/900/a1f/0eb900a1f8b96a0952061727037faf4f.jpg" alt="imagen"><br><br>  El resultado de este planificador ser√° este resultado: ((120-0) + (20-10) + (30-10)) / 3 = 50.  Por lo tanto, dicho planificador se vuelve a√∫n m√°s √≥ptimo para nuestras tareas. <br><br><h3>  Tiempo de respuesta m√©trica </h3><br>  Por lo tanto, si conocemos el tiempo de ejecuci√≥n de las tareas y si estas tareas usan solo la CPU, STCF ser√° la mejor soluci√≥n.  Y una vez en los primeros d√≠as, estos algoritmos funcionaron y bastante bien.  Sin embargo, ahora el usuario pasa la mayor parte del tiempo en el terminal y espera una interacci√≥n interactiva productiva del mismo.  As√≠ naci√≥ una nueva m√©trica: <b>tiempo de</b> respuesta (respuesta). <br><br>  El tiempo de respuesta se calcula de la siguiente manera: <br><br>  <u>Tresponse = Tfirstrun - Tarrival</u> <br><br>  Por lo tanto, para el ejemplo anterior, el tiempo de respuesta ser√° el siguiente: A = 0, B = 0, B = 10 (abg = 3.33). <br><br>  Y resulta que el algoritmo STCF no es tan bueno en una situaci√≥n en la que llegan 3 tareas al mismo tiempo; tendr√° que esperar hasta que las tareas peque√±as se completen por completo.  Por lo tanto, el algoritmo es bueno para la m√©trica de tiempo de respuesta, pero malo para la m√©trica de interactividad.  Imag√≠nese sentado en la terminal en un intento de escribir caracteres en el editor, tendr√≠a que esperar m√°s de 10 segundos, porque el procesador ocupa otra tarea.  Esto no es muy agradable. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bed/aed/2e2/bedaed2e2491a426eb3fe137ed5b467e.jpg" alt="imagen"><br><br>  Entonces nos enfrentamos a otro problema: ¬øc√≥mo podemos construir un programador que sea sensible al tiempo de respuesta? <br><br><h3>  Round robin </h3><br>  Para resolver este problema, se desarroll√≥ el algoritmo <b>Round Robin</b> (RR).  La idea b√°sica es bastante simple: en lugar de comenzar las tareas para completar la finalizaci√≥n, comenzaremos la tarea durante un cierto per√≠odo de tiempo (llamado tiempo cu√°ntico) y luego cambiaremos a otra tarea desde la cola.  El algoritmo repite su trabajo hasta que se completen todas las tareas.  En este caso, el tiempo de ejecuci√≥n del programa debe ser un m√∫ltiplo del tiempo despu√©s del cual el temporizador interrumpe el proceso.  Por ejemplo, si el temporizador interrumpe el proceso cada x = 10 ms, entonces el tama√±o de la ventana de ejecuci√≥n del proceso debe ser un m√∫ltiplo de 10 y ser 10.20 o x * 10. <br><br>  Veamos un ejemplo: las tareas de ABV llegan simult√°neamente al sistema y cada una de ellas quiere trabajar durante 5 segundos.  El algoritmo SJF completar√° cada tarea hasta el final antes de comenzar otra.  Por el contrario, el algoritmo RR con la ventana de inicio = 1s realizar√° las tareas de la siguiente manera (Fig. 4.3): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bed/aed/2e2/bedaed2e2491a426eb3fe137ed5b467e.jpg" alt="imagen"><br>  <i>(SJF nuevamente (malo para el tiempo de respuesta)</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e40/351/12e/e4035112ea5d27958b0e099ed19a6c41.jpg" alt="imagen"><br>  <i>(Round Robin (Bueno para el tiempo de respuesta)</i> <br><br>  El tiempo de respuesta promedio para el algoritmo es RR (0 + 1 + 2) / 3 = 1, mientras que para SJF (0 + 5 + 10) / 3 = 5. <br><br>  Es l√≥gico suponer que la ventana de tiempo es un par√°metro muy importante para RR, cuanto m√°s peque√±o es, mayor es el tiempo de respuesta.  Sin embargo, no puede hacerlo demasiado peque√±o, porque el tiempo para cambiar el contexto tambi√©n jugar√° un papel en el rendimiento general.  Por lo tanto, el arquitecto del sistema operativo establece el tiempo de la ventana de ejecuci√≥n y depende de las tareas que se planean ejecutar en √©l.  Cambiar el contexto no es la √∫nica operaci√≥n de servicio que gasta tiempo: el programa en ejecuci√≥n funciona con mucho m√°s, por ejemplo, varios cach√©s, y cada vez que es necesario guardar y restaurar este entorno, lo que tambi√©n puede llevar mucho tiempo. <br><br>  RR es un gran planificador si solo fuera una m√©trica de tiempo de respuesta.  Pero, ¬øc√≥mo se comportar√° la m√©trica del tiempo de respuesta de la tarea con este algoritmo?  Considere el ejemplo anterior, cuando el tiempo de operaci√≥n A, B, C = 5s y llegue al mismo tiempo.  La tarea A finalizar√° a las 13, B a las 14, C a las 15s y el tiempo de respuesta promedio ser√° de 14s.  Por lo tanto, RR es el peor algoritmo para las m√©tricas de rotaci√≥n. <br><br>  En t√©rminos m√°s generales, cualquier algoritmo como RR es honesto, divide el tiempo dedicado a la CPU por igual entre todos los procesos.  Y as√≠, estas m√©tricas constantemente entran en conflicto entre s√≠. <br><br>  Por lo tanto, tenemos varios algoritmos opuestos y, al mismo tiempo, quedan varias suposiciones: que se conoce el tiempo de la tarea y que la tarea solo usa la CPU. <br><br><h3>  Mezclar con E / S </h3><br>  En primer lugar, eliminamos la suposici√≥n 4 de que el proceso solo usa la CPU, por supuesto, esto no es as√≠, y los procesos pueden recurrir a otro equipo. <br><br>  En el momento en que un proceso solicita una operaci√≥n de E / S, el proceso pasa a un estado bloqueado, esperando que se complete la E / S.  Si se env√≠a E / S al disco duro, dicha operaci√≥n puede demorar varios ms o m√°s, y el procesador estar√° inactivo en ese momento.  En este momento, el planificador puede hacerse cargo del procesador por cualquier otro proceso.  La siguiente decisi√≥n que tendr√° que tomar el planificador es cuando el proceso complete su E / S.  Cuando esto sucede, se producir√° una interrupci√≥n y el sistema operativo pondr√° el proceso de llamada de E / S en el estado listo. <br><br>  Considere un ejemplo de varias tareas.  Cada uno de ellos necesita 50 ms de tiempo de procesador.  Sin embargo, el primero acceder√° a E / S cada 10 ms (que tambi√©n se ejecutar√° durante 10 ms).  Y el proceso B simplemente usa un procesador de 50 ms sin E / S. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/50a/488/cae/50a488cae4476f65002df9ea966f9ef7.jpg" alt="imagen"><br><br>  En este ejemplo, usaremos el planificador STCF.  ¬øC√≥mo se comporta el planificador si ejecuta un proceso como A en √©l?  √âl proceder√° de la siguiente manera: primero procesar√° completamente A y luego procesar√° B. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/151/f5e/326/151f5e326437859d65d29541dbe0e94f.jpg" alt="imagen"><br><br>  El enfoque tradicional para resolver este problema es interpretar cada subtarea de 10 ms del proceso A como una tarea separada.  Por lo tanto, al comenzar con el algoritmo STJF, la elecci√≥n entre una tarea de 50 ms y una tarea de 10 ms es obvia.  Luego, cuando se complete la subtarea A, se iniciar√°n el proceso B y la E / S.  Una vez completada la E / S, ser√° habitual iniciar nuevamente el proceso A de 10 ms en lugar del proceso B. Por lo tanto, es posible realizar una superposici√≥n cuando la CPU es utilizada por otro proceso mientras el primero est√° esperando E / S.  Y como resultado, el sistema se utiliza mejor: en el momento en que los procesos interactivos est√°n esperando E / S, se pueden ejecutar otros procesos en el procesador. <br><br><h3>  Oracle ya no existe </h3><br>  Ahora tratemos de deshacernos de la suposici√≥n de que se conoce el momento de la tarea.  Esta es generalmente la suposici√≥n peor y m√°s poco realista de toda la lista.  De hecho, en los sistemas operativos est√°ndar promedio, el sistema operativo en s√≠ mismo generalmente sabe muy poco sobre el tiempo que lleva completar las tareas, entonces, ¬øc√≥mo puede construir un programador sin saber cu√°nto tiempo llevar√° la tarea?  ¬øQuiz√°s podr√≠amos usar algunos de los principios de RR para resolver este problema? <br><br><h3>  Resumen </h3><br>  Examinamos las ideas b√°sicas de planificaci√≥n de tareas y revisamos 2 familias de planificadores.  El primero comienza la tarea m√°s corta al principio y, por lo tanto, aumenta el tiempo de respuesta, el segundo se divide entre todas las tareas por igual, aumentando el tiempo de respuesta.  Ambos algoritmos son malos donde otros algoritmos familiares son buenos.  Tambi√©n observamos c√≥mo el uso paralelo de la CPU y la E / S puede mejorar el rendimiento, pero no resolvi√≥ el problema con la clarividencia del sistema operativo.  Y en la pr√≥xima lecci√≥n, consideraremos un planificador que mira el pasado cercano y trata de predecir el futuro.  Y se llama cola de comentarios de varios niveles. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/449026/">https://habr.com/ru/post/449026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../449014/index.html">Advance Ethereum DAPP</a></li>
<li><a href="../449016/index.html">Esteganograf√≠a en el sistema de archivos del disco √≥ptico.</a></li>
<li><a href="../449020/index.html">Analizando el C√≥digo de la Plataforma CUBA con PVS-Studio</a></li>
<li><a href="../449022/index.html">An√°lisis de c√≥digo de la plataforma CUBA usando PVS-Studio</a></li>
<li><a href="../449024/index.html">"El secreto del tercer planeta" con gr√°ficos mejorados de redes neuronales</a></li>
<li><a href="../449028/index.html">Ira, negociaci√≥n y depresi√≥n al trabajar con InfluxDB</a></li>
<li><a href="../449032/index.html">Dise√±amos un sistema de extinci√≥n de incendios por aspersi√≥n.</a></li>
<li><a href="../449034/index.html">Citymobil: un manual para mejorar la disponibilidad en medio del crecimiento del negocio para las nuevas empresas. Parte 1</a></li>
<li><a href="../449038/index.html">Gesti√≥n de contenedores Docker en Go</a></li>
<li><a href="../449040/index.html">Semana de la seguridad 17: Ataques a la cadena de suministro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>