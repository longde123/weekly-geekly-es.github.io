<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ñ∂Ô∏è üóÉÔ∏è ‚óæÔ∏è Introducci√≥n a ECMAScript 6 (ES-2015) ‚Ñ¢Ô∏è üí≤ üôã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introducci√≥n a ES6 

 Tabla de contenidos 
 1. Literales de plantilla 
 2. dejar y const 
 3. Expresiones de funciones de flecha 
 4. Para ... de 
 5....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introducci√≥n a ECMAScript 6 (ES-2015)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460741/"><h2>  Introducci√≥n a ES6 </h2><br><br>  <b>Tabla de contenidos</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1. Literales de plantilla</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2. dejar y const</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3. Expresiones de funciones de flecha</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4. Para ... de</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5. Nombres de propiedad calculados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6. Object.assign ()</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7. Par√°metros de descanso</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8. Par√°metros predeterminados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">9. Asignaci√≥n de desestructuraci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">10. Mapa</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">11. Establecer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">12. Clases</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">13. promesa</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">14. Iteradores</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">15. generadores</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">16. Sumbol</a> <br><br><a name="section001"></a><h2>  Literales de plantilla (cadenas de plantilla) </h2><br>  Los literales de plantilla son literales de cadena que permiten el uso de expresiones dentro.  Con ellos puedes usar literales multil√≠nea e interpolaci√≥n de cadenas. <br><br>  Los literales de plantilla se incluyen entre comillas (``) en lugar de dobles o simples.  Pueden contener comodines indicados por un signo de d√≥lar y llaves ($ {expresi√≥n}).  Las expresiones de sustituci√≥n y el texto entre ellas se pasan a la funci√≥n.  Por defecto, la funci√≥n simplemente concatena todas las partes en una cadena.  Si hay una expresi√≥n antes de la l√≠nea (aqu√≠ es etiqueta), la l√≠nea de plantilla se llama "plantilla de etiqueta".  En este caso, la expresi√≥n de etiqueta (generalmente una funci√≥n) se llama con el literal de plantilla procesado, que puede modificar antes de la salida.  Para escapar de la comilla en literales de plantilla, especifique la barra invertida \. <br><a name="habracut"></a><br>  <b>Literales multil√≠nea</b> <br>  Los caracteres de nueva l√≠nea son parte de los literales comod√≠n.  Usando cadenas regulares, la inserci√≥n de envoltura requerir√≠a la siguiente sintaxis: <br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'string text line 1\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'string text line 2'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "string text line 1 // string text line 2"</span></span></code> </pre> <br>  Lo mismo con el uso de literales de plantilla: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`string text line 1 string text line 2`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "string text line 1 // string text line 2"</span></span></code> </pre> <br><br>  <b>Interpolaci√≥n de Expresi√≥n</b> <br>  Para insertar expresiones en cadenas regulares, deber√≠a usar la siguiente sintaxis: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Fifteen is '</span></span> + (a + b) + <span class="hljs-string"><span class="hljs-string">' and not '</span></span> + (<span class="hljs-number"><span class="hljs-number">2</span></span> * a + b) + <span class="hljs-string"><span class="hljs-string">'.'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "Fifteen is 15 and not 20."</span></span></code> </pre> <br><br>  Ahora, con la ayuda de los literales de plantilla, puede usar 'az√∫car sint√°ctico', lo que hace que las sustituciones sean m√°s legibles: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Fifteen is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a + b}</span></span></span><span class="hljs-string"> and not </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> * a + b}</span></span></span><span class="hljs-string">.`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "Fifteen is 15 and not 20."</span></span></code> </pre> <cut></cut><br><br>  <b>Plantillas anidadas</b> <br>  A veces, anidar un patr√≥n es la forma m√°s corta y quiz√°s m√°s legible de hacer una cadena.  Simplemente coloque otro dentro de la plantilla entre comillas, envolvi√©ndolos en la sustituci√≥n $ {}.  Por ejemplo, si la expresi√≥n es verdadera, puede devolver una plantilla literal. <br>  En ES5: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classes = <span class="hljs-string"><span class="hljs-string">'header'</span></span> classes += (isLargeScreen() ? <span class="hljs-string"><span class="hljs-string">''</span></span> : item.isCollapsed ? <span class="hljs-string"><span class="hljs-string">' icon-expander'</span></span> : <span class="hljs-string"><span class="hljs-string">' icon-collapser'</span></span>);</code> </pre> <br>  En ES2015 con literales de plantilla sin anidar: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classes = <span class="hljs-string"><span class="hljs-string">`header </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ isLargeScreen() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">''</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : (item.isCollapsed ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'icon-expander'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'icon-collapser'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">) }</span></span></span><span class="hljs-string">`</span></span>;</code> </pre> <br>  En ES2015 con literales de plantilla anidadas: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classes = <span class="hljs-string"><span class="hljs-string">`header </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ isLargeScreen() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">''</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`icon-</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${item.isCollapsed ? </span></span></span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'expander'</span></span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"> : </span></span></span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'collapser'</span></span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> }</span></span></span><span class="hljs-string">`</span></span>;</code> </pre> <br><cut></cut><br>  <b>Plantillas de etiquetas</b> <br>  Una forma extendida de literales de plantilla es plantillas etiquetadas.  Le permiten analizar literales de plantilla usando una funci√≥n.  El primer argumento de dicha funci√≥n contiene una matriz de valores de cadena, y el resto contiene expresiones de sustituciones.  Como resultado, la funci√≥n deber√≠a devolver la cadena ensamblada (o algo completamente diferente, como se mostrar√° m√°s adelante).  El nombre de la funci√≥n puede ser cualquier cosa. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = <span class="hljs-string"><span class="hljs-string">'Mike'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> age = <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myTag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">strings, personExp, ageExp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str0 = strings[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// "That " var str1 = strings[1]; // " is a " // ,     // (  )    , //    (""),    . // var str2 = strings[2]; var ageStr; if (ageExp &gt; 99){ ageStr = 'centenarian'; } else { ageStr = 'youngster'; } //     ,     return `${str0}${personExp}${str1}${ageStr}`; } var output = myTag`That ${ person } is a ${ age }`; console.log(output);// That Mike is a youngster</span></span></code> </pre> <br>  La funci√≥n de etiqueta no es necesaria para devolver una cadena. <br><cut></cut><br>  <b>L√≠neas sin procesar</b> <br>  La propiedad sin formato especial, disponible para el primer argumento de la plantilla de etiqueta, le permite obtener la cadena en la forma en que se ingres√≥, sin interpretaci√≥n. <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">strings</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strings.raw[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } tag<span class="hljs-string"><span class="hljs-string">`string text line 1 \\n string text line 2`</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  "string text line 1 \\n string text line 2", //  'n'    '\'</span></span></code> </pre> <br>  Adem√°s, hay un m√©todo String.raw () que devuelve exactamente la misma cadena de origen que la funci√≥n de plantilla predeterminada y la concatenaci√≥n de cadenas volver√≠a juntas. <br><cut></cut><br>  En ECMAScript 2016, las plantillas etiquetadas siguen las reglas para escapar de los siguientes caracteres: <br><ul><li>  Caracteres Unicode que comienzan con "\ u", por ejemplo, \ u00A9 </li><li>  Puntos de c√≥digo Unicode que comienzan con "\ u {}", por ejemplo, \ u {2F804} </li><li>  representaciones de caracteres hexadecimales que comienzan con "\ x", por ejemplo, \ xA9 </li><li>  representaciones octales de caracteres que comienzan con "\", por ejemplo, \ 251 </li></ul><br><cut></cut><br><a name="section002"></a><h2>  dejar y const </h2><br>  El alcance de las variables declaradas por las palabras clave let y const es el bloque en el que se declaran, y todo ello debajo de los bloques.  En esto, la operaci√≥n de la directiva let es similar a la de la directiva var.  La principal diferencia es que el alcance de la variable declarada por la directiva var es la funci√≥n completa en la que se declara.  Adem√°s de las variables, el valor de las constantes no se puede cambiar mediante una nueva asignaci√≥n, ni se puede redefinir.  Al declarar una variable con la palabra clave const, debe usar el operador de asignaci√≥n para establecer el valor de la constante. <br><br>  Las constantes globales no se convierten en propiedades del objeto de ventana, a diferencia de las variables var. <br>  Se requiere la inicializaci√≥n de una constante. <br>  Debe especificar un valor al mismo tiempo que la declaraci√≥n (el punto es que este valor ya no se puede cambiar). <br>  La declaraci√≥n de variables con la palabra clave const crea una constante (una nueva referencia con nombre a una regi√≥n de memoria) que es de solo lectura. <br>  Esto no significa que el valor indicado no cambie, pero s√≠ significa que el identificador no puede reasignarse.  Por ejemplo, si una constante apunta a un objeto, entonces el objeto en s√≠ puede modificarse. <br>  Los nombres de las constantes no pueden coincidir con los nombres de funciones o variables del mismo alcance. <cut></cut><br><br>  Un ejemplo de la diferencia entre el alcance global y el de bloque: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); <span class="hljs-comment"><span class="hljs-comment">//SyntaxError   a     if if (true) var b = 5; console.log(b); //5   b     }</span></span></code> </pre> <br><br><a name="section003"></a><h2>  Expresiones de funci√≥n de flecha </h2><br>  Las expresiones de funci√≥n de flecha tienen una sintaxis m√°s corta que las expresiones funcionales y est√°n vinculadas l√©xicamente al valor de esto (pero no a sus propios esto, argumentos, super o new.target).  La expresi√≥n de las funciones de flecha no le permite especificar un nombre, por lo tanto, las funciones de flecha son an√≥nimas a menos que est√©n asignadas a algo. <br><cut></cut><br>  <b>Sintaxis b√°sica</b> <br><pre> <code class="javascript hljs">(param1, param2, ‚Ä¶, paramN) =&gt; { statements } (param1, param2, ‚Ä¶, paramN) =&gt; expression <span class="hljs-comment"><span class="hljs-comment">// : (param1, param2, ‚Ä¶, paramN) =&gt; { return expression; } //       : (singleParam) =&gt; { statements } singleParam =&gt; { statements } //       : () =&gt; { statements } () =&gt; expression // : () =&gt; { return expression; }</span></span></code> </pre> <br><br>  <b>Sintaxis Extendida</b> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,     params =&gt; ({foo: bar}) // Rest       (param1, param2, ...rest) =&gt; { statements } (param1 = defaultValue1, param2, ‚Ä¶, paramN = defaultValueN) =&gt; { statements } //    var f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c; f(); // 6</span></span></code> </pre> <br>  Puede encontrar m√°s informaci√≥n sobre las funciones de flecha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><a name="section004"></a><h2>  Para ... de </h2><br>  La instrucci√≥n for ... of ejecuta un bucle a trav√©s de objetos iterables (incluidos Array, Map, Set, un objeto de argumentos y similares), invocando en cada paso de iteraci√≥n los operadores para cada valor de varias propiedades del objeto. <br><cut></cut><br>  ¬øPor qu√© NO DEBE usar un for ... in loop para iterar?  Porque dependiendo del motor, JavaScript puede iterar en orden aleatorio, lo que puede conducir a resultados impredecibles.  Si una propiedad cambia en una iteraci√≥n y luego cambia nuevamente, su valor en el bucle es su √∫ltimo valor.  Una propiedad eliminada antes de que llegue el ciclo no participar√° en ella.  Las propiedades agregadas a los objetos en el bucle pueden omitirse.  En general, es mejor no agregar, modificar o eliminar una propiedad del objeto durante la iteraci√≥n si a√∫n no la ha pasado.  No hay garant√≠a de que la propiedad agregada sea visitada por el ciclo, modificada despu√©s de que se realicen los cambios y eliminada despu√©s de la eliminaci√≥n.  Adem√°s, la variable iterativa es una cadena, no un n√∫mero, lo que significa que si va a hacer alg√∫n c√°lculo con la variable, deber√° concatenar las cadenas en lugar de agregarlas.  Entonces, para evitar errores l√≥gicos, ¬°no debe usarlo! <br><br>  A diferencia del bucle for ... of, el bucle for ... in devuelve todas las propiedades enumeradas, incluidas aquellas con nombres no enteros y heredados. <br><br>  <b>Para ... de sintaxis de bucle</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> arr) <span class="hljs-comment"><span class="hljs-comment">//for ( of ) arr[i] = "something value"</span></span></code> </pre> <br>  Ejemplos: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.objCustom = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.arrCustom = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iterable = [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>]; iterable.foo = <span class="hljs-string"><span class="hljs-string">'hello'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> iterable) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); <span class="hljs-comment"><span class="hljs-comment">// 0, 1, 2, "foo", "arrCustom", "objCustom" for (let i in iterable) { if (iterable.hasOwnProperty(i)) console.log(i); //  0, 1, 2, "foo" } for (let i of iterable) console.log(i); // 3, 5, 7</span></span></code> </pre><cut></cut><br>  Cada objeto heredar√° el m√©todo objCustom y cada Array heredar√° el m√©todo arrCustom al crearlos en Object.prototype y Array.prototype.  El objeto iterable heredar√° los m√©todos objCustom y arrCustom debido a la herencia del prototipo. <br><br>  El bucle muestra solo las propiedades enumeradas del objeto iterable, en el orden en que se crearon.  No imprime los valores 3, 5, 7 y hola ya que no son enumerables.  Se muestran los nombres de propiedades y m√©todos, por ejemplo, arrCustom y objCustom. <br><br>  El bucle es similar al anterior, pero usa hasOwnProperty () para verificar si esta propiedad del objeto es propia o heredada.  Solo se muestran las propiedades propias.  Los nombres 0, 1, 2 y foo pertenecen solo a la instancia del objeto (no heredado).  Los m√©todos arrCustom y objCustom no se generan porque se heredan. <br><br>  Este bucle omite iterable y muestra los valores del objeto iterable que se definen en el m√©todo de iteraci√≥n, es decir,  no las propiedades del objeto, sino los valores de la matriz 3, 5, 7. <br><br><a name="section005"></a><h2>  Nombres de propiedad calculados </h2><br>  La sintaxis para declarar objetos y sus elementos admite nombres de propiedades calculados.  Esto le permite agregar una expresi√≥n a los corchetes [] que se evaluar√°n como el nombre de la propiedad.  Se asemeja a los literales de plantilla. <br><br>  <b>Ejemplo de nombres calculados:</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"world"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = { [<span class="hljs-string"><span class="hljs-string">"a"</span></span> + (<span class="hljs-number"><span class="hljs-number">10</span></span> - <span class="hljs-number"><span class="hljs-number">6</span></span>)]: { [<span class="hljs-string"><span class="hljs-string">"some"</span></span> + <span class="hljs-string"><span class="hljs-string">"string"</span></span>]: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, [<span class="hljs-number"><span class="hljs-number">10</span></span> + <span class="hljs-number"><span class="hljs-number">20</span></span>]: <span class="hljs-number"><span class="hljs-number">10</span></span>, [<span class="hljs-string"><span class="hljs-string">`hello </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a()}</span></span></span><span class="hljs-string">`</span></span>]: a() } }</code> </pre> <br><cut></cut><br><br><a name="section006"></a><h2>  Object.assign () </h2><br>  El m√©todo Object.assign () se usa para copiar los valores de todas sus propiedades enumeradas de uno o m√°s objetos de origen al objeto de destino.  Despu√©s de copiar, devuelve el objeto de destino. <br><br>  El m√©todo Object.assign () copia solo las propiedades enumeradas y nativas de los objetos de origen al objeto de destino.  Utiliza el m√©todo interno [[Get]] en los objetos de origen y el m√©todo interno [[Set]] en el objeto de destino, por lo que tambi√©n llama a getters y setters.  Es por eso que asigna propiedades en lugar de simplemente copiar o definir nuevas propiedades.  Este comportamiento puede hacer que el m√©todo sea inadecuado para inyectar nuevas propiedades en el prototipo si los objetos fuente inyectados contienen captadores.  En cambio, para copiar prototipos de definiciones de propiedades, incluido un signo de su enumeraci√≥n, se deben usar los m√©todos Object.getOwnPropertyDescriptor () y Object.defineProperty (). <br><br>  Se copian las propiedades de los tipos de Cadena y S√≠mbolo. <br><br>  En el caso de un error, por ejemplo, cuando la propiedad no se puede escribir, se genera una excepci√≥n TypeError y el objeto de destino permanece sin cambios. <br><br>  Tenga en cuenta que el m√©todo Object.assign () no produce una excepci√≥n si los valores iniciales son nulos o indefinidos. <br><br>  <b>Ejemplo: clonaci√≥n de un objeto</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> copy = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, obj); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(copy); <span class="hljs-comment"><span class="hljs-comment">// { a: 1 }</span></span></code> </pre> <br>  <b>Ejemplo: fusionar objetos</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o1 = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o2 = { <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o3 = { <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(o1, o2, o3); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// { a: 1, b: 2, c: 3 } console.log(o1); // { a: 1, b: 2, c: 3 },     .</span></span></code> </pre> <br><br><a name="section007"></a><h2>  Par√°metros de descanso </h2><br>  La sintaxis de los par√°metros restantes de la funci√≥n le permite representar un conjunto ilimitado de argumentos en forma de matriz. <br><br>  Si el √∫ltimo argumento de la funci√≥n nombrada tiene un prefijo ..., se convierte autom√°ticamente en una matriz con elementos del 0 al Args.length de acuerdo con el n√∫mero real de argumentos pasados ‚Äã‚Äãa la funci√≥n. <br><br>  <b>Sintaxis</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, ...theArgs</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><br>  <b>Un ejemplo del uso de la sintaxis de los par√°metros restantes:</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, ...c</span></span></span><span class="hljs-function">) </span></span>{} name (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>,)</code> </pre> <br>  En este ejemplo, a = 0 b = 1 c [0] = 2 c [1] = 3 <br>  Si no se pasa el par√°metro restante, ser√° una matriz vac√≠a (a diferencia de los par√°metros normales, nunca ser√° indefinido). <br><br>  Esta sintaxis se puede usar no solo en argumentos de funci√≥n, sino tambi√©n en otros lugares, por ejemplo, para copiar y combinar matrices: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = [ <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = [ <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = [ ...a, ...b ]; <span class="hljs-comment"><span class="hljs-comment">// [ 0, 1, 2, 3, 4, 5 ]</span></span></code> </pre> <br><br><a name="section008"></a><h2>  Par√°metros por defecto </h2><br>  Los par√°metros predeterminados le permiten establecer los par√°metros formales de la funci√≥n a los valores predeterminados si la funci√≥n se llama sin argumentos, o si el par√°metro se pasa expl√≠citamente indefinido. <br><br>  En JavaScript, los par√°metros de una funci√≥n que no son valores pasados ‚Äã‚Äãcuando se llama toman el valor predeterminado indefinido.  Sin embargo, en algunos casos puede ser √∫til establecer un valor predeterminado diferente.  Para tales casos, se pretende la configuraci√≥n predeterminada. <br><br>  El valor predeterminado se asigna a un par√°metro formal solo si, durante una llamada a la funci√≥n, el valor de este par√°metro no se pas√≥ o se pas√≥ expl√≠citamente. <br><br>  <b>Un ejemplo de uso de par√°metros predeterminados:</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFun</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a*a; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFun()); <span class="hljs-comment"><span class="hljs-comment">// 25</span></span></code> </pre> <cut></cut><br><br><a name="section009"></a><h2>  Asignaci√≥n de desestructuraci√≥n </h2><br>  La sintaxis de asignaci√≥n de desestructuraci√≥n en las expresiones de JavaScript le permite recuperar datos de matrices u objetos utilizando una sintaxis similar a la declaraci√≥n de una matriz o literales en un objeto. <br><br>  Las expresiones de declaraci√≥n de objeto o matriz proporcionan una manera f√°cil de crear un paquete de datos homog√©neo.  Al crear dicho paquete, tiene la oportunidad de utilizarlo de cualquier manera posible.  Tambi√©n puede devolverlo en funciones. <br><br>  Una de las formas clave de utilizar la asignaci√≥n destructiva es leer la estructura de datos con un operador, aunque puede encontrar muchos otros usos adem√°s de esto. <br><br>  <b>Ejemplo de asignaci√≥n destructiva:</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a, b, rest; [a, b] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); <span class="hljs-comment"><span class="hljs-comment">// 1 console.log(b); // 2 [a, b, ...rest] = [1, 2, 3, 4, 5]; console.log(a); // 1 console.log(b); // 2 console.log(rest); // [3, 4, 5] ({a, b} = {a:1, b:2}); console.log(a); // 1 console.log(b); // 2</span></span></code> </pre> <br>  Puedes ver m√°s ejemplos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><a name="section010"></a><h2>  Mapa </h2><br>  Mapa: un objeto que contiene pares clave-valor y preserva el orden de inserci√≥n.  Cualquier valor (tanto objetos como primitivos) se puede utilizar como claves. <br><br>  <b>Un ejemplo:</b> <cut></cut><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keyObj = {}, keyFunc = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, keyString = <span class="hljs-string"><span class="hljs-string">"a string"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   myMap.set(keyString, "value associated with 'a string'"); myMap.set(keyObj, "value associated with keyObj"); myMap.set(keyFunc, "value associated with keyFunc"); myMap.size; // 3 //   myMap.get(keyString); // "value associated with 'a string'" myMap.get(keyObj); // "value associated with keyObj" myMap.get(keyFunc); // "value associated with keyFunc" myMap.get("a string"); // "value associated with 'a string'" //   keyString === 'a string' myMap.get({}); // undefined,   keyObj !== {} myMap.get(function() {}) // undefined,   keyFunc !== function () {}</span></span></code> </pre> <br>  <b>Diferencia del mapa del objeto:</b> <br><br><ul><li>  Las teclas de objeto son l√≠neas y s√≠mbolos, mientras que cualquier valor puede ser una tecla de mapa, incluidas funciones, objetos y primitivas. </li><li>  A diferencia de los objetos, las teclas en el mapa est√°n ordenadas.  Por lo tanto, durante la iteraci√≥n del mapa, las claves se devuelven en orden de inserci√≥n. </li><li>  Puede obtener f√°cilmente el n√∫mero de elementos en un Mapa utilizando la propiedad de tama√±o, mientras que el n√∫mero de elementos en un Objeto solo puede determinarse manualmente. </li><li>  El mapa es un objeto iterable y puede iterarse directamente, mientras que el objeto requiere la recepci√≥n manual de la lista de claves y su iteraci√≥n. </li><li>  El objeto tiene un prototipo y, por lo tanto, tiene un conjunto est√°ndar de teclas que, si no se toman en cuenta, pueden cruzarse con las teclas.  Desde el lanzamiento de ES5, esto se puede cambiar usando map = Object.create (nulo). </li><li>  El mapa puede tener un mejor rendimiento en casos de agregar o quitar claves con frecuencia. </li></ul><cut></cut><br>  <b>Propiedades y m√©todos:</b> <br><br><ul><li>  Map.prototype.size: devuelve el n√∫mero de pares clave \ valor en un mapa </li><li>  Map.prototype.set (clave, valor): agrega el par clave / valor pasado al mapa.  Si la clave especificada ya existe, se sobrescribir√° con el nuevo valor. </li><li>  Map.prototype.get (key): devuelve el valor de la clave pasada.  Si no hay clave, entonces indefinido volver√° </li><li>  Map.prototype.has (key): devuelve verdadero si la clave pasada existe y falso si no </li><li>  Map.prototype.delete (clave): elimina el par clave \ valor especificado y devuelve verdadero.  Devuelve falso si la clave no existe. </li><li>  Map.prototype.clear () - Elimina todos los pares clave \ valor del Mapa </li><li>  Map.prototype.keys (): devuelve un iterador de claves en un mapa para cada elemento </li><li>  Map.prototype.values ‚Äã‚Äã(): devuelve un iterador de valores en el mapa para cada elemento </li><li>  Map.prototype.entries (): devuelve un iterador de la matriz [clave, valor] en el mapa para cada elemento </li></ul><cut></cut><br><br><a name="section011"></a><h2>  Set </h2><br>  Le permite guardar valores √∫nicos de cualquier tipo, tanto primitivos como otros tipos de objetos. <br><br>  Los objetos de conjunto representan colecciones de valores que puede recorrer en el orden en que se insertan los elementos.  El valor de un elemento en Set puede estar presente en una sola instancia, lo que garantiza su unicidad en la colecci√≥n Set. <br><br>  Conjunto de propiedades y m√©todos de instancia <br><ul><li>  size: devuelve el n√∫mero de elementos en el objeto Set. </li><li>  add (value): agrega un nuevo elemento con el valor dado al objeto Set.  Devuelve un objeto Set. </li><li>  clear (): elimina todos los elementos del objeto Set. </li><li>  delete (value): elimina el elemento asociado con el valor y devuelve el valor que ten√≠a (value) anteriormente.  has (valor) devolver√° falso m√°s tarde. </li><li>  Entradas () - Devuelve un nuevo objeto Iterator que contiene una matriz de [valor, valor] para cada elemento en el objeto Set en orden de inserci√≥n.  Esto se almacena de manera similar al objeto Map, por lo que cada entrada tiene el mismo valor para su clave y valor aqu√≠. </li><li>  forEach (callbackFn [, thisArg]) - Llama a callbackFn una vez por cada valor presente en el objeto Set, en orden de inserci√≥n.  Si se especifica thisArg para thisEach, se usar√° como este valor para cada devoluci√≥n de llamada. </li><li>  has (value): devuelve un valor booleano que confirma si el elemento con el valor dado est√° presente en el objeto Set o no. </li><li>  values ‚Äã‚Äã() - Devuelve un nuevo objeto Iterator que contiene los valores para cada elemento en el objeto Set en orden de inserci√≥n. </li></ul><br>  <b>Usando el objeto Set</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mySet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(); mySet.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Set { 1 } mySet.add(5); // Set { 1, 5 } mySet.add(5); // Set { 1, 5 } mySet.add("some text"); // Set { 1, 5, 'some text' } var o = {a: 1, b: 2}; mySet.add(o); mySet.add({a: 1, b: 2}); //  o    ,      mySet.has(1); // true mySet.has(3); // false, 3     set mySet.has(5); // true mySet.has(Math.sqrt(25)); // true mySet.has("Some Text".toLowerCase()); // true mySet.has(o); // true mySet.size; // 5 mySet.delete(5); //  5  set mySet.has(5); // false, 5   mySet.size; // 4,     console.log(mySet); // Set {1, 'some text', Object {a: 1, b: 2}, Object {a: 1, b: 2}}</span></span></code> </pre> <br>  <b>Conjunto de derivaci√≥n</b> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    : 1, "some text", {"a": 1, "b": 2} for (let item of mySet) console.log(item); //    : 1, "some text", {"a": 1, "b": 2} for (let item of mySet.keys()) console.log(item); //    : 1, "some text", {"a": 1, "b": 2} for (let item of mySet.values()) console.log(item); //    : 1, "some text", {"a": 1, "b": 2} //(key  value    ) for (let [key, value] of mySet.entries()) console.log(key); //  Set  Array var myArr = Array.from(mySet); // [1, "some text", {"a": 1, "b": 2}] //       HTML  mySet.add(document.body); mySet.has(document.querySelector("body")); // true //   Array  Set   mySet2 = new Set([1,2,3,4]); mySet2.size; // 4 [...mySet2]; // [1,2,3,4] //      var intersection = new Set([...set1].filter(x =&gt; set2.has(x))); //      var difference = new Set([...set1].filter(x =&gt; !set2.has(x))); //   set   forEach mySet.forEach(function(value) { console.log(value); }); // 1 // 2 // 3 // 4</span></span></code> </pre> <br><cut></cut><br><br><a name="section012"></a><h2>  Clases </h2><br>  Las clases en JavaScript se introdujeron en ECMAScript 2015 y son az√∫car sint√°ctica sobre herencia prototipo en JavaScript.  La sintaxis de clase no introduce un nuevo modelo orientado a objetos, pero proporciona una forma m√°s simple e intuitiva de crear objetos y organizar la herencia. <br><br>  Las clases son en realidad "funciones especiales", as√≠ que al igual que define funciones (expresiones de funci√≥n y declaraciones de funci√≥n), puede definir clases con: declaraciones de clase y expresiones de clase. <br><br>  La diferencia entre una declaraci√≥n de funci√≥n y una declaraci√≥n de clase es que una declaraci√≥n de funci√≥n se iza, mientras que una declaraci√≥n de clase no.  Por lo tanto, primero debe declarar su clase y solo luego trabajar con ella; de lo contrario, se generar√° una excepci√≥n del tipo ReferenceError. <br><cut></cut><br><h4>  Declaraci√≥n de clase </h4><br>  La primera forma de definir una clase es con una declaraci√≥n de clase.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para hacer esto, use la palabra clave class y especifique el nombre de la clase (en el ejemplo, "myClass"). </font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myClass</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(height, width) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = width; } }</code> </pre> <cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La segunda forma de definir una clase es la expresi√≥n de clase. </font><font style="vertical-align: inherit;">Puede crear expresiones con nombre y sin nombre. </font><font style="vertical-align: inherit;">En el primer caso, el nombre de la expresi√≥n de clase est√° en el √°mbito local de la clase y se puede obtener a trav√©s de las propiedades de la clase en s√≠, y no de su instancia.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  var myClass = class { constructor(height, width) { this.height = height; this.width = width; } }; //  var myClass = class myClass { constructor(height, width) { this.height = height; this.width = width; } };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬°Las expresiones de clase est√°n sujetas a los mismos problemas de elevaci√≥n que las declaraciones de clase! </font></font><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los cuerpos de declaraci√≥n de clase y las expresiones de clase se ejecutan en modo estricto. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El modo estricto cambia la sintaxis y el comportamiento del tiempo de ejecuci√≥n. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ser m√°s precisos, el modo estricto se caracteriza por lo siguiente:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Convierta errores en excepciones </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cambios que simplifican el c√°lculo de una variable en ciertos casos de usar su nombre; </font></font></li><li> ,  eval  arguments; </li><li> ,   ¬´¬ª JavaScript; </li></ul><br> <b>   </b> <br><ol><li>        . </li><li>     . </li><li> ,      ,  . </li><li>        (           ). </li><li>  ,    ,     .       ,      . </li><li>         .             . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La sintaxis del sistema de n√∫meros octales est√° prohibida. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se proh√≠be establecer propiedades con valores primitivos. </font></font></li></ol><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplificaci√≥n del trabajo con variables El</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> modo estricto simplifica la comparaci√≥n del nombre de la variable con el lugar de su definici√≥n en el c√≥digo.</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usar con est√° prohibido. </font><font style="vertical-align: inherit;">El problema con with es que en tiempo de ejecuci√≥n, cualquier nombre dentro del bloque puede referirse a una propiedad del objeto que se est√° procesando o a una variable en el contexto circundante (o incluso global); es imposible saber esto de antemano. </font><font style="vertical-align: inherit;">Ya existe una alternativa simple con: asignar el objeto a una variable con un nombre corto y luego acceder a la propiedad deseada como una propiedad de esta variable.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eval () en modo estricto no agrega nuevas variables al contexto circundante. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Est√° prohibido eliminar nombres simples. </font></font></li></ol><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplificaci√≥n de eval y argumentos El</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> modo estricto reduce el n√∫mero de rarezas en el comportamiento de los argumentos y eval, los cuales mezclan una cierta cantidad de magia en el c√≥digo regular. </font><font style="vertical-align: inherit;">Entonces eval agrega o elimina variables y cambia sus valores, y la variable de argumentos puede sorprender con sus propiedades indexadas, que son referencias (sin√≥nimos) para argumentos de funciones con nombre.</font></font><cut></cut><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Las palabras clave eval y los argumentos no pueden anularse ni modificarse. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los campos del objeto de argumentos no est√°n asociados con los argumentos de la funci√≥n nombrada, sino que son sus copias duplicadas de los valores. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La propiedad argumentos.callee no es compatible. </font><font style="vertical-align: inherit;">En el c√≥digo regular, la propiedad argumentos.callee se refiere a la funci√≥n en s√≠, para la invocaci√≥n de la cual se cre√≥ el objeto de argumentos.</font></font></li></ol><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript "seguro"</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algunos sitios web ofrecen a los usuarios la capacidad de escribir JavaScript que se ejecutar√° en el sitio en nombre de otros usuarios. </font><font style="vertical-align: inherit;">En los navegadores, JavaScript puede tener acceso a informaci√≥n privada, que es un agujero de seguridad en JavaScript.</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El valor pasado a la funci√≥n ya que esto no se convierte al objeto en modo estricto. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No es posible "ejecutar" la pila de JavaScript a trav√©s de las extensiones b√°sicas de ECMAScript. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En funciones, la propiedad de argumentos ya no proporciona acceso a las variables creadas dentro de la funci√≥n. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede consultar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la especificaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ECMAScript 5.1 para obtener m√°s informaci√≥n sobre el modo estricto. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y tambi√©n </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de Mozilla.</font></font><br><cut></cut><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Constructores </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El constructor es un m√©todo especial usado para crear e inicializar objetos creados usando la clase. </font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> robert = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Student(<span class="hljs-string"><span class="hljs-string">'Robert'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(robert.name); <span class="hljs-comment"><span class="hljs-comment">// Outputs 'Robert'</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al crear nuevos objetos desde la clase, se iniciar√° constructor (), que es necesario para inicializar los objetos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo puede haber un m√©todo en una clase llamada constructor. </font><font style="vertical-align: inherit;">Si la clase contiene m√°s de un constructor, se generar√° una excepci√≥n SyntaxError. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La palabra clave super se puede usar en el constructor para invocar al constructor de la clase padre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si no defini√≥ un m√©todo de constructor, se utilizar√° el constructor predeterminado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para las clases base, el constructor predeterminado es:</font></font><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para las clases derivadas, el constructor predeterminado es: </font></font><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(...args) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(...args); }</code> </pre> <br><cut></cut><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√©todos </font></font></h4><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©todo de sintaxis de declaraci√≥n:</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { property([parameters]) {}, get property() {}, set property(value) {}, * generator() {} };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abreviatura de m√©todos generadores</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { * g() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> index++; } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> it = obj.g(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(it.next().value); // 1</span></span></code> </pre> <br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas las definiciones de m√©todos, excepto los m√©todos de generador, no pueden ser constructores y arrojar√°n un TypeError si intentas instanciarlos. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nombres de propiedades calculadas</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { [<span class="hljs-string"><span class="hljs-string">"foo"</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>](){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.foo2()); <span class="hljs-comment"><span class="hljs-comment">// 2 };</span></span></code> </pre> <br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La palabra clave static define m√©todos est√°ticos para una clase. </font><font style="vertical-align: inherit;">Los m√©todos est√°ticos se invocan sin crear instancias de su clase, y no se pueden invocar en instancias de la clase.</font></font><br><cut></cut><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaxis de getters y setters</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } get Name() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } set Name(newName) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(newName) != <span class="hljs-string"><span class="hljs-string">"string"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Name is not a string!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = newName; <span class="hljs-comment"><span class="hljs-comment">// Robert } } var robert = new Student('robert'); robert.Name = "Robert"; console.log(robert.Name);</span></span></code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> setter: necesario para la validaci√≥n de par√°metros escritos (como en el ejemplo anterior) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getter: necesario para obtener propiedades (aunque se pueden obtener directamente). </font><font style="vertical-align: inherit;">No puede tener argumentos</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No hay una encapsulaci√≥n integrada en ES6, pero puede organizarla usted mismo. </font></font> Por ejemplo, as√≠: <br><cut></cut><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Student = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> privateProps = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name, Age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-comment"><span class="hljs-comment">// public privateProps.set(this, {age: Age}); // private } get Age() { return privateProps.get(this).age; } set Age (newAge) { privateProps.set(this, {age: newAge}); } } return Person; })(); var robert = new Student('Robert', 19); robert.Age = 20; console.log(robert.Age); // 20</span></span></code> </pre> <br><cut></cut><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Herencia </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La palabra clave extendidos se utiliza en declaraciones de clase y expresiones de clase para crear una clase que es hija de otra clase. </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> (age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age = age; } sayAge () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> (name, age) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(age); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } sayFull () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Hello my name is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string"> and I'm </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.sayAge()}</span></span></span><span class="hljs-string"> years old`</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> robert = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Student(<span class="hljs-string"><span class="hljs-string">"Robert"</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(robert.sayFull()); <span class="hljs-comment"><span class="hljs-comment">// Hello my name is Robert and I'm 19 years old</span></span></code> </pre> <br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el constructor, la palabra clave super () se usa como una funci√≥n que llama al constructor padre. </font><font style="vertical-align: inherit;">Debe llamarse antes de la primera llamada a la palabra clave this en el cuerpo del constructor. </font><font style="vertical-align: inherit;">La palabra clave super tambi√©n se puede utilizar para llamar a funciones del objeto padre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando anula los m√©todos de la clase principal en la clase secundaria, los m√©todos de la clase secundaria se invocar√°n de manera predeterminada, pero puede llamar expl√≠citamente a los m√©todos de la clase primaria mediante la funci√≥n super ().</font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } displayName(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name.length; } } <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj_2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); } displayName() { <span class="hljs-comment"><span class="hljs-comment">//     return [this.name, super.displayName()]; } } var Obj = new obj_2("obj_2"); console.log(Obj.displayName()); // Array [ "obj_2", 5 ]</span></span></code> </pre><cut></cut><br><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extender objetos en l√≠nea con extend.</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este ejemplo extiende un objeto Date en l√≠nea.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myDate</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); } getFormattedDate() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> months = [ <span class="hljs-string"><span class="hljs-string">'Jan'</span></span>, <span class="hljs-string"><span class="hljs-string">'Feb'</span></span>, <span class="hljs-string"><span class="hljs-string">'Mar'</span></span>, <span class="hljs-string"><span class="hljs-string">'Apr'</span></span>, <span class="hljs-string"><span class="hljs-string">'May'</span></span>, <span class="hljs-string"><span class="hljs-string">'Jun'</span></span>, <span class="hljs-string"><span class="hljs-string">'Jul'</span></span>, <span class="hljs-string"><span class="hljs-string">'Aug'</span></span>, <span class="hljs-string"><span class="hljs-string">'Sep'</span></span>, <span class="hljs-string"><span class="hljs-string">'Oct'</span></span>, <span class="hljs-string"><span class="hljs-string">'Nov'</span></span>, <span class="hljs-string"><span class="hljs-string">'Dec'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getDate() + <span class="hljs-string"><span class="hljs-string">'-'</span></span> + months[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMonth()] + <span class="hljs-string"><span class="hljs-string">'-'</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getFullYear(); } }</code> </pre> <br><br><a name="section013"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promesa </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El objeto Promise se usa para c√°lculos diferidos y asincr√≥nicos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La promesa puede ser en tres estados:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pendiente: estado inicial, no completado y no rechazado. </font></font></li><li>  (fulfilled):   . </li><li>  (rejected):    . </li></ul><br>       (pending),      (fulfilled),    (),   (rejected),   .       ,     then. (         ,     , ..           ¬´ ¬ª, , ,      DOM.) <br><br>    Promise.prototype.then()  Promise.prototype.catch()   ,    ,  . <br><img src="https://habrastorage.org/getpro/habr/post_images/835/119/a5c/835119a5c72db92a1ae89730a7af1251.png" alt="imagen"><br><br> <b>  (promise)</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se crea un objeto Promise utilizando la nueva palabra clave y su constructor. </font><font style="vertical-align: inherit;">El constructor Promise toma un argumento llamado funci√≥n ejecutora como argumento. </font><font style="vertical-align: inherit;">Esta funci√≥n debe aceptar dos funciones de devoluci√≥n de llamada como par√°metros. </font><font style="vertical-align: inherit;">El primero (resolver) se llama cuando la operaci√≥n asincr√≥nica se completa con √©xito y devuelve el resultado de su ejecuci√≥n como un valor. </font><font style="vertical-align: inherit;">La segunda devoluci√≥n de llamada (rechazo) se llama cuando falla la operaci√≥n y devuelve un valor que indica el motivo del error, a menudo un objeto de error.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,    : resolve(someValue); //   //  reject("failure reason"); //  });</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un objeto de funci√≥n con dos argumentos, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resolver</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rechazar,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hace que la promesa tenga √©xito; el segundo la rechaza. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para proporcionar la funci√≥n con la funcionalidad de promesa, solo necesita devolver el objeto Promesa en ella.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAsyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, url); xhr.onload = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(xhr.responseText); xhr.onerror = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> reject(xhr.statusText); xhr.send(); }); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizando. </font><font style="vertical-align: inherit;">luego se adjuntan controladores de ejecuci√≥n y rechazo.</font></font><br><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©todos</font></font></b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.all (iterable): espera a que se ejecuten o rechacen todas las promesas para cualquiera de ellas. </font><font style="vertical-align: inherit;">Devuelve una promesa que se ejecutar√° despu√©s de que todas las promesas se ejecuten en iterable. </font><font style="vertical-align: inherit;">En el caso de que alguna de las promesas sea rechazada, Promise.all tambi√©n ser√° rechazada.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.allSettled (iterable): espera la finalizaci√≥n de todas las promesas recibidas (ejecuci√≥n y rechazo). </font><font style="vertical-align: inherit;">Devuelve una promesa que se ejecuta cuando se completan todas las promesas recibidas (ejecutadas o rechazadas), que contiene una matriz de los resultados de la ejecuci√≥n de las promesas recibidas.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.race (iterable): espera la ejecuci√≥n o el rechazo de cualquiera de las promesas recibidas. </font><font style="vertical-align: inherit;">Devuelve una promesa que se ejecutar√° o rechazar√° con el resultado de la ejecuci√≥n de la primera promesa ejecutada o rechazada de .iterable.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promise.reject (reason): devuelve una promesa rechazada debido a la raz√≥n. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promise.resolve (value): devuelve la promesa ejecutada con el valor del resultado. </font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prototipo de promesa</font></font></b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> catch (onRejected): agrega una funci√≥n de devoluci√≥n de llamada para manejar el rechazo de una promesa, que devuelve una nueva promesa hecha con el valor pasado si se llama, o el valor de resoluci√≥n original si se hizo la promesa. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> luego (onFulfilled, onRejected): agrega un cumplimiento de promesa y un controlador de rechazo, y devuelve una nueva promesa ejecutada con el valor del controlador llamado o el valor original si la promesa no se proces√≥ (es decir, si el controlador onFulfilled o onRejected correspondiente no es una funci√≥n). </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crear una solicitud http as√≠ncrona: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> URL = <span class="hljs-string"><span class="hljs-string">"https://getfestivo.com/v1/holidays?api_key=f8f42551-eb66-49d2-bcba-b8e42727ddfb&amp;country=US&amp;year=2019"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  API      function asyncHttpRequest (url) { return new Promise((resolve, reject) =&gt; { //  promise if (url == undefined) //     url reject(new Error("Expected url and received nothing")); else { resolve(() =&gt; { fetch(url).then((response) =&gt; { //   return response.json(); //    JSON   }).then((myJson) =&gt; { return(console.log(myJson)); //      }); }); } } );} asyncHttpRequest(URL).then((result) =&gt; result(), (error) =&gt; console.log(error));</span></span></code> </pre> <br><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede obtener m√°s ejemplos e informaci√≥n sobre promesas en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oficial </font><font style="vertical-align: inherit;">, as√≠ como en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentaci√≥n de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mozilla </font><font style="vertical-align: inherit;">.</font></font><br><br><a name="section014"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Iteradores </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Procesar cada elemento de una colecci√≥n es una operaci√≥n muy com√∫n. JavaScript proporciona varias formas de iterar sobre una colecci√≥n, desde un simple bucle for hasta map (), filter () y comprensiones de matriz. Los iteradores y generadores implementan el concepto de enumeraci√≥n directamente en el n√∫cleo del lenguaje y proporcionan un mecanismo para establecer el comportamiento para ... de los bucles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un objeto es un iterador si puede acceder a los elementos de la colecci√≥n de uno en uno, mientras rastrea su posici√≥n actual dentro de esta secuencia. En JavaScript, un iterador es un objeto que proporciona un m√©todo next () que devuelve el siguiente elemento de una secuencia. Este m√©todo devuelve un objeto con dos propiedades: hecho y valor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una vez creado, el objeto iterador se puede usar expl√≠citamente llamando al m√©todo next ().</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterable: este es un objeto cuyo contenido se puede iterar. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El objeto iterable difiere del no iterable en que tiene un m√©todo especial que devuelve un objeto para acceder al cual se usa un s√≠mbolo especial: Symbol.iterator</font></font><br><pre> <code class="javascript hljs">Iterable { [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]() }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El objeto que devuelve el m√©todo se llama formalmente un iterador. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El iterador solo tiene un m√©todo next ()</font></font><br><pre> <code class="javascript hljs">Iterator { next(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Que devuelve un objeto (llam√©moslo itreratorResult) con dos propiedades hechas y valor </font></font><br><pre> <code class="javascript hljs">IteratorResult { done, value }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hecho indica si todav√≠a hay un valor en la secuencia que se est√° buscando, y el valor contiene el siguiente elemento de la secuencia. </font></font><br><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de la inicializaci√≥n, se puede llamar al m√©todo next () para acceder a los pares clave-valor en el objeto uno por uno. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un objeto es iterable si define un m√©todo para enumerar valores, es decir, por ejemplo, c√≥mo se enumeran los valores en la construcci√≥n for..of. </font><font style="vertical-align: inherit;">Algunos tipos integrados, como Array o Map, son iterables de forma predeterminada, mientras que otros tipos, como Object, no lo son. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ser iterable, un objeto debe implementar el m√©todo iterador, lo que significa que (o uno de los objetos en la cadena del prototipo) debe tener una propiedad llamada Symbol.iterator. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As√≠ es como se ve el iterador est√°ndar:</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nextIndex &lt; array.length ? { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: array[nextIndex++], <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } : { <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; } } }</code> </pre> <br><br><a name="section015"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generadores </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los generadores son un tipo especial de funci√≥n que funciona como una f√°brica de iteradores. </font><font style="vertical-align: inherit;">Una funci√≥n se convierte en un generador si contiene una o m√°s declaraciones de rendimiento y utiliza la sintaxis de la funci√≥n *.</font></font><br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los generadores son un nuevo tipo de funci√≥n que puede pausar su ejecuci√≥n y devolver un resultado intermedio y reanudar la ejecuci√≥n m√°s tarde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veamos una funci√≥n regular que hace algunas matem√°ticas y devuelve un resultado:</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ a = a*<span class="hljs-number"><span class="hljs-number">2</span></span>; a = a - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// 9</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora eche un vistazo a una funci√≥n generadora similar: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ a = a*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> a; a = a - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> it = generator(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value); <span class="hljs-comment"><span class="hljs-comment">// 10 console.log(it.next().value); // 9&lt;/i&gt;</span></span></code> </pre> <cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como se indic√≥ anteriormente, los generadores pueden pausar su ejecuci√≥n y devolver un resultado intermedio. Este ejemplo muestra que en el momento de la primera llamada, la funci√≥n como si suspende su ejecuci√≥n en el primer punto de corte produce y devuelve el resultado de la primera expresi√≥n. En la segunda llamada, la funci√≥n contin√∫a desde el punto de interrupci√≥n anterior y se mueve a la siguiente, devolviendo el resultado de la siguiente expresi√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los generadores de funciones proporcionan una herramienta poderosa para escribir funciones secuenciales complejas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los generadores calculan los resultados de sus expresiones de rendimiento bajo demanda, lo que les permite trabajar eficientemente con secuencias con alta complejidad computacional, o incluso secuencias infinitas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El m√©todo next () tambi√©n toma un valor que puede usarse para cambiar el estado interno del generador. El valor pasado a next () se considerar√° como el resultado de la √∫ltima expresi√≥n de rendimiento que detuvo el generador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede forzar al generador a lanzar una excepci√≥n llamando a su m√©todo throw () y pasando el valor de la excepci√≥n que debe lanzarse como par√°metro. Esta excepci√≥n se lanzar√° desde el contexto de pausa actual del generador como si la declaraci√≥n de rendimiento en pausa actual fuera una declaraci√≥n de lanzamiento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la declaraci√≥n de rendimiento no se produce durante el manejo de la excepci√≥n lanzada, la excepci√≥n se pasa arriba a trav√©s de la llamada throw (), y el resultado de las llamadas posteriores a next () ser√° la propiedad done igual a true.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los generadores tienen un m√©todo de retorno (valor) que devuelve el valor dado y detiene el generador. </font></font><br><br><a name="section016"></a><h2>  S√≠mbolo </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol es un tipo de datos primitivo cuyas instancias son √∫nicas e inmutables. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el tiempo de ejecuci√≥n de JavaScript, se crea un valor de "s√≠mbolo" llamando a la funci√≥n Symbol (), que crea din√°micamente un valor an√≥nimo y √∫nico. </font><font style="vertical-align: inherit;">El √∫nico uso razonable es guardar el car√°cter y luego usar el valor almacenado para crear la propiedad del objeto.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando se utiliza un car√°cter como identificador en una asignaci√≥n de propiedad, la propiedad (por ejemplo, un car√°cter) es an√≥nima; </font><font style="vertical-align: inherit;">y tampoco contable. </font><font style="vertical-align: inherit;">Como la propiedad no es computable, no se mostrar√° en el bucle "for (... in ...)", y dado que la propiedad es an√≥nima, no se mostrar√° en la matriz de resultados "Object.getOwnPropertyNames ()". </font><font style="vertical-align: inherit;">El acceso a esta propiedad se puede obtener utilizando el valor inicial del s√≠mbolo que lo cre√≥ o iterando a trav√©s de la matriz de resultados "Object.getOwnPropertySymbols ()".</font></font><br><br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para que pueda crear una propiedad de personaje: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Alex"</span></span>, [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">"password"</span></span>)]: <span class="hljs-string"><span class="hljs-string">"12hsK3I"</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obtener una matriz de objetos de caracteres, use la propiedad Object.getOwnPropertySymbols (obj); </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para acceder a cualquier parte de su c√≥digo, use los m√©todos Symbol.for () y Symbol.keyFor (). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obtener m√°s informaci√≥n sobre el tipo de datos Sumbol, consulte la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oficial </font><font style="vertical-align: inherit;">y tambi√©n la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentaci√≥n de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mozilla.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460741/">https://habr.com/ru/post/460741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460729/index.html">Agradable y √∫til en la ense√±anza.</a></li>
<li><a href="../460731/index.html">Las autoridades estadounidenses completan una investigaci√≥n sobre un accidente de autob√∫s rob√≥tico en 2017</a></li>
<li><a href="../460735/index.html">CI \ CD para startups: qu√© herramientas hay y por qu√© no solo las utilizan grandes y conocidas empresas</a></li>
<li><a href="../460737/index.html">Escuche los antecedentes: Podcasts de gesti√≥n de proyectos</a></li>
<li><a href="../460739/index.html">Vinimos en paz de toda la humanidad.</a></li>
<li><a href="../460743/index.html">Gu√≠a para principiantes de Flutter</a></li>
<li><a href="../460745/index.html">Experiencia en el uso de un m√≥dulo GSM en dom√≥tica</a></li>
<li><a href="../460747/index.html">Busque ganancias o apriete las tuercas: Spotify ha dejado de trabajar directamente con los autores, ¬øqu√© significa?</a></li>
<li><a href="../460751/index.html">C√≥mo lanzamos robots en el peque√±o Chernobyl. Parte 1</a></li>
<li><a href="../460755/index.html">ROS Trolley Robot - Parte 1: Hierro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>