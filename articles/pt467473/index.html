<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçø üßë üë©üèø‚Äçü§ù‚Äçüë©üèª E mais sobre as sortes üö∂ ‚èπÔ∏è ‚öìÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="E mais sobre as sortes 
 Atrevo-me a levantar esse t√≥pico novamente. Come√ßarei com um link para um artigo de Mikhail Opanasenko (oms7) , que √© muito i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>E mais sobre as sortes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467473/"><h1>  E mais sobre as sortes </h1><br>  Atrevo-me a levantar esse t√≥pico novamente.  Come√ßarei com um link para um artigo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mikhail Opanasenko (oms7)</a> , que √© muito impressionante em termos de quantidade de trabalho realizado, bem como no n√∫mero de links citados.  Ele come√ßou a preparar seu material, sem conhecer esta publica√ß√£o, que posteriormente, ap√≥s a familiariza√ß√£o, levou √† necessidade de seu processamento substancial.  Para quem j√° leu este artigo, informo que, no meu material, s√£o estudados tipos mais diversos de dados, em particular cadeias de caracteres e n√∫meros reais, as bibliotecas boost e bsd, e s√£o mencionados alguns outros t√≥picos ausentes do artigo. <br><a name="habracut"></a><br>  Existem dezenas de maneiras diferentes de organizar os itens de dados em ordem.  Entre eles, existem aqueles que trabalham r√°pido, como, por exemplo, eles podem classificar qualquer matriz de dados localizada na RAM do computador em no m√°ximo minutos.  Mais especificamente, pode-se dizer que a classifica√ß√£o r√°pida organiza um bilh√£o de n√∫meros inteiros em um bom computador pessoal moderno em menos de cem segundos.  Se voc√™ usar m√©todos lentos e primitivos, por exemplo, classifica√ß√£o de bolhas ou classifica√ß√£o, para classificar um n√∫mero maior de elementos, o tempo gasto nesse processamento de dados poder√° exceder qualquer expectativa - esse "processamento" pode levar v√°rios dias, semanas e at√© anos.  Essa grande diferen√ßa √© causada pelo fato de o tempo de classifica√ß√£o por m√©todos r√°pidos levar aproximadamente proporcional a <i>N</i> log <i>N</i> e primitivo - <i>N</i> <sup>2</sup> .  Com o aumento de <i>N, a</i> diferen√ßa entre os dois valores se torna muito percept√≠vel.  Portanto, √© razo√°vel usar m√©todos primitivos apenas para trabalhar com dados pequenos, por exemplo, em computadores modernos, com v√°rios milhares de elementos.  Tamb√©m √© natural us√°-los para ensinar os conceitos b√°sicos de programa√ß√£o e pensamento l√≥gico, uma vez que s√£o muito mais simples que os m√©todos r√°pidos. <br><br>  Gostaria de entender os m√©todos de classifica√ß√£o existentes nas bibliotecas padr√£o atuais.  Descubra qu√£o grande √© a diferen√ßa entre eles em termos de suas principais caracter√≠sticas, velocidade do trabalho e tamb√©m seus recursos.  Al√©m disso, consideraremos ao longo do caminho para compara√ß√£o e exerc√≠cios para a mente alguns m√©todos que n√£o s√£o dif√≠ceis de implementar.  Tamb√©m √© importante notar que o otimizador do compilador GCC e possivelmente outros bons compiladores funcionam muito bem, acelerando o c√≥digo v√°rias vezes (√†s vezes at√© mais de 5 vezes). <br><br>  Vamos come√ßar com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o m√©todo de</a> classifica√ß√£o de bolhas como o mais simples e o mais lento.  De acordo com esse m√©todo, voc√™ precisa percorrer a matriz de dados repetidamente, comparando elementos vizinhos e alterando seus lugares se a ordem entre eles for quebrada.  Ap√≥s cada passagem, pelo menos um elemento (o maior ou o menor - depende da ordem selecionada) est√° em seu lugar.  Al√©m da simplicidade, esse m√©todo possui mais uma vantagem: n√£o requer mem√≥ria adicional.  √â poss√≠vel observar mais um recurso do m√©todo da bolha - ele processa muito rapidamente os dados j√° solicitados e, em alguns casos, o torna um dos m√©todos mais r√°pidos.  Se os dados forem solicitados apenas parcialmente, esse m√©todo funcionar√° com eles mais rapidamente, mas na maioria dos casos apenas muito levemente.  Para testes, usei a seguinte <a href="">implementa√ß√£o</a> . <br><br>  Outro m√©todo lento √© a classifica√ß√£o por sele√ß√£o.  Aqui, em cada passagem, os elementos maiores e menores dos dados s√£o encontrados primeiro e, em seguida, esses elementos s√£o colocados nas posi√ß√µes extremas correspondentes √† ordem selecionada.  Na pr√≥xima passagem, classificamos os dados sem esses elementos extremos.  Esse m√©todo √© t√£o simples quanto a classifica√ß√£o de bolhas e tamb√©m n√£o requer mem√≥ria adicional, mas √© visivelmente mais r√°pido.  Al√©m disso, a classifica√ß√£o por esse m√©todo realiza um n√∫mero m√≠nimo de permuta√ß√µes de elementos de dados.  Portanto, quando as permuta√ß√µes s√£o muito mais lentas que as compara√ß√µes, a ordena√ß√£o pelo m√©todo de sele√ß√£o pode ser aceit√°vel se o n√∫mero de elementos de dados for pequeno.  Aqui est√° a minha <a href="">implementa√ß√£o</a> .  Com mais freq√º√™ncia, essa classifica√ß√£o √© realizada, colocando apenas um elemento por passagem.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A</a> classifica√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pilha</a> (ou piramidal), que ser√° discutida mais adiante, √© a vers√£o mais avan√ßada da classifica√ß√£o em quest√£o. <br><br>  O c√≥digo do √∫ltimo m√©todo considerado lento, a classifica√ß√£o por inser√ß√£o, √© provavelmente o menor de todos os c√≥digos que implementam a classifica√ß√£o; portanto, esse m√©todo √†s vezes √© usado por classifica√ß√µes r√°pidas complexas para casos em que o n√∫mero de itens a serem classificados √© pequeno (v√°rias dezenas).  √â um pouco semelhante √† classifica√ß√£o por uma bolha, pois aqui e ali os elementos vizinhos s√£o comparados sucessivamente.  Mas a classifica√ß√£o por inser√ß√µes procura o pr√≥ximo elemento para a posi√ß√£o correta na parte j√° classificada dos dados, e n√£o apenas empurra o elemento extremo para a posi√ß√£o extrema.  Com essa abordagem, tamb√©m n√£o √© necess√°ria mem√≥ria adicional.  Como a classifica√ß√£o por bolhas, a classifica√ß√£o por inser√ß√£o √© muito r√°pida nos dados solicitados e mais r√°pida nos dados parcialmente solicitados.  Neste √∫ltimo caso, significativamente mais r√°pido que a bolha.  Normalmente, a classifica√ß√£o por inser√ß√µes √© um pouco mais r√°pida que a sele√ß√£o por sele√ß√£o.  E, ao contr√°rio do √∫ltimo, ele, como a classifica√ß√£o de bolhas, √© est√°vel.  O pior de tudo √© que a classifica√ß√£o por inser√ß√£o funciona com os dados na ordem inversa, com a qual √†s vezes se torna o mais lento e o mais lento.  Para testes, a seguinte <a href="">implementa√ß√£o</a> foi usada.  Pode ser acelerado um pouco se voc√™ usar a pesquisa n√£o linear, mas a bin√°ria, por exemplo, usando a fun√ß√£o std :: bsearch.  Uma acelera√ß√£o significativa pode ser alcan√ßada usando uma estrutura de tipo de lista, a inser√ß√£o de um elemento no qual √© muito r√°pido.  Voc√™ tamb√©m pode perceber que essa √© a classifica√ß√£o mais natural - por exemplo, geralmente √© usada intuitivamente ao jogar cartas. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A</a> classifica√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">shell</a> √© a mais simples dentre os m√©todos r√°pidos e √© bastante adequada para os alunos que est√£o come√ßando a aprender programa√ß√£o.  √â apenas uma modifica√ß√£o da classifica√ß√£o das bolhas.  A √∫nica diferen√ßa entre eles √© que, na classifica√ß√£o de Shell, a dist√¢ncia entre os elementos comparados √© tomada variando de passagem para passagem, de maior na primeira passagem, a 1 na √∫ltima, assim, nessas √∫ltimas passagens, o m√©todo Shell degenera em uma classifica√ß√£o primitiva por uma bolha.  Donald Shell publicou o algoritmo b√°sico de classifica√ß√£o que recebeu esse nome em 1959.  Portanto, essa √© uma das primeiras classifica√ß√µes universais que funcionam rapidamente.  Para compara√ß√£o, o algoritmo de classifica√ß√£o r√°pida foi publicado dois anos depois, e a classifica√ß√£o popular de Tim ou classifica√ß√£o introspectiva ficou conhecida apenas nos anos 90.  V√°rios problemas matem√°ticos interessantes n√£o resolvidos est√£o associados √† classifica√ß√£o do Shell, o principal deles √© como selecionar de maneira otimizada os deslocamentos entre os elementos comparados.  Algumas seq√º√™ncias de registros foram encontradas, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A102549</a> .  Essas seq√º√™ncias s√£o encontradas atrav√©s de c√°lculos colossais, portanto, possuem um comprimento muito curto; o A102549 possui apenas 8 elementos, o que √© suficiente apenas para dados de at√© 3.000 elementos.  Para big data, as sequ√™ncias precisam ser vistas quase aleatoriamente.  Valores usados ‚Äã‚Äãpr√≥ximos √†s pot√™ncias de 2, <i>e</i> , 2,25 e 3. Os n√∫meros primos pr√≥ximos √†s pot√™ncias de 2 apresentaram os piores resultados, visivelmente inferiores aos melhores.  Mas as outras tr√™s op√ß√µes foram aproximadamente as mesmas em termos de impacto no desempenho e provavelmente muito pr√≥ximas do ideal.  Al√©m disso, nesses tr√™s casos, o uso de n√∫meros primos n√£o deu vantagens tang√≠veis.  √â curioso que os vieses propostos na Wikipedia (com base em 2,25) baseados em refer√™ncias aos trabalhos correspondentes n√£o tenham apresentado os melhores resultados nos testes, embora suas diferen√ßas em rela√ß√£o aos melhores tenham sido muito insignificantes (n√£o mais que 5-10%).  Usar o A102549 como ponto de partida tamb√©m n√£o deu nenhum resultado percept√≠vel.  Mikhail Opanasenko tamb√©m tentou desvendar a classifica√ß√£o da Shell e obteve um resultado interessante de que os deslocamentos selecionados pela f√≥rmula <i>s <sub>n + 1</sub> = 10s <sub>n</sub> / 3</i> produzem um efeito muito bom e talvez at√© pr√≥ximo do ideal.  Meus resultados confirmam isso.  Em muitos casos, foram esses vieses que deram o melhor resultado, embora esse nem sempre tenha sido o caso e a diferen√ßa do resultado mais pr√≥ximo foi bastante pequena (cerca de 5%).  Meu <a href="">c√≥digo</a> para implementar as classifica√ß√µes do Shell usa pequenas tabelas com deslocamentos, embora se voc√™ n√£o usar n√∫meros primos, esses deslocamentos para tabelas podem ser calculados quase instantaneamente, como foi feito na implementa√ß√£o de uma das variantes fornecidas dessa classifica√ß√£o. <br><br>  √â interessante que, se tirarmos as compensa√ß√µes pr√≥ximas √†s pot√™ncias dos triplos de uma maneira um pouco diferente e usarmos um algoritmo ligeiramente diferente (ver <a href="">implementa√ß√£o</a> ), em n√∫meros de 32 bits obteremos velocidades pr√≥ximas das melhores, mas em n√∫meros mais longos e nas linhas obteremos uma desacelera√ß√£o significativa, √†s vezes mais de 100%.  Os resultados para o melhor algoritmo usado por oms7 tamb√©m est√£o na tabela abaixo, mas, embora mostre bons resultados em ordem, fica significativamente atr√°s dos l√≠deres em termos de valores absolutos. <br><br>  Alguma vez haver√° uma maneira de encontrar as melhores compensa√ß√µes?  Talvez, mas ouso sugerir que n√£o √© t√£o cedo.  A classifica√ß√£o de shell √© usada no kernel do Linux e, em pelo menos uma biblioteca C, seu c√≥digo √© usado para a fun√ß√£o qsort () padr√£o.  Foi teoricamente provado que a velocidade ideal de classifica√ß√£o da Shell √© apenas um pouco mais lenta que os m√©todos logar√≠tmicos r√°pidos "reais".  De fato, a depend√™ncia do tempo m√©dio de processamento de dados em seu tamanho para a classifica√ß√£o ideal de Shell √© descrita pela f√≥rmula ‚àΩ <i>N</i> (log <i>N</i> / log log <i>N</i> ) <sup>2</sup> , que mesmo para <i>N</i> muito grande <i>√©</i> muito pr√≥xima da f√≥rmula ‚àΩ <i>N</i> log <i>N</i> t√≠pica para outros m√©todos r√°pidos.  Geralmente, a classifica√ß√£o do shell geralmente √© ainda mais r√°pida do que os m√©todos teoricamente mais r√°pidos e s√≥ come√ßa a render um pouco para eles ao processar matrizes bastante grandes (da ordem de 10 milh√µes de elementos).  Essa classifica√ß√£o absolutamente n√£o precisa de mem√≥ria adicional e se comporta de maneira est√°vel para uma ampla variedade de op√ß√µes para o preenchimento de dados, comparando favoravelmente com as classifica√ß√µes r√°pidas.  O m√©todo Shell n√£o possui a propriedade de estabilidade. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A</a> classifica√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">r√°pida</a> √© apenas um pouco mais complexa que o algoritmo Shell e ainda √© a maneira mais r√°pida de organizar dados dispersos aleatoriamente.  No entanto, essa classifica√ß√£o tem v√°rias desvantagens.  Ela precisa de mem√≥ria adicional e, em casos muito raros, funciona extremamente devagar, de acordo com uma depend√™ncia quadr√°tica.  A id√©ia principal desse m√©todo √© dividir os dados em duas partes: os dados em uma parte devem ser mais ou menos (depende da ordem selecionada) do que na outra.  Existem v√°rios m√©todos para essa separa√ß√£o.  Idealmente, com cada divis√£o, ambas as partes devem ter aproximadamente o mesmo tamanho e, o pior de tudo, quando uma das partes acaba por ser composta por apenas um elemento durante a divis√£o.  Vamos considerar v√°rias implementa√ß√µes de algoritmos de classifica√ß√£o r√°pida, em particular <a href="">o m√©todo Hoar</a> , no qual um elemento de refer√™ncia que divide os dados em duas partes √© selecionado no meio dos dados classificados. <br><br>  Tamb√©m consideramos o <a href="">algoritmo Lomuto</a> extremamente compacto, que √†s vezes √© ligeiramente (cerca de 1%) mais r√°pido do que o m√©todo Hoare considerado.  No entanto, em casos especiais t√≠picos, por exemplo, em dados ordenados, inversos ou malovariantes, o m√©todo Lomuto mostra lentid√£o extrema.  Al√©m disso, entre as op√ß√µes consideradas para a classifica√ß√£o r√°pida, essa foi a mais gananciosa para o tamanho da pilha durante execu√ß√µes pr√°ticas: ao classificar matrizes relativamente pequenas, apenas essa classifica√ß√£o n√£o tinha 8 megabytes suficientes para a pilha, tive que definir esse tamanho com ulimite mais.  Essa gan√¢ncia pela pilha leva a grandes lentid√µes ao processar grandes dados (dezenas de milh√µes de linhas), e estou tendo dificuldade em chamar sua natureza.  S√≥ posso afirmar que √© melhor n√£o usar essa classifica√ß√£o do pr√≥ximo par√°grafo com esses dados. <br><br>  O m√©todo Lomuto seleciona o √∫ltimo elemento como o de refer√™ncia, mas √© poss√≠vel implementar a classifica√ß√£o r√°pida sem nenhum <a href="">elemento de suporte</a> , mais precisamente, a sele√ß√£o de um desses elementos aqui ocorre como resultado da bissec√ß√£o de dados j√° realizada.  Essa classifica√ß√£o por caracter√≠sticas de velocidade mostrou-se pr√≥xima ao m√©todo Lomuto, embora geralmente seja um pouco mais r√°pido e, em casos extremos, √© visivelmente mais r√°pida que Lomuto, mas mais lenta que Hoar. <br><br>  Em 2009, um <a href="">algoritmo de</a> classifica√ß√£o r√°pida de duas √¢ncoras foi publicado, que se tornou padr√£o para a linguagem Java.  Esse algoritmo reduz o n√∫mero de permuta√ß√µes em 20% em compara√ß√£o com as melhores, mas o n√∫mero de compara√ß√µes n√£o muda.  Seu autor √© Vladimir Yaroslavsky.  Ele realmente funciona, via de regra, mais r√°pido do que outros tipos r√°pidos.  Eu o otimizei um pouco, usando o fato conhecido de que na arquitetura x86, o swap geralmente funciona mais r√°pido que a atribui√ß√£o, e para cadeias de caracteres C ++ √© muito, muito mais r√°pido.  Todas as classifica√ß√µes r√°pidas consideradas at√© agora n√£o possuem a propriedade de estabilidade. <br><br>  √â necess√°ria mem√≥ria adicional para classifica√ß√£o r√°pida para organizar chamadas recursivas.  No entanto, a segunda chamada pode ser substitu√≠da por um loop, otimizando a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recurs√£o</a> da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cauda</a> , que em termos de velocidade pode n√£o gerar ganhos, mas reduz significativamente o tamanho dos dados adicionais utilizados.  Eu implementei a op√ß√£o de classifica√ß√£o Hoar com essa otimiza√ß√£o.  Al√©m disso, nos programas do sistema, voc√™ pode verificar o ponteiro da pilha e, se ele se aproximar de um valor cr√≠tico, pode simplesmente redefinir todas as chamadas recursivas e come√ßar a classificar novamente - nesse caso, √© √≥bvio que voc√™ precisa usar a op√ß√£o de classifica√ß√£o r√°pida que n√£o diminui a velocidade dos dados quase pedidos, por exemplo , a vers√£o proposta acima do Hoar.  Combater o uso de mem√≥ria adicional pode ser considerado a id√©ia principal da classifica√ß√£o r√°pida da biblioteca de idiomas C padr√£o no GCC.  Geralmente abandonava a recurs√£o.  Em vez disso, eles usam a simula√ß√£o, que permite que um ter√ßo reduza a carga na pilha.  O c√≥digo ficou bastante grande, cerca de 150 linhas.  Sobre essa classifica√ß√£o, ainda haver√° um pouco de material abaixo. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A</a> classifica√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hash</a> pode ser muito r√°pida, pr√≥xima a <i>N.</i>  No entanto, √†s vezes pode funcionar em uma depend√™ncia quadr√°tica.  A velocidade deste m√©todo de classifica√ß√£o √© muito dependente da entrada.  Se os dados forem distribu√≠dos uniformemente pela fun√ß√£o hash na matriz auxiliar, obtemos o relacionamento linear mais r√°pido.  E se todos os dados estiverem agrupados pr√≥ximos a v√°rios "centros de massa" distantes ou quando houver muitos elementos de dados id√™nticos, ou seja, quando ocorrerem muitas colis√µes de hash, obteremos o pior tipo <sup>de</sup> depend√™ncia ‚àΩ <i>N2</i> .  Como na classifica√ß√£o em √°rvore, para classificar o hash, s√£o necess√°rios muitos dados adicionais. Na <a href="">lista de</a> c√≥digos <a href="">abaixo</a> , s√£o necess√°rios, por exemplo, 12 bytes adicionais para cada n√∫mero inteiro classific√°vel (int32, x86-64).  Uma propriedade interessante da classifica√ß√£o de hash √© a aus√™ncia de opera√ß√µes de compara√ß√£o entre elementos de dados, que distingue essa classifica√ß√£o de todas as consideradas acima.  Mais precisamente, essas opera√ß√µes s√£o necess√°rias apenas para colis√µes.  Ao classificar dados em que a chave corresponde ao elemento de dados inteiro, voc√™ pode usar um contador adicional para o n√∫mero de elementos id√™nticos, mas essa √© uma otimiza√ß√£o duvidosa.  Voc√™ tamb√©m pode usar uma √°rvore bin√°ria em vez de uma lista para armazenar dados de colis√£o de hash, isso acelera bastante o trabalho para casos particulares individuais quando h√° muitas colis√µes, mas no geral, ao usar uma √°rvore bin√°ria, em muitos casos ela fica lenta e isso apesar do fato de que, neste caso, o elemento os dados precisam armazenar quase 100 bytes de informa√ß√µes adicionais.  Eu implementei <a href="">tr√™s op√ß√µes para a</a> classifica√ß√£o de hash usando uma √°rvore bin√°ria: uma usa uma √°rvore n√£o ordenada e as outras duas usam √°rvores padr√£o das bibliotecas std e boost.  A classifica√ß√£o de hash √© praticamente inadequada para a classifica√ß√£o de seq√º√™ncias de texto, exceto as muito curtas, pois √© imposs√≠vel criar uma boa fun√ß√£o de hash para esses dados.  N√£o consegui adaptar o hash C ++ padr√£o (unordered_multiset) para classificar: tentei usar fun√ß√µes hash mon√≥tonas e ordenar rela√ß√µes em vez de igualdade - isso n√£o funcionou. <br><br>  A classifica√ß√£o da matriz √© muito semelhante √† anterior.  Tamb√©m √© usada uma matriz auxiliar, na qual os valores s√£o inseridos pela fun√ß√£o hash.  No caso de uma colis√£o, √© necess√°rio deslocar o fragmento cont√≠nuo dos elementos ocupados para a posi√ß√£o esquerda ou direita, liberando a posi√ß√£o indicada pela fun√ß√£o hash para o novo elemento.  Para obter uma boa velocidade, √© necess√°rio que a matriz auxiliar seja v√°rias vezes (de 2 a 3) mais que a original.  Com um aumento no tamanho da matriz auxiliar, a velocidade aumenta apenas para um determinado limite, dependendo dos dados classificados e da fun√ß√£o hash associada a eles, e depois (normalmente de 4-5) diminui.  A velocidade de opera√ß√£o √© quase a mesma que a do hash, mas com dados bons um pouco mais r√°pidos e com dados ruins, √© visivelmente mais lenta.  Esse tipo tamb√©m precisa de muita mem√≥ria extra.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se limitarmos o n√∫mero de elementos na matriz classificada a pouco mais de quatro bilh√µes, uma matriz auxiliar tripla exigir√° a mesma quantidade de dados adicionais que a classifica√ß√£o com um hash, e uma tripla exigir√° 28 bytes, o que √© notavelmente menor do que o da classifica√ß√£o por uma √°rvore ou muito menos do que o hash com √°rvores. Essa classifica√ß√£o tamb√©m √© quase inadequada para trabalhar com strings. N√£o existe um artigo da Wikipedia sobre esse algoritmo, mas aqui est√° minha </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementa√ß√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curiosamente, na Wikipedia, em um bom </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vis√£o geral </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">, n√£o</font></a><font style="vertical-align: inherit;"> h√° men√ß√£o de m√©todos intermedi√°rios, como classifica√ß√£o de matriz e hash, que naturalmente podem ser colocados entre m√©todos com base na compara√ß√£o de elementos e m√©todos com base no valor absoluto dos elementos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma das classifica√ß√µes mais r√°pidas, que nunca usa compara√ß√µes, √© a </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">classifica√ß√£o bit</font></a><font style="vertical-align: inherit;"> a </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">bit</font></a><font style="vertical-align: inherit;"> conhecida desde o s√©culo XIX.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(classifica√ß√£o do radical). A ideia dela √© muito simples - voc√™ precisa trabalhar com grupos de bits de representa√ß√£o de dados (para testes fiz grupos de 8, 11 e 16 bits). As tabelas s√£o criadas para cada grupo e os resultados s√£o combinados de maneira relativamente simples. Existem duas maneiras principais de usar a classifica√ß√£o bit a bit. √â mais conveniente usar os d√≠gitos para classificar n√∫meros da direita para a esquerda (esta √© a op√ß√£o LSD - Menos D√≠gito Significativo) e para classificar cadeias da esquerda para a direita (essa √© a op√ß√£o MSD - D√≠gito Mais Significativo). A classifica√ß√£o bit a bit geralmente √© significativamente mais r√°pida que qualquer outro m√©todo de pedido de dados. Surpreendentemente, o suporte √† classifica√ß√£o bit a bit ainda n√£o √© muito significativo: ele n√£o est√° no boost nem na biblioteca C ++ padr√£o; eu nem conhe√ßo sua vers√£o para qualquer biblioteca conhecida por trabalhar com n√∫meros ou seq√º√™ncias de caracteres C ++. Este tipo tem√© claro, e desvantagens. √â muito sens√≠vel ao tipo de dados para classifica√ß√£o, por exemplo, voc√™ precisa ter sua pr√≥pria vers√£o dessa classifica√ß√£o para dados de cada tamanho, precisa fazer op√ß√µes especiais para n√∫meros inteiros n√£o assinados e assinados, e o suporte ao trabalho com n√∫meros reais pode exigir muito esfor√ßo. Ao usar a ordem do byte menos significativo ao mais importante, sua variante geralmente requer mem√≥ria adicional, um pouco mais do que para os dados iniciais (isso √© significativamente menor do que para a classifica√ß√£o por um hash ou matriz, e ainda mais por uma √°rvore). Al√©m disso, essa op√ß√£o √© pouco √∫til para classificar seq√º√™ncias longas. Meu c√≥digo para esse tipovoc√™ precisa fazer op√ß√µes especiais para n√∫meros inteiros n√£o assinados e assinados, e o suporte para trabalhar com n√∫meros reais pode exigir bastante esfor√ßo. Ao usar a ordem do byte menos significativo ao mais importante, sua variante geralmente requer mem√≥ria adicional, um pouco mais do que para os dados iniciais (isso √© significativamente menor do que para a classifica√ß√£o por um hash ou matriz, e ainda mais por uma √°rvore). Al√©m disso, essa op√ß√£o √© pouco √∫til para classificar seq√º√™ncias longas. Meu c√≥digo para esse tipovoc√™ precisa fazer op√ß√µes especiais para n√∫meros inteiros n√£o assinados e assinados, e o suporte para trabalhar com n√∫meros reais pode exigir bastante esfor√ßo. Ao usar a ordem do byte menos significativo ao mais importante, sua variante geralmente requer mem√≥ria adicional, um pouco mais do que para os dados iniciais (isso √© significativamente menor do que para a classifica√ß√£o por um hash ou matriz, e ainda mais por uma √°rvore). Al√©m disso, essa op√ß√£o √© pouco √∫til para classificar seq√º√™ncias longas. Meu c√≥digo para esse tipoEsta op√ß√£o n√£o √© adequada para classificar seq√º√™ncias longas. Meu c√≥digo para esse tipoEsta op√ß√£o n√£o √© adequada para classificar seq√º√™ncias longas. Meu c√≥digo para esse tipo</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ele se baseia no c√≥digo do artigo oms7 mencionado. A op√ß√£o de ordem inversa de bytes √© mais vers√°til e muito adequada para a classifica√ß√£o de strings. Essa op√ß√£o pode ser implementada sem o uso de mem√≥ria adicional (o pre√ßo disso √© a perda da propriedade de estabilidade), como √© feito na fun√ß√£o radixsort () da biblioteca bsd. Meu </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√≥digo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para esta op√ß√£o, ela tamb√©m √© baseada no c√≥digo oms7, usa mem√≥ria extra, dados de origem um pouco maiores, possui a propriedade de estabilidade, mas n√£o √© otimizada para strings e, portanto, apresenta caracter√≠sticas de desempenho significativamente piores que a fun√ß√£o semelhante sradixsort () da biblioteca bsd j√° mencionada . Essa classifica√ß√£o pode mostrar resultados surpreendentemente ruins ao trabalhar com pequenas matrizes num√©ricas, trabalhando v√°rias ordens de magnitude mais lentas que as bolhas, embora falemos de valores muito pequenos de n√£o mais do que alguns milissegundos e essa diferen√ßa n√£o √© f√°cil de notar. Isso se deve ao fato de usar matrizes auxiliares de tamanho pequeno, mas ao classificar dados de tamanho pequeno, esses tamanhos pequenos podem ser maiores que os pr√≥prios dados classificados.Para evitar lentid√µes, a op√ß√£o "da esquerda para a direita" usa a classifica√ß√£o de inser√ß√£o em vez da principal nesses casos. Em conclus√£o, vale a pena notar que esta √© a √∫nica classifica√ß√£o relativamente popular conhecida por mim que sempre funciona com confiabilidade a uma velocidade de ‚àΩ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas o coeficiente de proporcionalidade aqui depende do tamanho dos elementos de dados e, para cadeias ou n√∫meros longos, pode ser bastante percept√≠vel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma op√ß√£o para classifica√ß√£o MSD bit a bit √© a classifica√ß√£o por </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">feixe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , uma estrutura de dados que permite colocar com efici√™ncia as chaves de uma matriz associativa. Minha </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementa√ß√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , apesar de otimizar o uso da mem√≥ria, ainda se mostrou muito gananciosa por isso. Por velocidade, os melhores resultados foram obtidos na classifica√ß√£o das linhas longas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, consideraremos algumas classifica√ß√µes que podem ser encontradas nas bibliotecas padr√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos come√ßar com o r√°pido da biblioteca C padr√£o (qsort, uma variante do GCC), eu j√° escrevi sobre isso. S√≥ posso acrescentar aqui que essa classifica√ß√£o e outras classifica√ß√µes C (por exemplo, as seguintes da biblioteca BSD) n√£o s√£o adequadas para trabalhar com dados de objetos, em particular cadeias C ++, causadas pelo fato de que esses dados n√£o s√£o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tendo a fonte, o problema pode ser facilmente resolvido substituindo opera√ß√µes memcpy por atribui√ß√µes regulares. Voc√™ tamb√©m pode notar que, em algumas bibliotecas C padr√£o, essa classifica√ß√£o pode n√£o ser necessariamente r√°pida, pode ser substitu√≠da por outras. Na vers√£o atual do GCC, essa classifica√ß√£o ainda possui a propriedade de estabilidade. √Äs vezes, havia surpresas com as c-ordena√ß√µes mencionadas ao coletar dados, por exemplo, ao trabalhar com o tipo std :: vector atrav√©s de um objeto funcional, elas poderiam criar dificuldades - eu recomendo us√°-lo com dados de objeto com cautela. De acordo com as execu√ß√µes, essa classifica√ß√£o √†s vezes √© relativamente lenta: √© notavelmente inferior em velocidade a outras implementa√ß√µes de classifica√ß√£o r√°pida ao trabalhar com n√∫meros, mas ao trabalhar com strings si √© melhor, apenas a classifica√ß√£o com dois pontos de controle √†s vezes o leva adiante,mas em linhas longas, o qsort padr√£o quase sempre o ultrapassa. O mais interessante foi descoberto quando tentei classificar um bilh√£o de n√∫meros inteiros com sua ajuda - descobriu-se que o preenchimento do tipo 7 leva a uma depend√™ncia de tempo pr√≥xima a uma lei quadr√°tica, ou seja, a um poss√≠vel "processamento" com dura√ß√£o de v√°rios anos (n√£o esperei pelo fim e o parei √†s 21 horas de execu√ß√£o). Com menos dados, essa classifica√ß√£o geralmente pode selecionar pontos de ancoragem com os quais trabalha rapidamente.Com menos dados, essa classifica√ß√£o geralmente pode selecionar pontos de ancoragem com os quais trabalha rapidamente.Com menos dados, essa classifica√ß√£o geralmente pode selecionar pontos de ancoragem com os quais trabalha rapidamente.</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> classifica√ß√£o </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">introspectiva</font></a><font style="vertical-align: inherit;"> √© usada na biblioteca padr√£o C ++, embora o m√©todo exato usado em std :: sort dependa da implementa√ß√£o, fornecendo informa√ß√µes apenas sobre o GCC. De acordo com as execu√ß√µes, este √© o segundo mais r√°pido ap√≥s a classifica√ß√£o por dispers√£o ao trabalhar com n√∫meros, e a vantagem da classifica√ß√£o por dispers√£o √© pequena (de quase 0 a 30%), mas com a classifica√ß√£o por sequ√™ncia tudo √© muito pior - pode ser 3-4 vezes menor que os l√≠deres . Essa √©, na verdade, uma classifica√ß√£o r√°pida, na qual dois casos especiais s√£o levados em considera√ß√£o: 1) se o n√∫mero de recurs√µes se tornar muito grande, ocorre a troca para a classifica√ß√£o por heap; 2) se o n√∫mero de elementos para classifica√ß√£o for pequeno, ocorrer√° a troca para classifica√ß√£o por inser√ß√µes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classifica√ß√£o est√°vel da biblioteca padr√£o C ++ ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: stable_sort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), como o nome indica, tem a propriedade de estabilidade - preserva a ordem relativa entre os elementos com a mesma chave. Essa propriedade √© relativamente raramente necess√°ria, embora eu escreva sobre ela de forma infundada, apenas com base em minha pr√≥pria experi√™ncia. Ele pode usar mem√≥ria adicional, o que o torna mais r√°pido. Surpreendentemente, essa classifica√ß√£o geralmente √© mais r√°pida que std :: sort. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No python de linguagem super popular, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> classifica√ß√£o </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">de Tim</font></a><font style="vertical-align: inherit;"> √© usada como padr√£o </font><font style="vertical-align: inherit;">. Para testes, usei sua vers√£o no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reposit√≥rio github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ele mostra bons resultados recordes em dados parcialmente pedidos, mas, em m√©dia, ainda √© visivelmente mais lento que os l√≠deres. Geralmente, sua velocidade √© a m√©dia entre a classifica√ß√£o r√°pida e a classifica√ß√£o da Shell, embora nas linhas √†s vezes esteja pr√≥xima dos l√≠deres. Tem a propriedade de estabilidade. Ele implementa um algoritmo relativamente complicado, na implementa√ß√£o padr√£o do qual um erro foi descoberto em 2015, o que, no entanto, requer uma situa√ß√£o pouco realista para sua manifesta√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A biblioteca BSD C possui classifica√ß√£o bit a bit ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">radixsort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) e sua vers√£o est√°vel (sradixsort). Infelizmente, esses dois tipos podem ser usados ‚Äã‚Äãapenas para cordas C. Como ser√° visto nos dados de teste, esta √© a maneira mais r√°pida de classificar seq√º√™ncias de caracteres hoje e, portanto, √© surpreendente que n√£o exista uma op√ß√£o padr√£o para seq√º√™ncias de caracteres C ++. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A biblioteca BSD C tem mais sorte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merge</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a mergesort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Essa classifica√ß√£o √© conhecida como uma das mais r√°pidas para dados de acesso seq√ºencial (arquivos, listas) e provavelmente √© usada na biblioteca padr√£o C ++ para classificar listas (std :: list e std :: forward_list). A prop√≥sito, ela era conhecida desde 1948 e um de seus desenvolvedores era um matem√°tico muito conhecido e especialista nos primeiros sistemas de computadores von Neumann. Dos m√©todos r√°pidos, essa classifica√ß√£o n√£o se distingue pelas melhores caracter√≠sticas, embora, como regra, seja um pouco mais r√°pida que os m√©todos Shell. Requer mem√≥ria adicional e geralmente √© implementado de maneira sustent√°vel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, ainda h√° uma classifica√ß√£o por </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v√°rios</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(mont√£o). O heap geralmente √© usado para enfileiramento ideal com prioridades, mas tamb√©m pode ser usado para classifica√ß√£o. Os heaps de classifica√ß√£o n√£o requerem mem√≥ria adicional, mas n√£o possuem a propriedade de estabilidade. Na velocidade dos n√∫meros, √© significativamente (at√© 3-6 vezes) mais lento que os m√©todos Shell, mas para linhas n√£o muito curtas, mostra resultados muito bons, ultrapassando (com o aumento do comprimento da linha, a vantagem aumenta) os m√©todos Shell. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A classifica√ß√£o de heap tamb√©m est√° dispon√≠vel na biblioteca padr√£o C ++. Essa classifica√ß√£o √© feita em duas opera√ß√µes: construindo o heap (std :: make_heap) e depois classificando ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: sort_heap)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Aqui, diferentemente da biblioteca bsd, a classifica√ß√£o √© apenas uma das opera√ß√µes do heap. Geralmente, essa op√ß√£o de classifica√ß√£o √© um pouco mais r√°pida que a anterior (a op√ß√£o bsd mostra melhores resultados apenas em n√∫meros curtos e linhas s longas).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando a biblioteca C ++ padr√£o, voc√™ pode classificar a √°rvore balanceada bin√°ria (std :: multiset) - apenas preencha a √°rvore e depois circule. Esse m√©todo pode ser considerado uma classifica√ß√£o r√°pida n√£o-recursiva. Algum problema surge no fato de que o alocador de mem√≥ria padr√£o √© not√°vel por ser lento; portanto, para obter os melhores resultados, voc√™ precisa usar seu pr√≥prio alocador, que acelera em cerca de 10 a 30%. Tamb√©m √© poss√≠vel observar que esse m√©todo requer muita mem√≥ria adicional, com g ++ para cada elemento de dados; al√©m disso, voc√™ tamb√©m precisa armazenar 32 bytes (na arquitetura x86-64) - seria interessante tentar armazenar essa √°rvore como um monte, ou seja, sem adicional byte Se voc√™ usar boost :: container :: multiset, precisar√° de menos mem√≥ria: apenas 24 bytes extras por elemento de dados. No entanto, como impulso,e a biblioteca padr√£o mostrou uma surpresa desagrad√°vel - no processo, √†s vezes eles exigiam mais mem√≥ria do que o necess√°rio. Talvez isso se deva ao balanceamento de √°rvores bin√°rias. C√≥digos -</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A biblioteca boost possui </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spreadsort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um algoritmo que foi inventado no s√©culo XXI. Esse √© o m√©todo geral mais r√°pido dispon√≠vel hoje em bibliotecas conhecidas. Essa classifica√ß√£o usa algumas id√©ias bit a bit e, como ela, pode ser bastante sombria sobre o tipo de argumento. Normalmente, essa classifica√ß√£o mostra resultados recordes, √†s vezes significativamente melhores que os dos concorrentes mais pr√≥ximos. A √∫nica exce√ß√£o √© a classifica√ß√£o das linhas C, onde √© significativamente inferior aos m√©todos bit a bit da biblioteca bsd. Ao classificar linhas C longas, ele pode ser inferior a outros m√©todos, por exemplo, classifica√ß√£o por rota√ß√£o ou classifica√ß√£o r√°pida com dois pontos de ancoragem. A classifica√ß√£o da propaga√ß√£o (aumento v1.62) mostrou um </font><em><font style="vertical-align: inherit;">problema</font></em><font style="vertical-align: inherit;"> muito desagrad√°vel</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ao classificar pequenas matrizes de cadeia C (at√© 1000 elementos), ele funciona com erros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√° tamb√©m um novo algoritmo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pdqsort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que aprimora, como declarado pelo autor, a classifica√ß√£o introspectiva. Este novo algoritmo, que ainda n√£o est√° descrito na Wikipedia. Seus resultados - embora n√£o sejam ruins, mas n√£o particularmente impressionantes. √â mais lento que std :: sort em inteiros curtos, mas mais r√°pido em strings e inteiros longos. Nos dois casos, a diferen√ßa √© bastante insignificante. Os melhores resultados para essa classifica√ß√£o foram obtidos para seq√º√™ncias longas de C ++ - aqui √© inferior, embora visivelmente, apenas ao l√≠der, na classifica√ß√£o por dispers√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No impulso voc√™ ainda pode encontrar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spinsort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este tamb√©m √© um novo algoritmo, que, diferentemente do anterior, possui a propriedade de estabilidade e ainda n√£o est√° descrito na Wikipedia. Geralmente ele est√° perto do l√≠der, mas com um atraso percept√≠vel atr√°s dele. Requer, embora n√£o muito, mem√≥ria adicional. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Vamos terminar</font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> com </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flat_stable_sort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> da mesma biblioteca de impulso. Este √© outro novo algoritmo robusto que ainda n√£o est√° descrito na Wikipedia. Esse √© de longe o m√©todo mais r√°pido, mas um pouco inferior ao da maioria dos outros m√©todos de biblioteca r√°pida. Ele usa muito pouca mem√≥ria adicional (no entanto, sempre precisa de uma tabela de tamanho fixo de 8 KB) e geralmente √© visivelmente mais r√°pido que o m√©todo Shell. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tabela</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tempo (em ms) da opera√ß√£o desses algoritmos em um computador com 8 GB de RAM com um processador AMD Phenom ‚Ñ¢ II X4 955 a 3.214 MHz. O computador funcionou por v√°rios meses e o tamanho total dos dados coletados em dois arquivos json carregados com tabelas √© de quase 400 KB. Os tempos s√£o dados pela m√©dia do n√∫mero de execu√ß√µes; para tamanhos menores, essas execu√ß√µes foram maiores. Trabalhar com o cache de uma maneira bastante complicada altera a velocidade dos c√°lculos, de modo que os resultados obtidos s√£o apenas aproximados na melhor das hip√≥teses (posso assumir que as imprecis√µes de tempo podem chegar a 20%). Acredito que nos melhores processadores modernos para PCs, o resultado pode ser obtido 2-3 vezes mais r√°pido, mas lembre-se de que muitos processadores modernos funcionam alternando entre diferentes frequ√™ncias e o resultado obtido com eles,ser√° ainda mais aproximado.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta e a tabela a seguir s√£o interativas. Al√©m dos valores absolutos dos tempos, voc√™ tamb√©m pode ver seus valores em rela√ß√£o √† m√©dia, mediana, m√≠nimo e m√°ximo. Voc√™ pode alterar a precis√£o dos caracteres. Voc√™ tamb√©m pode obter relacionamentos de tempo para diferentes tipos de preenchimentos e tipos de dados. O √∫ltimo, por exemplo, pode mostrar que a classifica√ß√£o de seq√º√™ncias de caracteres C √© visivelmente mais r√°pida que as seq√º√™ncias de caracteres C ++. Nos m√©todos de classifica√ß√£o, voc√™ tamb√©m pode selecionar e montar uma variedade de subconjuntos. Obviamente, voc√™ pode definir a classifica√ß√£o por qualquer coluna. Infelizmente, n√£o sei como usar o Javascript no artigo no hub, portanto, as tabelas est√£o dispon√≠veis apenas por refer√™ncia. No caso de o github.io estar sobrecarregado, tamb√©m forne√ßo links de backup para a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeira</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segunda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tabelas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O tempo √© medido em milissegundos, mas, na lei da depend√™ncia do tempo, para evitar coeficientes muito pequenos, s√£o fornecidas f√≥rmulas para microssegundos. </font><font style="vertical-align: inherit;">Portanto, se substituirmos o valor por </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na f√≥rmula </font><font style="vertical-align: inherit;">, o resultado tamb√©m deve ser dividido por 1000 para obter um n√∫mero pr√≥ximo ao correspondente da tabela. </font><font style="vertical-align: inherit;">A lei da depend√™ncia do tempo √© derivada com base nos tempos obtidos, a partir de uma compara√ß√£o de dois resultados (geralmente os extremos s√£o tomados). </font><font style="vertical-align: inherit;">Voc√™ pode verificar a qualidade da lei derivada usando a op√ß√£o de desvio relativo do valor real da sa√≠da.</font></font><br><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algumas conclus√µes gerais dos resultados desta tabela: </font></font><br></p><ul><li> as melhores classifica√ß√µes de shell em dados de at√© 10 milh√µes de elementos podem ultrapassar o timsort e at√© algumas classifica√ß√µes r√°pidas; </li><li>  O timsort est√° muito pr√≥ximo da velocidade qsort (clib), √†s vezes ultrapassando um pouco e √†s vezes vice-versa atr√°s; </li><li>  O heapsort e especialmente o treesort geralmente diminuem visivelmente, mas no contexto de uma bolha ou mesmo de uma escolha, fica claro que esses ainda s√£o m√©todos r√°pidos.  Curiosamente, esses dois m√©todos geralmente t√™m caracter√≠sticas muito semelhantes - ambos constroem √°rvores.  √â f√°cil notar que as depend√™ncias para heapsort e treesort, embora n√£o sejam claramente quadr√°ticas, obviamente n√£o s√£o <i>N</i> log <i>N</i> , mas muito pior - compare com a classifica√ß√£o do Shell, que se comporta muito melhor com o aumento do volume de dados do que o heapsort ou o treesort, enquanto que ela pr√≥pria √© mais lenta que <i>N</i> log <i>N.</i>  Assim, as implementa√ß√µes pr√°ticas de ordena√ß√£o de heap e √°rvore n√£o correspondem √†s suas especifica√ß√µes te√≥ricas; </li><li>  os dados sobre a classifica√ß√£o de cadeias de caracteres mostram que as leis das depend√™ncias de tempo aqui n√£o s√£o as mesmas dos n√∫meros - os comprimentos das cadeias ordenadas s√£o de alguma forma sobrepostas a essas leis aqui.  Infelizmente, eu n√£o conhe√ßo as f√≥rmulas para classifica√ß√µes conhecidas que dariam leis exatas das depend√™ncias de tempo ao trabalhar com strings; </li><li>  √© interessante que a velocidade de trabalhar com n√∫meros reais seja quase a mesma que n√∫meros inteiros - isso √© uma conseq√º√™ncia do fato de que na arquitetura moderna x86 s√£o feitas otimiza√ß√µes muito eficazes para trabalhar com a pilha; </li><li>  hash_sort mostrou resultados bastante med√≠ocres, isso √© poss√≠vel devido ao fato de que, devido ao uso de mem√≥ria adicional, o desempenho dos caches do processador diminui acentuadamente.  Em pequenos dados aleat√≥rios (menos de cem mil elementos), a classifica√ß√£o de hash ultrapassa as melhores classifica√ß√µes r√°pidas.  Voc√™ tamb√©m pode perceber que √© poss√≠vel novamente devido a caches, alguns dos resultados dessa classifica√ß√£o s√£o muito estranhos, por exemplo, 10 <sup>5</sup> , 10 <sup>6</sup> e 10 <sup>7</sup> n√∫meros inteiros de 32 bits ao usar preenchimento parcialmente ordenado s√£o classificados aproximadamente para o mesmo valor hora!  Algum tipo de efeitos quase qu√¢nticos.  :) Tenho certeza de que, se voc√™ pesquisar, poder√° encontrar outros resultados dif√≠ceis de explicar. </li></ul><br><p>  Vou acrescentar mais algumas conclus√µes sobre alguns casos especiais: <br></p><ul><li>  alguns tipos de preenchimento de dados revelam fraquezas nas classifica√ß√µes r√°pidas.  No entanto, a escolha de um elemento de suporte de maneira complicada aumenta a probabilidade de cair em uma sequ√™ncia incorreta para classificar praticamente zero.  Voc√™ tamb√©m pode selecionar um elemento de suporte em cada passagem de maneiras diferentes ou aleatoriamente.  Talvez eles o fa√ßam em qsort (clib).  O m√©todo Hoare em considera√ß√£o funciona muito lentamente apenas em seq√º√™ncias especialmente projetadas, encontradas por acaso durante o trabalho pr√°tico - este √© um caso com uma probabilidade de 2 <sup><i>N</i> -3</sup> / <i>N</i> <sup><i>N</i></sup> , ou seja, um evento quase absolutamente imposs√≠vel.  Embora se considerarmos sequ√™ncias nas quais o m√©todo Hoar n√£o funciona o mais lentamente poss√≠vel, mas apenas com uma desacelera√ß√£o significativa, existem muito mais casos, o que, no entanto, deixa a probabilidade de um caso de processamento de dados inaceitavelmente lento ainda ser praticamente insignificante, embora muito irritante em sua diferen√ßa de zero.  Tamb√©m √© quase imposs√≠vel obter acidentalmente dados sobre os quais a classifica√ß√£o r√°pida com dois pontos de controle funcionar√° lentamente, de acordo com a lei quadr√°tica.  As op√ß√µes de classifica√ß√£o r√°pida do Lomuto sem e sem um elemento de suporte mostram resultados muito ruins em quase todos os casos de preenchimento espec√≠ficos; </li><li>  em alguns casos especiais, a classifica√ß√£o mais lenta da ‚Äúbolha‚Äù produz excelentes resultados, e algumas das mais r√°pidas e r√°pidas, pelo contr√°rio, s√£o muito ruins; </li><li>  A classifica√ß√£o de hash mostrou um resultado muito ruim nos preenchimentos dos tipos 8 e 9, isso ocorre porque a sequ√™ncia mon√≥tona √© obtida a partir de valores consecutivos, come√ßando pelo menor, e 1% dos n√∫meros aleat√≥rios √© retirado da faixa do valor mais baixo ao m√°ximo, que cont√©m 99% dos dados consecutivos em um elemento de hash.  Este caso demonstra muito bem os problemas que podem surgir ao usar essa classifica√ß√£o ou classifica√ß√£o com uma matriz com dados desconhecidos; </li><li>  a classifica√ß√£o por sele√ß√£o se comporta de maneira muito est√°vel em todos os tipos de preenchimento; a classifica√ß√£o por pilhas e √°rvores tamb√©m √© bastante est√°vel, sem picos e quedas √≥bvios.  Isso √© verdade, √© claro, para os tipos de Shell, bem como para a maioria dos outros m√©todos r√°pidos das bibliotecas padr√£o. </li></ul><br>  Agora √© hora de falar sobre os tipos de dados usados ‚Äã‚Äãnos algoritmos de classifica√ß√£o: <br><br><ol><li>  n√∫meros inteiros de 32 bits assinados (int32_t), mas apenas n√£o negativos foram usados.  Outros dados num√©ricos tamb√©m foram obtidos apenas como n√£o negativos - isso n√£o reduz a generalidade dos resultados, mas facilita muito a obten√ß√£o deles para alguns algoritmos; </li><li>  n√∫meros inteiros, assinados de 64 bits (int64_t); </li><li>  n√∫meros inteiros, assinados em 128 bits (__int128 - suportado por pelo menos GCC); </li><li>  estruturas de cinco n√∫meros inteiros (int32_t), um dos quais √© usado como chave (INT1P4).  Ao classificar esses dados, o n√∫mero de permuta√ß√µes come√ßa a afetar o tempo computacional de maneira mais significativa, portanto, m√©todos com menos permuta√ß√µes ganham alguma vantagem; </li><li>  n√∫meros reais, como precis√£o dupla, dupla (n√∫meros flutuantes); </li><li>  cadeias curtas C ++ e C. Foram utilizadas cadeias de 1 a 16 (cadeias curtas e c-cadeias curtas); </li><li>  strings C e C ++ de comprimento m√©dio, cujo comprimento √© de 1 a 256 (strings e c-strings); </li><li>  linhas longas C e C ++, cujo comprimento √© de 1 a 2 <sup>20</sup> (isso √© um pouco mais de um milh√£o), e as linhas s√£o selecionadas para que seu comprimento m√©dio n√£o exceda 512; portanto, as linhas foram selecionadas apenas para preenchimento aleat√≥rio; em outros casos, as linhas foram simplesmente utilizadas comprimentos de 1 a 512 (cordas longas e c-longas). </li></ol><br><p>  E tamb√©m sobre como preencher a matriz de origem para classifica√ß√£o: <br><br></p><ol><li>  por acaso; </li><li>  estritamente ascendente (ordenado); </li><li>  estritamente descendente (ordem inversa, reversa); </li><li>  valores aleat√≥rios da faixa de 0 a 99 (pequena varia√ß√£o, baixa varia√ß√£o 100); </li><li>  sequ√™ncia aleat√≥ria de 0 e 1 (pequena varia√ß√£o, baixa varia√ß√£o 2); </li><li>  constante 0 (spread pequeno, baixa varia√ß√£o 1); </li><li>  a sequ√™ncia que leva a vers√£o qsort (Hoare) √† execu√ß√£o mais lenta.  √â curioso que existam exatamente 2 <sup><i>N</i> -3</sup> dessas seq√º√™ncias entre todas as sequ√™ncias de comprimento <i>N</i> ; </li><li>  estritamente ascendente, com a inser√ß√£o de 1% de n√∫meros aleat√≥rios (parcialmente pedidos); </li><li>  estritamente descendente, com inser√ß√£o de 1% de vari√°veis ‚Äã‚Äãaleat√≥rias (parcialmente revertidas). </li></ol><br>  Deve-se enfatizar que dados aleat√≥rios s√£o o caso mais t√≠pico de preenchimento de uma matriz, todos os outros m√©todos s√£o extremamente raros e at√© quase imposs√≠veis durante a opera√ß√£o normal de um determinado. <br><br>  Vejamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">os</a> resultados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do</a> teste, onde as classifica√ß√µes funcionam com todas as sequ√™ncias de dados poss√≠veis.  O n√∫mero de tais seq√º√™ncias √© igual ao fatorial de seu comprimento; portanto, para as seq√º√™ncias de comprimento 12, existem 479'001'600 variantes - um bom PC moderno calcula seu n√∫mero em menos de um minuto.  Se tomarmos seq√º√™ncias de comprimento 14, j√° temos 87'178'291'200 variantes para v√°rias horas de opera√ß√£o do computador.  Portanto, a tabela a seguir mostra o tempo m√©dio (em ciclos do processador obtido atrav√©s da instru√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RDTSC</a> ) de uma classifica√ß√£o ao classificar todas as permuta√ß√µes at√© apenas 12. Nos dados, os tipos num√©ricos e seq√º√™ncias de caracteres anteriores s√£o obtidos.  Obviamente, pode-se notar que seq√º√™ncias com elementos repetidos n√£o s√£o consideradas.  No entanto, atrevo-me a sugerir que a presen√ßa deles n√£o alteraria qualitativamente os resultados, mas poderia retardar significativamente o recebimento. <br><br>  Os resultados para esses dados pequenos n√£o s√£o muito representativos, e especialmente para m√©todos de classifica√ß√£o complexos, mas ainda complementam a ideia do comportamento de classifica√ß√£o.  Alguns tipos, at√© onde eu sei, substituem seu algoritmo principal por outro ao trabalhar com matrizes pequenas - s√£o tipos espalhados, r√°pidos com dois pontos de ancoragem e radix_msd (os √∫ltimos dois usam inser√ß√µes).  E algumas classifica√ß√µes (flat_stable e radix) usam tabelas pequenas, mas com pequenos tamanhos de dados, essas tabelas acabam sendo muito maiores que os dados em si, o que diminui bastante esses m√©todos em compara√ß√£o com outros e produz resultados estranhos.  Resultados estranhos tamb√©m s√£o obtidos com outras classifica√ß√µes bit a bit e com classifica√ß√µes hash e array.  Tais resultados incomuns s√£o facilmente explicados pelo fato de que o tempo de prepara√ß√£o dos dados antes da classifica√ß√£o desses m√©todos para dados pequenos √© maior que o pr√≥prio tempo de classifica√ß√£o.  Obviamente, ao medir intervalos de tempo t√£o pequenos (nanossegundos), a influ√™ncia de v√°rios erros na lei exibida √© muito maior do que na tabela anterior.  Portanto, as leis acabaram sendo muito aproximadas, geralmente "com uma tend√™ncia" a valores exagerados.  O √∫ltimo √© parcialmente explicado pelo fato de que, ao trabalhar com dados pequenos, o pr√≥prio tempo de classifica√ß√£o se torna compar√°vel ao tempo de chamar a fun√ß√£o de classifica√ß√£o e v√°rias opera√ß√µes auxiliares necess√°rias para medir o tempo.  O programa tenta subtrair a sobrecarga nomeada da sa√≠da, mas acaba sendo feita aproximadamente.  Com tudo isso, atrevo-me a supor que, comparando os resultados para diferentes tipos de dados e levando em considera√ß√£o os coment√°rios feitos, √†s vezes voc√™ pode fazer suposi√ß√µes que n√£o est√£o muito longe da precis√£o. <br><br>  Em conclus√£o, outra tabela que mostra quantos m√©todos de teste diferentes s√£o necess√°rios para classificar mem√≥ria adicional.  Obviamente, esse valor depende do sistema.  Nos meus testes, como j√° escrevi, esse √© o x86-64, GCC.  A letra T significa o tamanho do tipo em bytes (o comprimento da string n√£o est√° inclu√≠do neste tamanho: para linhas C √© o tamanho do ponteiro, para linhas C ++ √© o tamanho do descritor, 32 bytes para x86-64 GCC), a letra L √© o meio o comprimento do tipo em bytes (para n√∫meros √© T e para cadeias √© o comprimento m√©dio da cadeia), a letra A pode ser 1 ou 0 - este √© o alinhamento com a borda de 64 bits e a letra M √© o alinhamento do alocador de mem√≥ria padr√£o (sup√µe-se alinha a um limite de 32 bytes).  O s√≠mbolo <sup>*</sup> significa que os dados para esse tipo de classifica√ß√£o foram obtidos apenas com base na an√°lise da leitura do campo VmRSS em / proc / PID / status (o campo mencionado √© o tamanho do programa de processo). <br><br><div class="spoiler">  <b class="spoiler_title">Tabela de mem√≥ria adicional</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  M√©todo </th><th>  Depend√™ncia </th></tr><tr><td>  matriz * 1 </td><td align="center">  (T + 1/8) <i>N</i> </td></tr><tr><td>  matriz * k, k&gt; 1 </td><td align="center">  (T + 4k) <i>N</i> </td></tr><tr><td>  bolha </td><td align="center">  0 0 </td></tr><tr><td>  clib_qsort </td><td align="center">  ‚âàT <i>N</i> / 2 a NT <i>N</i> <sup>*</sup> </td></tr><tr><td>  flat_stable </td><td align="center">  NT <i>N</i> / 256 </td></tr><tr><td>  hash </td><td align="center">  (T + 8 + 4A) <i>N</i> </td></tr><tr><td>  hashbt </td><td align="center">  (T + 12) <i>N</i> </td></tr><tr><td>  hashbt_boost </td><td align="center">  (56 + T + 4A + M) <i>N</i> </td></tr><tr><td>  hashbt_std </td><td align="center">  (80 + T + 4A + M) <i>N</i> </td></tr><tr><td>  heapsort </td><td align="center">  0 0 </td></tr><tr><td>  inser√ß√£o </td><td align="center">  0 0 </td></tr><tr><td>  mergesort_bsd </td><td align="center">  LogTlog <sub>2</sub> <i>N</i> a T <i>N</i> <sup>*</sup> </td></tr><tr><td>  pdq </td><td align="center">  Tlog <i>n</i> </td></tr><tr><td>  quicksort </td><td align="center">  Log16log <sub>2</sub> <i>N</i> a 16 <i>N</i> </td></tr><tr><td>  quicksort_tco </td><td align="center">  de 0 a <i>N</i> </td></tr><tr><td>  radix </td><td align="center">  NT <i>N</i> </td></tr><tr><td>  radix8_trie </td><td align="center">  de ‚âàT <i>N</i> + 24L a ‚âà (T + 24L + 12) <i>N</i> </td></tr><tr><td>  radix_bsd </td><td align="center">  0 0 </td></tr><tr><td>  radix_msd </td><td align="center">  NT <i>N</i> </td></tr><tr><td>  sele√ß√£o </td><td align="center">  0 0 </td></tr><tr><td>  concha </td><td align="center">  0 0 </td></tr><tr><td>  girar </td><td align="center">  T <i>N</i> / 2 </td></tr><tr><td>  espalhar </td><td align="center">  ‚âà0 </td></tr><tr><td>  sradix_bsd </td><td align="center">  ‚âàT <i>N</i> <sup>*</sup> </td></tr><tr><td>  Stlsort </td><td align="center">  de 0 a ‚âàTlog <sub>2</sub> <i>N</i> <sup>*</sup> </td></tr><tr><td>  stlstable </td><td align="center">  de 0 a ‚âàT <i>N</i> / 2 <sup>*</sup> </td></tr><tr><td>  timsort </td><td align="center">  de 0 a ‚âàT <i>N</i> <sup>*</sup> </td></tr><tr><td>  tree_boost </td><td align="center">  (T + 24) <i>N</i> </td></tr><tr><td>  tree_stl </td><td align="center">  (T + 32) <i>N</i> </td></tr></tbody></table></div><br></div></div><br>  √â claro que existem outros m√©todos de classifica√ß√£o, tanto primitivos quanto r√°pidos.  A biblioteca de refor√ßo possui algoritmos paralelos que permitem tirar vantagem da presen√ßa de n√∫cleos de processador adicionais no sistema.  Voc√™ tamb√©m pode usar o container self-order boost :: container :: flat_multiset em vez de std :: multiset, mas funciona muito lentamente. <br><br>  Aproveito a oportunidade para fazer alguns coment√°rios sobre a biblioteca boost em geral.  Eu recomendo n√£o passar.  Mesmo os recursos que est√£o na biblioteca padr√£o em impulso, como regra, s√£o melhor implementados e, √†s vezes (como express√µes regulares, por exemplo) s√£o muito melhores.  Se falamos de cont√™ineres, eles s√£o notoriamente maiores, e aqueles que coincidem com os cont√™ineres √†s vezes s√£o um pouco mais r√°pidos e geralmente t√™m pequenas, mas boas melhorias.  O Boost verifica os tipos mais detalhadamente, o que √†s vezes pode ajudar na detec√ß√£o de erros quase ilus√≥rios que geralmente n√£o se manifestam, mas, em algumas circunst√¢ncias, podem ser ativados inesperadamente.  As desvantagens do aumento incluem mensagens incondicionalmente completamente ileg√≠veis e enormes em volume sobre erros de compila√ß√£o em muitas constru√ß√µes desta biblioteca - isso, embora em menor grau, se aplica √† biblioteca padr√£o.  Chegou a hora dos desenvolvedores de C ++ fazerem algo sobre isso. <br><br>  Todos os arquivos com testes e outros materiais relacionados podem ser obtidos no meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reposit√≥rio</a> .  Se algu√©m estiver interessado em dados de origem brutos, voc√™ pode obt√™-los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> (1,4 MB).  Ficarei feliz em quaisquer coment√°rios, cr√≠ticas e acr√©scimos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467473/">https://habr.com/ru/post/pt467473/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467459/index.html">Como um microcontrolador pode ler dados em 1,6 Gbps</a></li>
<li><a href="../pt467461/index.html">RubyRussia 2019. Julian Pokrovsky: como otimizar um mon√≥lito</a></li>
<li><a href="../pt467463/index.html">Apenas divis√£o, ou como criar uma teoria matem√°tica e ganhar US $ 400 mil com ela. S√©rie Tr√™s, Final</a></li>
<li><a href="../pt467465/index.html">A nuvem salvar√° smartphones com or√ßamento limitado</a></li>
<li><a href="../pt467471/index.html">Alma Mikrotik contra ILV sem alma e o mesmo provedor</a></li>
<li><a href="../pt467475/index.html">Retorne Thread.Abort () para o .NET Core. Entrega de aplicativos com sua vers√£o do CoreCLR e CoreFX</a></li>
<li><a href="../pt467477/index.html">Kubernetes 1.16: Vis√£o geral dos destaques</a></li>
<li><a href="../pt467479/index.html">Kir Shatrov: O Shopify come√ßou com o Rails e aqui eles amam sinceramente esse framework.</a></li>
<li><a href="../pt467485/index.html">Solu√ß√£o de problemas com a calculadora pwnable.kr 23 - md5. Lidamos com Stack Canary. Conectando bibliotecas C em python</a></li>
<li><a href="../pt467487/index.html">Sobre o futuro dos pagamentos em blockchain e criptomoeda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>