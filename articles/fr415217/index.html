<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ôüèø üìº üóùÔ∏è Cr√©ation d'un crochet pour chat dans Unity. 2e partie üë®‚Äçüë¶ üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø üëåüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Remarque : ce didacticiel est destin√© aux utilisateurs avanc√©s et exp√©riment√©s, et il ne couvre pas des sujets tels que l'ajout de composants, la cr√©a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©ation d'un crochet pour chat dans Unity. 2e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415217/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db0/187/d5e/db0187d5e9f5fc2bfa78b078dcb2a178.png" alt="image"></div><br><blockquote> <em>Remarque</em> : ce didacticiel est destin√© aux utilisateurs avanc√©s et exp√©riment√©s, et il ne couvre pas des sujets tels que l'ajout de composants, la cr√©ation de nouveaux scripts GameObject et la syntaxe C #.  Si vous avez besoin d'am√©liorer vos comp√©tences Unity, consultez nos didacticiels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prise en main de Unity</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction √† Unity Scripting</a> . </blockquote><br>  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premi√®re partie du</a> tutoriel, nous avons appris √† cr√©er un crochet pour chat avec la m√©canique d'enrouler une corde autour des obstacles.  Cependant, nous en voulons plus: la corde peut s'enrouler autour des objets au niveau, mais elle ne se d√©tache pas √† votre retour. <br><a name="habracut"></a><br><h2>  Se rendre au travail </h2><br>  Ouvrez le projet termin√© √† partir de la premi√®re partie dans Unity ou t√©l√©chargez le <a href="">brouillon</a> de cette partie du didacticiel, puis ouvrez <em>2DGrapplingHook-Part2-Starter</em> .  Comme dans la premi√®re partie, nous utiliserons la version Unity 2017.1 ou sup√©rieure. <br><br>  Ouvrez la sc√®ne du <em>jeu</em> dans l'√©diteur √† partir du dossier de projet <em>Sc√®nes</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/89c/ee3/48c/89cee348caa1656418bcc0ded8e91bab.png"></div><br>  Lancez la sc√®ne du jeu et essayez d'accrocher le crochet de chat sur les pierres au-dessus du personnage, puis balancez-vous pour que la corde s'enroule autour d'une paire de bords de pierre. <br><br>  Lorsque vous revenez en arri√®re, vous remarquerez que les points de la pierre √† travers lesquels la corde utilis√©e pour se retourner ne se d√©crochent plus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e9/d83/da7/4e9d83da7eda544a3f48cecbf3e64b08.gif"></div><br>  Pensez au point auquel la corde doit se d√©rouler.  Pour simplifier la t√¢che, il est pr√©f√©rable d'utiliser l'√©tui lorsque la corde s'enroule autour des bords. <br><br>  Si la limace, accroch√©e √† une pierre au-dessus de sa t√™te, pivote vers la droite, la corde se pliera apr√®s le seuil auquel elle franchit le point d'angle de 180 degr√©s avec la nervure √† laquelle la limace est actuellement attach√©e.  Dans la figure ci-dessous, elle est repr√©sent√©e par un point vert en surbrillance. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3eb/257/132/3eb25713213c01fb76fb97c49e6958cf.png"></div><br>  Lorsque la limace retourne dans l'autre sens, la corde doit √† nouveau se d√©crocher au m√™me point (surlign√© en rouge sur la figure ci-dessus): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ef/ad3/e22/2efad3e22fddf83cefcf52fca6175792.png"></div><br><h2>  La logique de d√©torsion </h2><br>  Pour calculer le moment o√π vous devez d√©tordre la corde aux points sur lesquels elle a √©t√© enroul√©e plus t√¥t, nous avons besoin de connaissances en g√©om√©trie.  En particulier, nous utiliserons une comparaison des angles pour d√©terminer quand la corde doit se d√©tacher du bord. <br><br>  Cette t√¢che peut sembler un peu intimidante.  Les math√©matiques peuvent inspirer l'horreur et le d√©sespoir m√™me aux plus courageux. <br><br>  Heureusement, Unity a d'excellentes fonctions d'aide math√©matique qui peuvent nous faciliter un peu la vie. <br><br>  Ouvrez le script <em>RopeSystem</em> dans l'EDI et cr√©ez une nouvelle m√©thode appel√©e <code>HandleRopeUnwrap()</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleRopeUnwrap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  Allez dans <code>Update()</code> et ajoutez √† la fin un appel √† notre nouvelle m√©thode. <br><br><pre> <code class="cs hljs">HandleRopeUnwrap();</code> </pre> <br>  Alors que <code>HandleRopeUnwrap()</code> ne fait rien, mais maintenant nous pouvons traiter la logique associ√©e √† l'ensemble du processus de d√©tachement des bords. <br><br>  Comme vous vous en souvenez de la premi√®re partie du didacticiel, nous avons stock√© les positions d'enroulement de la corde dans une collection appel√©e <code>ropePositions</code> , qui est une collection <code>List&lt;Vector2&gt;</code> .  Chaque fois qu'une corde s'enroule autour d'un bord, nous gardons la position de ce point d'enroulement dans cette collection. <br><br>  Pour rendre le processus plus efficace, nous n'ex√©cuterons aucune logique dans <code>HandleRopeUnwrap()</code> si le nombre de positions stock√©es dans la collection est √©gal ou inf√©rieur √† 1. <br><br>  En d'autres termes, lorsque la limace s'est accroch√©e au point de d√©part et que sa corde n'a pas encore enroul√© autour des bords, le nombre de <code>ropePositions</code> de <code>ropePositions</code> sera de 1 et nous ne suivrons pas la logique de traitement de d√©torsion. <br><br>  Ajoutez cette simple <code>return</code> en haut de <code>HandleRopeUnwrap()</code> pour enregistrer de pr√©cieux cycles CPU, car cette m√©thode est appel√©e √† partir de <code>Update()</code> plusieurs fois par seconde. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ropePositions.Count &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><h3>  Ajout de nouvelles variables </h3><br>  Dans le cadre de ce nouveau test, nous ajouterons quelques dimensions et r√©f√©rences aux diff√©rents angles n√©cessaires pour mettre en ≈ìuvre la base de la logique de d√©roulement.  Ajoutez le code suivant √† <code>HandleRopeUnwrap()</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Hinge =       // Anchor =     Hinge // Hinge Angle =   anchor  hinge // Player Angle =   anchor  player // 1 var anchorIndex = ropePositions.Count - 2; // 2 var hingeIndex = ropePositions.Count - 1; // 3 var anchorPosition = ropePositions[anchorIndex]; // 4 var hingePosition = ropePositions[hingeIndex]; // 5 var hingeDir = hingePosition - anchorPosition; // 6 var hingeAngle = Vector2.Angle(anchorPosition, hingeDir); // 7 var playerDir = playerPosition - anchorPosition; // 8 var playerAngle = Vector2.Angle(anchorPosition, playerDir);</span></span></code> </pre> <br>  Il y a beaucoup de variables ici, donc je vais expliquer chacune d'entre elles, ainsi que d'ajouter une illustration pratique qui aidera √† comprendre leur objectif. <br><br><ol><li>  <code>anchorIndex</code> est l'index de la collection <code>ropePositions</code> √† deux positions √† partir de la fin de la collection.  On peut le consid√©rer comme un point en deux positions sur la corde √† partir de la position de la limace.  Dans la figure ci-dessous, il s'agit du premier point de fixation du crochet √† la surface.  Lors du remplissage de la collection <code>ropePositions</code> nouveaux points d'emballage, ce point restera toujours le point d'emballage √† une distance de deux positions de la limace. </li><li>  <code>hingeIndex</code> est l'index de la collection qui stocke le point de la charni√®re actuelle;  en d'autres termes, la position dans laquelle la corde s'enroule actuellement autour du point le plus proche de l'extr√©mit√© de la corde de la balle.  Il est toujours √† une distance d'une position de la limace, c'est pourquoi nous utilisons <code>ropePositions.Count - 1</code> . </li><li>  <code>anchorPosition</code> calcul√© en r√©f√©ren√ßant la place <code>anchorIndex</code> dans la collection <code>ropePositions</code> et est la simple valeur Vector2 de cette position. </li><li>  <code>hingePosition</code> calcul√© en r√©f√©ren√ßant la place de <code>hingeIndex</code> dans la collection <code>ropePositions</code> et est la simple valeur Vector2 de cette position. </li><li>  <code>hingeDir</code> est un vecteur dirig√© de <code>anchorPosition</code> vers <code>hingePosition</code> .  Il est utilis√© dans la variable suivante pour obtenir l'angle. </li><li>  <code>hingeAngle</code> - la fonction d'aide utile <code>Vector2.Angle()</code> est utilis√©e ici pour calculer l'angle entre <code>anchorPosition</code> et le point d'articulation. </li><li>  <code>playerDir</code> est un vecteur dirig√© de <code>anchorPosition</code> vers la position actuelle du slug (playerPosition) </li><li>  Ensuite, en utilisant l'angle entre le point d'ancrage et le joueur (limace), <code>playerAngle</code> calcul√©. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73f/207/4c4/73f2074c470b3016bcd5ee386ce240e8.png"></div><br>  Toutes ces variables sont calcul√©es en utilisant des positions stock√©es en tant que valeurs Vector2 dans la collection <code>ropePositions</code> et en comparant ces positions avec d'autres positions ou la position actuelle du joueur (slug). <br><br>  Les deux variables importantes utilis√©es pour la comparaison sont <code>hingeAngle</code> et <code>hingeAngle</code> . <br><br>  La valeur stock√©e dans <code>hingeAngle</code> doit rester statique car il s'agit toujours d'un angle constant entre le point situ√© aux deux ¬´plis de la corde¬ª par rapport √† la limace et le ¬´pli de la corde¬ª actuel le plus proche de la limace qui ne bouge pas tant que la corde n'est pas torsad√©e ou apr√®s pliage. un nouveau point de pliage sera ajout√©. <br><br>  Lorsque la limace se <code>playerAngle</code> change.  En comparant cet angle avec <code>hingeAngle</code> , et en v√©rifiant √©galement si le slug est √† gauche ou √† droite de ce coin, nous pouvons d√©terminer si le point de pliage actuel le plus proche du slug doit √™tre d√©tach√©. <br><br>  Dans la premi√®re partie de ce didacticiel, nous avons enregistr√© les positions de pliage dans un dictionnaire appel√© <code>wrapPointsLookup</code> .  Chaque fois que nous enregistrons le point de pliage, nous l'avons ajout√© au dictionnaire avec la position comme cl√© et avec 0 comme valeur.  Cependant, cette valeur de 0 √©tait plut√¥t myst√©rieuse, non? <br><br>  Nous utiliserons cette valeur pour stocker la position du slug par rapport √† son angle avec le point d'articulation (le point de pliage actuel le plus proche du slug). <br><br>  Si vous affectez une valeur de <em>-1</em> , alors l'angle du slug ( <code>playerAngle</code> ) est inf√©rieur √† l'angle de la charni√®re ( <code>hingeAngle</code> ), et avec une valeur de <em>1, l'</em> angle de <code>playerAngle</code> sup√©rieur √† <code>hingeAngle</code> . <br><br>  √âtant donn√© que nous enregistrons les valeurs dans le dictionnaire, chaque fois que nous comparons <code>hingeAngle</code> avec <code>hingeAngle</code> , nous pouvons comprendre si le slug vient de d√©passer la limite apr√®s laquelle la corde doit se d√©crocher. <br><br>  Cela peut s'expliquer diff√©remment: si l'angle de la limace vient d'√™tre v√©rifi√© et qu'il est plus petit que l'angle de la charni√®re, mais la derni√®re fois qu'il a √©t√© enregistr√© dans le dictionnaire des points de pliage, il a √©t√© marqu√© d'une valeur indiquant qu'il √©tait de l'autre c√¥t√© de ce coin, alors le point doit √™tre supprim√© imm√©diatement ! <br><br><h3>  Corde de d√©saccouplement </h3><br>  Jetez un ≈ìil √† la capture d'√©cran ci-dessous avec des notes.  Notre limace s'accrochait au rocher, se balan√ßait vers le haut, enroulant une corde autour du bord du rocher en montant. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db0/187/d5e/db0187d5e9f5fc2bfa78b078dcb2a178.png"></div><br>  Vous remarquerez peut-√™tre qu'√† la position de swing la plus haute, o√π la limace est opaque, son point de pliage le plus proche actuel (marqu√© d'un point blanc) sera stock√© dans le dictionnaire <code>wrapPointsLookup</code> avec une valeur de <em>1</em> . <br><br>  En descendant, lorsque <code>playerAngle</code> devient plus petit que <code>hingeAngle</code> (deux lignes vertes en pointill√©s), comme indiqu√© par la fl√®che bleue, une v√©rification est effectu√©e, et si la derni√®re valeur (actuelle) du point de pliage √©tait <em>1</em> , alors le point de pliage doit √™tre supprim√©. <br><br>  Maintenant, impl√©mentons cette logique dans le code.  Mais avant de commencer, cr√©ons un blanc de la m√©thode que nous utiliserons pour nous d√©tendre.  Pour cette raison, apr√®s avoir cr√©√© la logique, cela ne conduira pas √† une erreur. <br><br>  Ajoutez une nouvelle m√©thode <code>UnwrapRopePosition(anchorIndex, hingeIndex)</code> en ins√©rant les lignes suivantes: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnwrapRopePosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> anchorIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hingeIndex</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Cela fait, revenons √† <code>HandleRopeUnwrap()</code> .  Sous les variables nouvellement ajout√©es, ajoutez la logique suivante, qui g√©rera deux cas: <code>playerAngle</code> moins que <code>hingeAngle</code> et <code>hingeAngle</code> plus que <code>hingeAngle</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (playerAngle &lt; hingeAngle) { <span class="hljs-comment"><span class="hljs-comment">// 1 if (wrapPointsLookup[hingePosition] == 1) { UnwrapRopePosition(anchorIndex, hingeIndex); return; } // 2 wrapPointsLookup[hingePosition] = -1; } else { // 3 if (wrapPointsLookup[hingePosition] == -1) { UnwrapRopePosition(anchorIndex, hingeIndex); return; } // 4 wrapPointsLookup[hingePosition] = 1; }</span></span></code> </pre> <br>  Ce code doit correspondre √† l'explication de la logique d√©crite ci-dessus pour le premier cas (lorsque <code>hingeAngle</code> &lt; <code>hingeAngle</code> ), mais g√®re √©galement le second cas (lorsque <code>hingeAngle</code> &gt; <code>hingeAngle</code> ). <br><br><ol><li>  Si le point de pliage actuel le plus proche du slug a une valeur de <em>1</em> au point o√π <code>hingeAngle</code> &lt; <code>hingeAngle</code> , alors nous <code>hingeAngle</code> ce point et effectuons un retour afin que le reste de la m√©thode ne s'ex√©cute pas. </li><li>  Sinon, si le point de pliage n'a pas √©t√© marqu√© pour la derni√®re fois avec une valeur de <em>1</em> , mais que <code>hingeAngle</code> <code>playerAngle</code> inf√©rieur √† <code>hingeAngle</code> , alors <em>-1 est</em> affect√©. </li><li>  Si le point de pliage actuel le plus proche du slug est <em>-1</em> au point o√π <code>hingeAngle</code> &gt; <code>hingeAngle</code> , supprimez le point et revenez. </li><li>  Sinon, nous attribuons les entr√©es dans le dictionnaire des points de pliage √† la position charni√®re √† <em>1</em> . </li></ol><br>  Ce code garantit que le dictionnaire <code>wrapPointsLookup</code> toujours mis √† jour, garantissant que la valeur du point de pliage actuel (le plus proche du slug) correspond √† l'angle de slug actuel par rapport au point de pliage. <br><br>  N'oubliez pas que la valeur est -1 lorsque l'angle de slug est inf√©rieur √† l'angle de charni√®re (par rapport au point de r√©f√©rence), et 1 lorsque l'angle de slug est sup√©rieur √† l'angle de charni√®re. <br><br>  Nous allons maintenant <code>UnwrapRopePosition()</code> dans le script <em>RopeSystem avec un</em> code qui va directement s'engager dans le d√©couplage, d√©placer la position de r√©f√©rence et attribuer une nouvelle valeur de distance √† la valeur de distance de corde DistanceJoint2D.  Ajoutez les lignes suivantes au disque de m√©thode cr√©√© pr√©c√©demment: <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// 1 var newAnchorPosition = ropePositions[anchorIndex]; wrapPointsLookup.Remove(ropePositions[hingeIndex]); ropePositions.RemoveAt(hingeIndex); // 2 ropeHingeAnchorRb.transform.position = newAnchorPosition; distanceSet = false; // Set new rope distance joint distance for anchor position if not yet set. if (distanceSet) { return; } ropeJoint.distance = Vector2.Distance(transform.position, newAnchorPosition); distanceSet = true;</span></span></code> </pre> <br><ol><li>  L'index du point d'ancrage actuel (la deuxi√®me position de la corde par rapport √† la limace) devient la nouvelle position de la charni√®re, et l'ancienne position de la charni√®re est supprim√©e (celle qui √©tait auparavant la plus proche de la limace et que nous sommes maintenant en train de ¬´d√©tordre¬ª).  La variable <code>newAnchorPosition</code> attribuer la valeur <code>anchorIndex</code> dans la liste des positions de corde.  Il sera ensuite utilis√© pour positionner la position mise √† jour du point d'ancrage. </li><li>  La corde-joint RigidBody2D (√† laquelle la corde DistanceJoint2D est attach√©e) change sa position √† la nouvelle position du point d'ancrage.  Cela garantit un mouvement continu et en douceur de la balle sur la corde lorsqu'elle est connect√©e √† DistanceJoint2D, et cette connexion devrait lui permettre de continuer √† osciller par rapport √† la nouvelle position, qui est devenue la r√©f√©rence - en d'autres termes, par rapport au point suivant vers le bas de la corde √† partir de sa position. </li><li>  Ensuite, vous devez mettre √† jour la valeur de distance distanceJoint2D pour prendre en compte un changement brusque de la distance entre la limace et le nouveau point de r√©f√©rence.  Si ce n'est pas d√©j√† fait, une v√©rification rapide de l'indicateur <code>distanceSet</code> est effectu√©e et la distance est affect√©e √† la valeur de la distance calcul√©e entre le slug et la nouvelle position du point d'ancrage. </li></ol><br>  Enregistrez le script et revenez √† l'√©diteur.  Red√©marrez le jeu et regardez comment la corde se d√©tache des bords lorsque la balle d√©passe les valeurs de seuil de chaque point de flexion! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65b/4af/3a1/65b4af3a13e464947b394595dc052a06.gif"></div><br>  Bien que la logique soit pr√™te, nous ajouterons du code d'assistance √† <code>HandleRopeUnwrap()</code> juste avant de comparer <code>hingeAngle</code> avec <code>hingeAngle</code> ( <code>if (playerAngle &lt; hingeAngle)</code> ). <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!wrapPointsLookup.ContainsKey(hingePosition)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"We were not tracking hingePosition ("</span></span> + hingePosition + <span class="hljs-string"><span class="hljs-string">") in the look up dictionary."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  En fait, cela ne devrait pas se produire, car nous red√©finissons et d√©connectons le crochet de chat lorsqu'il s'enroule deux fois autour d'une c√¥te, mais si cela se produit toujours, nous pouvons facilement quitter cette m√©thode avec une simple <code>return</code> et un message d'erreur dans la console. <br><br>  De plus, gr√¢ce √† cela, nous traiterons plus facilement de tels cas limites;  de plus, nous recevons notre propre message d'erreur dans le cas o√π quelque chose d'inutile se produit. <br><br><h2>  O√π aller ensuite? </h2><br>  Voici un <a href="">lien vers le projet termin√© de</a> cette deuxi√®me et derni√®re partie du tutoriel. <br><br>  F√©licitations pour avoir termin√© cette s√©rie de didacticiels!  En ce qui concerne la comparaison des angles et des positions, tout est devenu assez compliqu√©, mais nous y avons surv√©cu et nous avons maintenant un merveilleux syst√®me de crochet et de chat qui peut se retrouver sur des objets dans le jeu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5f/69a/cbe/b5f69acbefc9de390ff25f0fbc4cbe10.png"></div><br>  Saviez-vous que notre √©quipe de d√©veloppement Unity a √©crit un livre?  Sinon, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Unity Games By Tutorials</a> .  Ce jeu vous apprendra √† cr√©er quatre jeux pr√™ts √† l'emploi √† partir de z√©ro: <br><br><ul><li>  Tireur √† deux b√¢tons </li><li>  Tireur √† la premi√®re personne </li><li>  Jeu de tower defense (avec support VR!) </li><li>  Plateforme 2D </li></ul><br>  Apr√®s avoir lu ce livre, vous apprendrez √† cr√©er vos propres jeux pour Windows, macOS, iOS et autres plateformes! <br><br>  Ce livre est destin√© aux d√©butants et √† ceux qui souhaitent mettre √† niveau leurs comp√©tences Unity vers un niveau professionnel.  Pour ma√Ætriser le livre, vous devez avoir une exp√©rience en programmation (dans n'importe quelle langue). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415217/">https://habr.com/ru/post/fr415217/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415207/index.html">Quand le paradis a perdu la perfection</a></li>
<li><a href="../fr415209/index.html">¬´Je devais garder une pi√®ce vide¬ª: l'√©mergence d'emplois d√©nu√©s de sens</a></li>
<li><a href="../fr415211/index.html">La Voie lact√©e cache des dizaines de milliers de trous noirs</a></li>
<li><a href="../fr415213/index.html">Les √©lections ne fonctionnent pas du tout; les math√©matiques doivent √™tre bl√¢m√©es</a></li>
<li><a href="../fr415215/index.html">L'Universit√© du Michigan pr√©sente le plus petit ordinateur au monde</a></li>
<li><a href="../fr415219/index.html">Comment j'ai re√ßu une offre d'un √©diteur √©tranger bien connu pour devenir auteur d'un cours en ligne</a></li>
<li><a href="../fr415221/index.html">Semaine de la s√©curit√© 23: 50 milliards d'appareils IoT</a></li>
<li><a href="../fr415223/index.html">Entonnoir de vente</a></li>
<li><a href="../fr415227/index.html">√âcosyst√®me de d√©veloppement en 2018: ce que les programmeurs vivent en Russie et dans le monde</a></li>
<li><a href="../fr415229/index.html">DevTube - Nouvel agr√©gateur vid√©o open source pour les d√©veloppeurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>