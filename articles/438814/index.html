<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß¢ üë©üèΩ‚Äçüè≠ üßòüèº Una mirada sobria a Helm 2: "Eso es lo que es ..." ‚è∏Ô∏è üìò üéø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Al igual que cualquier otra soluci√≥n, Helm, el administrador de paquetes de Kubernetes, tiene ventajas, desventajas y alcance, por lo que al usarlo, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Una mirada sobria a Helm 2: "Eso es lo que es ..."</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/438814/">  Al igual que cualquier otra soluci√≥n, Helm, el administrador de paquetes de Kubernetes, tiene ventajas, desventajas y alcance, por lo que al usarlo, debe evaluar correctamente sus expectativas ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ix/5j/fm/ix5jfmapr_v4yignapctr-x7_jc.jpeg"></div><br>  Usamos Helm en nuestro arsenal de herramientas de laminaci√≥n continua.  Al momento de escribir, hay <b>m√°s de mil aplicaciones</b> en nuestros cl√∫steres y alrededor de 4000 instalaciones de estas aplicaciones en diversas variaciones.  Peri√≥dicamente encontramos problemas, pero en general estamos satisfechos con la soluci√≥n, no tenemos tiempo de inactividad ni p√©rdida de datos. <br><br>  El motivo principal para escribir este art√≠culo es proporcionar al usuario una <b>evaluaci√≥n objetiva de los</b> principales problemas de Helm 2 sin conclusiones definitivas, as√≠ como el deseo de compartir experiencias y nuestras soluciones. <a name="habracut"></a><br><br><h2>  [ERROR] Despu√©s de la implementaci√≥n, el estado de los recursos de liberaci√≥n en el cl√∫ster no corresponde al gr√°fico Helm descrito </h2><br>  Al trabajar, Helm no tiene en cuenta el estado de los recursos de liberaci√≥n en el cl√∫ster.  Al reinstalar, el resultado est√° determinado solo por las configuraciones actuales y guardadas.  Por lo tanto, el estado del recurso en el cl√∫ster y el registro de Helm es diferente, y Helm no tiene esto en cuenta. <br><br>  Considere c√≥mo se manifiesta este problema: <br><br><ol><li>  La plantilla de recursos en el gr√°fico corresponde al estado X. </li><li>  El usuario instala el gr√°fico (Tiller guarda el estado del recurso X). </li><li>  A continuaci√≥n, el usuario cambia manualmente el recurso en el cl√∫ster (el estado cambia de X a Y). </li><li>  Sin realizar ning√∫n cambio, realiza la <code>helm upgrade</code> ... Y el recurso todav√≠a est√° en estado Y, aunque el usuario espera X. </li></ol><br>  Y eso no es todo.  En alg√∫n momento, el usuario cambia la plantilla de recursos en el gr√°fico (nuevo estado W), luego tenemos dos escenarios despu√©s de la <code>helm upgrade</code> : <br><br><ul><li>  La aplicaci√≥n del parche XW est√° cayendo. </li><li>  Despu√©s de aplicar el parche, el recurso pasa al estado Z, que no corresponde al deseado. </li></ul><br>  Para evitar este problema, se propone organizar el trabajo con versiones de la siguiente manera: <b>nadie debe cambiar los recursos manualmente</b> , Helm es la √∫nica herramienta para trabajar con los recursos de la versi√≥n.  Idealmente, los cambios de gr√°ficos se versionan en el repositorio de Git y se aplican <b>exclusivamente</b> dentro del CD. <br><br>  Si esta opci√≥n no es adecuada, puede <b>supervisar la sincronizaci√≥n de los estados de los recursos de la</b> versi√≥n.  La sincronizaci√≥n manual puede verse as√≠: <br><br><ol><li>  Descubrimos el estado de los recursos de lanzamiento a trav√©s de <code>helm get</code> . </li><li>  Descubra el estado de los recursos en Kubernetes a trav√©s de <code>kubectl get</code> . </li><li>  Si los recursos son diferentes, sincronizamos Helm con Kubernetes: <br><ol><li>  Crea una rama separada. </li><li>  Actualizaci√≥n de los manifiestos de la tabla.  Las plantillas deben coincidir con los estados de recursos en Kubernetes. </li><li>  Realizamos el despliegue.  Sincronizamos el estado en el registro de Helm y el cl√∫ster. </li><li>  Despu√©s de eso, la rama se puede eliminar y continuar con el trabajo regular. </li></ol></li></ol><br>  Al aplicar parches utilizando el <code>kubectl apply</code> , se ejecuta la llamada <b>fusi√≥n de 3 v√≠as,</b> es decir,  Se tiene en cuenta el estado real del recurso actualizado.  Puede ver el c√≥digo del algoritmo <a href="">aqu√≠</a> y leer sobre esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  Al momento de escribir, los desarrolladores de Helm est√°n buscando formas de implementar la fusi√≥n de 3 v√≠as en Helm 3. Con Helm 2, las cosas no son tan optimistas: la fusi√≥n de 3 v√≠as no est√° planificada para implementarse, pero hay un RP para corregir la forma en que se crean los recursos: puede encontrar detalles o incluso participar como parte de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuesti√≥n relevante</a> . <br><br><h2>  [ERROR] Error: no se encontr√≥ ning√∫n RECURSO con el nombre NOMBRE </h2><br>  El problema se manifiesta si los <b>nuevos recursos</b> se crean con √©xito cuando se repite el despliegue, y el despliegue en s√≠ mismo finalmente falla.  <b>Nuevos recursos</b> significan aquellos que no estaban en la √∫ltima instalaci√≥n de la tabla. <br><br>  Si el despliegue falla, la versi√≥n se guarda en el registro marcado <b>FAILED</b> , y durante la instalaci√≥n, Helm se basa en el estado de la √∫ltima versi√≥n <b>DESPLEGADA</b> , que en este caso no sabe nada sobre los nuevos recursos.  Como resultado, Helm intenta recrear estos recursos y falla con el error "no se encontr√≥ ning√∫n RECURSO con el nombre NAME" (el error dice lo contrario, pero este es el problema).  Parte del problema es que Helm no tiene en cuenta el estado de los recursos de liberaci√≥n en el cl√∫ster al crear el parche, como se describe en la secci√≥n anterior. <br><br>  Por ahora, la √∫nica soluci√≥n es eliminar manualmente los nuevos recursos. <br><br>  Para evitar tal estado, es posible eliminar autom√°ticamente los nuevos recursos creados en la actualizaci√≥n / reversi√≥n actual si el comando finalmente falla.  Despu√©s de una larga discusi√≥n con los desarrolladores de Helm, para los comandos de actualizaci√≥n / reversi√≥n, se agreg√≥ la opci√≥n <code>--cleanup-on-fail</code> , que activa la limpieza autom√°tica cuando falla la implementaci√≥n.  Nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RP</a> est√° en discusi√≥n, buscando la mejor soluci√≥n. <br><br>  A partir de la versi√≥n 2.13 de Helm, la opci√≥n <code>--atomic</code> aparece en los <code>--atomic</code> <code>helm install/upgrade</code> , que activa la limpieza y la reversi√≥n durante una instalaci√≥n fallida (para m√°s detalles, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PR</a> ). <br><br><h2>  [ERROR] Error: reloj cerrado antes Hasta el tiempo de espera </h2><br>  El problema puede ocurrir cuando el enlace Helm se ejecuta durante demasiado tiempo (por ejemplo, durante las migraciones), aunque no se excedan los tiempos de espera especificados de <code>helm install/upgrade</code> de <code>helm install/upgrade</code> y <code>spec.activeDeadlineSeconds</code> trabajo correspondiente. <br><br>  Este error es generado por el servidor API de Kubernetes mientras espera que se complete el trabajo de enlace.  Helm no maneja este error y se bloquea inmediatamente, en lugar de volver a intentar la solicitud de espera. <br><br>  Como soluci√≥n, puede aumentar el tiempo de espera en api-server: <code>--min-request-timeout=xxx</code> en el archivo <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> . <br><br><h2>  [ERROR] Error: NO SE PUEDE ACTUALIZAR: "foo" no tiene lanzamientos implementados </h2><br>  Si falla la primera versi√≥n a trav√©s de la <code>helm install</code> , la <code>helm upgrade</code> posterior de <code>helm upgrade</code> devolver√° un error similar. <br><br>  Parece que la soluci√≥n es bastante simple: necesita realizar manualmente la <code>helm delete --purge</code> despu√©s de una primera instalaci√≥n fallida, pero esta acci√≥n manual interrumpe la automatizaci√≥n de CI / CD.  Para no interrumpir la ejecuci√≥n de comandos manuales, puede utilizar las funciones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">werf</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementar</a> .  Al usar werf, la versi√≥n problem√°tica se volver√° a crear autom√°ticamente tras la reinstalaci√≥n. <br><br>  Adem√°s, comenzando con Helm 2.13, en los <code>helm upgrade --install</code> <code>helm install</code> y <code>helm upgrade --install</code> simplemente especifique la opci√≥n <code>--atomic</code> y, despu√©s de una instalaci√≥n fallida, la versi√≥n se eliminar√° autom√°ticamente (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PR para m√°s</a> detalles). <br><br><h2>  Autorollback </h2><br>  Helm carece de la opci√≥n <code>--autorollback</code> , que, cuando <code>--autorollback</code> , recordar√° la revisi√≥n exitosa actual (se eliminar√° si la √∫ltima revisi√≥n no es exitosa) y, despu√©s de un intento de implementaci√≥n fallido, regresar√° a la revisi√≥n guardada. <br><br>  Dado que es cr√≠tico que el producto funcione sin interrupciones, es necesario buscar soluciones, la implementaci√≥n debe ser predecible.  Para minimizar la probabilidad de tiempo de inactividad del producto, a menudo se utiliza un <b>enfoque con varios circuitos</b> (por ejemplo, etapas, qa y producci√≥n), que consiste en el despliegue secuencial en los circuitos.  Con este enfoque, la mayor√≠a de los problemas se solucionan antes de lanzarlos a la productividad y, junto con el autorolback, le permite lograr buenos resultados. <br><br>  Para organizar el retroceso autom√°tico, puede usar el complemento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">helm-monitor</a> , que le permite vincular el retroceso a las m√©tricas de Prometheus.  Un buen art√≠culo que describe este enfoque est√° disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  Para algunos de nuestros proyectos, se utiliza un enfoque bastante simple: <br><br><ol><li>  Antes del despliegue, recordamos la revisi√≥n actual (creemos que en una situaci√≥n normal, si la versi√≥n existe, entonces necesariamente est√° en el estado DESPLEGADO): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> _RELEASE_NAME=myrelease <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> _LAST_DEPLOYED_RELEASE=$(helm list -adr | \ grep <span class="hljs-variable"><span class="hljs-variable">$_RELEASE_NAME</span></span> | grep DEPLOYED | head -n2 | awk <span class="hljs-string"><span class="hljs-string">'{print $2}'</span></span>)</code> </pre> </li><li>  Ejecute instalar o actualizar: <br><br><pre> <code class="bash hljs">helm install/upgrade ... || <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> _DEPLOY_FAILED=1</code> </pre> </li><li>  Verificamos el estado de la implementaci√≥n y hacemos la reversi√≥n al estado guardado: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$_DEPLOY_FAILED</span></span></span><span class="hljs-string">"</span></span> == <span class="hljs-string"><span class="hljs-string">"1"</span></span> ] &amp;&amp; [ <span class="hljs-string"><span class="hljs-string">"x</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$_LAST_DEPLOYED_RELEASE</span></span></span><span class="hljs-string">"</span></span> != <span class="hljs-string"><span class="hljs-string">"x"</span></span> ] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> helm rollback <span class="hljs-variable"><span class="hljs-variable">$_RELEASE_NAME</span></span> <span class="hljs-variable"><span class="hljs-variable">$_LAST_DEPLOYED_RELEASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> </li><li>  Terminamos la canalizaci√≥n con un error si la implementaci√≥n no tuvo √©xito: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$_DEPLOY_FAILED</span></span></span><span class="hljs-string">"</span></span> == <span class="hljs-string"><span class="hljs-string">"1"</span></span> ] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 ; <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> </li></ol><br>  Nuevamente, comenzando con la versi√≥n 2.13 de Helm, cuando se llama a la <code>helm upgrade</code> Helm <code>helm upgrade</code> suficiente especificar la opci√≥n <code>--atomic</code> y luego de una instalaci√≥n fallida, la reversi√≥n se realizar√° autom√°ticamente (ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PR para m√°s</a> detalles). <br><br><h2>  Esperando la disponibilidad de recursos de lanzamiento y comentarios al momento del lanzamiento </h2><br>  Seg√∫n lo planeado, Helm debe monitorear la ejecuci√≥n de las pruebas de vida y preparaci√≥n correspondientes cuando se usa la opci√≥n <code>--wait</code> : <br><br><pre> <code class="bash hljs">--<span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>, will <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> until all Pods, PVCs, Services, and minimum number of Pods of a Deployment are <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a ready state before marking the release as successful. It will <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> as long as --timeout</code> </pre> <br>  Esta funci√≥n no funciona correctamente ahora: no todos los recursos y no todas las versiones de API son compatibles.  Y el proceso de espera declarado en s√≠ no satisface nuestras necesidades. <br><br>  Al igual que con <code>kubectl wait</code> , no hay comentarios r√°pidos y no hay forma de regular este comportamiento.  Si el despliegue falla, lo sabremos <b>solo despu√©s de un tiempo de espera</b> .  En caso de una instalaci√≥n problem√°tica, es necesario completar el proceso de implementaci√≥n lo antes posible, voltear la tuber√≠a de CI / CD, revertir el lanzamiento a la versi√≥n de trabajo y proceder a la depuraci√≥n. <br><br>  Si la versi√≥n problem√°tica se revierte y Helm no devuelve ninguna informaci√≥n durante el proceso de implementaci√≥n, ¬øde qu√© se trata la depuraci√≥n?  En el caso de <code>kubectl wait</code> puede organizar un proceso separado para mostrar registros, lo que requerir√° liberar nombres de recursos.  C√≥mo organizar una soluci√≥n simple y funcional no est√° claro de inmediato.  Y adem√°s de los registros de pod, puede contener informaci√≥n √∫til en el proceso de implementaci√≥n, eventos de recursos ... <br><br>  Nuestra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">utilidad werf</a> CI / CD puede implementar un gr√°fico Helm y monitorear la disponibilidad de recursos, as√≠ como mostrar informaci√≥n relacionada con el despliegue.  Todos los datos se combinan en una sola secuencia y se env√≠an al registro. <br><br>  Esta l√≥gica se realiza en una soluci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">kubedog</a> separada.  Con la utilidad, puede suscribirse a un recurso y recibir eventos y registros, as√≠ como aprender sobre despliegues fallidos de manera oportuna.  Es decir  Como soluci√≥n, despu√©s de llamar a <code>helm install/upgrade</code> sin la opci√≥n <code>--wait</code> , puede llamar a kubedog para cada recurso de lanzamiento. <br><br>  Nuestro objetivo era crear una herramienta que proporcione toda la informaci√≥n necesaria para la depuraci√≥n en la salida de la canalizaci√≥n de CI / CD.  Lea m√°s sobre la utilidad en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuestro art√≠culo reciente</a> . <br><br>  Quiz√°s en Helm 3 alg√∫n d√≠a aparezca una soluci√≥n similar, pero hasta ahora nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problema</a> est√° en un estado suspendido. <br><br><h2>  Seguridad cuando se usa helm init por defecto </h2><br>  De manera predeterminada, cuando se ejecuta el <code>helm init</code> , el componente del servidor se instala en el cl√∫ster con privilegios similares al superusuario, lo que puede tener consecuencias no deseadas cuando terceros acceden a √©l. <br><br>  Para garantizar la seguridad del cl√∫ster, es necesario limitar las capacidades de Tiller, as√≠ como cuidar la conexi√≥n: la seguridad de la red a trav√©s de la cual se lleva a cabo la comunicaci√≥n entre los componentes de Helm. <br><br>  El primero se puede lograr mediante el uso del mecanismo est√°ndar Ruber Kubernetes, que limitar√° las acciones del tim√≥n, y el segundo, mediante la configuraci√≥n de SSL.  Lea m√°s en la documentaci√≥n de Helm: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asegurar su instalaci√≥n de Helm</a> . <br><br>  <i>Se cree que la presencia del componente del servidor, Tiller, es un <b>grave error arquitect√≥nico</b> , literalmente un recurso extranjero con derechos de superusuario en el ecosistema de Kubernetes.</i>  <i>En parte, estamos de acuerdo: la implementaci√≥n es imperfecta, pero <b>echemos un vistazo a esto desde el otro lado</b> .</i>  <i>Si interrumpe el proceso de implementaci√≥n y elimina el cliente Helm, el sistema no permanecer√° en un estado indefinido, es decir,</i>  <i>Tiller traer√° el estado de lanzamiento a v√°lido.</i>  <i>Tambi√©n es necesario comprender que a pesar del hecho de que Tiller se abandona en Helm 3, estas funciones ser√°n de alguna manera realizadas por el controlador CRD.</i> <br><br><h2>  Martian Go Templates </h2><br>  Las plantillas Go tienen un umbral de entrada grande, pero la tecnolog√≠a no tiene limitaciones en las capacidades y problemas con DRY.  Los principios b√°sicos, la sintaxis, las funciones y los operadores se analizan en nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior</a> de la serie Helm. <br><br><h2>  Falta de secretos fuera de la caja </h2><br>  Es conveniente almacenar y mantener el c√≥digo de la aplicaci√≥n, la infraestructura y las plantillas de implementaci√≥n cuando se encuentran en un solo lugar.  Y los secretos no son la excepci√≥n. <br><br>  Helm no admite secretos listos para usar, sin embargo, el complemento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">helm-secrets</a> est√° disponible, que es esencialmente una capa entre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sops</a> , el administrador de secretos de Mozilla y Helm. <br><br>  Cuando trabajamos con secretos, utilizamos nuestra propia soluci√≥n implementada en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">werf</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n sobre secretos</a> ).  De las caracter√≠sticas: <br><br><ul><li>  Facilidad de implementaci√≥n. </li><li>  Mantener un secreto en un archivo, no solo en YAML.  Conveniente al almacenar certificados, llaves. </li><li>  Regeneraci√≥n de secretos con una nueva clave. </li><li>  Implementaci√≥n sin una clave secreta (cuando se utiliza werf).  Puede ser √∫til para aquellos casos en que el desarrollador no tiene esta clave secreta, pero es necesario iniciar una implementaci√≥n en una prueba o circuito local. </li></ul><br><h2>  Conclusi√≥n </h2><br>  Helm 2 se posiciona como un producto estable, pero al mismo tiempo hay muchos errores que cuelgan en el limbo (¬°algunos de ellos duran varios a√±os!).  En lugar de soluciones, o al menos parches, todos los esfuerzos se dedican al desarrollo de Helm 3. <br><br>  A pesar del hecho de que MR y el problema pueden colgar durante meses ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠ hay un ejemplo</a> de c√≥mo agregamos una <code>before-hook-creation policy</code> de anzuelos antes de anzuelos durante varios meses), a√∫n puede participar en el desarrollo del proyecto.  Todos los jueves hay una reuni√≥n de media hora de desarrolladores de Helm, donde puedes aprender sobre las prioridades y las instrucciones actuales del equipo, hacer preguntas y forzar tus propias mejores pr√°cticas.  Acerca de mete y otros canales de comunicaci√≥n se escribe en detalle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  Si usar Helm o no depende de usted, por supuesto.  Hoy nos adherimos a una posici√≥n tal que, a pesar de las deficiencias, Helm es una soluci√≥n aceptable para el despliegue y es √∫til para que toda la comunidad participe en su desarrollo. <br><br><h2>  PS </h2><br>  Lea tambi√©n en nuestro blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Creaci√≥n de paquetes para Kubernetes con Helm: estructura de gr√°ficos y plantillas</a> "; </li><li>  ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Una introducci√≥n pr√°ctica al administrador de paquetes para Kubernetes - Helm</a> ‚Äù; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Administrador de paquetes para Kubernetes - Helm: pasado, presente, futuro</a> "; </li><li>  ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Practica con dapp.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2. Implementar im√°genes de Docker en Kubernetes con Helm</a> ". </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438814/">https://habr.com/ru/post/438814/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438804/index.html">Esperando a todos en la pr√≥xima reuni√≥n de CocoaHeads</a></li>
<li><a href="../438806/index.html">Problemas de traducci√≥n literaria.</a></li>
<li><a href="../438808/index.html">ModelMapper: ida y vuelta</a></li>
<li><a href="../438810/index.html">HTTP / 3: de ra√≠z a punta</a></li>
<li><a href="../438812/index.html">Calidad de c√≥digo de front-end HH</a></li>
<li><a href="../438818/index.html">UDB Que es esto Parte 5. Ruta de datos. Peque√±as cosas √∫tiles</a></li>
<li><a href="../438820/index.html">Gesti√≥n del conocimiento: qu√© documentos se necesitan y qu√© arreglar en ellos</a></li>
<li><a href="../438824/index.html">Curso corto de gesti√≥n remota</a></li>
<li><a href="../438826/index.html">Aprender ingl√©s para una entrevista: metodolog√≠a y costos laborales</a></li>
<li><a href="../438828/index.html">Lazarus: escribir un componente para la animaci√≥n de sprites</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>