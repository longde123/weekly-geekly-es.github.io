<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§‘ğŸ¿â€ğŸ¤â€ğŸ§‘ğŸ½ ğŸ“½ï¸ ğŸ’» Implementasi operator dalam di C ++ ğŸ‘ˆğŸ¿ ğŸ¾ ğŸ®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Hari ini saya berharap menunjukkan beberapa keajaiban. Hobi saya adalah menciptakan semua jenis karya yang tampaknya mustahil di C ++, yang memban...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementasi operator dalam di C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419579/">  Hai  Hari ini saya berharap menunjukkan beberapa keajaiban.  Hobi saya adalah menciptakan semua jenis karya yang tampaknya mustahil di C ++, yang membantu saya mempelajari semua jenis seluk-beluk bahasa, atau hanya untuk bersenang-senang.  Operator in ada dalam beberapa bahasa, misalnya Python, JS.  Tetapi mereka tidak membawanya dalam C ++, tetapi kadang-kadang saya menginginkannya, jadi mengapa tidak menerapkannya. <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; some_map = { { <span class="hljs-string"><span class="hljs-string">"black"</span></span>, <span class="hljs-string"><span class="hljs-string">"white"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"cat"</span></span>, <span class="hljs-string"><span class="hljs-string">"dog"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"day"</span></span>, <span class="hljs-string"><span class="hljs-string">"night"</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res = <span class="hljs-string"><span class="hljs-string">"cat"</span></span> in some_map) { res-&gt;second = <span class="hljs-string"><span class="hljs-string">"fish"</span></span>; }</code> </pre> <br><a name="habracut"></a><br>  Bagaimana operator seharusnya bekerja, saya pikir sudah jelas.  Dia mengambil objek kiri dan memeriksa apakah ada kejadian objek ini di objek yang ditunjukkan di sebelah kanan, yang tidak harus menjadi koleksi.  Tidak ada solusi universal dengan sendirinya, sama seperti tidak ada solusi universal untuk operator lain, oleh karena itu, kemungkinan overloading mereka diciptakan.  Oleh karena itu, untuk operator dalam, Anda perlu menerapkan mekanisme serupa. <br><br>  Kelebihan akan terlihat seperti ini. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator_in</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unordered_map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data.find(key) != data.end(); }</code> </pre><br>  Saya pikir idenya jelas, ekspresi spesies. <br><br><pre> <code class="cpp hljs"> <span class="hljs-string"><span class="hljs-string">"some string"</span></span> in some_map</code> </pre><br>  Seharusnya berubah menjadi panggilan fungsi. <br><br><pre> <code class="cpp hljs"> operator_in(<span class="hljs-string"><span class="hljs-string">"some string"</span></span>, some_map)</code> </pre><br>  Menerapkan mekanisme ini cukup sederhana, menggunakan kapabilitas yang ada untuk overloading operator.  Operator in itu sendiri pada dasarnya adalah makro yang melakukan perkalian. <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> in *OP_IN_HELP{}*</span></span></code> </pre><br>  Dalam hal ini, <b>OP_IN_HELP</b> adalah kelas kosong dan hanya melayani kami untuk memilih kelebihan beban yang benar. <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OP_IN_HELP</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIn</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OP_IN_LVAL</span></span></span><span class="hljs-class">&lt;TIn&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">*(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIn</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OP_IN_HELP</span></span></span><span class="hljs-class">&amp;) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OP_IN_LVAL&lt;TIn&gt;(data); }</code> </pre><br>  Operatornya adalah boilerplate, yang memungkinkan Anda menerima jenis apa pun sebagai argumen pertama.  Sekarang kita perlu entah bagaimana mendapatkan objek yang tepat, tanpa kehilangan yang kiri.  Untuk melakukan ini, kami menerapkan kelas <b>OP_IN_LVAL</b> yang akan menyimpan objek kiri kami. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIn</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OP_IN_LVAL</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIn&amp; m_in; OP_IN_LVAL(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIn&amp; val) : m_in(val) {}; };</code> </pre><br>  Karena objek itu sendiri akan hidup ketika ekspresi sedang berjalan, tidak ada yang perlu dikhawatirkan jika kita tetap menggunakan referensi konstan untuk objek ini.  Sekarang yang tersisa bagi kita adalah mengimplementasikan operator internal dari perkalian, yang akan mengembalikan kepada kita hasil dari operator yang kelebihan beban, itu akan menjadi template dengan sendirinya. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIn</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OP_IN_LVAL</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIn&amp; m_in; OP_IN_LVAL(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIn&amp; val) : m_in(val) {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TWhat</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">*(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TWhat</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">what</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> operator_in(m_in, what); } };</code> </pre><br>  Sebenarnya solusi ini sudah berfungsi, tetapi terbatas dan tidak akan mengizinkan kami menulis dengan cara ini. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res = <span class="hljs-string"><span class="hljs-string">"true"</span></span> in some_map) { res-&gt;second = <span class="hljs-string"><span class="hljs-string">"false"</span></span>; }</code> </pre><br>  Agar kita memiliki kesempatan seperti itu, kita perlu membuang nilai kembali dari operator yang kelebihan beban.  Ada dua versi cara melakukan ini, yang satu menggunakan kemampuan C ++ 14, yang lainnya bekerja di dalam C ++ 11. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIn</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OP_IN_LVAL</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIn&amp; m_in; OP_IN_LVAL(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIn&amp; val) :m_in(val) {}; <span class="hljs-comment"><span class="hljs-comment">//   C++14 template&lt;class TWhat&gt; auto operator*(const TWhat&amp; what) const { return operator_in(m_in, what); } //   C++11 template&lt;class TWhat&gt; auto operator*(const TWhat&amp; what) const -&gt; decltype(operator_in(m_in, what)) { return operator_in(m_in, what); } //       //       template&lt;class TWhat&gt; auto operator*(TWhat&amp; what) const -&gt; decltype(operator_in(m_in, what)) { return operator_in(m_in, what); } };</span></span></code> </pre><br>  Karena saya terutama bekerja di Visual Studio 2013, saya terbatas pada kerangka kerja C ++ 11 dan solusi dalam C ++ 11 akan bekerja dengan sukses di C ++ 14, jadi saya menyarankan Anda untuk memilihnya. <br><br>  Contoh implementasi dari operator generik dalam untuk unordered_map. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TIterator</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpInResult</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_result; TIterator m_iter; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: OpInResult(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result, TIterator&amp; iter) : m_result(result), m_iter(iter) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_result; } TIterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_iter; } <span class="hljs-function"><span class="hljs-function">TIterator&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_iter; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TKey</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TVal</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator_in</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TKey</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;TKey, TVal&gt;&amp; data) -&gt; OpInResult&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;TKey, TVal&gt;::iterator&gt; { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> iter = data.find(key); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OpInResult&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;TKey, TVal&gt;::iterator&gt;(iter != data.end(), iter); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TKey</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TVal</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator_in</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;TKey, TVal&gt;&amp; data) -&gt; OpInResult&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;TKey, TVal&gt;::iterator&gt; { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> iter = data.find(key); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OpInResult&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;TKey, TVal&gt;::iterator&gt;(iter != data.end(), iter); }</code> </pre><br>  Kelas <b>OpInResult</b> memungkinkan <b>Anda</b> untuk menimpa operator transmisi, yang memungkinkan kami untuk menggunakannya jika.  Itu juga menimpa operator panah, yang memungkinkan Anda untuk menutupi diri Anda sebagai iterator yang mengembalikan unordered_map.find (). <br><br>  Contohnya dapat ditemukan di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cpp.sh/7rfdw</a> <br><br>  Saya juga ingin mengatakan tentang beberapa fitur dari solusi ini. <br>  Visual Studio instantiates templat di tempat penggunaan, yang berarti bahwa fungsi kelebihan itu sendiri harus dideklarasikan sebelum operator digunakan, tetapi dapat dideklarasikan setelah <b>deklarasi</b> kelas <b>OP_IN_LVAL</b> .  GCC pada gilirannya membuat instantiates templat di lokasi pernyataan (ketika menemukan penggunaannya sendiri), yang berarti bahwa pernyataan kelebihan beban harus dideklarasikan sebelum kelas <b>OP_IN_LVAL dideklarasikan</b> .  Jika tidak sepenuhnya jelas tentang apa ini, maka inilah contohnya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cpp.sh/5jxcq</a> Dalam kode ini, saya hanya membebani operator di bawah <b>deklarasi</b> kelas <b>OP_IN_LVAL</b> dan berhenti mengkompilasi di GCC (kecuali jika dikompilasi dengan flag -fpermissive), tetapi berhasil dikompilasi di Visual Studio. <br><br>  Di C ++ 17, menjadi mungkin untuk menulis seperti ini. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res = some_map.find(<span class="hljs-string"><span class="hljs-string">"true"</span></span>); res != some_map.end()) { res-&gt;second = <span class="hljs-string"><span class="hljs-string">"false"</span></span>; }</code> </pre><br>  Tapi menurut saya desain tampilan <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res = <span class="hljs-string"><span class="hljs-string">"true"</span></span> in some_map) { res-&gt;second = <span class="hljs-string"><span class="hljs-string">"false"</span></span>; }</code> </pre><br>  Terlihat lebih bagus. <br><br>  Contoh lebih banyak kelebihan dapat dilihat di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/ChaosOptima/operator_in</a> <br><br>  Berdasarkan prinsip implementasi operator ini, juga tidak akan ada masalah untuk diterapkan <br>  dan operator dan ekspresi lainnya, misalnya. <br><br><pre> <code class="cpp hljs"> negative = FROM some_vector WHERE [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x){<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>;};</code> </pre><br><div class="spoiler">  <b class="spoiler_title">PS</b> <div class="spoiler_text">  Saya ingin tahu jika Anda tertarik dengan topik seperti itu, apakah ada gunanya menulis tentang hal ini di sini?  Dan apakah Anda ingin tahu bagaimana menerapkan hal-hal menarik lainnya? <br><br>  operator kondisi nol <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = $<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_ptr $-&gt;func1()$-&gt;func2()$-&gt;func3(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)$endif;</code> </pre><br>  pencocokan patern <br><br><pre> <code class="cpp hljs"> succes = patern_match val with_type(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"some int "</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } with_cast(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; items) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; val : items) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } with(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>()) [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"empty string\n"</span></span>; } with(oneof&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"one"</span></span>, <span class="hljs-string"><span class="hljs-string">"two"</span></span>, <span class="hljs-string"><span class="hljs-string">"three"</span></span>)) [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; value) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; value &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } with_cast(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; str) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"some str "</span></span> &lt;&lt; str &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } at_default { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"no match"</span></span>; };</code> </pre><br>  string enum <br><br><pre> <code class="cpp hljs"> StringEnum Power $def ( POW0, POW1, POW2 = POW1 * <span class="hljs-number"><span class="hljs-number">2</span></span>, POW3, POW4 = POW3 + <span class="hljs-number"><span class="hljs-number">1</span></span>, POW8 = POW4 * <span class="hljs-number"><span class="hljs-number">2</span></span>, POW9, POW10 ); to_string(Power::POW0) from_string&lt;Power&gt;(<span class="hljs-string"><span class="hljs-string">"POW0"</span></span>)</code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419579/">https://habr.com/ru/post/id419579/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419569/index.html">Slurm: video kelas dan aspek organisasi</a></li>
<li><a href="../id419571/index.html">Posisi itu bagus, tetapi mereka terus menanam untuk repost</a></li>
<li><a href="../id419573/index.html">Pengalaman Wisata Luar Angkasa</a></li>
<li><a href="../id419575/index.html">Mengikuti persyaratan untuk menunjukkan kecepatan koneksi yang tepat, penyedia UK mengurangi jumlah iklan rata-rata 41%</a></li>
<li><a href="../id419577/index.html">Desain hal-hal yang familier: cara meningkatkan antarmuka pada contoh YouTube</a></li>
<li><a href="../id419581/index.html">Apa proyek nirlaba yang menarik untuk Y Combinator</a></li>
<li><a href="../id419583/index.html">Bagaimana Rusia melewatkan masa kejayaan DVD, tetapi menyusul dengan Barat dengan munculnya Internet broadband</a></li>
<li><a href="../id419585/index.html">PWA mudah. Halo habr</a></li>
<li><a href="../id419587/index.html">Kompetisi yang mengubah dunia. 1567 - 2035</a></li>
<li><a href="../id419589/index.html">Kami menggunakan AMP sebagai pustaka serba guna untuk membuat situs dinamis cepat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>