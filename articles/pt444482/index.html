<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì≠ üëáüèΩ üêñ O que infla a mem√≥ria no Ruby? üôãüèª üì• üïã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="N√≥s da Phusion temos um proxy HTTP multiencadeado simples em Ruby (distribui pacotes DEB e RPM). Vi nele um consumo de mem√≥ria de 1,3 GB. Mas isso √© l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O que infla a mem√≥ria no Ruby?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444482/">  N√≥s da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Phusion temos</a> um proxy HTTP multiencadeado simples em Ruby (distribui pacotes DEB e RPM).  Vi nele um consumo de mem√≥ria de 1,3 GB.  Mas isso √© louco por um processo sem estado ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ba/f7a/d2b/9baf7ad2bd3ecdfb0779482c018473eb.jpg"></div><br>  <i><font color="gray">Pergunta: O que √© isso?</font></i>  <i><font color="gray">Resposta: Ruby usa mem√≥ria ao longo do tempo!</font></i> <br><br>  Acontece que n√£o estou sozinho nesse problema.  Aplicativos Ruby podem usar muita mem√≥ria.  Mas porque?  De acordo com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Heroku</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nate Burkopek</a> , o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">incha√ßo</a> deve-se principalmente √† fragmenta√ß√£o da mem√≥ria e √† distribui√ß√£o excessiva de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">heap</a> . <br><a name="habracut"></a><br>  Berkopek concluiu que existem duas solu√ß√µes: <br><br><ol><li>  Use um alocador de mem√≥ria completamente diferente do glibc - geralmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jemalloc</a> , ou: </li><li> Defina a vari√°vel de ambiente m√°gica <code>MALLOC_ARENA_MAX=2</code> . </li></ol><br>  Estou preocupado com a descri√ß√£o do problema e as solu√ß√µes propostas.  H√° algo errado aqui ... N√£o tenho certeza de que o problema esteja totalmente descrito corretamente ou que essas sejam as √∫nicas solu√ß√µes dispon√≠veis.  Tamb√©m me incomoda que muitos se refiram ao jemalloc como uma piscina m√°gica de prata. <br><br>  <b>Magia √© apenas uma ci√™ncia que ainda n√£o entendemos</b> .  Ent√£o, eu fui em uma viagem de pesquisa para descobrir toda a verdade.  Este artigo abordar√° os seguintes t√≥picos: <br><br><ol><li>  Como a aloca√ß√£o de mem√≥ria funciona. <br></li><li>  O que √© essa "fragmenta√ß√£o" e "distribui√ß√£o excessiva" de mem√≥ria que todo mundo est√° falando? <br></li><li>  O que causa um grande consumo de mem√≥ria?  A situa√ß√£o √© consistente com o que as pessoas est√£o dizendo ou h√° algo mais?  (spoiler: sim, h√° outra coisa). <br></li><li>  Existem solu√ß√µes alternativas?  (spoiler: eu encontrei um). </li></ol><br>  <i>Nota: este artigo √© relevante apenas para Linux e somente para aplicativos Ruby com v√°rios threads.</i> <br><br><h1>  Conte√∫do </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aloca√ß√£o de mem√≥ria Ruby: uma introdu√ß√£o</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ruby</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Alocador de mem√≥ria do sistema</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O n√∫cleo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Defini√ß√£o de uso de mem√≥ria</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que √© fragmenta√ß√£o?</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fragmenta√ß√£o em n√≠vel de rubi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fragmenta√ß√£o de Aloca√ß√£o de Mem√≥ria</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A fragmenta√ß√£o da p√°gina de pilha Ruby est√° causando incha√ßo na mem√≥ria?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estudo de fragmenta√ß√£o de aloca√ß√£o de mem√≥ria</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aloca√ß√£o excessiva de mem√≥ria e glibc</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Visualiza√ß√£o de pilhas do sistema</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Truque de M√°gica: Circuncis√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conclus√£o</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C√≥digo-fonte do Visualizer</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">E o desempenho?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Precisa de mais testes.</a> </li></ul></li></ul><br><a name="1"></a><h1>  Aloca√ß√£o de mem√≥ria Ruby: uma introdu√ß√£o </h1><br>  Ruby aloca mem√≥ria em tr√™s n√≠veis, de cima para baixo: <br><br><ol><li>  Int√©rprete Ruby que gerencia objetos Ruby. <br></li><li>  A biblioteca do alocador de mem√≥ria do sistema operacional. <br></li><li>  O n√∫cleo. </li></ol><br>  Vamos passar por cada n√≠vel. <br><br><a name="1_1"></a><h3>  Ruby </h3><br>  Por outro lado, Ruby organiza objetos em √°reas da mem√≥ria chamadas <i>p√°ginas de pilha</i> do <i>Ruby</i> .  Essa p√°gina de heap √© dividida em slots do mesmo tamanho, onde um objeto ocupa um slot.  Seja uma sequ√™ncia de caracteres, uma tabela de hash, uma matriz, uma classe ou outra coisa, ela ocupa um slot. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d6/155/0be/2d61550be208df42ad3052ca1f821807.png"></div><br><br>  Os slots na p√°gina da pilha podem estar ocupados ou livres.  Quando Ruby seleciona um novo objeto, ele imediatamente tenta ocupar um espa√ßo livre.  Se n√£o houver slots livres, uma nova p√°gina de heap ser√° destacada. <br><br>  O slot √© pequeno, cerca de 40 bytes.  Obviamente, alguns objetos n√£o cabem nele, por exemplo, linhas de 1 MB.  Em seguida, Ruby armazena as informa√ß√µes em outro local fora da p√°gina da pilha e coloca um ponteiro para essa √°rea de mem√≥ria externa no slot. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/e96/1c6/1e5e961c6c90ed1cd17daa8ab19d8212.png"></div><br>  <i><font color="gray">Os dados que n√£o cabem no slot s√£o armazenados fora da p√°gina da pilha.</font></i>  <i><font color="gray">Ruby coloca um ponteiro para esses dados externos no slot</font></i> <br><br>  As p√°ginas de heap do Ruby e quaisquer √°reas de mem√≥ria externa s√£o alocadas usando o alocador de mem√≥ria do sistema. <br><br><a name="1_2"></a><h3>  Alocador de mem√≥ria do sistema </h3><br>  O alocador de mem√≥ria do sistema operacional faz parte do glibc (C runtime).  √â usado por quase todas as aplica√ß√µes, n√£o apenas pelo Ruby.  Possui uma API simples: <br><br><ul><li>  A mem√≥ria √© alocada chamando <code>malloc(size)</code> .  Voc√™ fornece o n√∫mero de bytes que deseja alocar e retorna o endere√ßo de aloca√ß√£o ou um erro. </li><li>  A mem√≥ria alocada √© liberada chamando <code>free(address)</code> . </li></ul><br>  Diferentemente do Ruby, onde slots do mesmo tamanho s√£o alocados, o alocador de mem√≥ria lida com solicita√ß√µes para alocar mem√≥ria de qualquer tamanho.  Como voc√™ aprender√° mais adiante, esse fato leva a algumas complica√ß√µes. <br><br>  Por sua vez, o alocador de mem√≥ria acessa a API do kernel.  √â necess√°ria uma quantidade muito maior de mem√≥ria do kernel do que seus pr√≥prios assinantes solicitam, pois a chamada do kernel √© cara e a API do kernel tem uma limita√ß√£o: ela s√≥ pode alocar mem√≥ria em m√∫ltiplos de 4 KB. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/dba/21a/323dba21a7b5ad2df8e1f9335d6b7c11.png"></div><br>  <i><font color="gray">O alocador de mem√≥ria aloca grandes peda√ßos - eles s√£o chamados de heaps do sistema - e compartilha seu conte√∫do para satisfazer solicita√ß√µes de aplicativos</font></i> <br><br>  A √°rea de mem√≥ria que o alocador de mem√≥ria aloca do kernel √© chamada heap.  Observe que isso n√£o tem nada a ver com as p√°ginas da pilha Ruby, portanto, para maior clareza, usaremos o termo <i>pilha do sistema</i> . <br><br>  O alocador de mem√≥ria atribui partes do sistema a seus chamadores at√© que haja espa√ßo livre.  Nesse caso, o alocador de mem√≥ria aloca um novo heap do sistema a partir do kernel.  √â semelhante √† maneira como o Ruby seleciona objetos das p√°ginas de uma pilha de Ruby. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/f81/c11/453f81c11aaadb818ecdcf798112db99.png"></div><br>  <i><font color="gray">Ruby aloca mem√≥ria do alocador de mem√≥ria, que, por sua vez, aloca mem√≥ria do kernel</font></i> <br><br><a name="1_3"></a><h3>  O n√∫cleo </h3><br>  O kernel pode alocar mem√≥ria apenas em unidades de 4 KB.  Um desses blocos de 4K √© chamado de p√°gina.  Para evitar confus√£o com as p√°ginas de heap do Ruby, para maior clareza, usaremos o termo <i>p√°gina do sistema</i> (p√°gina do SO). <br><br>  O motivo √© dif√≠cil de explicar, mas √© assim que todos os kernels modernos funcionam. <br><br>  A aloca√ß√£o de mem√≥ria atrav√©s do kernel tem um impacto significativo no desempenho, e √© por isso que os alocadores de mem√≥ria tentam minimizar o n√∫mero de chamadas do kernel. <br><br><a name="1_4"></a><h3>  Defini√ß√£o de uso de mem√≥ria </h3><br>  Assim, a mem√≥ria √© alocada em v√°rios n√≠veis, e cada n√≠vel aloca mais mem√≥ria do que realmente precisa.  As p√°ginas de heap Ruby podem ter slots livres, bem como heaps do sistema.  Portanto, a resposta para a pergunta "Quanta mem√≥ria √© usada?"  depende completamente de qual n√≠vel voc√™ pergunta! <br><br>  Ferramentas como <code>top</code> ou <code>ps</code> mostram o uso de mem√≥ria da perspectiva do <b>kernel</b> .  Isso significa que n√≠veis mais altos devem funcionar em conjunto para liberar mem√≥ria do ponto de vista do kernel.  Como voc√™ aprender√° mais tarde, isso √© mais dif√≠cil do que parece. <br><br><a name="2"></a><h1>  O que √© fragmenta√ß√£o? </h1><br>  Fragmenta√ß√£o de mem√≥ria significa que as aloca√ß√µes de mem√≥ria s√£o espalhadas aleatoriamente.  Isso pode causar problemas interessantes. <br><br><a name="2_1"></a><h3>  Fragmenta√ß√£o em n√≠vel de rubi </h3><br>  Considere a coleta de lixo do Ruby.  A coleta de lixo para um objeto significa marcar o slot da p√°gina de pilha do Ruby como livre, permitindo que ele seja reutilizado.  Se a p√°gina inteira do heap Ruby consistir apenas em slots livres, sua p√°gina inteira poder√° ser liberada de volta ao alocador de mem√≥ria (e, possivelmente, de volta ao kernel). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27b/cde/97d/27bcde97d27e6aeed3dc2020a4eda766.png"></div><br><br>  Mas o que acontece se nem todos os slots forem gratuitos?  E se tivermos muitas p√°ginas da pilha Ruby e o coletor de lixo liberar objetos em lugares diferentes, para que, no final, haja muitos espa√ßos livres, mas em p√°ginas diferentes?  Nessa situa√ß√£o, o Ruby possui slots livres para colocar objetos, mas o alocador de mem√≥ria e o kernel continuar√£o alocando mem√≥ria! <br><br><a name="2_2"></a><h3>  Fragmenta√ß√£o de Aloca√ß√£o de Mem√≥ria </h3><br>  O alocador de mem√≥ria tem um problema semelhante, mas completamente diferente.  Ele n√£o precisa limpar imediatamente pilhas inteiras do sistema.  Teoricamente, ele pode liberar qualquer p√°gina do sistema.  Mas como o alocador de mem√≥ria lida com aloca√ß√µes de mem√≥ria de tamanho arbitr√°rio, pode haver v√°rias aloca√ß√µes na p√°gina do sistema.  Ele n√£o pode liberar a p√°gina do sistema at√© que todas as sele√ß√µes sejam liberadas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76b/723/850/76b72385026fa24bd18b7db324d7353b.png"></div><br><br>  Pense no que acontece se tivermos uma aloca√ß√£o de 3 KB, bem como uma aloca√ß√£o de 2 KB, dividida em duas p√°ginas do sistema.  Se voc√™ liberar os primeiros 3 KB, as duas p√°ginas do sistema permanecer√£o parcialmente ocupadas e n√£o poder√£o ser liberadas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc2/cf1/70f/cc2cf170facbc6bca673014e33389606.png"></div><br><br>  Portanto, se as circunst√¢ncias falharem, haver√° muito espa√ßo livre nas p√°ginas do sistema, mas elas n√£o ser√£o totalmente liberadas. <br><br>  Pior ainda: e se houver muitos locais gratuitos, mas nenhum deles for grande o suficiente para atender a uma nova solicita√ß√£o de aloca√ß√£o?  O alocador de mem√≥ria precisar√° alocar um heap de sistema totalmente novo. <br><br><a name="3"></a><h1>  A fragmenta√ß√£o da p√°gina de pilha Ruby est√° causando incha√ßo na mem√≥ria? </h1><br>  √â prov√°vel que a fragmenta√ß√£o esteja causando uso excessivo de mem√≥ria no Ruby.  Em caso afirmativo, qual das duas fragmenta√ß√µes √© mais prejudicial?  Isto √© ... <br><br><ol><li>  Fragmenta√ß√£o de p√°gina de pilha Ruby?  Ou <br></li><li>  Fragmenta√ß√£o de alocador de mem√≥ria? </li></ol><br>  A primeira op√ß√£o √© bastante simples de verificar.  O Ruby fornece duas APIs: <code>ObjectSpace.memsize_of_all</code> e <code>GC.stat</code> .  Gra√ßas a essas informa√ß√µes, voc√™ pode calcular toda a mem√≥ria que Ruby recebeu do alocador. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb8/f7e/30e/cb8f7e30e363d2fa57f0fc37b84183fe.png"></div><br><br>  <code>ObjectSpace.memsize_of_all</code> retorna a mem√≥ria ocupada por todos os objetos Ruby ativos.  Ou seja, todo o espa√ßo em seus slots e quaisquer dados externos.  No diagrama acima, esse √© o tamanho de todos os objetos azuis e laranja. <br><br>  <code>GC.stat</code> permite descobrir o tamanho de todos os slots livres, ou seja, toda a √°rea cinza da ilustra√ß√£o acima.  Aqui est√° o algoritmo: <br><br><pre> <code class="cpp hljs">GC.stat[:heap_free_slots] * GC::INTERNAL_CONSTANTS[:RVALUE_SIZE]</code> </pre> <br>  Para resumir, essa √© toda a mem√≥ria que Ruby conhece e envolve a fragmenta√ß√£o das p√°ginas da pilha de Ruby.  Se, do ponto de vista do kernel, o uso da mem√≥ria for maior, a mem√≥ria restante ficar√° fora do controle do Ruby, por exemplo, para bibliotecas ou fragmenta√ß√£o de terceiros. <br><br>  Eu escrevi um programa de teste simples que cria um monte de threads, cada um dos quais seleciona linhas em um loop.  Aqui est√° o resultado depois de um tempo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4e/859/2fc/a4e8592fc1d2edf2f11957844d33e55d.png"></div><br><br>  √© ... apenas ... louco! <br><br>  O resultado mostra que o Ruby tem um efeito t√£o fraco na quantidade total de mem√≥ria usada, n√£o importa se as p√°ginas da pilha do Ruby est√£o fragmentadas ou n√£o. <br><br>  Tem que procurar o culpado em outro lugar.  Pelo menos agora sabemos que Ruby n√£o tem culpa. <br><br><a name="4"></a><h1>  Estudo de fragmenta√ß√£o de aloca√ß√£o de mem√≥ria </h1><br>  Outro suspeito prov√°vel √© um alocador de mem√≥ria.  No final, Nate Berkopek e Heroku notaram que a confus√£o com o alocador de mem√≥ria (uma substitui√ß√£o completa do jemalloc ou a configura√ß√£o da vari√°vel de ambiente m√°gica <code>MALLOC_ARENA_MAX=2</code> ) reduz drasticamente o uso de mem√≥ria. <br><br>  Vamos primeiro ver o que <code>MALLOC_ARENA_MAX=2</code> faz e por que ajuda.  Em seguida, examinamos a fragmenta√ß√£o no n√≠vel do distribuidor. <br><br><a name="4_1"></a><h3>  Aloca√ß√£o excessiva de mem√≥ria e glibc </h3><br>  A raz√£o <code>MALLOC_ARENA_MAX=2</code> qual <code>MALLOC_ARENA_MAX=2</code> ajuda √© <code>MALLOC_ARENA_MAX=2</code> multithreading.  Quando v√°rios threads simultaneamente tentam alocar mem√≥ria do mesmo heap do sistema, eles lutam pelo acesso.  Somente um thread por vez pode receber mem√≥ria, o que reduz o desempenho da aloca√ß√£o de mem√≥ria multithread. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a40/99c/65b/a4099c65b73541efa05c38008fa0e181.png"></div><br>  <i><font color="gray">Somente um encadeamento de cada vez pode trabalhar com o heap do sistema.</font></i>  <i><font color="gray">Nas tarefas multithread, surge um conflito e, consequentemente, o desempenho diminui</font></i> <br><br>  No alocador de mem√≥ria para esse caso, h√° otimiza√ß√£o.  Ele tenta criar v√°rios heaps do sistema e atribu√≠-los a diferentes threads.  Na maioria das vezes, um encadeamento funciona apenas com seu pr√≥prio heap, evitando conflitos com outros encadeamentos. <br><br>  De fato, o n√∫mero m√°ximo de pilhas do sistema alocadas dessa maneira √©, por padr√£o, igual ao n√∫mero de processadores virtuais multiplicados por 8. Ou seja, em um sistema de n√∫cleo duplo com dois hiperencadeamentos, cada um produz <code>2 * 2 * 8 = 32</code> pilhas do sistema!  Isso √© o que eu chamo de <b>distribui√ß√£o excessiva</b> . <br><br>  Por que o multiplicador padr√£o √© t√£o grande?  Porque o principal desenvolvedor do alocador de mem√≥ria √© a Red Hat.  Seus clientes s√£o grandes empresas com servidores poderosos e uma tonelada de RAM.  A otimiza√ß√£o acima permite aumentar o desempenho m√©dio de multithreading em 10% devido a um aumento significativo no uso de mem√≥ria.  Para os clientes da Red Hat, esse √© um bom compromisso.  Para a maioria do resto - dificilmente. <br><br>  Nate em seu blog e artigo em Heroku argumentam que aumentar o n√∫mero de pilhas do sistema aumenta a fragmenta√ß√£o e cita a documenta√ß√£o oficial.  A vari√°vel <code>MALLOC_ARENA_MAX</code> reduz o n√∫mero m√°ximo de heaps do sistema alocados para multithreading.  Por essa l√≥gica, reduz a fragmenta√ß√£o. <br><br><a name="4_2"></a><h3>  Visualiza√ß√£o de pilhas do sistema </h3><br>  A afirma√ß√£o de Nate e Heroku √© verdadeira de que aumentar o n√∫mero de pilhas do sistema aumenta a fragmenta√ß√£o?  De fato, h√° algum problema com a fragmenta√ß√£o no n√≠vel do alocador de mem√≥ria?  Eu n√£o queria tomar nenhuma dessas premissas como garantidas, ent√£o comecei o estudo. <br><br>  Infelizmente, n√£o existem ferramentas para visualizar pilhas de sistemas, ent√£o <b>eu mesmo escrevi esse visualizador</b> . <br><br>  Primeiro, voc√™ precisa preservar o esquema de distribui√ß√£o dos heaps do sistema.  Estudei a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fonte do alocador de mem√≥ria</a> e observei como ele representa internamente a mem√≥ria.  Em seguida, ele escreveu uma biblioteca que itera sobre essas estruturas de dados e grava o esquema em um arquivo.  Por fim, ele escreveu uma ferramenta que usa esse arquivo como entrada e compila a visualiza√ß√£o como imagens HTML e PNG ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo fonte</a> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/309/adb/064/309adb06474b3ec49bb2d0d6622bbb48.png"></div><br><br>  Aqui est√° um exemplo de visualiza√ß√£o de um heap de sistema espec√≠fico (h√° muito mais).  Pequenos blocos nesta visualiza√ß√£o representam p√°ginas do sistema. <br><br><ul><li>  √Åreas vermelhas s√£o usadas c√©lulas de mem√≥ria. </li><li>  Os cinzas s√£o √°reas livres que n√£o s√£o liberadas de volta ao n√∫cleo. </li><li>  √Åreas brancas s√£o liberadas para o n√∫cleo. </li></ul><br>  As seguintes conclus√µes podem ser tiradas da visualiza√ß√£o: <br><br><ol><li>  Existe alguma fragmenta√ß√£o.  Pontos vermelhos est√£o espalhados na mem√≥ria e algumas p√°ginas do sistema est√£o apenas meio vermelhas. <br></li><li>  Para minha surpresa, a <i>maioria dos</i> pacotes de sistema cont√©m uma quantidade significativa de p√°ginas do sistema totalmente gratuitas (cinza)! </li></ol><br>  E ent√£o me dei conta: <br><br>  <i><b>Embora a fragmenta√ß√£o continue sendo um problema, n√£o √© esse o ponto!</b></i> <br><br>  Em vez disso, o problema √© muito cinza: esse alocador de mem√≥ria <i>n√£o envia mem√≥ria de volta ao kernel</i> ! <br><br>  Depois de re-estudar o c√≥digo fonte do alocador de mem√≥ria, descobriu-se que, por padr√£o, ele envia apenas p√°ginas do sistema para o kernel no final do heap do sistema, e <i>raramente o</i> faz.  Provavelmente, esse algoritmo √© implementado por raz√µes de desempenho. <br><br><a name="5"></a><h1>  Truque de M√°gica: Circuncis√£o </h1><br>  Felizmente, encontrei um truque.  H√° uma interface de programa√ß√£o que for√ßar√° o alocador de mem√≥ria a liberar para o kernel n√£o apenas a √∫ltima, mas <i>todas</i> as p√°ginas relevantes do sistema.  √â chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">malloc_trim</a> . <br><br>  Eu conhecia essa fun√ß√£o, mas n√£o achei que fosse √∫til, porque o manual diz o seguinte: <br><br><blockquote>  A fun√ß√£o malloc_trim () tenta liberar mem√≥ria livre na parte superior da pilha. </blockquote><br>  <b>O manual est√° errado!</b>  A an√°lise do c√≥digo fonte diz que o programa libera todas as p√°ginas relevantes do sistema, n√£o apenas as principais. <br><br>  O que acontece se essa fun√ß√£o for chamada durante a coleta de lixo?  <code>malloc_trim()</code> c√≥digo-fonte do Ruby 2.6 para chamar <code>malloc_trim()</code> na fun√ß√£o gc_start do gc.c, por exemplo: <br><br><pre> <code class="cpp hljs">gc_prof_timer_start(objspace); { gc_marks(objspace, do_full_mark); <span class="hljs-comment"><span class="hljs-comment">// BEGIN MODIFICATION if (do_full_mark) { malloc_trim(0); } // END MODIFICATION } gc_prof_timer_stop(objspace);</span></span></code> </pre> <br>  E aqui est√£o os resultados do teste: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f4/cfc/063/1f4cfc063a1c0672a80ed11baec2c323.png"></div><br><br>  <b>Que grande diferen√ßa!</b>  Um patch simples reduziu o consumo de mem√≥ria para quase <code>MALLOC_ARENA_MAX=2</code> . <br><br>  Veja como fica na visualiza√ß√£o: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9de/410/594/9de410594884baa131d3b8e52d7c6656.png"></div><br><br>  Vemos muitas √°reas brancas que correspondem √†s p√°ginas do sistema liberadas de volta ao kernel. <br><br><a name="6"></a><h1>  Conclus√£o </h1><br>  Aconteceu que a fragmenta√ß√£o, basicamente, n√£o tinha nada a ver com isso.  A desfragmenta√ß√£o ainda √© √∫til, mas o principal problema √© que o alocador de mem√≥ria n√£o gosta de liberar mem√≥ria de volta ao kernel. <br><br>  Felizmente, a solu√ß√£o acabou sendo muito simples.  O principal foi encontrar a causa raiz. <br><br><a name="6_1"></a><h3>  C√≥digo-fonte do Visualizer </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C√≥digo fonte</a> <br><br><a name="6_2"></a><h3>  E o desempenho? </h3><br>  O desempenho continuou sendo uma das principais preocupa√ß√µes.  Chamar <code>malloc_trim()</code> n√£o pode ser <code>malloc_trim()</code> de gra√ßa, mas de acordo com o c√≥digo, o algoritmo funciona em tempo linear.  Ent√£o, virei-me para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Noah Gibbs</a> , que lan√ßou o benchmark Rails Ruby Bench.  Para minha surpresa, o patch causou um ligeiro <b>aumento no</b> desempenho. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/115/88c/7e511588c662a60e0f8a82556b2e1988.jpg"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/474/c8e/f91/474c8ef919bf360ecf45f365e1a87ab0.jpg"></div><br><br>  Isso me impressionou.  O efeito √© incompreens√≠vel, mas as not√≠cias s√£o boas. <br><br><a name="6_3"></a><h3>  Precisa de mais testes. </h3><br>  Dentro deste estudo, apenas um n√∫mero limitado de casos foi verificado.  N√£o se sabe qual √© o impacto em outras cargas de trabalho.  Se voc√™ quiser ajudar nos testes, entre em <a href="">contato comigo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt444482/">https://habr.com/ru/post/pt444482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt444470/index.html">20 h√°bitos de higiene da aten√ß√£o: como usar a tecnologia, mas n√£o deix√°-los tomar tempo e aten√ß√£o</a></li>
<li><a href="../pt444472/index.html">Emulando servi√ßos web da Amazon em um processo JVM. Evitando Roskomnadzor e acelerando o desenvolvimento e os testes</a></li>
<li><a href="../pt444474/index.html">Constru√ß√£o da linha de comunica√ß√£o Sakhalin-Kuril. Segero Tour - Telef√©rico</a></li>
<li><a href="../pt444476/index.html">Competi√ß√£o da RUSNANO: fa√ßa um curso on-line sobre microeletr√¥nica moderna e fa√ßa um tour pr√°tico com FPGAs, ganhe um pr√™mio</a></li>
<li><a href="../pt444480/index.html">Como reduzir o peso de um elemento estrutural da aeronave em um ter√ßo</a></li>
<li><a href="../pt444484/index.html">Estimativa de termos para desenvolvimento e teste de tarefas (n√£o necess√°rio)</a></li>
<li><a href="../pt444488/index.html">Matrix Powerwatch por dentro e por fora: o que h√° de novo?</a></li>
<li><a href="../pt444490/index.html">Eu escaneei a Ucr√¢nia</a></li>
<li><a href="../pt444492/index.html">Aventuras do nada</a></li>
<li><a href="../pt444494/index.html">La Moto Volante (Lazareth LMV 496) - motocicleta transformadora voadora</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>