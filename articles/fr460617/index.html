<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦐 👨🏻‍🍳 🔓 Toute la vérité sur RTOS. Article # 30. Procédures d'initialisation et de démarrage de Nucleus SE 👨🏾‍🎤 👇🏿 👍🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tout système d'exploitation possède un mécanisme de démarrage spécifique. Le principe de fonctionnement de ce mécanisme pour chaque système est différ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toute la vérité sur RTOS. Article # 30. Procédures d'initialisation et de démarrage de Nucleus SE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460617/"><img src="https://habrastorage.org/webt/nr/me/cz/nrmeczn3tg-kdwyme6qgmd7ily4.jpeg"><br><br>  Tout système d'exploitation possède un mécanisme de démarrage spécifique.  Le principe de fonctionnement de ce mécanisme pour chaque système est différent.  Habituellement, ils disent que le système démarre (Eng. Boot), il s'agit d'une abréviation de "bootstrap", qui se réfère à l'expression "tirer soi-même sur une clôture par ses bootstraps" (pour franchir la clôture, se tirer par les sangles des chaussures), qui décrit grossièrement comment le système passe indépendamment d'un état dans lequel la mémoire est pleine de vide ( <i>note du traducteur: si absolument précis, alors ordure</i> ) à l'exécution stable du programme.  Traditionnellement, une petite partie du programme est chargée en mémoire; elle peut être stockée dans la ROM.  Dans le passé, il pouvait être saisi à l'aide des commutateurs situés à l'avant de l'ordinateur.  Ce chargeur de démarrage lit un programme de démarrage plus complexe qui a déjà chargé le système d'exploitation.  Aujourd'hui, l'ordinateur de bureau démarre comme suit: le code BIOS recherche les périphériques (disques durs, CD-ROM, clés USB) à partir desquels vous pouvez démarrer, puis le système d'exploitation démarre. <br><br>  Le système d'exploitation pour les systèmes embarqués peut également être initialisé de la même manière.  Et en fait, les systèmes d'exploitation embarqués développés sur la base des systèmes d'exploitation de bureau sont chargés.  Mais dans la plupart des RTOS "classiques", une méthode beaucoup plus simple (et donc plus rapide) est utilisée. <br><a name="habracut"></a><br>  Le système d'exploitation fait partie du logiciel.  Si ce logiciel est déjà en mémoire (par exemple, sous une forme ou une autre de ROM), il vous suffit de vous assurer que la séquence de commandes CPU après la réinitialisation se termine avec l'exécution du code d'initialisation du système d'exploitation.  C'est ainsi que la plupart des RTOS fonctionnent, y compris Nucleus SE ( <i>note du traducteur: cela s'applique également à notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS MAX</a></i> ). <br><br>  La plupart des outils de développement de logiciels intégrés incluent le code de démarrage nécessaire pour gérer la réinitialisation du processeur et transférer le contrôle à la fonction Point d'entrée dans la fonction <b>main ()</b> .  Le code redistribuable Nucleus SE ne traite pas ce processus, car il doit être aussi portable que possible.  Au lieu de cela, il contient la fonction <b>main ()</b> , qui prend le contrôle du CPU et initialise et démarre le système d'exploitation.  Cette fonctionnalité sera discutée en détail ci-dessous. <br><br><div class="spoiler">  <b class="spoiler_title">Articles précédents de la série:</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 29.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interruptions dans Nucleus SE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 28.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Minuteries logicielles</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Heure système</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Canaux: services auxiliaires et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Canaux de données: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Files d'attente: services auxiliaires et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Files d'attente: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boîtes aux lettres: services auxiliaires et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boîtes aux lettres: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sémaphores: services auxiliaires et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sémaphores: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groupes d'indicateurs d'événements: services d'assistance et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groupes de drapeaux d'événements: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Signaux</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partitions de mémoire: services et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sections de mémoire: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Structures de données de tâche et appels d'API non pris en charge</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Services pour travailler avec des tâches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tâches: configuration et introduction à l'API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scheduler: fonctionnalités avancées et préservation du contexte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scheduler: implémentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: conception interne et déploiement</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: Introduction</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Autres services RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interaction et synchronisation des tâches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tâches, changement de contexte et interruptions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tâches et planification</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: Structure et mode temps réel</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: introduction.</a> <br></div></div><br><h3>  Initialisation de la mémoire </h3><br>  Les déclarations de toutes les variables statiques dans le code Nucleus SE commencent par le préfixe <b>ROM</b> ou <b>RAM</b> pour indiquer où elles doivent être situées.  Ces deux directives <b>#define</b> sont définies dans le fichier <b>nuse_types.h</b> et doivent être configurées en tenant compte des spécificités de l'ensemble d'outils de développement utilisé (compilateur et éditeur de liens).  En règle générale, la <b>ROM</b> doit être de type <b>const</b> ( <i>note du traducteur: d'après mon expérience, <b>const</b> n'est pas toujours suffisant, <b>statique</b> est meilleur</i> ), et <b>RAM</b> est une valeur vide. <br><br>  Toutes <b>les</b> variables <b>ROM</b> sont initialisées statiquement, ce qui est logique.  <b>Les</b> variables <b>RAM</b> ne sont pas initialisées statiquement (car cela ne fonctionne qu'avec certaines boîtes à outils configurées pour copier automatiquement de la ROM vers la RAM);  un code d'initialisation explicite est inclus dans l'application et sera décrit en détail ci-dessous. <br><br>  Nucleus SE ne stocke pas de données «constantes» dans la RAM, qui est généralement insuffisante dans les petits systèmes.  Au lieu d'utiliser des structures de données complexes pour décrire les objets du noyau, des ensembles de tables (tableaux) sont utilisés, qui sont facilement placés dans la ROM ou la RAM, selon les besoins. <br><br><h2>  Fonction Main () </h2><br>  Voici le code complet de la fonction <b>main ()</b> de Nucleus SE: <br><br><pre><code class="plaintext hljs">void main(void) { NUSE_Init(); /* initialize kernel data */ /* user initialization code here */ NUSE_Scheduler(); /* start tasks */ }</code> </pre> <br>  La séquence des opérations est assez simple: <br><br><ul><li>  Tout d'abord, la fonction <b>NUSE_Init ()</b> est <b>appelée</b> .  Il initialise toutes les structures de données Nucleus SE et sera décrit en détail ci-dessous. </li><li>  L'utilisateur peut ensuite insérer tout code d'initialisation d'application qui sera exécuté avant le démarrage du planificateur de tâches.  Pour plus d'informations sur ce qui peut être réalisé avec ce code, voir plus loin dans cet article. </li><li>  Enfin, le planificateur Nucleus SE ( <b>NUSE_Scheduler ()</b> ) démarre.  Cela sera également discuté en détail plus loin dans cet article. </li></ul><br><h2>  Fonction NUSE_Init () </h2><br>  Cette fonction initialise toutes les variables du noyau Nucleus SE et les structures de données. <br><br><div class="spoiler">  <b class="spoiler_title">Voici le code de fonction complet:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void NUSE_Init(void) { U8 index; /* global data */ NUSE_Task_Active = 0; NUSE_Task_State = NUSE_STARTUP_CONTEXT; #if NUSE_SYSTEM_TIME_SUPPORT NUSE_Tick_Clock = 0; #endif #if NUSE_SCHEDULER_TYPE == NUSE_TIME_SLICE_SCHEDULER NUSE_Time_Slice_Ticks = NUSE_TIME_SLICE_TICKS; #endif /* tasks */ #if ((NUSE_SCHEDULER_TYPE != NUSE_RUN_TO_COMPLETION_SCHEDULER) || NUSE_SIGNAL_SUPPORT || NUSE_TASK_SLEEP || NUSE_SUSPEND_ENABLE || NUSE_SCHEDULE_COUNT_SUPPORT) for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { NUSE_Init_Task(index); } #endif /* partition pools */ #if NUSE_PARTITION_POOL_NUMBER != 0 for (index=0; index&lt;NUSE_PARTITION_POOL_NUMBER; index++) { NUSE_Init_Partition_Pool(index); } #endif /* mailboxes */ #if NUSE_MAILBOX_NUMBER != 0 for (index=0; index&lt;NUSE_MAILBOX_NUMBER; index++) { NUSE_Init_Mailbox(index); } #endif /* queues */ #if NUSE_QUEUE_NUMBER != 0 for (index=0; index&lt;NUSE_QUEUE_NUMBER; index++) { NUSE_Init_Queue(index); } #endif /* pipes */ #if NUSE_PIPE_NUMBER != 0 for (index=0; index&lt;NUSE_PIPE_NUMBER; index++) { NUSE_Init_Pipe(index); } #endif /* semaphores */ #if NUSE_SEMAPHORE_NUMBER != 0 for (index=0; index&lt;NUSE_SEMAPHORE_NUMBER; index++) { NUSE_Init_Semaphore(index); } #endif /* event groups */ #if NUSE_EVENT_GROUP_NUMBER != 0 for (index=0; index&lt;NUSE_EVENT_GROUP_NUMBER; index++) { NUSE_Init_Event_Group(index); } #endif /* timers */ #if NUSE_TIMER_NUMBER != 0 for (index=0; index&lt;NUSE_TIMER_NUMBER; index++) { NUSE_Init_Timer(index); } #endif }</code> </pre><br></div></div><br>  Tout d'abord, les variables globales sont initialisées: <br><ul><li>  <b>NUSE_Task_Active</b> - index de la tâche active, initialisé à zéro;  plus tard, cela peut changer le planificateur. </li><li>  <b>NUSE_Task_State</b> - initialisé avec la valeur <b>NUSE_STARTUP_CONTEXT</b> , ce qui limite la fonctionnalité de l'API pour tout code d'initialisation d'application ultérieur. </li><li>  Si la prise en charge de l'heure système est activée, <b>NUSE_Tick_Clock est défini</b> sur zéro. </li><li>  Si le planificateur de tranche horaire est activé, <b>NUSE_Time_Slice_Ticks</b> reçoit la valeur configurée <b>NUSE_TIME_SLICE_TICKS</b> . </li></ul><br>  Ensuite, les fonctions sont appelées pour initialiser les objets du noyau: <br><br><ul><li>  <b>NUSE_Init_Task ()</b> est appelée pour initialiser les structures de données de chaque tâche.  Cet appel n'est ignoré que si le planificateur Run to Completion est utilisé et que les signaux, la pause de tâche et le compteur de planification ne sont pas configurés (car cette combinaison de fonctions entraînera l'absence de ces structures de tâches dans la RAM, par conséquent, l'initialisation ne sera pas effectuée). </li><li>  <b>NUSE_Init_Partition_Pool ()</b> est appelée pour initialiser chaque objet de pool de partitions.  Ces appels sont ignorés si aucun pool de partitions n'est configuré. </li><li>  <b>NUSE_Init_Mailbox ()</b> est appelée pour initialiser chaque objet de boîte aux lettres.  Ces appels sont ignorés s'il n'y a pas de boîtes aux lettres configurées. </li><li>  <b>NUSE_Init_Queue ()</b> est appelée pour initialiser chaque objet de file d'attente.  Ces appels sont ignorés si aucune file d'attente n'est configurée. </li><li>  <b>NUSE_Init_Pipe ()</b> est appelé pour initialiser chaque objet de canal.  Ces appels sont ignorés si aucun canal n'est configuré. </li><li>  <b>NUSE_Init_Semaphore ()</b> est appelé pour initialiser chaque objet sémaphore.  Ces appels sont ignorés si aucun sémaphores n'est configuré. </li><li>  <b>NUSE_Init_Event_Group ()</b> est appelé pour initialiser chaque objet de groupe d'événements.  Ces appels sont ignorés s'il n'y a aucun groupe d'événements configuré. </li><li>  <b>NUSE_Init_Timer ()</b> est appelé pour initialiser chaque objet timer.  Ces appels sont ignorés si aucun temporisateur n'est configuré. </li></ul><br><h3>  Initialisation de la tâche </h3><br><div class="spoiler">  <b class="spoiler_title">Voici le code complet de la fonction NUSE_Init_Task ():</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void NUSE_Init_Task(NUSE_TASK task) { #if NUSE_SCHEDULER_TYPE != NUSE_RUN_TO_COMPLETION_SCHEDULER NUSE_Task_Context[task][15] = /* SR */ NUSE_STATUS_REGISTER; NUSE_Task_Context[task][16] = /* PC */ NUSE_Task_Start_Address[task]; NUSE_Task_Context[task][17] = /* SP */ (U32 *)NUSE_Task_Stack_Base[task] + NUSE_Task_Stack_Size[task]; #endif #if NUSE_SIGNAL_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Task_Signal_Flags[task] = 0; #endif #if NUSE_TASK_SLEEP || NUSE_INCLUDE_EVERYTHING NUSE_Task_Timeout_Counter[task] = 0; #endif #if NUSE_SUSPEND_ENABLE || NUSE_INCLUDE_EVERYTHING #if NUSE_INITIAL_TASK_STATE_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Task_Status[task] = NUSE_Task_Initial_State[task]; #else NUSE_Task_Status[task] = NUSE_READY; #endif #endif #if NUSE_SCHEDULE_COUNT_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Task_Schedule_Count[task] = 0; #endif }</code> </pre><br></div></div><br>  Si le planificateur Run to Completion n'a pas été configuré, le bloc de contexte pour la <b>tâche NUSE_Task_Context [task] [] est</b> initialisé.  La plupart des éléments ne sont pas affectés de valeurs, car ils représentent des registres de machine communs, qui devraient avoir une valeur intermédiaire lors du démarrage d'une tâche.  Dans l'exemple (Freescale ColdFire) de l'implémentation de Nucleus SE (mais pour les autres processeurs, le mécanisme sera similaire), les trois dernières entrées sont définies explicitement: <br><br><ul><li>  <b>NUSE_Task_Context [tâche] [15]</b> contient le registre d'état ( <b>SR</b> , registre d'état) et a la valeur de la directive <b>#define NUSE_STATUS_REGISTER</b> . </li><li>  <b>NUSE_Task_Context [tâche] [16]</b> contient le compteur de programme ( <b>PC</b> , compteur de programme) et a la valeur d'adresse du point d'entrée du code de tâche: <b>NUSE_Task_Start_Address [tâche]</b> . </li><li>  <b>NUSE_Task_Context [tâche] [17]</b> contient le pointeur de pile ( <b>SP</b> , pointeur de pile) et est initialisé avec la valeur calculée comme la somme de l'adresse de la pile de tâches ( <b>NUSE_Task_Stack_Base [tâche]</b> ) et la taille de la pile de tâches ( <b>NUSE_Task_Stack_Size [tâche]</b> ). </li></ul><br>  Si la prise en charge du signal est activée, les indicateurs de signal de tâche ( <b>NUSE_Task_Signal_Flags [tâche]</b> ) sont mis à zéro. <br><br>  Si la suspension de tâche est activée (c'est-à-dire l'appel de service API <b>NUSE_Task_Sleep ()</b> ), le compteur de délai d'expiration de tâche ( <b>NUSE_Task_Timeout_Counter [tâche]</b> ) est défini sur zéro. <br><br>  Si l'état de suspension de tâche est activé, l'état de la tâche ( <b>NUSE_Task_Status [tâche]</b> ) est initialisé.  Cette valeur initiale est définie par l'utilisateur (dans <b>NUSE_Task_Initial_State [tâche]</b> ) si la prise en charge de l'état initial de la tâche est activée.  Sinon, l'état est affecté à <b>NUSE_READY</b> . <br><br>  Si le compteur de planification est activé, le compteur de tâches ( <b>NUSE_Task_Schedule_Count [tâche]</b> ) est mis à zéro. <br><br><h3>  Initialisation des pools de partitions </h3><br>  Voici le code complet de la fonction <b>NUSE_Init_Partition_Pool ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Partition_Pool(NUSE_PARTITION_POOL pool) { NUSE_Partition_Pool_Partition_Used[pool] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Partition_Pool_Blocking_Count[pool] = 0; #endif }</code> </pre><br>  Le compteur du pool de partitions "utilisé" ( <b>NUSE_Partition_Pool__Partition_Used [pool]</b> ) est défini sur zéro. <br><br>  Si le verrouillage des tâches est activé, le compteur de tâches bloquées des pools de partitions ( <b>NUSE_Partition_Pool_Blocking_Count [pool]) est défini</b> sur zéro. <br><br><h3>  Initialisation des boîtes aux lettres </h3><br>  Ci-dessous, le <b>code</b> complet <b>NUSE_Init_Mailbox ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Mailbox(NUSE_MAILBOX mailbox) { NUSE_Mailbox_Data[mailbox] = 0; NUSE_Mailbox_Status[mailbox] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Mailbox_Blocking_Count[mailbox] = 0; #endif }</code> </pre><br>  La <b>banque de</b> données de boîte aux lettres ( <b>NUSE_Mailbox_Data [boîte aux lettres]</b> ) est définie sur zéro et l'état ( <b>NUSE_Mailbox_Status [boîte aux lettres]</b> ) devient "inutilisé" (c'est-à-dire zéro). <br><br>  Si le verrouillage des tâches est activé, le compteur des tâches de boîte aux lettres bloquées ( <b>NUSE_Mailbox_Blocking_Count [boîte aux lettres]</b> ) est défini sur zéro. <br><br><h3>  Initialisation de la file d'attente </h3><br>  Voici le code complet de la fonction <b>NUSE_Init_Queue ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Queue(NUSE_QUEUE queue) { NUSE_Queue_Head[queue] = 0; NUSE_Queue_Tail[queue] = 0; NUSE_Queue_Items[queue] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Queue_Blocking_Count[queue] = 0; #endif }</code> </pre><br>  Les pointeurs vers le début et la fin de la file d'attente (en fait, ce sont les index <b>NUSE_Queue_Head [queue</b> ] et <b>NUSE_Queue_Tail [file d'attente)</b> ) reçoivent des valeurs qui indiquent le début de la zone de données des files d'attente (c'est-à-dire qu'ils prennent une valeur nulle).  Le compteur dans la file d'attente ( <b>NUSE_Queue_Items [file d'attente]</b> ) est également mis à zéro. <br><br>  Si le verrouillage des tâches est activé, le compteur des tâches de file d'attente bloquées ( <b>NUSE_Queue_Blocking_Count [file d'attente)</b> ) est mis à zéro. <br><br><h3>  Initialisation de canal </h3><br>  Voici le code complet de la fonction <b>NUSE_Init_Pipe ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Pipe(NUSE_PIPE pipe) { NUSE_Pipe_Head[pipe] = 0; NUSE_Pipe_Tail[pipe] = 0; NUSE_Pipe_Items[pipe] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Pipe_Blocking_Count[pipe] = 0; #endif }</code> </pre><br>  Les pointeurs vers le début et la fin du canal (en fait, ce sont les index - <b>NUSE_Pipe_Head [pipe]</b> et <b>NUSE_Pipe_Tail [pipe]</b> ) reçoivent une valeur qui indique le début de la zone de données du canal (c'est-à-dire qu'ils prennent une valeur nulle).  Le <b>compteur de</b> canaux ( <b>NUSE_Pipe_Items [pipe]</b> ) est également défini sur zéro. <br><br>  Si le verrouillage des tâches est activé, le compteur de tâches bloquées du canal ( <b>NUSE_Pipe_Blocking_Count [pipe]</b> ) est défini sur zéro. <br><br><h3>  Initialisation du sémaphore </h3><br>  Voici le code complet de la fonction <b>NUSE_Init_Semaphore ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Semaphore(NUSE_SEMAPHORE semaphore) { NUSE_Semaphore_Counter[semaphore] = NUSE_Semaphore_Initial_Value[semaphore]; #if NUSE_BLOCKING_ENABLE NUSE_Semaphore_Blocking_Count[semaphore] = 0; #endif }</code> </pre><br>  Le compteur de sémaphore ( <b>NUSE_Semaphore_Counter [sémaphore]</b> ) est initialisé avec la valeur définie par l'utilisateur ( <b>NUSE_Semaphore_Initial_Value [sémaphore]</b> ). <br><br>  Si le verrouillage de tâche est activé, le compteur de tâches de sémaphore verrouillé ( <b>NUSE_Semaphore_Blocking_Count [sémaphore]</b> ) est défini sur zéro. <br><br><h3>  Initialisation des groupes d'événements </h3><br>  Voici le code complet de la fonction <b>NUSE_Init_Event_Group ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Event_Group(NUSE_EVENT_GROUP group) { NUSE_Event_Group_Data[group] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Event_Group_Blocking_Count[group] = 0; #endif }</code> </pre><br>  Les drapeaux du groupe d'événements sont réinitialisés, c'est-à-dire  <b>NUSE_Event_Group_Data [group]</b> reçoit une valeur nulle. <br><br>  Si le verrouillage des tâches est activé, le compteur de tâches bloquées du groupe d'indicateurs d'événements ( <b>NUSE_Event_Group_Blocking_Count [groupe]</b> ) est défini sur zéro. <br><br><h3>  Initialisation de la minuterie </h3><br>  Ci-dessous, le code complet de <b>NUSE_Init_Timer ()</b> ; <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Timer(NUSE_TIMER timer) { NUSE_Timer_Status[timer] = FALSE; NUSE_Timer_Value[timer] = NUSE_Timer_Initial_Time[timer]; NUSE_Timer_Expirations_Counter[timer] = 0; }</code> </pre><br>  L'état du temporisateur ( <b>NUSE_Timer_Status [timer]</b> ) est réglé sur "inutilisé", c'est-à-dire  <b>FAUX</b> <br><br>  La valeur du compte à rebours ( <b>NUSE_Timer_Value [timer</b> ]) est initialisée par la valeur définie par l'utilisateur ( <b>NUSE_Timer_Initial_Time [timer]</b> ). <br><br>  Le compteur d'achèvement ( <b>NUSE_Timer_Expirations_Counter [timer]</b> ) est mis à zéro. <br><br><h2>  Initialisation du code d'application </h2><br>  Une fois les structures de données Nucleus SE initialisées, il devient possible d'exécuter le code responsable de l'initialisation de l'application avant de démarrer la tâche.  Cette fonctionnalité peut être utile pour les tâches suivantes: <br><br><ul><li>  Initialisation des structures de données d'application.  Le remplissage explicite des structures de données est plus facile à comprendre et à déboguer que l'initialisation automatique des variables statiques. </li><li>  Affectation des objets du noyau.  Étant donné que tous les objets du noyau sont créés statiquement au stade de la construction et sont identifiés à l'aide de valeurs d'index, il peut être utile d'attribuer un «propriétaire» ou de déterminer l'utilisation de ces objets.  Cela peut être fait à l'aide de la directive #define, cependant, s'il existe plusieurs instances de tâches, il est préférable d'affecter des index d'objets via des tableaux globaux (indexés par ID de tâche). </li><li>  Initialisation de l'appareil.  Cela peut être utile pour l'installation initiale des périphériques. </li></ul><br>  Évidemment, bon nombre de ces objectifs peuvent être atteints avant l'initialisation de Nucleus SE, mais l'avantage de l'emplacement du code d'application ici est que vous pouvez désormais utiliser les services du noyau (appels d'API).  Par exemple, une file d'attente ou une boîte aux lettres peut être préremplie avec des données qui devront être traitées au démarrage de la tâche. <br><br>  Les appels d'API ont une restriction: toutes les actions qui conduisent généralement à l'activation du planificateur sont interdites (par exemple, suspendre / bloquer des tâches).  La variable globale <b>NUSE_Task_State a</b> été définie sur <b>NUSE_STARTUP_CONTEXT</b> pour <b>indiquer</b> cette limitation. <br><br><h2>  Lancer le planificateur </h2><br>  Une fois l'initialisation terminée, il ne reste plus qu'à exécuter le planificateur pour commencer à exécuter le code d'application - tâches.  La configuration de l'ordonnanceur et le travail de divers types d'ordonnanceurs ont été décrits en détail dans l'un des articles précédents ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="># 9</a> ), donc seul un bref résumé est requis ici. <br>  La séquence des étapes clés est la suivante: <br><br><ul><li>  <b>Définition de la</b> variable globale <b>NUSE_Task_State sur</b> <b>NUSE_TASK_CONTEXT</b> . </li><li>  Sélectionnez l'index de la première tâche à exécuter.  Si la prise en charge de la tâche initiale est activée, la recherche de la première tâche terminée est effectuée, sinon, une valeur nulle est utilisée. </li><li>  L'ordonnanceur est <b>appelé</b> - <b>NUSE_Scheduler ()</b> . </li></ul><br>  Ce qui se passe exactement à la dernière étape dépend du planificateur sélectionné.  Lorsque vous utilisez le planificateur Run to Completion, un cycle de planification démarre et les tâches sont appelées séquentiellement.  Lorsque vous utilisez d'autres planificateurs, le contexte de la première tâche est chargé et le contrôle est transféré à la tâche. <br><br>  L'article suivant traite des diagnostics et de la vérification des erreurs. <br><br>  <b>À propos de l'auteur:</b> Colin Walls travaille dans l'industrie électronique depuis plus de trente ans, consacrant la majeure partie de son temps au micrologiciel.  Il est maintenant ingénieur firmware chez Mentor Embedded (une division de Mentor Graphics).  Colin Walls intervient souvent lors de conférences et séminaires, auteur de nombreux articles techniques et de deux livres sur le firmware.  Vit au Royaume-Uni.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Blog</a> professionnel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de Colin</a> , e-mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460617/">https://habr.com/ru/post/fr460617/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460603/index.html">V2G. Les voitures électriques aideront à équilibrer la production et la consommation d'électricité</a></li>
<li><a href="../fr460605/index.html">Studio photo automatique, partie 1</a></li>
<li><a href="../fr460607/index.html">App Store de sécurité offensive avec des outils de piratage d'Android</a></li>
<li><a href="../fr460611/index.html">Basculement: le perfectionnisme nous ruine et ... la paresse</a></li>
<li><a href="../fr460615/index.html">Dans le sillage d'Industrial Ninja: comment PLC a été piraté lors de Positive Hack Days 9</a></li>
<li><a href="../fr460621/index.html">Tic Tac Toe Partie 4: Interaction avec le backend Flask en utilisant HTTP</a></li>
<li><a href="../fr460623/index.html">À propos de la torture de Julian Assange</a></li>
<li><a href="../fr460625/index.html">Comme je n'ai pas pris la première place dans la compétition pour les développeurs JavaScript de Telegram</a></li>
<li><a href="../fr460627/index.html">vGPU - l'utilisation ne peut pas être ignorée</a></li>
<li><a href="../fr460629/index.html">La probabilité que 2 mineurs aient le même monde</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>