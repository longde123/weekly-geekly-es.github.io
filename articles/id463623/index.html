<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¾â€ğŸ”¬ ğŸ‡ ğŸ§ğŸ¾ Kami dipilih dari hutan tes: kami sedang membangun jalan singkat dari perlengkapan ke pengujian ğŸ‘’ ğŸ…ğŸ» ğŸš“</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini, saya ingin menawarkan alternatif untuk gaya desain tes tradisional menggunakan konsep pemrograman fungsional Scala. Pendekatan ini d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami dipilih dari hutan tes: kami sedang membangun jalan singkat dari perlengkapan ke pengujian</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/2gis/blog/463623/"><p><img src="https://habrastorage.org/webt/mu/ll/ar/mullaroquhqtdb05ygvb82nmghu.jpeg"></p><br><p>  Pada artikel ini, saya ingin menawarkan alternatif untuk gaya desain tes tradisional menggunakan konsep pemrograman fungsional Scala.  Pendekatan ini diilhami oleh rasa sakit selama berbulan-bulan dari dukungan puluhan dan ratusan ujian yang jatuh dan keinginan yang membara untuk menjadikannya lebih mudah dan lebih mudah dimengerti. </p><br><p>  Terlepas dari kenyataan bahwa kode tersebut ditulis dalam Scala, ide-ide yang diusulkan akan relevan untuk pengembang dan penguji dalam semua bahasa yang mendukung paradigma pemrograman fungsional.  Anda dapat menemukan tautan ke Github dengan solusi dan contoh lengkap di akhir artikel. </p><a name="habracut"></a><br><h2 id="problema">  Masalahnya </h2><br><p>  Jika Anda pernah berurusan dengan tes (itu tidak masalah - tes unit, integrasi atau fungsional), kemungkinan besar itu ditulis sebagai serangkaian instruksi berurutan.  Sebagai contoh: </p><br><pre><code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//     .     //  ,      ,  //     . "   = 'customer'" - { import TestHelper._ "    &lt; 250    -  " in { val db: Database = Database.forURL(TestConfig.generateNewUrl()) migrateDb(db) insertUser(db, id = 1, name = "test", role = "customer") insertPackage(db, id = 1, name = "test", userId = 1, status = "new") insertPackageItems(db, id = 1, packageId = 1, name = "test", price = 30) insertPackageItems(db, id = 2, packageId = 1, name = "test", price = 20) insertPackageItems(db, id = 3, packageId = 1, name = "test", price = 40) val svc = new SomeProductionLogic(db) val result = svc.calculatePrice(packageId = 1) result shouldBe 90 } "    &gt;= 250    -  10%" in { val db: Database = Database.forURL(TestConfig.generateNewUrl()) migrateDb(db) insertUser(db, id = 1, name = "test", role = "customer") insertPackage(db, id = 1, name = "test", userId = 1, status = "new") insertPackageItems(db, id = 1, packageId = 1, name = "test", price = 100) insertPackageItems(db, id = 2, packageId = 1, name = "test", price = 120) insertPackageItems(db, id = 3, packageId = 1, name = "test", price = 130) insertBonus(db, id = 1, packageId = 1, bonusAmount = 40) val svc = new SomeProductionLogic(db) val result = svc.calculatePrice(packageId = 1) result shouldBe 279 } } "   = 'vip'" - {/*...*/}</span></span></code> </pre> <br><p>  Ini adalah yang paling disukai untuk sebagian besar, tidak memerlukan pengembangan, cara untuk menggambarkan tes.  Proyek kami memiliki sekitar 1000 tes tingkat yang berbeda (tes unit, tes integrasi, ujung ke ujung), dan semuanya, hingga baru-baru ini, ditulis dengan gaya yang sama.  Ketika proyek tumbuh, kami mulai merasakan masalah yang signifikan dan perlambatan dengan dukungan tes-tes semacam itu: mengerjakan tes tidak memakan waktu lebih lama daripada menulis kode yang relevan dengan bisnis. </p><br><p>  Saat menulis tes baru, Anda harus selalu berpikir dari awal bagaimana menyiapkan data.  Seringkali salin-tempel langkah-langkah dari tes tetangga.  Akibatnya, ketika model data dalam aplikasi berubah, rumah kartu hancur dan harus dikumpulkan dengan cara baru di setiap tes: terbaik, hanya perubahan fungsi pembantu, paling buruk - perendaman mendalam dalam tes dan menulis ulang. </p><br><p>  Ketika tes jatuh dengan jujur â€‹â€‹- yaitu, karena bug dalam logika bisnis, dan bukan karena masalah dalam tes itu sendiri - untuk memahami di mana ada yang salah, tanpa debugging, tidak mungkin.  Karena kenyataan bahwa butuh waktu lama untuk memahami tes, tidak ada yang sepenuhnya memiliki pengetahuan tentang persyaratan - bagaimana sistem harus berperilaku dalam kondisi tertentu. </p><br><p>  Semua rasa sakit ini adalah gejala dari dua masalah yang lebih dalam dari desain ini: </p><br><ol><li>  Isi tes diizinkan dalam bentuk yang terlalu longgar.  Setiap tes unik, seperti kepingan salju.  Kebutuhan untuk membaca detail tes membutuhkan banyak waktu dan kehilangan motivasi.  Detail tidak penting mengalihkan perhatian dari hal utama - persyaratan diverifikasi oleh tes.  Copy paste menjadi cara utama untuk menulis test case baru. </li><li>  Tes tidak membantu pengembang melokalisasi bug, tetapi hanya menandakan masalah.  Untuk memahami keadaan di mana tes dilakukan, Anda harus mengembalikannya di kepala Anda atau terhubung dengan debugger. </li></ol><br><h2 id="modelirovanie">  Pemodelan </h2><br><p>  Bisakah kita berbuat lebih baik?  (Spoiler: kita bisa.) Mari kita lihat apa yang terdiri dari tes ini. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> db: <span class="hljs-type"><span class="hljs-type">Database</span></span> = <span class="hljs-type"><span class="hljs-type">Database</span></span>.forURL(<span class="hljs-type"><span class="hljs-type">TestConfig</span></span>.generateNewUrl()) migrateDb(db) insertUser(db, id = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, role = <span class="hljs-string"><span class="hljs-string">"customer"</span></span>) insertPackage(db, id = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, userId = <span class="hljs-number"><span class="hljs-number">1</span></span>, status = <span class="hljs-string"><span class="hljs-string">"new"</span></span>) insertPackageItems(db, id = <span class="hljs-number"><span class="hljs-number">1</span></span>, packageId = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, price = <span class="hljs-number"><span class="hljs-number">30</span></span>) insertPackageItems(db, id = <span class="hljs-number"><span class="hljs-number">2</span></span>, packageId = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, price = <span class="hljs-number"><span class="hljs-number">20</span></span>) insertPackageItems(db, id = <span class="hljs-number"><span class="hljs-number">3</span></span>, packageId = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, price = <span class="hljs-number"><span class="hljs-number">40</span></span>)</code> </pre> <br><p>  Kode yang diuji, sebagai suatu peraturan, akan menunggu beberapa parameter eksplisit untuk masuk - pengidentifikasi, ukuran, volume, filter, dll. Selain itu, sering kali perlu data dari dunia nyata - kita melihat bahwa aplikasi merujuk ke menu dan templat menu basis data.  Untuk pelaksanaan pengujian yang andal, kita perlu <em>fixture</em> - keadaan di mana sistem dan / atau penyedia data harus berada sebelum pengujian dimulai dan parameter input, sering terkait dengan keadaan. </p><br><p>  Kami akan menyiapkan <em>dependensi dengan</em> fixture ini - isi database (antrian, layanan eksternal, dll.).  Dengan ketergantungan yang disiapkan, kami menginisialisasi kelas yang diuji (layanan, modul, repositori, dll.). </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> svc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SomeProductionLogic</span></span>(db) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = svc.calculatePrice(packageId = <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Dengan mengeksekusi kode uji pada beberapa parameter input, kami mendapatkan <em>hasil</em> ( <em>output</em> ) bisnis-signifikan - baik eksplisit (dikembalikan oleh metode) dan implisit - perubahan dalam kondisi terkenal: database, layanan eksternal, dll. </p><br><pre> <code class="scala hljs">result shouldBe <span class="hljs-number"><span class="hljs-number">90</span></span></code> </pre> <br><p>  Akhirnya, kami memverifikasi bahwa hasilnya persis seperti yang mereka harapkan, menyimpulkan tes dengan satu atau lebih <em>pernyataan</em> . </p><br><p><img src="https://habrastorage.org/webt/em/aa/rb/emaarb5ltmnme4-wpda0ebakueq.jpeg"></p><br><p>  Dapat disimpulkan bahwa, secara umum, tes terdiri dari tahapan yang sama: menyiapkan parameter input, mengeksekusi kode tes pada mereka, dan membandingkan hasilnya dengan yang diharapkan.  Kita dapat menggunakan fakta ini untuk menyingkirkan <strong>masalah pertama dalam tes</strong> - bentuk terlalu longgar, membagi tes menjadi beberapa tahap.  Gagasan ini bukanlah hal baru dan telah lama digunakan dalam pengujian dengan gaya BDD ( <em>pengembangan yang didorong oleh perilaku</em> ). </p><br><p>  Bagaimana dengan ekstensibilitas?  Salah satu langkah dalam proses pengujian dapat berisi langkah-langkah antara sebanyak yang Anda suka.  Ke depan, kita bisa membentuk fixture, pertama menciptakan semacam struktur yang dapat dibaca manusia, dan kemudian mengubahnya menjadi objek yang mengisi database.  Proses pengujian dapat diperluas tanpa batas, tetapi, pada akhirnya, selalu turun ke tahap utama. </p><br><p><img src="https://habrastorage.org/webt/55/qf/zl/55qfzlhkl99txyyhizbvzg48yhs.jpeg"></p><br><h2 id="zapusk-testov">  Menjalankan tes </h2><br><p>  Mari kita coba mewujudkan ide untuk membagi tes menjadi beberapa tahapan, tetapi pertama-tama kita tentukan bagaimana kita ingin melihat hasil akhirnya. </p><br><p>  Secara umum, kami ingin membuat tes menulis dan mendukung proses yang kurang padat karya dan lebih menyenangkan.  Instruksi non-unik (diulangi di tempat lain) yang kurang eksplisit di dalam tubuh tes, semakin sedikit perubahan yang perlu dilakukan untuk tes setelah mengubah kontrak atau refactoring dan semakin sedikit waktu yang dibutuhkan untuk membaca tes.  Desain tes harus mendorong penggunaan kembali potongan kode yang sering digunakan dan mencegah penyalinan tanpa pertimbangan.  Akan lebih baik jika tesnya terlihat seragam.  Prediktabilitas meningkatkan keterbacaan dan menghemat waktu - bayangkan berapa banyak waktu yang diperlukan siswa fisika untuk menguasai setiap rumus baru jika mereka dijelaskan dalam kata-kata bentuk bebas daripada bahasa matematika. </p><br><p>  Dengan demikian, tujuan kami adalah untuk menyembunyikan segala sesuatu yang mengganggu dan berlebihan, hanya menyisakan informasi penting untuk memahami aplikasi: apa yang diuji, apa yang diharapkan pada input, dan apa yang diharapkan pada output. </p><br><p><img src="https://habrastorage.org/webt/em/aa/rb/emaarb5ltmnme4-wpda0ebakueq.jpeg"></p><br><p>  Mari kita kembali ke model perangkat uji.  Secara teknis, setiap titik pada grafik ini dapat diwakili oleh tipe data, dan transisi dari satu ke yang lain - fungsi.  Anda bisa datang dari tipe data awal ke yang terakhir dengan menerapkan fungsi berikut ke hasil yang sebelumnya satu per satu.  Dengan kata lain, menggunakan <em>komposisi fungsi</em> : menyiapkan data (sebut saja <code>prepare</code> ), mengeksekusi kode uji ( <code>execute</code> ) dan memeriksa hasil yang diharapkan ( <code>check</code> ).  Kami akan melewati titik pertama dari bagan, fixture, ke input komposisi ini.  <strong>Fungsi</strong> orde tinggi yang dihasilkan disebut <strong>fungsi siklus hidup</strong> tes. </p><br><div class="spoiler">  <b class="spoiler_title">Fungsi siklus hidup</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runTestCycle</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">FX</span></span>, <span class="hljs-type"><span class="hljs-type">DEP</span></span>, <span class="hljs-type"><span class="hljs-type">OUT</span></span>, <span class="hljs-type"><span class="hljs-type">F</span></span>[_]]( fixture: <span class="hljs-type"><span class="hljs-type">FX</span></span>, prepare: <span class="hljs-type"><span class="hljs-type">FX</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">DEP</span></span>, execute: <span class="hljs-type"><span class="hljs-type">DEP</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">OUT</span></span>, check: <span class="hljs-type"><span class="hljs-type">OUT</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">Assertion</span></span>] ): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">Assertion</span></span>] = <span class="hljs-comment"><span class="hljs-comment">//  Scala  ,   check(execute(prepare(fixture))) //        andThen: (prepare andThen execute andThen check) (fixture)</span></span></code> </pre> </div></div><br><p>  Pertanyaannya adalah, dari mana fungsi internal itu berasal?  Kami akan menyiapkan data dalam sejumlah cara terbatas - untuk mengisi database, menjadi basah, dll. - oleh karena itu, opsi untuk fungsi persiapan akan umum untuk semua tes.  Sebagai hasilnya, akan lebih mudah untuk membuat fungsi siklus hidup khusus yang menyembunyikan implementasi spesifik dari persiapan data.  Karena metode memohon kode yang diperiksa dan diperiksa relatif unik untuk setiap tes, <code>execute</code> dan <code>check</code> akan diberikan secara eksplisit. </p><br><div class="spoiler">  <b class="spoiler_title">Fungsi siklus hidup disesuaikan untuk tes integrasi pada database</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//    â€”     def prepareDatabase[DB](db: Database): DbFixture =&gt; DB def testInDb[DB, OUT]( fixture: DbFixture, execute: DB =&gt; OUT, check: OUT =&gt; Future[Assertion], db: Database = getDatabaseHandleFromSomewhere(), ): Future[Assertion] = runTestCycle(fixture, prepareDatabase(db), execute, check)</span></span></code> </pre> </div></div><br><p>  Dengan mendelegasikan semua nuansa administratif ke fungsi siklus hidup, kami mendapat kesempatan untuk memperluas proses pengujian tanpa harus melalui tes tertulis apa pun.  Karena komposisinya, kami dapat menyusup ke mana saja dalam proses, mengekstrak, atau menambahkan data di sana. </p><br><p>  Untuk mengilustrasikan kemungkinan pendekatan ini dengan lebih baik, kami akan menyelesaikan <strong>masalah kedua dari</strong> pengujian awal kami - kurangnya informasi pendukung untuk melokalisasi masalah.  Tambahkan pencatatan ketika menerima respons dari metode yang diuji.  Pencatatan kami tidak akan mengubah tipe data, tetapi hanya akan menghasilkan <em>efek samping</em> - menampilkan pesan di konsol.  Oleh karena itu, setelah efek samping, kami akan mengembalikannya apa adanya. </p><br><div class="spoiler">  <b class="spoiler_title">Fungsi Siklus Hidup Pencatatan</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logged</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> loggedT: <span class="hljs-type"><span class="hljs-type">Logged</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = (that: <span class="hljs-type"><span class="hljs-type">T</span></span>) =&gt; { <span class="hljs-comment"><span class="hljs-comment">//       Logged  T, //    â€œâ€  that  log(). //    - . loggedT.log(that) //    : that.log() that //    } def runTestCycle[FX, DEP, OUT, F[_]]( fixture: FX, prepare: FX =&gt; DEP, execute: DEP =&gt; OUT, check: OUT =&gt; F[Assertion] )(implicit loggedOut: Logged[OUT]): F[Assertion] = //  logged     -  execute (prepare andThen execute andThen logged andThen check) (fixture)</span></span></code> </pre> </div></div><br><p>  Dengan gerakan sederhana seperti itu, kami menambahkan pencatatan hasil yang dikembalikan dan status basis data <strong>dalam setiap pengujian</strong> .  Keuntungan dari fungsi-fungsi kecil ini adalah mereka mudah dipahami, mudah dikomposisi untuk digunakan kembali, dan mudah dihilangkan jika tidak diperlukan lagi. </p><br><p><img src="https://habrastorage.org/webt/ti/2t/l9/ti2tl9pk8wkd4hp8pqevf74hdn4.jpeg"></p><br><p>  Hasilnya, pengujian kami akan terlihat seperti ini: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fixture: <span class="hljs-type"><span class="hljs-type">SomeMagicalFixture</span></span> = ??? <span class="hljs-comment"><span class="hljs-comment">//  -    def runProductionCode(id: Int): Database =&gt; Double = (db: Database) =&gt; new SomeProductionLogic(db).calculatePrice(id) def checkResult(expected: Double): Double =&gt; Future[Assertion] = (result: Double) =&gt; result shouldBe expected //    Database   testInDb "   = 'customer'" in testInDb( state = fixture, execute = runProductionCode(id = 1), check = checkResult(90) )</span></span></code> </pre> <br><p>  Badan pengujian telah menjadi singkat, perlengkapan dan pemeriksaan dapat digunakan kembali dalam pengujian lain, dan kami tidak secara manual menyiapkan database di tempat lain.  Hanya satu masalah yang tersisa ... </p><br><h2 id="podgotovka-fikstur">  Persiapan perlengkapan </h2><br><p>  Dalam kode di atas, kami menggunakan asumsi bahwa fixture akan datang dari suatu tempat yang sudah jadi dan hanya perlu ditransfer ke fungsi siklus hidup.  Karena data merupakan unsur utama dalam pengujian sederhana dan didukung, kami tidak bisa tidak menyentuh bagaimana membentuknya. </p><br><p>  Misalkan toko pengujian kami memiliki basis data berukuran sedang yang khas (untuk kesederhanaan, contoh dengan 4 tabel, tetapi dalam kenyataannya mungkin ada ratusan).  Bagian berisi informasi latar belakang, bagian - bisnis langsung, dan secara keseluruhan dapat dihubungkan ke beberapa entitas logis penuh.  Tabel saling berhubungan dengan kunci (kunci <em>asing</em> ) - untuk membuat entitas <code>Bonus</code> , Anda memerlukan entitas <code>Package</code> , dan pada gilirannya, <code>User</code> .  Dan sebagainya. </p><br><p><img src="https://habrastorage.org/webt/3z/of/sy/3zofsyjoygierusjtmlu_okrmh0.png"></p><br><p>  Keadaan keterbatasan sirkuit dan segala jenis peretasan menyebabkan inkonsistensi dan, sebagai hasilnya, menguji ketidakstabilan dan berjam-jam debug yang menarik.  Untuk alasan ini, kami akan mengisi database dengan jujur. </p><br><p>  Kita dapat menggunakan metode militer untuk mengisi, tetapi bahkan dengan pemeriksaan dangkal terhadap gagasan ini, banyak pertanyaan sulit muncul.  Apa yang akan mempersiapkan data dalam tes untuk metode ini sendiri?  Apakah saya perlu menulis ulang tes jika kontrak berubah?  Bagaimana jika data dikirimkan oleh aplikasi yang tidak diuji (misalnya, diimpor oleh orang lain)?  Berapa banyak pertanyaan yang berbeda yang harus dilakukan untuk membuat entitas yang bergantung pada banyak orang lain? </p><br><div class="spoiler">  <b class="spoiler_title">Mengisi basis di tes awal</b> <div class="spoiler_text"><pre> <code class="scala hljs">insertUser(db, id = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, role = <span class="hljs-string"><span class="hljs-string">"customer"</span></span>) insertPackage(db, id = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, userId = <span class="hljs-number"><span class="hljs-number">1</span></span>, status = <span class="hljs-string"><span class="hljs-string">"new"</span></span>) insertPackageItems(db, id = <span class="hljs-number"><span class="hljs-number">1</span></span>, packageId = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, price = <span class="hljs-number"><span class="hljs-number">30</span></span>) insertPackageItems(db, id = <span class="hljs-number"><span class="hljs-number">2</span></span>, packageId = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, price = <span class="hljs-number"><span class="hljs-number">20</span></span>) insertPackageItems(db, id = <span class="hljs-number"><span class="hljs-number">3</span></span>, packageId = <span class="hljs-number"><span class="hljs-number">1</span></span>, name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, price = <span class="hljs-number"><span class="hljs-number">40</span></span>)</code> </pre> </div></div><br><p>  Metode pembantu yang tersebar, seperti pada contoh aslinya, adalah masalah yang sama, tetapi dengan saus yang berbeda.  Mereka menetapkan tanggung jawab untuk mengelola objek dependen dan hubungannya dengan diri kita sendiri, dan kami ingin menghindari ini. </p><br><p>  Idealnya, saya ingin memiliki tipe data ini, dengan satu pandangan sekilas yang cukup untuk memahami secara umum kondisi sistem yang akan digunakan selama pengujian.  Salah satu kandidat yang baik untuk visualisasi keadaan adalah tabel (a la <em>dataset</em> dalam PHP dan Python), di mana tidak ada yang berlebihan kecuali untuk bidang yang penting untuk logika bisnis.  Jika logika bisnis berubah dalam fitur, semua dukungan pengujian akan dikurangi hingga memperbarui sel dalam dataset.  Sebagai contoh: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataTable: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">DataRow</span></span>] = <span class="hljs-type"><span class="hljs-type">Table</span></span>( (<span class="hljs-string"><span class="hljs-string">"Package ID"</span></span>, <span class="hljs-string"><span class="hljs-string">"Customer's role"</span></span>, <span class="hljs-string"><span class="hljs-string">"Item prices"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bonus value"</span></span>, <span class="hljs-string"><span class="hljs-string">"Expected final price"</span></span>) , (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"customer"</span></span>, <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) , <span class="hljs-type"><span class="hljs-type">Vector</span></span>.empty , <span class="hljs-number"><span class="hljs-number">90.0</span></span>) , (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"customer"</span></span>, <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">250</span></span>) , <span class="hljs-type"><span class="hljs-type">Vector</span></span>.empty , <span class="hljs-number"><span class="hljs-number">225.0</span></span>) , (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"customer"</span></span>, <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) , <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">40</span></span>) , <span class="hljs-number"><span class="hljs-number">210.0</span></span>) , (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"customer"</span></span>, <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) , <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>) , <span class="hljs-number"><span class="hljs-number">279.0</span></span>) , (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"vip"</span></span> , <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>), <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>), <span class="hljs-number"><span class="hljs-number">252.0</span></span>) )</code> </pre> <br><p><img src="https://habrastorage.org/webt/5j/dt/2p/5jdt2pdn7hdzhepaut_bhukkcgm.jpeg"></p><br><p>  Dari tabel kami, kami akan menghasilkan <em>kunci</em> - hubungan entitas dengan ID.  Dalam hal ini, jika entitas bergantung pada entitas lain, kunci akan dibentuk untuk dependensi tersebut.  Mungkin terjadi bahwa dua entitas yang berbeda menghasilkan ketergantungan dengan pengidentifikasi yang sama, yang dapat menyebabkan pelanggaran pembatasan pada kunci primer dari basis data ( <em>kunci utama</em> ).  Tetapi pada titik ini, data sangat murah untuk dideduplikasi - karena kunci hanya berisi pengidentifikasi, kita dapat menempatkan mereka ke dalam koleksi yang menyediakan deduplikasi, misalnya, di <code>Set</code> .  Jika ini ternyata tidak mencukupi, kita selalu dapat membuat deduplikasi yang lebih cerdas dalam bentuk fungsi tambahan yang dikompilasi menjadi fungsi siklus hidup. </p><br><div class="spoiler">  <b class="spoiler_title">Contoh utama</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Key</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackageKey</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, userId: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Key</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackageItemKey</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, packageId: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Key</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserKey</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Key</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BonusKey</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, packageId: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Key</span></span></span></span></code> </pre> </div></div><br><p>  Kami mendelegasikan pembuatan konten palsu ke bidang (misalnya, nama) ke kelas terpisah.  Kemudian, dengan bantuan kelas ini dan aturan untuk mengonversi kunci, kita mendapatkan objek string yang ditujukan langsung untuk dimasukkan ke dalam database. </p><br><div class="spoiler">  <b class="spoiler_title">Contoh garis</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleData</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"test name"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">role</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"customer"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">price</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bonusAmount</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">status</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"new"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Row</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackageRow</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, userId: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, status: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Row</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackageItemRow</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, packageId: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, price: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Row</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRow</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, role: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Row</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BonusRow</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, packageId: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, bonusAmount: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Row</span></span></span></span></code> </pre> </div></div><br><p>  Data palsu default, sebagai suatu peraturan, tidak akan cukup bagi kami, jadi kami harus dapat mendefinisikan ulang bidang tertentu.  Kita dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>lensa</em></a> - jalankan melalui semua garis yang dibuat dan ubah hanya bidang yang dibutuhkan.  Karena lensa pada akhirnya adalah fungsi biasa, mereka dapat dikomposisi, dan ini adalah kegunaannya. </p><br><div class="spoiler">  <b class="spoiler_title">Contoh lensa</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeUserRole</span></span></span></span>(userId: <span class="hljs-type"><span class="hljs-type">Int</span></span>, newRole: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Set</span></span>[<span class="hljs-type"><span class="hljs-type">Row</span></span>] =&gt; <span class="hljs-type"><span class="hljs-type">Set</span></span>[<span class="hljs-type"><span class="hljs-type">Row</span></span>] = (rows: <span class="hljs-type"><span class="hljs-type">Set</span></span>[<span class="hljs-type"><span class="hljs-type">Row</span></span>]) =&gt; rows.modifyAll(_.each.when[<span class="hljs-type"><span class="hljs-type">UserRow</span></span>]) .using(r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r.id == userId) r.modify(_.role).setTo(newRole) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> r)</code> </pre> </div></div><br><p>  Berkat komposisi ini, dalam keseluruhan proses kami dapat menerapkan berbagai optimasi dan peningkatan - misalnya, kelompokkan baris dalam tabel sehingga dapat disisipkan dengan satu <code>insert</code> , mengurangi waktu pengujian, atau mengamankan keadaan akhir dari basis data untuk menyederhanakan masalah penangkapan. </p><br><div class="spoiler">  <b class="spoiler_title">Fungsi membentuk fixture</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFixture</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">STATE</span></span>, <span class="hljs-type"><span class="hljs-type">FX</span></span>, <span class="hljs-type"><span class="hljs-type">ROW</span></span>, <span class="hljs-type"><span class="hljs-type">F</span></span>[_]]( state: <span class="hljs-type"><span class="hljs-type">STATE</span></span>, applyOverrides: <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">ROW</span></span>] =&gt; <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">ROW</span></span>] = x =&gt; x ): <span class="hljs-type"><span class="hljs-type">FX</span></span> = (extractKeys andThen deduplicateKeys andThen enrichWithSampleData andThen applyOverrides andThen logged andThen buildFixture) (state)</code> </pre> </div></div><br><p>  Semua bersama-sama akan memberi kita fixture yang mengisi dependensi untuk tes - database.  Dalam tes itu sendiri, tidak ada yang berlebihan akan terlihat, kecuali untuk dataset asli - semua detail akan disembunyikan di dalam komposisi fungsi. </p><br><p><img src="https://habrastorage.org/webt/b3/wz/cq/b3wzcqmqj3gomn-s-zycrakuegy.jpeg"></p><br><p>  Rangkaian uji kami sekarang akan terlihat seperti ini: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataTable: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">DataRow</span></span>] = <span class="hljs-type"><span class="hljs-type">Table</span></span>( (<span class="hljs-string"><span class="hljs-string">"Package ID"</span></span>, <span class="hljs-string"><span class="hljs-string">"Customer's role"</span></span>, <span class="hljs-string"><span class="hljs-string">"Item prices"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bonus value"</span></span>, <span class="hljs-string"><span class="hljs-string">"Expected final price"</span></span>) , (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"customer"</span></span>, <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) , <span class="hljs-type"><span class="hljs-type">Vector</span></span>.empty , <span class="hljs-number"><span class="hljs-number">90.0</span></span>) , (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"customer"</span></span>, <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">250</span></span>) , <span class="hljs-type"><span class="hljs-type">Vector</span></span>.empty , <span class="hljs-number"><span class="hljs-number">225.0</span></span>) , (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"customer"</span></span>, <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) , <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">40</span></span>) , <span class="hljs-number"><span class="hljs-number">210.0</span></span>) , (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"customer"</span></span>, <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) , <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>) , <span class="hljs-number"><span class="hljs-number">279.0</span></span>) , (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"vip"</span></span> , <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>), <span class="hljs-type"><span class="hljs-type">Vector</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>), <span class="hljs-number"><span class="hljs-number">252.0</span></span>) ) <span class="hljs-string"><span class="hljs-string">"   -"</span></span> - { <span class="hljs-string"><span class="hljs-string">"'customer'"</span></span> - { <span class="hljs-string"><span class="hljs-string">"   "</span></span> - { <span class="hljs-string"><span class="hljs-string">"&lt; 250    -  "</span></span> - { <span class="hljs-string"><span class="hljs-string">"(:  )"</span></span> in calculatePriceFor(dataTable, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"(:  )"</span></span> in calculatePriceFor(dataTable, <span class="hljs-number"><span class="hljs-number">3</span></span>) } <span class="hljs-string"><span class="hljs-string">"&gt;= 250   "</span></span> - { <span class="hljs-string"><span class="hljs-string">"   -  10%  "</span></span> in calculatePriceFor(dataTable, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"   -  10%     "</span></span> in calculatePriceFor(dataTable, <span class="hljs-number"><span class="hljs-number">4</span></span>) } } } <span class="hljs-string"><span class="hljs-string">"'vip' -    20%      ,       "</span></span> in calculatePriceFor(dataTable, <span class="hljs-number"><span class="hljs-number">5</span></span>) }</code> </pre> <br><p>  Kode pembantu: </p><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//    def calculatePriceFor(table: Seq[DataRow], idx: Int) = testInDb( state = makeState(table.row(idx)), execute = runProductionCode(table.row(idx)._1), check = checkResult(table.row(idx)._5) ) def makeState(row: DataRow): Logger =&gt; DbFixture = { val items: Map[Int, Int] = ((1 to row._3.length) zip row._3).toMap val bonuses: Map[Int, Int] = ((1 to row._4.length) zip row._4).toMap MyFixtures.makeFixture( state = PackageRelationships .minimal(id = row._1, userId = 1) .withItems(items.keys) .withBonuses(bonuses.keys), overrides = changeRole(userId = 1, newRole = row._2) andThen items.map { case (id, newPrice) =&gt; changePrice(id, newPrice) }.foldPls andThen bonuses.map { case (id, newBonus) =&gt; changeBonus(id, newBonus) }.foldPls ) } def runProductionCode(id: Int): Database =&gt; Double = (db: Database) =&gt; new SomeProductionLogic(db).calculatePrice(id) def checkResult(expected: Double): Double =&gt; Future[Assertion] = (result: Double) =&gt; result shouldBe expected</span></span></code> </pre></div></div><br><p>  Menambahkan kasus uji baru ke tabel menjadi tugas yang sepele, yang memungkinkan Anda untuk berkonsentrasi pada <strong>mencakup jumlah maksimum kondisi batas</strong> , daripada pada pelat tungku. </p><br><h2 id="pereispolzovanie-koda-podgotovki-fikstur-na-drugih-proektah">  Menggunakan kembali kode persiapan fixture pada proyek lain </h2><br><p>  Yah, kami menulis banyak kode untuk menyiapkan perlengkapan dalam satu proyek tertentu, menghabiskan banyak waktu untuk ini.  Bagaimana jika kita memiliki beberapa proyek?  Apakah kita ditakdirkan untuk menemukan kembali roda dan copy-paste setiap kali? </p><br><p>  Kami dapat mengabstraksi persiapan perlengkapan dari model domain tertentu.  Di dunia FP, ada konsep <em>typeclass</em> .  Singkatnya, typeclasses bukan kelas dari OOP, tetapi sesuatu seperti antarmuka, mereka mendefinisikan beberapa jenis perilaku kelompok.  Perbedaan mendasar adalah bahwa kelompok jenis ini ditentukan bukan oleh pewarisan kelas, tetapi oleh instantiasi, seperti variabel biasa.  Seperti halnya warisan, penyelesaian instance dari tipe kelas (via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implisit</a> ) terjadi <em>secara statis</em> , pada tahap kompilasi.  Untuk kesederhanaan, untuk keperluan kami, typeclasses dapat dianggap sebagai <em>ekstensi</em> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotlin</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C #</a> . </p><br><p>  Untuk menjaminkan suatu objek, kita tidak perlu tahu apa yang ada di dalam objek ini, bidang apa dan metode yang dimilikinya.  Penting bagi kami untuk menentukan perilaku <code>log</code> dengan tanda tangan tertentu.  Akan <code>Logged</code> untuk mengimplementasikan antarmuka <code>Logged</code> tertentu di setiap kelas, dan itu tidak selalu mungkin - misalnya, di perpustakaan atau kelas standar.  Dalam kasus typeclasses, semuanya jauh lebih sederhana.  Kami dapat membuat turunan dari <code>Logged</code> Logged, misalnya, untuk perlengkapan, dan menampilkannya dalam bentuk yang dapat dibaca.  Dan untuk semua tipe lainnya, buat instance untuk tipe <code>Any</code> dan gunakan metode <code>toString</code> standar untuk mencatat objek apa pun di representasi internal mereka secara gratis. </p><br><div class="spoiler">  <b class="spoiler_title">Contoh dari kelas Tagged dan instance untuk itu</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logged</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span></span>(a: <span class="hljs-type"><span class="hljs-type">A</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> logger: <span class="hljs-type"><span class="hljs-type">Logger</span></span>): <span class="hljs-type"><span class="hljs-type">A</span></span> } <span class="hljs-comment"><span class="hljs-comment">//   Future implicit def futureLogged[T]: Logged[Future[T]] = new Logged[Future[T]] { override def log(futureT: Future[T])(implicit logger: Logger): Future[T] = { futureT.map { t =&gt; // map  Future       ,   //  logger.info(t.toString()) t } } } // ,        implicit def anyNoLogged[T]: Logged[T] = new Logged[T] { override def log(t: T)(implicit logger: Logger): T = { logger.info(t.toString()) t } }</span></span></code> </pre> </div></div><br><p>  Selain penebangan, kami dapat memperluas pendekatan ini ke seluruh proses mempersiapkan perlengkapan.  Solusi tes akan menawarkan kacamata waktu sendiri dan implementasi abstrak dari fungsi berdasarkan mereka.  Tanggung jawab proyek yang menggunakannya adalah menulis contoh typeclasses untuk tipenya sendiri. </p><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//    def makeFixture[STATE, FX, ROW, F[_]]( state: STATE, applyOverrides: F[ROW] =&gt; F[ROW] = x =&gt; x ): FX = (extractKeys andThen deduplicateKeys andThen enrichWithSampleData andThen applyOverrides andThen logged andThen buildFixture) (state) override def extractKeys(implicit toKeys: ToKeys[DbState]): DbState =&gt; Set[Key] = (db: DbState) =&gt; db.toKeys() override def enrichWithSampleData(implicit enrich: Enrich[Key]): Key =&gt; Set[Row] = (key: Key) =&gt; key.enrich() override def buildFixture(implicit insert: Insertable[Set[Row]]): Set[Row] =&gt; DbFixture = (rows: Set[Row]) =&gt; rows.insert() // ,   - (, )   trait ToKeys[A] { def toKeys(a: A): Set[Key] // Something =&gt; Set[Key] } // ...    trait Enrich[A] { def enrich(a: A): Set[Row] // Set[Key] =&gt; Set[Row] } // ...     trait Insertable[A] { def insert(a: A): DbFixture // Set[Row] =&gt; DbFixture } //      (.     ) implicit val toKeys: ToKeys[DbState] = ??? implicit val enrich: Enrich[Key] = ??? implicit val insert: Insertable[Set[Row]] = ???</span></span></code> </pre> <br><p>  Ketika merancang generator fixture, saya fokus pada penerapan prinsip-prinsip pemrograman dan desain SOLID sebagai indikator stabilitas dan kemampuan beradaptasi untuk sistem yang berbeda: </p><br><ul><li>  <em>Prinsip Tanggung Jawab Tunggal</em> : Setiap typeclass menggambarkan tepat satu aspek dari perilaku tipe. </li><li>  <em>Prinsip Terbuka Tertutup</em> : kami tidak memodifikasi tipe tempur yang ada untuk pengujian, kami memperluasnya dengan contoh dari tyclasses. </li><li>  <em>Prinsip Pergantian Liskov</em> tidak menjadi masalah dalam kasus ini, karena kami tidak menggunakan warisan. </li><li>  <em>Prinsip Segregasi Antarmuka</em> : Kami menggunakan banyak kacamata waktu khusus alih-alih yang global. </li><li>  <em>Prinsip Pembalikan Ketergantungan</em> : Implementasi generator fixture tidak tergantung pada tipe tempur tertentu, tetapi pada timeclasses abstrak. </li></ul><br><p>  Setelah memastikan bahwa semua prinsip terpenuhi, dapat dikatakan bahwa solusi kami terlihat cukup didukung dan dapat dikembangkan untuk menggunakannya dalam proyek yang berbeda. </p><br><p>  Setelah menulis fungsi siklus hidup, generasi fixture, dan konversi dataset menjadi fixture, serta abstrak dari model domain spesifik aplikasi, kami akhirnya siap untuk mengukur solusi kami untuk semua tes. </p><br><h2 id="itogi">  Ringkasan </h2><br><p>  Kami beralih dari gaya desain uji tradisional (selangkah demi selangkah) ke gaya fungsional.  Gaya selangkah demi selangkah baik pada tahap awal dan proyek kecil karena tidak memerlukan tenaga kerja tambahan dan tidak membatasi pengembang, tetapi mulai kehilangan ketika ada banyak tes pada proyek.  Gaya fungsional tidak dirancang untuk menyelesaikan semua masalah dalam pengujian, tetapi dapat sangat membantu penskalaan dan dukungan pengujian dalam proyek-proyek di mana jumlahnya ada dalam ratusan atau ribuan.  Tes gaya fungsional lebih kompak dan fokus pada apa yang benar-benar penting (data, kode uji dan hasil yang diharapkan), dan bukan pada langkah-langkah menengah. </p><br><p>  Selain itu, kami melihat contoh nyata dari seberapa kuat konsep komposisi dan jenis kacamata dalam pemrograman fungsional.  Dengan bantuan mereka, mudah untuk merancang solusi, bagian integral yang dapat diperpanjang dan dapat digunakan kembali. </p><br><p>      ,         ,     ,    .    ,   ,     ,     -.    ,        .   ! </p><br><hr><br><p>     : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463623/">https://habr.com/ru/post/id463623/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463609/index.html">Sistem rekomendasi untuk Directum Club. Bagian Satu, Kolaboratif</a></li>
<li><a href="../id463611/index.html">Plugin yang fantastis, vol. 2. Berlatih</a></li>
<li><a href="../id463613/index.html">Gambar Docker juga dapat dibangun di werf menggunakan Dockerfile biasa</a></li>
<li><a href="../id463617/index.html">Fitur pengujian MMO seluler</a></li>
<li><a href="../id463619/index.html">Bekerja dari jarak jauh: pengalaman kami</a></li>
<li><a href="../id463625/index.html">Pemantauan jaringan dan deteksi aktivitas jaringan abnormal menggunakan solusi Flowmon Networks</a></li>
<li><a href="../id463627/index.html">Perpustakaan generator kode assembler untuk mikrokontroler AVR. Bagian 4</a></li>
<li><a href="../id463629/index.html">Mengkonfigurasi NextCloud + ONLYOFFICE di server yang sama menggunakan Docker</a></li>
<li><a href="../id463631/index.html">Dialog tentang surat</a></li>
<li><a href="../id463637/index.html">Menguji infrastruktur Anda sebagai kode dengan Pulumi. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>