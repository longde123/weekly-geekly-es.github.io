<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè´ üéÖüèø üë©üèª‚Äçüîß Extender UObject en Unreal Engine 4 üôéüèø üëåüèæ üëåüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! Mi nombre es Alexander, he estado trabajando con Unreal Engine durante m√°s de 5 a√±os, y casi todo este tiempo, con proyectos de red. 

 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Extender UObject en Unreal Engine 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/475622/"><p>  Hola a todos!  Mi nombre es Alexander, he estado trabajando con Unreal Engine durante m√°s de 5 a√±os, y casi todo este tiempo, con proyectos de red. <br><br>  Dado que los proyectos de red difieren en sus requisitos de desarrollo y rendimiento, a menudo es necesario trabajar con objetos m√°s simples, como las clases UObject, pero su funcionalidad se trunca inicialmente, lo que puede crear un marco s√≥lido.  En este art√≠culo, hablar√© sobre c√≥mo activar varias funciones en la clase base UObject en Unreal Engine 4. <br><br><img src="https://habrastorage.org/webt/fe/7o/ui/fe7ouisyxz09hjfen72lsdvx5ae.png"><br><br></p><p>  De hecho, escrib√≠ el art√≠culo m√°s como referencia.  La mayor√≠a de la informaci√≥n es extremadamente dif√≠cil de encontrar en la documentaci√≥n o en la comunidad, y aqu√≠ puede abrir r√°pidamente el enlace y copiar el c√≥digo deseado.  ¬°Decid√≠ al mismo tiempo compartir contigo!  El art√≠culo est√° dirigido a aquellos que ya est√°n un poco familiarizados con UE4.  Se considerar√° el c√≥digo C ++, aunque no es necesario saberlo.  Simplemente puede seguir las instrucciones si necesita algo de qu√© hablar.  Adem√°s, no es necesario copiar todo, puede pegar el c√≥digo de la secci√≥n con las propiedades necesarias y deber√≠a funcionar. <a name="habracut"></a></p><br><br><h2>  Un poco sobre UObject </h2><br>  <b>UObject</b> es la clase base para casi todo lo que est√° en Unreal Engine 4. La gran mayor√≠a de los objetos que se crean en su mundo o solo en la memoria se heredan de √©l: objetos en el escenario (AActor), componentes (UActorComponent), diferentes tipos para trabajar con datos y otros. <br><br>  La clase en s√≠ misma, aunque es m√°s f√°cil que las derivadas, es al mismo tiempo bastante funcional.  Por ejemplo, contiene muchos eventos √∫tiles, como cambiar los valores de las variables en el editor y las funciones b√°sicas de la red, que no est√°n activas de forma predeterminada. <br><br>  Los objetos creados por esta clase no pueden estar en el escenario y existen exclusivamente en la memoria.  No se pueden agregar como componentes a los actores, aunque puede ser un tipo de componente si implementa usted mismo la funcionalidad necesaria. <br><br><p>  ¬øPor qu√© necesito UObject si AActor ya admite todo lo que necesito?  En general, hay muchos ejemplos de uso.  Lo m√°s f√°cil son los art√≠culos de inventario.  En el escenario, en alg√∫n lugar del cielo, almacenarlos no es pr√°ctico, por lo que puede almacenarlos en la memoria sin cargar el renderizado y sin crear propiedades innecesarias.  Para aquellos a quienes les gustan las comparaciones t√©cnicas, AActor toma un kilobyte (1016 bytes) y un UObject vac√≠o tiene solo 56 bytes. </p><br><br><h2>  ¬øQu√© es un problema de UObject? </h2><br>  No hay problemas en general, bueno, o simplemente no los encontr√©.  Todo lo que molesta a UObject es la falta de varias funciones que est√°n disponibles por defecto en AActor o en componentes.  Estos son los problemas que he identificado para mi pr√°ctica: <br><br><ul><li>  Los UObjects no se replican a trav√©s de la red; </li><li>  debido al primer punto, no podemos activar eventos RPC; </li><li>  No puede utilizar un amplio conjunto de funciones que requieren un enlace al mundo en Blueprints; </li><li>  no tienen eventos est√°ndar como BeginPlay y Tick; </li><li>  no puede agregar componentes de UObjects a AActor en Blueprints. </li></ul><br><p>  La mayor√≠a de las cosas se pueden resolver f√°cilmente.  Pero algunos tendr√°n que jugar. </p><br><br><h2>  Creando UObject </h2><br>  Antes de expandir nuestra clase con caracter√≠sticas, necesitamos crearla.  Usemos el editor para que el generador escriba autom√°ticamente todo lo que se necesita para trabajar en el encabezado (.h). <br><br>  Podemos crear una nueva clase en el editor de Content Browser haciendo clic en el bot√≥n <i>Nuevo</i> y seleccionando <i>Nueva clase C ++</i> . <br><br><img src="https://habrastorage.org/webt/x3/7r/8d/x37r8d1ahvstuxtpdnafshrnp9m.png"><br><br>  A continuaci√≥n, debemos elegir la clase en s√≠.  Es posible que no est√© en la lista general, por lo tanto, √°bralo y seleccione UObject. <br><br><img src="https://habrastorage.org/webt/p2/7d/dh/p27ddhbtq9bxgmjzobmozoa1tlk.png"><br><br>  Asigne un nombre a su clase y seleccione en qu√© carpeta se almacenar√°.  Cuando creamos la clase, puede ir al estudio, encontrarla all√≠ y comenzar a incorporar todas las funciones necesarias. <br><br>  <i>Principiantes, tenga en cuenta que se crean dos archivos: .h y .ccp.</i>  <i>En .h, declarar√° variables y funciones, y en .cpp definir√° su l√≥gica.</i>  <i>Encuentra ambos archivos en tu proyecto.</i>  <i>Si no cambi√≥ la ruta, entonces deber√≠an estar en Proyecto / Fuente / Proyecto /.</i> <br><br>  Hasta que continuemos, escribamos el par√°metro <i>Blueprintable</i> en la macro UCLASS () sobre la declaraci√≥n de clase.  Deber√≠as obtener algo como esto: <br><br>  <b>.h</b> <br><br><pre><code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() }</code> </pre> <br><p>  Gracias a esto, puede crear Blueprints que heredar√°n todo lo que hacemos con este objeto. </p><br><br><h2>  Replicaci√≥n de UObject </h2><br>  Por defecto, los UObjects no se replican a trav√©s de la red.  Como describ√≠ anteriormente, se crean una serie de restricciones cuando necesita sincronizar datos o l√≥gica entre las partes, pero no almacena basura en el mundo. <br><br>  En Unreal Engine 4, la replicaci√≥n tiene lugar precisamente debido a los objetos del mundo.  Significa que simplemente crear un objeto en la memoria y replicarlo fallar√°.  En cualquier caso, necesitar√° un propietario que gestione la transferencia de datos de objetos entre el servidor y los clientes.  Por ejemplo, si su objeto es la habilidad de un personaje, entonces el personaje en s√≠ deber√≠a convertirse en el propietario.  Tambi√©n ser√° un conductor para transmitir informaci√≥n a trav√©s de la red. <br><br>  Prepare nuestro objeto para la replicaci√≥n.  Hasta ahora en el encabezado necesitamos establecer solo una funci√≥n: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSupportedForNetworking</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; }</code> </pre><br>  <i>IsSupportedForNetworking ()</i> determinar√° que el objeto es compatible con la red y se puede replicar. <br><br>  Sin embargo, no todo es tan simple.  Como escrib√≠ anteriormente, necesita un propietario que controle la transferencia del objeto.  Para la pureza del experimento, cree un AActor que lo replicar√°.  Esto se puede hacer exactamente de la misma manera que UObject, solo la clase padre, naturalmente, AActor. <br><br>  <i>Principiantes, si necesita replicar un objeto en un personaje, controlador u otro lugar, cree la clase base adecuada a trav√©s del editor, agregue la l√≥gica necesaria y ya herede de esta clase en Blueprints.</i> <br><br>  Dentro necesitamos 3 funciones: un constructor, una funci√≥n para replicar subobjetos, una funci√≥n que determina lo que se replica dentro de este AActor (variables, referencias de objetos, etc.) y el lugar donde creamos nuestro objeto. <br><br>  No olvides crear una variable por la cual nuestro objeto ser√° almacenado: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMyActor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AActor { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AMyActor(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplicateSubobjects</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(class UActorChannel *Channel, class FOutBunch *Bunch, FReplicationFlags *RepFlags)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLifetimeReplicatedProps</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginPlay</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; UPROPERTY(Replicated, BlueprintReadOnly, Category=<span class="hljs-string"><span class="hljs-string">"Object"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObject</span></span></span><span class="hljs-class">;</span></span> }</code> </pre><br>  Dentro del archivo fuente tenemos que escribir todo: <br><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  #include "MyActor.h" #include "Net/UnrealNetwork.h" #include "Engine/World.h" #include "Engine/ActorChannel.h" #include "   UObject/MyObject.h" AMyActor::AMyActor() { //  Actor  . bReplicates = true // . NetCullDistanceSquared = 99999; //  (  ). NetUpdateFrequency = 1.f; } void AMyActor::GetLifetimeReplicatedProps (TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) { Super::GetLifetimeReplicatedProps(OutLifetimeProps); //       .           . DOREPLIFETIME(AMyActor, MyObject); } bool AMyActor::ReplicateSubobjects(UActorChannel * Channel, FOutBunch * Bunch, FReplicationFlags * RepFlags) { bool WroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags); //   . if (MyObject ) WroteSomething |= Channel-&gt;ReplicateSubobject(MyObject , *Bunch, *RepFlags); return WroteSomething; } AMyActor::BeginPlay() { /*       (  )  .    this.        . ,       ,     . */ if(HasAuthority()) { MyObject = NewObject&lt;UMyObject&gt;(this); //       if(MyObject) UE_LOG(LogTemp, Log, TEXT("%s created"), *MyObject-&gt;GetName()); } }</span></span></code> </pre><br><p>  Ahora su objeto se replicar√° con este actor.  Puede mostrar su nombre en la marca, pero ya en el cliente.  Tenga en cuenta que en Begin Play es poco probable que un objeto llegue antes que el cliente, por lo que no tiene sentido escribir un registro en √©l. </p><br><br><h2>  Replicaci√≥n de variables en UObject </h2><br>  En la mayor√≠a de los casos, no tiene sentido replicar un objeto si no contiene informaci√≥n que tambi√©n se sincronizar√° entre el servidor y los clientes.  Como nuestro objeto ya est√° replicado, pasar variables no es dif√≠cil.  Esto se hace de la misma manera que dentro de nuestro Actor: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSupportedForNetworking</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLifetimeReplicatedProps</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; UPROPERTY(Replicated, BlueprintReadWrite, Category=<span class="hljs-string"><span class="hljs-string">"Object"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MyInteger; <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  #include "MyObject.h" #include "Net/UnrealNetwork.h" UMyObject ::UMyObject () { //  Object  .     . bReplicates = true //       ,     . } void UMyObject ::GetLifetimeReplicatedProps (TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) { Super::GetLifetimeReplicatedProps(OutLifetimeProps); //   Integer  . DOREPLIFETIME(UMyObject, MyInteger); } }</span></span></code> </pre><br>  Al agregar una variable y marcarla para su replicaci√≥n, podemos replicarla.  Todo es simple y lo mismo que en AActor. <br><br>  Sin embargo, hay una peque√±a trampa que no es visible de inmediato, pero puede ser enga√±osa.  Esto ser√° especialmente notable si est√° creando su UObject no para trabajar en C ++, sino para prepararlo para la herencia y el trabajo en Blueprints. <br><br>  La conclusi√≥n es que las variables creadas en el heredero de Blueprints no se replicar√°n.  El motor no los marca autom√°ticamente y cambiar un par√°metro en el servidor en el BP no cambia nada en el valor del cliente.  Pero hay una cura para esto.  Para la replicaci√≥n correcta de las variables de BP, debe marcarlas de antemano.  Agregue un par de l√≠neas a GetLifetimeReplicatedProps (): <br><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UMyObject ::GetLifetimeReplicatedProps (TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) { Super::GetLifetimeReplicatedProps(OutLifetimeProps); <span class="hljs-comment"><span class="hljs-comment">//   Integer  . DOREPLIFETIME(UMyObject, MyInteger); //       UBlueprintGeneratedClass* BPClass = Cast&lt;UBlueprintGeneratedClass&gt;(GetClass()); if (BPClass) BPClass-&gt;GetLifetimeBlueprintReplicationList(OutLifetimeProps); }</span></span></code> </pre><br><p>  Las variables en las clases secundarias de Blueprint ahora se replicar√°n como se esperaba. </p><br><br><h2>  Eventos RPC en UObject </h2><br>  Los eventos RPC (Llamada a procedimiento remoto) son funciones especiales que se llaman al otro lado de la interacci√≥n de red de un proyecto.  Utiliz√°ndolos, puede llamar a la funci√≥n desde el servidor en otros clientes y desde el cliente en el servidor.  Muy √∫til y de uso frecuente al escribir proyectos de red. <br><br>  <i>Si no est√° familiarizado con ellos, le recomiendo leer un art√≠culo.</i>  <i>Describe el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uso en C ++ y en Blueprints</a> .</i> <br><br>  Si bien no hay problemas en Actor o en los componentes con su llamada, en UObject los eventos se disparan en el mismo lado donde fueron llamados, lo que hace que sea imposible hacer una llamada remota cuando sea necesario. <br><br>  Mirando el c√≥digo del componente (UActorComponent), podemos encontrar varias funciones que le permiten transferir llamadas a trav√©s de la red.  Como UActorComponent se hereda de UObject, simplemente podemos copiar las secciones de c√≥digo necesarias y pegarlas en nuestro objeto para que funcione como deber√≠a: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   #include "Engine/EngineTypes.h" UCLASS(Blueprintable) class MYPROPJECT_API UMyObject : public UObject { GENERATED_BODY() public: virtual bool CallRemoteFunction (UFunction * Function, void * Parms, struct FOutParmRec * OutParms, FFrame * Stack) override; virtual int32 GetFunctionCallspace (UFunction* Function, void* Parameters, FFrame* Stack) override; //   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   #include "Engine/NetDriver.h" //       . bool UMyObject::CallRemoteFunction(UFunction * Function, void * Parms, FOutParmRec * OutParms, FFrame * Stack) { if (!GetOuter()) return false; UNetDriver* NetDriver = GetOuter()-&gt;GetNetDriver(); if (!NetDriver) return false; NetDriver-&gt;ProcessRemoteFunction(GetOuter(), Function, Parms, OutParms, Stack, this); return true; } int32 UMyObject::GetFunctionCallspace(UFunction * Function, void * Parameters, FFrame * Stack) { return (GetOuter() ? GetOuter()-&gt;GetFunctionCallspace(Function, Parameters, Stack) : FunctionCallspace::Local); }</span></span></code> </pre><br>  Con estas funciones, podremos activar eventos RPC no solo en c√≥digo, sino tambi√©n en planos. <br><br><p>  Tenga en cuenta que para activar eventos de Cliente o Servidor, necesita un propietario cuyo Propietario sea nuestro jugador.  Por ejemplo, el objeto es propiedad del personaje del usuario o del objeto en el que el Propietario es el Controlador del jugador. </p><br><br><h2>  Caracter√≠sticas globales en planos </h2><br>  Si alguna vez ha creado un Blueprint de objetos, es posible que haya notado que no puede llamar a funciones globales (est√°ticas, pero por razones de claridad lo llamamos) que est√°n disponibles en otras clases, por ejemplo, GetGamemode ().  Parece que simplemente no puede hacer clases en las clases Object, por lo que debe pasar todos los enlaces al crear o pervertir de alguna manera, y a veces la elecci√≥n recae por completo en la clase Actor que se crea en el escenario y Soporta todo. <br><br>  Pero en C ++, por supuesto, no hay tales problemas.  Sin embargo, el dise√±ador del juego, que juega con la configuraci√≥n y agrega diferentes cosas peque√±as, no puede decir que necesita abrir Visual Studio, encontrar la clase adecuada y obtener el modo de juego en la funci√≥n doSomething () cambiando los puntos en √©l.  Por lo tanto, es imperativo que el dise√±ador pueda iniciar sesi√≥n en Bluprint y que con dos clics haga su trabajo.  Ahorre tanto su tiempo como el suyo.  Sin embargo, los planos fueron inventados para esto. <br><br>  La conclusi√≥n es que cuando busca o llama a funciones en el men√∫ contextual de Bluprint, esas mismas funciones globales que requieren una referencia al mundo intentan llamar a una funci√≥n dentro de su objeto que se refiere a √©l.  Y si el editor ve que no hay una funci√≥n, entiende que no puede usarla y no la muestra en la lista. <br><br><img src="https://habrastorage.org/webt/bb/mj/gu/bbmjguakea7gkb-roirojnwnrsg.png"><br><br>  Sin embargo, hay una cura para esto.  Incluso dos. <br><br>  Consideremos primero una opci√≥n para un uso m√°s conveniente en el editor.  Tendremos que redefinir una funci√≥n que devuelva un enlace al mundo y luego el editor comprender√° que en el juego en s√≠ puede funcionar: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-comment"><span class="hljs-comment">//  GetWorld()    . virtual UWorld* GetWorld() const override; //   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs">UWorld* UMyObject::GetWorld() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//       ,    . if (GIsEditor &amp;&amp; !GIsPlayInEditorWorld) return nullptr; else if (GetOuter()) return GetOuter()-&gt;GetWorld(); else return nullptr; }</span></span></code> </pre><br>  Ahora est√° definido y el editor comprender√° que, en general, el objeto puede obtener el puntero deseado (aunque no es v√°lido) y usar funciones globales en el BP. <br><br>  <i>Tenga en cuenta que el propietario (GetOuter ()) tambi√©n debe tener acceso al mundo.</i>  <i>Podr√≠a ser otro UObject con un objeto GetWorld (), componente u actor espec√≠fico en la escena.</i> <br><br><img src="https://habrastorage.org/webt/7x/wu/w3/7xwuw3u7qkekz9m6-bnhdfd0o10.png"><br><br>  Hay otra manera  Es suficiente agregar una etiqueta a la macro UCLASS () al declarar la clase que el par√°metro WorldContextObject se agregar√° a las funciones est√°ticas en el BP, en el cual cualquier objeto que sirve como conductor del "mundo" y las funciones globales del motor se alimentan.  Esta opci√≥n es adecuada para aquellos que en el proyecto pueden tener varios mundos al mismo tiempo (por ejemplo, el mundo del juego y el mundo para el espectador): <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   WorldContext      UCLASS(Blueprintable, meta=(ShowWorldContextPin)) class MYPROPJECT_API UMyObject : public UObject { GENERATED_BODY() //   }</span></span></code> </pre><br>  Si ingresa GetGamemode en la b√∫squeda en el BP, aparecer√° en la lista, al igual que otras funciones similares, y el par√°metro ser√° WorldContextObject, en el que debe pasar un enlace a Actor. <br><br><img src="https://habrastorage.org/webt/nn/uo/xg/nnuoxgsfj912bnoa5fheedsz3yk.png"><br><br>  Por cierto, puede presentar el propietario de nuestra propiedad all√≠.  Recomiendo crear una funci√≥n en Actor, siempre ser√° √∫til para el objeto: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable, meta=(ShowWorldContextPin)) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-comment"><span class="hljs-comment">//      ,     . public: UFUNCTION(BlueprintPure) AActor* GetOwner() const {return Cast&lt;AActor&gt;(GetOuter());}; //   }</span></span></code> </pre><br>  Ahora puede simplemente usar las funciones globales en combinaci√≥n con nuestra funci√≥n Pure para obtener el propietario. <br><br><img src="https://habrastorage.org/webt/ux/22/7w/ux227wpx_b6yp8l8vnlutwxywu8.png"><br><br>  Si tambi√©n declara GetWorld () en la segunda variante como en la primera variante, puede enviar una referencia a usted mismo (Self o This) en el par√°metro WorldContextObject. <br><br><p><img src="https://habrastorage.org/webt/op/jh/mb/opjhmbcmm5jsktm_gtxk-jkgzyy.png"></p><br><br><h2>  BeginPlay y eventos Tick </h2><br>  Otro problema que pueden encontrar los desarrolladores de Blueprint es que no hay eventos BeginPlay y Tick en la clase Object.  Por supuesto, puede crearlos usted mismo y llamar desde otra clase.  Pero debe admitir que es mucho m√°s conveniente cuando todo sale de la caja. <br><br>  Comencemos por comprender c√≥mo hacer Begin Play.  Podemos crear una funci√≥n disponible para reescribir en el BP y llamarla en el constructor de la clase, pero hay una serie de problemas, ya que en el momento del constructor su objeto a√∫n no est√° completamente inicializado. <br><br>  En todas las clases, existe la funci√≥n PostInitProperties (), que se llama despu√©s de la inicializaci√≥n de la mayor√≠a de los par√°metros y el registro del objeto en varios sistemas internos, por ejemplo, para el recolector de basura.  En √©l, puede llamar a nuestro evento, que se utilizar√° en los Blueprints: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-comment"><span class="hljs-comment">//      . virtual void PostInitProperties() override; // ,      . UFUNCTION(BlueprintImplementableEvent) void BeginPlay(); //   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UMyObject::PostInitProperties() { Super::PostInitProperties(); <span class="hljs-comment"><span class="hljs-comment">//   ,   .   BeginPlay    if(GetOuter() &amp;&amp; GetOuter()-&gt;GetWorld()) BeginPlay(); }</span></span></code> </pre><br>  <i>En lugar de if (GetOuter () &amp;&amp; GetOuter () -&gt; GetWorld ()) simplemente puede poner if (GetWorld ()) si ya lo ha redefinido.</i> <i><br><br></i>  <i>Ten cuidado</i>  <i>Por defecto, PostInitProperties () tambi√©n se llama en el editor.</i> <i><br></i> <br>  Ahora podemos entrar en nuestro objeto BP y llamar al evento BeginPlay.  Se llamar√° cuando se cree el objeto. <br><br>  Pasemos al Evento Tick.  No hay una funci√≥n simple para nosotros.  Los objetos de marca en el motor llaman a un administrador especial, al que debe seleccionar de alguna manera.  Sin embargo, aqu√≠ hay un truco muy conveniente: herencia adicional de FTickableGameObject.  Esto le permitir√° hacer autom√°ticamente todo lo que necesita, y luego ser√° suficiente solo para recoger las funciones necesarias: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   #include "Tickable.h" //   c FTickableGameObject UCLASS(Blueprintable) class MYPROPJECT_API UMyObject : public UObject, public FTickableGameObject { GENERATED_BODY() public: //   virtual void Tick(float DeltaTime) override; virtual bool IsTickable() const override; virtual TStatId GetStatId() const override; protected: //     UFUNCTION(BlueprintImplementableEvent) void EventTick(float DeltaTime); //   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UMyObject::Tick(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime) { <span class="hljs-comment"><span class="hljs-comment">//       . EventTick(DeltaTime); //     . } //     bool UMyObject::IsTickable() const { return true; } TStatId UMyObject::GetStatId() const { return TStatId(); }</span></span></code> </pre><br><p>  Si hereda de su objeto y crea una clase BP, estar√° disponible un evento EventTick, lo que causar√° l√≥gica para cada marco. </p><br><br><h2>  Agregar componentes desde UObjects </h2><br>  En UObject Blueprints, no puede generar componentes para actores.  El mismo problema es inherente a los planos de ActorComponent.  La l√≥gica de Epic Games no est√° muy clara, ya que en C ++ esto se puede hacer.  Adem√°s, puede agregar un componente de Actor a otro objeto de Actor simplemente especificando un enlace.  Pero esto no se puede hacer. <br><br>  Desafortunadamente, no pude resolver este art√≠culo.  Si alguien tiene instrucciones sobre c√≥mo hacer esto, estar√© encantado de publicarlo aqu√≠. <br><br><p>  La √∫nica opci√≥n que puedo ofrecer en este momento es hacer un contenedor en la clase UObject, proporcionando acceso a una simple adici√≥n de componentes.  Por lo tanto, ser√° posible agregar componentes al Actor, pero no habr√° creado din√°micamente los par√°metros de entrada del engendro.  A menudo, esto puede ser descuidado. </p><br><br><h2>  Configurar una instancia a trav√©s del editor </h2><br>  En UE4, hay otra "caracter√≠stica" conveniente para trabajar con objetos: esta es la capacidad de crear una instancia durante la inicializaci√≥n y cambiar sus par√°metros a trav√©s del editor, estableciendo as√≠ sus propiedades, sin crear una clase secundaria solo por el bien de la configuraci√≥n.  Especialmente √∫til para dise√±adores de juegos. <br><br>  Suponga que tiene un administrador de modificadores para un personaje y los modificadores mismos est√°n representados por clases que describen los efectos superpuestos.  El dise√±ador del juego cre√≥ un par de modificadores e indica en el administrador cu√°les se utilizan. <br><br>  En una situaci√≥n normal, se ver√≠a as√≠: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMyActor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AActor { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: UPROPERTY(EditAnywhere) TSubclassOf&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObjectClass</span></span></span><span class="hljs-class">;</span></span> }</code> </pre><br><img src="https://habrastorage.org/webt/hd/rx/zc/hdrxzc1qsu2d9htiydsmgfy1t-0.png"><br><br>  Sin embargo, existe el problema de que no puede configurar modificadores y debe crear una clase adicional para otros valores.  De acuerdo, no es muy conveniente tener docenas de clases en el Navegador de contenido que difieran solo en valores.  Arreglar esto es f√°cil.  Puede agregar un par de campos dentro de USTRUCT (), y tambi√©n indicar en el objeto contenedor que nuestros objetos ser√°n instancias, y no solo referencias a objetos o clases inexistentes: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable, DefaultToInstanced, EditInlineNew) <span class="hljs-comment"><span class="hljs-comment">//  -        class MYPROPJECT_API UMyObject : public UObject { GENERATED_BODY() UPROPERTY(EditAnywhere) //       uint8 MyValue; // ,    //   }</span></span></code> </pre><br>  Esto por s√≠ solo no es suficiente, ahora es necesario indicar que la misma variable con la clase ser√° una instancia.  Esto ya se hace donde almacena el objeto, por ejemplo, en el administrador de modificadores de caracteres: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMyActor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AActor { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: UPROPERTY(EditAnywhere, Instanced) <span class="hljs-comment"><span class="hljs-comment">//   Instanced    class UMyObject* MyObject; //    }</span></span></code> </pre><br>  Tenga en cuenta que usamos la referencia al objeto, y no a la clase, ya que la instancia se crear√° inmediatamente despu√©s de la inicializaci√≥n.  Ahora podemos ir a la ventana del editor para seleccionar una clase y ajustar los valores dentro de la instancia.  Es mucho m√°s conveniente y m√°s flexible. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ee4/1cd/e76/ee41cde76aed943c03f0a15ff2e903f6.png" alt="imagen"></p><br><br><h2>  Informacion </h2><br>  Hay otra clase interesante en Unreal Engine.  Este es AInfo.  Una clase heredada de AActor que no tiene una representaci√≥n visual en el mundo.  Info utiliza clases como: modo de juego, GameState, PlayerState y otros.  Es decir, las clases que admiten diferentes chips de AActor, por ejemplo, la replicaci√≥n, pero no se colocan en la escena. <br><br>  Si necesita crear un administrador global adicional que deber√≠a admitir la red y todas las clases de actores resultantes, puede usarlo.  No tiene que manipular la clase UObject como se describi√≥ anteriormente para forzarla, por ejemplo, a replicar datos. <br><br><p>  Sin embargo, tenga en cuenta que aunque el objeto no tiene coordenadas, ni componentes visuales, y no se muestra en la pantalla, sigue siendo un descendiente de la clase Actor, lo que significa que es tan pesado como el padre.  Razonablemente utilizado en peque√±as cantidades y por conveniencia. </p><br><br><h2>  Conclusi√≥n </h2><br>  UObject se necesita con mucha frecuencia, y le aconsejo que lo use siempre que el Actor no sea realmente necesario.  Es una pena que sea un poco limitado, pero tambi√©n es una ventaja.  A veces tiene que jugar cuando necesita usar una plantilla personalizada, pero lo m√°s importante es que se pueden eliminar todas las restricciones principales. <br><br>         ,            ,      UObject,   ,      ,           . <br><br> ,    ,      Unreal Engine 4.   -   ,          .    ,  -    ,   UObject. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/475622/">https://habr.com/ru/post/475622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../475604/index.html">Configuraci√≥n de la plantilla oficial de PostgreSQL en Zabbix 4.4</a></li>
<li><a href="../475608/index.html">Administrador de etiquetas de Google: configuraciones de disparador poco obvias y √∫tiles</a></li>
<li><a href="../475610/index.html">L√°mparas de mesa LED seguras que retienen la visi√≥n</a></li>
<li><a href="../475612/index.html">Dado, cuando, afirmaciones y confianza en la implementaci√≥n</a></li>
<li><a href="../475614/index.html">Automatizaci√≥n para los m√°s peque√±os. Segunda parte Dise√±o de red</a></li>
<li><a href="../475624/index.html">PHP-Watcher: una herramienta que simplifica el desarrollo de aplicaciones de larga duraci√≥n</a></li>
<li><a href="../475630/index.html">Knative: una plataforma basada en k8s como servicio con soporte sin servidor</a></li>
<li><a href="../475640/index.html">Si est√° creando algo, evite la programaci√≥n del gerente.</a></li>
<li><a href="../475642/index.html">Mecanismo de tuplas de solo almacenamiento din√°mico en PostgreSQL</a></li>
<li><a href="../475646/index.html">Yuri Ryabtsev: "La primera intercepci√≥n de un misil bal√≠stico es un evento aproximadamente igual al vuelo de Gagarin"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>