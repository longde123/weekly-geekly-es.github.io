<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🔧 👂🏼 👨‍🌾 Coroutinen :: praktische Erfahrung 😄 🍈 🤹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich darüber sprechen, wie Coroutinen funktionieren und wie sie erstellt werden. Betrachten Sie die Anwendung in sequentieller,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Coroutinen :: praktische Erfahrung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/442920/"> In diesem Artikel werde ich darüber sprechen, wie Coroutinen funktionieren und wie sie erstellt werden.  Betrachten Sie die Anwendung in sequentieller, paralleler Ausführung.  Lassen Sie uns über Fehlerbehandlung, Debugging und Möglichkeiten zum Testen von Coroutine sprechen.  Am Ende werde ich die Eindrücke, die nach Anwendung dieses Ansatzes verblieben sind, zusammenfassen und darüber sprechen. <br><br>  Der Artikel wurde basierend auf den Materialien meines Berichts über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MBLT DEV 2018</a> am Ende des Beitrags erstellt - ein Link zum Video. <br><br><h2>  Konsistenter Stil </h2><br><img src="https://habrastorage.org/webt/ke/8z/tu/ke8ztulkufchujj6k5pxutqtigw.png"><a name="habracut"></a><br>  <i>Abb.</i>  <i>2.1</i> <br><br>  Was war der Zweck der Corutin-Entwickler?  Sie wollten, dass die asynchrone Programmierung so einfach wie möglich ist.  Es gibt nichts Einfacheres, als den Code „Zeile für Zeile“ mit den syntaktischen Konstruktionen der Sprache auszuführen: try-catch-finally, Schleifen, bedingte Anweisungen usw. <br><br>  Betrachten wir zwei Funktionen.  Jeder wird in einem eigenen Thread ausgeführt (Abb. 2.1).  Die erste wird in Thread <b>B ausgeführt</b> und gibt einige Ergebnisdaten <b>B</b> zurück. Dann müssen wir dieses Ergebnis an die zweite Funktion übergeben, die <b>dataB</b> als Argument verwendet und bereits in Thread <b>A ausgeführt wird.</b>  Mit Coroutine können wir unseren Code wie in Abb. 1 gezeigt schreiben.  2.1.  Überlegen Sie, wie Sie dies erreichen können. <br><br>  Funktionen <b>longOpOnB, longOpOnA</b> - die sogenannten <i>Suspend-Funktionen</i> , vor denen der Thread freigegeben wird und nach Abschluss seiner Arbeit wieder beschäftigt wird. <br><br>  Damit diese beiden Funktionen tatsächlich in einem anderen Thread als dem aufgerufenen ausgeführt werden können, während ein „konsistenter“ Schreibstil beibehalten wird, müssen wir sie in den Kontext der Coroutine eintauchen. <br><br>  Dazu werden Coroutinen mit dem sogenannten Coroutine Builder erstellt.  In der Abbildung ist dies ein <i>Start</i> , aber es gibt andere, z. B. <i>asynchron</i> , <i>runBlocking</i> .  Ich werde später darüber sprechen. <br><br>  Das letzte Argument ist ein Codeblock, der im Kontext der Coroutine ausgeführt wird: Aufrufen von Suspend-Funktionen, was bedeutet, dass alle oben genannten Verhaltensweisen nur im Kontext der Coroutine oder in einer anderen Suspend-Funktion möglich sind. <br><br>  Die Coroutine Builder-Methode enthält weitere Parameter, z. B. die Art des Starts, den Thread, in dem der Block ausgeführt wird, und andere. <br><br><h2>  Lebenszyklusmanagement </h2><br>  Coroutine Builder gibt uns den Rückgabewert als Rückgabewert - eine Unterklasse der Jobklasse (Abb.2.2).  Damit können wir den Lebenszyklus von Corutin steuern. <br><br>  Beginnen Sie mit der <i>start ()</i> -Methode, brechen Sie mit der <i>cancel ()</i> -Methode ab, warten Sie, bis der Job mit der <i>join (</i> ) -Methode abgeschlossen ist, abonnieren Sie das Jobabschlussereignis und vieles mehr. <br><br><img src="https://habrastorage.org/webt/os/bf/9j/osbf9jvwmvqtlidv_ugwrfbk-yc.png"><br>  <i>Abb.</i>  <i>2.2</i> <br><br><h2>  Durchflussänderung </h2><br>  Sie können den Ablauf der Coroutine-Ausführung ändern, indem Sie das Kontextelement der Coroutine ändern, die für die Planung verantwortlich ist.  (Abb. 2.3) <br><br>  Beispielsweise wird Corutin 1 in einem <i>UI-</i> Thread ausgeführt, während Corutin 2 in einem Thread aus dem <i>Dispatchers.IO-</i> Pool entnommen wird. <br><br><img src="https://habrastorage.org/webt/oe/9e/o1/oe9eo1ynqwdskvi-laxuunj-xkk.png"><br>  <i>Abb.2.3</i> <br><br>  Die Coroutine-Bibliothek bietet auch eine Suspend-Funktion mit <i>Context (CoroutineContext)</i> , mit der Sie im Kontext einer Coroutine zwischen Threads wechseln können.  Das Wechseln zwischen Threads kann daher recht einfach sein: <br><br><img src="https://habrastorage.org/webt/ga/ca/im/gacaimxsxh_bjcxjweywrc8kstw.png"><br>  <i>Abb.</i>  <i>2.4.</i> <br><br>  Wir starten unsere Coroutine auf UI-Thread 1 → zeigen die Lastanzeige → wechseln zu Arbeitsthread 2, geben den Hauptthread frei → wir führen dort eine lange Operation durch, die im UI-Thread nicht ausgeführt werden kann → geben das Ergebnis zurück zu UI-Thread 3 → und arbeiten dort bereits Damit werden die empfangenen Daten gerendert und die Ladeanzeige ausgeblendet. <br><br>  Bis jetzt sieht es ziemlich bequem aus, mach weiter. <br><br><h2>  Suspend-Funktion </h2><br>  Betrachten Sie die Arbeit von Corutin am Beispiel des häufigsten Falls - Arbeiten mit Netzwerkanforderungen mithilfe der Retrofit 2-Bibliothek. <br><br>  Als erstes müssen wir den <b>Rückrufaufruf</b> in eine <i>Suspend-</i> Funktion konvertieren, um die Coroutine-Funktion nutzen zu können: <br><br><img src="https://habrastorage.org/webt/hs/kk/ue/hskkuekq2frbocs_hd-oxsz8k7o.png"><br>  <i>Abb.</i>  <i>2.5</i> <br><br>  Um den Status der Coroutine zu steuern, bietet die Bibliothek Funktionen der Form <i>suspendXXXXCoroutine</i> , die ein Argument bereitstellen, das die <i>Continuation-</i> Schnittstelle implementiert. Dabei werden die Methoden <i>resumeWithException</i> und <i>resume</i> verwendet, mit denen die Coroutine im Falle eines Fehlers bzw. Erfolgs <i>fortgesetzt werden</i> kann. <br><br>  Als Nächstes werden wir herausfinden, was passiert, wenn die Methode resumeWithException aufgerufen wird, und zunächst sicherstellen, dass der Netzwerkanforderungsaufruf irgendwie abgebrochen werden muss. <br><br><h2>  Funktion aussetzen.  Anrufstornierung </h2><br>  Um den Aufruf und andere Aktionen im Zusammenhang mit der Freigabe nicht verwendeter Ressourcen abzubrechen, können Sie bei der Implementierung der Suspend-Funktion die <i>sofort einsatzbereite suspendCancellableCoroutine-</i> Methode verwenden (Abb. 2.6).  Hier implementiert das <i>Blockargument</i> bereits die <i>CancellableContinuation-</i> Schnittstelle, mit einer der zusätzlichen Methoden - <i>invokeOnCancellation</i> - können Sie sich für einen Fehler oder ein erfolgreiches Coroutine- <i>Abbruchereignis anmelden</i> .  Daher ist es hier auch notwendig, den Methodenaufruf abzubrechen. <br><br><img src="https://habrastorage.org/webt/59/ut/hw/59uthwhyrpuk2-hzm6c2rax0vzk.png"><br>  <i>Abb.</i>  <i>2.6</i> <br><br><h3>  Änderungen in der Benutzeroberfläche anzeigen </h3><br>  Nachdem die Suspend-Funktion für Netzwerkanforderungen vorbereitet wurde, können Sie ihren Aufruf im Coroutine-UI-Stream als sequentiell verwenden, während der Stream während der Ausführung der Anforderung frei ist und der Nachrüst-Stream für die Anforderung verwendet wird. <br><br>  Daher implementieren wir das Verhalten asynchron in Bezug auf den UI-Stream, schreiben es jedoch in einem konsistenten Stil (Abb. 2.6). <br><br>  Wenn Sie nach Erhalt der Antwort die harte Arbeit erledigen müssen, z. B. die empfangenen Daten in die Datenbank schreiben, kann diese Funktion, wie bereits gezeigt, problemlos mit <i>withContext</i> im Pool der <i>Backstream</i> -Flows ausgeführt und die Ausführung auf der Benutzeroberfläche ohne eine einzige Codezeile fortgesetzt werden. <br><br><img src="https://habrastorage.org/webt/ks/qk/g4/ksqkg48x7gjja00x6hii4cpc1uo.png"><br>  <i>Abb.</i>  <i>2.7</i> <br><br>  Leider ist dies nicht alles, was wir für die Anwendungsentwicklung benötigen.  Betrachten Sie die Fehlerbehandlung. <br><br><h3>  Fehlerbehandlung: try-catch-finally.  Coroutine abbrechen: CancellationException </h3><br>  Eine Ausnahme, die nicht in der Coroutine abgefangen wurde, gilt als nicht behandelt und kann zum Absturz der Anwendung führen.  Zusätzlich zu normalen Situationen wird eine Ausnahme ausgelöst, indem die Coroutine mit der Methode <i>resumeWithException</i> in der entsprechenden Zeile des Aufrufs der Suspend-Funktion <i>fortgesetzt</i> wird.  In diesem Fall wird die als Argument übergebene Ausnahme unverändert ausgelöst.  (Abb. 2.8) <br><br><img src="https://habrastorage.org/webt/hm/sv/f0/hmsvf0yzwobbhf3mlv_ce8xy2l8.png"><br>  <i>Abb.</i>  <i>2.8</i> <br><br>  Für die Ausnahmebehandlung steht das Standard-Sprachkonstrukt try catch finally zur Verfügung.  Der Code, der den Fehler in der Benutzeroberfläche anzeigen kann, hat nun die folgende Form: <br><br><img src="https://habrastorage.org/webt/ce/53/hp/ce53hpazfknfd3962fn0wvfv8x8.png"><br>  <i>Abb.</i>  <i>2.9</i> <br><br>  Beim Abbrechen der Coroutine, die durch Aufrufen der Job # cancel-Methode erreicht werden kann, wird eine <i>CancellationException</i> ausgelöst.  Diese Ausnahme wird standardmäßig behandelt und führt nicht zu Abstürzen oder anderen negativen Folgen. <br><br>  Wenn Sie jedoch das <b>try / catch-</b> Konstrukt verwenden, wird es im <b>catch-Block</b> abgefangen, und Sie müssen damit rechnen, wenn Sie nur wirklich „fehlerhafte“ Situationen behandeln möchten.  Beispielsweise wird eine Fehlerbehandlung in der Benutzeroberfläche bereitgestellt, wenn Anforderungen abgebrochen oder Fehler protokolliert werden können.  Im ersten Fall wird der Fehler dem Benutzer angezeigt, obwohl er tatsächlich nicht vorhanden ist, und im zweiten Fall wird eine nutzlose Ausnahme protokolliert und die Berichte werden unübersichtlich. <br><br>  Um die Situation beim Abbrechen von Coroutinen zu ignorieren, müssen Sie den Code leicht ändern: <br><br><img src="https://habrastorage.org/webt/cw/9p/yf/cw9pyfzj3sbzqrpz49b0ochntjq.png"><br>  <i>Abb.</i>  <i>2.10</i> <br><br><h2>  Fehlerprotokollierung </h2><br>  Betrachten Sie den Exception Exception Stack Trace. <br><br>  Wenn Sie eine Ausnahme direkt in den Coroutine-Codeblock auslösen (Abb. 2.11), sieht der Stack-Trace ordentlich aus. Mit nur wenigen Aufrufen von Coroutine werden die Zeile und die Informationen zur Ausnahme korrekt angezeigt.  In diesem Fall können Sie anhand der Stapelverfolgung leicht erkennen, wo genau, in welcher Klasse und in welcher Funktion die Ausnahme ausgelöst wurde. <br><br><img src="https://habrastorage.org/webt/70/1q/h7/701qh72uei7qbt8jpf9kegbnavy.png"><br>  <i>Abb.</i>  <i>2.11</i> <br><br>  Ausnahmen, die an die <i>resumeWithException-</i> Methode von <i>suspend-</i> Funktionen übergeben werden, enthalten jedoch in der Regel keine Informationen über die Coroutine, in der sie aufgetreten ist.  Wenn Sie beispielsweise (Abb. 2.12) die Coroutine der zuvor implementierten Suspend-Funktion mit derselben Ausnahme wie im vorherigen Beispiel fortsetzen, gibt die Stapelverfolgung keine Informationen darüber, wo speziell nach dem Fehler gesucht werden muss. <br><br><img src="https://habrastorage.org/webt/wd/41/xr/wd41xr4kb6f-luf61_cvcmxetr4.png"><br>  <i>Abb.</i>  <i>2.12</i> <br><br>  Um zu verstehen, welche Coroutine mit einer Ausnahme wieder aufgenommen wurde, können Sie das <i>Kontextelement CoroutineName verwenden</i> .  (Abb. 2.13) <br><br>  Das <i>CoroutineName-</i> Element <i>wird</i> zum Debuggen verwendet, indem der Name der Coroutine übergeben wird. Sie können es in Suspend-Funktionen extrahieren und beispielsweise die Ausnahmemeldung ergänzen.  Das heißt, zumindest wird klar sein, wo nach einem Fehler gesucht werden muss. <br><br>  Dieser Ansatz funktioniert nur, wenn die Suspend-Funktion davon ausgeschlossen ist: <br><br><img src="https://habrastorage.org/webt/5u/xs/st/5uxsstlugngflzdlcrarrfws1d4.png"><br>  <i>Abb.</i>  <i>2.13</i> <br><br><h3>  Fehlerprotokollierung.  ExceptionHandler </h3><br>  Um die Ausnahmeprotokollierung für eine bestimmte Coroutine zu ändern, können Sie Ihren eigenen ExceptionHandler festlegen, der eines der Elemente des Coroutine-Kontexts ist.  (Abb. 2.14) <br><br>  Der Handler muss die <i>CoroutineExceptionHandler-</i> Schnittstelle implementieren.  Mit dem überschriebenen Operator + für den Coroutine-Kontext können Sie den Standard-Ausnahmebehandler durch Ihren eigenen ersetzen.  Die nicht behandelte Ausnahme fällt in die <i>handleException-</i> Methode, mit der Sie alles tun können, was Sie brauchen.  Zum Beispiel völlig ignorieren.  Dies geschieht, wenn Sie den Handler leer lassen oder Ihre eigenen Informationen hinzufügen: <br><br><img src="https://habrastorage.org/webt/c_/1w/3y/c_1w3ya8lagmhplbeeq9ajvtbws.png"><br>  <i>Abb.</i>  <i>2.14</i> <br><br>  Mal sehen, wie die Protokollierung unserer Ausnahme aussehen könnte: <br><br><ol><li>  Sie müssen sich an die <i>CancellationException</i> erinnern, die wir ignorieren möchten. </li><li>  Fügen Sie Ihre eigenen Protokolle hinzu. </li><li>  Denken Sie an das Standardverhalten, zu dem das Protokollieren und Beenden der Anwendung gehört. Andernfalls wird die Ausnahme einfach „ausgeblendet“ und es ist nicht klar, was passiert ist. </li></ol><br>  Für den Fall, dass eine Ausnahme ausgelöst wird, wird eine Stapelverfolgungsliste mit den hinzugefügten Informationen an den Logcat gesendet: <br><br><img src="https://habrastorage.org/webt/mr/jl/sc/mrjlscj8bilbyancdfmygexqlki.png"><br>  <i>Abb.</i>  <i>2.15</i> <br><br><h2>  Parallele Ausführung.  asynchron </h2><br>  Betrachten Sie den Parallelbetrieb von Suspend-Funktionen. <br><br>  <i>Async</i> eignet sich am besten zum Organisieren paralleler Ergebnisse aus mehreren Funktionen.  Async, wie <i>Launch</i> - Coroutine Builder.  Die Bequemlichkeit besteht darin, dass mit der Methode <i>await ()</i> bei Erfolg Daten zurückgegeben werden oder eine Ausnahme ausgelöst wird, die während der Ausführung der Coroutine aufgetreten ist.  Die Methode wait wartet auf den Abschluss der Coroutine, falls diese noch nicht abgeschlossen ist. Andernfalls wird das Ergebnis der Arbeit sofort zurückgegeben.  Beachten Sie, dass das Warten eine Suspend-Funktion ist und daher nicht außerhalb des Kontexts einer Coroutine oder einer anderen Suspend-Funktion ausgeführt werden kann. <br><br>  Wenn Sie asynchron arbeiten und Daten von zwei Funktionen parallel abrufen, sieht dies ungefähr so ​​aus: <br><br><img src="https://habrastorage.org/webt/w1/-t/hv/w1-thvudknznjyexdz7_c5rb0w8.png"><br>  <i>Abb.</i>  <i>2.16</i> <br><br>  Stellen Sie sich vor, wir stehen vor der Aufgabe, Daten von zwei Funktionen parallel abzurufen.  Dann müssen Sie sie kombinieren und anzeigen.  Im Fehlerfall muss die Benutzeroberfläche gezeichnet werden, um alle aktuellen Anforderungen abzubrechen.  Ein solcher Fall ist in der Praxis häufig anzutreffen. <br><br>  In diesem Fall muss der Fehler wie folgt behandelt werden: <br><br><ol><li>  Bringen Sie die Fehlerbehandlung in jedes Async-Corutin. </li><li>  Brechen Sie im Fehlerfall alle Coroutinen ab.  Glücklicherweise ist es dafür möglich, einen übergeordneten Job anzugeben, bei dessen Stornierung alle untergeordneten Jobs storniert werden. </li><li>  Wir haben eine zusätzliche Implementierung entwickelt, um zu verstehen, ob alle Daten erfolgreich geladen wurden.  Wir gehen beispielsweise davon aus, dass beim Empfang von Daten ein Fehler aufgetreten ist, wenn wait null zurückgegeben hat. </li></ol><br>  Vor diesem Hintergrund wird die Implementierung der elterlichen Coroutine etwas komplizierter.  Die Implementierung von Async-Corutin ist ebenfalls kompliziert: <br><br><img src="https://habrastorage.org/webt/wy/xe/ny/wyxenyk2quyek7zmhz4ze1dq5sw.png"><br>  <i>Abb.</i>  <i>2.17</i> <br><br>  Dieser Ansatz ist nicht der einzig mögliche.  Beispielsweise können Sie die parallele Ausführung mit Fehlerbehandlung mithilfe von <i>ExceptionHandler</i> oder <i>SupervisorJob</i> implementieren. <br><br><h2>  Verschachtelte Coroutinen </h2><br>  Schauen wir uns die Arbeit der verschachtelten Coroutine an. <br><br>  Standardmäßig wird eine verschachtelte Coroutine mithilfe eines externen Bereichs erstellt und erbt ihren Kontext.  Infolgedessen wird die verschachtelte Coroutine eine Tochter und der externe Elternteil. <br><br>  Wenn wir die externe Coroutine abbrechen, werden auch die auf diese Weise erstellten verschachtelten Coroutinen, die im vorherigen Beispiel verwendet wurden, abgebrochen.  Dies ist auch nützlich, wenn Sie den Bildschirm verlassen, wenn Sie aktuelle Anforderungen abbrechen müssen.  Darüber hinaus wartet das Eltern-Corutin immer auf die Fertigstellung der Tochter. <br><br>  Sie können eine von der externen unabhängige Coroutine mithilfe eines globalen Bereichs erstellen.  In diesem Fall funktioniert die verschachtelte Coroutine, wenn die externe Coroutine abgebrochen wird, so weiter, als wäre nichts passiert: <br><br><img src="https://habrastorage.org/webt/fj/pu/_y/fjpu_yzyp3z0ttuypjypxu2oav4.png"><br>  <i>Abb.</i>  <i>2.18</i> <i><br></i> <br>  Sie können der global verschachtelten Coroutine ein untergeordnetes Element erstellen, indem Sie das Kontextelement durch den <i>Jobschlüssel</i> durch den übergeordneten Job ersetzen, oder Sie können den Kontext der übergeordneten Coroutine vollständig verwenden.  In diesem Fall ist jedoch zu beachten, dass alle Elemente der übergeordneten Coroutine übernommen werden: der Thread-Pool, der Ausnahmebehandler usw. <br><br><img src="https://habrastorage.org/webt/hh/wd/jx/hhwdjxobjkl0arojj0sh6ufii7m.png"><br>  <i>Abb.</i>  <i>2.19</i> <br><br>  Wenn Sie Coroutine von außen verwenden, müssen Sie ihnen die Möglichkeit geben, entweder eine Instanz des Jobs oder den Kontext des übergeordneten Elements zu installieren.  Und Bibliotheksentwickler müssen die Möglichkeit in Betracht ziehen, es als Kind zu installieren, was zu Unannehmlichkeiten führt. <br><br><h2>  Haltepunkte </h2><br>  Coroutinen wirken sich auf die Anzeige von Objektwerten im Debug-Modus aus.  Wenn Sie einen Haltepunkt in die nächste Coroutine der <b>logData-</b> Funktion <b>einfügen</b> , sehen wir beim <b>Auslösen</b> , dass hier alles in Ordnung ist und die Werte korrekt angezeigt werden: <br><br><img src="https://habrastorage.org/webt/hp/t-/oc/hpt-ockcfqvrlzej2ncx0v2cboy.png"><br>  <i>Abb.</i>  <i>2.20</i> <br><br>  <b>Holen Sie sich</b> jetzt <b>dataA</b> mithilfe der verschachtelten Coroutine und lassen Sie einen Haltepunkt in <b>logData</b> : <br><br><img src="https://habrastorage.org/webt/bq/0j/cb/bq0jcbefwitj0ss-bhahf8_cjy8.png"><br>  <i>Abb.</i>  <i>2.21</i> <br><br>  Der Versuch, diesen Block zu erweitern, um die gewünschten Werte zu finden, schlägt fehl.  Daher wird das Debuggen in Gegenwart von Suspend-Funktionen schwierig. <br><br><h2>  Unit Testing </h2><br>  Unit-Tests sind ziemlich einfach.  Sie können hierfür den Coroutine Builder <i>runBlocking verwenden</i> .  <i>runBlocking</i> blockiert einen Thread, bis alle verschachtelten Coroutinen fertig sind. Genau das benötigen Sie zum Testen. <br><br>  Wenn beispielsweise bekannt ist, dass irgendwo innerhalb der Methode Coroutine verwendet wird, um sie zu implementieren, müssen Sie sie zum Testen der Methode nur in <i>runBlocking einschließen</i> . <br><br>  <i>Mit runBlocking</i> kann eine Suspend-Funktion getestet werden: <br><br><img src="https://habrastorage.org/webt/ok/vi/4t/okvi4t5bogczdolbbiimwmqyz5g.png"><br>  <i>Abb.</i>  <i>2.22</i> <br><br><h2>  Beispiele </h2><br>  Abschließend möchte ich einige Beispiele für die Verwendung von Corutin zeigen. <br><br>  Stellen Sie sich vor, wir müssen drei Abfragen A, B und C parallel ausführen, ihre Fertigstellung anzeigen und den Zeitpunkt der Fertigstellung der Anforderungen A und B widerspiegeln. <br><br>  Dazu können Sie einfach die Abfragekoroutinen A und B in eine gemeinsame zusammenfassen und wie mit einem einzigen Ganzen damit arbeiten: <br><br><img src="https://habrastorage.org/webt/xy/ut/fo/xyutfowgblzyjx5l-fb0tcazbx4.png"><br>  <i>Abb.</i>  <i>2.23</i> <br><br>  Das folgende Beispiel zeigt, wie Sie mit der regulären for-Schleife periodische Abfragen mit einem Intervall von 5 Sekunden ausführen: <br><br><img src="https://habrastorage.org/webt/an/bk/zb/anbkzbm6ozetsl3vtwopsmtm2f0.png"><br>  <i>Abb.</i>  <i>2.24</i> <br><br><h2>  Schlussfolgerungen </h2><br>  Von den Minuspunkten stelle ich fest, dass Coroutinen ein relativ junges Werkzeug sind. Wenn Sie sie also für das Produkt verwenden möchten, sollten Sie dies mit Vorsicht tun.  Es gibt Schwierigkeiten beim Debuggen, ein kleines Boilerplate bei der Implementierung offensichtlicher Dinge. <br><br>  Im Allgemeinen sind Coroutinen recht einfach zu verwenden, insbesondere für die Implementierung nicht komplizierter asynchroner Aufgaben.  Insbesondere aufgrund der Tatsache, dass Standard-Sprachkonstrukte verwendet werden können.  Coroutinen sind für Unit-Tests leicht zugänglich, und all dies wird sofort von derselben Firma geliefert, die die Sprache entwickelt hat. <br><br><h2>  Video melden </h2><br>  Es stellte sich heraus, viele Briefe.  Für diejenigen, die mehr hören <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">möchten</a> - Video aus meinem Bericht über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MBLT DEV 2018</a> : <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wsYou5lx6zA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Nützliche Materialien zum Thema: </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung in Coroutinen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tief in Coroutinen eintauchen</a> </li><li>  <a href="">Leitfaden zu kotlinx.coroutines anhand eines Beispiels</a> </li><li>  <a href="">Anleitung zur UI-Programmierung mit Coroutinen</a> </li><li>  <a href="">Coroutines Designdokument (KEEP)</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442920/">https://habr.com/ru/post/de442920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442910/index.html">Warum brauchen wir erweiterte Analysen in SIBUR?</a></li>
<li><a href="../de442912/index.html">Kundgebung gegen die Isolation von Runet</a></li>
<li><a href="../de442914/index.html">Battle Royale: Designgeheimnisse des beliebtesten Gaming-Genres</a></li>
<li><a href="../de442916/index.html">Sind Raubkopien von UKW-Radiosendern heute relevant?</a></li>
<li><a href="../de442918/index.html">Handbuch zum Bereitstellen von Modellen für maschinelles Lernen in einer Produktionsumgebung als API mithilfe von Flask</a></li>
<li><a href="../de442922/index.html">Mondmission "Bereshit" - Eigenschaften des Geräts, eine Reihe von Manövern und der längste Weg zum Mond</a></li>
<li><a href="../de442924/index.html">Erweitertes Terrain Texture Splatting</a></li>
<li><a href="../de442926/index.html">"Mausaufhebens" im Infrarotlicht: das Einbringen von Nanopartikeln in die subretinale Region des Mausauges</a></li>
<li><a href="../de442928/index.html">Schreiben eines flexiblen Codes mit SOLID</a></li>
<li><a href="../de442934/index.html">Wie man Leute in einem riesigen Unternehmen mit einem unbeliebten Stapel anstellt. Gespräch mit Wrike</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>