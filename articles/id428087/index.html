<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™ŒğŸ¿ ğŸ§‘ğŸ»â€ğŸ¤â€ğŸ§‘ğŸ» ğŸ‘¨â€ğŸ’¼ â€œBebas kunci, atau tidak bebas kunci, itulah pertanyaannyaâ€ atau â€œTidur sehat lebih buruk daripada lobak pahitâ€ ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦ ğŸ“² ğŸŒ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Komentar pada artikel " Cara tidur dengan benar dan salah " mengilhami saya untuk menulis artikel ini. 


 Artikel ini akan fokus pada pengembangan ap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>â€œBebas kunci, atau tidak bebas kunci, itulah pertanyaannyaâ€ atau â€œTidur sehat lebih buruk daripada lobak pahitâ€</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428087/"><p>  Komentar pada artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara tidur dengan benar dan salah</a> " mengilhami saya untuk menulis artikel ini. </p><br><p>  Artikel ini akan fokus pada pengembangan aplikasi multi-threaded, penerapan bebas-penguncian untuk beberapa kasus yang timbul dalam proses bekerja pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LAppS</a> , fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nanosleep</a> dan kekerasan terhadap penjadwal tugas. </p><br><pre><code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">NB</span></span>:      <span class="hljs-selector-tag"><span class="hljs-selector-tag">C</span></span>++  <span class="hljs-selector-tag"><span class="hljs-selector-tag">Linux</span></span>,       <span class="hljs-selector-tag"><span class="hljs-selector-tag">POSIX</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1-2008</span></span>  <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> (    ).</code> </pre> <br><p>  Secara umum, semuanya cukup berantakan, saya berharap alur pemikiran dalam presentasi akan jelas.  Jika tertarik, maka saya minta kucing. </p><a name="habracut"></a><br><p>  Perangkat lunak yang berorientasi pada peristiwa selalu menunggu sesuatu.  Baik itu GUI atau server jaringan, mereka menunggu acara apa pun: input keyboard, acara mouse, paket data yang tiba melalui jaringan.  Tetapi semua perangkat lunak menunggu berbeda.  Sistem bebas kunci tidak harus menunggu sama sekali.  Setidaknya penggunaan algoritma bebas kunci harus terjadi di mana Anda tidak perlu menunggu, dan bahkan berbahaya.  Tetapi kita berbicara tentang sistem kompetitif (multi-threaded), dan anehnya, algoritma bebas kunci juga menunggu.  Ya, mereka tidak memblokir eksekusi thread paralel, tetapi mereka sendiri sedang menunggu kesempatan untuk melakukan sesuatu tanpa memblokir. </p><br><p>  LAppS menggunakan mutex dan semaphores dengan sangat aktif.  Pada saat yang sama, tidak ada semaphores dalam standar C ++.  Mekanisme ini sangat penting dan nyaman, tetapi C ++ harus bekerja pada sistem yang tidak memiliki dukungan semaphore, dan oleh karena itu semaphores tidak termasuk dalam standar.  Selain itu, jika saya menggunakan semaphores karena mereka nyaman, maka mutex karena saya harus. </p><br><p>  Perilaku mutex dalam kasus kunci kompetitif (), seperti sem_wait () di Linux, menempatkan utas menunggu di akhir antrian penjadwal tugas, dan ketika berada di atas, pemeriksaan diulang tanpa kembali ke tanah pengguna, utas dimasukkan kembali dalam antrian jika acara yang diharapkan belum terjadi.  Ini adalah poin yang sangat penting. </p><br><p>  Dan saya memutuskan untuk memeriksa apakah saya dapat menolak std :: mutex dan POSIX semaphores, meniru mereka dengan std :: atomic, mentransfer sebagian besar beban ke userland.  Sebenarnya gagal, tapi yang pertama dulu. </p><br><p>  Pertama, saya memiliki beberapa bagian di mana eksperimen ini dapat bermanfaat: </p><br><ul><li>  mengunci LibreSSL (kasus 1); </li><li>  memblokir ketika mentransfer muatan yang diterima paket ke aplikasi Lua (kasus 2); </li><li>  Menunggu acara payload siap diproses oleh aplikasi Lua (kasus 3). </li></ul><br><p>  Mari kita mulai dengan non-blocking-locks.  Mari kita menulis mutex menggunakan atom, seperti yang ditunjukkan dalam beberapa pidato oleh H. Sutter (oleh karena itu, tidak ada kode asli, oleh karena itu, kode tersebut tidak sesuai dengan yang asli 100%, dan di Satter kode ini terkait dengan kemajuan C ++ 20, oleh karena itu ada perbedaan).  Dan terlepas dari kesederhanaan kode ini, ada jebakan di dalamnya. </p><br><pre> <code class="hljs kotlin">#include &lt;atomic&gt; #include &lt;pthread.h&gt; namespace test { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mutex</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: std::atomic&lt;pthread_t&gt; mLock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: explicit mutex():mLock{<span class="hljs-number"><span class="hljs-number">0</span></span>} { } mutex(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mutex&amp;)=delete; mutex(mutex&amp;)=delete; void lock() { pthread_t locked_by=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  C++20     , .. compare_exchange_strong          while(!mLock.compare_exchange_strong(locked_by,pthread_self())) { locked_by=0; //      } } void unlock() { pthread_t current=pthread_self(); if(!mLock.compare_exchange_strong(current,0)) { throw std::system_error(EACCES, std::system_category(), "An attempt to unlock the mutex owned by other thread"); } } const bool try_lock() { pthread_t unused=0; return mLock.compare_exchange_strong(unused,pthread_self()); } }; }</span></span></code> </pre> <br><p>  Tidak seperti std :: mutex :: unlock (), perilaku pengujian :: mutex: unlock () ketika mencoba membuka kunci dari utas lainnya adalah deterministik.  Pengecualian akan dilempar.  Ini bagus, meskipun tidak konsisten dengan perilaku standar.  Dan apa yang buruk di kelas ini?  Berita buruknya adalah bahwa metode test :: mutex: lock () akan tanpa malu-malu menghabiskan sumber daya CPU dalam kuota waktu yang dialokasikan untuk utas, dalam upaya untuk mengambil alih mutex yang sudah dimiliki oleh utas lain.  Yaitu  loop in test :: mutex: lock () akan menjadi pemborosan sumber daya CPU.  Apa pilihan kita untuk mengatasi situasi ini? </p><br><p>  Kita dapat menggunakan sched_yield () (seperti yang disarankan dalam salah satu komentar pada artikel di atas).  Apakah sesederhana itu?  Pertama, untuk menggunakan sched_yield (), perlu bahwa utas eksekusi menggunakan SCHED_RR, SCHED_FIFO kebijakan untuk memprioritaskan mereka dalam penjadwal tugas.  Kalau tidak, memanggil sched_yield () akan menjadi pemborosan sumber daya CPU.  Kedua, panggilan yang sangat sering ke sched_yield () masih akan meningkatkan konsumsi CPU.  Selain itu, penggunaan kebijakan waktu-nyata dalam aplikasi Anda, dan asalkan tidak ada aplikasi waktu-nyata lain dalam sistem, akan membatasi antrian penjadwal dengan kebijakan yang dipilih hanya untuk utas Anda.  Tampaknya ini bagus!  Tidak bagus  Seluruh sistem akan menjadi kurang responsif, karena  sibuk dengan tugas prioritas.  CFQ akan berada di kandang.  Tetapi ada utas lain dalam aplikasi, dan sangat sering muncul situasi ketika utas yang telah menangkap mutex diletakkan di akhir antrian (kuota telah kedaluwarsa), dan utas yang menunggu mutex akan dirilis tepat di depannya.  Dalam percobaan saya (kasus 2), metode ini memberikan hasil yang sama (3,8% lebih buruk) daripada std :: mutex, tetapi sistem ini kurang responsif dan konsumsi CPU meningkat 5% -7%. </p><br><p>  Anda dapat mencoba mengubah test :: mutex :: lock () seperti ini (juga buruk): </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> locked_by=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!mLock.compare_exchange_strong(locked_by,pthread_self())) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">thread_local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pause</span></span></span><span class="hljs-class">{</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// -      nanosleep(&amp;pause,nullptr); locked_by=0; } }</span></span></code> </pre> <br><p>  Di sini Anda dapat bereksperimen dengan durasi tidur dalam nanodetik, penundaan 4 ns optimal untuk CPU saya dan penurunan kinerja relatif ke std :: mutex dalam kasus yang sama 2 adalah 1,2%.  Bukan fakta bahwa nanosleep tidur 4ns.  Bahkan, atau lebih (dalam kasus umum) atau kurang (jika terputus).  Turunnya (!) Dalam konsumsi CPU adalah 12% -20%.  Yaitu  itu adalah mimpi yang sehat. </p><br><p>  OpenSSL dan LibreSSL memiliki dua fungsi yang mengatur panggilan balik untuk diblokir saat menggunakan pustaka ini di lingkungan multi-utas.  Ini terlihat seperti ini: </p><br><pre> <code class="hljs pgsql">//  callback <span class="hljs-type"><span class="hljs-type">void</span></span> openssl_crypt_locking_function_callback(<span class="hljs-type"><span class="hljs-type">int</span></span> mode, <span class="hljs-type"><span class="hljs-type">int</span></span> n, const <span class="hljs-type"><span class="hljs-type">char</span></span>* file, const <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-type"><span class="hljs-type">line</span></span>) { static std::vector&lt;std::mutex&gt; locks(CRYPTO_num_locks()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n&gt;=static_cast&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;(locks.size())) { <span class="hljs-keyword"><span class="hljs-keyword">abort</span></span>(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mode &amp; CRYPTO_LOCK) locks[n].<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> locks[n].unlock(); } //  callback-a CRYPTO_set_locking_callback(openssl_crypt_locking_function_callback); //  id CRYPTO_set_id_callback(pthread_self);</code> </pre> <br><p>  Dan sekarang yang terburuk adalah menggunakan tes di atas :: mutex mutex di LibreSSL mengurangi kinerja LAppS hampir 2 kali.  Selain itu, terlepas dari opsi (loop tunggu kosong, sched_yield (), nanosleep ()). </p><br><p>  Secara umum, kami menghapus case 2 dan case 1, dan tetap menggunakan std :: mutex. </p><br><p>  Mari kita beralih ke semaphores.  Ada banyak contoh bagaimana menerapkan semaphores menggunakan std :: condition_variable.  Mereka semua menggunakan std :: mutex juga.  Dan simulator semaphore seperti itu lebih lambat (menurut tes saya) daripada semaphores sistem POSIX. </p><br><p>  Oleh karena itu, kami akan membuat semafor pada atom: </p><br><pre> <code class="hljs java"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">semaphore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: std::atomic&lt;bool&gt; mayRun; mutable std::atomic&lt;int64_t&gt; counter; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">explicit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">semaphore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> : mayRun</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>},counter{<span class="hljs-number"><span class="hljs-number">0</span></span>} { } semaphore(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> semaphore&amp;)=delete; semaphore(semaphore&amp;)=delete; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ++counter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mayRun.load(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mayRun.load()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(counter.fetch_sub(<span class="hljs-number"><span class="hljs-number">1</span></span>)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++counter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::system_error(ENOENT,std::system_category(),<span class="hljs-string"><span class="hljs-string">"Semaphore is destroyed"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!try_wait()) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> thread_local <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> struct timespec pause{<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>}; nanosleep(&amp;pause,nullptr); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mayRun.store(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> int64_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrimentOn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size_t value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mayRun.load()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter.fetch_sub(value); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::system_error(ENOENT,std::system_category(),<span class="hljs-string"><span class="hljs-string">"Semaphore is destroyed"</span></span>); } } ~semaphore() { destroy(); } };</code> </pre> <br><p>  Oh, semaphore ini jauh lebih cepat daripada sistem semaphore.  Hasil pengujian terpisah dari semaphore ini dengan satu penyedia dan 20 konsumen: </p><br><pre> <code class="hljs bash">OS semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Started 20 threads waiting on a semaphore Thread(OS): wakes: 500321 Thread(OS): wakes: 500473 Thread(OS): wakes: 501504 Thread(OS): wakes: 502337 Thread(OS): wakes: 498324 Thread(OS): wakes: 502755 Thread(OS): wakes: 500212 Thread(OS): wakes: 498579 Thread(OS): wakes: 499504 Thread(OS): wakes: 500228 Thread(OS): wakes: 499696 Thread(OS): wakes: 501978 Thread(OS): wakes: 498617 Thread(OS): wakes: 502238 Thread(OS): wakes: 497797 Thread(OS): wakes: 498089 Thread(OS): wakes: 499292 Thread(OS): wakes: 498011 Thread(OS): wakes: 498749 Thread(OS): wakes: 501296 OS semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. 10000000 of posts <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> 20 waiting threads have taken 9924 milliseconds OS semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Post latency: 0.9924ns ======================================= AtomicEmu semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Started 20 threads waiting on a semaphore Thread(EmuAtomic) wakes: 492748 Thread(EmuAtomic) wakes: 546860 Thread(EmuAtomic) wakes: 479375 Thread(EmuAtomic) wakes: 534676 Thread(EmuAtomic) wakes: 501014 Thread(EmuAtomic) wakes: 528220 Thread(EmuAtomic) wakes: 496783 Thread(EmuAtomic) wakes: 467563 Thread(EmuAtomic) wakes: 608086 Thread(EmuAtomic) wakes: 489825 Thread(EmuAtomic) wakes: 479799 Thread(EmuAtomic) wakes: 539634 Thread(EmuAtomic) wakes: 479559 Thread(EmuAtomic) wakes: 495377 Thread(EmuAtomic) wakes: 454759 Thread(EmuAtomic) wakes: 482375 Thread(EmuAtomic) wakes: 512442 Thread(EmuAtomic) wakes: 453303 Thread(EmuAtomic) wakes: 480227 Thread(EmuAtomic) wakes: 477375 AtomicEmu semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. 10000000 of posts <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> 20 waiting threads have taken 341 milliseconds AtomicEmu semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Post latency: 0.0341ns</code> </pre><br><p>  Semafor ini dengan pos hampir bebas (), yang 29 kali lebih cepat daripada sistem satu, juga sangat cepat dalam membangunkan utas menunggu: 29325 bangun per milidetik, terhadap 1007 bangun per milidetik dari sistem.  Ini memiliki perilaku deterministik dengan semaphore hancur atau semaphore dirusak.  Dan tentu saja, segfault ketika mencoba menggunakan yang sudah hancur. </p><br><p>  (Â¹) Sebenarnya, berkali-kali dalam milidetik aliran tidak dapat ditunda dan dibangunkan oleh penjadwal.  Karena  post () tidak menghalangi, dalam tes sintetik ini, tunggu () sangat sering menemukan dirinya dalam situasi di mana Anda tidak perlu tidur.  Pada saat yang sama, setidaknya 7 utas secara paralel membaca nilai dari semaphore. </p><br><p>  Tetapi menggunakannya dalam kasus 3 dalam LAppS menyebabkan kerugian kinerja terlepas dari waktu tidur.  Dia bangun terlalu sering untuk memeriksa, dan peristiwa di LAppS tiba jauh lebih lambat (latensi jaringan, latensi sisi klien menghasilkan beban, dll.).  Dan memeriksa lebih jarang berarti juga kehilangan kinerja. </p><br><p>  Selain itu, penggunaan tidur dalam kasus seperti itu dan dengan cara yang sama benar-benar berbahaya, karena  pada perangkat keras lain, hasilnya mungkin benar-benar berbeda (seperti dalam kasus jeda instruksi perakitan), dan untuk setiap model CPU, Anda juga harus memilih waktu tunda. </p><br><p>  Keuntungan dari sistem mutex dan semaphore adalah bahwa thread eksekusi tidak terbangun sampai suatu peristiwa (membuka kunci mutex atau menambah semaphore) terjadi.  Siklus CPU ekstra tidak sia-sia - untung. </p><br><p>  Secara umum, segala sesuatu dari yang jahat ini, menonaktifkan iptables pada sistem saya memberikan dari 12% (dengan TLS) hingga 30% (tanpa TLS) keuntungan kinerja ... </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428087/">https://habr.com/ru/post/id428087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428077/index.html">React.js: A Beginner's Guide</a></li>
<li><a href="../id428079/index.html">Menerapkan Prinsip SOLID untuk Bereaksi Pengembangan Aplikasi</a></li>
<li><a href="../id428081/index.html">Menggunakan RxJS dalam React Development untuk Mengelola Status Aplikasi</a></li>
<li><a href="../id428083/index.html">Matriks pengaruh analisis web - sistem strategis Avinash Koshik</a></li>
<li><a href="../id428085/index.html">Frontend menyerang kembali: top 10 (?) HolyJS 2018 Piter melaporkan</a></li>
<li><a href="../id428089/index.html">"Kalender Tester" untuk Oktober. Umpan balik: bagaimana itu terjadi</a></li>
<li><a href="../id428091/index.html">Bagaimana siswa magang menciptakan video game paling populer di dunia, atau sejarah game Windows</a></li>
<li><a href="../id428095/index.html">Riset pasar untuk studio web dan agensi digital</a></li>
<li><a href="../id428097/index.html">Routing rekursif dalam MikroTik melalui gateway yang ditetapkan oleh DHCP</a></li>
<li><a href="../id428099/index.html">Apa kesamaan dari gaun biasa dan era 5G yang akan datang?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>