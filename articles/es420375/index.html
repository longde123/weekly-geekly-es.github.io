<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏼 🏴 📣 Aprende OpenGL. Lección 5.8 - Bloom 🙎🏻 👩‍👦 👨‍👦‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bloom 
 Debido al rango de brillo limitado disponible para los monitores convencionales, la tarea de mostrar convincentemente fuentes de luz brillante...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprende OpenGL. Lección 5.8 - Bloom</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420375/"><img align="left" src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="OGL3" width="300"><h2>  Bloom </h2><br>  Debido al rango de brillo limitado disponible para los monitores convencionales, la tarea de mostrar convincentemente fuentes de luz brillante y superficies iluminadas es difícil por definición.  Uno de los métodos comunes para resaltar áreas brillantes en el monitor es una técnica que agrega un halo de brillo alrededor de los objetos brillantes, dando la impresión de "propagación" de la luz fuera de la fuente de luz.  Como resultado, el observador da la impresión de un alto brillo de tales áreas iluminadas o fuentes de luz. <br><br>  El efecto descrito de un halo y la salida de luz más allá de la fuente se logra mediante una técnica de procesamiento posterior llamada <i>bloom</i> .  La aplicación del efecto agrega un halo de brillo característico a todas las áreas brillantes de la escena mostrada, que se puede ver en el siguiente ejemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oi/qw/mj/oiqwmjiua0ogznqfllr0q9v53fc.png"></div><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Contenido</b> <div class="spoiler_text">  Parte 1. Comenzando <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Creación de ventanas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hola ventana</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hola triangulo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sombreadores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Texturas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Transformaciones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sistemas de coordenadas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cámara</a> </li></ol><br>  Parte 2. Iluminación básica <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Colores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conceptos básicos de iluminación</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Materiales</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapas de textura</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuentes de luz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Múltiples fuentes de iluminación</a> </li></ol><br>  Parte 3. Descargar modelos 3D <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Biblioteca Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clase de polígono de malla</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clase de modelo 3D</a> </li></ol><br>  Parte 4. Características avanzadas de OpenGL <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prueba de profundidad</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prueba de plantilla</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mezcla de colores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Caras de recorte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buffer de trama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tarjetas cúbicas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Manejo avanzado de datos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GLSL avanzado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sombreador geométrico</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instancia</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Suavizado</a> </li></ol><br>  Parte 5. Iluminación avanzada <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Iluminación avanzada.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Modelo Blinn-Fong.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Corrección gamma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cartas de sombra</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapas de sombras omnidireccionales</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapeo normal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapeo de paralaje</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Renderizado diferido</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SSAO</a> </li></ol><br>  Parte 6. PBR <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Teoría</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuentes de luz analiticas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Radiación difusa.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Exposición al espejo.</a> </li></ol><br></div></div><br>  Bloom agrega una pista visual distintiva a la imagen sobre el brillo significativo de los objetos cubiertos por el halo del efecto aplicado.  Al aplicarse de manera selectiva y en un grado preciso (que muchos juegos, por desgracia, no pueden hacer frente), el efecto puede mejorar significativamente la expresividad visual de la iluminación utilizada en la escena, así como agregar drama en ciertas situaciones. <br><br>  Esta técnica funciona en conjunto con el renderizado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HDR</a> casi como una adición evidente.  Aparentemente, debido a esto, muchas personas mezclan erróneamente estos dos términos con la plena intercambiabilidad.  Sin embargo, estas técnicas son completamente independientes y se utilizan para diferentes propósitos.  Es posible implementar bloom utilizando el buffer de fotogramas predeterminado con una profundidad de color de 8 bits, al igual que aplicar el renderizado HDR sin recurrir al uso de bloom.  Lo único es que el renderizado HDR le permite implementar el efecto de una manera más eficiente (lo veremos más adelante). <br><br>  Para implementar la floración, la escena iluminada se representa primero de la manera habitual.  A continuación, se extrae un búfer de color HDR y un búfer de color que contiene solo partes brillantes de la escena.  Esta imagen de porción brillante extraída se borra y se superpone encima de la imagen HDR original de la escena. <br><br>  Para hacerlo más claro, analizaremos el proceso paso a paso.  Renderice una escena que contenga 4 fuentes de luz brillante que se muestran como cubos de colores.  Todos ellos tienen un valor de brillo en el rango de 1.5 a 15.0.  Si el búfer de color se emite al HDR, el resultado es el siguiente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_2/_h/wn/_2_hwnque0owtvpdcyh_vo_p9pg.png"></div><br>  De este búfer de color HDR, extraemos todos los fragmentos cuyo brillo excede un límite predeterminado.  Resulta una imagen que contiene solo áreas iluminadas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q7/jb/uz/q7jbuz_9apwuc9cb2jzpe4a-4si.png"></div><br>  Además, esta imagen de áreas brillantes es borrosa.  La gravedad del efecto está determinada esencialmente por la fuerza y ​​el radio del filtro de desenfoque aplicado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5u/cv/b7/5ucvb73pzpcbvbrn2pcp5khu1_i.png"></div><br>  La imagen borrosa resultante de áreas brillantes es la base del efecto final de halos alrededor de objetos brillantes.  Esta textura simplemente se mezcla con la imagen HDR original de la escena.  Dado que las áreas brillantes estaban borrosas, sus tamaños aumentaron, lo que finalmente da un efecto visual de luminosidad que va más allá de los límites de las fuentes de luz: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wq/pt/lx/wqptlxwywvag8dzh0dck64yzrbg.png"></div><br>  Como puede ver, la floración no es la técnica más sofisticada, pero lograr su alta calidad visual y confiabilidad no siempre es fácil.  En su mayor parte, el efecto depende de la calidad y el tipo de filtro de desenfoque aplicado.  Incluso pequeños cambios en los parámetros del filtro pueden cambiar drásticamente la calidad final del equipo. <br><br>  Entonces, las acciones anteriores nos dan un algoritmo paso a paso del efecto de post-procesamiento para el efecto de floración.  La imagen a continuación resume las acciones requeridas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t7/kt/pz/t7ktpzzm8bo_ccpmh70uu5x0rye.png"></div><br>  En primer lugar, necesitamos información sobre las partes brillantes de la escena en función de un valor umbral dado.  Esto es lo que haremos. <br><br><h2>  Extraer destacados </h2><br>  Entonces, para empezar, necesitamos obtener dos imágenes basadas en nuestra escena.  Sería ingenuo renderizar dos veces, pero use el método más avanzado <i>de Objetivos de renderizado múltiple</i> ( <i>MRT</i> ): especificamos más de una salida en el sombreador de fragmentos final, y gracias a esto, ¡se pueden extraer dos imágenes en una sola pasada!  Para especificar en qué búfer de color se generará el sombreador, se utiliza el especificador de <i>diseño</i> : <br><br><pre><code class="cpp hljs">layout (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) out vec4 FragColor; layout (location = <span class="hljs-number"><span class="hljs-number">1</span></span>) out vec4 BrightColor;</code> </pre> <br>  Por supuesto, el método solo funcionará si hemos preparado varios buffers para escribir.  En otras palabras, para implementar múltiples salidas desde el sombreador de fragmentos, el búfer de cuadros utilizado en este momento debe contener un número suficiente de búferes de color conectados.  Si pasamos a la lección sobre el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">búfer de cuadros</a> , entonces se recuerda que al unir la textura como un búfer de color, podríamos indicar el <i>número de archivo adjunto de color</i> .  Hasta ahora, no necesitábamos usar un archivo adjunto que no sea <i>GL_COLOR_ATTACHMENT0</i> , pero esta vez <i>GL_COLOR_ATTACHMENT1</i> será útil, porque necesitamos dos objetivos para grabar a la vez: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       unsigned int hdrFBO; glGenFramebuffers(1, &amp;hdrFBO); glBindFramebuffer(GL_FRAMEBUFFER, hdrFBO); unsigned int colorBuffers[2]; glGenTextures(2, colorBuffers); for (unsigned int i = 0; i &lt; 2; i++) { glBindTexture(GL_TEXTURE_2D, colorBuffers[i]); glTexImage2D( GL_TEXTURE_2D, 0, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_FLOAT, NULL ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); //     glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D, colorBuffers[i], 0 ); }</span></span></code> </pre> <br>  Además, al llamar a <i>glDrawBuffers</i> , deberá decirle explícitamente a OpenGL que vamos a enviar a varios buffers.  De lo contrario, la biblioteca solo se enviará al primer archivo adjunto, ignorando las operaciones de escritura en otros archivos adjuntos.  Como argumento para la función, se pasa una matriz de identificadores de los archivos adjuntos utilizados de la enumeración correspondiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> attachments[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 }; glDrawBuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, attachments);</code> </pre> <br>  Para este búfer de cuadros, cualquier sombreador de fragmentos que especifique un especificador de <i>ubicación</i> para sus salidas escribirá en el búfer de color correspondiente.  Y esta es una gran noticia, porque de esta manera evitamos el pase de renderizado innecesario para extraer datos sobre las partes brillantes de la escena: puede hacer todo de una vez en un solo sombreador: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) out vec4 FragColor; layout (location = 1) out vec4 BrightColor; [...] void main() { [...] </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      FragColor = vec4(lighting, 1.0); //         //   -    ,    float brightness = dot(FragColor.rgb, vec3(0.2126, 0.7152, 0.0722)); if(brightness &gt; 1.0) BrightColor = vec4(FragColor.rgb, 1.0); else BrightColor = vec4(0.0, 0.0, 0.0, 1.0); }</span></span></span></span></code> </pre> <br>  En este fragmento, se omite la parte que contiene el código típico para calcular la iluminación.  Su resultado se escribe en la primera salida del sombreador: la variable <i>FragColor</i> .  A continuación, el color resultante del fragmento se usa para calcular el valor del brillo.  Para esto, se realiza una traducción ponderada en escala de grises (por multiplicación escalar, multiplicamos los componentes correspondientes de los vectores y los sumamos, lo que lleva a un solo valor).  Luego, cuando se excede el brillo de un fragmento de cierto umbral, registramos su color en la segunda salida del sombreador.  Para los cubos que reemplazan las fuentes de luz, este sombreador también se ejecuta. <br><br>  Habiendo descubierto el algoritmo, podemos entender por qué esta técnica funciona tan bien con el renderizado HDR.  El renderizado en formato HDR permite que los componentes de color vayan más allá del límite superior de 1.0, lo que le permite ajustar de manera más flexible el umbral de brillo fuera del intervalo estándar [0., 1.], proporcionando la capacidad de ajustar qué secciones de la escena se consideran brillantes.  Sin usar HDR, tendrá que contentarse con un umbral de brillo en el intervalo [0., 1.], que es bastante aceptable, pero conduce a un corte de brillo más "agudo", que a menudo hace que la floración sea demasiado intrusiva y llamativa (imagínese en un campo de nieve en lo alto de las montañas) . <br><br>  Después de ejecutar el sombreador, dos buffers de destino contendrán una imagen normal de la escena, así como una imagen que contenga solo áreas brillantes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hp/rf/pr/hprfprhsu9v4q6_gvhhg43leup4.png"></div><br>  La imagen de las áreas brillantes ahora debe procesarse con desenfoque.  Puede lograr esto con un filtro rectangular simple ( <i>cuadro</i> ), que se utilizó en la sección de postprocesamiento de la lección de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">búfer de marco</a> .  Pero se obtiene un resultado mucho mejor mediante el <i>filtrado de Gauss</i> . <br><br><h2>  Desenfoque gaussiano </h2><br>  La lección posterior al procesamiento nos dio una idea de desenfoque utilizando un promedio simple de color de los fragmentos de imagen adyacentes.  Este método de desenfoque es simple, pero la imagen resultante puede parecer más atractiva.  El desenfoque gaussiano se basa en la curva de distribución en forma de campana del mismo nombre: los valores altos de la función se encuentran más cerca del centro de la curva y caen a ambos lados de la misma.  Matemáticamente, una curva gaussiana se puede expresar con diferentes parámetros, pero la forma general de la curva sigue siendo la siguiente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0o/xq/eq/0oxqeqhhsip9d0iai3eit6cpooo.png"></div><br>  El desenfoque con pesos basados ​​en los valores de la curva de Gauss se ve mucho mejor que un filtro rectangular: debido al hecho de que la curva tiene un área más grande en la vecindad de su centro, que corresponde a pesos más grandes para fragmentos cerca del centro del núcleo del filtro.  Tomando, por ejemplo, el núcleo de 32x32, usaremos los factores de ponderación cuanto más pequeño, más lejos esté el fragmento del central.  Es esta característica del filtro la que proporciona un resultado de desenfoque gaussiano visualmente más satisfactorio. <br><br>  La implementación del filtro requerirá una matriz bidimensional de coeficientes de ponderación, que podría rellenarse sobre la base de la expresión bidimensional que describe la curva gaussiana.  Sin embargo, nos encontraremos inmediatamente con un problema de rendimiento: ¡incluso un núcleo de desenfoque relativamente pequeño en un fragmento de 32x32 requerirá 1024 muestras de textura para cada fragmento de la imagen procesada! <br><br>  Afortunadamente para nosotros, la expresión de la curva gaussiana tiene una característica matemática muy conveniente: la separabilidad, que permitirá hacer dos expresiones unidimensionales a partir de una expresión bidimensional que describa los componentes horizontal y vertical.  Esto permitirá desenfocar a su vez en dos enfoques: horizontalmente y luego verticalmente con conjuntos de pesos correspondientes a cada una de las direcciones.  La imagen resultante será la misma que cuando se procesa un algoritmo bidimensional, pero requerirá mucha menos potencia de procesamiento del procesador de video: en lugar de 1024 muestras de la textura, ¡solo necesitamos 32 + 32 = 64!  Esta es la esencia de la filtración gaussiana de dos pasos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3g/my/aq/3gmyaqmqfsy1rk3hegbx_4s5rpc.png"></div><br>  Para nosotros, todo esto significa una cosa: el desenfoque de una imagen tendrá que hacerse dos veces, y aquí el uso de objetos de frame buffer será útil.  Aplicamos la llamada técnica de ping-pong: hay un par de objetos de búfer de cuadro y el contenido del búfer de color de un búfer de cuadro se procesa en el búfer de color del búfer de cuadro actual, luego se intercambian el búfer de cuadro de origen y el receptor de cuadro de búfer y este proceso se repite un número dado de veces.  De hecho, el búfer de cuadro actual para mostrar la imagen simplemente se cambia, y con él, la textura actual a partir de la cual se realiza el muestreo para el renderizado.  El enfoque le permite desenfocar la imagen original colocándola en el primer búfer de cuadros, luego desenfocar el contenido del primer búfer de cuadros, colocarlo en el segundo, luego desenfocar el segundo, colocarlo en el primero y así sucesivamente. <br><br>  Antes de pasar al código de ajuste del búfer de cuadros, echemos un vistazo al código de sombreador de desenfoque gaussiano: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D image; uniform bool horizontal; uniform float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216); void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     vec2 tex_offset = 1.0 / textureSize(image, 0); //    vec3 result = texture(image, TexCoords).rgb * weight[0]; if(horizontal) { for(int i = 1; i &lt; 5; ++i) { result += texture(image, TexCoords + vec2(tex_offset.x * i, 0.0)).rgb * weight[i]; result += texture(image, TexCoords - vec2(tex_offset.x * i, 0.0)).rgb * weight[i]; } } else { for(int i = 1; i &lt; 5; ++i) { result += texture(image, TexCoords + vec2(0.0, tex_offset.y * i)).rgb * weight[i]; result += texture(image, TexCoords - vec2(0.0, tex_offset.y * i)).rgb * weight[i]; } } FragColor = vec4(result, 1.0); }</span></span></span></span></code> </pre> <br>  Como puede ver, utilizamos una muestra bastante pequeña de coeficientes de la curva gaussiana, que se utilizan como pesos para muestras horizontal o verticalmente en relación con el fragmento actual.  El código tiene dos ramas principales que dividen el algoritmo en paso vertical y horizontal en función del valor del uniforme <i>horizontal</i> .  El desplazamiento para cada muestra se establece igual al tamaño del texel, que se define como el recíproco del tamaño de la textura (un valor de tipo <i>vec2</i> devuelto por la función <i>textureSize</i> ()). <br><br>  Cree dos búferes de cuadros que contengan un búfer de color basado en la textura: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pingpongFBO[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pingpongBuffer[<span class="hljs-number"><span class="hljs-number">2</span></span>]; glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, pingpongFBO); glGenTextures(<span class="hljs-number"><span class="hljs-number">2</span></span>, pingpongBuffer); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { glBindFramebuffer(GL_FRAMEBUFFER, pingpongFBO[i]); glBindTexture(GL_TEXTURE_2D, pingpongBuffer[i]); glTexImage2D( GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, pingpongBuffer[i], <span class="hljs-number"><span class="hljs-number">0</span></span> ); }</code> </pre> <br>  Después de obtener la textura HDR de la escena y extraer la textura de las áreas brillantes, llenamos el búfer de color de uno de los pares de framebuffers preparados con la textura de brillo y comenzamos el proceso de ping-pong diez veces (cinco veces verticalmente, cinco horizontalmente): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> horizontal = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, first_iteration = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = <span class="hljs-number"><span class="hljs-number">10</span></span>; shaderBlur.use(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; amount; i++) { glBindFramebuffer(GL_FRAMEBUFFER, pingpongFBO[horizontal]); shaderBlur.setInt(<span class="hljs-string"><span class="hljs-string">"horizontal"</span></span>, horizontal); glBindTexture( GL_TEXTURE_2D, first_iteration ? colorBuffers[<span class="hljs-number"><span class="hljs-number">1</span></span>] : pingpongBuffers[!horizontal] ); RenderQuad(); horizontal = !horizontal; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_iteration) first_iteration = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  En cada iteración, seleccionamos y anclamos uno de los búferes de cuadros en función de si esta iteración se desenfocará horizontal o verticalmente, y el búfer de color del otro búfer de cuadros se usará como textura de entrada para el sombreador de desenfoque.  En la primera iteración, tenemos que usar explícitamente una imagen que contenga áreas brillantes ( <i>brilloTextura</i> ); de lo contrario, ambos framebuffers de ping-pong permanecerán vacíos.  Después de diez pases, la imagen original toma la forma de cinco veces borrosa por un filtro gaussiano completo.  El enfoque utilizado nos permite cambiar fácilmente el grado de desenfoque: cuantas más iteraciones de ping-pong, más fuerte será el desenfoque. <br><br>  En nuestro caso, el resultado borroso se ve así: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2j/du/ga/2jdugaud8hudvnsz8pkdjgaqvus.png"></div><br>  Para completar el efecto, solo queda combinar la imagen borrosa con la imagen HDR original de la escena. <br><br><h2>  Mezcla de texturas </h2><br>  Teniendo a mano la textura HDR de la escena renderizada y la textura borrosa de las áreas sobreexpuestas, todo lo que necesita para darse cuenta del famoso efecto de floración o brillo es combinar estas dos imágenes.  El sombreador de fragmentos final (muy similar al que se presentó en la lección sobre el formato <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HDR</a> ) hace exactamente eso: mezcla de forma aditiva dos texturas: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D scene; uniform sampler2D bloomBlur; uniform float exposure; void main() { const float gamma = 2.2; vec3 hdrColor = texture(scene, TexCoords).rgb; vec3 bloomColor = texture(bloomBlur, TexCoords).rgb; hdrColor += bloomColor; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// additive blending //   vec3 result = vec3(1.0) - exp(-hdrColor * exposure); //     - result = pow(result, vec3(1.0 / gamma)); FragColor = vec4(result, 1.0); }</span></span></span></span></code> </pre> <br>  Qué buscar: la mezcla se realiza antes de aplicar el <i>mapeo de tonos</i> .  Esto traducirá correctamente el brillo adicional del efecto en el <i>rango</i> LDR ( <i>Rango dinámico bajo</i> ), mientras mantiene la distribución relativa del brillo en la escena. <br><br>  El resultado del procesamiento: todas las áreas brillantes recibieron un notable efecto de brillo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ye/ga/s7/yegas7stvrwhww7-a_rzdu3g_lk.png"></div><br>  Los cubos que reemplazan las fuentes de luz ahora se ven mucho más brillantes y transmiten mejor la impresión de una fuente de luz.  Esta escena es bastante primitiva, porque la implementación del efecto de un entusiasmo especial no causará, pero en escenas complejas con iluminación reflexiva, una floración cualitativamente realizada puede ser un elemento visual crucial que agrega drama. <br><br>  El código fuente para el ejemplo está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  Observo que la lección usó un filtro bastante simple con solo cinco muestras en cada dirección.  Al hacer más muestras en un radio mayor o al realizar varias iteraciones del filtro, puede mejorar visualmente el efecto.  Además, vale la pena decir que visualmente la calidad de todo el efecto depende directamente de la calidad del algoritmo de desenfoque utilizado.  Al mejorar el filtro, puede lograr una mejora significativa y todo el efecto.  Por ejemplo, un resultado más impresionante se muestra mediante la combinación de varios filtros con diferentes tamaños de núcleo o diferentes curvas gaussianas.  Los siguientes son recursos adicionales de Kalogirou y EpicGames que abordan cómo mejorar la calidad de la floración modificando el desenfoque gaussiano. <br><br><h2>  Recursos Adicionales </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desenfoque gaussiano eficiente con muestreo lineal</a> : una descripción cualitativa del funcionamiento del filtro gaussiano, junto con el estudio de mejorar el rendimiento del método mediante el uso de filtrado bilineal de muestras de textura OpenGL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bloom Post Process Effect</a> : un artículo de EpicGames sobre cómo mejorar la calidad de un efecto combinando varias curvas de Gauss. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo hacer una buena floración para la representación HDR</a> : un artículo de Kalogirou que describe la mejora en la floración modificando el algoritmo de filtro Gauss original. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420375/">https://habr.com/ru/post/es420375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420363/index.html">Seminarios web de HPE en agosto-octubre: nuevos temas (+ SHD, práctica de IA, almacenamiento de petabytes llave en mano)</a></li>
<li><a href="../es420367/index.html">Apocalipsis con aire acondicionado: escenario de apagón de red inteligente</a></li>
<li><a href="../es420369/index.html">Extreme Extended Edge, o IEEE 802.1BR Switching</a></li>
<li><a href="../es420371/index.html">Sobre el tema de la construcción de bicicletas en el campo del almacenamiento de correo eléctrico</a></li>
<li><a href="../es420373/index.html">Casi OCR para obtener la contraseña de VPNBook. PHP + Mikrotik</a></li>
<li><a href="../es420377/index.html">Cómo comenzamos las videollamadas</a></li>
<li><a href="../es420381/index.html">¿Por qué es suficiente considerar las redes neuronales como una caja negra?</a></li>
<li><a href="../es420383/index.html">"Yandex.Money no le interesa ingresar su solicitud".</a></li>
<li><a href="../es420385/index.html">Pruebas de integración basadas en contenedores.</a></li>
<li><a href="../es420387/index.html">Tres cubos inteligentes de Rubik: Xiaomi, Roobo y GoCube</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>