<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëºüèº üè¥ üì£ Aprende OpenGL. Lecci√≥n 5.8 - Bloom üôéüèª üë©‚Äçüë¶ üë®‚Äçüë¶‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bloom 
 Debido al rango de brillo limitado disponible para los monitores convencionales, la tarea de mostrar convincentemente fuentes de luz brillante...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprende OpenGL. Lecci√≥n 5.8 - Bloom</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420375/"><img align="left" src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="OGL3" width="300"><h2>  Bloom </h2><br>  Debido al rango de brillo limitado disponible para los monitores convencionales, la tarea de mostrar convincentemente fuentes de luz brillante y superficies iluminadas es dif√≠cil por definici√≥n.  Uno de los m√©todos comunes para resaltar √°reas brillantes en el monitor es una t√©cnica que agrega un halo de brillo alrededor de los objetos brillantes, dando la impresi√≥n de "propagaci√≥n" de la luz fuera de la fuente de luz.  Como resultado, el observador da la impresi√≥n de un alto brillo de tales √°reas iluminadas o fuentes de luz. <br><br>  El efecto descrito de un halo y la salida de luz m√°s all√° de la fuente se logra mediante una t√©cnica de procesamiento posterior llamada <i>bloom</i> .  La aplicaci√≥n del efecto agrega un halo de brillo caracter√≠stico a todas las √°reas brillantes de la escena mostrada, que se puede ver en el siguiente ejemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oi/qw/mj/oiqwmjiua0ogznqfllr0q9v53fc.png"></div><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Contenido</b> <div class="spoiler_text">  Parte 1. Comenzando <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Creaci√≥n de ventanas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hola ventana</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hola triangulo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sombreadores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Texturas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Transformaciones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sistemas de coordenadas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√°mara</a> </li></ol><br>  Parte 2. Iluminaci√≥n b√°sica <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Colores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conceptos b√°sicos de iluminaci√≥n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Materiales</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapas de textura</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuentes de luz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">M√∫ltiples fuentes de iluminaci√≥n</a> </li></ol><br>  Parte 3. Descargar modelos 3D <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Biblioteca Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clase de pol√≠gono de malla</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clase de modelo 3D</a> </li></ol><br>  Parte 4. Caracter√≠sticas avanzadas de OpenGL <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prueba de profundidad</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prueba de plantilla</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mezcla de colores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Caras de recorte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buffer de trama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tarjetas c√∫bicas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Manejo avanzado de datos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GLSL avanzado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sombreador geom√©trico</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instancia</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Suavizado</a> </li></ol><br>  Parte 5. Iluminaci√≥n avanzada <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Iluminaci√≥n avanzada.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Modelo Blinn-Fong.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Correcci√≥n gamma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cartas de sombra</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapas de sombras omnidireccionales</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapeo normal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapeo de paralaje</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Renderizado diferido</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SSAO</a> </li></ol><br>  Parte 6. PBR <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Teor√≠a</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuentes de luz analiticas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Radiaci√≥n difusa.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Exposici√≥n al espejo.</a> </li></ol><br></div></div><br>  Bloom agrega una pista visual distintiva a la imagen sobre el brillo significativo de los objetos cubiertos por el halo del efecto aplicado.  Al aplicarse de manera selectiva y en un grado preciso (que muchos juegos, por desgracia, no pueden hacer frente), el efecto puede mejorar significativamente la expresividad visual de la iluminaci√≥n utilizada en la escena, as√≠ como agregar drama en ciertas situaciones. <br><br>  Esta t√©cnica funciona en conjunto con el renderizado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HDR</a> casi como una adici√≥n evidente.  Aparentemente, debido a esto, muchas personas mezclan err√≥neamente estos dos t√©rminos con la plena intercambiabilidad.  Sin embargo, estas t√©cnicas son completamente independientes y se utilizan para diferentes prop√≥sitos.  Es posible implementar bloom utilizando el buffer de fotogramas predeterminado con una profundidad de color de 8 bits, al igual que aplicar el renderizado HDR sin recurrir al uso de bloom.  Lo √∫nico es que el renderizado HDR le permite implementar el efecto de una manera m√°s eficiente (lo veremos m√°s adelante). <br><br>  Para implementar la floraci√≥n, la escena iluminada se representa primero de la manera habitual.  A continuaci√≥n, se extrae un b√∫fer de color HDR y un b√∫fer de color que contiene solo partes brillantes de la escena.  Esta imagen de porci√≥n brillante extra√≠da se borra y se superpone encima de la imagen HDR original de la escena. <br><br>  Para hacerlo m√°s claro, analizaremos el proceso paso a paso.  Renderice una escena que contenga 4 fuentes de luz brillante que se muestran como cubos de colores.  Todos ellos tienen un valor de brillo en el rango de 1.5 a 15.0.  Si el b√∫fer de color se emite al HDR, el resultado es el siguiente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_2/_h/wn/_2_hwnque0owtvpdcyh_vo_p9pg.png"></div><br>  De este b√∫fer de color HDR, extraemos todos los fragmentos cuyo brillo excede un l√≠mite predeterminado.  Resulta una imagen que contiene solo √°reas iluminadas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q7/jb/uz/q7jbuz_9apwuc9cb2jzpe4a-4si.png"></div><br>  Adem√°s, esta imagen de √°reas brillantes es borrosa.  La gravedad del efecto est√° determinada esencialmente por la fuerza y ‚Äã‚Äãel radio del filtro de desenfoque aplicado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5u/cv/b7/5ucvb73pzpcbvbrn2pcp5khu1_i.png"></div><br>  La imagen borrosa resultante de √°reas brillantes es la base del efecto final de halos alrededor de objetos brillantes.  Esta textura simplemente se mezcla con la imagen HDR original de la escena.  Dado que las √°reas brillantes estaban borrosas, sus tama√±os aumentaron, lo que finalmente da un efecto visual de luminosidad que va m√°s all√° de los l√≠mites de las fuentes de luz: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wq/pt/lx/wqptlxwywvag8dzh0dck64yzrbg.png"></div><br>  Como puede ver, la floraci√≥n no es la t√©cnica m√°s sofisticada, pero lograr su alta calidad visual y confiabilidad no siempre es f√°cil.  En su mayor parte, el efecto depende de la calidad y el tipo de filtro de desenfoque aplicado.  Incluso peque√±os cambios en los par√°metros del filtro pueden cambiar dr√°sticamente la calidad final del equipo. <br><br>  Entonces, las acciones anteriores nos dan un algoritmo paso a paso del efecto de post-procesamiento para el efecto de floraci√≥n.  La imagen a continuaci√≥n resume las acciones requeridas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t7/kt/pz/t7ktpzzm8bo_ccpmh70uu5x0rye.png"></div><br>  En primer lugar, necesitamos informaci√≥n sobre las partes brillantes de la escena en funci√≥n de un valor umbral dado.  Esto es lo que haremos. <br><br><h2>  Extraer destacados </h2><br>  Entonces, para empezar, necesitamos obtener dos im√°genes basadas en nuestra escena.  Ser√≠a ingenuo renderizar dos veces, pero use el m√©todo m√°s avanzado <i>de Objetivos de renderizado m√∫ltiple</i> ( <i>MRT</i> ): especificamos m√°s de una salida en el sombreador de fragmentos final, y gracias a esto, ¬°se pueden extraer dos im√°genes en una sola pasada!  Para especificar en qu√© b√∫fer de color se generar√° el sombreador, se utiliza el especificador de <i>dise√±o</i> : <br><br><pre><code class="cpp hljs">layout (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) out vec4 FragColor; layout (location = <span class="hljs-number"><span class="hljs-number">1</span></span>) out vec4 BrightColor;</code> </pre> <br>  Por supuesto, el m√©todo solo funcionar√° si hemos preparado varios buffers para escribir.  En otras palabras, para implementar m√∫ltiples salidas desde el sombreador de fragmentos, el b√∫fer de cuadros utilizado en este momento debe contener un n√∫mero suficiente de b√∫feres de color conectados.  Si pasamos a la lecci√≥n sobre el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b√∫fer de cuadros</a> , entonces se recuerda que al unir la textura como un b√∫fer de color, podr√≠amos indicar el <i>n√∫mero de archivo adjunto de color</i> .  Hasta ahora, no necesit√°bamos usar un archivo adjunto que no sea <i>GL_COLOR_ATTACHMENT0</i> , pero esta vez <i>GL_COLOR_ATTACHMENT1</i> ser√° √∫til, porque necesitamos dos objetivos para grabar a la vez: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       unsigned int hdrFBO; glGenFramebuffers(1, &amp;hdrFBO); glBindFramebuffer(GL_FRAMEBUFFER, hdrFBO); unsigned int colorBuffers[2]; glGenTextures(2, colorBuffers); for (unsigned int i = 0; i &lt; 2; i++) { glBindTexture(GL_TEXTURE_2D, colorBuffers[i]); glTexImage2D( GL_TEXTURE_2D, 0, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_FLOAT, NULL ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); //     glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D, colorBuffers[i], 0 ); }</span></span></code> </pre> <br>  Adem√°s, al llamar a <i>glDrawBuffers</i> , deber√° decirle expl√≠citamente a OpenGL que vamos a enviar a varios buffers.  De lo contrario, la biblioteca solo se enviar√° al primer archivo adjunto, ignorando las operaciones de escritura en otros archivos adjuntos.  Como argumento para la funci√≥n, se pasa una matriz de identificadores de los archivos adjuntos utilizados de la enumeraci√≥n correspondiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> attachments[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 }; glDrawBuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, attachments);</code> </pre> <br>  Para este b√∫fer de cuadros, cualquier sombreador de fragmentos que especifique un especificador de <i>ubicaci√≥n</i> para sus salidas escribir√° en el b√∫fer de color correspondiente.  Y esta es una gran noticia, porque de esta manera evitamos el pase de renderizado innecesario para extraer datos sobre las partes brillantes de la escena: puede hacer todo de una vez en un solo sombreador: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) out vec4 FragColor; layout (location = 1) out vec4 BrightColor; [...] void main() { [...] </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      FragColor = vec4(lighting, 1.0); //         //   -    ,    float brightness = dot(FragColor.rgb, vec3(0.2126, 0.7152, 0.0722)); if(brightness &gt; 1.0) BrightColor = vec4(FragColor.rgb, 1.0); else BrightColor = vec4(0.0, 0.0, 0.0, 1.0); }</span></span></span></span></code> </pre> <br>  En este fragmento, se omite la parte que contiene el c√≥digo t√≠pico para calcular la iluminaci√≥n.  Su resultado se escribe en la primera salida del sombreador: la variable <i>FragColor</i> .  A continuaci√≥n, el color resultante del fragmento se usa para calcular el valor del brillo.  Para esto, se realiza una traducci√≥n ponderada en escala de grises (por multiplicaci√≥n escalar, multiplicamos los componentes correspondientes de los vectores y los sumamos, lo que lleva a un solo valor).  Luego, cuando se excede el brillo de un fragmento de cierto umbral, registramos su color en la segunda salida del sombreador.  Para los cubos que reemplazan las fuentes de luz, este sombreador tambi√©n se ejecuta. <br><br>  Habiendo descubierto el algoritmo, podemos entender por qu√© esta t√©cnica funciona tan bien con el renderizado HDR.  El renderizado en formato HDR permite que los componentes de color vayan m√°s all√° del l√≠mite superior de 1.0, lo que le permite ajustar de manera m√°s flexible el umbral de brillo fuera del intervalo est√°ndar [0., 1.], proporcionando la capacidad de ajustar qu√© secciones de la escena se consideran brillantes.  Sin usar HDR, tendr√° que contentarse con un umbral de brillo en el intervalo [0., 1.], que es bastante aceptable, pero conduce a un corte de brillo m√°s "agudo", que a menudo hace que la floraci√≥n sea demasiado intrusiva y llamativa (imag√≠nese en un campo de nieve en lo alto de las monta√±as) . <br><br>  Despu√©s de ejecutar el sombreador, dos buffers de destino contendr√°n una imagen normal de la escena, as√≠ como una imagen que contenga solo √°reas brillantes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hp/rf/pr/hprfprhsu9v4q6_gvhhg43leup4.png"></div><br>  La imagen de las √°reas brillantes ahora debe procesarse con desenfoque.  Puede lograr esto con un filtro rectangular simple ( <i>cuadro</i> ), que se utiliz√≥ en la secci√≥n de postprocesamiento de la lecci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b√∫fer de marco</a> .  Pero se obtiene un resultado mucho mejor mediante el <i>filtrado de Gauss</i> . <br><br><h2>  Desenfoque gaussiano </h2><br>  La lecci√≥n posterior al procesamiento nos dio una idea de desenfoque utilizando un promedio simple de color de los fragmentos de imagen adyacentes.  Este m√©todo de desenfoque es simple, pero la imagen resultante puede parecer m√°s atractiva.  El desenfoque gaussiano se basa en la curva de distribuci√≥n en forma de campana del mismo nombre: los valores altos de la funci√≥n se encuentran m√°s cerca del centro de la curva y caen a ambos lados de la misma.  Matem√°ticamente, una curva gaussiana se puede expresar con diferentes par√°metros, pero la forma general de la curva sigue siendo la siguiente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0o/xq/eq/0oxqeqhhsip9d0iai3eit6cpooo.png"></div><br>  El desenfoque con pesos basados ‚Äã‚Äãen los valores de la curva de Gauss se ve mucho mejor que un filtro rectangular: debido al hecho de que la curva tiene un √°rea m√°s grande en la vecindad de su centro, que corresponde a pesos m√°s grandes para fragmentos cerca del centro del n√∫cleo del filtro.  Tomando, por ejemplo, el n√∫cleo de 32x32, usaremos los factores de ponderaci√≥n cuanto m√°s peque√±o, m√°s lejos est√© el fragmento del central.  Es esta caracter√≠stica del filtro la que proporciona un resultado de desenfoque gaussiano visualmente m√°s satisfactorio. <br><br>  La implementaci√≥n del filtro requerir√° una matriz bidimensional de coeficientes de ponderaci√≥n, que podr√≠a rellenarse sobre la base de la expresi√≥n bidimensional que describe la curva gaussiana.  Sin embargo, nos encontraremos inmediatamente con un problema de rendimiento: ¬°incluso un n√∫cleo de desenfoque relativamente peque√±o en un fragmento de 32x32 requerir√° 1024 muestras de textura para cada fragmento de la imagen procesada! <br><br>  Afortunadamente para nosotros, la expresi√≥n de la curva gaussiana tiene una caracter√≠stica matem√°tica muy conveniente: la separabilidad, que permitir√° hacer dos expresiones unidimensionales a partir de una expresi√≥n bidimensional que describa los componentes horizontal y vertical.  Esto permitir√° desenfocar a su vez en dos enfoques: horizontalmente y luego verticalmente con conjuntos de pesos correspondientes a cada una de las direcciones.  La imagen resultante ser√° la misma que cuando se procesa un algoritmo bidimensional, pero requerir√° mucha menos potencia de procesamiento del procesador de video: en lugar de 1024 muestras de la textura, ¬°solo necesitamos 32 + 32 = 64!  Esta es la esencia de la filtraci√≥n gaussiana de dos pasos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3g/my/aq/3gmyaqmqfsy1rk3hegbx_4s5rpc.png"></div><br>  Para nosotros, todo esto significa una cosa: el desenfoque de una imagen tendr√° que hacerse dos veces, y aqu√≠ el uso de objetos de frame buffer ser√° √∫til.  Aplicamos la llamada t√©cnica de ping-pong: hay un par de objetos de b√∫fer de cuadro y el contenido del b√∫fer de color de un b√∫fer de cuadro se procesa en el b√∫fer de color del b√∫fer de cuadro actual, luego se intercambian el b√∫fer de cuadro de origen y el receptor de cuadro de b√∫fer y este proceso se repite un n√∫mero dado de veces.  De hecho, el b√∫fer de cuadro actual para mostrar la imagen simplemente se cambia, y con √©l, la textura actual a partir de la cual se realiza el muestreo para el renderizado.  El enfoque le permite desenfocar la imagen original coloc√°ndola en el primer b√∫fer de cuadros, luego desenfocar el contenido del primer b√∫fer de cuadros, colocarlo en el segundo, luego desenfocar el segundo, colocarlo en el primero y as√≠ sucesivamente. <br><br>  Antes de pasar al c√≥digo de ajuste del b√∫fer de cuadros, echemos un vistazo al c√≥digo de sombreador de desenfoque gaussiano: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D image; uniform bool horizontal; uniform float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216); void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     vec2 tex_offset = 1.0 / textureSize(image, 0); //    vec3 result = texture(image, TexCoords).rgb * weight[0]; if(horizontal) { for(int i = 1; i &lt; 5; ++i) { result += texture(image, TexCoords + vec2(tex_offset.x * i, 0.0)).rgb * weight[i]; result += texture(image, TexCoords - vec2(tex_offset.x * i, 0.0)).rgb * weight[i]; } } else { for(int i = 1; i &lt; 5; ++i) { result += texture(image, TexCoords + vec2(0.0, tex_offset.y * i)).rgb * weight[i]; result += texture(image, TexCoords - vec2(0.0, tex_offset.y * i)).rgb * weight[i]; } } FragColor = vec4(result, 1.0); }</span></span></span></span></code> </pre> <br>  Como puede ver, utilizamos una muestra bastante peque√±a de coeficientes de la curva gaussiana, que se utilizan como pesos para muestras horizontal o verticalmente en relaci√≥n con el fragmento actual.  El c√≥digo tiene dos ramas principales que dividen el algoritmo en paso vertical y horizontal en funci√≥n del valor del uniforme <i>horizontal</i> .  El desplazamiento para cada muestra se establece igual al tama√±o del texel, que se define como el rec√≠proco del tama√±o de la textura (un valor de tipo <i>vec2</i> devuelto por la funci√≥n <i>textureSize</i> ()). <br><br>  Cree dos b√∫feres de cuadros que contengan un b√∫fer de color basado en la textura: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pingpongFBO[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pingpongBuffer[<span class="hljs-number"><span class="hljs-number">2</span></span>]; glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, pingpongFBO); glGenTextures(<span class="hljs-number"><span class="hljs-number">2</span></span>, pingpongBuffer); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { glBindFramebuffer(GL_FRAMEBUFFER, pingpongFBO[i]); glBindTexture(GL_TEXTURE_2D, pingpongBuffer[i]); glTexImage2D( GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, pingpongBuffer[i], <span class="hljs-number"><span class="hljs-number">0</span></span> ); }</code> </pre> <br>  Despu√©s de obtener la textura HDR de la escena y extraer la textura de las √°reas brillantes, llenamos el b√∫fer de color de uno de los pares de framebuffers preparados con la textura de brillo y comenzamos el proceso de ping-pong diez veces (cinco veces verticalmente, cinco horizontalmente): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> horizontal = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, first_iteration = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = <span class="hljs-number"><span class="hljs-number">10</span></span>; shaderBlur.use(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; amount; i++) { glBindFramebuffer(GL_FRAMEBUFFER, pingpongFBO[horizontal]); shaderBlur.setInt(<span class="hljs-string"><span class="hljs-string">"horizontal"</span></span>, horizontal); glBindTexture( GL_TEXTURE_2D, first_iteration ? colorBuffers[<span class="hljs-number"><span class="hljs-number">1</span></span>] : pingpongBuffers[!horizontal] ); RenderQuad(); horizontal = !horizontal; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_iteration) first_iteration = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  En cada iteraci√≥n, seleccionamos y anclamos uno de los b√∫feres de cuadros en funci√≥n de si esta iteraci√≥n se desenfocar√° horizontal o verticalmente, y el b√∫fer de color del otro b√∫fer de cuadros se usar√° como textura de entrada para el sombreador de desenfoque.  En la primera iteraci√≥n, tenemos que usar expl√≠citamente una imagen que contenga √°reas brillantes ( <i>brilloTextura</i> ); de lo contrario, ambos framebuffers de ping-pong permanecer√°n vac√≠os.  Despu√©s de diez pases, la imagen original toma la forma de cinco veces borrosa por un filtro gaussiano completo.  El enfoque utilizado nos permite cambiar f√°cilmente el grado de desenfoque: cuantas m√°s iteraciones de ping-pong, m√°s fuerte ser√° el desenfoque. <br><br>  En nuestro caso, el resultado borroso se ve as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2j/du/ga/2jdugaud8hudvnsz8pkdjgaqvus.png"></div><br>  Para completar el efecto, solo queda combinar la imagen borrosa con la imagen HDR original de la escena. <br><br><h2>  Mezcla de texturas </h2><br>  Teniendo a mano la textura HDR de la escena renderizada y la textura borrosa de las √°reas sobreexpuestas, todo lo que necesita para darse cuenta del famoso efecto de floraci√≥n o brillo es combinar estas dos im√°genes.  El sombreador de fragmentos final (muy similar al que se present√≥ en la lecci√≥n sobre el formato <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HDR</a> ) hace exactamente eso: mezcla de forma aditiva dos texturas: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D scene; uniform sampler2D bloomBlur; uniform float exposure; void main() { const float gamma = 2.2; vec3 hdrColor = texture(scene, TexCoords).rgb; vec3 bloomColor = texture(bloomBlur, TexCoords).rgb; hdrColor += bloomColor; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// additive blending //   vec3 result = vec3(1.0) - exp(-hdrColor * exposure); //     - result = pow(result, vec3(1.0 / gamma)); FragColor = vec4(result, 1.0); }</span></span></span></span></code> </pre> <br>  Qu√© buscar: la mezcla se realiza antes de aplicar el <i>mapeo de tonos</i> .  Esto traducir√° correctamente el brillo adicional del efecto en el <i>rango</i> LDR ( <i>Rango din√°mico bajo</i> ), mientras mantiene la distribuci√≥n relativa del brillo en la escena. <br><br>  El resultado del procesamiento: todas las √°reas brillantes recibieron un notable efecto de brillo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ye/ga/s7/yegas7stvrwhww7-a_rzdu3g_lk.png"></div><br>  Los cubos que reemplazan las fuentes de luz ahora se ven mucho m√°s brillantes y transmiten mejor la impresi√≥n de una fuente de luz.  Esta escena es bastante primitiva, porque la implementaci√≥n del efecto de un entusiasmo especial no causar√°, pero en escenas complejas con iluminaci√≥n reflexiva, una floraci√≥n cualitativamente realizada puede ser un elemento visual crucial que agrega drama. <br><br>  El c√≥digo fuente para el ejemplo est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  Observo que la lecci√≥n us√≥ un filtro bastante simple con solo cinco muestras en cada direcci√≥n.  Al hacer m√°s muestras en un radio mayor o al realizar varias iteraciones del filtro, puede mejorar visualmente el efecto.  Adem√°s, vale la pena decir que visualmente la calidad de todo el efecto depende directamente de la calidad del algoritmo de desenfoque utilizado.  Al mejorar el filtro, puede lograr una mejora significativa y todo el efecto.  Por ejemplo, un resultado m√°s impresionante se muestra mediante la combinaci√≥n de varios filtros con diferentes tama√±os de n√∫cleo o diferentes curvas gaussianas.  Los siguientes son recursos adicionales de Kalogirou y EpicGames que abordan c√≥mo mejorar la calidad de la floraci√≥n modificando el desenfoque gaussiano. <br><br><h2>  Recursos Adicionales </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desenfoque gaussiano eficiente con muestreo lineal</a> : una descripci√≥n cualitativa del funcionamiento del filtro gaussiano, junto con el estudio de mejorar el rendimiento del m√©todo mediante el uso de filtrado bilineal de muestras de textura OpenGL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bloom Post Process Effect</a> : un art√≠culo de EpicGames sobre c√≥mo mejorar la calidad de un efecto combinando varias curvas de Gauss. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo hacer una buena floraci√≥n para la representaci√≥n HDR</a> : un art√≠culo de Kalogirou que describe la mejora en la floraci√≥n modificando el algoritmo de filtro Gauss original. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420375/">https://habr.com/ru/post/es420375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420363/index.html">Seminarios web de HPE en agosto-octubre: nuevos temas (+ SHD, pr√°ctica de IA, almacenamiento de petabytes llave en mano)</a></li>
<li><a href="../es420367/index.html">Apocalipsis con aire acondicionado: escenario de apag√≥n de red inteligente</a></li>
<li><a href="../es420369/index.html">Extreme Extended Edge, o IEEE 802.1BR Switching</a></li>
<li><a href="../es420371/index.html">Sobre el tema de la construcci√≥n de bicicletas en el campo del almacenamiento de correo el√©ctrico</a></li>
<li><a href="../es420373/index.html">Casi OCR para obtener la contrase√±a de VPNBook. PHP + Mikrotik</a></li>
<li><a href="../es420377/index.html">C√≥mo comenzamos las videollamadas</a></li>
<li><a href="../es420381/index.html">¬øPor qu√© es suficiente considerar las redes neuronales como una caja negra?</a></li>
<li><a href="../es420383/index.html">"Yandex.Money no le interesa ingresar su solicitud".</a></li>
<li><a href="../es420385/index.html">Pruebas de integraci√≥n basadas en contenedores.</a></li>
<li><a href="../es420387/index.html">Tres cubos inteligentes de Rubik: Xiaomi, Roobo y GoCube</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>