<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏼 🍧 🔉 Mesin otomatis terhadap kode spageti 💡 💏 🌩️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="“Saya suka spageti barat, saya benci kode spageti” 

 "Kode spageti" adalah ungkapan yang ideal untuk menggambarkan perangkat lunak yang merupakan kek...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mesin otomatis terhadap kode spageti</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446330/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/049/15b/078/04915b0789f8de5be2bc6950b3265a8a.png"></div><br>  <i>“Saya suka spageti barat, saya benci kode spageti”</i> <br><br>  "Kode spageti" adalah ungkapan yang ideal untuk menggambarkan perangkat lunak yang merupakan kekacauan dari sudut pandang kognitif dan estetika.  Dalam artikel ini, saya akan berbicara tentang rencana tiga poin untuk menghancurkan kode spageti: <br><br><ul><li>  Kami membahas mengapa kode spageti tidak begitu enak. </li><li>  Memperkenalkan tampilan baru pada apa kode sebenarnya. </li><li>  Kami sedang mendiskusikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener">Frame Machine Notation (FMN)</a> , yang membantu pengembang mengurai pasta. </li></ul><br>  Kita semua tahu betapa sulitnya membaca kode orang lain.  Ini mungkin disebabkan oleh kenyataan bahwa tugas itu sendiri sulit atau karena struktur kode terlalu ... "kreatif".  Seringkali kedua masalah ini berjalan beriringan. <br><br>  Tantangan adalah tugas yang sulit, dan biasanya hanya penemuan revolusioner yang dapat menyederhanakannya.  Namun, itu terjadi bahwa struktur perangkat lunak itu sendiri menambah kompleksitas yang tidak perlu, dan masalah ini <em>patut</em> dipecahkan. <br><br>  Keburukan kode spageti terletak pada logika kondisional yang kompleks.  Dan meskipun hidup bisa sulit untuk dibayangkan tanpa banyak konstruksi rumit jika-maka-lain, artikel ini akan menunjukkan kepada Anda solusi yang lebih baik. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6cc/af0/c3c/6ccaf0c3c57a472e1eb5b80a238a86c5.png"></div><br>  Untuk mengilustrasikan situasi dengan kode spaghetti, kita perlu terlebih dahulu mengubah ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf9/eac/43c/cf9eac43c588d9fecbbfc9bf15753ee1.jpg"></div><br>  <i>Pasta renyah</i> <br><br>  Dalam hal ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fc/683/f12/7fc683f12aa20bcf4abcf5a774c7a039.jpg"></div><br>  <i>Al dente!</i> <br><br>  Ayo mulai memasak. <br><br><h3>  Keadaan tersirat </h3><br>  Untuk membuat pasta, kita pasti membutuhkan air untuk memasak.  Namun, bahkan elemen sederhana yang melibatkan kode spaghetti bisa sangat membingungkan. <br><br>  Ini adalah contoh sederhana: <br><br><pre><code class="cpp hljs">(temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>)</code> </pre> <br>  Apa yang sebenarnya dilakukan pemeriksaan ini?  Jelas, itu membagi garis bilangan menjadi dua bagian, tetapi apa <em>artinya</em> bagian-bagian ini?  Saya pikir Anda dapat membuat asumsi logis, tetapi masalahnya adalah bahwa kode tersebut tidak benar-benar berkomunikasi <em>secara eksplisit</em> . <br><br>  Jika saya benar-benar mengkonfirmasi bahwa dia memeriksa apakah airnya SOLID <i>[kira-kira.</i>  <i>jalur: menurut skala Fahrenheit, air membeku pada +32 derajat]</i> , apa yang secara logis berarti pengembalian salah? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SOLID water } else { // not SOLID water. is (LIQUID | GAS) }</span></span></code> </pre> <br>  Meskipun cek membagi angka menjadi dua kelompok, sebenarnya ada tiga keadaan logis - padat, cair dan gas (SOLID, LIQUID, GAS)! <br><br>  Yaitu, garis angka ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fad/b04/343/fadb04343c512bbf297dbf17a250d742.png"></div><br>  dibagi dengan kondisi periksa sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/e83/2cc/56ae832ccebc547053d46dec39993ec3.png"></div><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a55/dcf/20d/a55dcf20d2de1f679a233913c045546f.png"></div><br><pre> <code class="cpp hljs">}</code> </pre> <br>  Perhatikan apa yang terjadi karena sangat penting untuk memahami sifat kode spageti.  Pemeriksaan Boolean membagi ruang angka menjadi dua bagian, tetapi TIDAK mengkategorikan sistem sebagai struktur logis nyata dari (SOLID, LIQUID, GAS).  Sebagai gantinya, cek membagi ruang menjadi (SOLID, yang lainnya). <br><br>  Ini cek serupa: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &gt; <span class="hljs-number"><span class="hljs-number">212</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// GAS water } else { // not GAS water. is (SOLID | LIQUID) }</span></span></code> </pre> <br>  Secara visual, akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &gt; <span class="hljs-number"><span class="hljs-number">212</span></span>) {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/127/810/51d127810231b42191868d0972e3865f.png"></div><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42a/187/bd4/42a187bd4559e2dfa9e6acffcd24c8b2.png"></div><br><pre> <code class="cpp hljs">}</code> </pre> <br>  Perhatikan bahwa: <br><br><ol><li>  set lengkap negara yang mungkin tidak diumumkan di mana pun </li><li>  tidak ada dalam konstruksi bersyarat yang menyatakan negara logis atau kelompok negara dinyatakan </li><li>  beberapa negara secara tidak langsung dikelompokkan berdasarkan struktur logika kondisional dan percabangan </li></ol><br>  Kode seperti itu rapuh, tetapi sangat umum, dan tidak terlalu besar untuk menyebabkan masalah dengan dukungannya.  Jadi mari kita buat situasinya lebih buruk. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/852/bd5/7a1/852bd57a151d005a34ddd883aea5d1ab.png"></div><br>  <i>Saya tidak pernah menyukai kode Anda</i> <br><br>  Kode yang ditunjukkan di atas menyiratkan adanya tiga keadaan materi - SOLID, LIQUID, GAS.  Namun, menurut data ilmiah, pada kenyataannya, ada <strong><em>empat</em></strong> keadaan yang dapat diamati di mana plasma (PLASMA) dimasukkan (sebenarnya, ada banyak yang lain, tetapi ini akan cukup bagi kita).  Meskipun tidak ada yang menyiapkan pasta dari plasma, jika kode ini diterbitkan di Github, dan kemudian beberapa mahasiswa pascasarjana yang mempelajari fisika energi tinggi akan membayarnya, kita juga harus mempertahankan keadaan ini. <br><br>  Namun, ketika plasma ditambahkan, kode yang ditunjukkan di atas secara naif akan melakukan hal berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SOLID water } else { // not SOLID water. is (LIQUID | GAS) + (PLASMA?) // how did PLASMA get in here?? } if (temp &gt; 212) { // GAS water + (PLASMA) // again with the PLASMA!! } else { // not GAS water. is (SOLID | LIQUID) }</span></span></code> </pre> <br>  Sangat mungkin bahwa kode lama, ketika ditambahkan ke banyak negara plasma, akan pecah di cabang lain.  Sayangnya, tidak ada dalam struktur kode yang membantu melaporkan keberadaan negara baru atau memengaruhi perubahan.  Selain itu, bug apa pun cenderung tidak mencolok, yaitu, menemukan mereka akan menjadi yang paling sulit.  Katakan saja tidak pada serangga di spageti. <br><br>  Singkatnya, masalahnya adalah ini: Pemeriksaan Boolean digunakan untuk menentukan status <em>secara tidak langsung</em> .  Keadaan logis sering tidak dinyatakan dan tidak terlihat dalam kode.  Seperti yang kita lihat di atas, ketika sistem menambahkan keadaan logis baru, kode yang ada dapat rusak.  Untuk menghindari hal ini, <strong>pengembang harus memeriksa ulang setiap pemeriksaan bersyarat dan cabang individu</strong> untuk memastikan bahwa jalur kode masih valid untuk <em>semua</em> keadaan logis mereka!  Ini adalah alasan utama degradasi fragmen kode besar karena menjadi lebih kompleks. <br><br>  Meskipun tidak ada cara untuk sepenuhnya menyingkirkan pemeriksaan data bersyarat, teknik apa pun yang meminimalkannya akan mengurangi kompleksitas kode. <br><br>  Sekarang mari kita lihat implementasi kelas berorientasi objek yang khas yang menciptakan model volume air yang <em>sangat</em> sederhana.  Kelas akan mengelola perubahan dalam keadaan substansi air.  Setelah mempelajari masalah solusi klasik untuk masalah ini, kami kemudian membahas notasi baru bernama <strong>Frame</strong> dan menunjukkan bagaimana hal itu dapat mengatasi kesulitan yang telah kami temukan. <br><br><h3>  Pertama-tama didihkan airnya ... </h3><br>  Ilmu pengetahuan memberi nama pada semua transisi yang mungkin dilakukan suatu zat ketika suhu berubah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/638/016/dc5/638016dc5b2a19ecd2b677cc40e2ee26.png"></div><br>  Kelas kami sangat sederhana (dan tidak terlalu berguna).  Ini menjawab tantangan melakukan transisi antara negara dan mengubah suhu sampai menjadi cocok untuk negara target yang diinginkan: <br><br>  (Catatan: Saya menulis pseudo-code ini. Gunakan dalam pekerjaan Anda hanya dengan risiko dan risiko Anda sendiri.) <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaterSample</span></span></span><span class="hljs-class"> {</span></span> temp:<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Water</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(temp:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.temp = temp } <span class="hljs-comment"><span class="hljs-comment">// gas -&gt; solid func depose() { // If not in GAS state, throw an error if (temp &lt; WATER_GAS_TEMP) throw new IllegalStateError() // do depose while (temp &gt; WATER_SOLID_TEMP) decreaseTemp(1) } // gas -&gt; liquid func condense() { // If not in GAS state, throw an error if (temp &lt; WATER_GAS_TEMP) throw new IllegalStateError() // do condense while (temp &gt; WATER_GAS_TEMP) decreaseTemp(1) } // liquid -&gt; gas func vaporize() { // If not in LIQUID state, throw an error if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError() // do vaporize while (temp &lt; WATER_GAS_TEMP) increaseTemp(1) } // liquid -&gt; solid func freeze() { // If not in LIQUID state, throw an error if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError() // do freeze while (temp &gt; WATER_SOLID_TEMP) decreaseTemp(1) } // solid -&gt; liquid func melt() { // If not in SOLID state, throw an error if (temp &gt; WATER_SOLID_TEMP) throw new IllegalStateError() // do melt while (temp &lt; WATER_SOLID_TEMP) increaseTemp(1) } // solid -&gt; gas func sublimate() { // If not in SOLID state, throw an error if (temp &gt; WATER_SOLID_TEMP) throw new IllegalStateError() // do sublimate while (temp &lt; WATER_GAS_TEMP) increaseTemp(1) } func getState():string { if (temp &lt; WATER_SOLID_TEMP) return "SOLID" if (temp &gt; WATER_GAS_TEMP) return "GAS" return "LIQUID" } }</span></span></code> </pre> <br>  Dibandingkan dengan contoh pertama, kode ini memiliki peningkatan tertentu.  Pertama, angka "ajaib" hard-code (32, 212) digantikan oleh konstanta batas suhu negara (WATER_ LAPORAN_TEMP, WATER_GAS_TEMP).  Perubahan ini mulai membuat negara lebih eksplisit, meskipun secara tidak langsung. <br><br>  Pemeriksaan untuk "pemrograman defensif" juga muncul dalam kode ini, yang membatasi pemanggilan metode jika ia dalam kondisi tidak cocok untuk operasi.  Misalnya, air tidak dapat membeku jika bukan cairan - ini melanggar hukum (dari alam).  Tetapi menambahkan kondisi anjing penjaga membuat memahami tujuan kode lebih sulit.  Sebagai contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// liquid -&gt; solid if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError()</span></span></code> </pre> <br>  Pemeriksaan bersyarat ini melakukan hal berikut: <br><br><ol><li>  Periksa apakah <code>temp</code> lebih rendah dari suhu batas GAS </li><li>  Cek apakah <code>temp</code> melebihi suhu batas SOLID </li><li>  Mengembalikan kesalahan jika salah satu dari pemeriksaan ini tidak benar </li></ol><br>  Logika ini membingungkan.  Pertama, berada dalam keadaan cair ditentukan oleh apa yang <strong>bukan</strong> zat - padat atau gas. <br><br><pre> <code class="cpp hljs">(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-comment"><span class="hljs-comment">// is liquid?</span></span></code> </pre> <br>  Kedua, kode memeriksa untuk melihat apakah air itu cair untuk mengetahui apakah kesalahan perlu dikembalikan. <br><br><pre> <code class="cpp hljs">!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-comment"><span class="hljs-comment">// Seriously?</span></span></code> </pre> <br>  Pertama kali memahami negasi ganda negara ini tidaklah mudah.  Berikut adalah penyederhanaan yang sedikit mengurangi kompleksitas ekspresi: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isLiquidWater = (temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLiquidWater) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateError()</code> </pre> <br>  Kode ini lebih mudah dipahami karena kondisi <strong>isLiquidWater</strong> <em>eksplisit</em> . <br><br>  Sekarang kami sedang mengeksplorasi teknik yang memperbaiki keadaan <strong>eksplisit</strong> sebagai cara terbaik untuk menyelesaikan masalah.  Dengan pendekatan ini, keadaan logis sistem menjadi struktur fisik perangkat lunak, yang meningkatkan kode dan menyederhanakan pemahamannya. <br><br><h3>  Notasi mesin bingkai </h3><br>  <strong>Frame Machine Notation (FMN)</strong> adalah bahasa khusus domain (Domain Specific Language, DSL) yang mendefinisikan pendekatan kategorikal, metodologis, dan sederhana untuk mendefinisikan dan mengimplementasikan berbagai jenis <em>mesin</em> .  Untuk kesederhanaan, saya akan memanggil Frame automata hanya "mesin," karena notasi ini dapat menentukan kriteria teoritis untuk berbagai jenis (mesin negara, toko automata, dan evolusi teratas automata - mesin Turing).  Untuk mengetahui tentang berbagai jenis mesin dan aplikasinya, saya sarankan untuk mempelajari halaman di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow noopener">Wikipedia</a> . <br><br>  Meskipun teori automata mungkin menarik (pernyataan yang SANGAT meragukan), dalam artikel ini kita akan fokus pada aplikasi praktis dari konsep-konsep kuat ini untuk membangun sistem dan menulis kode. <br><br>  Untuk mengatasi masalah ini, Frame memperkenalkan notasi standar yang berfungsi pada tiga level terintegrasi: <br><br><ol><li>  Teks DSL untuk mendefinisikan pengontrol Frame dengan sintaks yang elegan dan ringkas </li><li>  Satu set pola pengkodean referensi untuk menerapkan kelas berorientasi objek dalam bentuk mesin yang Frame sebut "pengontrol" </li><li>  Notasi visual di mana FMN digunakan untuk mengekspresikan operasi kompleks yang sulit untuk diwakili secara grafis - <strong>Frame Visual Notation (FVN)</strong> </li></ol><br>  Pada artikel ini, saya akan mempertimbangkan dua poin pertama: FMN dan pola referensi, dan saya akan meninggalkan diskusi FVN untuk artikel selanjutnya. <br><br>  Frame adalah notasi yang memiliki beberapa aspek penting: <br><br><ol><li>  FMN memiliki objek tingkat pertama yang terkait dengan konsep automata, yang tidak tersedia dalam bahasa berorientasi objek. </li><li>  Spesifikasi FMN mendefinisikan pola implementasi standar dalam kode semu yang menunjukkan bagaimana notasi FMN dapat diimplementasikan. </li><li>  FMN akan segera dapat mengkompilasi (bekerja dalam proses) dalam bahasa berorientasi objek apa pun </li></ol><br>  Catatan: implementasi referensi digunakan untuk menunjukkan kesetaraan absolut dari notasi FMN dan cara sederhana untuk mengimplementasikannya dalam bahasa berorientasi objek apa pun.  Anda dapat memilih metode apa pun. <br><br>  Sekarang saya akan memperkenalkan Anda ke dua objek tingkat pertama yang paling penting dalam Frame - <strong>Frame Events</strong> dan <strong>Frame Controllers</strong> . <br><br><h3>  Bingkai acara </h3><br>  FrameEvents adalah bagian integral dari kesederhanaan notasi FMN.  FrameEvent diimplementasikan sebagai struktur atau kelas yang setidaknya memiliki variabel anggota berikut: <br><br><ul><li>  id pesan </li><li>  kamus atau daftar parameter </li><li>  mengembalikan objek </li></ul><br>  Inilah pseudocode dari kelas FrameEvent: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FrameEvent</span></span></span><span class="hljs-class"> {</span></span> var _msg:String var _params:Object var _return:<span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FrameEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg:String, params:Object = null)</span></span></span><span class="hljs-function"> </span></span>{ _msg = msg _params = params } }</code> </pre> <br>  Notasi bingkai menggunakan simbol <strong>@</strong> , yang mengidentifikasi objek FrameEvent.  Setiap atribut FrameEvent yang diperlukan memiliki token khusus untuk mengaksesnya: <br><br><pre> <code class="cpp hljs">@|message| :  -    _msg @[param1] :  []      @^ :              _return</code> </pre> <br>  Seringkali kita tidak perlu menentukan dengan apa FrameEvent bekerja.  Karena sebagian besar konteks bekerja dengan hanya satu FrameEvent pada suatu waktu, notasi pasti dapat disederhanakan sehingga hanya menggunakan pemilih atribut.  Karena itu, kami dapat menyederhanakan akses: <br><br><pre> <code class="cpp hljs">|buttonClick| <span class="hljs-comment"><span class="hljs-comment">// Select for a "buttonClick" event _msg [firstName] = "Mark" // Set firstName _params property to "Mark" ^ = "YES" // Set the _return object to "YES"</span></span></code> </pre> <br>  Notasi seperti itu mungkin tampak aneh pada awalnya, tetapi segera kita akan melihat bagaimana sintaksis yang sederhana untuk peristiwa sangat menyederhanakan pemahaman kode FMN. <br><br><h3>  Pengontrol bingkai </h3><br>  Frame Controller adalah kelas berorientasi objek, yang dipesan dengan cara yang jelas untuk mengimplementasikan mesin Frame.  Jenis pengontrol diidentifikasi oleh awalan <strong>#</strong> : <br><br><pre> <code class="cpp hljs">#MyController</code> </pre> <br>  ini setara dengan pseudocode berorientasi objek berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span>}</code> </pre> <br>  Jelas kelas ini tidak terlalu berguna.  Agar ia dapat melakukan sesuatu, pengontrol memerlukan setidaknya satu keadaan untuk merespons peristiwa. <br><br>  Pengontrol disusun sedemikian rupa sehingga berisi blok berbagai jenis, yang diidentifikasi oleh tanda hubung di sekitar nama jenis blok: <br><br><pre> <code class="cpp hljs">#MyController&lt;br&gt; -block <span class="hljs-number"><span class="hljs-number">1</span></span>- -block <span class="hljs-number"><span class="hljs-number">2</span></span>- -block <span class="hljs-number"><span class="hljs-number">3</span></span>-</code> </pre> <br>  Kontroler dapat memiliki tidak lebih dari satu instance dari setiap blok, dan tipe blok hanya dapat berisi tipe subkomponen tertentu.  Dalam artikel ini, kami hanya memeriksa blok <strong>-machine</strong> , yang hanya dapat berisi status.  Negara diidentifikasi oleh token <strong>$</strong> awalan. <br><br>  Di sini kita melihat FMN untuk pengontrol yang berisi mesin dengan hanya satu keadaan: <br><br><pre> <code class="cpp hljs">#MyController <span class="hljs-comment"><span class="hljs-comment">// controller declaration -machine- // machine block $S1 // state declaration</span></span></code> </pre> <br>  Berikut ini adalah implementasi kode FMN di atas: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// -machine- var _state(e:FrameEvent) = S1 // initialize state variable // to $S1 func S1(e:FrameEvent) { // state $S1 does nothing } }</span></span></code> </pre> <br>  Implementasi blok mesin terdiri dari elemen-elemen berikut: <br><br><ol><li>  variabel <strong>_state</strong> , yang mengacu pada fungsi dari status saat ini.  Ini diinisialisasi dengan fungsi status pertama di controller. </li><li>  satu atau lebih metode negara </li></ol><br>  Metode Frame state didefinisikan sebagai fungsi dengan tanda tangan berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e:FrameEvent)</span></span></span></span>;</code> </pre> <br>  Setelah mendefinisikan dasar-dasar implementasi blok mesin ini, kita dapat melihat seberapa baik FrameEvent berinteraksi dengan mesin. <br><br><h3>  Unit antarmuka </h3><br>  Interaksi FrameEvents yang mengontrol operasi mesin adalah inti dari kesederhanaan dan kekuatan notasi Frame.  Namun, kami belum menjawab pertanyaan, dari mana FrameEvents berasal - bagaimana mereka masuk ke controller untuk mengendalikannya?  Satu opsi: klien eksternal sendiri dapat membuat dan menginisialisasi FrameEvents, dan kemudian langsung memanggil metode yang ditunjukkan oleh variabel anggota _state: <br><br><pre> <code class="cpp hljs">myController._state(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>))</code> </pre> <br>  Alternatif yang jauh lebih baik adalah membuat antarmuka umum yang membungkus panggilan langsung ke variabel anggota _state: <br><br><pre> <code class="cpp hljs">myController.sendEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>))</code> </pre> <br>  Namun, cara yang paling mudah, sesuai dengan cara biasa membuat perangkat lunak berorientasi objek, adalah menciptakan metode umum yang mengirim acara atas nama klien ke mesin internal: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ FrameEvent e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>) _state(e) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e._return } }</code> </pre> <br>  Frame mendefinisikan sintaks untuk <strong>blok antarmuka</strong> yang berisi metode yang mengubah panggilan menjadi antarmuka umum untuk FrameEvents. <br><br><pre> <code class="cpp hljs">#MyController -interface- buttonClick ...</code> </pre> <br>  Blok <code>interface</code> memiliki banyak fitur lain, tetapi contoh ini memberi kita gambaran umum tentang cara kerjanya.  Saya akan memberikan penjelasan lebih lanjut dalam artikel seri berikut. <br><br>  Sekarang mari kita terus mempelajari operasi otomat Frame. <br><br><h3>  Penangan acara </h3><br>  Meskipun kami telah menunjukkan cara mendefinisikan mobil, kami belum memiliki notasi <em>untuk melakukan</em> apa pun.  Untuk memproses peristiwa, kita perlu 1) untuk dapat memilih acara yang perlu diproses dan 2) untuk melampirkannya ke perilaku yang sedang dilakukan. <br><br>  Berikut adalah pengontrol Frame sederhana yang menyediakan infrastruktur untuk menangani acara: <br><br><pre> <code class="cpp hljs">#MyController <span class="hljs-comment"><span class="hljs-comment">// controller declaration -machine- // machine block $S1 // state declaration |e1| ^ // e1 event handler and return</span></span></code> </pre> <br>  Seperti yang dinyatakan di atas, untuk mengakses atribut <code>_msg</code> dari acara <code>_msg</code> , notasi FMN menggunakan tanda kurung dari garis vertikal: <br><br><pre> <code class="cpp hljs">|messageName|</code> </pre> <br>  FMN juga menggunakan token eksponen yang mewakili pernyataan pengembalian.  Kontroler yang ditunjukkan di atas akan diimplementasikan sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #MyController // -machine- var _state(e:FrameEvent) = S1 func S1(e:FrameEvent) { // $S1 if (e._msg == "e1") { // |e1| return // ^ } } }</span></span></code> </pre> <br>  Di sini kita melihat betapa jelas notasi FMN sesuai dengan pola implementasi yang mudah dipahami dan dikodekan. <br><br>  Setelah mengatur aspek-aspek dasar peristiwa, pengontrol, mesin, status, dan penangan peristiwa, kita dapat melanjutkan untuk memecahkan masalah nyata dengan bantuan mereka. <br><br><h3>  Mesin fokus tunggal </h3><br>  Di atas kami melihat pengontrol stateless yang sangat tidak berguna. <br><br><pre> <code class="cpp hljs">#MyController</code> </pre> <br>  Satu langkah lebih tinggi dalam rantai makanan utilitas adalah kelas dengan satu negara, yang, meskipun tidak sia-sia, hanya membosankan.  Tapi setidaknya dia setidaknya melakukan <em>sesuatu</em> . <br><br>  Pertama, mari kita lihat bagaimana kelas dengan hanya satu negara (tersirat) akan diimplementasikan: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mono</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OFF"</span></span> } }</code> </pre> <br>  Tidak ada status yang dideklarasikan atau bahkan tersirat di sini, tetapi mari kita asumsikan bahwa jika kode melakukan sesuatu, sistem dalam keadaan "Bekerja". <br><br>  Kami juga akan memperkenalkan ide penting: panggilan antarmuka akan dianggap sama dengan mengirim acara ke objek.  Oleh karena itu, kode di atas dapat dianggap sebagai metode transmisi | status |  kelas Mono, selalu dalam status $ Working. <br><br>  Situasi ini dapat divisualisasikan menggunakan tabel acara pengikatan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/81e/7e0/e1b81e7e0916b8354c4092abcc79ab40.png"></div><br>  Sekarang mari kita lihat FMN, yang menunjukkan fungsi yang sama dan cocok dengan tabel penjilidan yang sama: <br><br><pre> <code class="cpp hljs">#Mono -machine- $Working |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>)</code> </pre> <br>  Begini tampilannya: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mono</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Mono // -machine- var _state(e:FrameEvent) = Working // initialize start state func Working(e:FrameEvent) { // $Working if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } }</span></span></code> </pre> <br>  Anda dapat melihat bahwa kami juga memperkenalkan notasi baru untuk <strong>pernyataan pengembalian</strong> , yang berarti mengevaluasi ekspresi dan mengembalikan hasilnya ke antarmuka: <br><br><pre> <code class="cpp hljs">^(return_expr)</code> </pre> <br>  Operator ini setara <br><br><pre> <code class="cpp hljs">@^ = return_expr</code> </pre> <br>  atau adil <br><br><pre> <code class="cpp hljs">^ = return_expr</code> </pre> <br>  Semua operator ini setara secara fungsional dan Anda dapat menggunakan salah satu dari mereka, tetapi <code>^(return_expr)</code> terlihat paling ekspresif. <br><br><h3>  Nyalakan kompor </h3><br>  Sejauh ini kita telah melihat controller dengan 0 state dan controller dengan 1 state.  Mereka belum sangat berguna, tetapi kita sudah di ambang sesuatu yang menarik. <br><br>  Untuk memasak pasta kami, pertama-tama Anda harus menyalakan kompor.  Berikut ini adalah kelas Switch sederhana dengan variabel boolean tunggal: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch</span></span></span><span class="hljs-class"> {</span></span> boolean _isOn; <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_isOn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"ON"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OFF"</span></span>; } } }</code> </pre> <br>  Meskipun pada pandangan pertama ini tidak jelas, kode yang ditunjukkan di atas mengimplementasikan tabel pengikatan acara berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ef/5f8/ad7/2ef5f8ad7634c21066e847faf89c8228.png"></div><br>  Sebagai perbandingan, ini adalah FMN untuk perilaku yang sama: <br><br><pre> <code class="cpp hljs">#Switch1 -machine- $Off |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br>  Sekarang kita melihat bagaimana tepatnya notasi Frame cocok dengan tujuan kode kita - melampirkan peristiwa (pemanggilan metode) ke perilaku berdasarkan pada keadaan di mana controller berada.  Selain itu, struktur implementasi juga sesuai dengan tabel penjilidan: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch1 // -machine- var _state(e:FrameEvent) = Off func Off(e:FrameEvent) { // $Off if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } func On(e:FrameEvent) { // $On if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br>  Tabel ini memungkinkan Anda untuk dengan cepat memahami tujuan pengontrol di berbagai statusnya.  Struktur notasi Frame dan pola implementasi keduanya memiliki keunggulan yang sama. <br><br>  Namun, sakelar kami memiliki masalah fungsional yang nyata.  Ini diinisialisasi dalam status $ Tidak Aktif, tetapi tidak dapat beralih ke status $ Aktif!  Untuk melakukan ini, kita perlu memasukkan operator <strong>perubahan status</strong> . <br><br><h3>  Ubah status </h3><br>  <strong>Pernyataan perubahan negara adalah</strong> sebagai berikut: <br><br><pre> <code class="cpp hljs">-&gt;&gt; $NewState</code> </pre> <br>  Sekarang kita bisa menggunakan operator ini untuk beralih antara $ Off dan $ On: <br><br><pre> <code class="cpp hljs">#Switch2 -machine- $Off |toggle| -&gt;&gt; $On ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |toggle| -&gt;&gt; $Off ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br>  Dan di sini adalah tabel pengikatan acara yang sesuai: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b02/08f/688/b0208f68897eb1412f386392e8779247.png"></div><br>  Acara Baru | beralih |  sekarang memicu perubahan yang cukup siklus melalui dua negara.  Bagaimana operasi perubahan negara dapat diimplementasikan? <br><br>  Tidak ada tempat yang lebih mudah.  Berikut ini adalah implementasi Switch2: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch2 // -machine- var _state(e:FrameEvent) = Off func Off(e:FrameEvent) { if (e._msg == "toggle") { // |toggle| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } func On(e:FrameEvent) { if (e._msg == "toggle") { // |toggle| _state = Off // -&gt;&gt; $Off return // ^("OFF") } if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br>  Anda juga dapat membuat peningkatan terakhir di Switch2 sehingga tidak hanya memungkinkan Anda untuk beralih antar negara, tetapi juga secara eksplisit mengatur negara: <br><br><pre> <code class="cpp hljs">#Switch3 -machine- $Off |turnOn| -&gt;&gt; $On ^ |toggle| -&gt;&gt; $On ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |turnOff| -&gt;&gt; $Off ^ |toggle| -&gt;&gt; $Off ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br>  Berbeda dengan | toggle | event, if | turnOn |  ditransmisikan ketika Switch3 sudah aktif atau | turnOff | ketika sudah mati, pesan diabaikan dan tidak ada yang terjadi.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Peningkatan kecil ini memberi klien kemampuan untuk secara eksplisit menunjukkan keadaan di mana saklar harus: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch3 // -machine- var _state(e:FrameEvent) = Off /********************************** $Off |turnOn| -&gt;&gt; $On ^ |toggle| -&gt;&gt; $On ^ |status| ^("OFF") ***********************************/ func Off(e:FrameEvent) { if (e._msg == "turnOn") { // |turnOn| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "toggle") { // |toggle| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } /********************************** $On |turnOff| -&gt;&gt; $Off ^ |toggle| -&gt;&gt; $Off ^ |status| ^("ON") ***********************************/ func On(e:FrameEvent) { if (e._msg == "turnOff") { // |turnOff| _state = Off // -&gt;&gt; $Off return // ^ } if (e._msg == "toggle") { // |toggle| _state = Off // -&gt;&gt; $Off return // ^ } if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah terakhir dalam evolusi saklar kami menunjukkan betapa mudahnya memahami tujuan pengontrol FMN. </font><font style="vertical-align: inherit;">Kode yang relevan menunjukkan betapa mudahnya mengimplementasikan menggunakan mekanisme Frame. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menciptakan mesin Switch, kita dapat menyalakan api dan mulai memasak!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Keadaan suara </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kunci, walaupun halus, aspek automata adalah keadaan mesin saat ini adalah hasil dari situasi (misalnya, menghidupkan) atau semacam analisis data atau lingkungan. </font><font style="vertical-align: inherit;">Ketika mesin telah beralih ke kondisi yang diinginkan, itu tersirat. </font><font style="vertical-align: inherit;">bahwa situasinya tidak akan berubah tanpa sepengetahuan mobil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, anggapan ini tidak selalu benar. </font><font style="vertical-align: inherit;">Dalam beberapa situasi, verifikasi (atau "penginderaan") data diperlukan untuk menentukan keadaan logis saat ini:</font></font><br><br><ol><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kondisi awal yang dipulihkan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - saat mesin dipulihkan dari kondisi konstan</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keadaan eksternal</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - mendefinisikan "situasi aktual" yang ada di lingkungan pada saat pembuatan, pemulihan atau pengoperasian mesin</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keadaan internal yang mudah berubah</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ketika bagian dari data internal yang dikelola oleh mesin yang sedang berjalan dapat berubah di luar kendali mesin</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam semua kasus ini, data, lingkungan, atau keduanya harus "diselidiki" untuk menentukan situasi dan mengatur keadaan mesin yang sesuai. </font><font style="vertical-align: inherit;">Idealnya, logika Boolean ini dapat diimplementasikan dalam satu fungsi yang mendefinisikan keadaan logis yang benar. </font><font style="vertical-align: inherit;">Untuk mendukung pola ini, Notasi bingkai memiliki jenis fungsi khusus yang menyelidiki alam semesta dan menentukan situasi saat ini. </font><font style="vertical-align: inherit;">Fungsi-fungsi tersebut ditunjukkan oleh </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> awalan </font><font style="vertical-align: inherit;">sebelum nama metode yang mengembalikan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tautan ke status</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs">$probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam situasi kami, metode seperti itu dapat diimplementasikan sebagai berikut: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probeForState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:FrameState </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Solid <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">212</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Liquid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Gas }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang dapat kita lihat, metode hanya mengembalikan referensi ke fungsi negara yang sesuai dengan keadaan logis yang benar. </font><font style="vertical-align: inherit;">Fungsi penginderaan ini kemudian dapat digunakan untuk memasukkan kondisi yang benar:</font></font><br><br><pre> <code class="cpp hljs">-&gt;&gt; $probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mekanisme implementasi terlihat seperti ini: </font></font><br><br><pre> <code class="cpp hljs">_state = probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode penginderaan negara adalah contoh notasi Frame untuk mengelola keadaan dengan cara tertentu. </font><font style="vertical-align: inherit;">Selanjutnya, kita juga akan mempelajari notasi penting untuk mengelola FrameEvents.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warisan dan dispatcher perilaku </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warisan perilaku dan dispatcher</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah paradigma pemrograman yang kuat dan topik terakhir tentang notasi Frame dalam artikel ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penggunaan frame menggunakan pewarisan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perilaku</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , bukan pewarisan data atau atribut lainnya. </font><font style="vertical-align: inherit;">Untuk keadaan ini, FrameEvents dikirim ke negara-negara lain jika keadaan awal tidak menangani acara (atau, seperti yang akan kita lihat di artikel berikutnya, hanya ingin meneruskannya). </font><font style="vertical-align: inherit;">Rantai peristiwa ini dapat mencapai kedalaman yang diinginkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk ini, mesin dapat diimplementasikan menggunakan teknik yang disebut </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode chaining</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Notasi FMN untuk mengirim acara dari satu negara ke negara lain adalah </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operator </font></font></strong> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=&gt;</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs">$S1 =&gt; $S2</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pernyataan FMN ini dapat diimplementasikan sebagai berikut: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">S1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e:FrameEvent)</span></span></span><span class="hljs-function"> </span></span>{ S2(e) <span class="hljs-comment"><span class="hljs-comment">// $S1 =&gt; $S2 }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita melihat betapa mudahnya untuk metode rantai negara. </font><font style="vertical-align: inherit;">Mari kita terapkan teknik ini pada situasi yang agak sulit:</font></font><br><br><pre> <code class="cpp hljs">#Movement -machine- $Walking =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">3</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Running =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">6</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Crawling =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">.5</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) $AtAttention =&gt; $Motionless |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $LyingDown =&gt; $Motionless |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) $Moving |isMoving| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Motionless |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">0</span></span>) |isMoving| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kode di atas, kita melihat bahwa ada dua status dasar - $ Moving dan $ Motionless - dan lima status lainnya mewarisi fungsi penting dari mereka. </font><font style="vertical-align: inherit;">Penjilidan acara dengan jelas menunjukkan kepada kita bagaimana binding secara umum akan terlihat:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/117/95d/97c/11795d97c6a96d32824dc9ac2ddf62dc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berkat teknik yang telah kami pelajari, implementasinya akan sangat sederhana: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Movement</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Movement // -machine- /********************************** $Walking =&gt; $Moving |getSpeed| ^(3) |isStanding| ^(true) ***********************************/ func Walking(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 3 return } if (e._msg == "isStanding") { e._return = true return } Moving(e) // $Walking =&gt; $Moving } /********************************** $Running =&gt; $Moving |getSpeed| ^(6) |isStanding| ^(true) ***********************************/ func Running(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 6 return } if (e._msg == "isStanding") { e._return = true return } Moving(e) // $Running =&gt; $Moving } /********************************** $Crawling =&gt; $Moving |getSpeed| ^(.5) |isStanding| ^(false) ***********************************/ func Crawling(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = .5 return } if (e._msg == "isStanding") { e._return = false return } Moving(e) // $Crawling =&gt; $Moving } /********************************** $AtAttention =&gt; $Motionless |isStanding| ^(true) ***********************************/ func AtAttention(e:FrameEvent) { if (e._msg == "isStanding") { e._return = true return } Motionless(e) // $AtAttention =&gt; $Motionless } /********************************** $LyingDown =&gt; $Motionless |isStanding| ^(false) ***********************************/ func LyingDown(e:FrameEvent) { if (e._msg == "isStanding") { e._return = false return } Motionless(e) // $AtAttention =&gt; $Motionless } /********************************** $Moving |isMoving| ^(true) ***********************************/ func Moving(e:FrameEvent) { if (e._msg == "isMoving") { e._return = true return } } /********************************** $Motionless |getSpeed| ^(0) |isMoving| ^(false) ***********************************/ func Motionless(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 0 return } if (e._msg == "isMoving") { e._return = false return } } }</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mesin air </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita memiliki dasar-dasar pengetahuan tentang FMN, memungkinkan kita untuk memahami bagaimana menerapkan kembali kelas WaterSample dengan negara dan dengan cara yang jauh lebih cerdas. </font><font style="vertical-align: inherit;">Kami juga akan membuatnya berguna bagi fisikawan mahasiswa pascasarjana kami dan menambahkan status $ Plasma baru ke dalamnya:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afb/d16/64d/afbd1664dacfde5e4857c45e35ee33ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seperti apa bentuk implementasi FMN lengkapnya: </font></font><br><br><pre> <code class="cpp hljs">#WaterSample -machine- $Begin |create| <span class="hljs-comment"><span class="hljs-comment">// set temp to the event param value setTemp(@[temp]) // probe for temp state and change to it -&gt;&gt; $probeForState() ^ $Solid =&gt; $Default |melt| doMelt() -&gt;&gt; $Liquid ^ |sublimate| doSublimate() -&gt;&gt; $Gas ^ |getState| ^("SOLID") $Liquid =&gt; $Default |freeze| doFreeze() -&gt;&gt; $Solid ^ |vaporize| doVaporize() -&gt;&gt; $Gas ^ |getState| ^("LIQUID") $Gas =&gt; $Default |condense| doCondense() -&gt;&gt; $Liquid ^ |depose| doDepose() -&gt;&gt; $Solid ^ |ionize| doIonize() -&gt;&gt; $Plasma ^ |getState| ^("GAS") $Plasma =&gt; $Default |recombine| doRecombine() -&gt;&gt; $Gas ^ |getState| ^("PLASMA") $Default |melt| throw new InvalidStateError() |sublimate| throw new InvalidStateError() |freeze| throw new InvalidStateError() |vaporize| throw new InvalidStateError() |condense| throw InvalidStateError() |depose| throw InvalidStateError() |ionize| throw InvalidStateError() |recombine| throw InvalidStateError() |getState| throw InvalidStateError()</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat, kita memiliki status awal $ Begin, yang merespons pesan | create | dan mempertahankan nilai </font></font><code>temp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Fungsi penginderaan pertama memeriksa nilai awal </font></font><code>temp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menentukan keadaan logis, dan kemudian melakukan transisi mesin ke keadaan ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua status fisik ($ Solid, $ Liquid, $ Gas, $ Plasma) mewarisi perilaku protektif dari keadaan $ Default. Semua peristiwa yang tidak valid untuk keadaan saat ini diteruskan ke keadaan $ Default, yang melempar kesalahan InvalidStateError. Ini menunjukkan bagaimana pemrograman defensif sederhana dapat diimplementasikan menggunakan pewarisan perilaku. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan sekarang implementasinya:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaterSample</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// -machine- var _state(e:FrameEvent) = Begin /********************************** $Begin |create| // set temp to the event param value setTemp(@[temp]) // probe for temp state and change to it -&gt;&gt; $probeForState() ^ ***********************************/ func Begin(e:FrameEvent) { if (e._msg == "create") { setTemp(e["temp"]) _state = probeForState() return } } /********************************** $Solid =&gt; $Default |melt| doMelt() -&gt;&gt; $Liquid ^ |sublimate| doSublimate() -&gt;&gt; $Gas ^ |sublimate| ^("SOLID") ***********************************/ func Solid(e:FrameEvent) { if (e._msg == "melt") { doMelt() _state = Liquid return } if (e._msg == "sublimate") { doSublimate() _state = Gas return } if (e._msg == "getState") { e._return = "SOLID" return } Default(e) } /********************************** $Liquid =&gt; $Default |freeze| doFreeze() -&gt;&gt; $Solid ^ |vaporize| doVaporize() -&gt;&gt; $Gas ^ |getState| ^("LIQUID") ***********************************/ func Liquid(e:FrameEvent) { if (e._msg == "freeze") { doFreeze() _state = Solid return } if (e._msg == "vaporize") { doVaporize() _state = Gas return } if (e._msg == "getState") { e._return = "LIQUID" return } Default(e) } /********************************** $Gas =&gt; $Default |condense| doCondense() -&gt;&gt; $Liquid ^ |depose| doDepose() -&gt;&gt; $Solid ^ |ionize| doIonize() -&gt;&gt; $Plasma ^ |getState| ^("GAS") ***********************************/ func Gas(e:FrameEvent) { if (e._msg == "condense") { doCondense() _state = Liquid return } if (e._msg == "depose") { doDepose() _state = Solid return } if (e._msg == "ionize") { doIonize() _state = Plasma return } if (e._msg == "getState") { e._return = "GAS" return } Default(e) } /********************************** $Plasma =&gt; $Default |recombine| doRecombine() -&gt;&gt; $Gas ^ |getState| ^("PLASMA") ***********************************/ func Plasma(e:FrameEvent) { if (e._msg == "recombine") { doRecombine() _state = Gas return } if (e._msg == "getState") { e._return = "PLASMA" return } Default(e) } /********************************** $Default |melt| throw new InvalidStateError() |sublimate| throw new InvalidStateError() |freeze| throw new InvalidStateError() |vaporize| throw new InvalidStateError() |condense| throw InvalidStateError() |depose| throw InvalidStateError() |ionize| throw InvalidStateError() |recombine| throw InvalidStateError() |getState| throw InvalidStateError() ***********************************/ func Default(e:FrameEvent) { if (e._msg == "melt") { throw new InvalidStateError() } if (e._msg == "sublimate") { throw new InvalidStateError() } if (e._msg == "freeze") { throw new InvalidStateError() } if (e._msg == "vaporize") { throw new InvalidStateError() } if (e._msg == "condense") { throw new InvalidStateError() } if (e._msg == "depose") { throw new InvalidStateError() } if (e._msg == "ionize") { throw new InvalidStateError() } if (e._msg == "recombine") { throw new InvalidStateError() } if (e._msg == "getState") { throw new InvalidStateError() } } }</span></span></code> </pre> <br><h3>  Kesimpulan </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automata adalah konsep dasar ilmu komputer yang telah digunakan terlalu lama hanya di bidang khusus pengembangan perangkat lunak dan perangkat keras. Tugas utama Frame adalah membuat notasi untuk mendeskripsikan automata dan menetapkan pola sederhana untuk menulis kode atau "mekanisme" untuk implementasinya. Saya berharap notasi Frame akan mengubah cara programmer memandang mesin, menyediakan cara mudah untuk mempraktikkannya dalam tugas pemrograman sehari-hari dan, tentu saja, menyelamatkan mereka dari spaghetti dalam kode.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/411/041/f9d/411041f9dac0d4b6b9901a9528939495.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terminator makan pasta (foto oleh Suzuki san)</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam artikel mendatang, berdasarkan konsep yang telah kita pelajari, kita akan menciptakan kekuatan dan ekspresi yang lebih besar dari notasi FMN. </font><font style="vertical-align: inherit;">Seiring waktu, saya akan memperluas diskusi ke studi pemodelan visual, yang mencakup FMN dan memecahkan masalah perilaku yang tidak pasti dalam pendekatan modern untuk pemodelan perangkat lunak.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446330/">https://habr.com/ru/post/id446330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446320/index.html">Bagaimana pemindai 3D diizinkan meninggalkan unit kontrol jembatan skala penuh</a></li>
<li><a href="../id446322/index.html">Kriptografi di Jawa. Utilitas Keytool</a></li>
<li><a href="../id446324/index.html">Navigasi di DataGrip dengan Yandex.Navigator</a></li>
<li><a href="../id446326/index.html">Memecahkan masalah lalu lintas</a></li>
<li><a href="../id446328/index.html">Mengapa kita membutuhkan layanan penerimaan SMS dan makan apa dengan mereka</a></li>
<li><a href="../id446332/index.html">IBM System i (alias AS / 400) - Bagaimana kami melakukan tes otomatis aplikasi layar hijau</a></li>
<li><a href="../id446334/index.html">Refleksi tentang karir di bidang TI dan tips untuk pemula</a></li>
<li><a href="../id446336/index.html">Cara melarang kata sandi standar dan membuat semua orang membenci Anda</a></li>
<li><a href="../id446338/index.html">SVG 3D: Buat, Putar, dan Hidupkan</a></li>
<li><a href="../id446340/index.html">Sistem Operasi: Tiga Potongan Mudah. Bagian 1: Intro (terjemahan)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>