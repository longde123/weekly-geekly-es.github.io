<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💙 📉 👨🏼‍🚀 9 Alternativen zu einem schlechten Team (Designmuster) 📇 🌌 💄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was ist das und warum? 
 Beim Entwerfen kann ein Entwickler auf ein Problem stoßen: Kreaturen und Objekte haben möglicherweise unterschiedliche Fähigk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>9 Alternativen zu einem schlechten Team (Designmuster)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439506/"><img src="https://habrastorage.org/getpro/habr/post_images/986/ab5/0b3/986ab50b34cc8a3453a622333411cc46.png" alt="Bild"><br><br><h3>  Was ist das und warum? </h3><br>  Beim Entwerfen kann ein Entwickler auf ein Problem stoßen: Kreaturen und Objekte haben möglicherweise unterschiedliche Fähigkeiten in unterschiedlichen Kombinationen.  Frösche springen und schwimmen, Enten schwimmen und fliegen, aber nicht mit einem Gewicht, und Frösche können mit einem Ast und Enten fliegen.  Daher ist es praktisch, von der Vererbung zur Komposition zu wechseln und Fähigkeiten dynamisch hinzuzufügen.  Die Notwendigkeit, fliegende Frösche zu animieren, führte zu einer ungerechtfertigten Ablehnung der Fähigkeitsmethoden und der Übertragung ihres Codes an Teams in einer der Implementierungen.  Da ist sie: <a name="habracut"></a><br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CastSpellCommand</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Command</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> (source, target, spell) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.source = source; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target = target; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.spell = spell; } execute () { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spellAbility = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.source.getAbility(SpellCastAbility); <span class="hljs-comment"><span class="hljs-comment">//      if (!cond) return error if (spellAbility == null) { throw new Error('NoSpellCastAbility'); } this.addChildren(new PayManaCommand(this.source, this.spell.manaCost)); this.addChildren(this.spell.getCommands(this.source, this.target)); //   : healthAbility.health = Math.max( 0, resultHealth ); } } // : async onMeleeHit (meleeHitCommand) { await view.drawMeleeHit( meleeHitCommand.source, meleeHitCommand.target ); } async onDealDamage (dealDamageCommand) { await view.showDamageNumbers( dealDamageCommand.target, dealDamageCommand.damage ); }</span></span></code> </pre> <br><h3>  Was kann getan werden? </h3><br>  Betrachten Sie verschiedene Ansätze unterschiedlicher Art: <br><br><h4>  Beobachter </h4><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Executor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Observer</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Observer</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>}</code> </pre><br>  Eine klassische Lösung, die Programmierern bekannt ist.  Sie müssen es nur minimal ändern, um die von Beobachtern zurückgegebenen Werte zu überprüfen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result, listener</span></span></span><span class="hljs-function">) =&gt;</span></span> result &amp;&amp; listener(action), <span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br>  Nachteil: Beobachter müssen Ereignisse in der richtigen Reihenfolge abonnieren. <br><br>  Wenn Sie Fehler behandeln, kann der Animator auch Animationen fehlgeschlagener Aktionen anzeigen.  Sie können den vorherigen Wert an die Beobachter übergeben, konzeptionell bleibt die Lösung dieselbe.  Ob Beobachtermethoden oder Rückruffunktionen aufgerufen werden, ob anstelle der Faltung eine reguläre Schleife verwendet wird, die Details sind nicht so wichtig. <br><br><h4>  Lass es wie es ist </h4><br>  Und in der Tat.  Der derzeitige Ansatz hat sowohl Nachteile als auch Vorteile: <br><br><ol><li>  Um die Fähigkeit zum Ausführen eines Befehls zu testen, muss ein Befehl ausgeführt werden </li><li>  Argumente in wechselnder Reihenfolge, Bedingungen und Methodenpräfixe sind fest verdrahtet </li><li>  Schleifenabhängigkeiten (Befehl &lt;Zauber &lt;Befehl) </li><li>  Zusätzliche Entitäten für jede Aktion (die Methode wird durch die Methode, die Klasse und ihren Konstruktor ersetzt) </li><li>  Übermäßiges Wissen und Handeln eines einzelnen Teams: von der Spielmechanik über Synchronisationsfehler bis hin zur direkten Manipulation der Eigenschaften anderer Personen </li><li>  Die Schnittstelle ist irreführend (nicht nur Aufrufe ausführen, sondern auch Befehle über addChildren hinzufügen; was natürlich das Gegenteil bewirkt) </li><li>  Zweifelhafte Notwendigkeit und Implementierung von rekursiven Anweisungen an sich </li><li>  Die Dispatcher-Klasse führt, falls vorhanden, ihre Funktionen nicht aus </li><li>  [+] Angeblich die einzige Möglichkeit, in der Praxis zu animieren, wenn die Animationen vollständige Daten benötigen (als Hauptgrund angegeben) </li><li>  [+] Wahrscheinlich andere Gründe </li></ol><br>  Einige der Mängel können separat behandelt werden, der Rest erfordert jedoch drastischere Änderungen. <br><br><h4>  ad hoc </h4><br><ul><li>  Die Bedingungen für die Ausführung des Teams, insbesondere die Spielmechanik, müssen aus den Teams herausgenommen und separat ausgeführt werden.  Die Bedingungen können sich zur Laufzeit ändern, und das Hervorheben inaktiver Schaltflächen in Grau erfolgt in der Praxis lange vor Beginn der Animationsarbeiten, ganz zu schweigen von der Logik.  Um ein Kopieren zu vermeiden, kann es sinnvoll sein, allgemeine Bedingungen in Fähigkeitsprototypen zu speichern. </li><li>  Rückgabemethoden in Kombination mit dem vorherigen Absatz werden solche Überprüfungen nicht mehr erforderlich sein: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spellAbility = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.source.getAbility(SpellCastAbility); <span class="hljs-comment"><span class="hljs-comment">//      if (!cond) return error if (spellAbility == null) { throw new Error('NoSpellCastAbility'); }</span></span></code> </pre> <br>  Die Javascript-Engine selbst zeigt den richtigen TypeError an, wenn die Methode fälschlicherweise aufgerufen wird. </li><li>  Das Team braucht auch kein solches Wissen: <br><br><pre> <code class="javascript hljs">healthAbility.health = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max( <span class="hljs-number"><span class="hljs-number">0</span></span>, resultHealth );</code> </pre> </li><li>  Um das Problem von Argumenten zu lösen, die Orte ändern, können sie vom Objekt übergeben werden. </li><li>  Obwohl der aufrufende Code nicht für das Studium verfügbar ist, scheinen die meisten Mängel aufgrund der nicht optimalen Art des Aufrufs von Spielaktionen zuzunehmen.  Beispielsweise greifen Schaltflächenhandler auf bestimmte Entitäten zu.  Daher erscheint es ganz natürlich, sie in Handlern durch bestimmte Befehle zu ersetzen.  Wenn Sie einen Dispatcher haben, ist es viel einfacher, eine Animation nach der Aktion aufzurufen. Sie können dieselben Informationen darauf übertragen, damit keine Daten fehlen. </li></ul><br><h4>  Warteschlange </h4><br>  Um die Animation der Aktion nach Abschluss der Aktion anzuzeigen, müssen Sie sie der Warteschlange hinzufügen und ungefähr wie in Lösung 1 ausführen. <br><br><pre> <code class="javascript hljs">[ [ walkRequirements, walkAction, walkAnimation ], [ castRequirements, castAction, castAnimation ], <span class="hljs-comment"><span class="hljs-comment">// ... ]</span></span></code> </pre> <br>  Es spielt keine Rolle, welche Entitäten sich im Array befinden: Funktionen, die mit den erforderlichen Parametern gesperrt wurden, Instanzen von benutzerdefinierten Klassen oder gewöhnlichen Objekten. <br>  Der Wert einer solchen Lösung liegt in der Einfachheit und Transparenz. Es ist einfach, ein Schiebefenster zum Anzeigen der N letzten Befehle zu erstellen. <br><br>  Gut geeignet für Prototyping und Debugging. <br><br><h4>  Understudy-Klasse </h4><br>  Wir machen eine Animationsklasse für die Fähigkeit. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MovementAbility</span></span></span><span class="hljs-class"> </span></span>{ walk (...args) { <span class="hljs-comment"><span class="hljs-comment">// action } } class AnimatedMovementAbility { walk (...args) { // animation } }</span></span></code> </pre><br>  Wenn es nicht möglich ist, Änderungen an der aufrufenden Klasse vorzunehmen, erben wir davon oder dekorieren die gewünschte Methode so, dass sie die Animation aufruft.  Oder wir übertragen Animationen anstelle von Fähigkeiten, sie haben die gleiche Oberfläche. <br><br>  Gut geeignet, wenn Sie praktisch die gleichen Methoden benötigen, können diese automatisch überprüft und getestet werden. <br><br><h4>  Methodenkombinationen </h4><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AnimatedMovementAbility = combinedClass(MovementAbility, { [<span class="hljs-string"><span class="hljs-string">'*:before'</span></span>] (method, ...args) { <span class="hljs-comment"><span class="hljs-comment">// call requirements }, ['*:after'] (method, ...args) { // call animations } })</span></span></code> </pre> <br>  Es wäre eine interessante Gelegenheit mit Unterstützung für Muttersprachen. <br>  Es ist gut, es zu verwenden, wenn diese Option produktiver ist, obwohl tatsächlich ein Proxy benötigt wird. <br><br><h4>  Proxies </h4><br>  Wir wickeln Fähigkeiten in Proxys ein, fangen Methoden in Getter. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MovementAbility, {<span class="hljs-comment"><span class="hljs-comment">/* handler */</span></span>})</code> </pre> <br>  Nachteil: um ein Vielfaches langsamer als normale Anrufe, was für die Animation nicht so wichtig ist.  Auf einem Server, der Millionen von Objekten verarbeitet, ist die Verlangsamung spürbar, aber der Server benötigt keine Animation. <br><br><h4>  Versprich es mir </h4><br>  Sie können Ketten aus Promise erstellen, es gibt jedoch eine andere Option (ES2018): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> action <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> actionDispatcher.getActions()) { <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre> <br>  getActions gibt einen asynchronen Aktionsiterator zurück.  Die nächste Methode des Iterators gibt das verzögerte Versprechen der nächsten Aktion zurück.  Nachdem wir Ereignisse vom Benutzer und vom Server verarbeitet haben, rufen wir resolve () auf und erstellen ein neues Versprechen. <br><br><h4>  Besseres Team </h4><br>  Erstellen Sie Objekte wie folgt: <br><br><pre> <code class="javascript hljs">{actor, ability, method, options}</code> </pre> <br>  Der Code besteht darin, die Fähigkeitsmethode mit Parametern zu überprüfen und aufzurufen.  Die einfachste und produktivste Option. <br><br><h4>  Hinweis </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispielbefehlsquelle</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439506/">https://habr.com/ru/post/de439506/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439496/index.html">So erfolgt die Abrechnung dort: Wenn Kunde und Entwickler unterschiedliche Sprachen sprechen</a></li>
<li><a href="../de439498/index.html">Auf welcher Hardware soll ein riesiger Informationsschacht analysiert werden?</a></li>
<li><a href="../de439500/index.html">Warum sind Captchas so kompliziert geworden?</a></li>
<li><a href="../de439502/index.html">Undefiniertes Verhalten und Wahrheit nicht definiert</a></li>
<li><a href="../de439504/index.html">Benötigt Ihr Team einen Dateningenieur?</a></li>
<li><a href="../de439508/index.html">Mitap über Open Source-Entwicklung in Moskau</a></li>
<li><a href="../de439510/index.html">Hoch belastetes verteiltes Steuerungssystem eines modernen Kernkraftwerks</a></li>
<li><a href="../de439512/index.html">Das Alter der Dinosaurier oder die gesetzlich geprüfte Rückversicherung?</a></li>
<li><a href="../de439514/index.html">Tarantool-Replikation: Konfiguration und Verwendung</a></li>
<li><a href="../de439516/index.html">00110001 00110100 00101110 00110000 00110010</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>