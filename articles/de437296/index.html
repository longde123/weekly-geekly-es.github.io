<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ùî üë©üèæ‚Äçü§ù‚Äçüë®üèø ü§î Warum wenden die Menschen keine formalen Methoden an? üë®üèø‚Äçüè´ üë®üèº üìò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beim Software Engineering Stack Exchange sah ich die Frage : "Was verhindert die weit verbreitete Einf√ºhrung formaler Methoden?" Die Frage wurde als v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum wenden die Menschen keine formalen Methoden an?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437296/"> Beim Software Engineering Stack Exchange sah ich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frage</a> : "Was verhindert die weit verbreitete Einf√ºhrung formaler Methoden?"  Die Frage wurde als voreingenommen geschlossen und die meisten Antworten waren Kommentare wie "Zu teuer !!!"  oder "Eine Seite ist kein Flugzeug !!!"  In gewisser Weise ist dies wahr, aber es erkl√§rt nicht viel.  Ich habe diesen Artikel geschrieben, um ein umfassenderes historisches Bild der formalen Methoden (FM) zu vermitteln, warum sie nicht tats√§chlich verwendet werden und was wir tun, um die Situation zu korrigieren. <br><br>  Bevor Sie beginnen, m√ºssen Sie einige Bedingungen formulieren.  Tats√§chlich gibt es nicht viele formale Methoden: nur ein <abbr title="TLA + ist eine der beliebtesten Spezifikationssprachen, und alle TLA + -Experten passen in einen gro√üen Schulbus">paar winzige Gruppen</abbr> .  Dies bedeutet, dass verschiedene Gruppen die Begriffe unterschiedlich verwenden.  Grunds√§tzlich gibt es zwei Gruppen formaler Methoden: Die <b>formale Spezifikation</b> untersucht das Schreiben pr√§ziser, eindeutiger Spezifikationen und die <b>formale Verifikation</b> untersucht die Beweismethoden.  Dies umfasst sowohl Code- als auch abstrakte Systeme.  Wir verwenden nicht nur unterschiedliche Begriffe f√ºr Code und Systeme, sondern verwenden h√§ufig unterschiedliche Tools, um sie zu √ºberpr√ºfen.  Um die Sache noch verwirrender zu machen: Wenn jemand sagt, dass er eine formale Spezifikation erstellt, bedeutet dies <i>normalerweise</i> eine Entwurfs√ºberpr√ºfung.  Und wenn jemand sagt, dass er eine formale √úberpr√ºfung durchf√ºhrt, bezieht sich dies <i>normalerweise</i> auf die Code√ºberpr√ºfung. <br><a name="habracut"></a><br>  Aus Gr√ºnden der √úbersichtlichkeit teilen wir die <b>Codeverifizierungs√ºberpr√ºfung</b> (CV) und die <b>Entwurfs√ºberpr√ºfung</b> (DV) auf und unterteilen die Spezifikationen auf √§hnliche Weise in CS und DS.  Solche Begriffe werden in der breiten FM-Community nicht h√§ufig verwendet.  Beginnen wir mit CS und CV und fahren dann mit DS und DV fort. <br><br>  Dar√ºber hinaus ist eine <b>teilweise √úberpr√ºfung</b> m√∂glich, bei der nur eine Teilmenge der Spezifikation √ºberpr√ºft wird, oder eine <b>vollst√§ndige √úberpr√ºfung</b> .  Dies kann der Unterschied zwischen den Beweisen der Behauptungen sein, dass das System niemals abst√ºrzt und das falsche Passwort nicht akzeptiert, oder dass das System niemals abst√ºrzt und das Konto sperrt, wenn Sie dreimal das falsche Passwort eingeben.  Grunds√§tzlich gehen wir davon aus, dass wir eine vollst√§ndige √úberpr√ºfung durchf√ºhren. <br><br>  Sie sollten auch die Art der Software kl√§ren, die wir formalisieren.  Die meisten Menschen identifizieren implizit <b>hochzuverl√§ssige</b> Programme wie medizinische Ger√§te und Flugzeuge.  Die Menschen gehen davon aus, dass formale Methoden f√ºr sie weit verbreitet sind, f√ºr den Rest jedoch nicht.  Dies ist zu <i>optimistisch</i> : Die meisten hochzuverl√§ssigen Programme verwenden keine formalen Methoden.  Stattdessen konzentrieren wir uns auf ‚Äûnormale‚Äú Software. <br><br>  Zum Schluss der Haftungsausschluss: Ich bin kein professioneller Historiker, und obwohl ich versucht habe, die Informationen sorgf√§ltig zu √ºberpr√ºfen, kann der Artikel Fehler enthalten.  Dar√ºber hinaus bin ich auf formale Spezifikationen (DS und DV) spezialisiert, sodass bei Fehlern √ºber die Code√ºberpr√ºfung mehr Fehler auftreten k√∂nnen.  Wenn Sie sehen, schreiben Sie mir, ich werde das Problem beheben (und noch etwas: Ich verdiene Geld mit Seminaren zu TLA + und Alloy, daher bin ich sehr voreingenommen gegen√ºber diesen Sprachen; ich versuche so objektiv wie m√∂glich zu sein, aber Sie verstehen: Voreingenommenheit ist Voreingenommenheit). <br><br><h1>  Formale Programmierung </h1><br><h2>  Spezifikation erhalten </h2><br>  Bevor Sie die Richtigkeit des Codes nachweisen k√∂nnen, m√ºssen Sie den Standard der Wahrheit ermitteln.  Dies bedeutet eine <b>Spezifikation dessen,</b> was der Code tun soll.  Wir m√ºssen sicher sein, dass das Ergebnis der Spezifikation entspricht.  Es reicht nicht aus zu sagen, dass die Liste "sortiert" ist: Wir wissen nicht, was wir sortieren, welche Kriterien wir verwenden und was wir unter "Sortieren" verstehen.  Stattdessen k√∂nnen wir sagen: "Die Liste der ganzen Zahlen <code>l</code> <i>in aufsteigender Reihenfolge</i> f√ºr zwei beliebige Indizes i und j <i>sortiert.</i> Wenn <code>i &lt; j</code> , dann ist <code>l[i] &lt;= l[j]</code> ." <br><br>  Die Codespezifikationen sind in drei Haupttypen unterteilt: <br><br><ol><li>  Die erste besteht darin, codeunabh√§ngige Anweisungen zu schreiben.  Wir schreiben unsere Sortierfunktion und schreiben in eine separate Datei den Satz ‚ÄûDies gibt sortierte Listen zur√ºck‚Äú.  Dies ist die √§lteste Form der Spezifikation, aber Isabelle und ACL2 funktionieren immer noch auf diese Weise (ML wurde speziell erfunden, um solche Spezifikationen zu schreiben). <br></li><li>  Die zweite implementiert Spezifikationen im Code in Form von Vor- und Nachbedingungen, Anweisungen und Invarianten.  Sie k√∂nnen der Funktion "Der R√ºckgabewert ist eine sortierte Liste" eine Nachbedingung hinzuf√ºgen.  Anspruchsbasierte Spezifikationen wurden urspr√ºnglich als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hoars Logik</a> formalisiert.  Sie erschienen zum ersten Mal in der Programmiersprache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Euclid</a> in den fr√ºhen 1970er Jahren (es ist nicht klar, wer sie zuerst verwendet hat: Euclid oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SPV</a> , aber soweit ich wei√ü, wurde Euclid zuvor der √ñffentlichkeit vorgestellt).  Dieser Stil wird auch als <b>Vertragsprogrammierung bezeichnet</b> - die beliebteste Form der √úberpr√ºfung in der modernen Industrie (hier werden Vertr√§ge als Code-Spezifikationen verwendet). <br></li><li>  Schlie√ülich gibt es Typsysteme.  Durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Curry-Howard-Korrespondenz kann</a> jeder mathematische Satz oder Beweis als abh√§ngiger Typ codiert werden.  Wir definieren den Typ der sortierten Listen und deklarieren den Typ <code>[Int] -&gt; Sorted [Int]</code> f√ºr die Funktion. </li></ol><br>  Auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Let's Prove Leftpad k√∂nnen</a> Sie sehen, wie es aussieht.  HOL4 und Isabelle sind gute Beispiele f√ºr die Spezifikationen des ‚Äûunabh√§ngigen Theorems‚Äú, SPARK und Dafny sind die Spezifikationen der ‚Äûverschachtelten Anweisung‚Äú und Coq und Agda sind der ‚Äûabh√§ngige Typ‚Äú. <br><br>  Wenn Sie genau hinschauen, werden diese drei Formen der Codespezifikation mit den drei Hauptbereichen der automatischen Validierung verglichen: Tests, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vertr√§ge</a> und Typen.  Dies ist kein Zufall.  Korrektheit ist ein weites Feld, und die formale √úberpr√ºfung ist eines ihrer Extreme.  Wenn die Genauigkeit (und der Aufwand) der √úberpr√ºfung abnimmt, erhalten wir einfachere und engere √úberpr√ºfungen, unabh√§ngig davon, ob der zu untersuchende Zustandsraum begrenzt, schw√§chere Typen verwendet oder zur Laufzeit erzwungen werden.  Dann wird jedes Mittel zur vollst√§ndigen Spezifikation zu einem Mittel zur teilweisen Spezifikation und umgekehrt: Viele betrachten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cleanroom als eine</a> Technik der formalen Verifikation, bei der eine Code√ºberpr√ºfung weit √ºber die menschlichen F√§higkeiten hinausgeht. <br><br><h3>  Welche Angaben sind richtig? </h3><br>  Durch die √úberpr√ºfung wird √ºberpr√ºft, ob der Code der Spezifikation entspricht.  Es stellt sich die Frage: Woher wissen wir, dass wir die richtige Spezifikation haben?  Das Finden der richtigen Spezifikation ist eines der gr√∂√üten Probleme bei formalen Methoden.  Dies ist auch eine der wichtigsten Einw√§nde gegen sie.  Aber Skeptiker meinen hier nicht <i>genau</i> das <i>,</i> was formale Spezialisten im Sinn haben. <br><br>  Wenn Au√üenstehende fragen: "Wie erhalten Sie die richtigen Spezifikationen?", Denken sie <i>normalerweise</i> an die <b>Validierung</b> , <b>dh an</b> Spezifikationen, die nicht den Anforderungen des Kunden entsprechen.  Wenn Sie offiziell beweisen, dass Ihr Code die Liste sortiert und der Kunde Uber tats√§chlich f√ºr Suppen (tm) m√∂chte, haben Sie nur eine Menge Zeit aufgewendet.  Nur schnelle Iterationen und kurze R√ºckkopplungsschleifen k√∂nnen Ihre Anforderungen best√§tigen. <br><br>  Es ist wahr, dass die Code√ºberpr√ºfung sie nicht validiert.  Bei diesem Argument gibt es jedoch zwei Probleme.  Das erste ist, dass die Phase der Anwendung formaler Methoden einfach verschoben wird, aber nicht vollst√§ndig verschwindet.  Nach all diesen schnellen Iterationen haben Sie wahrscheinlich bereits eine Vorstellung davon, was der Client will.  Und <i>dann</i> beginnen <i>Sie</i> mit der Code√ºberpr√ºfung.  Zweitens k√∂nnen wir, obwohl wir nicht genau wissen, was der Kunde will, davon ausgehen, was er definitiv <i>nicht</i> will.  Zum Beispiel, um versehentlich Software zum Absturz zu bringen.  Sie brauchen keine Sicherheitsl√ºcken.  Alle sind damit einverstanden: Am Ende sagt niemand, dass Sie Unit-Tests w√§hrend der Iterationen √ºberspringen m√ºssen.  Stellen Sie also zumindest sicher, dass Ihr Versionskontrollsystem keine zuf√§lligen Benutzerdaten l√∂scht (Hinweis: Denken Sie nicht, dass ich verbittert bin oder so etwas). <br><br>  Das Problem beim Finden der richtigen Spezifikation ist grundlegender: <i>Wir wissen oft nicht, was wir dort schreiben sollen</i> .  Wir denken √ºber unsere Anforderungen in menschlichen, nicht mathematischen Begriffen nach.  Wenn ich sage: ‚ÄûDas Programm sollte B√§ume von V√∂geln unterscheiden‚Äú, worum geht es dann?  Ich kann es einer Person erkl√§ren, indem ich ein paar Bilder von B√§umen und V√∂geln zeige, aber dies sind nur konkrete Beispiele, keine Beschreibung der <i>Idee</i> .  In der Tat ist es notwendig, menschliche Konzepte zu formalisieren, um dies in eine formale Spezifikation umzusetzen, und dies ist ein ernstes Problem. <br><br>  Versteh mich nicht falsch.  Hier k√∂nnen die relevanten Spezifikationen definiert werden, und Experten tun dies st√§ndig.  Das Schreiben der entsprechenden Spezifikationen ist jedoch eine F√§higkeit, die entwickelt werden muss, sowie Programmierkenntnisse.  Aus diesem Grund erkl√§ren sich viele der j√ºngsten Erfolge der Code√ºberpr√ºfung durch eine klare Zuordnung dessen, was wir wollen, zu dem, was wir ausdr√ºcken k√∂nnen.  Beispielsweise ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CompCert</a> ein formal verifizierter C-Compiler. Die Spezifikation daf√ºr lautet: ‚ÄûKompilierungsfehler vermeiden‚Äú. <br><br>  Das alles hat aber nichts mit Verifikation zu tun.  Wenn Sie eine Spezifikation haben, m√ºssen Sie noch nachweisen, dass der Code mit dieser √ºbereinstimmt. <br><br><h3>  Spezifikationsnachweis </h3><br>  Das erste Tool zur Code√ºberpr√ºfung ist die Dijkstra-Methode ‚Äû√úberlegen Sie, warum dies wahr ist‚Äú, die haupts√§chlich f√ºr ALGOL gilt.  Zum Beispiel kann ich die Richtigkeit der Sortierung mit der Einf√ºgemethode wie folgt ‚Äûbeweisen‚Äú: <br><br><ol><li>  <i>Die grundlegende Option</i> : Wenn Sie der leeren Liste ein Element hinzuf√ºgen, ist dies das einzige Element, sodass es sortiert wird. <br></li><li>  Wenn wir eine sortierte Liste mit k Elementen haben und ein Element hinzuf√ºgen, f√ºgen wir das Element so ein, dass es nach allen kleineren Zahlen und vor allen gr√∂√üeren Zahlen steht.  Dies bedeutet, dass die Liste noch sortiert ist. <br></li><li>  Durch Induktion sortiert die Einf√ºgesortierung die gesamte Liste. </li></ol><br>  In Wirklichkeit wird der Beweis nat√ºrlich strenger aussehen, aber dies ist eine allgemeine Idee.  Dijkstra und andere verwendeten diesen Stil, um die Richtigkeit vieler Algorithmen zu beweisen, einschlie√ülich vieler Grundlagen der Parallelit√§t.  Dies ist auch der Stil, mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Knuths Worte verbunden</a> sind: ‚ÄûVorsicht vor Fehlern in diesem Code;  Ich habe nur bewiesen, dass es richtig ist, aber ich habe es nicht gestartet. "  Sie k√∂nnen einen mathematischen Beweis leicht ruinieren, so dass niemand es bemerkt.  Nach einigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sch√§tzungen enthalten</a> ungef√§hr 20% der ver√∂ffentlichten mathematischen Beweise Fehler.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20140630071239/">Peter Guttmann</a> hat einen ausgezeichneten Aufsatz √ºber die Gesundheit eines l√§cherlichen Programms, in dem Tonnen von "getestetem" Code sofort fallen, wenn Sie sie ausf√ºhren. <br><br>  Gleichzeitig untersuchten wir M√∂glichkeiten, um mathematische Theoreme automatisch zu beweisen.  Das erste <b>Programm, das die Theoreme beweist,</b> wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1967 ver√∂ffentlicht</a> .  In den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºhen 1970er Jahren wurden</a> solche Programme zum Testen von Pascal-Code verwendet, und Mitte des Jahrzehnts erschienen spezielle formale Sprachen.  Der Programmierer formuliert einige Eigenschaften des Codes und erstellt dann einen √ºberpr√ºfbaren Beweis daf√ºr, dass der Code diese Eigenschaften aufweist.  Die ersten Programme zum Beweisen von Theoremen halfen den Menschen lediglich, die Beweise zu verifizieren, w√§hrend ausgefeiltere Werkzeuge Teile des Theorems unabh√§ngig voneinander beweisen konnten. <br><br>  Was zu folgendem Problem f√ºhrt. <br><br><h3>  Beweise sind schwer zu bekommen </h3><br>  Beweise sind schwierig und es ist ein sehr b√∂ser Job.  Es ist schwer, die Programmierung zu beenden und in den Zirkus zu gehen.  √úberraschenderweise sind formale Code-Beweise oft strenger als die von den meisten Mathematikern geschriebenen Beweise!  Mathematik ist eine sehr kreative Aktivit√§t, bei der die Antwort auf den Satz nur g√ºltig ist, wenn Sie sie zeigen.  Kreativit√§t passt schlecht zu Formalismus und Computern. <br><br>  Nehmen Sie das gleiche Beispiel f√ºr die Sortierung von Einf√ºgungen, bei dem wir die Induktion angewendet haben.  Jeder Mathematiker wird sofort verstehen, was Induktion ist, wie sie im Allgemeinen funktioniert und wie sie in diesem Fall funktioniert.  Aber im Programm zum Beweis der Theoreme muss alles streng formalisiert werden.  Gleiches gilt f√ºr Beweise durch Widerspruch, Beweise durch Gegenposition usw. Dar√ºber hinaus m√ºssen alle Annahmen formalisiert werden, auch diejenigen, bei denen sich die meisten Mathematiker nicht um Beweise k√ºmmern.  Zum Beispiel ist <code>a + (b + c) = (a + b) + c</code> .  Das Programm zur √úberpr√ºfung von Theoremen a priori wei√ü nicht, dass dies wahr ist.  Sie m√ºssen es entweder beweisen (schwer) oder es gem√§√ü dem assoziativen Additionsgesetz (gef√§hrlich) als wahr erkl√§ren oder eine Bibliothek von Theoremen von jemandem kaufen, der es bereits beweisen konnte (teuer).  Fr√ºhe Theorempr√ºfprogramme konkurrierten um die Anzahl der eingebauten Proof-Taktiken und der zugeh√∂rigen Theorembibliotheken.  Eines der ersten weit verbreiteten SPADE-Programme pr√§sentierte die komplette Arithmetikbibliothek als Hauptvorteil. <br><br>  Als n√§chstes m√ºssen Sie den Beweis selbst erhalten.  Sie k√∂nnen dies dem Programm anvertrauen oder selbst schreiben.  Normalerweise ist die automatische Definition von Beweismitteln nicht entscheidbar.  F√ºr extrem enge F√§lle wie Aussagenlogik oder Typpr√ºfung HM ist es ‚Äûnur‚Äú NP-vollst√§ndig.  Tats√§chlich schreiben wir selbst die meisten Beweise, und der Computer √ºberpr√ºft ihre Richtigkeit.  Dies bedeutet, dass Sie gut wissen m√ºssen: <br><br><ul><li>  Mathe <br></li><li>  Informatik; <br></li><li>  der Bereich, in dem Sie arbeiten: Compiler, Hardware usw.; <br></li><li>  die Nuancen Ihres Programms und Ihrer Spezialisierung; <br></li><li>  die Nuancen des Programms, um die von Ihnen verwendeten Theoreme zu beweisen, was an sich eine ganze Spezialit√§t ist. </li></ul><br>  Schlimmer noch, computer-spezifische Sticks in R√§dern.  Erinnern Sie sich, ich sagte, es sei gef√§hrlich, ein assoziatives Additionsgesetz anzunehmen?  Einige Sprachen erf√ºllen diese nicht.  Zum Beispiel in C ++ <code>INT_MAX. ((-1) + INT_MAX) + 1</code>  <code>INT_MAX. ((-1) + INT_MAX) + 1</code> ist <code>INT_MAX. -1 + (INT_MAX + 1)</code>  <code>INT_MAX. -1 + (INT_MAX + 1)</code> , was nicht nachweisbar ist.  Unter der Annahme einer assoziativen Hinzuf√ºgung in C ++ ist Ihr Beweis falsch und der Code wird besch√§digt.  Sie m√ºssen diese Aussage entweder vermeiden oder nachweisen, dass f√ºr Ihr bestimmtes Fragment niemals ein √úberlauf auftritt. <br><br>  Sie k√∂nnen sagen, dass eine unbestimmte Addition ein Fehler ist, aber Sie m√ºssen eine Sprache mit nicht verwandten Ganzzahlen verwenden.  Die meisten Sprachen haben jedoch spezifische Merkmale, die die Evidenz beeintr√§chtigen.  Nehmen Sie den folgenden Code: <br><br><pre> <code class="plaintext hljs">a = true; b = false; f(a); assert a;</code> </pre> <br>  Ist das immer so?  Keine Tatsache.  Vielleicht √§ndert <code>f</code> <code>a</code> .  Vielleicht √§ndert es den parallelen Fluss.  Vielleicht wurde <code>b</code> ein Alias <code>a</code> zugewiesen, so dass <code>a</code> √Ñnderung auch a √§ndert (Hinweis: Aliase behindern das Schreiben von Beweisen so sehr, dass John C. Reynolds eine v√∂llig neue <b>Trennungslogik</b> erstellen musste, um dieses Problem zu l√∂sen).  Wenn so etwas in Ihrer Sprache m√∂glich ist, sollten Sie klar beweisen, dass dies hier nicht der Fall ist.  Sauberer Code hilft hier, in einem anderen Fall kann er den Beweis zerst√∂ren, da Sie gezwungen sind, Rekursionen und Funktionen h√∂herer Ordnung zu verwenden.  Beide sind √ºbrigens die Basis f√ºr das Schreiben guter Funktionsprogramme.  Was f√ºr die Programmierung gut ist, ist f√ºr den Beweis schlecht!  (Hinweis: In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser Vorlesung</a> listete Edmund Clark einige Eigenschaften auf, die schwer zu √ºberpr√ºfen sind: ‚ÄûGleitkommawerte, Zeichenfolgen, benutzerdefinierte Typen, Prozeduren, Parallelit√§t, universelle Vorlagen, Speicher, Bibliotheken ...‚Äú). <br><br>  Formale Verifizierer haben ein Dilemma: Je ausdrucksvoller die Sprache ist, desto schwieriger ist es, etwas zu beweisen.  Aber je weniger ausdrucksstark die Sprache ist, desto schwieriger ist es, darauf zu schreiben.  Die ersten formalen Arbeitssprachen waren sehr begrenzte Teilmengen ausdrucksst√§rkerer Sprachen: ACL2 war eine Teilmenge von Lisp, Euklid war eine Teilmenge von Pascal usw. Und nichts von dem, was wir bisher besprochen haben, beweist tats√§chlich echte Programme, dies sind nur Versuche, sich zu n√§hern Beweise zu schreiben. <br><br>  Die Beweise sind schwierig.  Aber es wird einfacher.  Forscher auf diesem Gebiet f√ºgen neue Heuristiken, Theorembibliotheken, vorab getestete Komponenten usw. hinzu. Der technische Fortschritt hilft auch: Je schneller Computer, desto schneller die Suche. <br><br><h3>  SMT Revolution </h3><br>  Eine der Neuerungen Mitte der 2000er Jahre war die Einbeziehung von SMT-L√∂sern in Programme zum Nachweis von Theoremen.  Im Allgemeinen kann ein SMT-L√∂ser (einige) mathematische Theoreme in Probleme bei der Einhaltung von Beschr√§nkungen umwandeln.  Dies verwandelt eine kreative Aufgabe in eine rechnerische.  M√∂glicherweise m√ºssen Sie noch Zwischenprobleme (Lemmas) als Schritte im Theorem bereitstellen, aber dies ist besser, als alles selbst zu beweisen.  Die ersten SMT-L√∂ser erschienen um 2004, zun√§chst als akademische Projekte.  Einige Jahre sp√§ter ver√∂ffentlichte Microsoft Research den Z3, einen handels√ºblichen SMT-Solver.  Der gro√üe Vorteil des Z3 war, dass es viel bequemer zu bedienen war als andere SMTs, die offen gesagt fast nichts sagten.  Microsoft Research hat es intern verwendet, um die Eigenschaften des Windows-Kernels zu beweisen, sodass sie nicht auf minimale UX beschr√§nkt waren. <br><br>  SMT traf die FM-Community unter dem Atem, weil es pl√∂tzlich viele einfache Beweise trivial machte und es ihr erm√∂glichte, sich sehr komplexen Problemen zu n√§hern.  So konnten die Menschen in ausdrucksst√§rkeren Sprachen arbeiten, da nun die Probleme der Ausdrucksaussagen gel√∂st wurden.  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IronFleet-</a> Projekt sind unglaubliche Fortschritte zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verzeichnen</a> : Mit den besten SMT-L√∂sern und einer erweiterten Verifizierungssprache konnte Microsoft in nur 3,7 Mannjahren 5.000 Zeilen bew√§hrten Dafny-Codes schreiben!  Dies ist ein unglaublich schnelles Tempo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bis zu</a> <i>vier ganze Zeilen pro Tag</i> (Hinweis: Der vorherige Datensatz geh√∂rte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seL4</a> , dessen Entwickler <i>zwei Zeilen pro Tag in C geschrieben haben.</i> <br><br>  Die Beweise sind schwierig. <br><br><h3>  Warum wird das ben√∂tigt? </h3><br>  Es ist Zeit, zur√ºckzutreten und zu fragen: "Was ist der Sinn?"  Wir versuchen zu beweisen, dass ein Programm einer bestimmten Spezifikation entspricht.  Korrektheit ist ein Bereich.  Die √úberpr√ºfung besteht aus zwei Teilen: Wie objektiv ‚Äûkorrekt‚Äú Ihr Programm ist und wie sorgf√§ltig Sie die Richtigkeit √ºberpr√ºft haben.  Je mehr √ºberpr√ºft wird, desto besser, aber die √úberpr√ºfung ist die Zeit und das Geld wert.  Wenn wir verschiedene Einschr√§nkungen haben (Leistung, Time-to-Market, Kosten usw.), ist eine vollst√§ndige Validierung nicht unbedingt die beste Option.  Dann stellt sich die Frage, was der Mindestscheck ist, den wir brauchen und was er kostet.  In den meisten F√§llen reichen beispielsweise 90% oder 95% oder 99% Korrektheit f√ºr Sie aus.  Vielleicht sollten Sie Zeit damit verbringen, die Benutzeroberfl√§che zu verbessern, anstatt die verbleibenden 1% zu √ºberpr√ºfen? <br><br>  Dann die Frage: "Ist ein Scheck von 90/95/99% viel billiger als 100%?"  Die Antwort lautet ja.  Es ist sehr angenehm zu sagen, dass die Codebasis, die wir gut getestet und getippt haben, bis auf einige Korrekturen in der Produktion <i>grunds√§tzlich</i> korrekt ist und wir sogar mehr als vier Codezeilen pro Tag schreiben.  Tats√§chlich h√§tte die √ºberwiegende Mehrheit der Fehlfunktionen in verteilten Systemen durch etwas umfassendere Tests verhindert werden k√∂nnen.  Und es ist nur eine Erweiterung der Tests, ganz zu schweigen von Fuzzing, eigenschaftsbasierten Tests oder Modelltests.  Mit diesen einfachen Tricks k√∂nnen Sie ein wirklich herausragendes Ergebnis erzielen, ohne einen vollst√§ndigen Beweis erhalten zu m√ºssen. <br><br>  Was ist, wenn das Tippen und Testen keine ausreichende √úberpr√ºfung bietet?  Es ist immer noch viel einfacher, von 90% auf 99% zu wechseln als von 99% auf 100%.  Wie bereits erw√§hnt, ist Cleanroom eine Entwicklerpraxis, die umfassende Dokumentation, gr√ºndliche Flussanalyse und umfassende Code√ºberpr√ºfungen umfasst.  Keine Beweise, keine formelle √úberpr√ºfung, nicht einmal Unit-Tests.  Ein ordnungsgem√§√ü organisierter Reinraum reduziert die Fehlerdichte jedoch auf weniger als 1 Fehler pro 1000 Codezeilen in der Produktion (Hinweis: Zahlen aus der Stavley-Studie in <i>Richtung Null-</i> Fehler <i>-Programmierung</i> &gt;, aber seien Sie immer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">skeptisch und √ºberpr√ºfen Sie die Quelle</a> ).  Das Programmieren von Cleanroom verlangsamt das Entwicklungstempo nicht und geht mit Sicherheit schneller als 4 Zeilen pro Tag.  Und Cleanroom selbst ist nur eine von vielen hochzuverl√§ssigen Softwareentwicklungsmethoden, die zwischen der √ºblichen Entwicklung und der Code√ºberpr√ºfung liegen.  Sie ben√∂tigen keine vollst√§ndige √úberpr√ºfung, um eine gute oder fast perfekte Software zu schreiben.  Es gibt Zeiten, in denen es gebraucht wird, aber f√ºr die meisten Branchen ist es eine Geldverschwendung. <br><br>  Dies bedeutet jedoch nicht, dass formale Methoden im Allgemeinen unwirtschaftlich sind.  Viele der oben genannten hochzuverl√§ssigen Methoden basieren auf dem Schreiben von Codespezifikationen, die Sie formal nicht nachweisen.  In Bezug auf die √úberpr√ºfung gibt es zwei g√§ngige M√∂glichkeiten, von denen die Branche profitiert.  Zuerst die Entwurfs√ºberpr√ºfung anstelle des Codes, auf die wir sp√§ter noch eingehen werden.  Zweitens eine teilweise √úberpr√ºfung des Codes, die wir jetzt betrachten werden. <br><br><h2>  Teilweise Code√ºberpr√ºfung </h2><br>  F√ºr allt√§gliche Aufgaben ist es zu teuer, eine vollst√§ndige √úberpr√ºfung durchzuf√ºhren.  Wie w√§re es teilweise?  Schlie√ülich k√∂nnen Sie vom Nachweis einiger Eigenschaften einzelner Codefragmente profitieren.  Anstatt zu beweisen, dass meine Funktion Zahlen immer richtig sortiert, kann ich zumindest beweisen, dass sie nicht f√ºr immer wiederholt wird und niemals au√üerhalb des Bereichs liegt.  Dies sind auch sehr n√ºtzliche Informationen.  Selbst der einfachste Beweis f√ºr C-Programme ist eine gro√üartige M√∂glichkeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, einen gro√üen Teil des undefinierten Verhaltens zu eliminieren</a> . <br><br>  Das Problem ist die <i>Zug√§nglichkeit</i> .       ,     .             ,          ,    .             ,   C  Java.      . , SPARK    Ada,        SPARK       Ada.      . <br><br>         .      ‚Äî  :    ,  <i>tail</i>   tail,    ,    <code>[a] -&gt; [a]</code> .      Rust      Pony     .     SPARK  Frama-C ,    <i></i>  .         ,      :     ,    . ,    ,  Rust  Haskell,      . <br><br><h1>   </h1><br>         .        ,       ,  .    ,    <b> </b> :  - ,    ,  ,  ,      . <br><br>    ,     ,  .        - ,  -   .     , ,   ,     ,     ,             .        ,      , ,  ,    <abbr title="       ,   ,  &nbsp;‚Äî ,    ">  </abbr> .           ,    .      ,         ,    . <br><br>  ,      ¬´  ,             ¬ª.   ,   ,   .    ?     -  ?         ?         ¬´    ¬ª     : <br><br><ul><li>      , <i>   </i> ?      <i></i>  ? <br></li><li>   ?  ?      ?      ? <br></li><li>          ?      ,    ?    ¬´¬ª     ,     ? <br></li><li>  ,       ?   ? <br></li><li>     ?    ¬´  ¬ª      ? <br></li><li>   GDPR? <br></li><li>      . </li></ul><br>          .      ,    ,           ,      .      ,    ,      ,  . <br><br>  ,        ,   <b> </b>   .       ,    ,         (:         <b></b> ).         (DL),      ( ,    ;    ¬´ ¬ª,          ). <br><br> ,   DL  VDM   1972 .          .  DL     ,      (CVL).  ,   DL    ,  CVL ‚Äî   .        ,  DL     .  ,      DL: <br><br><table><tbody><tr><th>  Sprache </th><th>   </th><th>  </th></tr><tr><td>  Z. </td><td> - </td><td>   </td></tr><tr><td> Promela </td><td>  Beitr√§ge </td><td> CSP </td></tr><tr><td> SDL </td><td>  </td><td> - </td></tr><tr><td>    </td><td>  </td><td>  </td></tr><tr><td>    </td><td>  </td><td>  </td></tr></tbody></table><br>  DL      ,            .  ,   .   ,  DL       .      Praxis ( Altran),   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">¬´--¬ª</a> ‚Äî  Z-   SPARK ‚Äî     .     ,           . <br><br>     Alloy   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>  Chord,     -. AWS   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">35-  </a> ,   TLA+.   ,     ,        . <br><br>          -    .       ,        ,   .      ,    ,        .      .    -  DL,      ,     ,   . <br><br>  ,       ,    ‚Äî   . <br><br><h2>   </h2><br>      ,    ,  .  ,      :   <b>  </b> (model checker).   ,   ,        ,      .    ,     (:        ,  JMBC,         ,   ). <br><br>     . -,    ,      . -,   <i></i>  ,     . -,   ,     .  , <i></i>   ,       35 .    . <br><br>    . -,     .  ,     <b></b> (unbounded) ,      . ,     :        .        ‚Ä¶ ,   ,      .            ,       ,    . <br><br>    ‚Äî <b>   </b> (state-space explosion). ,     ,        ,       .        ,   <code>(4*3)! / (4!)^3 = 34 650</code>   ().         ,       4 300 000.     ,      .    ,       !     ,      .         ,     ,    . <br><br>              :     .       ‚Äî ¬´ ¬ª  ,       .  (  )    .             AWS      . <br><br>       ,            (:   ,  ¬´ ¬ª ‚Äî   ).         ,       ,      . <br><br><h3>     </h3><br>  ,     ,   ,     .      ?   DV  .   ‚Äî   ,    ‚Äî  :     . <br><br>     ,  <i> ‚Äî   </i> .   DL      ,             (:      <b></b> ;   .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ; ,     (    )  <b></b> :      ). <br><br>       ,          .       , , ,     . <br><br> ,    ,     - .   ,  ,    (, , TDD)      .   ,           ,   . <br><br>         ,   :  TDD ,      TDD,  Haskell ,          . <br><br>   ,  Agile     ,       .  Kann sein.    ,   ,   Agile,  FM.      ,          .   ,      <i></i>   ,       . <br><br>        ,     ,    . <br><br><h1>  Zusammenfassung </h1><br>   ‚Äî  .      ,       SMT-    .  -   , ,    . <br><br>    ,        . ,   .       -      ,      .  ,       . <br><br> ,     ,      .   ,   ,    ¬´ ‚Äî    ¬ª.   ,   -  . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437296/">https://habr.com/ru/post/de437296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437280/index.html">Einfache Logistik zum Selbermachen</a></li>
<li><a href="../de437282/index.html">Eine Einf√ºhrung in Kubernetes f√ºr VMware-Benutzer. Teil 2. √úbung</a></li>
<li><a href="../de437284/index.html">Zoo-Berufe im Zusammenhang mit der Audioindustrie</a></li>
<li><a href="../de437286/index.html">Ich versuche .NET Core + Kubernetes + Appmetrics + Prometheus + Grafana + Jobs + Gesundheitschecks</a></li>
<li><a href="../de437292/index.html">Warum das traditionelle Einzelhandelsmodell bereits tot ist</a></li>
<li><a href="../de437298/index.html">√úber einen Kerl</a></li>
<li><a href="../de437300/index.html">10 F√§higkeiten und Kenntnisse, die f√ºr einen iOS-Anf√§nger erforderlich sind</a></li>
<li><a href="../de437304/index.html">Wie man Kartoffeln kauft, wenn man farbenblind ist</a></li>
<li><a href="../de437306/index.html">Nicht offensichtliche F√§higkeiten, die der Produktmanager ben√∂tigt</a></li>
<li><a href="../de437308/index.html">SDL 2.0-Unterrichtszyklus: Lektion 4 - Behandeln von Ereignissen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>