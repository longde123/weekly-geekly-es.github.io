<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❔ 👩🏾‍🤝‍👨🏿 🤔 Warum wenden die Menschen keine formalen Methoden an? 👨🏿‍🏫 👨🏼 📘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beim Software Engineering Stack Exchange sah ich die Frage : "Was verhindert die weit verbreitete Einführung formaler Methoden?" Die Frage wurde als v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum wenden die Menschen keine formalen Methoden an?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437296/"> Beim Software Engineering Stack Exchange sah ich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frage</a> : "Was verhindert die weit verbreitete Einführung formaler Methoden?"  Die Frage wurde als voreingenommen geschlossen und die meisten Antworten waren Kommentare wie "Zu teuer !!!"  oder "Eine Seite ist kein Flugzeug !!!"  In gewisser Weise ist dies wahr, aber es erklärt nicht viel.  Ich habe diesen Artikel geschrieben, um ein umfassenderes historisches Bild der formalen Methoden (FM) zu vermitteln, warum sie nicht tatsächlich verwendet werden und was wir tun, um die Situation zu korrigieren. <br><br>  Bevor Sie beginnen, müssen Sie einige Bedingungen formulieren.  Tatsächlich gibt es nicht viele formale Methoden: nur ein <abbr title="TLA + ist eine der beliebtesten Spezifikationssprachen, und alle TLA + -Experten passen in einen großen Schulbus">paar winzige Gruppen</abbr> .  Dies bedeutet, dass verschiedene Gruppen die Begriffe unterschiedlich verwenden.  Grundsätzlich gibt es zwei Gruppen formaler Methoden: Die <b>formale Spezifikation</b> untersucht das Schreiben präziser, eindeutiger Spezifikationen und die <b>formale Verifikation</b> untersucht die Beweismethoden.  Dies umfasst sowohl Code- als auch abstrakte Systeme.  Wir verwenden nicht nur unterschiedliche Begriffe für Code und Systeme, sondern verwenden häufig unterschiedliche Tools, um sie zu überprüfen.  Um die Sache noch verwirrender zu machen: Wenn jemand sagt, dass er eine formale Spezifikation erstellt, bedeutet dies <i>normalerweise</i> eine Entwurfsüberprüfung.  Und wenn jemand sagt, dass er eine formale Überprüfung durchführt, bezieht sich dies <i>normalerweise</i> auf die Codeüberprüfung. <br><a name="habracut"></a><br>  Aus Gründen der Übersichtlichkeit teilen wir die <b>Codeverifizierungsüberprüfung</b> (CV) und die <b>Entwurfsüberprüfung</b> (DV) auf und unterteilen die Spezifikationen auf ähnliche Weise in CS und DS.  Solche Begriffe werden in der breiten FM-Community nicht häufig verwendet.  Beginnen wir mit CS und CV und fahren dann mit DS und DV fort. <br><br>  Darüber hinaus ist eine <b>teilweise Überprüfung</b> möglich, bei der nur eine Teilmenge der Spezifikation überprüft wird, oder eine <b>vollständige Überprüfung</b> .  Dies kann der Unterschied zwischen den Beweisen der Behauptungen sein, dass das System niemals abstürzt und das falsche Passwort nicht akzeptiert, oder dass das System niemals abstürzt und das Konto sperrt, wenn Sie dreimal das falsche Passwort eingeben.  Grundsätzlich gehen wir davon aus, dass wir eine vollständige Überprüfung durchführen. <br><br>  Sie sollten auch die Art der Software klären, die wir formalisieren.  Die meisten Menschen identifizieren implizit <b>hochzuverlässige</b> Programme wie medizinische Geräte und Flugzeuge.  Die Menschen gehen davon aus, dass formale Methoden für sie weit verbreitet sind, für den Rest jedoch nicht.  Dies ist zu <i>optimistisch</i> : Die meisten hochzuverlässigen Programme verwenden keine formalen Methoden.  Stattdessen konzentrieren wir uns auf „normale“ Software. <br><br>  Zum Schluss der Haftungsausschluss: Ich bin kein professioneller Historiker, und obwohl ich versucht habe, die Informationen sorgfältig zu überprüfen, kann der Artikel Fehler enthalten.  Darüber hinaus bin ich auf formale Spezifikationen (DS und DV) spezialisiert, sodass bei Fehlern über die Codeüberprüfung mehr Fehler auftreten können.  Wenn Sie sehen, schreiben Sie mir, ich werde das Problem beheben (und noch etwas: Ich verdiene Geld mit Seminaren zu TLA + und Alloy, daher bin ich sehr voreingenommen gegenüber diesen Sprachen; ich versuche so objektiv wie möglich zu sein, aber Sie verstehen: Voreingenommenheit ist Voreingenommenheit). <br><br><h1>  Formale Programmierung </h1><br><h2>  Spezifikation erhalten </h2><br>  Bevor Sie die Richtigkeit des Codes nachweisen können, müssen Sie den Standard der Wahrheit ermitteln.  Dies bedeutet eine <b>Spezifikation dessen,</b> was der Code tun soll.  Wir müssen sicher sein, dass das Ergebnis der Spezifikation entspricht.  Es reicht nicht aus zu sagen, dass die Liste "sortiert" ist: Wir wissen nicht, was wir sortieren, welche Kriterien wir verwenden und was wir unter "Sortieren" verstehen.  Stattdessen können wir sagen: "Die Liste der ganzen Zahlen <code>l</code> <i>in aufsteigender Reihenfolge</i> für zwei beliebige Indizes i und j <i>sortiert.</i> Wenn <code>i &lt; j</code> , dann ist <code>l[i] &lt;= l[j]</code> ." <br><br>  Die Codespezifikationen sind in drei Haupttypen unterteilt: <br><br><ol><li>  Die erste besteht darin, codeunabhängige Anweisungen zu schreiben.  Wir schreiben unsere Sortierfunktion und schreiben in eine separate Datei den Satz „Dies gibt sortierte Listen zurück“.  Dies ist die älteste Form der Spezifikation, aber Isabelle und ACL2 funktionieren immer noch auf diese Weise (ML wurde speziell erfunden, um solche Spezifikationen zu schreiben). <br></li><li>  Die zweite implementiert Spezifikationen im Code in Form von Vor- und Nachbedingungen, Anweisungen und Invarianten.  Sie können der Funktion "Der Rückgabewert ist eine sortierte Liste" eine Nachbedingung hinzufügen.  Anspruchsbasierte Spezifikationen wurden ursprünglich als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hoars Logik</a> formalisiert.  Sie erschienen zum ersten Mal in der Programmiersprache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Euclid</a> in den frühen 1970er Jahren (es ist nicht klar, wer sie zuerst verwendet hat: Euclid oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SPV</a> , aber soweit ich weiß, wurde Euclid zuvor der Öffentlichkeit vorgestellt).  Dieser Stil wird auch als <b>Vertragsprogrammierung bezeichnet</b> - die beliebteste Form der Überprüfung in der modernen Industrie (hier werden Verträge als Code-Spezifikationen verwendet). <br></li><li>  Schließlich gibt es Typsysteme.  Durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Curry-Howard-Korrespondenz kann</a> jeder mathematische Satz oder Beweis als abhängiger Typ codiert werden.  Wir definieren den Typ der sortierten Listen und deklarieren den Typ <code>[Int] -&gt; Sorted [Int]</code> für die Funktion. </li></ol><br>  Auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Let's Prove Leftpad können</a> Sie sehen, wie es aussieht.  HOL4 und Isabelle sind gute Beispiele für die Spezifikationen des „unabhängigen Theorems“, SPARK und Dafny sind die Spezifikationen der „verschachtelten Anweisung“ und Coq und Agda sind der „abhängige Typ“. <br><br>  Wenn Sie genau hinschauen, werden diese drei Formen der Codespezifikation mit den drei Hauptbereichen der automatischen Validierung verglichen: Tests, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verträge</a> und Typen.  Dies ist kein Zufall.  Korrektheit ist ein weites Feld, und die formale Überprüfung ist eines ihrer Extreme.  Wenn die Genauigkeit (und der Aufwand) der Überprüfung abnimmt, erhalten wir einfachere und engere Überprüfungen, unabhängig davon, ob der zu untersuchende Zustandsraum begrenzt, schwächere Typen verwendet oder zur Laufzeit erzwungen werden.  Dann wird jedes Mittel zur vollständigen Spezifikation zu einem Mittel zur teilweisen Spezifikation und umgekehrt: Viele betrachten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cleanroom als eine</a> Technik der formalen Verifikation, bei der eine Codeüberprüfung weit über die menschlichen Fähigkeiten hinausgeht. <br><br><h3>  Welche Angaben sind richtig? </h3><br>  Durch die Überprüfung wird überprüft, ob der Code der Spezifikation entspricht.  Es stellt sich die Frage: Woher wissen wir, dass wir die richtige Spezifikation haben?  Das Finden der richtigen Spezifikation ist eines der größten Probleme bei formalen Methoden.  Dies ist auch eine der wichtigsten Einwände gegen sie.  Aber Skeptiker meinen hier nicht <i>genau</i> das <i>,</i> was formale Spezialisten im Sinn haben. <br><br>  Wenn Außenstehende fragen: "Wie erhalten Sie die richtigen Spezifikationen?", Denken sie <i>normalerweise</i> an die <b>Validierung</b> , <b>dh an</b> Spezifikationen, die nicht den Anforderungen des Kunden entsprechen.  Wenn Sie offiziell beweisen, dass Ihr Code die Liste sortiert und der Kunde Uber tatsächlich für Suppen (tm) möchte, haben Sie nur eine Menge Zeit aufgewendet.  Nur schnelle Iterationen und kurze Rückkopplungsschleifen können Ihre Anforderungen bestätigen. <br><br>  Es ist wahr, dass die Codeüberprüfung sie nicht validiert.  Bei diesem Argument gibt es jedoch zwei Probleme.  Das erste ist, dass die Phase der Anwendung formaler Methoden einfach verschoben wird, aber nicht vollständig verschwindet.  Nach all diesen schnellen Iterationen haben Sie wahrscheinlich bereits eine Vorstellung davon, was der Client will.  Und <i>dann</i> beginnen <i>Sie</i> mit der Codeüberprüfung.  Zweitens können wir, obwohl wir nicht genau wissen, was der Kunde will, davon ausgehen, was er definitiv <i>nicht</i> will.  Zum Beispiel, um versehentlich Software zum Absturz zu bringen.  Sie brauchen keine Sicherheitslücken.  Alle sind damit einverstanden: Am Ende sagt niemand, dass Sie Unit-Tests während der Iterationen überspringen müssen.  Stellen Sie also zumindest sicher, dass Ihr Versionskontrollsystem keine zufälligen Benutzerdaten löscht (Hinweis: Denken Sie nicht, dass ich verbittert bin oder so etwas). <br><br>  Das Problem beim Finden der richtigen Spezifikation ist grundlegender: <i>Wir wissen oft nicht, was wir dort schreiben sollen</i> .  Wir denken über unsere Anforderungen in menschlichen, nicht mathematischen Begriffen nach.  Wenn ich sage: „Das Programm sollte Bäume von Vögeln unterscheiden“, worum geht es dann?  Ich kann es einer Person erklären, indem ich ein paar Bilder von Bäumen und Vögeln zeige, aber dies sind nur konkrete Beispiele, keine Beschreibung der <i>Idee</i> .  In der Tat ist es notwendig, menschliche Konzepte zu formalisieren, um dies in eine formale Spezifikation umzusetzen, und dies ist ein ernstes Problem. <br><br>  Versteh mich nicht falsch.  Hier können die relevanten Spezifikationen definiert werden, und Experten tun dies ständig.  Das Schreiben der entsprechenden Spezifikationen ist jedoch eine Fähigkeit, die entwickelt werden muss, sowie Programmierkenntnisse.  Aus diesem Grund erklären sich viele der jüngsten Erfolge der Codeüberprüfung durch eine klare Zuordnung dessen, was wir wollen, zu dem, was wir ausdrücken können.  Beispielsweise ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CompCert</a> ein formal verifizierter C-Compiler. Die Spezifikation dafür lautet: „Kompilierungsfehler vermeiden“. <br><br>  Das alles hat aber nichts mit Verifikation zu tun.  Wenn Sie eine Spezifikation haben, müssen Sie noch nachweisen, dass der Code mit dieser übereinstimmt. <br><br><h3>  Spezifikationsnachweis </h3><br>  Das erste Tool zur Codeüberprüfung ist die Dijkstra-Methode „Überlegen Sie, warum dies wahr ist“, die hauptsächlich für ALGOL gilt.  Zum Beispiel kann ich die Richtigkeit der Sortierung mit der Einfügemethode wie folgt „beweisen“: <br><br><ol><li>  <i>Die grundlegende Option</i> : Wenn Sie der leeren Liste ein Element hinzufügen, ist dies das einzige Element, sodass es sortiert wird. <br></li><li>  Wenn wir eine sortierte Liste mit k Elementen haben und ein Element hinzufügen, fügen wir das Element so ein, dass es nach allen kleineren Zahlen und vor allen größeren Zahlen steht.  Dies bedeutet, dass die Liste noch sortiert ist. <br></li><li>  Durch Induktion sortiert die Einfügesortierung die gesamte Liste. </li></ol><br>  In Wirklichkeit wird der Beweis natürlich strenger aussehen, aber dies ist eine allgemeine Idee.  Dijkstra und andere verwendeten diesen Stil, um die Richtigkeit vieler Algorithmen zu beweisen, einschließlich vieler Grundlagen der Parallelität.  Dies ist auch der Stil, mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Knuths Worte verbunden</a> sind: „Vorsicht vor Fehlern in diesem Code;  Ich habe nur bewiesen, dass es richtig ist, aber ich habe es nicht gestartet. "  Sie können einen mathematischen Beweis leicht ruinieren, so dass niemand es bemerkt.  Nach einigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schätzungen enthalten</a> ungefähr 20% der veröffentlichten mathematischen Beweise Fehler.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20140630071239/">Peter Guttmann</a> hat einen ausgezeichneten Aufsatz über die Gesundheit eines lächerlichen Programms, in dem Tonnen von "getestetem" Code sofort fallen, wenn Sie sie ausführen. <br><br>  Gleichzeitig untersuchten wir Möglichkeiten, um mathematische Theoreme automatisch zu beweisen.  Das erste <b>Programm, das die Theoreme beweist,</b> wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1967 veröffentlicht</a> .  In den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">frühen 1970er Jahren wurden</a> solche Programme zum Testen von Pascal-Code verwendet, und Mitte des Jahrzehnts erschienen spezielle formale Sprachen.  Der Programmierer formuliert einige Eigenschaften des Codes und erstellt dann einen überprüfbaren Beweis dafür, dass der Code diese Eigenschaften aufweist.  Die ersten Programme zum Beweisen von Theoremen halfen den Menschen lediglich, die Beweise zu verifizieren, während ausgefeiltere Werkzeuge Teile des Theorems unabhängig voneinander beweisen konnten. <br><br>  Was zu folgendem Problem führt. <br><br><h3>  Beweise sind schwer zu bekommen </h3><br>  Beweise sind schwierig und es ist ein sehr böser Job.  Es ist schwer, die Programmierung zu beenden und in den Zirkus zu gehen.  Überraschenderweise sind formale Code-Beweise oft strenger als die von den meisten Mathematikern geschriebenen Beweise!  Mathematik ist eine sehr kreative Aktivität, bei der die Antwort auf den Satz nur gültig ist, wenn Sie sie zeigen.  Kreativität passt schlecht zu Formalismus und Computern. <br><br>  Nehmen Sie das gleiche Beispiel für die Sortierung von Einfügungen, bei dem wir die Induktion angewendet haben.  Jeder Mathematiker wird sofort verstehen, was Induktion ist, wie sie im Allgemeinen funktioniert und wie sie in diesem Fall funktioniert.  Aber im Programm zum Beweis der Theoreme muss alles streng formalisiert werden.  Gleiches gilt für Beweise durch Widerspruch, Beweise durch Gegenposition usw. Darüber hinaus müssen alle Annahmen formalisiert werden, auch diejenigen, bei denen sich die meisten Mathematiker nicht um Beweise kümmern.  Zum Beispiel ist <code>a + (b + c) = (a + b) + c</code> .  Das Programm zur Überprüfung von Theoremen a priori weiß nicht, dass dies wahr ist.  Sie müssen es entweder beweisen (schwer) oder es gemäß dem assoziativen Additionsgesetz (gefährlich) als wahr erklären oder eine Bibliothek von Theoremen von jemandem kaufen, der es bereits beweisen konnte (teuer).  Frühe Theoremprüfprogramme konkurrierten um die Anzahl der eingebauten Proof-Taktiken und der zugehörigen Theorembibliotheken.  Eines der ersten weit verbreiteten SPADE-Programme präsentierte die komplette Arithmetikbibliothek als Hauptvorteil. <br><br>  Als nächstes müssen Sie den Beweis selbst erhalten.  Sie können dies dem Programm anvertrauen oder selbst schreiben.  Normalerweise ist die automatische Definition von Beweismitteln nicht entscheidbar.  Für extrem enge Fälle wie Aussagenlogik oder Typprüfung HM ist es „nur“ NP-vollständig.  Tatsächlich schreiben wir selbst die meisten Beweise, und der Computer überprüft ihre Richtigkeit.  Dies bedeutet, dass Sie gut wissen müssen: <br><br><ul><li>  Mathe <br></li><li>  Informatik; <br></li><li>  der Bereich, in dem Sie arbeiten: Compiler, Hardware usw.; <br></li><li>  die Nuancen Ihres Programms und Ihrer Spezialisierung; <br></li><li>  die Nuancen des Programms, um die von Ihnen verwendeten Theoreme zu beweisen, was an sich eine ganze Spezialität ist. </li></ul><br>  Schlimmer noch, computer-spezifische Sticks in Rädern.  Erinnern Sie sich, ich sagte, es sei gefährlich, ein assoziatives Additionsgesetz anzunehmen?  Einige Sprachen erfüllen diese nicht.  Zum Beispiel in C ++ <code>INT_MAX. ((-1) + INT_MAX) + 1</code>  <code>INT_MAX. ((-1) + INT_MAX) + 1</code> ist <code>INT_MAX. -1 + (INT_MAX + 1)</code>  <code>INT_MAX. -1 + (INT_MAX + 1)</code> , was nicht nachweisbar ist.  Unter der Annahme einer assoziativen Hinzufügung in C ++ ist Ihr Beweis falsch und der Code wird beschädigt.  Sie müssen diese Aussage entweder vermeiden oder nachweisen, dass für Ihr bestimmtes Fragment niemals ein Überlauf auftritt. <br><br>  Sie können sagen, dass eine unbestimmte Addition ein Fehler ist, aber Sie müssen eine Sprache mit nicht verwandten Ganzzahlen verwenden.  Die meisten Sprachen haben jedoch spezifische Merkmale, die die Evidenz beeinträchtigen.  Nehmen Sie den folgenden Code: <br><br><pre> <code class="plaintext hljs">a = true; b = false; f(a); assert a;</code> </pre> <br>  Ist das immer so?  Keine Tatsache.  Vielleicht ändert <code>f</code> <code>a</code> .  Vielleicht ändert es den parallelen Fluss.  Vielleicht wurde <code>b</code> ein Alias <code>a</code> zugewiesen, so dass <code>a</code> Änderung auch a ändert (Hinweis: Aliase behindern das Schreiben von Beweisen so sehr, dass John C. Reynolds eine völlig neue <b>Trennungslogik</b> erstellen musste, um dieses Problem zu lösen).  Wenn so etwas in Ihrer Sprache möglich ist, sollten Sie klar beweisen, dass dies hier nicht der Fall ist.  Sauberer Code hilft hier, in einem anderen Fall kann er den Beweis zerstören, da Sie gezwungen sind, Rekursionen und Funktionen höherer Ordnung zu verwenden.  Beide sind übrigens die Basis für das Schreiben guter Funktionsprogramme.  Was für die Programmierung gut ist, ist für den Beweis schlecht!  (Hinweis: In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser Vorlesung</a> listete Edmund Clark einige Eigenschaften auf, die schwer zu überprüfen sind: „Gleitkommawerte, Zeichenfolgen, benutzerdefinierte Typen, Prozeduren, Parallelität, universelle Vorlagen, Speicher, Bibliotheken ...“). <br><br>  Formale Verifizierer haben ein Dilemma: Je ausdrucksvoller die Sprache ist, desto schwieriger ist es, etwas zu beweisen.  Aber je weniger ausdrucksstark die Sprache ist, desto schwieriger ist es, darauf zu schreiben.  Die ersten formalen Arbeitssprachen waren sehr begrenzte Teilmengen ausdrucksstärkerer Sprachen: ACL2 war eine Teilmenge von Lisp, Euklid war eine Teilmenge von Pascal usw. Und nichts von dem, was wir bisher besprochen haben, beweist tatsächlich echte Programme, dies sind nur Versuche, sich zu nähern Beweise zu schreiben. <br><br>  Die Beweise sind schwierig.  Aber es wird einfacher.  Forscher auf diesem Gebiet fügen neue Heuristiken, Theorembibliotheken, vorab getestete Komponenten usw. hinzu. Der technische Fortschritt hilft auch: Je schneller Computer, desto schneller die Suche. <br><br><h3>  SMT Revolution </h3><br>  Eine der Neuerungen Mitte der 2000er Jahre war die Einbeziehung von SMT-Lösern in Programme zum Nachweis von Theoremen.  Im Allgemeinen kann ein SMT-Löser (einige) mathematische Theoreme in Probleme bei der Einhaltung von Beschränkungen umwandeln.  Dies verwandelt eine kreative Aufgabe in eine rechnerische.  Möglicherweise müssen Sie noch Zwischenprobleme (Lemmas) als Schritte im Theorem bereitstellen, aber dies ist besser, als alles selbst zu beweisen.  Die ersten SMT-Löser erschienen um 2004, zunächst als akademische Projekte.  Einige Jahre später veröffentlichte Microsoft Research den Z3, einen handelsüblichen SMT-Solver.  Der große Vorteil des Z3 war, dass es viel bequemer zu bedienen war als andere SMTs, die offen gesagt fast nichts sagten.  Microsoft Research hat es intern verwendet, um die Eigenschaften des Windows-Kernels zu beweisen, sodass sie nicht auf minimale UX beschränkt waren. <br><br>  SMT traf die FM-Community unter dem Atem, weil es plötzlich viele einfache Beweise trivial machte und es ihr ermöglichte, sich sehr komplexen Problemen zu nähern.  So konnten die Menschen in ausdrucksstärkeren Sprachen arbeiten, da nun die Probleme der Ausdrucksaussagen gelöst wurden.  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IronFleet-</a> Projekt sind unglaubliche Fortschritte zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verzeichnen</a> : Mit den besten SMT-Lösern und einer erweiterten Verifizierungssprache konnte Microsoft in nur 3,7 Mannjahren 5.000 Zeilen bewährten Dafny-Codes schreiben!  Dies ist ein unglaublich schnelles Tempo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bis zu</a> <i>vier ganze Zeilen pro Tag</i> (Hinweis: Der vorherige Datensatz gehörte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seL4</a> , dessen Entwickler <i>zwei Zeilen pro Tag in C geschrieben haben.</i> <br><br>  Die Beweise sind schwierig. <br><br><h3>  Warum wird das benötigt? </h3><br>  Es ist Zeit, zurückzutreten und zu fragen: "Was ist der Sinn?"  Wir versuchen zu beweisen, dass ein Programm einer bestimmten Spezifikation entspricht.  Korrektheit ist ein Bereich.  Die Überprüfung besteht aus zwei Teilen: Wie objektiv „korrekt“ Ihr Programm ist und wie sorgfältig Sie die Richtigkeit überprüft haben.  Je mehr überprüft wird, desto besser, aber die Überprüfung ist die Zeit und das Geld wert.  Wenn wir verschiedene Einschränkungen haben (Leistung, Time-to-Market, Kosten usw.), ist eine vollständige Validierung nicht unbedingt die beste Option.  Dann stellt sich die Frage, was der Mindestscheck ist, den wir brauchen und was er kostet.  In den meisten Fällen reichen beispielsweise 90% oder 95% oder 99% Korrektheit für Sie aus.  Vielleicht sollten Sie Zeit damit verbringen, die Benutzeroberfläche zu verbessern, anstatt die verbleibenden 1% zu überprüfen? <br><br>  Dann die Frage: "Ist ein Scheck von 90/95/99% viel billiger als 100%?"  Die Antwort lautet ja.  Es ist sehr angenehm zu sagen, dass die Codebasis, die wir gut getestet und getippt haben, bis auf einige Korrekturen in der Produktion <i>grundsätzlich</i> korrekt ist und wir sogar mehr als vier Codezeilen pro Tag schreiben.  Tatsächlich hätte die überwiegende Mehrheit der Fehlfunktionen in verteilten Systemen durch etwas umfassendere Tests verhindert werden können.  Und es ist nur eine Erweiterung der Tests, ganz zu schweigen von Fuzzing, eigenschaftsbasierten Tests oder Modelltests.  Mit diesen einfachen Tricks können Sie ein wirklich herausragendes Ergebnis erzielen, ohne einen vollständigen Beweis erhalten zu müssen. <br><br>  Was ist, wenn das Tippen und Testen keine ausreichende Überprüfung bietet?  Es ist immer noch viel einfacher, von 90% auf 99% zu wechseln als von 99% auf 100%.  Wie bereits erwähnt, ist Cleanroom eine Entwicklerpraxis, die umfassende Dokumentation, gründliche Flussanalyse und umfassende Codeüberprüfungen umfasst.  Keine Beweise, keine formelle Überprüfung, nicht einmal Unit-Tests.  Ein ordnungsgemäß organisierter Reinraum reduziert die Fehlerdichte jedoch auf weniger als 1 Fehler pro 1000 Codezeilen in der Produktion (Hinweis: Zahlen aus der Stavley-Studie in <i>Richtung Null-</i> Fehler <i>-Programmierung</i> &gt;, aber seien Sie immer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">skeptisch und überprüfen Sie die Quelle</a> ).  Das Programmieren von Cleanroom verlangsamt das Entwicklungstempo nicht und geht mit Sicherheit schneller als 4 Zeilen pro Tag.  Und Cleanroom selbst ist nur eine von vielen hochzuverlässigen Softwareentwicklungsmethoden, die zwischen der üblichen Entwicklung und der Codeüberprüfung liegen.  Sie benötigen keine vollständige Überprüfung, um eine gute oder fast perfekte Software zu schreiben.  Es gibt Zeiten, in denen es gebraucht wird, aber für die meisten Branchen ist es eine Geldverschwendung. <br><br>  Dies bedeutet jedoch nicht, dass formale Methoden im Allgemeinen unwirtschaftlich sind.  Viele der oben genannten hochzuverlässigen Methoden basieren auf dem Schreiben von Codespezifikationen, die Sie formal nicht nachweisen.  In Bezug auf die Überprüfung gibt es zwei gängige Möglichkeiten, von denen die Branche profitiert.  Zuerst die Entwurfsüberprüfung anstelle des Codes, auf die wir später noch eingehen werden.  Zweitens eine teilweise Überprüfung des Codes, die wir jetzt betrachten werden. <br><br><h2>  Teilweise Codeüberprüfung </h2><br>  Für alltägliche Aufgaben ist es zu teuer, eine vollständige Überprüfung durchzuführen.  Wie wäre es teilweise?  Schließlich können Sie vom Nachweis einiger Eigenschaften einzelner Codefragmente profitieren.  Anstatt zu beweisen, dass meine Funktion Zahlen immer richtig sortiert, kann ich zumindest beweisen, dass sie nicht für immer wiederholt wird und niemals außerhalb des Bereichs liegt.  Dies sind auch sehr nützliche Informationen.  Selbst der einfachste Beweis für C-Programme ist eine großartige Möglichkeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, einen großen Teil des undefinierten Verhaltens zu eliminieren</a> . <br><br>  Das Problem ist die <i>Zugänglichkeit</i> .       ,     .             ,          ,    .             ,   C  Java.      . , SPARK    Ada,        SPARK       Ada.      . <br><br>         .      —  :    ,  <i>tail</i>   tail,    ,    <code>[a] -&gt; [a]</code> .      Rust      Pony     .     SPARK  Frama-C ,    <i></i>  .         ,      :     ,    . ,    ,  Rust  Haskell,      . <br><br><h1>   </h1><br>         .        ,       ,  .    ,    <b> </b> :  - ,    ,  ,  ,      . <br><br>    ,     ,  .        - ,  -   .     , ,   ,     ,     ,             .        ,      , ,  ,    <abbr title="       ,   ,  &nbsp;— ,    ">  </abbr> .           ,    .      ,         ,    . <br><br>  ,      «  ,             ».   ,   ,   .    ?     -  ?         ?         «    »     : <br><br><ul><li>      , <i>   </i> ?      <i></i>  ? <br></li><li>   ?  ?      ?      ? <br></li><li>          ?      ,    ?    «»     ,     ? <br></li><li>  ,       ?   ? <br></li><li>     ?    «  »      ? <br></li><li>   GDPR? <br></li><li>      . </li></ul><br>          .      ,    ,           ,      .      ,    ,      ,  . <br><br>  ,        ,   <b> </b>   .       ,    ,         (:         <b></b> ).         (DL),      ( ,    ;    « »,          ). <br><br> ,   DL  VDM   1972 .          .  DL     ,      (CVL).  ,   DL    ,  CVL —   .        ,  DL     .  ,      DL: <br><br><table><tbody><tr><th>  Sprache </th><th>   </th><th>  </th></tr><tr><td>  Z. </td><td> - </td><td>   </td></tr><tr><td> Promela </td><td>  Beiträge </td><td> CSP </td></tr><tr><td> SDL </td><td>  </td><td> - </td></tr><tr><td>    </td><td>  </td><td>  </td></tr><tr><td>    </td><td>  </td><td>  </td></tr></tbody></table><br>  DL      ,            .  ,   .   ,  DL       .      Praxis ( Altran),   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">«--»</a> —  Z-   SPARK —     .     ,           . <br><br>     Alloy   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>  Chord,     -. AWS   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">35-  </a> ,   TLA+.   ,     ,        . <br><br>          -    .       ,        ,   .      ,    ,        .      .    -  DL,      ,     ,   . <br><br>  ,       ,    —   . <br><br><h2>   </h2><br>      ,    ,  .  ,      :   <b>  </b> (model checker).   ,   ,        ,      .    ,     (:        ,  JMBC,         ,   ). <br><br>     . -,    ,      . -,   <i></i>  ,     . -,   ,     .  , <i></i>   ,       35 .    . <br><br>    . -,     .  ,     <b></b> (unbounded) ,      . ,     :        .        … ,   ,      .            ,       ,    . <br><br>    — <b>   </b> (state-space explosion). ,     ,        ,       .        ,   <code>(4*3)! / (4!)^3 = 34 650</code>   ().         ,       4 300 000.     ,      .    ,       !     ,      .         ,     ,    . <br><br>              :     .       — « »  ,       .  (  )    .             AWS      . <br><br>       ,            (:   ,  « » —   ).         ,       ,      . <br><br><h3>     </h3><br>  ,     ,   ,     .      ?   DV  .   —   ,    —  :     . <br><br>     ,  <i> —   </i> .   DL      ,             (:      <b></b> ;   .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ; ,     (    )  <b></b> :      ). <br><br>       ,          .       , , ,     . <br><br> ,    ,     - .   ,  ,    (, , TDD)      .   ,           ,   . <br><br>         ,   :  TDD ,      TDD,  Haskell ,          . <br><br>   ,  Agile     ,       .  Kann sein.    ,   ,   Agile,  FM.      ,          .   ,      <i></i>   ,       . <br><br>        ,     ,    . <br><br><h1>  Zusammenfassung </h1><br>   —  .      ,       SMT-    .  -   , ,    . <br><br>    ,        . ,   .       -      ,      .  ,       . <br><br> ,     ,      .   ,   ,    « —    ».   ,   -  . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437296/">https://habr.com/ru/post/de437296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437280/index.html">Einfache Logistik zum Selbermachen</a></li>
<li><a href="../de437282/index.html">Eine Einführung in Kubernetes für VMware-Benutzer. Teil 2. Übung</a></li>
<li><a href="../de437284/index.html">Zoo-Berufe im Zusammenhang mit der Audioindustrie</a></li>
<li><a href="../de437286/index.html">Ich versuche .NET Core + Kubernetes + Appmetrics + Prometheus + Grafana + Jobs + Gesundheitschecks</a></li>
<li><a href="../de437292/index.html">Warum das traditionelle Einzelhandelsmodell bereits tot ist</a></li>
<li><a href="../de437298/index.html">Über einen Kerl</a></li>
<li><a href="../de437300/index.html">10 Fähigkeiten und Kenntnisse, die für einen iOS-Anfänger erforderlich sind</a></li>
<li><a href="../de437304/index.html">Wie man Kartoffeln kauft, wenn man farbenblind ist</a></li>
<li><a href="../de437306/index.html">Nicht offensichtliche Fähigkeiten, die der Produktmanager benötigt</a></li>
<li><a href="../de437308/index.html">SDL 2.0-Unterrichtszyklus: Lektion 4 - Behandeln von Ereignissen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>