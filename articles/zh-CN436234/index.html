<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆑 ⏰ 😞 Haskell应用解析器 🚄 🎿 ↕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="动机 


 当我刚开始学习Haskell时，我对复杂抽象而不是任何特定解决方案的广泛使用感到非常恼火。 在我看来，始终遵循KISS原则并使用基本语言构造编写自行车要比理解所有这些类型类更好，以便在某个地方编写一个据认为方便的构造要好得多。 


 我没有一个很好的例子，花在发展“物资”上的努力会得...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Haskell应用解析器</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436234/"><p><img src="https://habrastorage.org/webt/tq/9u/iw/tq9uiw8d_nbb1bbwrfdg1euyvci.png"></p><br><h1 id="motivaciya"> 动机 </h1><br><p> 当我刚开始学习Haskell时，我对复杂抽象而不是任何特定解决方案的广泛使用感到非常恼火。 在我看来，始终遵循KISS原则并使用基本语言构造编写自行车要比理解所有这些类型类更好，以便在某个地方编写一个据认为方便的构造要好得多。 </p><br><p> 我没有一个很好的例子，花在发展“物资”上的努力会得到回报。 对我来说，最成功的例子之一就是解析器。 现在，当他们问我可以使用Haskell完成哪些常见任务时，我经常谈论它们。 </p><br><p>我想为初学者提供这种方法，并从头开始创建一个小的函数库，以方便解析器的实现，然后使用它编写自己的解析器，其代码几乎会真正地重复用于解析的语法。 </p><br><p> 我希望这可以帮助某人克服对抽象的恐惧，并教他们如何<em>适当</em>地使用它们（是的，我仍然认为编写自行车有时会更有效率）。 </p><a name="habracut"></a><br><p> 我没有目的，也不想从头开始编写Haskell课程，因此我假设读者熟悉语法并独立开发了简单程序。 以防万一，在继续介绍实现之前，我将简要讨论类型类。 </p><br><p> 对于从未写过Haskell但想了解此处发生情况的用户，建议您先<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Y分钟内</a>查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Learn X</a>的相应页面。 作为适合初学者的优秀俄语书籍，我建议丹尼斯·舍甫琴科<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">（</a> Denis Shevchenko）撰写的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“关于人类的哈斯克尔”</a> 。 </p><br><p> 我将尝试使用初学者可以理解的最简单的语言构造。 在文章的结尾，给出了到源存储库的链接，其中在代码的某些部分中使用了更方便，更短的条目，乍一看可能不太清楚。 </p><br><p> 是的，Haskellist先生们，很多情况下都非常简单明了，对于特殊情况，不是很抽象，没有使用类别理论的术语和其他令人恐惧的词。 我很高兴您认识他们，当然他们很容易掌握它们。 我也知道它们，但是在这种情况下，我认为没有必要抛弃对准备不足的读者来说不必要的大量信息。 </p><br><h1 id="klassy-tipov"> 类型类别 </h1><br><p>  Haskell类型类与C ++和其他面向对象语言中的类无关。 如果我们用OOP做一个类比，则类型类更像是方法和函数的重载。 </p><br><p>类确定可以对组成该类的类型的对象执行哪些操作。 例如，可以对所有数字进行相等性比较，但可以对所有数字进行排序（复杂数字除外），并且通常根本无法对函数进行比较。 可以比较的类型类别称为<code>Eq</code> ，有序<code>Ord</code> （类型不必为数字）。 通过转换为字符串可以打印的内容属于<code>Show</code>类，它具有“相反的” <code>Read</code>类，该类确定如何将字符串转换为所需类型的对象。 </p><br><p> 对于一组标准类型类（例如<code>Eq</code> ， <code>Show</code> ， <code>Read</code> ...），您可以要求编译器在确定类型之后使用<code>deriving</code>关键字以标准方式实现所需的功能： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xCoord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">yCoord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p> 您可以定义自己的类型类： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrettyPrint</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pPrint :: a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span></code> </pre> <br><p> 在这里， <code>PrettyPrint</code>是类的名称， <code>a</code>是类型变量。  <code>where</code>关键字后面是所谓的类方法的列表，即 可以应用于此类中的对象的函数。 </p><br><p> 为了指示数据类型属于类，使用了以下构造： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrettyPrint</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pPrint (<span class="hljs-type"><span class="hljs-type">Point</span></span> xy) = <span class="hljs-string"><span class="hljs-string">"("</span></span> ++ show x ++ <span class="hljs-string"><span class="hljs-string">", "</span></span> ++ show y ++ <span class="hljs-string"><span class="hljs-string">")"</span></span></code> </pre> <br><p> 该语言允许您指定必须与函数参数关联的类型类的限制： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">showVsPretty</span></span> :: (<span class="hljs-type"><span class="hljs-type">Show</span></span> a, <span class="hljs-type"><span class="hljs-type">PrettyPrint</span></span> a) =&gt; a -&gt; (<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>) showVsPretty x = (show x, pPrint x)</code> </pre> <br><p> 对于每个函数调用，编译器都会检查是否满足这些类型要求，并在失败的情况下显示错误（当然，这是在编译阶段发生的）。 </p><br><pre> <code class="haskell hljs">&gt;&gt;&gt; showVsPretty (<span class="hljs-type"><span class="hljs-type">Point</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-string"><span class="hljs-string">"Point {xCoord = 2.0, yCoord = 3.0}"</span></span>,<span class="hljs-string"><span class="hljs-string">"(2.0, 3.0)"</span></span>) &gt;&gt;&gt; showVsPretty <span class="hljs-string"><span class="hljs-string">"str"</span></span> error: <span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> for (<span class="hljs-type"><span class="hljs-type">PrettyPrint</span></span> [<span class="hljs-type"><span class="hljs-type">Char</span></span>]) arising from a use <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> 'showVsPretty'</code> </pre> <br><h1 id="realizaciya"> 实作 </h1><br><p> 解析器收到一个输入字符串，它必须根据预定义的规则进行解析，并获取我们需要的类型的值（例如，整数）。 在这种情况下，输入线可能不会结束，其余部分将用作进一步分析的输入。 另外，我们的解析器通常是不确定的，即 将返回几个可能的解析结果作为列表。 </p><br><p> 两个元素<code>(String, a)</code>的元组适合描述解析器操作的一个结果，其中<code>a</code>是可以表示任何用户类型的类型变量。 </p><br><p> 由于解析器根据一些规则解析字符串，因此我们将其描述为一个将字符串作为输入并返回结果列表的函数： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unParser</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> -&gt; [(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)] }</span></span></code> </pre> <br><p> 如果结果列表由一个元素组成并且输入字符串已完全处理，我们将认为解析成功。 我们实现了一个辅助函数，该函数尝试唯一地解析整个字符串： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parseString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a parseString s (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (ps) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [(<span class="hljs-string"><span class="hljs-string">""</span></span>, val)] -&gt; <span class="hljs-type"><span class="hljs-type">Just</span></span> val _ -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span></code> </pre> <br><h2 id="prosteyshie-parsery"> 简单解析器 </h2><br><p> 我们实现了几个简单的解析器，这些解析器将在构建更复杂的组合时派上用场。 </p><br><p> 我们首先分析一个必须满足谓词的字符。 如果输入字符串为空，则工作结果为空列表。 否则，我们在字符串的第一个字符上检查谓词的值。 如果返回<code>True</code> ，则解析结果为该字符；否则为false。 将其与其余字符串一起返回。 否则，解析也会失败。 </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">predP</span></span> :: (<span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> predP p = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f <span class="hljs-string"><span class="hljs-string">""</span></span> = [] f (c : cs) | pc = [(cs, c)] | otherwise = []</code> </pre> <br><p> 现在，我们可以编写一个解析器，该解析器在该行的开头采用一个特定的字符。 为此，请使用刚刚编写的<code>predP</code>并将其作为参数传递给一个函数，该函数将其参数与所需的字符进行比较： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">charP</span></span> :: <span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> charP char = predP (\c -&gt; c == char)</code> </pre> <br><p> 以下是最简单的情况：整体上仅接受特定字符串的解析器。  <code>stringP</code>称它为<code>stringP</code> 。 解析器中的函数将输入行与所需行进行比较，如果行相等，则返回一个元素的列表：一对空行（输入中不留任何内容）和原始行。 否则，解析将失败，并返回一个空结果列表。 </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">stringP</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> stringP s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fs' | s == s' = [(<span class="hljs-string"><span class="hljs-string">""</span></span>, s)] | otherwise = []</code> </pre> <br><p> 通常，在行首时需要跳过具有特定属性的字符（例如，空白字符）。 此外，分析的结果对我们并不重要，将来也将无用。 我们编写了一个<code>skip</code>函数，该函数在保留谓词的真实值的同时跳过字符串的初始字符。 作为分析结果，我们使用一个空的元组。 </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skip</span></span> :: (<span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skip p = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [(dropWhile ps, ())])</code> </pre> <br><p> 接下来的两个解析器彼此非常相似。 两者都检查输入行前缀，只有第一个（如果成功的话）返回该前缀，第二个返回空的元组，即 允许您在输入的开头跳过任意行。 该实现使用<code>Data.List</code>模块中定义的<code>isPrefixOf</code>函数。 </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">prefixP</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> prefixP s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s `isPrefixOf` input <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> [(drop (length s) input, s)] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> [] skipString :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skipString s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s `isPrefixOf` input <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> [(drop (length s) input, ())] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> []</code> </pre> <br><p> 稍后，我们将考虑对后者函数的更简单实现，并消除代码重复。 </p><br><h2 id="parser-kak-funktor"> 解析器作为函子 </h2><br><p> 我们可以区分一类满足以下条件的整个容器类型：如果您知道如何在容器内转换对象，则可以自己转换容器。 最简单的示例是作为容器的列表和<code>map</code>函数，几乎所有高级语言都提供了该列表。 实际上，您可以遍历<code>[a]</code>类型的列表的所有元素，对每个元素应用a- <code>a -&gt; b</code>函数，并获得<code>[b]</code>类型的列表。 </p><br><p> 这种类型的类称为<code>Functor</code> ；该类具有一个<code>fmap</code>方法： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br><p> 假设我们已经知道如何将字符串解析为某种类型<code>a</code>对象，此外，我们知道如何将<code>a</code>类型<code>a</code>对象转换为<code>b</code>类型<code>a</code>对象。 是否可以说存在<code>b</code>类型对象的解析器？ </p><br><p> 如果以函数的形式表示，则它将具有以下类型： </p><br><pre> <code class="haskell hljs">(a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b</code> </pre> <br><p> 此类型与<code>fmap</code>函数的类型一致，因此让我们尝试将解析器用作函子。 让我们从头开始创建一个类型为<code>b</code>的值的解析器，该解析器将首先调用第一个解析器（我们已经有一个），然后将该函数应用于其解析结果。 </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b fmap f (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> p2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p2 :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; [(<span class="hljs-type"><span class="hljs-type">String</span></span>, b)] p2 s = convert (p1 s) convert :: [(<span class="hljs-type"><span class="hljs-type">String</span></span>, a)] -&gt; [(<span class="hljs-type"><span class="hljs-type">String</span></span>, b)] convert results = map (\(s, val) -&gt; (s, f val)) results</code> </pre> <br><p>  <code>fmap</code>函数有一个方便的后缀同义词： <code>fmap fx == f &lt;$&gt; x</code> 。 </p><br><p> 如果我们使用函数作为<code>fmap</code>的参数，只是将其第一个参数替换为新值，那么即使在两个实例中，我们也将为所有函子实现另一个有用的操作（它们仅在参数顺序上有所不同）： </p><br><pre> <code class="plaintext hljs">(&lt;$) :: Functor f =&gt; a -&gt; fb -&gt; fa ($&gt;) :: Functor f =&gt; fa -&gt; b -&gt; fb</code> </pre> <br><p> 还记得跳过特定行的分析器（ <code>skipString</code> ）吗？ 现在，您可以按以下方式实现它： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skipString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skipString s = () &lt;$ prefixP s</code> </pre> <br><h2 id="kombinacii-parserov"> 解析器组合 </h2><br><p> 在Haskell中，默认情况下所有函数都是咖喱的，并且部分可用。 这意味着<code>n</code>参数的函数实际上是一个参数的函数，返回<code>n-1</code>参数的函数： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">cons</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] cons = (:) cons1 :: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] cons1 = cons <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">--  cons  </span></span></code> </pre> <br><p> 我们使用<code>fmap</code>将三个参数中的函数应用于解析器中的某个值。 类型如下： </p><br><pre> <code class="plaintext hljs">f :: c -&gt; a -&gt; b p :: Parser c (fmap fp) :: Parser (a -&gt; b)</code> </pre> <br><p> 函数解析器原来是？！ 当然，当函数的表示确实在输入行中时，可能会出现这种情况，但是我希望能够使用此函数，或者更确切地说，将<code>Parser (a -&gt; b)</code>和<code>Parser a</code>解析器组合以获得<code>Parser b</code> ： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">applyP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b</code> </pre> <br><p> 此函数的类型与<code>fmap</code>类型非常相似，只有需要应用的函数本身也位于容器中。 这可以直观地了解<code>applyP</code>函数的实现方式：从容器中获取函数（作为应用第一个解析器的结果），获取函数应应用的值（应用第二个解析器的结果），然后将使用此函数转换后的值“打包”放入容器中（创建一个新的解析器）。 在实现中，我们将使用列表推导： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">applyP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b applyP (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p2) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fs = [ (sx, fx) | (sf, f) &lt;- p1 s, <span class="hljs-comment"><span class="hljs-comment">-- p1     (sx, x) &lt;- p2 sf] -- p2   ,    </span></span></code> </pre> <br><p> 有一个<code>Applicative</code>类，该类的方法具有相同的原型。 该类的第二种方法称为<code>pure</code>函数，用于“包装”或“提升”（ <em>lift</em> ）一个值，包括一个功能值。 对于解析器的实现， <code>pure</code>函数将其参数添加到解析器的结果中，而无需更改输入字符串。 </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pure :: a -&gt; fa (&lt;*&gt;) :: f (a -&gt; b) -&gt; fa -&gt; fb <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Applicative</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> pure x = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [(s, x)]) pf &lt;*&gt; px = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [ (sx, fx) | (sf, f) &lt;- unParser pf $ s, (sx, x) &lt;- unParser px $ sf])</code> </pre> <br><p>  <code>applyP</code>函数是<code>Applicative</code>类中的<code>&lt;*&gt;</code> 。 属于此类的类型称为应用函子。 </p><br><p> 对于应用函子，实现了两个对我们有用的辅助功能： </p><br><pre> <code class="haskell hljs">(*&gt;) :: fa -&gt; fb -&gt; fb (&lt;*) :: fa -&gt; fb -&gt; fa</code> </pre> <br><p> 这些函数执行两个连续的动作，并仅返回其中一个的结果。 对于解析器，可以使用它们来例如在分析承载语义负载的字符串的一部分之前跳过前导空格。 </p><br><p> 通过组合<code>&lt;$&gt;</code>和<code>&lt;*&gt;</code> ，可以创建非常方便的设计。 考虑以下数据类型： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyStructType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyStruct</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type1</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field2</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type2</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field3</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type3</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p> 值<code>MyStruct</code>的构造函数也是一个函数，在这种情况下，它的类型为<code>Type1 -&gt; Type2 -&gt; Type3 -&gt; MyStructType</code> 。 您可以像使用其他任何函数一样使用构造函数。 假设已经为结构字段的类型编写了解析器： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parser1</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type1</span></span> parser2 :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type2</span></span> parser3 :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type3</span></span></code> </pre> <br><p> 使用<code>fmap</code>函数，可以将<code>MyStruct</code>部分应用于这些解析器中的第一个： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct'</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (<span class="hljs-type"><span class="hljs-type">Type2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Type3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyStructType</span></span>) parserStruct' = <span class="hljs-type"><span class="hljs-type">MyStruct</span></span> &lt;$&gt; parser1</code> </pre> <br><p> 让我们尝试应用现在位于解析器“内部”的函数。 为此，您已经需要使用<code>&lt;*&gt;</code> ： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct''</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (<span class="hljs-type"><span class="hljs-type">Type3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyStructType</span></span>) parserStruct'' = parserStruct' &lt;*&gt; parser2 parserStruct :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">MyStructType</span></span> parserStruct = parserStruct'' &lt;*&gt; parser3</code> </pre> <br><p> 结果，我们得到了整个结构的解析器（当然，这里我们假设在原始行中其字段的表示是连续的）。 可以在一行中完成同一件事： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">MyStructType</span></span> parserStruct = <span class="hljs-type"><span class="hljs-type">MyStruct</span></span> &lt;$&gt; parser1 &lt;*&gt; parser2 &lt;*&gt; parser3</code> </pre> <br><p> 在用例中经常会遇到这种构造。 </p><br><p> 现在假设我们正在尝试编写一个解析器来解析简单的算术表达式，其中整数和标识符可以作为操作数出现。 让我们为它们创建一个单独的<code>Operand</code>类型： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operand</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IntOp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IdentOp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span></span></code> </pre> <br><p> 如果我们已经知道如何解析整数和标识符（例如，在C语言中），那么我们需要<em>一个</em>解析器来解析可以互斥的一个操作数。 此解析器是其他两个解析器的替代方案，因此我们需要一个可以组合解析器的功能，以便合并其工作结果。 解析器的结果是一个列表，合并列表就是它们的串联。 我们实现结合两个解析器的<code>altP</code>函数： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">altP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a altP (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p2) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; p1 s ++ p2 s)</code> </pre> <br><p> 然后，可以使用此函数来实现操作数解析器（此处假定<code>parserInt</code>和<code>parserIdent</code>已经在某处<code>parserIdent</code>了描述： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserOperand</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Operand</span></span> parserOperand = altP parserIntOp parserIdentOp <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> parserIntOp = <span class="hljs-type"><span class="hljs-type">IntOp</span></span> &lt;$&gt; parserInt parserIdentOp = <span class="hljs-type"><span class="hljs-type">IdentOp</span></span> &lt;$&gt; parserIdent</code> </pre> <br><p> 当然，对于替代方案，我们已经提出了一个单独的类，称为<code>Alternative</code> 。 它有另一种方法<code>empty</code> ，它描述了替代操作的中性元素。 在我们的例子中，它是一个从不解析任何内容的解析器，即 总是返回一个空的结果列表。 对于解析器， <code>Alternative</code>类的方法的实现如下所示： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alternative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> empty :: fa (&lt;|&gt;) :: fa -&gt; fa -&gt; fa <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Alternative</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> empty = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (const []) px &lt;|&gt; py = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; unParser px s ++ unParser py s)</code> </pre> <br><p> 操作<code>&lt;|&gt;</code>仅是后缀表示法中的<code>altP</code>函数，通过将多个解析器组合成一行，使用起来更方便。 </p><br><p> 对于此类中的所有类型，都实现了两个函数， <code>some</code>函数<code>many</code>类型为<code>fa -&gt; f [a]</code> 。 它们每个都可以通过另一个表达： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">some</span></span> v = (:) &lt;$&gt; v &lt;*&gt; many v many v = some v &lt;|&gt; pure []</code> </pre> <br><p> 就解析器而言，如果您知道如何解析单个数据元素，这些函数就可以解析数据序列。 如果使用<code>some</code>序列<code>some</code>序列必须为非空。 </p><br><h1 id="primer-ispolzovaniya"> 使用范例 </h1><br><p> 现在，我们准备编写您自己的解析器，例如，用于具有以下语法的简单算术表达式： </p><br><pre> <code class="plaintext hljs"> expr ::= constExpr | binOpExpr | negExpr const ::= int int ::= digit{digit} digit ::= '0' | ... | '9' binOpExpr ::= '(' expr ' ' binOp ' ' expr ')' binOp ::= '+' | '*' negExpr ::= '-' expr</code> </pre> <br><p> 该表达式由整数常量，一元减号和两个中缀二进制运算组成：加法和乘法。 用二进制运算符在表达式周围需要括号，运算符与操作数之间仅需一个空格，不允许前导和悬挂空格。 </p><br><p> 正确表达形式的示例： </p><br><pre> <code class="plaintext hljs">"123" "-(10 + 42)" "(1 + ((2 + 3) * (4 + 5)))"</code> </pre> <br><p> 错误输入示例： </p><br><pre> <code class="plaintext hljs">" 666 " "2 + 3" "(10 * 10)"</code> </pre> <br><p> 我们声明必要的数据类型（表达式本身和二进制操作）： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ConstExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BinaryExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operator</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NegateExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operator</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Add</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mul</span></span></span></span></code> </pre> <br><p> 您可以开始解析！ 该表达式本身包含三种选择。 所以我们写： </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- expr ::= constExpr | binOpExpr | negExpr exprParser :: Parser Expr exprParser = constParser &lt;|&gt; binParser &lt;|&gt; negParser</span></span></code> </pre> <br><p> 常数是一个正整数。 在我们的数据类型中，它在构造函数中被“包装”，因此我们不能直接将解析器用于整数，但是可以使用<code>fmap</code>获取所需类型的值。 </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- const ::= int constParser :: Parser Expr constParser = ConstExpr &lt;$&gt; intParser</span></span></code> </pre> <br><p> 根据语法，整数表示为数字的非空序列。 要解析一位数字，我们使用辅助函数<code>predP</code>和<code>Data.Char</code>模块中的谓词<code>isDigit</code> 。 现在，要构建用于解析数字序列的解析器，我们使用<code>some</code>功能（不多，因为必须至少有一个数字）。 这样的解析器的结果从最长的记录开始，返回所有可能的解析选项的列表。 例如，如果输入字符串为“ 123ab”，则结果列表如下： <code>[("ab", "123"), ("3ab", "12"), ("23ab", "1")]</code> 。 我们需要解析最长的数字序列并将其转换为<code>Int</code>类型。 整个实现如下： </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- int ::= digit{digit} -- digit ::= '0' | ... | '9' intParser :: Parser Int intParser = Parser $ \s -&gt; let res = unParser (some digitParser) s in case res of [] -&gt; [] ((rest, i) : xs) -&gt; [(rest, read i)] where digitParser = predP isDigit</span></span></code> </pre> <br><p> 编写表达式的另一种方法是使用二进制运算。 根据语法，开括号必须首先包括开括号，第一个操作数，空格，运算符，另一个空格，第二个操作数和闭括号。 为了解析单个字符（括号和空格），我们使用<code>charP</code>函数。 操作数是表达式，并且已经有一个解析器（ <code>exprParser</code> ）来解析它们。 为了解析二进制运算符号，我们在下面描述辅助解析器。 整齐地组合这组解析器仍然有待解决。 表达式的开头和结尾应该有方括号：您需要检查一下，但要丢弃结果本身。 为此，请使用<code>*&gt;</code>和<code>&lt;*</code> ： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">binParser</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Expr</span></span> binParser = charP '(' *&gt; ??? &lt;* charP ')'</code> </pre> <br><p> 在这些用于括号的解析器之间，必须使用<code>BinaryExpr</code>构造函数以及用于表达式和操作的解析器<code>BinaryExpr</code>构造表达式。 使用与方括号相同的方法，不要忘记操作符号周围的空格。 这部分如下： </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">BinaryExpr</span></span> &lt;$&gt; exprParser <span class="hljs-comment"><span class="hljs-comment">--   &lt;*&gt; (charP ' ' *&gt; binOpParser &lt;* charP ' ') -- ,   &lt;*&gt; exprParser --  </span></span></code> </pre> <br><p> 我们用以下表达式代替问号： </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- binOpExpr ::= '(' expr ' ' binOp ' ' expr ')' binParser :: Parser Expr binParser = charP '(' *&gt; (BinaryExpr &lt;$&gt; exprParser &lt;*&gt; (charP ' ' *&gt; binOpParser &lt;* charP ' ') &lt;*&gt; exprParser ) &lt;* charP ')'</span></span></code> </pre> <br><p> 二进制运算符可以是<code>+</code>字符来解析<code>Add</code>值，或者是<code>*</code>来解析<code>Mul</code> ： </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- binOp ::= '+' | '*' binOpParser :: Parser Operator binOpParser = plusParser &lt;|&gt; multParser where plusParser = charP '+' $&gt; Add multParser = charP '*' $&gt; Mul</span></span></code> </pre> <br><p> 剩下的就是语法中最简单的部分，即表达的否定。 使用符号<code>-</code>与使用方括号和空格的操作相同。 接下来，将<code>NegateExpr</code>构造函数应用于递归解析的结果： </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- negExpr ::= '-' expr negParser = charP '-' *&gt; (NegateExpr &lt;$&gt; exprParser)</span></span></code> </pre> <br><p> 因此，解析器的所有部分均已实现。 该代码很像一个语法，并且在结构上与之完全一致。 </p><br><p> 可以从GitLab获得源代码： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> ://gitlab.com/fierce-katie/applicative-parsers-demo。 </p><br><p> 由于注释少得多，因此更容易评估其表达量和表达程度。 您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Stack</a>实用程序来编译项目，并使用我们编写的解析器运行基本解释器： </p><br><pre> <code class="plaintext hljs">$ stack build $ stack exec demo-parser</code> </pre> <br><p> 对于那些想自己进一步练习的人，我可以提供以下建议： </p><br><ul><li> 语法可以通过各种方式进行改进，例如，允许前导和悬挂空格，添加新操作等。 </li><li> 解析器将字符串转换为表达式的内部表示形式。 可以计算该表达式，并转换解释器，以便它不输出解析结果，而是输出计算结果。 </li><li> 探索<code>parsec</code> ， <code>attoparsec</code> ， <code>applicative-parsec</code>和<code>optparse-applicative</code> <code>applicative-parsec</code>的可能性，并尝试使用它们。 </li></ul><br><p> 感谢您的关注！ </p><br><h1 id="poleznye-materialy"> 有用的材料 </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Y分钟内学习Haskell</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">丹尼斯·舍甫琴科。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“关于Haskell作为人类”</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Parsec库</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Attoparsec库</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">应用视差库</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Optparse应用程序库</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN436234/">https://habr.com/ru/post/zh-CN436234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN436224/index.html">我们编写编程语言，第4部分：结构和类的表示形式，分配器的生成</a></li>
<li><a href="../zh-CN436226/index.html">Wireshark指南和备忘单</a></li>
<li><a href="../zh-CN436228/index.html">建立一个从数据库查询数据的团队</a></li>
<li><a href="../zh-CN436230/index.html">如何控制您的网络基础架构。 第三章 网络安全。 第二部分</a></li>
<li><a href="../zh-CN436232/index.html">心灵感应策略</a></li>
<li><a href="../zh-CN436236/index.html">我们使用数据科学来确定客户的生命周期</a></li>
<li><a href="../zh-CN436238/index.html">使用GitHub OAuth和Dex在Kubernetes中进行身份验证</a></li>
<li><a href="../zh-CN436240/index.html">自动化VS混乱</a></li>
<li><a href="../zh-CN436242/index.html">YOLO和其他宽松方法</a></li>
<li><a href="../zh-CN436244/index.html">劳伦斯教授的新大脑</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>