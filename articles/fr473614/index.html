<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥦 📘 🏀 Le livre «Head First. Kotlin » 👂🏿 🎅🏻 ✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, habrozhiteli! Nous avons un livre publié pour étudier Kotlin en utilisant la technique Head First, qui va au-delà de la syntaxe et des instruct...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le livre «Head First. Kotlin »</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/473614/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/ev/fj/ao/evfjaohk2b8qeka0nzciygs_q70.jpeg" align="left" alt="image"></a>  Salut, habrozhiteli!  Nous avons un livre publié pour étudier Kotlin en utilisant la technique Head First, qui va au-delà de la syntaxe et des instructions pour résoudre des problèmes spécifiques.  Ce livre vous donnera tout ce dont vous avez besoin - des bases du langage aux méthodes avancées.  Et vous pouvez pratiquer la programmation orientée objet et fonctionnelle. <br><br>  Un extrait "Data Classes" est présenté sous la coupe. <br><a name="habracut"></a><br><h3>  Travailler avec des données </h3><br>  Personne ne veut perdre de temps et refaire ce qui a déjà été fait.  La plupart des applications utilisent des classes pour stocker des données.  Pour simplifier le travail, les créateurs de Kotlin ont proposé le concept d'une classe de données.  Dans ce chapitre, vous apprendrez comment les classes de données vous aident à écrire du code plus élégant et concis dont vous ne pouviez que rêver auparavant.  Nous allons examiner les fonctions d'assistance des classes de données et apprendre à décomposer un objet de données en composants.  Dans le même temps, nous vous expliquerons comment les valeurs des paramètres par défaut rendent le code plus flexible et vous présenterons également Any, l'ancêtre de toutes les superclasses. <br><br><h3>  L'opérateur == appelle une fonction appelée égal </h3><br>  Comme vous le savez déjà, l'opérateur == peut être utilisé pour vérifier l'égalité.  Chaque fois que l'instruction == est exécutée, une fonction appelée égal est appelée.  Chaque objet contient une fonction égale et l'implémentation de cette fonction détermine le comportement de l'opérateur ==. <br><br>  Par défaut, la fonction égal pour vérifier l'égalité vérifie si deux variables font référence au même objet. <br><br>  Pour comprendre comment cela fonctionne, imaginez deux variables Wolf nommées w1 et w2.  Si w1 et w2 contiennent des références à un objet Wolf, lors de leur comparaison avec l'opérateur ==, le résultat est vrai: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/21/xu/jv/21xujvaljehbr6dvg7klxpu7qi8.png" alt="image"></div><br>  Mais si w1 et w2 contiennent des références à des objets Wolf différents, leur comparaison avec l'opérateur == donne le résultat faux, même si les objets contiennent les mêmes valeurs de propriété. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/de/xo/fb/dexofbmvz5qakq1ls-hhvp7h8r8.png" alt="image"></div><br>  Comme mentionné précédemment, la fonction equals est automatiquement incluse dans chaque objet que vous créez.  Mais d'où vient cette fonction? <br><br><h3>  est égal à hérite de la superclasse Any </h3><br>  Chaque objet contient une fonction appelée égal car sa classe hérite d'une fonction d'une classe nommée Any.  La classe Any est l'ancêtre de toutes les classes: la superclasse résultante de tout.  Chaque classe que vous définissez est une sous-classe de Any, et vous n'avez pas besoin de le signaler dans le programme.  Ainsi, si vous écrivez un code de classe appelé myClass, qui ressemble à ceci: <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br>  Le compilateur le convertira automatiquement au format suivant: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tv/04/lg/tv04lgenrnekhx2uqa2bsfr4meu.png" alt="image"></div><br><blockquote>  Chaque classe est une sous-classe de Any et hérite de son comportement.  Chaque classe est une sous-classe de Any, et vous n'avez pas à le signaler dans le programme. </blockquote><br><h3>  L'importance de tout héritage </h3><br>  Inclure Any en tant que superclasse résultante présente deux avantages importants: <br><br><ul><li>  <b>Il garantit que chaque classe hérite d'un comportement commun.</b>  La classe Any définit un comportement important dont dépend le fonctionnement du système.  Et puisque chaque classe est une sous-classe de Any, ce comportement est hérité par tous les objets que vous créez.  Ainsi, la classe Any définit une fonction appelée égal, et par conséquent, cette fonction est automatiquement héritée par tous les objets. </li><li>  <b>Cela signifie que le polymorphisme peut être utilisé avec n'importe quel objet.</b>  Chaque classe est une sous-classe de Any, donc tout objet que vous créez a la classe Any comme super-type final.  Cela signifie que vous pouvez créer une fonction avec des paramètres Any ou un type de retour Any qui fonctionnera avec des objets de tout type.  Cela signifie également que vous pouvez créer des tableaux polymorphes pour stocker des objets de tout type avec du code de la forme suivante: </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myArray = arrayOf(Car(), Guitar(), Giraffe())</code> </pre><br>  Le compilateur remarque que chaque objet du tableau a un prototype commun de Any et crée donc un tableau de type Array. <br><br>  Le comportement général hérité de la classe Any mérite un examen plus approfondi. <br><br><h3>  Comportement commun hérité de Any </h3><br>  La classe Any définit plusieurs fonctions héritées par chaque classe.  Voici des exemples de fonctions de base et de leur comportement: <br><br><ul><li>  <b>égal (tout: Tout): booléen</b> <br>  Vérifie si deux objets sont considérés comme «égaux».  Par défaut, la fonction renvoie true si elle est utilisée pour vérifier un objet, ou false - pour différents objets.  Dans les coulisses, la fonction d'égalité est appelée chaque fois que l'opérateur == est utilisé dans le programme. </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w1 = Wolf() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w1 = Wolf() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w2 = Wolf() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w2 = w1 println(w1.equals(w2)) println(w1.equals(w2)) <span class="hljs-literal"><span class="hljs-literal">false</span></span> (equals  <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> (equals  <span class="hljs-literal"><span class="hljs-literal">true</span></span>,   w1  w2   w1  w2        .)      —   ,   w1 == w2.</code> </pre> <br><ul><li>  <b>hashCode (): Int</b> <br>  Renvoie un code de hachage pour un objet.  Les codes de hachage sont souvent utilisés par certaines structures de données pour stocker et récupérer efficacement les valeurs. </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w = Wolf() println(w.hashCode())</code> </pre> <br>  <b>523429237</b> (valeur du code de hachage w) <br><br><ul><li>  <b>toString (): String</b> <br>  Renvoie un message String représentant l'objet.  Par défaut, le message contient le nom de la classe et un numéro, ce qui ne nous intéresse généralement pas. </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w = Wolf() println(w.toString())</code> </pre> <br>  <b>Wolf @ 1f32e575</b> <br><br><blockquote>  Par défaut, la fonction equals vérifie si deux objets sont le même objet réel. <br><br>  La fonction equals détermine le comportement de l'opérateur ==. </blockquote><br>  La classe Any fournit une implémentation par défaut pour toutes les fonctions répertoriées, et ces implémentations sont héritées par toutes les classes.  Cependant, vous pouvez remplacer ces implémentations pour modifier le comportement par défaut de toutes les fonctions répertoriées. <br><br><h3>  Vérification simple de l'équivalence de deux objets </h3><br>  Dans certaines situations, vous devez modifier l'implémentation de la fonction equals pour modifier le comportement de l'opérateur ==. <br><br>  Supposons que vous ayez une classe de recette qui vous permet de créer des objets pour stocker des recettes.  Dans une telle situation, vous considérerez probablement deux objets Recette égaux (ou équivalents) s'ils contiennent une description de la même recette.  Disons que la classe Recipe est définie avec deux propriétés - title et isVegetarian: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isVegetarian: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) { }</code> </pre> <br>  L'opérateur == retournera true s'il est utilisé pour comparer deux objets Recipe avec les mêmes propriétés, title et isVegetarian: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/x6/xf/mf/x6xfmfs4maim5uck7papwh2pqdg.png" alt="image"></div><br>  Bien que vous puissiez changer le comportement de l'opérateur == en écrivant du code supplémentaire pour remplacer la fonction equals, les développeurs de Kotlin ont fourni une solution plus pratique: ils ont créé le concept d'une classe de données.  Voyons ce que sont ces classes et comment elles sont créées. <br><br><h3>  La classe de données vous permet de créer des objets de données. </h3><br>  Une classe de données est une classe de création d'objets pour le stockage de données.  Il comprend des outils utiles pour travailler avec des données - par exemple, une nouvelle implémentation de la fonction equals, qui vérifie si deux objets de données contiennent les mêmes valeurs de propriété.  Si deux objets contiennent les mêmes données, ils peuvent être considérés comme égaux. <br><br>  Pour définir une classe de données, faites précéder la définition de données habituelle avec le mot-clé data.  Le code suivant convertit la classe de recette créée précédemment en une classe de données: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isVegetarian: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) { }</code> </pre> <br>  Le préfixe de données convertit une classe régulière en classe de données. <br><br><h3>  Comment créer des objets basés sur une classe de données </h3><br>  Les objets de classe de données sont créés de la même manière que les objets de classe standard: en appelant le constructeur de cette classe.  Par exemple, le code suivant crée un nouvel objet de données de recette et l'affecte à une nouvelle variable nommée r1: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br>  Les classes de données remplacent automatiquement leurs fonctions égales pour modifier le comportement de l'opérateur == afin que l'égalité des objets soit vérifiée en fonction des valeurs de propriété de chaque objet.  Si, par exemple, vous créez deux objets Recette avec les mêmes valeurs de propriété, la comparaison des deux objets avec l'opérateur == donnera le résultat vrai, car les mêmes données y sont stockées: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-comment"><span class="hljs-comment">//r1 == r2  true</span></span></code> </pre><br>  r1 et r2 sont considérés comme «égaux» car deux objets Recette contiennent les mêmes données. <br><br>  En plus de la nouvelle implémentation de la fonction equals héritée de la superclasse Any, les classes de données <br>  remplacer également les fonctions hashCode et toString.  Voyons comment ces fonctions sont implémentées. <br><br><h3>  Les objets de classe redéfinissent leur comportement hérité </h3><br>  Pour travailler avec des données, une classe de données a besoin d'objets, elle fournit donc automatiquement les implémentations suivantes pour les fonctions equals, hashCode et toString héritées de la superclasse Any: <br><br><h3>  La fonction equals compare les valeurs des propriétés </h3><br>  Lors de la définition d'une classe de données, sa fonction égale (et donc l'opérateur ==) renvoie toujours true si les liens pointent vers le même objet.  Mais elle renvoie également true si les objets ont les mêmes valeurs de propriété définies dans le constructeur: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) println(r1.equals(r2)) <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><blockquote>  Les objets de données sont considérés comme égaux si leurs propriétés contiennent la même valeur. </blockquote><br><h3>  Pour des objets égaux, les mêmes valeurs hashCode sont retournées </h3><br>  Si deux objets de données sont considérés comme égaux (en d'autres termes, ils ont les mêmes valeurs de propriété), la fonction hashCode renvoie la même valeur pour ces objets: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) println(r1.hashCode()) println(r2.hashCode())</code> </pre> <br>  <b>241131113</b> <b><br></b>  <b>241131113</b> <br><br><h3>  toString renvoie les valeurs de toutes les propriétés </h3><br>  Enfin, la fonction toString ne renvoie plus le nom de la classe, suivi d'un nombre, mais renvoie une chaîne utile avec les valeurs de toutes les propriétés définies dans le constructeur de la classe de données: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) println(r1.toString()) Recipe(title=Chicken Bhuna, isVegetarian=<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br>  En plus de remplacer les fonctions héritées de la superclasse Any, la classe de données fournit également des outils supplémentaires qui permettent un travail plus efficace avec les données, par exemple, la possibilité de copier des objets de données.  Voyons comment fonctionnent ces outils. <br><br><h3>  Copie d'objets de données avec la fonction de copie </h3><br>  Si vous devez créer une copie de l'objet de données en modifiant certaines de ses propriétés, mais en laissant les autres propriétés dans leur état d'origine, utilisez la fonction de copie.  Pour ce faire, la fonction est appelée pour l'objet que vous souhaitez copier et les noms de toutes les propriétés modifiables avec de nouvelles valeurs lui sont transmis. <br><br>  Supposons que vous ayez un objet Recipe nommé r1, qui est défini dans le code comme ceci: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Thai Curry"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tu/hk/oi/tuhkoizk5srtgdpish28kozd5o4.png" alt="image"></div><br>  Si vous souhaitez créer une copie de l'objet Recipe, en remplaçant la valeur de la propriété isVegetarian par true, cela se fait comme suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p1/_9/xb/p1_9xbbjnwqi2p-lwlsh7jzjvcw.png" alt="image"></div><br>  Essentiellement, cela signifie «créer une copie de l'objet r1, changer la valeur de sa propriété isVegetarian sur true et affecter un nouvel objet à une variable nommée r2».  Cela crée une nouvelle copie de l'objet et l'objet d'origine reste inchangé. <br><br>  En plus de la fonction de copie, les classes de données fournissent également un ensemble de fonctions pour diviser un objet de données en un ensemble de valeurs de ses propriétés - ce processus est appelé déstructuration.  Voyons comment cela se fait. <br><br><h3>  Les classes de données définissent les fonctions componentN ... </h3><br>  Lors de la définition d'une classe de données, le compilateur ajoute automatiquement à la classe un ensemble de fonctions qui peuvent être utilisées comme mécanisme alternatif pour accéder aux valeurs des propriétés des objets.  Ces fonctions sont connues sous le nom général des fonctions componentN, où N est le nombre de propriétés à récupérer (dans l'ordre de déclaration). <br><br>  Pour voir comment fonctionnent les fonctions componentN, supposons que vous ayez l'objet Recipe suivant: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br>  Si vous souhaitez obtenir la valeur de la première propriété de l'objet (propriété title), vous pouvez appeler la fonction component1 () de l'objet pour cela: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title = r.component1()</code> </pre> <br>  component1 () renvoie la référence contenue dans la première propriété définie dans le constructeur de la classe de données. <br><br>  La fonction fait la même chose que le code suivant: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title = r.title</code> </pre> <br>  Le code avec la fonction est plus universel.  Pourquoi les fonctions ComponentN sont-elles si utiles dans les classes de données? <br><br><h3>  ... conçu pour restructurer les objets de données </h3><br>  Les fonctions génériques de componentN sont utiles principalement parce qu'elles fournissent un moyen simple et pratique de diviser un objet de données en valeurs de propriété ou de le détruire. <br><br>  Supposons que vous souhaitiez prendre les valeurs des propriétés d'un objet Recette et affecter la valeur de chacune de ses propriétés à une variable distincte.  Au lieu de code <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title = r.title <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vegetarian = r.isVegetarian</code> </pre> <br>  avec le traitement séquentiel de chaque propriété, vous pouvez utiliser le code suivant: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (title, vegetarian) = r</code> </pre> <br>  Attribue un titre à la première propriété r et végétarien à la deuxième propriété. <br><br>  Ce code signifie "créer deux variables, titre et végétarien, et attribuer la valeur de l'une des r propriétés de chaque variable."  Il fait la même chose que le prochain fragment <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title = r.component1() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vegetarian = r.component2()</code> </pre> <br>  mais il s'avère plus compact. <br><br>  <b>L'opérateur === vérifie toujours si deux variables se réfèrent au même objet.</b> <br><br>  Si vous souhaitez vérifier si deux variables font référence au même objet quel que soit leur type, utilisez l'opérateur === au lieu de ==.  L'opérateur === donne le résultat vrai si (et seulement si) lorsque deux variables contiennent une référence à un objet réel.  Si vous avez deux variables, x et y, et l'expression suivante: <br><br><pre> <code class="kotlin hljs">x === y</code> </pre> <br>  donne le résultat vrai, alors vous savez que les variables x et y doivent faire référence au même objet. <br><br>  Contrairement à l'opérateur ==, le comportement de l'opérateur === est indépendant de la fonction égal.  L'opérateur === se comporte toujours de la même manière quel que soit le type de classe. <br><br>  Maintenant que vous avez appris à créer et à utiliser des classes de données, créez un projet pour le code de recette. <br><br><h3>  Création d'un projet de recettes </h3><br>  Créez un nouveau projet Kotlin pour la JVM et nommez-le «Recettes».  Ensuite, créez un nouveau <br>  Fichier Kotlin nommé Recipes.kt: sélectionnez le dossier src, ouvrez le menu Fichier et sélectionnez la commande <br>  Nouveau → Fichier / classe Kotlin.  Saisissez le nom de fichier «Recettes» et sélectionnez l'option Fichier dans le groupe Type. <br><br>  Nous ajoutons une nouvelle classe de données au projet appelé Recette et créons des objets de données Recette.  Voici le code.  Mettez à jour votre version de Recipes.kt et alignez-la avec la nôtre: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isVegetarian: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) (  {} ,        .) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Thai Curry"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Thai Curry"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r3 = r1.copy(title = <span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>) (  r1    title) println(<span class="hljs-string"><span class="hljs-string">"r1 hash code: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1.hashCode()}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r2 hash code: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r2.hashCode()}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r3 hash code: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r3.hashCode()}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r1 toString: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1.toString()}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r1 == r2? </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1 == r2}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r1 === r2? </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1 === r2}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r1 == r3? </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1 == r3}</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (title, vegetarian) = r1 ( r1) println(<span class="hljs-string"><span class="hljs-string">"title is </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$title</span></span></span><span class="hljs-string"> and vegetarian is </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$vegetarian</span></span></span><span class="hljs-string">"</span></span>) }</code> </pre> <br>  Lorsque vous exécutez votre code, le texte suivant apparaît dans la fenêtre de sortie de l'EDI: <br><br><pre> <code class="kotlin hljs">r1 hash code: -<span class="hljs-number"><span class="hljs-number">135497891</span></span> r2 hash code: -<span class="hljs-number"><span class="hljs-number">135497891</span></span> r3 hash code: <span class="hljs-number"><span class="hljs-number">241131113</span></span> r1 toString: Recipe(title=Thai Curry, isVegetarian=<span class="hljs-literal"><span class="hljs-literal">false</span></span>) r1 == r2? <span class="hljs-literal"><span class="hljs-literal">true</span></span> r1 === r2? <span class="hljs-literal"><span class="hljs-literal">false</span></span> r1 == r3? <span class="hljs-literal"><span class="hljs-literal">false</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Thai Curry and vegetarian <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre><br><br>  »Plus d'informations sur le livre sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de l'éditeur</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contenu</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Extrait</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a> <br>  25% de réduction sur le coupon pour Khabrozhitel - <b>Kotlin</b> <br><br>  Lors du paiement de la version papier du livre, un livre électronique est envoyé par e-mail. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr473614/">https://habr.com/ru/post/fr473614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr473600/index.html">Qui a besoin de Chromebooks?</a></li>
<li><a href="../fr473602/index.html">Travailler de manière asynchrone</a></li>
<li><a href="../fr473608/index.html">Un guide pour comprendre le concept de développement d'applications Web modernes</a></li>
<li><a href="../fr473610/index.html">Analyse de la nouvelle console Web Plesk Obsidian</a></li>
<li><a href="../fr473612/index.html">Traité sur la broche. Réflexions sur la configuration et l'utilisation des broches en C ++ pour les microcontrôleurs (en utilisant CortexM comme exemple)</a></li>
<li><a href="../fr473626/index.html">«Le développeur veut acheter un avion dans trois ans. Ma tâche est de l'aider »- Denis Pushkin sur la motivation Skyeng</a></li>
<li><a href="../fr473628/index.html">C ++ au service de l'orthodontie: entretien avec Mikhail Matrosov, développeur CAO chez Align Technology</a></li>
<li><a href="../fr473630/index.html">Meilleures pratiques et outils pour développer des applications iOS</a></li>
<li><a href="../fr473632/index.html">Nous avons vu un article sur Habr</a></li>
<li><a href="../fr473634/index.html">Les lobbies de Comcast interdisent le cryptage DNS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>