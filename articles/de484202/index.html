<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöØ üîü üë©üèø‚Äçüé® Maschinelles Lernen in der statischen Analyse von Programmquellcode üòê ‚õÖÔ∏è üèÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Maschinelles Lernen hat sich in verschiedenen Bereichen des Menschen fest etabliert, von der Spracherkennung bis zur medizinischen Diagnose. Die Popul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Maschinelles Lernen in der statischen Analyse von Programmquellcode</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/484202/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/0e0/738/38e0e0738ea8b928bdecb77040a207c1.png" alt="Maschinelles Lernen in der statischen Analyse von Programmquellcode"></div><br>  Maschinelles Lernen hat sich in verschiedenen Bereichen des Menschen fest etabliert, von der Spracherkennung bis zur medizinischen Diagnose.  Die Popularit√§t dieses Ansatzes ist so gro√ü, dass die Leute versuchen, ihn zu verwenden, wo immer sie k√∂nnen.  Einige Versuche, klassische Ans√§tze durch neuronale Netze zu ersetzen, schlagen fehl.  Dieses Mal werden wir uns mit maschinellem Lernen befassen, um effektive statische Code-Analysatoren zum Auffinden von Fehlern und potenziellen Schwachstellen zu erstellen. <br><a name="habracut"></a><br>  Das PVS-Studio-Team wird h√§ufig gefragt, ob wir mit dem maschinellen Lernen beginnen m√∂chten, um Fehler im Software-Quellcode zu finden.  Die kurze Antwort lautet ja, aber in begrenztem Umfang.  Wir glauben, dass beim maschinellen Lernen viele Fallstricke bei Code-Analyse-Aufgaben lauern.  Im zweiten Teil des Artikels werden wir dar√ºber berichten.  Beginnen wir mit einer √úberpr√ºfung neuer L√∂sungen und Ideen. <br><br><h2>  Neue Ans√§tze </h2><br>  Heutzutage gibt es viele statische Analyseger√§te, die auf maschinellem Lernen basieren oder dieses verwenden, einschlie√ülich Deep Learning und NLP zur Fehlererkennung.  Nicht nur Enthusiasten, sondern auch gro√üe Unternehmen wie Facebook, Amazon oder Mozilla haben ihr Potenzial f√ºr maschinelles Lernen verdoppelt.  Einige Projekte sind keine vollwertigen statischen Analyseger√§te, da sie nur bestimmte Fehler in Commits finden. <br><br>  Interessanterweise sind fast alle von ihnen als Game-Changer-Produkte positioniert, die aufgrund k√ºnstlicher Intelligenz den Durchbruch im Entwicklungsprozess schaffen werden. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28c/cde/532/28ccde53241d54d5b927234ff729a19d.png"></div><br><br>  Schauen wir uns einige der bekannten Beispiele an: <br><br><ol><li>  Deepcode </li><li>  Infer, Sapienz, SapFix </li><li>  Embold </li><li>  Quelle {d} </li><li>  Clever-Commit, Commit-Assistent </li><li>  CodeGuru </li></ol><br><h3>  Deepcode </h3><br>  Deep Code ist ein Tool zur Suche nach Sicherheitsl√ºcken f√ºr Java-, JavaScript-, TypeScript- und Python-Software, das maschinelles Lernen als Komponente bietet.  Laut Boris Paskalev gibt es bereits mehr als 250.000 Regeln.  Dieses Tool lernt aus √Ñnderungen, die von Entwicklern im Quellcode von Open Source-Projekten vorgenommen wurden (eine Million Repositorys).  Das Unternehmen selbst sagt, dass ihr Projekt eine Art Grammatik f√ºr Entwickler ist. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c0/f09/8df/0c0f098dfabd07a95df228b434ab3bfb.png"></div><br><br>  In der Tat vergleicht dieser Analysator Ihre L√∂sung mit der Projektbasis und bietet Ihnen die beabsichtigte beste L√∂sung aus der Erfahrung anderer Entwickler. <br><br>  Im Mai 2018 teilten die Entwickler mit, dass die Unterst√ºtzung von C ++ in Vorbereitung ist, diese Sprache wird jedoch bislang nicht unterst√ºtzt.  Wie auf der Website angegeben, kann die neue Sprachunterst√ºtzung aufgrund der Tatsache, dass die Sprache nur von einer Phase abh√§ngt, die analysiert wird, in wenigen Wochen hinzugef√ºgt werden. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a38/68e/7e5/a3868e7e5efa50016e7a7858054da47a.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/111/984/4f5/1119844f5406645778271c64f12d0df9.png"></div><br><br>  Auf der Website finden Sie auch eine Reihe von Beitr√§gen zu den grundlegenden Methoden des Analyseger√§ts. <br><br><h3>  Infer </h3><br>  Facebook ist ziemlich eifrig bei seinen Versuchen, neue umfassende Ans√§tze in seine Produkte einzuf√ºhren.  Auch maschinelles Lernen blieb nicht au√üen vor.  Im Jahr 2013 kauften sie ein Startup, das einen statischen Analysator basierend auf maschinellem Lernen entwickelte.  Und im Jahr 2015 wurde der Quellcode des Projekts <a href="https://github.com/facebook/infer">ge√∂ffnet</a> . <br><br>  Infer ist ein statischer Analysator f√ºr Projekte in Java, C, C ++ und Objective-C, der von Facebook entwickelt wurde.  Der Website zufolge wird sie auch in Amazon Web Services, Oculus, Uber und anderen beliebten Projekten verwendet. <br><br>  Derzeit kann Infer Fehler im Zusammenhang mit Nullzeiger-Dereferenzierung und Speicherlecks finden.  Infer basiert auf Hoares Logik, Trennungslogik und Biabduktion sowie abstrakter Interpretationstheorie.  Durch die Verwendung dieser Ans√§tze kann der Analysator das Programm in Bl√∂cke aufteilen und diese unabh√§ngig analysieren. <br><br>  Sie k√∂nnen versuchen, Infer f√ºr Ihre Projekte zu verwenden. Entwickler warnen jedoch, dass bei Facebook-Projekten etwa 80% der n√ºtzlichen Warnungen generiert werden, bei anderen Projekten jedoch keine geringe Anzahl von Fehlalarmen garantiert ist.  Hier sind einige Fehler, die Infer bisher nicht erkennen kann, aber die Entwickler arbeiten daran, diese Warnungen zu implementieren: <br><br><ul><li>  Array-Index au√üerhalb der Grenzen; </li><li>  Typ Casting Ausnahmen; </li><li>  nicht verifizierte Datenlecks; </li><li>  Rennbedingung. </li></ul><br><h3>  Sapfix </h3><br>  SapFix ist ein automatisiertes Bearbeitungswerkzeug.  Es erh√§lt Informationen von Sapienz, einem Testautomatisierungs-Tool, und dem statischen Infer-Analysator.  Basierend auf den letzten √Ñnderungen und Meldungen w√§hlt Infer eine von mehreren Strategien aus, um Fehler zu beheben. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/547/de6/baa/547de6baa2d74f4e3be984a78c704d45.png"></div><br><br>  In einigen F√§llen setzt SapFix alle √Ñnderungen oder Teile davon zur√ºck.  In anderen F√§llen wird versucht, das Problem zu l√∂sen, indem ein Patch aus den Fixierungsmustern generiert wird.  Dieser Satz wird aus Mustern von Fixes gebildet, die von Programmierern selbst aus einem Satz bereits vorgenommener Fixes zusammengestellt wurden.  Wenn ein solches Muster einen Fehler nicht behebt, versucht SapFix, ihn an die Situation anzupassen, indem kleine √Ñnderungen in einem abstrakten Syntaxbaum vorgenommen werden, bis die potenzielle L√∂sung gefunden ist. <br><br>  Eine m√∂gliche L√∂sung reicht jedoch nicht aus, daher sammelt SapFix mehrere L√∂sungen auf der Grundlage einiger Punkte: ob Kompilierungsfehler vorliegen, ob es abst√ºrzt, ob es neue Abst√ºrze einf√ºhrt.  Sobald die Bearbeitungen vollst√§ndig getestet wurden, werden die Patches von einem Programmierer √ºberpr√ºft, der entscheidet, welche der Bearbeitungen das Problem am besten l√∂st. <br><br><h3>  Embold </h3><br>  Embold ist eine Startplattform f√ºr die statische Analyse von Software-Quellcode, der vor der Umbenennung als Gamma bezeichnet wurde.  Der statische Analysator basiert auf der eigenen Diagnose des Tools sowie auf integrierten Analysatoren wie Cppcheck, SpotBugs, SQL Check und anderen. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f40/406/bd8/f40406bd824b5eeb1815de357d95565b.png"></div><br><br>  Neben der eigentlichen Diagnose konzentriert sich die Plattform auf lebendige Infografiken zum Laden der Codebasis und zur bequemen Anzeige gefundener Fehler sowie auf die Suche nach m√∂glichen Umgestaltungen.  Au√üerdem verf√ºgt dieser Analysator √ºber eine Reihe von Anti-Patterns, mit denen Sie Probleme in der Codestruktur auf Klassen- und Methodenebene erkennen und verschiedene Metriken zur Berechnung der Qualit√§t eines Systems verwenden k√∂nnen. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/74f/abb/22074fabb8b67de2ce5d5427729387f7.png"></div><br><br>  Einer der Hauptvorteile ist das intelligente System des Angebots von L√∂sungen und Bearbeitungen, das zus√§tzlich zur herk√∂mmlichen Diagnose Bearbeitungen anhand von Informationen √ºber fr√ºhere √Ñnderungen √ºberpr√ºft. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/122/c46/6e5122c462cd33320eafecd4deac2a49.png"></div><br><br>  Mit NLP l√∂st Embold den Code auf und sucht nach Zusammenh√§ngen und Abh√§ngigkeiten zwischen Funktionen und Methoden, wodurch Umgestaltungszeit gespart wird. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94e/129/3fe/94e1293fe9e031d4065beb9ea1b21932.png"></div><br><br>  Auf diese Weise bietet Embold im Grunde genommen eine komfortable Visualisierung Ihrer Quellcode-Analyseergebnisse durch verschiedene Analyseger√§te sowie eine eigene Diagnose, von denen einige auf maschinellem Lernen basieren. <br><br><h3>  Quelle {d} </h3><br>  Source {d} ist im Vergleich zu den von uns getesteten Analyseger√§ten das offenste Tool in Bezug auf die Art und Weise seiner Implementierung.  Es ist auch eine <a href="https://github.com/src-d/sourced-ce">Open-Source-Code-L√∂sung</a> .  Auf ihrer Website erhalten Sie im Austausch f√ºr Ihre E-Mail-Adresse eine Produktbrosch√ºre, in der die von ihnen verwendeten Technologien beschrieben werden.  Au√üerdem enth√§lt die Website einen <a href="https://github.com/src-d/awesome-machine-learning-on-source-code">Link</a> zur Datenbank mit Ver√∂ffentlichungen zur Verwendung von maschinellem Lernen f√ºr die Codeanalyse sowie zum <a href="https://github.com/src-d/datasets/tree/master/PublicGitArchive">Repository</a> mit Dataset f√ºr das codebasierte Lernen.  Das Produkt selbst ist eine Plattform zur Analyse des Quellcodes und des Softwareprodukts und richtet sich nicht an Entwickler, sondern an Manager.  Zu seinen F√§higkeiten geh√∂ren die Berechnung der technischen Schulden, Engp√§sse im Entwicklungsprozess und andere globale Statistiken zum Projekt. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af2/b8c/425/af2b8c42537b1a2628c95773165ed190.png"></div><br><br>  Ihr Ansatz zur Code-Analyse durch maschinelles Lernen basiert auf der Natural-Hypothese, wie im Artikel " <a href="https://people.inf.ethz.ch/suz/publications/natural.pdf">√úber die Nat√ºrlichkeit von Software</a> " beschrieben. <br><br>  <i>"Programmiersprachen sind theoretisch komplex, flexibel und leistungsf√§hig, aber die Programme, die echte Menschen tats√§chlich schreiben, sind meistens einfach und eher repetitiv, und daher haben sie brauchbar vorhersagbare statistische Eigenschaften, die in statistischen Sprachmodellen erfasst und f√ºr das Software-Engineering genutzt werden k√∂nnen Aufgaben. "</i> <br><br>  Basierend auf dieser Hypothese sind die statistischen Eigenschaften umso gr√∂√üer und die durch Lernen erreichten Metriken umso genauer, je gr√∂√üer die Codebasis ist. <br><br>  Zur Analyse des Codes in source {d} wird der Babelfish-Dienst verwendet, der die Codedatei in einer der verf√ºgbaren Sprachen analysieren, einen abstrakten Syntaxbaum abrufen und in einen universellen Syntaxbaum konvertieren kann. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39e/bbd/c4d/39ebbdc4d561895c1f7b9e251d44e17c.png"></div><br><br>  Quelle {d} sucht jedoch nicht nach Fehlern im Code.  Basierend auf dem Baum, in dem ML f√ºr das gesamte Projekt verwendet wird, erkennt source {d} die Formatierung des Codes, den im Projekt angewendeten Stil und ein Commit.  Wenn der neue Code nicht dem Projektcode-Stil entspricht, werden einige √Ñnderungen vorgenommen. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/196/c0a/e7f196c0a742ba8f68436b157708c109.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/f51/7bd/debf517bd5d74c2553a9b7fbd112a1b2.png"></div><br><br>  Das Lernen konzentriert sich auf mehrere grundlegende Elemente: Leerzeichen, Tabellierung, Zeilenumbr√ºche usw. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39a/ade/8c5/39aade8c5ea77cb3bf89d4a0e999c5f7.png"></div><br><br>  Lesen Sie mehr dazu in ihrer Publikation: " <a href="https://arxiv.org/abs/1904.00935">STYLE-ANALYZER: Beheben von Inkonsistenzen im Code-Stil mit interpretierbaren, nicht √ºberwachten Algorithmen</a> ". <br><br>  Alles in allem ist source {d} eine breite Plattform f√ºr die Erfassung verschiedener Statistiken zum Quellcode und zum Projektentwicklungsprozess: von Effizienzberechnungen der Entwickler bis hin zu Zeitkosten f√ºr die Code√ºberpr√ºfung. <br><br><h3>  Clever begehen </h3><br>  Clever-Commit ist ein Analysator, der von Mozilla in Zusammenarbeit mit Ubisoft erstellt wurde.  Es basiert auf einer <a href="https://static-wordpress.akamaized.net/montreal.ubisoft.com/wp-content/uploads/2018/03/03172129/clever-commit-msr18.pdf">CLEVER-Studie</a> (Combining Levels of Bug Prevention and Resolution Techniques) von Ubisoft und seinem Commit Assistant f√ºr <a href="https://static-wordpress.akamaized.net/montreal.ubisoft.com/wp-content/uploads/2018/03/03172129/clever-commit-msr18.pdf">untergeordnete</a> Produkte, die verd√§chtige Commits erkennt, die wahrscheinlich einen Fehler enthalten.  Da CLEVER auf einem Codevergleich basiert, kann es sowohl auf gef√§hrlichen Code verweisen als auch Vorschl√§ge f√ºr m√∂gliche √Ñnderungen machen.  Nach der Beschreibung findet Clever-Commit in 60-70% der F√§lle Problemstellen und bietet korrekte Bearbeitungen mit der gleichen Wahrscheinlichkeit an.  Im Allgemeinen gibt es nur wenige Informationen zu diesem Projekt und zu den Fehlern, die es finden kann. <br><br><h3>  CodeGuru </h3><br>  Vor kurzem ist CodeGuru, ein Produkt von Amazon, mit maschinellem Lernen in Einklang mit Analyseger√§ten gekommen.  Es handelt sich um einen maschinellen Lerndienst, mit dem Sie Fehler im Code finden und kostspielige Bereiche darin identifizieren k√∂nnen.  Die Analyse ist bisher nur f√ºr Java-Code verf√ºgbar, die Autoren versprechen jedoch, in Zukunft andere Sprachen zu unterst√ºtzen.  Andy Jassy, ‚Äã‚ÄãCEO von AWS (Amazon Web Services), gibt an, dass es bereits seit langer Zeit bei Amazon eingesetzt wird. <br><br>  Der Website zufolge lernte CodeGuru sowohl auf der Amazon-Codebasis als auch in mehr als 10.000 Open Source-Projekten. <br><br>  Grunds√§tzlich besteht der Dienst aus zwei Teilen: CodeGuru Reviewer, der mithilfe der Suche nach assoziativen Regeln und der Suche nach Fehlern im Code unterrichtet wird, und CodeGuru Profiler, der die Leistung von Anwendungen √ºberwacht. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/662/3a6/ee06623a61ab3f1345d05f169f3325ac.png"></div><br><br>  Im Allgemeinen sind nicht viele Informationen zu diesem Projekt verf√ºgbar.  Wie auf der Website angegeben, analysiert der Pr√ºfer die Amazon-Codebasen und sucht nach Pull-Anforderungen, die die AWS-API-Aufrufe enthalten, um zu erfahren, wie Abweichungen von "Best Practices" festgestellt werden k√∂nnen.  Anschlie√üend werden die vorgenommenen √Ñnderungen betrachtet und mit Daten aus der Dokumentation verglichen, die gleichzeitig analysiert werden.  Das Ergebnis ist ein "Best Practices" -Modell. <br><br>  Es wird auch gesagt, dass sich die Empfehlungen f√ºr den Benutzercode tendenziell verbessern, nachdem Feedback zu ihnen eingegangen ist. <br><br>  Die Liste der Fehler, auf die der Pr√ºfer reagiert, ist ziemlich verschwommen, da keine spezifische Fehlerdokumentation ver√∂ffentlicht wurde: <br><br><ul><li>  Best Practices AWS </li><li>  Parallelit√§t </li><li>  Ressourcenlecks </li><li>  Verlust vertraulicher Informationen </li><li>  Allgemeine "Best Practices" der Codierung </li></ul><br><h2>  Unsere Skepsis </h2><br>  Betrachten wir nun die Fehlersuche aus der Sicht unseres Teams, das seit vielen Jahren statische Analyseger√§te entwickelt.  Wir sehen eine Reihe allgemeiner Probleme bei der Anwendung von Lernmethoden, die wir gerne behandeln m√∂chten.  Zun√§chst werden wir alle ML-Ans√§tze in zwei Typen unterteilen: <br><br><ol><li>  Diejenigen, die einem statischen Analysator manuell beibringen, anhand von synthetischen und realen Codebeispielen nach verschiedenen Problemen zu suchen. </li><li>  Diejenigen, die Algorithmen f√ºr eine gro√üe Anzahl von Open-Source-Code und Revisionsverlauf (GitHub) lehren, wonach der Analysator beginnt, Fehler zu erkennen und sogar Bearbeitungen anzubieten. </li></ol><br>  Wir werden √ºber jede Richtung getrennt sprechen, da sie unterschiedliche Nachteile haben.  Danach werden die Leser, glaube ich, erfahren, warum wir die M√∂glichkeiten des maschinellen Lernens nicht leugnen, aber die Begeisterung trotzdem nicht teilen. <br><br>  <b>Hinweis</b>  Wir betrachten die Entwicklung eines universellen statischen Universalanalysators.  Wir konzentrieren uns auf die Entwicklung des Analyseger√§ts, das von jedem Team verwendet werden kann und nicht auf eine bestimmte Codebasis. <br><br><h3>  Manuelles Einlernen eines statischen Analysators </h3><br>  Angenommen, wir m√∂chten ML verwenden, um nach den folgenden Arten von Fehlern im Code zu suchen: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == A)</code> </pre> <br>  Es ist seltsam, eine Variable mit sich selbst zu vergleichen.  Wir k√∂nnen viele Beispiele f√ºr korrekten und falschen Code schreiben und dem Analysator beibringen, nach solchen Fehlern zu suchen.  Au√üerdem k√∂nnen Sie den Tests echte Beispiele bereits gefundener Fehler hinzuf√ºgen.  Nun, die Frage ist, wo solche Beispiele zu finden sind.  Ok, nehmen wir an, es ist m√∂glich.  Zum Beispiel haben wir eine Reihe von Beispielen f√ºr solche Fehler: <a href="https://www.viva64.com/en/examples/v501/">V501</a> , <a href="https://www.viva64.com/en/examples/v3001/">V3001</a> , <a href="https://www.viva64.com/en/examples/v6001/">V6001</a> . <br><br>  Ist es also m√∂glich, solche Fehler im Code mithilfe der ML-Algorithmen zu identifizieren?  Ja, das ist es.  Die Sache ist - warum brauchen wir das? <br><br>  Sehen Sie, um den Analysator zu unterrichten, m√ºssen wir viel Aufwand betreiben, um die Beispiele f√ºr den Unterricht vorzubereiten.  Eine andere M√∂glichkeit besteht darin, den Code der realen Anwendungen zu markieren und die Fragmente anzugeben, bei denen der Analysator eine Warnung ausgeben muss.  In jedem Fall muss eine Menge Arbeit geleistet werden, da es Tausende von Beispielen f√ºr das Lernen geben sollte.  Oder Zehntausende. <br><br>  Schlie√ülich wollen wir nicht nur (A == A) F√§lle erkennen, sondern auch: <br><br><ul><li>  if (X &amp;&amp; A == A) </li><li>  if (A + 1 == A + 1) </li><li>  if (A [i] == A [i]) </li><li>  if ((A) == (A)) </li><li>  und so weiter. </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19e/a51/95d/19ea5195d9075802dbdcd3feda3c4aad.png"></div><br>  Schauen wir uns die m√∂gliche Implementierung einer so einfachen Diagnose in PVS-Studio an: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RulePrototype_V501</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VivaWalker &amp;walker, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *right, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *operation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SafeEq(operation, <span class="hljs-string"><span class="hljs-string">"=="</span></span>) &amp;&amp; SafeEqual(left, right)) { walker.AddError(<span class="hljs-string"><span class="hljs-string">"Oh boy! Holy cow!"</span></span>, left, <span class="hljs-number"><span class="hljs-number">501</span></span>, Level_1, <span class="hljs-string"><span class="hljs-string">"CWE-571"</span></span>); } }</code> </pre> <br>  Und das war's auch schon!  Sie brauchen keine Beispiele f√ºr ML! <br><br>  Zuk√ºnftig muss die Diagnose lernen, eine Reihe von Ausnahmen zu ber√ºcksichtigen und Warnungen f√ºr (A [0] == A [1-1]) auszugeben.  Wie wir wissen, kann es leicht programmiert werden.  Im Gegenteil, in diesem Fall wird es mit der Basis von Beispielen schlecht. <br><br>  Beachten Sie, dass wir in beiden F√§llen ein System zum Testen, Dokumentieren usw. ben√∂tigen.  Was den Arbeitsaufwand bei der Erstellung einer neuen Diagnose anbelangt, √ºbernimmt der klassische Ansatz, bei dem die Regel fest im Code programmiert ist, die F√ºhrung. <br><br>  Ok, es ist Zeit f√ºr eine andere Regel.  Zum Beispiel die, bei der das Ergebnis einiger Funktionen verwendet werden muss.  Es hat keinen Sinn, sie anzurufen und ihr Ergebnis nicht zu verwenden.  Hier sind einige solcher Funktionen: <br><br><ul><li>  Malloc </li><li>  memcmp </li><li>  Zeichenfolge :: leer </li></ul><br>  Dies ist die <a href="https://www.viva64.com/en/w/v530/">Aufgabe</a> der PVS-Studio <a href="https://www.viva64.com/en/w/v530/">V530-</a> Diagnose. <br><br>  Wir m√∂chten also Aufrufe solcher Funktionen erkennen, deren Ergebnis nicht verwendet wird.  Dazu k√∂nnen Sie viele Tests generieren.  Und wir denken, dass alles gut funktionieren wird.  Aber auch hier ist nicht klar, warum es ben√∂tigt wird. <br><br>  Die V530-Diagnoseimplementierung nahm im PVS-Studio-Analysator mit allen Ausnahmen 258 Codezeilen in Anspruch, von denen 64 Kommentare sind.  Es gibt auch eine Tabelle mit Funktionsanmerkungen, in der darauf hingewiesen wird, dass deren Ergebnis verwendet werden muss.  Es ist viel einfacher, diese Tabelle aufzuladen, als synthetische Beispiele zu erstellen. <br><br>  Bei Diagnosen mit Datenflussanalyse wird es noch schlimmer.  Beispielsweise kann der PVS-Studio-Analysator den Wert von Zeigern verfolgen, wodurch Sie einen solchen Speicherverlust finden k√∂nnen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* BnNew() { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>[kBigIntSize]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(result, <span class="hljs-number"><span class="hljs-number">0</span></span>, kBigIntSize * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AndroidRSAPublicKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(crypto::RSAPrivateKey* key)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* n = BnNew(); .... RSAPublicKey pkey; pkey.len = kRSANumWords; pkey.exponent = <span class="hljs-number"><span class="hljs-number">65537</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Fixed public exponent pkey.n0inv = 0 - ModInverse(n0, 0x100000000LL); if (pkey.n0inv == 0) return kDummyRSAPublicKey; // &lt;= .... }</span></span></code> </pre> <br>  Das Beispiel stammt aus dem Artikel " <a href="https://www.viva64.com/en/b/0555/">Chrom: Memory Leaks</a> ".  Wenn die Bedingung <i>(pkey.n0inv == 0)</i> wahr ist, wird die Funktion beendet, ohne den Puffer <i>freizugeben</i> , auf den der Zeiger in der Variablen <i>n</i> gespeichert ist. <br><br>  Aus Sicht des PVS-Studios ist hier nichts kompliziert.  Der Analysator hat die <i>BnNew-</i> Funktion untersucht und sich daran erinnert, dass er einen Zeiger auf den zugewiesenen Speicherblock zur√ºckgegeben hat.  In einer anderen Funktion wurde festgestellt, dass der Puffer m√∂glicherweise nicht freigegeben wird und der Zeiger darauf beim Verlassen der Funktion verloren geht. <br><br>  Es ist ein √ºblicher Algorithmus zum Verfolgen von Werten.  Es ist egal, wie der Code geschrieben ist.  Es spielt keine Rolle, was sich in der Funktion noch befindet, das sich nicht auf die Zeigerarbeit bezieht.  Der Algorithmus ist universell und die V773-Diagnose findet viele Fehler in verschiedenen Projekten.  Sehen Sie, wie unterschiedlich die <a href="https://www.viva64.com/en/examples/v773/">Codefragmente</a> mit erkannten Fehlern sind! <br><br>  Wir sind keine Experten f√ºr ML, aber wir haben das Gef√ºhl, dass gro√üe Probleme hier gleich um die Ecke liegen.  Es gibt unglaublich viele M√∂glichkeiten, wie Sie Code mit Speicherlecks schreiben k√∂nnen.  Selbst wenn die Maschine gut gelernt h√§tte, wie man Werte von Variablen verfolgt, m√ºsste sie verstehen, dass es auch Aufrufe von Funktionen gibt. <br><br>  Wir vermuten, dass daf√ºr so viele Beispiele erforderlich sind, dass die Aufgabe nicht mehr greifbar ist.  Wir sagen nicht, dass es unrealistisch ist.  Wir bezweifeln, dass sich die Kosten f√ºr die Erstellung des Analysators auszahlen werden. <br><br>  <b>Analogie</b>  Was mir in den Sinn kommt, ist die Analogie zu einem Taschenrechner, bei dem man anstelle der Diagnose arithmetische Aktionen programmieren muss.  Wir sind sicher, dass Sie einem ML-basierten Rechner beibringen k√∂nnen, Zahlen gut zu summieren, indem Sie die Ergebnisse der Operationen 1 + 1 = 2, 1 + 2 = 3, 2 + 1 = 3, 100 + 200 = 300 usw. eingeben .  Wie Sie verstehen, ist die Machbarkeit der Entwicklung eines solchen Rechners eine gro√üe Frage (es sei denn, es wird ein Zuschuss gew√§hrt :).  Mit der einfachen Operation "+" im Code kann ein viel einfacher, schneller, genauer und zuverl√§ssiger Taschenrechner geschrieben werden. <br><br>  <b>Fazit</b> Nun, dieser Weg wird klappen.  Unserer Meinung nach macht es jedoch keinen praktischen Sinn, es zu verwenden.  Die Entwicklung wird zeitaufw√§ndiger, aber das Ergebnis ist weniger zuverl√§ssig und genau, insbesondere wenn es um die Implementierung komplexer Diagnosen auf der Grundlage von Datenflussanalysen geht. <br><br><h3>  Lernen mit einer gro√üen Menge an Open Source Code </h3><br>  Okay, wir haben manuelle Synthesebeispiele zusammengestellt, aber es gibt auch GitHub.  Sie k√∂nnen den Commit-Verlauf nachverfolgen und Code-√Ñnderungs- / Korrekturmuster ableiten.  Dann k√∂nnen Sie nicht nur auf Fragmente verd√§chtigen Codes verweisen, sondern auch eine M√∂glichkeit vorschlagen, den Code zu reparieren. <br><br>  Wenn Sie auf dieser Detailebene stehen bleiben, sieht alles gut aus.  Der Teufel steckt wie immer im Detail.  Sprechen wir also richtig √ºber diese Details. <br><br>  <b>Die erste Nuance.</b>  <b>Datenquelle.</b> <br><br>  GitHub-Bearbeitungen sind ziemlich zuf√§llig und vielf√§ltig.  Die Leute sind oft faul, atomare Commits zu machen und gleichzeitig mehrere √Ñnderungen im Code vorzunehmen.  Sie wissen, wie es passiert: Sie w√ºrden den Fehler beheben und ihn gleichzeitig ein wenig √ºberarbeiten ("Und hier werde ich die Behandlung eines solchen Falls hinzuf√ºgen ...").  Sogar eine Person kann dann unverst√§ndlich sein, ob diese fest miteinander verwandt sind oder nicht. <br><br>  Die Herausforderung besteht darin, tats√§chliche Fehler vom Hinzuf√ºgen neuer Funktionen oder etwas anderem zu unterscheiden.  Sie k√∂nnen nat√ºrlich 1000 Personen einstellen, die die Commits manuell markieren.  Die Leute m√ºssen darauf hinweisen: Hier wurde ein Fehler behoben, hier wird umgestaltet, hier gibt es einige neue Funktionen, hier haben sich die Anforderungen ge√§ndert und so weiter. <br><br>  Ist so ein Aufschlag m√∂glich?  Ja!  Beachten Sie jedoch, wie schnell das Spoofing erfolgt.  Anstatt "der Algorithmus lernt sich auf der Basis von GitHub" diskutieren wir bereits, wie man Hunderte von Menschen f√ºr eine lange Zeit r√§tselt.  Der Aufwand und die Kosten f√ºr die Erstellung des Tools steigen dramatisch. <br><br>  Sie k√∂nnen versuchen, automatisch festzustellen, wo die Fehler behoben wurden.  Dazu sollten Sie die Kommentare zu den Commits analysieren und auf kleine lokale √Ñnderungen achten, bei denen es sich h√∂chstwahrscheinlich um Fehlerbehebungen handelt.  Es ist schwer zu sagen, wie gut Sie automatisch nach Fehlerkorrekturen suchen k√∂nnen.  In jedem Fall ist dies eine gro√üe Aufgabe, die eine getrennte Recherche und Programmierung erfordert. <br><br>  Wir m√ºssen also noch nicht einmal lernen, und es gibt bereits Nuancen :). <br><br>  <b>Die zweite Nuance.</b>  <b>Eine Verz√∂gerung in der Entwicklung.</b> <br><br>  Analysatoren, die auf solchen Plattformen wie GitHub lernen, werden immer einem solchen Syndrom wie "mental retardation delay" ausgesetzt sein.  Dies liegt daran, dass sich die Programmiersprachen im Laufe der Zeit √§ndern. <br><br>  Seit C # 8.0 gibt es nullbare Referenztypen, die dazu beitragen, NRE (Null Reference Exceptions) zu bek√§mpfen.  In JDK 12 erschien ein neuer Vermittlungsoperator ( <a href="https://openjdk.java.net/jeps/325">JEP 325</a> ).  In C ++ 17 gibt es die M√∂glichkeit, bedingte Konstrukte zur Kompilierungszeit auszuf√ºhren ( <a href="https://www.bfilipek.com/2018/03/ifconstexpr.html">constexpr if</a> ).  Und so weiter. <br><br>  Programmiersprachen entwickeln sich weiter.  Dar√ºber hinaus entwickeln sich diejenigen wie C ++ sehr schnell.  Neue Konstruktionen erscheinen, neue Standardfunktionen werden hinzugef√ºgt und so weiter.  Neben den neuen Funktionen gibt es neue Fehlermuster, die wir auch mit der statischen Code-Analyse identifizieren m√∂chten. <br><br>  An dieser Stelle steht die ML-Methode vor einem Problem: Das Fehlermuster ist bereits klar, wir m√∂chten es erkennen, aber es gibt keine Codebasis zum Lernen. <br><br>  Schauen wir uns dieses Problem an einem bestimmten Beispiel an.  Die bereichsbasierte for-Schleife wurde in C ++ 11 angezeigt.  Sie k√∂nnen den folgenden Code schreiben, der alle Elemente im Container durchl√§uft: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) foo(num);</code> </pre> <br>  Die neue Schleife hat das neue Fehlermuster mitgebracht.  Wenn wir den Container innerhalb der Schleife √§ndern, f√ºhrt dies dazu, dass die "Schatten" -Iteratoren ung√ºltig werden. <br><br>  Schauen wir uns den folgenden falschen Code an: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Der Compiler wird es in so etwas verwandeln: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> __begin = begin(numbers), __end = end(numbers); __begin != __end; ++__begin) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = *__begin; numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  W√§hrend des <i>Push-</i> <i>Backs</i> <i>k√∂nnen die</i> Iteratoren <i>__begin</i> und <i>__end</i> ung√ºltig gemacht werden, wenn der Speicher innerhalb des Vektors <i>verschoben</i> wird.  Das Ergebnis ist das undefinierte Verhalten des Programms. <br><br>  Daher ist das Fehlermuster seit langem bekannt und in der Literatur beschrieben.  Der PVS-Studio-Analysator diagnostiziert es mit der <a href="https://www.viva64.com/en/w/v789/">V789-</a> Diagnose und hat in Open-Source-Projekten bereits <a href="https://www.viva64.com/en/examples/v789/">echte Fehler</a> gefunden. <br><br>  Wie schnell wird GitHub genug neuen Code bekommen, um dieses Muster zu bemerken?  Gute Frage ... Es ist wichtig zu bedenken, dass wenn es eine bereichsbasierte for-Schleife gibt, dies nicht bedeutet, dass alle Programmierer sofort damit beginnen, sie sofort zu verwenden.  Es kann Jahre dauern, bis die neue Schleife viel Code enth√§lt.  Au√üerdem m√ºssen viele Fehler gemacht und dann behoben werden, damit der Algorithmus das Muster in den Bearbeitungen erkennen kann. <br><br>  Wie viele Jahre wird es dauern?  F√ºnf?  Zehn? <br><br>  Zehn ist zu viel, oder ist es eine pessimistische Vorhersage?  Weit davon entfernt.  Zu dem Zeitpunkt, als der Artikel verfasst wurde, waren bereits acht Jahre vergangen, seit eine bereichsbasierte for-Schleife in C ++ 11 erschienen war.  Bisher gibt es in unserer Datenbank jedoch nur <a href="https://www.viva64.com/en/examples/v789/">drei F√§lle</a> eines solchen Fehlers.  Drei Fehler sind nicht viel und nicht wenig.  Aus dieser Zahl sollte man keine Schlussfolgerung ziehen.  Die Hauptsache ist, zu best√§tigen, dass ein solches Fehlermuster real ist und es sinnvoll ist, es zu erkennen. <br><br>  Vergleichen Sie nun beispielsweise diese Zahl mit diesem Fehlermuster: Der <a href="https://www.viva64.com/en/examples/v595/">Zeiger wird vor der Pr√ºfung dereferenziert</a> .  Insgesamt haben wir bei der Pr√ºfung von Open-Source-Projekten bereits 1.716 solcher F√§lle identifiziert. <br><br>  Vielleicht sollten wir √ºberhaupt nicht nach Fehlern in bereichsbasierten for-Schleifen suchen?  Nr  Es ist nur so, dass Programmierer tr√§ge sind und dieser Operator sehr langsam popul√§r wird.  Allm√§hlich wird es sowohl mehr Code als auch Fehler geben. <br><br>  Dies wird wahrscheinlich erst 10-15 Jahre nach Erscheinen von C ++ 11 geschehen.  Dies f√ºhrt zu einer philosophischen Frage.  Nehmen wir an, wir kennen das Fehlermuster bereits und warten viele Jahre, bis wir viele Fehler in Open Source-Projekten haben.  Wird es so sein <br><br>  Wenn "Ja", ist es sicher, "geistige Entwicklungsverz√∂gerung" f√ºr alle ML-basierten Analyseger√§te zu diagnostizieren. <br><br>  Wenn "nein", was sollen wir tun?  Es gibt keine Beispiele.  Manuell schreiben?  Auf diese Weise kehren wir zum vorherigen Kapitel zur√ºck, in dem wir eine detaillierte Beschreibung der Option gegeben haben, in der die Leute eine ganze Reihe von Beispielen f√ºr das Lernen schreiben w√ºrden. <br><br>  Dies kann getan werden, aber die Frage der Zweckm√§√üigkeit stellt sich erneut.  Die Implementierung der V789-Diagnose mit allen Ausnahmen im PVS-Studio-Analysator erfordert nur 118 Codezeilen, von denen 13 Kommentarzeilen sind.  Das hei√üt, es ist eine sehr einfache Diagnose, die auf klassische Weise leicht programmiert werden kann. <br><br>  Die Situation wird √§hnlich sein wie bei anderen Innovationen, die in einer anderen Sprache erscheinen.  Wie sie sagen, gibt es etwas zu √ºberlegen. <br><br>  <b>Die dritte Nuance.</b>  <b>Dokumentation</b> <br><br>  Ein wichtiger Bestandteil jedes statischen Analysators ist die Dokumentation, in der die einzelnen Diagnosen beschrieben werden.  Ohne diesen kann der Analysator nur sehr schwer oder gar nicht verwendet werden.  In der <a href="https://www.viva64.com/en/w/">Dokumentation zu</a> PVS-Studio finden Sie eine Beschreibung der einzelnen Diagnosen, die ein Beispiel f√ºr einen fehlerhaften Code und dessen Behebung enth√§lt.  Wir geben auch den Link zu <a href="https://cwe.mitre.org/">CWE</a> , wo man eine alternative Problembeschreibung lesen kann.  Und dennoch verstehen Benutzer manchmal etwas nicht und stellen uns kl√§rende Fragen. <br><br>  Bei ML-basierten statischen Analysatoren ist das Dokumentationsproblem irgendwie vertuscht.  Es wird davon ausgegangen, dass der Analysator lediglich auf einen Ort zeigt, der ihm verd√§chtig erscheint, und m√∂glicherweise sogar vorschl√§gt, wie er behoben werden kann.  Die Entscheidung, eine √Ñnderung vorzunehmen oder nicht, liegt bei der Person.  Hier beginnt der √Ñrger ... Es ist nicht einfach, eine Entscheidung zu treffen, ohne lesen zu k√∂nnen, was den Analyzer an einer bestimmten Stelle im Code misstrauisch erscheinen l√§sst. <br><br>  Nat√ºrlich wird in einigen F√§llen alles offensichtlich sein.  Angenommen, der Analysator verweist auf diesen Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Und schlagen vor, dass wir es ersetzen durch: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src) + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Es ist sofort klar, dass der Programmierer einen Tippfehler gemacht und 1 an der falschen Stelle hinzugef√ºgt hat.  Infolgedessen wird weniger Speicher als erforderlich zugewiesen. <br><br>  Hier ist auch ohne Dokumentation alles klar.  Dies wird jedoch nicht immer der Fall sein. <br><br>  Stellen Sie sich vor, der Analysator zeigt "still" auf diesen Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  Und schl√§gt vor, dass wir den char-Typ des R√ºckgabewerts f√ºr int √§ndern: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  Es gibt keine Dokumentation f√ºr die Warnung.  Anscheinend enth√§lt die Warnmeldung auch keinen Text, wenn es sich um einen v√∂llig unabh√§ngigen Analysator handelt. <br><br>  Was sollen wir tun  Was ist der unterschied  Lohnt sich ein solcher Ersatz? <br><br>  Eigentlich k√∂nnte ich das Risiko eingehen und zustimmen, den Code zu reparieren.  Obwohl es eine heikle √úbung ist, Fixes zu akzeptieren, ohne sie zu verstehen ... :) Sie k√∂nnen in die Beschreibung der <a href="http://www.cplusplus.com/reference/cstring/memcmp/"><i>memcmp-</i></a> Funktion <a href="http://www.cplusplus.com/reference/cstring/memcmp/"><i>schauen</i></a> und feststellen, dass die Funktion wirklich Werte wie <i>int</i> : 0, mehr als null und weniger als null zur√ºckgibt.  Es ist jedoch m√∂glicherweise immer noch unklar, warum √Ñnderungen vorgenommen werden, wenn der Code bereits ordnungsgem√§√ü funktioniert. <br><br>  Wenn Sie jetzt nicht wissen, was die Bearbeitung ist, <a href="https://www.viva64.com/en/w/v642/">lesen Sie</a> die Beschreibung der <a href="https://www.viva64.com/en/w/v642/">V642-</a> Diagnose.  Es wird sofort klar, dass dies ein echter Bug ist.  Dar√ºber hinaus kann es zu einer Sicherheitsanf√§lligkeit kommen. <br><br>  Vielleicht schien das Beispiel nicht zu √ºberzeugen.  Immerhin schlug der Analysator einen Code vor, der wahrscheinlich besser ist.  Ok  Schauen wir uns zur Abwechslung ein weiteres Beispiel f√ºr Pseudocode in Java an. <br><br><pre> <code class="cpp hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj.state = <span class="hljs-number"><span class="hljs-number">200</span></span>; out.writeObject(obj); out.close();</code> </pre> <br>  Da ist ein Gegenstand.  Es wird serialisiert.  Dann √§ndert sich der Status des Objekts und es wird erneut serialisiert.  Es sieht gut aus.  Stellen Sie sich nun vor, der Analysator mag den Code pl√∂tzlich nicht mehr und m√∂chte ihn durch den folgenden ersetzen: <br><br><pre> <code class="cpp hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); <span class="hljs-comment"><span class="hljs-comment">// The line is added obj.state = 200; out.writeObject(obj); out.close();</span></span></code> </pre> <br>  Anstatt das Objekt zu √§ndern und neu zu schreiben, wird ein neues Objekt erstellt und es wird serialisiert. <br><br>  Es gibt keine Beschreibung des Problems.  Keine Dokumentation.  Der Code ist l√§nger geworden.  Aus irgendeinem Grund wird ein neues Objekt erstellt.  Sind Sie bereit, eine solche √Ñnderung in Ihrem Code vorzunehmen? <br><br>  Du wirst sagen, es ist nicht klar.  In der Tat ist es unverst√§ndlich.  Und es wird die ganze Zeit so sein.  Die Arbeit mit einem solchen "stillen" Analyseger√§t wird eine endlose Studie sein, um zu verstehen, warum das Analyseger√§t nichts mag. <br><br>  Wenn es Dokumentation gibt, wird alles transparent.  Die f√ºr die Serialisierung verwendete Klasse <i>java.io.ObjectOuputStream speichert</i> die geschriebenen Objekte im Cache.  Dies bedeutet, dass dasselbe Objekt nicht zweimal serialisiert wird.  Die Klasse serialisiert das Objekt einmal und schreibt beim zweiten Mal nur einen Verweis auf dasselbe erste Objekt in den Stream.  <a href="https://www.viva64.com/en/w/v6076/">Weiterlesen</a> : <a href="https://www.viva64.com/en/w/v6076/">V6076</a> - Bei der wiederkehrenden Serialisierung wird der Status des zwischengespeicherten Objekts aus der ersten Serialisierung verwendet. <br><br>  Wir hoffen, wir haben es geschafft, die Wichtigkeit der Dokumentation zu erkl√§ren.  Hier kommt die Frage.  Wie erscheint die Dokumentation f√ºr den ML-basierten Analysator? <br><br>  Wenn ein klassischer Code-Analysator entwickelt wird, ist alles einfach und klar.  Es gibt ein Fehlermuster.  Wir beschreiben es in der Dokumentation und implementieren die Diagnose. <br><br>  Im Fall von ML ist der Prozess umgekehrt.  Ja, der Analysator kann eine Abweichung im Code feststellen und darauf hinweisen.  Aber es wei√ü nichts √ºber das Wesen des Mangels.  Es versteht nicht und sagt Ihnen auch nicht, warum Sie so keinen Code schreiben k√∂nnen.  Dies sind zu hochrangige Abstraktionen.  Auf diese Weise sollte der Analysator auch lernen, die Dokumentation f√ºr Funktionen zu lesen und zu <b>verstehen</b> . <br><br>  Wie gesagt, da das Dokumentationsproblem in Artikeln zum maschinellen Lernen vermieden wird, sind wir nicht bereit, weiter darauf einzugehen.  Nur eine weitere gro√üe Nuance, die wir ausgesprochen haben. <br><br>  <b>Hinweis</b>  Sie k√∂nnten argumentieren, dass die Dokumentation optional ist.  Der Analysator kann auf viele Beispiele f√ºr Korrekturen in GitHub verweisen, und die Person, die sich die Commits und Kommentare ansieht, wird verstehen, was was ist.  Ja es ist so  Aber die Idee sieht nicht attraktiv aus.  Hier ist der Analysator der b√∂se Kerl, der einen Programmierer eher verwirren wird, als ihm zu helfen. <br><br>  <b>Vierte Nuance.</b>  <b>Hochspezialisierte Sprachen.</b> <br><br>  Der beschriebene Ansatz ist nicht auf hochspezialisierte Sprachen anwendbar, f√ºr die die statische Analyse ebenfalls √§u√üerst n√ºtzlich sein kann.  Der Grund daf√ºr ist, dass GitHub und andere Quellen einfach keine ausreichende Quellcodebasis haben, um effektives Lernen zu erm√∂glichen. <br><br>  Schauen wir uns das an einem konkreten Beispiel an.  Lassen Sie uns zun√§chst zu GitHub gehen und nach Repositorys f√ºr die beliebte Java-Sprache suchen. <br><br>  Ergebnis: Sprache: "Java": <b>3.128.884</b> verf√ºgbare Repository-Ergebnisse <br><br>  Nehmen wir nun die Fachsprache ‚Äû1C Enterprise‚Äú, die in Buchhaltungsanwendungen der russischen Firma <a href="https://ru.wikipedia.org/wiki/1%25D0%25A1">1C verwendet wird</a> . <br><br>  Ergebnis: Sprache: "1C Enterprise": <b>551</b> verf√ºgbare Repository-Ergebnisse <br><br>  Vielleicht werden f√ºr diese Sprache keine Analysatoren ben√∂tigt?  Nein, das sind sie.  Es besteht ein praktischer Bedarf, solche Programme zu analysieren, und es gibt bereits geeignete Analyseger√§te.  Zum Beispiel gibt es das SonarQube 1C (BSL) Plugin der Firma " <a href="https://silverbulleters.org/">Silver Bullet</a> ". <br><br>  Ich denke, es sind keine spezifischen Erkl√§rungen erforderlich, warum der ML-Ansatz f√ºr Fachsprachen schwierig sein wird. <br><br>  <b>Die f√ºnfte Nuance.</b>  <b>C, C ++, #include</b> . <br><br>  In Artikeln zur ML-basierten statischen Code-Analyse geht es haupts√§chlich um Sprachen wie Java, JavaScript und Python.  Dies erkl√§rt sich durch ihre extreme Beliebtheit.  C und C ++ werden ignoriert, obwohl man sie nicht als unbeliebt bezeichnen kann. <br><br>  Wir schlagen vor, dass es nicht um ihre Popularit√§t / vielversprechende Aussichten geht, sondern um die Probleme mit C- und C ++ - Sprachen.  Und jetzt werden wir ein unangenehmes Problem ans Licht bringen. <br><br>  Eine abstrakte c / cpp-Datei kann sehr schwierig zu kompilieren sein.  Zumindest k√∂nnen Sie kein Projekt von GitHub laden, eine zuf√§llige cpp-Datei ausw√§hlen und sie einfach kompilieren.  Nun werden wir erkl√§ren, was dies alles mit ML zu tun hat. <br><br>  Also wollen wir den Analysator unterrichten.  Wir haben ein Projekt von GitHub heruntergeladen.  Wir kennen den Patch und gehen davon aus, dass er den Fehler behebt.  Wir m√∂chten, dass diese Bearbeitung ein Beispiel f√ºr das Lernen ist.  Mit anderen Worten, wir haben eine .cpp-Datei vor und nach der Bearbeitung. <br><br>  Hier beginnt das Problem.  Es reicht nicht aus, nur die Korrekturen zu studieren.  Der vollst√§ndige Kontext ist ebenfalls erforderlich.  Sie m√ºssen die Deklaration der verwendeten Klassen kennen, Sie m√ºssen die Prototypen der verwendeten Funktionen kennen, Sie m√ºssen wissen, wie Makros erweitert werden und so weiter.  Dazu m√ºssen Sie eine vollst√§ndige Dateivorbearbeitung durchf√ºhren. <br><br>  Schauen wir uns das Beispiel an.  Der Code sah zun√§chst so aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_name == <span class="hljs-string"><span class="hljs-string">"ML"</span></span>; }</code> </pre> <br>  Es wurde auf diese Weise behoben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(m_name, <span class="hljs-string"><span class="hljs-string">"ML"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Sollte der Analysator anfangen zu lernen, um <i>(x == "y")</i> Ersatz f√ºr strcmp (x, "y") vorzuschlagen? <br><br>  Sie k√∂nnen diese Frage nicht beantworten, ohne zu wissen, wie das <i>Member m_name</i> in der Klasse deklariert ist.  Es k√∂nnte zum Beispiel solche Optionen geben: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *m_name; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_name; };</code> </pre> <br>  √Ñnderungen werden vorgenommen, falls es sich um einen normalen Zeiger handelt.  Wenn wir den Variablentyp nicht ber√ºcksichtigen, lernt der Analysator m√∂glicherweise, sowohl gute als auch schlechte Warnungen auszugeben (f√ºr den Fall mit <i>std :: string</i> ). <br><br>  Klassendeklarationen befinden sich normalerweise in Header-Dateien.  Hier bestand die Notwendigkeit, eine Vorverarbeitung durchzuf√ºhren, um alle notwendigen Informationen zu erhalten.  Es ist extrem wichtig f√ºr C und C ++. <br><br>  Wenn jemand sagt, dass es m√∂glich ist, auf eine Vorverarbeitung zu verzichten, ist er entweder ein Betr√ºger oder nur mit C- oder C ++ -Sprachen nicht vertraut. <br><br>  Um alle notwendigen Informationen zu sammeln, ben√∂tigen Sie eine korrekte Vorverarbeitung.  Dazu m√ºssen Sie wissen, wo und welche Header-Dateien sich befinden und welche Makros w√§hrend des Erstellungsprozesses festgelegt werden.  Sie m√ºssen auch wissen, wie eine bestimmte cpp-Datei kompiliert wird. <br><br>  Das ist das Problem.  Man kompiliert die Datei nicht einfach (oder spezifiziert vielmehr den Schl√ºssel f√ºr den Compiler, damit er eine Vorverarbeitungsdatei erzeugt).  Wir m√ºssen herausfinden, wie diese Datei kompiliert wird.  Diese Informationen sind in den Build-Skripten enthalten, die Frage ist jedoch, wie Sie sie von dort abrufen k√∂nnen.  Im Allgemeinen ist die Aufgabe kompliziert. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91b/aaf/95a/91baaf95a62415697b40f23298d115c2.png"></div><br><br>  Dar√ºber hinaus sind viele Projekte auf GitHub ein Chaos.  Wenn Sie ein abstraktes Projekt von dort nehmen, m√ºssen Sie oft basteln, um es zu kompilieren.  Eines Tages fehlt Ihnen eine Bibliothek und Sie m√ºssen sie manuell suchen und herunterladen.  An einem anderen Tag wird eine Art selbst geschriebenes Build-System verwendet, das behandelt werden muss.  Es k√∂nnte alles sein.  Manchmal l√§sst sich das heruntergeladene Projekt einfach nicht erstellen und muss irgendwie angepasst werden.  Sie k√∂nnen nicht einfach eine vorverarbeitete (.i) Darstellung f√ºr .cpp-Dateien erstellen und automatisch abrufen.  Es kann schwierig sein, auch wenn Sie es manuell tun. <br><br>  Wir k√∂nnen sagen, dass das Problem mit Nichtbauprojekten verst√§ndlich, aber nicht entscheidend ist.  Arbeiten wir nur mit Projekten, die erstellt werden k√∂nnen.  Es bleibt noch die Aufgabe, eine bestimmte Datei vorzuverarbeiten.  Ganz zu schweigen von den F√§llen, in denen wir uns mit einigen spezialisierten Compilern befassen, zum Beispiel f√ºr eingebettete Systeme. <br><br>  Immerhin ist das beschriebene Problem nicht un√ºberwindbar.  All dies ist jedoch sehr schwierig und arbeitsintensiv.  Im Falle von C und C ++ hat der auf GitHub befindliche Quellcode keine Wirkung.  Es ist viel zu tun, um zu lernen, wie Compiler automatisch ausgef√ºhrt werden. <br><br>  <b>Hinweis</b>  Wenn der Leser die Tiefe des Problems immer noch nicht kennt, laden wir Sie ein, an dem folgenden Experiment teilzunehmen.  Nehmen Sie zehn mittelgro√üe Zufallsprojekte aus GitHub und versuchen Sie, sie zu kompilieren und erhalten Sie dann ihre vorverarbeitete Version f√ºr CPP-Dateien.  Danach verschwindet die Frage nach der M√ºhsamkeit dieser Aufgabe :). <br><br>  Es kann √§hnliche Probleme mit anderen Sprachen geben, die jedoch in C und C ++ besonders offensichtlich sind. <br><br>  <b>Sechste Nuance.</b>  <b>Der Preis f√ºr die Beseitigung von Fehlalarmen.</b> <br><br>  Statische Analyseger√§te neigen dazu, Fehlalarme zu generieren, und wir m√ºssen die Diagnose st√§ndig verfeinern, um die Anzahl der Fehlalarme zu verringern. <br><br>  Jetzt <a href="https://www.viva64.com/en/w/v789/">kehren</a> wir zur zuvor betrachteten <a href="https://www.viva64.com/en/w/v789/">V789-</a> Diagnose zur√ºck und erkennen Container√§nderungen innerhalb der <a href="https://www.viva64.com/en/w/v789/">bereichsbasierten</a> for-Schleife.  Nehmen wir an, wir waren beim Schreiben nicht vorsichtig genug und der Kunde meldet ein falsches Positiv.  Er schreibt, dass der Analysator das Szenario nicht ber√ºcksichtigt, wenn die Schleife endet, nachdem der Container gewechselt wurde, und daher kein Problem besteht.  Dann gibt er das folgende Codebeispiel an, in dem der Analysator ein falsches Positiv ausgibt: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { numbers.push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">// or, for example, return } }</span></span></code> </pre> <br>  Ja, das ist ein Fehler.  In einem klassischen Analyseger√§t ist die Eliminierung extrem schnell und kosteng√ºnstig.  In PVS-Studio besteht die Implementierung dieser Ausnahme aus 26 Codezeilen. <br><br>  Dieser Fehler kann auch behoben werden, wenn der Analysator auf Lernalgorithmen basiert.  Es kann mit Sicherheit gelehrt werden, indem Dutzende oder Hunderte von Codebeispielen gesammelt werden, die als korrekt angesehen werden sollten. <br><br>  Auch hier geht es nicht um Machbarkeit, sondern um praktischen Ansatz.  Wir vermuten, dass der Kampf gegen bestimmte Fehlalarme, die die Kunden st√∂ren, bei ML weitaus kostspieliger ist.  Das hei√üt, die Kundenunterst√ºtzung bei der Beseitigung von Fehlalarmen kostet mehr Geld. <br><br>  <b>Siebte Nuance.</b>  <b>Selten genutzte Features und langer Schwanz.</b> <br><br>  Bisher haben wir uns mit dem Problem der hochspezialisierten Sprachen auseinandergesetzt, f√ºr die m√∂glicherweise nicht genug Quellcode zum Lernen vorhanden ist.  Ein √§hnliches Problem tritt bei selten verwendeten Funktionen auf (Systemfunktionen, WinAPI, aus g√§ngigen Bibliotheken usw.). <br><br>  Wenn wir √ºber solche Funktionen aus der C-Sprache sprechen, wie <i>strcmp</i> , dann gibt es tats√§chlich eine <i>Lernbasis</i> .  GitHub, verf√ºgbare Code-Ergebnisse: <br><br><ul><li>  strcmp - 40,462,158 </li><li>  stricmp - 1,256,053 </li></ul><br>  Ja, es gibt viele Anwendungsbeispiele.  Vielleicht lernt der Analysator, zum Beispiel die folgenden Muster zu bemerken: <br><br><ul><li>  Es ist seltsam, wenn die Zeichenfolge mit sich selbst verglichen wird.  Es wird behoben. </li><li>  Es ist seltsam, wenn einer der Zeiger NULL ist.  Es wird behoben. </li><li>  Es ist seltsam, dass das Ergebnis dieser Funktion nicht verwendet wird.  Es wird behoben. </li><li>  Und so weiter. </li></ul><br>  Ist es nicht cool?  Nr  Hier stehen wir vor dem Problem des "langen Schwanzes".  Ganz kurz die Spitze des "langen Schwanzes" im Folgenden.  Es ist unpraktisch, nur die Top50 der beliebtesten und derzeit gelesenen B√ºcher in einem Buchladen zu verkaufen.  Ja, jedes dieser B√ºcher wird beispielsweise 100-mal h√§ufiger gekauft als B√ºcher, die nicht von dieser Liste stammen.  Der Gro√üteil des Erl√∂ses wird jedoch aus anderen B√ºchern bestehen, die, wie sie sagen, ihren Leser finden.  Zum Beispiel erh√§lt ein Online-Shop Amazon.com mehr als die H√§lfte der Gewinne aus nicht mehr als 130.000 "beliebtesten Artikeln". <br><br>  Es gibt beliebte Funktionen, von denen es nur wenige gibt.  Es gibt unpopul√§re, aber es gibt viele von ihnen.  Beispielsweise gibt es die folgenden Variationen der Zeichenfolgenvergleichsfunktion: <br><br><ul><li>  g_ascii_strncasecmp - 35.695 </li><li>  lstrcmpiA - 27,512 </li><li>  _wcsicmp_l - 5.737 </li><li>  _strnicmp_l - 5.848 </li><li>  _mbscmp_l - 2.458 </li><li>  und andere. </li></ul><br>  Wie Sie sehen, werden sie viel seltener verwendet, aber wenn Sie sie verwenden, k√∂nnen Sie dieselben Fehler machen.  Es gibt zu wenige Beispiele, um Muster zu identifizieren.  Diese Funktionen k√∂nnen jedoch nicht ignoriert werden.  Einzeln werden sie selten verwendet, aber mit ihrer Verwendung wird viel Code geschrieben, der besser √ºberpr√ºft werden sollte.  Hier zeigt sich der "lange Schwanz". <br><br>  Bei PVS-Studio werden Funktionen manuell mit Anmerkungen versehen.  Zum Beispiel wurden bis jetzt ungef√§hr 7.200 Funktionen f√ºr C und C ++ kommentiert.  Dies ist, was wir markieren: <br><br><ul><li>  Winapi </li><li>  Standard C-Bibliothek, </li><li>  Standard Template Library (STL), </li><li>  glibc (GNU C-Bibliothek) </li><li>  Qt </li><li>  Mfc </li><li>  zlib </li><li>  libpng </li><li>  √ñffnetsl </li><li>  und andere. </li></ul><br>  Einerseits scheint es eine Sackgasse zu sein.  Sie k√∂nnen nicht alles mit Anmerkungen versehen.  Auf der anderen Seite funktioniert es. <br><br>  Nun ist hier die Frage.  Welche Vorteile kann ML haben?  Wesentliche Vorteile sind nicht so offensichtlich, aber Sie k√∂nnen die Komplexit√§t sehen. <br><br>  Man k√∂nnte argumentieren, dass Algorithmen, die auf ML selbst aufbauen, Muster mit h√§ufig verwendeten Funktionen finden und nicht kommentiert werden m√ºssen.  Ja, das stimmt.  Es ist jedoch kein Problem, beliebte Funktionen wie <i>strcmp</i> oder <i>malloc</i> unabh√§ngig voneinander zu kommentieren. <br><br>  Trotzdem bereitet der lange Schwanz Probleme.  Sie k√∂nnen unterrichten, indem Sie synthetische Beispiele erstellen.  Hier kehren wir jedoch zum Artikelteil zur√ºck, in dem wir sagten, es sei einfacher und schneller, klassische Diagnosen zu schreiben, als viele Beispiele zu generieren. <br><br>  Nehmen Sie zum Beispiel eine Funktion wie <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a> .  Nat√ºrlich wird es seltener als <i>Fread verwendet</i> .  Aber wenn Sie es verwenden, k√∂nnen Sie die gleichen Fehler machen.  Beispielsweise sollte der Puffer gro√ü genug sein.  Diese Gr√∂√üe sollte nicht kleiner sein als das Ergebnis der Multiplikation des zweiten und dritten Arguments.  Das hei√üt, Sie m√∂chten einen solchen falschen Code finden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buffer[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n = _fread_nolock(buffer, size_of(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-number"><span class="hljs-number">100</span></span>, stream);</code> </pre> <br>  So sieht die Annotation dieser Funktion in PVS-Studio aus: <br><br><pre> <code class="cpp hljs">C_<span class="hljs-string"><span class="hljs-string">"size_t _fread_nolock"</span></span> <span class="hljs-string"><span class="hljs-string">"(void * _DstBuf, size_t _ElementSize, size_t _Count, FILE * _File);"</span></span> ADD(HAVE_STATE | RET_SKIP | F_MODIFY_PTR_1, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-string"><span class="hljs-string">"_fread_nolock"</span></span>, POINTER_1, BYTE_COUNT, COUNT, POINTER_2). Add_Read(from_2_3, to_return, buf_1). Add_DataSafetyStatusRelations(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Auf den ersten Blick mag eine solche Annotation schwierig aussehen, aber tats√§chlich wird es einfach, wenn Sie anfangen, sie zu schreiben.  Plus, es ist schreibgesch√ºtzter Code.  Schrieb und verga√ü.  Anmerkungen √§ndern sich selten. <br><br>  Lassen Sie uns nun √ºber diese Funktion aus der Sicht von ML sprechen.  GitHub wird uns nicht helfen.  Es gibt ungef√§hr 15.000 Erw√§hnungen dieser Funktion.  Es gibt noch weniger guten Code.  Ein wesentlicher Teil der Suchergebnisse nimmt Folgendes ein: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> fread_unlocked _fread_nolock</span></span></code> </pre> <br>  Welche M√∂glichkeiten gibt es? <ol><li>  Tu nichts.  Es ist ein Weg ins Nirgendwo. </li><li>  Stellen Sie sich vor, Sie lehren den Analysator, indem Sie Hunderte von Beispielen nur f√ºr eine Funktion schreiben, damit der Analysator die Verbindung zwischen dem Puffer und anderen Argumenten versteht.  Ja, das k√∂nnen Sie, aber es ist wirtschaftlich irrational.  Es ist eine Sackgasse. </li><li>  Sie k√∂nnen einen √§hnlichen Weg wie den unseren finden, wenn die Anmerkungen zu Funktionen manuell festgelegt werden.  Es ist ein guter, vern√ºnftiger Weg.  Das ist nur ML, was nichts damit zu tun hat :).  Dies ist ein R√ºckfall auf die klassische Art, statische Analysatoren zu schreiben. </li></ol><br>  Wie Sie sehen, passen ML und der lange Schwanz der selten verwendeten Features nicht zusammen. <br><br>  Zu diesem Zeitpunkt gab es mit ML verwandte Personen, die Einw√§nde erhoben und sagten, dass wir nicht in Betracht gezogen h√§tten, wann der Analysator alle Funktionen lernen und Schlussfolgerungen daraus ziehen w√ºrde, was er tut.  Hier verstehen wir anscheinend entweder die Experten nicht oder sie verstehen unseren Standpunkt nicht. <br><br>  K√∂rper von Funktionen k√∂nnen unbekannt sein.  Beispielsweise k√∂nnte es sich um eine WinAPI-bezogene Funktion handeln.  Wenn dies eine selten verwendete Funktion ist, wie wird der Analysator verstehen, was er tut?  Wir k√∂nnen uns vorstellen, dass der Analysator Google selbst verwendet, eine Beschreibung der Funktion findet, sie liest und <b>versteht</b> .  Dar√ºber hinaus m√ºsste es aus der Dokumentation Schlussfolgerungen auf hoher Ebene ziehen.  Die Beschreibung von <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a> sagt nichts √ºber die Verbindung zwischen dem Puffer, dem zweiten und dem dritten Argument aus.  Dieser Vergleich sollte durch k√ºnstliche Intelligenz allein abgeleitet werden, basierend auf einem Verst√§ndnis der allgemeinen Prinzipien der Programmierung und der Funktionsweise der C ++ - Sprache.  Ich denke, wir sollten in 20 Jahren ernsthaft dar√ºber nachdenken. <br><br>  M√∂glicherweise sind Funktionsk√∂rper verf√ºgbar, die jedoch m√∂glicherweise nicht verwendet werden k√∂nnen.  Sehen wir uns eine Funktion wie <i>memmove an</i> .  Es wird oft so implementiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memmove</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dest, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __builtin___memmove_chk(dest, src, len, __builtin_object_size(dest, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br>  Was ist <i>__builtin___memmove_chk</i> ?  Dies ist eine intrinsische Funktion, die der Compiler selbst bereits implementiert.  Diese Funktion verf√ºgt nicht √ºber den Quellcode. <br><br>  Oder <i>memmove</i> sieht <i>ungef√§hr</i> so aus: <a href="">Die erste Assembly-Version</a> .  Sie k√∂nnen dem Analysator beibringen, verschiedene Montageoptionen zu verstehen, aber ein solcher Ansatz scheint falsch zu sein. <br><br>  Ok, manchmal sind K√∂rper von Funktionen wirklich bekannt.  Dar√ºber hinaus kennen wir auch K√∂rper von Funktionen im Code des Benutzers.  Es scheint, dass ML in diesem Fall enorme Vorteile hat, wenn man liest und versteht, was all diese Funktionen bewirken. <br><br>  Aber auch in diesem Fall sind wir voller Pessimismus.  Diese Aufgabe ist zu komplex.  Es ist sogar f√ºr einen Menschen kompliziert.  √úberlegen Sie, wie schwierig es f√ºr Sie ist, den Code zu verstehen, den Sie nicht geschrieben haben.  Wenn es f√ºr eine Person schwierig ist, warum sollte diese Aufgabe f√ºr eine KI einfach sein?  Tats√§chlich hat AI ein gro√ües Problem beim Verst√§ndnis von Konzepten auf hoher Ebene.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir √ºber das Verstehen des Codes sprechen, k√∂nnen wir nicht auf die F√§higkeit verzichten, die Details der Implementierung zu abstrahieren und den Algorithmus auf einer hohen Ebene zu betrachten. Es scheint, dass diese Diskussion auch um 20 Jahre verschoben werden kann. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Nuancen</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es gibt andere Punkte, die ebenfalls ber√ºcksichtigt werden sollten, auf die wir jedoch nicht n√§her eingegangen sind. Der Artikel f√§llt √ºbrigens recht lang aus. Deshalb werden wir einige andere Nuancen kurz auflisten und sie dem Leser zum Nachdenken √ºberlassen.</font></font><br><br><ul><li> <b>Outdated recommendations.</b> As mentioned, languages change, and recommendations for their use change, respectively. If the analyzer learns on old source code, it might start issuing outdated recommendations at some point. Example. Formerly, C++ programmers have been recommended using <a href="http://www.cplusplus.com/reference/memory/auto_ptr/"><i>auto_ptr</i></a> instead of half-done pointers. This smart pointer is now considered obsolete and it is recommended that you use <i>unique_ptr</i> . </li><li> <b>Data models.</b> At the very least, C and C++ languages have such a thing as a <a href="https://www.viva64.com/en/t/0012/">data model</a> . This means that data types have different number of bits across platforms. If you don't take this into account, you can incorrectly teach the analyzer. For example, in Windows 32/64 the <i>long</i> type always has 32 bits. But in Linux, its size will vary and take 32/64 bits depending on the platform's number of bits. Without taking all this into account, the analyzer can learn to miscalculate the size of the types and structures it forms. But the types also align in different ways. All this, of course, can be taken into account. You can teach the analyzer to know about the size of the types, their alignment and mark the projects (indicate how they are building). However, all this is an additional complexity, which is not mentioned in the research articles. </li><li> <b>Behavioral unambiguousness.</b> Since we're talking about ML, the analysis result is more likely to have probabilistic nature. That is, sometimes the erroneous pattern will be recognized, and sometimes not, depending on how the code is written. From our experience, we know that the user is extremely irritated by the ambiguity of the analyzer's behavior. He wants to know exactly which pattern will be considered erroneous and which will not, and why. In the case of the classical analyzer developing approach, this problem is poorly expressed. Only sometimes we need to explain our clients why there is a/there is no analyzer warning and how the algorithm works, what exceptions are handled in it. Algorithms are clear and everything can always be easily explained. An example of this kind of communication: " <a href="https://www.viva64.com/en/b/0612/">False Positives in PVS-Studio: How Deep the Rabbit Hole Goes</a> ". It's not clear how the described problem will be solved in the analyzers built on ML. </li></ul><br><h2> Conclusions </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir bestreiten nicht die Aussichten der ML-Richtung, einschlie√ülich ihrer Anwendung in Bezug auf die statische Code-Analyse. ML kann potenziell bei der Suche nach Tippfehlern, beim Filtern von False Positives, bei der Suche nach neuen (noch nicht beschriebenen) Fehlermustern usw. verwendet werden. Wir teilen jedoch nicht den Optimismus, der die Artikel √ºber ML in Bezug auf die Code-Analyse durchdringt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Artikel haben wir einige Probleme umrissen, an denen man arbeiten muss, wenn er ML verwenden will. Die beschriebenen Nuancen machen die Vorteile des neuen Ansatzes weitgehend zunichte. Dar√ºber hinaus sind die alten klassischen Ans√§tze der Implementierung von Analysatoren rentabler und wirtschaftlicher.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interessanterweise erw√§hnen die Artikel der Anh√§nger der ML-Methodik diese Fallstricke nicht. </font><font style="vertical-align: inherit;">Naja, nichts neues. </font><font style="vertical-align: inherit;">ML ist ein gewisser Hype, und wir sollten wahrscheinlich keine ausgewogene Einsch√§tzung der ML-Anwendbarkeit bei statischen Code-Analyse-Aufgaben von seinen Entschuldigern erwarten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus unserer Sicht wird maschinelles Lernen eine Nische in Technologien f√ºllen, die in statischen Analyseger√§ten zusammen mit Kontrollflussanalysen, symbolischen Ausf√ºhrungen und anderen verwendet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Methode der statischen Analyse kann von der Einf√ºhrung von ML profitieren, aber √ºbertreiben Sie nicht die M√∂glichkeiten dieser Technologie.</font></font><br><br><h2>  PS </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da der Artikel im Allgemeinen kritisch ist, k√∂nnten einige denken, wir f√ºrchten das Neue und als </font></font><a href="https://en.wikipedia.org/wiki/Luddite"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luddites</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sich gegen ML wandte, weil sie bef√ºrchten, den Markt f√ºr statische Analysewerkzeuge zu verlieren.</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/659/1f4/7fa/6591f47faa384c2ac9472bc1f5eeacb9.png" alt="Luddites"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nein, wir haben keine Angst. Wir sehen keinen Sinn darin, Geld f√ºr ineffiziente Ans√§tze in der Entwicklung des PVS-Studio-Code-Analysators auszugeben. In der einen oder anderen Form werden wir ML √ºbernehmen. Dar√ºber hinaus enthalten einige Diagnosen bereits Elemente von selbstlernenden Algorithmen. Wir werden jedoch auf jeden Fall sehr konservativ sein und nur das nehmen, was eindeutig eine gr√∂√üere Wirkung hat als die klassischen Ans√§tze, die auf Schleifen und Ifs basieren :). Schlie√ülich m√ºssen wir ein effektives Tool erstellen, nicht einen Zuschuss abarbeiten :). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Artikel wurde aus dem Grund geschrieben, dass immer mehr Fragen zum Thema gestellt werden und wir wollten einen Expository-Artikel, der alles an seine Stelle stellt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielen Dank f√ºr Ihre Aufmerksamkeit. Wir laden Sie ein, den Artikel zu lesen "</font></font><a href="https://www.viva64.com/en/b/0687/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum Sie sich f√ºr den statischen Analysator von PVS-Studio entscheiden sollten, um ihn in Ihren Entwicklungsprozess zu integrieren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . "</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484202/">https://habr.com/ru/post/de484202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484192/index.html">Einfache und leicht zu implementierende Anwendungen auf Tarantool Cartridge (Teil 2)</a></li>
<li><a href="../de484194/index.html">Kubernetes √ºbersetzt in Kinder</a></li>
<li><a href="../de484196/index.html">Aufnahme von JS-Ton √ºber ein Mikrofon oder Sprachkommentare</a></li>
<li><a href="../de484198/index.html">R√ºckseite der Medaille: Wer hat beim Wachstum der Tesla-Aktien gewonnen und verloren?</a></li>
<li><a href="../de484200/index.html">Wie man Ziele setzt, um sie zu erreichen</a></li>
<li><a href="../de484204/index.html">FTCODE fileless Ransomware stiehlt jetzt Konten</a></li>
<li><a href="../de484206/index.html">Verwendung von Mixins in Dart</a></li>
<li><a href="../de484208/index.html">Verwendung des maschinellen Lernens bei der statischen Analyse des Programmquellcodes</a></li>
<li><a href="../de484212/index.html">Free stuff for karma - die Geschichte eines belarussischen Startups, das das Konsumprinzip √§ndert</a></li>
<li><a href="../de484214/index.html">Tensoren in TensorFlow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>