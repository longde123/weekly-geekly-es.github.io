<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎶 👴 🛒 Waktu untuk byte pertama: apa itu dan mengapa itu penting 👨🏾‍🏭 👩‍⚖️ 🧜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sekarang saya sedang mengerjakan proyek untuk satu klien. Ini adalah situs e-commerce, jadi saya sangat tertarik dengan beberapa aspek kinerja. Sebaga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Waktu untuk byte pertama: apa itu dan mengapa itu penting</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/470868/">  Sekarang saya sedang mengerjakan proyek untuk satu klien.  Ini adalah situs e-commerce, jadi saya sangat tertarik dengan beberapa aspek kinerja.  Sebagai permulaan, ini adalah berbagai indikator yang mencirikan waktu pemuatan suatu situs.  Berikutnya - ini adalah waktu mulai merender halaman, yang penting bagi pengunjung yang, setelah memasuki situs, ingin melihat isinya secepat mungkin (tentu saja, semua pengunjung situs termasuk dalam kategori ini).  Di antara indikator kinerja yang menarik minat saya adalah yang mencerminkan spesifikasi aktivitas klien saya.  Misalnya: "Seberapa cepat gambar utama memuat produk?"  Analisis semua indikator ini dapat memberikan informasi berharga tentang keadaan proyek. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/tq/4b/8i/tq4b8ifmpqelzhiw5uzboghocp8.jpeg"></a> <br><br>  Namun, ada satu indikator, yang, sepertinya, pengembang front-end sering tidak memperhatikan.  Sudah waktunya untuk byte pertama (Waktu ke Byte Pertama, TTFB).  Anda dapat memahami ini, Anda dapat dan setidaknya memaafkan sebagian pengembang atas sikap terhadap TTFB, terutama mengingat fakta bahwa mereka melihat indikator ini sebagai sesuatu yang hanya bergantung pada bagian belakang proyek.  Tetapi jika kita mencoba untuk secara singkat mengungkapkan masalah mengenai indikator ini, maka kita dapat mengatakan yang berikut: "Meskipun nilai TTFB yang baik tidak selalu berarti bahwa situs web yang mendemonstrasikannya dapat dianggap cepat, indikator TTFB yang buruk hampir pasti mengindikasikan masalah dengan kinerja proyek." <br><a name="habracut"></a><br>  Bahkan jika kita memperhitungkan fakta bahwa pengembang front-end mungkin berada dalam posisi di mana ia tidak dapat memengaruhi backend dan TTFB secara independen, penting untuk mempertimbangkan fakta bahwa nilai-nilai TTFB yang tinggi dapat secara signifikan mempengaruhi kinerja situs.  Akibatnya, upaya pengembang front-end yang berjuang untuk kecepatan situs web akan menyerupai game catch-up.  Ini berlaku, misalnya, untuk pengoptimalan gambar, dan untuk meminimalkan volume materi yang membentuk bagian paling penting dari proyek, dan untuk mengunduh font web secara asinkron.  Ini bukan untuk mengatakan bahwa, mengetahui hal ini, Anda dapat menyerah dan mengabaikan optimisasi front-end.  Tetapi jika TTFB terlalu tinggi, maka semua optimasi tersebut mengingatkan untuk mencoba memperbaiki masalah dalam kondisi ketika sudah membahayakan, dan ketika sudah terlambat untuk memperbaiki masalah ini.  Faktanya, itu sebabnya sangat penting bagi mereka yang mengembangkan front-end untuk memonitor indikator TTFB, dan sangat penting, ketika nilainya terlalu tinggi, mengambil langkah-langkah untuk memperbaikinya. <br><br><h2>  <font color="#3AC1EF">Apa itu TTFB?</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/620/d0b/fe1/620d0bfe1034ff0d0c565f459ad2aa79.png"></div><br>  <i><font color="#999999">TTFB tidak terlihat sangat informatif ( <a href="">gambar ukuran penuh</a> )</font></i> <br><br>  TTFB adalah indikator yang terlihat, lebih tepatnya, buram.  Begitu banyak yang dipengaruhi olehnya sehingga saya merasa bahwa kita semua hanya menghabiskan analisisnya yang serius.  Banyak yang berspekulasi bahwa TTFB hanyalah waktu yang dibutuhkan server untuk menyiapkan respons, tetapi kenyataannya, hanya sebagian kecil dari apa yang memengaruhi TTFB. <br><br>  Hal pertama yang saya ingin menarik perhatian Anda adalah setelah mengetahui apa yang biasanya orang sangat terkejut.  Kita berbicara tentang fakta bahwa TTFB mencakup waktu ketika permintaan dari klien berpindah jaringan ke server, dan waktu yang dibutuhkan jalur tanggapan server ke klien.  Inilah yang disebut "waktu perjalanan pulang pergi" (Round Trip Time, RTT).  TTFB bukan hanya beberapa waktu yang dihabiskan oleh server menyiapkan tanggapan.  Ini juga merupakan waktu yang dihabiskan untuk cara data berpindah dari klien ke server dan dari server ke klien (data ini, tentu saja, berisi "byte pertama" yang menarik bagi kami). <br><br>  Sekarang, dengan berbekal pengetahuan ini, kita dapat dengan mudah memahami alasan bahwa ketika melihat situs dari perangkat seluler, indikator TTFB sering kali tidak besar.  Sangat mungkin bahwa sebelumnya dalam situasi seperti itu Anda akan bertanya sesuatu seperti ini: "Saya yakin server tidak tahu bahwa saya melihat situs dari ponsel.  Lalu bagaimana cara meningkatkan TTFB? ”  Alasannya adalah karena koneksi jaringan seluler adalah koneksi latensi tinggi.  Jika indikator RTT, yang mencerminkan waktu yang diperlukan untuk data untuk melakukan perjalanan dari telepon ke server dan kembali, misalnya, 250 ms, maka TTFB akan meningkat dengan nilai yang sesuai. <br><br>  Jika saya ingin pembaca materi ini hanya mengambil satu ide utama darinya, maka saya akan merumuskan ide ini sebagai berikut: "Keterlambatan jaringan memengaruhi TTFB." <br><br>  Apa lagi yang memengaruhi TTFB?  Bahkan - banyak semuanya.  Berikut ini adalah daftar yang jauh dari lengkap tentang apa yang berkontribusi pada pembentukan indikator ini.  Item dalam daftar ini dalam urutan acak. <br><br><ul><li>  <b>Keterlambatan jaringan.</b>  Seperti yang telah disebutkan, TTFB mencakup waktu yang diperlukan untuk mengirimkan permintaan ke server dan mengembalikan respons dari server.  Ambil, misalnya, waktu yang diperlukan untuk sesi pertukaran data antara perangkat yang berlokasi di London dan server yang berlokasi di New York.  Idealnya, saat menggunakan koneksi serat optik, ini adalah 28 ms.  Tetapi ini didasarkan pada banyak asumsi yang sangat optimis.  Pada kenyataannya, Anda harus mengharapkan sekitar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">75 ms</a> .  Itulah mengapa sangat penting untuk menggunakan CDN.  Bahkan sekarang, di zaman Internet, kedekatan geografis suatu bisnis dan pelanggannya merupakan keuntungan. </li><li>  <b>Routing</b>  Jika Anda menggunakan CDN (dan memang seharusnya begitu!), Maka permintaan klien Anda, katakanlah, dari Leeds, dapat dialihkan ke pusat data MAN saja sehingga ternyata sumber daya yang dibutuhkan klien tidak ada dalam cache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PoP yang</a> sesuai .  Kemudian permintaan akan dialihkan ke server nyata dengan materi Anda untuk tetap mengirimkan kepada klien apa yang dibutuhkan.  Jika server ini berlokasi, misalnya, di Virginia, maka semua hal di atas akan menyebabkan peningkatan TTFB yang serius tanpa alasan yang jelas. </li><li>  <b>Bekerja dengan file.</b>  Bahkan jika server hanya membaca data statis dari sistem file-nya, seperti gambar atau file gaya, dibutuhkan beberapa waktu untuk menyelesaikan operasi ini.  Kali ini juga merupakan bagian dari TTFB. </li><li>  <b>Prioritas</b>  Protokol HTTP / 2 memiliki mekanisme untuk memprioritaskan pemrosesan permintaan.  Akibatnya, mungkin ternyata permintaan prioritas rendah dapat ditunda di server, memberikan jalan bagi permintaan prioritas tinggi.  Bahkan jika Anda tidak memperhitungkan mekanisme prioritas HTTP / 2 dan menganggap bahwa semuanya berfungsi dengan lancar, penundaan yang diharapkan ini dapat berkontribusi pada TTFB. </li><li>  <b>Menjalankan aplikasi.</b>  Ini, pada kenyataannya, cukup jelas, tetapi saya ingin mencatat bahwa waktu yang diperlukan untuk menjalankan aplikasi server secara serius mempengaruhi TTFB. </li><li>  <b>Permintaan basis data.</b>  Jika Anda perlu meminta sesuatu dari database untuk membentuk halaman, maka waktu untuk menyelesaikan operasi semacam itu juga akan dimasukkan dalam TTFB. </li><li>  <b>Panggilan API</b>  Jika data dari API tertentu (internal atau eksternal) diperlukan untuk menyiapkan halaman, maka panggilan ke API ini akan memengaruhi TTFB. </li><li>  <b>Render server</b>  Sangat jelas bahwa rendering sisi server membutuhkan waktu, kali ini mudah untuk dievaluasi, tetapi ini tidak meniadakan kontribusi operasi ini ke TTFB. </li><li>  <b>Hosting murah.</b>  Jika Anda menggunakan hosting murah, berusaha menghemat sebanyak mungkin dan mengorbankan kinerja, ini biasanya berarti bahwa sejumlah proyek lain menggunakan server di mana proyek Anda berada.  Mungkin jumlah yang cukup banyak.  Akibatnya, seseorang yang menggunakan hosting murah dapat mengharapkan penurunan kinerja server, yang dapat memengaruhi kemampuan proyek untuk memproses permintaan.  Bahkan, kita berbicara tentang fakta bahwa kekuatan perangkat keras server tidak cukup untuk memenuhi kebutuhan aplikasi. </li><li>  <b>Serangan DDoS, beban tinggi pada proyek.</b>  Di sini kita melanjutkan topik yang dibahas dalam paragraf sebelumnya dari daftar ini.  Yaitu, jika beban pada server bertambah, dan proyek tidak menyediakan penskalaan kapasitas server yang fleksibel, ini mengarah pada fakta bahwa peralatan mulai bekerja hingga batasnya.  Dan, sebagai hasilnya, kinerja aplikasi turun. </li><li>  <b>WAF, muat penyeimbang.</b>  Layanan, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WAF</a> atau load balancers yang terletak di depan aplikasi server, meningkatkan TTFB. </li><li>  <b>Beberapa fitur CDN.</b>  Menggunakan CDN adalah faktor yang tentunya memiliki efek menguntungkan pada TTFB, tetapi beberapa fitur CDN dapat memperburuk ini.  Misalnya, ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan lipat</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ESI</a> , dll. </li><li>  <b>Keterlambatan di "last mile".</b>  Ketika kita berbicara tentang komputer dari London yang mengakses server yang berlokasi di New York, kita biasanya menyederhanakan situasi, hampir menguranginya menjadi fakta bahwa komputer dan server terhubung langsung satu sama lain.  Namun dalam kenyataannya, semuanya jauh lebih rumit.  Sinyal antara komputer dan server melewati banyak perantara.  Router kami mengirimkannya ke penyedia;  dari jaringan nirkabel, ia masuk ke kabel yang diletakkan di dasar lautan ... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penundaan pada "mil terakhir"</a> mencakup semua kesulitan yang menghalangi transfer data antara perangkat akhir. </li></ul><br>  TTFB 0 ms adalah mimpi pipa.  Oleh karena itu, penting untuk dicatat bahwa tidak ada dalam daftar yang selalu berdampak negatif terhadap TTFB atau selalu memperburuk indikator ini.  Daftar ini paling baik dipahami sebagai deskripsi struktur proyek TTFB.  Tujuan saya bukan untuk mengkritik teknologi tertentu, tetapi untuk menunjukkan bagaimana teknologi tertentu dapat memengaruhi TTFB.  Dan, jujur ​​saja, mengingat berapa banyak hal yang terjadi sebelum klien menerima byte pertama dari respon dari server, sudah mengejutkan bahwa situs-situs tersebut umumnya memuat. <br><br><h2>  <font color="#3AC1EF">Misteri Mengungkap dengan TTFB</font> </h2><br>  Mudah-mudahan, TTFB tidak terlihat misterius lagi.  Dan jika Anda menghabiskan sedikit waktu pada implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Timing Server</a> API, maka Anda dapat mulai mengukur indikator waktu server yang rumit dan mengirimkannya ke sistem klien.  Ini akan memungkinkan pengembang web untuk mendeteksi dan menghilangkan potensi kemacetan kinerja yang sebelumnya tersembunyi dari mata mereka. <br><br>  Server Timing API memungkinkan pengembang untuk memperluas respons kueri dengan header HTTP <code>Server-Timing</code> opsional.  Ini berisi informasi waktu yang diukur oleh aplikasi itu sendiri. <br><br>  Mekanisme inilah yang kami gunakan tahun lalu ketika bekerja pada BBC iPlayer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/573/4b1/63e/5734b163e8c49e7bd6729537f37a2866.png"></div><br>  <i><font color="#999999">Header Server-Timing baru dapat ditambahkan ke jawaban apa pun ( <a href="">gambar ukuran penuh</a></font></i> ) <br><br>  Perhatikan bahwa Waktu Server juga memberikan tekanan pada sistem.  Dalam perjalanan kerjanya, Anda perlu mengukur indikator yang relevan dan mengisi header <code>Server-Timing</code> .  Browser hanya memungkinkan pengembang front-end untuk melihat data ini menggunakan alat yang sesuai. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/503/a38/b0c/503a38b0cb82096726135107e593fb25.png"></div><br>  <i><font color="#999999">Sekarang, tepat di browser, Anda dapat melihat struktur TTFB ( <a href="">gambar ukuran penuh</a> )</font></i> <br><br>  Jika Anda ingin menerapkan Server Timing API, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">materi ini</a> . <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Sangat penting bahwa pengembang web memahami sejauh mana TTFB mempengaruhi apa yang mereka sebut "kinerja situs."  Waktu ke byte pertama adalah batas tertentu, setelah menyeberang yang dapat kita bicarakan optimasi situs web.  Semakin rendah indikator ini, semakin baik. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda mengoptimalkan proyek web Anda dengan TTFB? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470868/">https://habr.com/ru/post/id470868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470844/index.html">Proyek baru dari Durov bersaudara: Telegram Open Network</a></li>
<li><a href="../id470852/index.html">Memproses 40 TB kode dari 10 juta proyek pada server khusus dengan Go seharga $ 100</a></li>
<li><a href="../id470856/index.html">Telegram GRAM Wallet: ketentuan layanan</a></li>
<li><a href="../id470858/index.html">Antiquities: Benchmark dari prosesor 386 dan sembilan puluhan gagah</a></li>
<li><a href="../id470864/index.html">Tentang kelezatan beralih ke panel dan tidak hanya</a></li>
<li><a href="../id470870/index.html">Prapemuat Font</a></li>
<li><a href="../id470872/index.html">Metrik kinerja untuk meneliti aplikasi web yang sangat cepat</a></li>
<li><a href="../id470874/index.html">Mengoptimalkan pemuatan JavaScript di Wikipedia</a></li>
<li><a href="../id470876/index.html">Buat konstruksi sintaks JavaScript khusus menggunakan Babel. Bagian 1</a></li>
<li><a href="../id470878/index.html">Buat konstruksi sintaks JavaScript khusus menggunakan Babel. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>