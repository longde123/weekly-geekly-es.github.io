<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòï üï∂Ô∏è üë∂üèΩ Google Forms exportieren + Google Script √ºber REST-API (Python) herunterladen üç¶ üîÖ üèÇüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir hatten zwei Google-Formulare mit jeweils 75 Fragen, f√ºnf Gesch√§ftsbenutzer, die diese Formulare aktiv bearbeitet haben, sowie ein Google-Skript, m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Google Forms exportieren + Google Script √ºber REST-API (Python) herunterladen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485898/"><img src="https://habrastorage.org/webt/gi/tl/nl/gitlnlklzpbmybk3jz3utl4_uow.png"><br><br>  Wir hatten zwei Google-Formulare mit jeweils 75 Fragen, f√ºnf Gesch√§ftsbenutzer, die diese Formulare aktiv bearbeitet haben, sowie ein Google-Skript, mit dem das Formular in JSON exportiert wurde.  Nicht, dass es schwierig w√§re, es jedes Mal mit den H√§nden auszuf√ºhren, aber wenn Sie einmal damit begonnen haben, Ihre Arbeit zu automatisieren, gehen Sie in diesem Hobby zu Ende. <br><br>  In der offiziellen Dokumentation wird sich der Teufel das Bein brechen, daher werden wir uns unter der Katze den Remote-Download und das Starten von Google Apps Script √ºber die REST-API mit Python genauer ansehen. <br><a name="habracut"></a><br><h2>  Einleitung </h2><br>  In Doctor Near entwickeln wir eine Plattform f√ºr Chat-Bots, in der Google-Formulare zur Beschreibung von Szenarien verwendet werden.  Dementsprechend m√∂chte ich von den Formularen auf Knopfdruck einen JSON erhalten, der Knoten (Formpunkte) und Metadaten zu ihnen (√úberg√§nge zwischen Knoten, Knotentypen, deren Namen) enth√§lt.  Es scheint, dass der Wunsch einfach ist, aber Google unterst√ºtzt diese Funktionalit√§t nicht und Sie m√ºssen diesen "Exporteur" mit Ihren eigenen H√§nden zusammenbauen.  Betrachten Sie die Schritte, um es zu erstellen. <br><br><h2>  SCHRITT 1. Google Apps Script </h2><br>  Google bietet die M√∂glichkeit, mit seinen Diensten (Tabellen, Dokumente, Formulare) √ºber Google Apps Script zu interagieren - Skripte, die in Google Script (.gs) geschrieben sind.  Dieser Artikel enth√§lt keine Analyse der Google-Skriptsprache. Ich werde daher ein Beispiel f√ºr ein fertiges Skript geben, mit dem JSON aus einem vorhandenen Google-Formular erstellt wird.  Der Benutzercode <a href="https://github.com/stevenschmatz" rel="nofollow">Steven Schmatz</a> wurde aus dem Github als Grundlage genommen, wof√ºr ich ihm meinen Dank aussprechen m√∂chte. <br><br><div class="spoiler">  <b class="spoiler_title">Skriptcode</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Steven Schmatz // Humanitas Labs // 13 October, 2016. // Roman Shekhovtsov // dr-telemed.ru // Autumn 2019 // Nikita Orekhov // dr-telemed.ru // Autumn 2019 /** * Converts the given form URL into a JSON object. */ function main() { form_url = "&lt;YOUR_FORM_URL&gt;" var form = FormApp.openByUrl(form_url); var items = form.getItems(); var result = { "metadata": getFormMetadata(form), "items": items.map(itemToObject), "count": items.length }; // sendEmail("&lt;YOUR_EMAIL&gt;", result) return result; } /** If we want to receive data by email * Sends JSON as text to recipient email * @param recipient: String * @param result: JSON */ function sendEmail(recipient, json_file){ var subject = "google form json import" var body = JSON.stringify(json_file); Logger.log(body); MailApp.sendEmail(recipient, subject, body); } /** * Returns the form metadata object for the given Form object. * @param form: Form * @returns (Object) object of form metadata. */ function getFormMetadata(form) { return { "title": form.getTitle(), "id": form.getId(), "description": form.getDescription(), "publishedUrl": form.getPublishedUrl(), "editorEmails": form.getEditors().map(function(user) { return user.getEmail() }), "count": form.getItems().length, "confirmationMessage": form.getConfirmationMessage(), "customClosedFormMessage": form.getCustomClosedFormMessage() }; } /** * Returns an Object for a given Item. * @param item: Item * @returns (Object) object for the given item. */ function itemToObject(item) { var data = {}; data.type = item.getType().toString(); // Downcast items to access type-specific properties var itemTypeConstructorName = snakeCaseToCamelCase("AS_" + item.getType().toString() + "_ITEM"); var typedItem = item[itemTypeConstructorName](); // Keys with a prefix of "get" have "get" stripped var getKeysRaw = Object.keys(typedItem).filter(function(s) {return s.indexOf("get") == 0}); getKeysRaw.map(function(getKey) { var propName = getKey[3].toLowerCase() + getKey.substr(4); // Image data, choices, and type come in the form of objects / enums if (["image", "choices", "type", "alignment"].indexOf(propName) != -1) {return}; // Skip feedback-related keys if ("getFeedbackForIncorrect".equals(getKey) || "getFeedbackForCorrect".equals(getKey) || "getGeneralFeedback".equals(getKey)) {return}; var propValue = typedItem[getKey](); data[propName] = propValue; }); // Bool keys are included as-is var boolKeys = Object.keys(typedItem).filter(function(s) { return (s.indexOf("is") == 0) || (s.indexOf("has") == 0) || (s.indexOf("includes") == 0); }); boolKeys.map(function(boolKey) { var propName = boolKey; var propValue = typedItem[boolKey](); data[propName] = propValue; }); // Handle image data and list choices switch (item.getType()) { case FormApp.ItemType.LIST: case FormApp.ItemType.CHECKBOX: data.choices = typedItem.getChoices().map(function(choice) { return choice.getValue() }); case FormApp.ItemType.MULTIPLE_CHOICE: data.choices = typedItem.getChoices().map(function(choice) { gotoPage = choice.getGotoPage() if (gotoPage == null) return choice.getValue() else return { "value": choice.getValue(), "gotoPage":choice.getGotoPage().getId() }; }); break; case FormApp.ItemType.IMAGE: data.alignment = typedItem.getAlignment().toString(); if (item.getType() == FormApp.ItemType.VIDEO) { return; } var imageBlob = typedItem.getImage(); data.imageBlob = { "dataAsString": "", //imageBlob.getDataAsString(), - BLOB too big "name": imageBlob.getName(), "isGoogleType": imageBlob.isGoogleType() }; break; case FormApp.ItemType.PAGE_BREAK: data.pageNavigationType = typedItem.getPageNavigationType().toString(); break; default: break; } // Have to do this because for some reason Google Scripts API doesn't have a // native VIDEO type if (item.getType().toString() === "VIDEO") { data.alignment = typedItem.getAlignment().toString(); } return data; } /** * Converts a SNAKE_CASE string to a camelCase string. * @param s: string in snake_case * @returns (string) the camelCase version of that string */ function snakeCaseToCamelCase(s) { return s.toLowerCase().replace(/(\_\w)/g, function(m) {return m[1].toUpperCase();}); }</span></span></code> </pre> <br></div></div><br>  Was passiert im Code: <br><br><ul><li>  <i>getFormMetadata-</i> Funktion - <i>Gibt</i> JSON mit Formularmetadaten zur√ºck </li><li>  <i>itemToObject-</i> Funktion - konvertiert das <i>form.item-</i> Objekt mit den erforderlichen Feldern in JSON </li><li>  <i>sendEmail-</i> Funktion - sendet eine JSON-Datei an die angegebene E-Mail im Text </li><li>  Hauptfunktion - gibt den resultierenden JSON zur√ºck </li><li>  Die Variable <i>form_url</i> in der Hauptfunktion ist die Adresse unseres Google-Formulars </li></ul><br><h2>  SCHRITT 2. Das Skript testen </h2><br>  Im Moment kann die Leistung des Skripts wie folgt √ºberpr√ºft werden: <br><br><ol><li>  <a href="https://script.google.com/home/start" rel="nofollow">Erstellen Sie</a> Ihr eigenes App-Skript-Projekt </li><li>  Kopieren Sie den Code hinein </li><li>  Anstelle von <i>&lt;YOUR_FORM_URL&gt; ersetzen wir</i> die Adresse unseres Formulars aus dem Formular <i><a href="https://docs.google.com/forms/d/FORM_IDENTIFICATOR/edit" rel="nofollow">docs.google.com/forms/d/FORM_IDENTIFICATOR/edit</a></i> </li><li>  <i>Kommentieren Sie</i> den Aufruf von <i>sendEmail</i> in der <i>Hauptfunktion</i> aus </li><li>  Anstelle von <i>&lt;YOUR_EMAIL&gt; ersetzen wir</i> die E-Mail-Adresse, an die JSON <i>gesendet werden</i> soll </li><li>  Speichern Sie das Projekt </li><li>  F√ºhren Sie die <i>Hauptfunktion</i> aus </li><li>  Wenn dies die erste Ausf√ºhrung des Skripts ist, werden Sie vom System √ºber die Notwendigkeit informiert, dem Skript die Berechtigung zum Senden von E-Mails von Ihrer Adresse aus zu erteilen.  Hab keine Angst.  Dies ist die Standardprozedur, die zum Testen des Skripts erforderlich ist.  Gehe durch "Berechtigungen √ºberpr√ºfen" -&gt; w√§hle dein Konto aus -&gt; "Erweitert" -&gt; "Gehe zu PROJECT_NAME-Projekt (unsicher)" -&gt; "Zulassen" </li><li>  Warten auf das Skript zu arbeiten </li><li>  Schauen Sie in das Postfach und sehen Sie die JSON-Datei in Textform </li></ol><br>  Alles w√§re in Ordnung, aber die weitere Verwendung der erhaltenen Daten erfordert manuelles Kopieren aus der Mail, Verarbeiten dieses Texts (z. B. in Python) und Speichern der resultierenden Datei.  Es klingt nicht zu produktionsreif.  Wir automatisieren den Start dieses Skripts und erhalten das Ergebnis √ºber die Google Apps-Skript-API. Zun√§chst richten wir jedoch unser Google-Projekt entsprechend ein. <br><br>  <b>Achtung:</b> Um zu verstehen, was gerade passiert, werde ich im Folgenden nur auf zwei Seiten verweisen. Es wird daher empfohlen, diese in benachbarten Registerkarten zu √∂ffnen: <br><br><ol><li>  Skript / Skriptbearbeitungsseite - <i>‚ÄûSeite 1‚Äú</i> </li><li>  Google Cloud Platform-Seite - <i>"Seite 2"</i> </li></ol><br><h2>  SCHRITT 3. Google Cloud Platform konfigurieren </h2><br>  Wir gehen zur Google Cloud Platform (Seite 2) und erstellen ein neues Projekt.  Es ist erforderlich, ein neues Projekt zu erstellen, da der Standardstatus des Projekts "Standard" lautet und f√ºr unsere Zwecke "Standart" erforderlich ist.  Weitere Details finden Sie <a href="https://developers.google.com/apps-script/guides/cloud-platform-projects" rel="nofollow">hier</a> (Punkt 3). <br><br>  Wir kehren zu Seite 2 zur√ºck, gehen zur Registerkarte "API and Services" und dann zu "OAuth Access Request Window".  Stellen Sie den Benutzertyp auf "Extern". <br><br>  Geben Sie im angezeigten Fenster den "Anwendungsnamen" ein. <br><br>  √ñffnen Sie die Homepage auf der Google Cloud-Plattform.  Kopieren Sie aus dem Block "Projektinformationen" die Projektnummer. <br><br>  Gehen Sie zu Seite 1. √ñffnen Sie das zuvor erstellte Skript.  Gehen Sie im ge√∂ffneten Skriptbearbeitungsfenster zu ‚ÄûRessourcen‚Äú -&gt; ‚ÄûCloud Platform-Projekt‚Äú.  Geben Sie im Feld ‚ÄûProjekt √§ndern‚Äú die zuvor kopierte Projektnummer ein.  Dieses Skript ist nun dem erstellten Projekt zugeordnet. <br><br><h2>  SCHRITT 4. Python-REST-API </h2><br>  Es ist Zeit, das Skript mithilfe der <a href="https://developers.google.com/apps-script/api/reference/rest" rel="nofollow">REST-API</a> zu automatisieren.  Als Sprache wurde Python verwendet. <br><br><h3>  Anmeldung f√ºr Apps Script API </h3><br>  Der Code muss Zugriff auf das Projekt haben, daher ist die Anmeldung in der Apps Script-API die erste und sehr wichtige Prozedur.  √ñffnen Sie Seite 2 -&gt; ‚ÄûAPI and Services‚Äú -&gt; ‚ÄûCredentials‚Äú -&gt; ‚ÄûCreate Credentials‚Äú -&gt; ‚ÄûOAuth Client Identifier‚Äú -&gt; ‚ÄûOther Types‚Äú.  Wir nennen unseren Bezeichner, gehen Sie zu ihm.  W√§hlen Sie auf der Registerkarte "Anmeldeinformationen" die Option "JSON-Datei herunterladen".  Dadurch wird die Schl√ºsseldatei f√ºr den Zugriff vom Code auf das Projekt in Google geladen.  Wir legen diese Datei im Anmeldeinformationsordner ab. <br><br>  Jetzt m√ºssen Sie die Berechtigung erteilen, die API (in unserem Fall die Apps Script-API) als Teil dieses Projekts zu verwenden.  Gehen Sie dazu zu "API und Dienste" -&gt; "Bibliothek" -&gt; geben Sie "Apps Script API" in die Suche ein und klicken Sie auf "Aktivieren". <br><br>  Anwendungen, die mit Google interagieren, verf√ºgen √ºber eine Reihe von Berechtigungen, die der Nutzer beim Starten erteilen muss.  Diese Kopie h√§ngt von den Funktionen ab, die von einem bestimmten Skript verwendet werden. Sie finden sie auf Seite 1 im Skriptbearbeitungsfenster unter ‚ÄûDatei‚Äú -&gt; ‚ÄûProjekteigenschaften‚Äú -&gt; ‚ÄûBereiche‚Äú.  Diese Berechtigungen sollten f√ºr die zuk√ºnftige Verwendung im Code gespeichert werden. <br><br>  In diesem Fall sieht die Login-Funktion folgenderma√üen aus: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> googleapiclient.discovery <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> build <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> google_auth_oauthlib.flow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> InstalledAppFlow <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> google.auth.transport.requests <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Request <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: creds = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-comment"><span class="hljs-comment"># The file token.pickle stores the user's access and refresh tokens, and is # created automatically when the authorization flow completes for the first # time. token_file = config['credentials_path'] + config['token_file'] credentials_file = config['credentials_path'] + config['credentials_file'] if os.path.exists(token_file): with open(token_file, 'rb') as token: creds = pickle.load(token) # If there are no (valid) credentials available, let the user log in. if not creds or not creds.valid: if creds and creds.expired and creds.refresh_token: creds.refresh(Request()) else: flow = InstalledAppFlow.from_client_secrets_file(credentials_file, config['SCOPES']) creds = flow.run_local_server(port=0) # Save the credentials for the next run with open(token_file, 'wb') as token: pickle.dump(creds, token) service = build('script', 'v1', credentials=creds) pprint('Login successful') return service except Exception as e: pprint(f'Login failure: {e}') return None</span></span></code> </pre><br>  Dieser Codeblock ist das Standardverfahren f√ºr den Einstieg in Google App Script. <br>  Wir verwenden ein Authentifizierungstoken und erstellen bei der Anmeldung entweder ein neues Token oder verwenden ein vorhandenes. <br><br>  Zur Vereinfachung wurde eine JSON-Konfigurationsdatei mit der folgenden Form erstellt: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"SCOPES"</span></span>: [<span class="hljs-string"><span class="hljs-string">"https://www.googleapis.com/auth/forms"</span></span>, <span class="hljs-string"><span class="hljs-string">"https://www.googleapis.com/auth/script.send_mail"</span></span>], <span class="hljs-attr"><span class="hljs-attr">"credentials_path"</span></span>: <span class="hljs-string"><span class="hljs-string">"credentials/"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"credentials_file"</span></span>: <span class="hljs-string"><span class="hljs-string">"google_test_project.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"token_file"</span></span>: <span class="hljs-string"><span class="hljs-string">"token.pickle"</span></span> }</code> </pre><br>  <b>Wichtig: Das</b> Token wird f√ºr die Authentifizierung mit einem bestimmten Berechtigungsumfang erstellt.  Mit anderen Worten, wenn Sie den Berechtigungsumfang √§ndern, sollten Sie das Token l√∂schen und bei der Anmeldung ein neues erstellen. <br><br><h3>  Skriptcode f√ºr Remote-Aktualisierung </h3><br>  Jetzt lernen wir, wie man den Skriptcode remote aktualisiert, diesen Code dann ausf√ºhrt und das Ergebnis erh√§lt.  Zus√§tzlich zu dem Code, den wir im Google Editor ausf√ºhren, gibt es auch eine <a href="https://developers.google.com/apps-script/concepts/manifests" rel="nofollow">Manifestdatei</a> , die die Startrechte, Bereitstellungseinstellungen usw. enth√§lt.  Weitere Informationen zu seiner Struktur finden Sie <a href="https://developers.google.com/apps-script/manifest/" rel="nofollow">hier</a> . <br>  Um die von Google f√ºr Ihr Skript erstellte Standardmanifestdatei anzuzeigen, rufen Sie den Skripteditor unter "Ansicht" -&gt; "Manifestdatei anzeigen" auf.  Das Manifest wird in der Liste der Dateien angezeigt, die sich auf dieses Skript beziehen. <br><br>  Die Rede √ºber das Manifest war nicht ohne Grund: F√ºr die Remote-Skriptaktualisierung muss der Code sowohl der Dateien (* .gs) als auch des Manifests (appscript.json) heruntergeladen werden. <br><br>  Lesen Sie zun√§chst den Code der .gs-Datei, die Sie bereitstellen m√∂chten: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'export-google-form.gs'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: sample_code = f.read()</code> </pre><br>  Kopieren Sie nun das automatisch generierte Manifest und √§ndern Sie es ein wenig f√ºr unsere Zwecke.  Die Dokumentation beschreibt die Struktur der Manifestdatei ziemlich ausf√ºhrlich, so dass ich auf diesen Punkt nicht n√§her eingehen werde.  Damit das Skript funktioniert, m√ºssen Sie dem Standardmanifest den Abschnitt "executionApi" hinzuf√ºgen, der f√ºr die Remoteausf√ºhrung des Skripts √ºber die API erforderlich ist.  In diesem Abschnitt geben wir den Personenkreis an, der in der Lage ist, das Programm auszuf√ºhren.  Ich habe den Start f√ºr alle erlaubt, die die Autorisierung bestanden haben, die der Kennung "ANYONE" entspricht: <br><br><pre> <code class="python hljs">MANIFEST = <span class="hljs-string"><span class="hljs-string">''' { "timeZone": "America/New_York", "exceptionLogging": "STACKDRIVER", "executionApi": { "access": "ANYONE" } } '''</span></span>.strip()</code> </pre><br>  Der Hauptteil der Aktualisierungsanforderung sollte ein Array von Dateien mit der folgenden Struktur enthalten: <br><br><ul><li>  <i>name</i> : Name der Datei, die auf dem Server erstellt werden soll, ohne Erweiterung </li><li>  <i>Typ</i> : Dateityp (JSON f√ºr Manifest, SERVER_JS f√ºr .gs) </li><li>  <i>Quelle</i> : Dateicode </li></ul><br><pre> <code class="python hljs">request = { <span class="hljs-string"><span class="hljs-string">'files'</span></span>: [{ <span class="hljs-string"><span class="hljs-string">'name'</span></span>: <span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'type'</span></span>: <span class="hljs-string"><span class="hljs-string">'SERVER_JS'</span></span>, <span class="hljs-string"><span class="hljs-string">'source'</span></span>: sample_code }, { <span class="hljs-string"><span class="hljs-string">'name'</span></span>: <span class="hljs-string"><span class="hljs-string">'appsscript'</span></span>, <span class="hljs-string"><span class="hljs-string">'type'</span></span>: <span class="hljs-string"><span class="hljs-string">'JSON'</span></span>, <span class="hljs-string"><span class="hljs-string">'source'</span></span>: MANIFEST } ] }</code> </pre><br>  Schlie√ülich muss die Aktualisierungsanforderung selbst den Hauptteil (oben beschriebene Anforderung) und die Skript-ID enthalten.  Letzteres erhalten Sie, indem Sie im Skripteditor unter "Datei" -&gt; "Projekteigenschaften" die "Skript-ID" kopieren: <br><br><pre> <code class="python hljs">script_id = <span class="hljs-string"><span class="hljs-string">'qwertyuiopQWERTYUIOPasdfghjkl123456789zxcvbnmASDFGHJKL54'</span></span></code> </pre><br>  F√ºr das Serviceobjekt, das als Ergebnis der Anmeldung abgerufen wurde, erhalten wir das Feld projects () und rufen die Methode updateContent () auf. Anschlie√üend rufen wir die Methode execute () f√ºr das empfangene HttpRequest-Objekt auf: <br><br><pre> <code class="python hljs">service.projects().updateContent( body=request, scriptId=script_id ).execute()</code> </pre><br>  Derzeit f√ºhrt das Ausf√ºhren des Codes jedoch zu einem Fehler: <br><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"error"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">403</span></span>, <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"Request had insufficient authentication scopes."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"status"</span></span>: <span class="hljs-string"><span class="hljs-string">"PERMISSION_DENIED"</span></span> }</code> </pre><br>  Wie Sie sehen, gibt es nicht gen√ºgend Berechtigungen f√ºr den Authentifizierungs-Fischadler, auf den wir bereits hingewiesen haben.  Wir wenden uns der offiziellen Dokumentation der API zu, der <a href="https://developers.google.com/apps-script/api/reference/rest/v1/projects/updateContent" rel="nofollow">updateContent-</a> Methode, mit der wir das Skript remote aktualisiert haben.  Die Dokumentation besagt, dass f√ºr die Verwendung dieser Methode der Zugriff auf script.projects aktiviert werden muss: <br><br><pre> <code class="python hljs">https://www.googleapis.com/auth/script.projects</code> </pre> <br>  F√ºgen Sie es unserer Konfigurationsdatei im Bereich SCOPES hinzu.  Wie ich oben geschrieben habe, ist es beim √Ñndern des Fischadlers erforderlich, das automatisch generierte Token zu l√∂schen. <br><br>  Gro√üartig!  Im Moment haben wir gelernt, Google-Skript aus der Ferne zu aktualisieren.  Es bleibt zu laufen und das Ergebnis der Ausf√ºhrung zu erhalten. <br><br><h3>  Skript ausf√ºhren </h3><br>  Die Skriptstartanforderung enth√§lt die <a href="https://developers.google.com/apps-script/api/reference/rest/v1/scripts/run" rel="nofollow">Skript-</a> ID und den Text mit der folgenden Struktur: <br><br><ul><li>  <i>function</i> : Name der Funktion, die ausgef√ºhrt werden soll </li><li>  <i>parameters</i> : <i>(optional) Eine</i> Reihe von Parametern eines primitiven Typs (Zeichenfolge, Array ...), die an die Funktion √ºbergeben werden </li><li>  <i>sessionState</i> : <i>(optional)</i> ist nur f√ºr Android-Anwendungen erforderlich </li><li>  <i>devMode</i> : <i>(optional)</i> True, wenn der Benutzer der Eigent√ºmer des Skripts ist und dann die neueste Version gestartet wird, als diejenige, die mit der Apps Script-API bereitgestellt wurde.  (standardm√§√üig - Falsch) </li></ul><br>  Um die URL des Google-Formulars im Skript nicht zusammenzuf√ºgen, √ºbergeben wir <i>form_url</i> als Argument an die <i>Hauptfunktion</i> . <br><br>  <b>Achtung</b>  Beim Testen des Skripts hat die <i>Hauptfunktion</i> nichts akzeptiert. Daher √§ndern wir die ersten Codezeilen in der .gs-Datei wie folgt: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">form_url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> form = FormApp.openByUrl(form_url); .......</code> </pre><br>  Da unsere Anwendung nicht f√ºr Android ist und wir die Eigent√ºmer des Skripts sind, sieht der Text folgenderma√üen aus: <br><br><pre> <code class="python hljs">body = { <span class="hljs-string"><span class="hljs-string">"function"</span></span>: <span class="hljs-string"><span class="hljs-string">"main"</span></span>, <span class="hljs-string"><span class="hljs-string">"devMode"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-string"><span class="hljs-string">"parameters"</span></span>: form_url }</code> </pre><br>  F√ºhren Sie das Skript aus und schreiben Sie das Ergebnis der Ausf√ºhrung in die entsprechende Variable: <br><br><pre> <code class="python hljs">resp = service.scripts().run(scriptId=script_id, body=body).execute()</code> </pre><br>  Speichern bzw. in eine Datei mit praktischer JSON-Formatierung: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'habr_auto.json'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>, encoding=<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: json.dump(resp[<span class="hljs-string"><span class="hljs-string">'response'</span></span>][<span class="hljs-string"><span class="hljs-string">'result'</span></span>], f, ensure_ascii=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, indent=<span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre><br>  <b>Achtung</b>  Aufgrund der Tatsache, dass die script.run () -Anforderung √ºber den Socket auf das Ergebnis wartet und das Timeout um die Ausf√ºhrungszeit √ºberschritten wird, tritt ein Fehler des folgenden Typs auf: <br><br><pre> <code class="python hljs">socket.timeout: The read operation timed out</code> </pre><br>  Um dieses Verhalten zu vermeiden, empfehle ich, zu Beginn des Programms ein Limit f√ºr die Open-Socket-Zeit festzulegen, das offensichtlich ausreicht, um auf die Ausf√ºhrung des Skripts zu warten.  In meinem Fall reichen 120 Sekunden: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> socket socket.setdefaulttimeout(<span class="hljs-number"><span class="hljs-number">120</span></span>)</code> </pre><br>  Voila!  Eine praktische Pipeline zum Remote-Aktualisieren und Starten von Google-Skripten ist verf√ºgbar.  Der vollst√§ndige Code f√ºr den Start vom Terminal ist in meinem <a href="https://github.com/nikanor97/habr_google_script_api" rel="nofollow">Github angegeben</a> . <br><br>  Au√üerdem werde ich den Code der Hauptfunktionen unten geben <br><br><div class="spoiler">  <b class="spoiler_title">login.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pprint <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pprint <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> googleapiclient.discovery <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> build <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> google_auth_oauthlib.flow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> InstalledAppFlow <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> google.auth.transport.requests <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Request <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: creds = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-comment"><span class="hljs-comment"># The file token.pickle stores the user's access and refresh tokens, and is # created automatically when the authorization flow completes for the first # time. token_file = config['credentials_path'] + config['token_file'] credentials_file = config['credentials_path'] + config['credentials_file'] if os.path.exists(token_file): with open(token_file, 'rb') as token: creds = pickle.load(token) # If there are no (valid) credentials available, let the user log in. if not creds or not creds.valid: if creds and creds.expired and creds.refresh_token: creds.refresh(Request()) else: flow = InstalledAppFlow.from_client_secrets_file(credentials_file, config['SCOPES']) creds = flow.run_local_server(port=0) # Save the credentials for the next run with open(token_file, 'wb') as token: pickle.dump(creds, token) service = build('script', 'v1', credentials=creds) pprint('Login successful') return service except Exception as e: pprint(f'Login failure: {e}') return None</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">update_script.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pprint <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pprint <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> googleapiclient <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> errors <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> google_habr_login <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> login MANIFEST = <span class="hljs-string"><span class="hljs-string">''' { "timeZone": "America/New_York", "exceptionLogging": "STACKDRIVER", "executionApi": { "access": "ANYONE" } } '''</span></span>.strip() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update_project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service, script_id, script_file_name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Read from file code we want to deploy with open(script_file_name, 'r') as f: sample_code = f.read() # Upload two files to the project request = { 'files': [{ 'name': 'hello', 'type': 'SERVER_JS', 'source': sample_code }, { 'name': 'appsscript', 'type': 'JSON', 'source': MANIFEST } ] } # Update files in the project service.projects().updateContent( body=request, scriptId=script_id ).execute() pprint('Project was successfully updated') def main(): try: args = sys.argv if len(args) != 4: raise TypeError('Wrong number of arguments. Three argument required: &lt;config_file_name&gt;, &lt;script_id&gt; and ' '&lt;script_file_name&gt;') config_file_name = args[1] script_id = args[2] script_file_name = args[3] with open(config_file_name, "r") as f: config = json.load(f) service = login(config) update_project(service, script_id, script_file_name) except (errors.HttpError, ) as error: # The API encountered a problem. pprint(error.content.decode('utf-8')) if __name__ == '__main__': main()</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">export_form.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pprint <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pprint <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> socket <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> googleapiclient <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> errors <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> google_habr_login <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> login socket.setdefaulttimeout(<span class="hljs-number"><span class="hljs-number">120</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Get JSON, which is returned by script def get_json(service, file_name, script_id, form_url): pprint('Exporting form...') body = { "function": "main", "devMode": True, "parameters": form_url } # Get JSON from script resp = service.scripts().run(scriptId=script_id, body=body).execute() # Write out JSON to file with open(file_name, 'w', encoding='utf-8') as f: json.dump(resp['response']['result'], f, ensure_ascii=False, indent=4) pprint('Form was successfully exported') def main(): try: args = sys.argv if len(args) != 5: raise TypeError('Wrong number of arguments. Four arguments required: &lt;config_file_name&gt;, ' '&lt;result_file_name&gt;, &lt;script_id&gt; and &lt;google_form_url&gt;') config_file_name = args[1] file_name = args[2] script_id = args[3] form_url = args[4] with open(config_file_name, "r") as f: config = json.load(f) service = login(config) get_json(service, file_name, script_id, form_url) except (errors.HttpError, ) as error: # The API encountered a problem. pprint(error.content.decode('utf-8')) if __name__ == '__main__': main()</span></span></code> </pre><br></div></div><br>  Zu Beginn m√ºssen Sie die JSON-Datei mit den Google-Zugriffsschl√ºsseln im Ordner mit den Anmeldeinformationen und die Konfigurations-JSON im selben Verzeichnis wie die Skripts ablegen. <br><br>  Wenn wir dann das Skript aus der Ferne aktualisieren m√∂chten, rufen Sie im Terminal Folgendes auf: <br><br><pre> <code class="bash hljs">python update_script.py &lt;config_file_name&gt; &lt;script_id&gt; &lt;script_file_name&gt;</code> </pre><br>  In diesem Fall: <br><br><ul><li>  <i>config_file_name</i> - Name der Konfigurations-JSON-Datei </li><li>  <i>script_id</i> - Skript-ID </li><li>  <i>script_file_name</i> - Der Name der .gs-Datei, die auf Google hochgeladen wird </li></ul><br>  Rufen Sie zum Ausf√ºhren des Skripts Folgendes auf: <br><br><pre> <code class="bash hljs">python export_form.py &lt;config_file_name&gt; &lt;result_file_name&gt; &lt;script_id&gt; &lt;google_form_url&gt;</code> </pre><br>  In diesem Fall: <br><br><ul><li>  <i>config_file_name</i> - Name der Konfigurations-JSON-Datei </li><li>  <i>result_file_name</i> - Der Name der JSON-Datei, in die das Formular entladen wird </li><li>  <i>script_id</i> - Skript-ID </li><li>  <i>google_form_url</i> - Google-Formular-URL </li></ul><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit und das Warten auf Ihre Vorschl√§ge und Kommentare :) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485898/">https://habr.com/ru/post/de485898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485884/index.html">So richten Sie das chinesische Levitron ein</a></li>
<li><a href="../de485886/index.html">Wie (und warum) man die Schl√ºssel und Anzeigen der Mitbewerber von Yandex.Direct und Google Ads kostenlos parst</a></li>
<li><a href="../de485888/index.html">F√§lschung von Serveranforderungen, blinder SSRF-Betrieb</a></li>
<li><a href="../de485892/index.html">Das Ende der Trident-√Ñra</a></li>
<li><a href="../de485896/index.html">Massiv parallele Datenbank Greenplum - ein kurzes Bildungsprogramm</a></li>
<li><a href="../de485904/index.html">Load Testing Meetup bei der Raiffeisenbank</a></li>
<li><a href="../de485908/index.html">Dank der erstaunlichen Panne in Ocarina of Time konnten Modelle aus Star Fox 64 hinzugef√ºgt werden</a></li>
<li><a href="../de485910/index.html">Bereitstellen von APIs mit AWS Elastic Beanstalk</a></li>
<li><a href="../de485912/index.html">Warum beim Benennen √ºbersetzt wird, ist schlecht und andere interessante Merkmale unserer Wahrnehmung von Code</a></li>
<li><a href="../de485914/index.html">Unterst√ºtzt von ZeroTier. Ein praktischer Leitfaden zum Aufbau virtueller Netzwerke. Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>