<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¿â€ğŸ“ ğŸ‘¨ğŸ½â€ğŸš€ ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦ Anatomi suatu kejadian, atau cara bekerja mengurangi downtime ğŸ‘¨ğŸ¿â€ğŸš€ ğŸ­ â›</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cepat atau lambat, dalam proyek apa pun, saatnya untuk bekerja pada stabilitas / ketersediaan layanan Anda. Untuk beberapa layanan, pada tahap awal, k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anatomi suatu kejadian, atau cara bekerja mengurangi downtime</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/okmeter/blog/422973/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_c/bv/ts/_cbvtskjzvfzxtmqpwfhau4vt_g.png"></div><br><p>  Cepat atau lambat, dalam proyek apa pun, saatnya untuk bekerja pada stabilitas / ketersediaan layanan Anda.  Untuk beberapa layanan, pada tahap awal, kecepatan pengembangan fitur lebih penting, saat ini tim belum sepenuhnya terbentuk, dan teknologi tidak dipilih dengan sangat hati-hati.  Untuk layanan lain (sering kali teknologi b2b), untuk mendapatkan kepercayaan pelanggan, kebutuhan akan waktu kerja tinggi muncul dengan rilis publik pertama.  Tetapi anggaplah bahwa saat X bagaimanapun telah tiba dan Anda mulai peduli berapa banyak waktu layanan Anda "terletak" pada periode pelaporan.  Di bawah potongan, saya sarankan untuk melihat apa yang dimaksud dengan waktu henti dan cara terbaik untuk menguranginya. </p><a name="habracut"></a><br><h2 id="pokazateli">  Indikator </h2><br><p>  Jelas, sebelum Anda memperbaiki sesuatu, Anda perlu memahami keadaan saat ini.  Oleh karena itu, jika kita mulai mengurangi waktu henti, itu yang pertama-tama dan perlu untuk mulai mengukurnya. </p><br><p>  Kami tidak akan berbicara di sini secara rinci tentang bagaimana melakukan hal ini secara khusus, pro dan kontra dari berbagai pendekatan, tetapi proses tesisnya terlihat seperti ini: </p><br><ul><li>  kami mengandalkan metrik bisnis dekat (kesalahan dalam layanan, waktu respons layanan, $ / detik, pendaftaran / detik, dll.) </li><li>  tentukan apa yang baik dan apa yang buruk </li><li>  transisi baik-&gt; buruk adalah awal dari suatu insiden </li><li>  transisi buruk-&gt; baik - akhir dari insiden </li><li>  waktu dari awal hingga akhir - durasi kejadian (tutup bersama kami) </li><li>  jumlah durasi insiden untuk periode (bulan / kuartal / tahun) - downtime </li><li>  (100 - &lt;downtime&gt; / &lt;durasi periode&gt; * 100) = persentase ketersediaan untuk periode tersebut </li></ul><br><p>  Ketika berbicara tentang uptime / downtime, mereka sering menyebutkan indikator lain: </p><br><p>  <strong>MTTR</strong> (waktu rata-rata untuk memperbaiki) - waktu rata-rata dari awal insiden hingga akhir. <br>  Masalah dengannya mulai dari kata pertama dalam singkatan.  Mengingat bahwa semua insiden berbeda, rata-rata durasinya tidak dapat memberi tahu kami apa pun tentang sistem. </p><br><p>  Kali ini kami tidak akan rata-rata apa pun, tetapi hanya melihat apa yang terjadi selama kejadian. </p><br><h2 id="anatomiya-incidenta">  Anatomi suatu kejadian </h2><br><p>  Mari kita lihat langkah penting apa yang dapat dibedakan selama kejadian: </p><br><img src="https://habrastorage.org/webt/ux/vx/be/uxvxbem_ictsovnxnjmjsocquti.png"><br><ul><li>  <strong>deteksi</strong> - interval antara kesalahan pertama yang kami berikan kepada pengguna sebelum petugas menerima SMS </li><li>  <strong>reaksi</strong> - dari menerima pemberitahuan tentang masalah hingga saat seseorang mulai menyelesaikan masalah ini (biasanya pada saat itu acara pemantauan dipindahkan ke keadaan yang Diakui) </li><li>  <strong>investigasi</strong> - dari awal pekerjaan pada masalah hingga saat penyebab insiden dipahami dan kami tahu apa yang perlu dilakukan untuk memulihkan pekerjaan. </li><li>  <strong>eliminasi</strong> - waktu pemulihan, misalnya, rilis rollback, dipromosikan baru <del>  tuan </del>  server basis data primer </li></ul><br><p>  Mungkin model kami tidak lengkap dan ada beberapa tahap lain, tetapi saya mengusulkan untuk memperkenalkan mereka hanya setelah menyadari bagaimana ini akan membantu kami dalam praktik.  Sementara itu, pertimbangkan lebih detail setiap tahap. </p><br><h2 id="detection">  Deteksi </h2><br><p> Mengapa kita menghabiskan waktu mencari keadaan darurat?  Mengapa tidak mengirim pemberitahuan tentang kesalahan pertama yang diterima pengguna?  Sebenarnya, saya tahu banyak perusahaan yang mencoba melakukan ini, tetapi mereka meninggalkan ide ini hanya beberapa jam kemudian, dan mereka menerima beberapa puluh SMS.  Saya pikir tidak ada satu pun layanan yang kurang lebih besar yang tidak memiliki aliran kesalahan "latar belakang" yang konstan.  Tidak semua dari mereka adalah tanda bahwa ada sesuatu yang rusak, ada juga bug dalam perangkat lunak, data tidak valid yang diperoleh dari formulir dan tidak cukup validasi, dll. </p><br><p>  Akibatnya, tingkat kesalahan (atau metrik lainnya) yang melebihi fluktuasi harian digunakan sebagai kriteria untuk membuka insiden.  Inilah yang mengarah pada fakta bahwa pemberitahuan karyawan yang bertanggung jawab terjadi lebih lambat dari permulaan masalah sebenarnya. </p><br><p>  Tetapi kembali ke tugas awal kita - mengurangi durasi insiden.  Bagaimana kita dapat mempersingkat waktu deteksi?  Lebih cepat memberi tahu?  Datang dengan logika super untuk mendeteksi anomali? </p><br><p>  Saya sarankan belum melakukan apa-apa, tetapi untuk melihat tahap selanjutnya, karena pada kenyataannya mereka saling berhubungan. </p><br><h2 id="reaction">  Reaksi </h2><br><p>  Di sini kita memiliki faktor manusia murni.  Kami berasumsi bahwa pemantauan berhasil mendeteksi masalah dan kami berhasil membangunkan insinyur yang bertugas (seluruh eskalasi juga bekerja pada tahap sebelumnya). </p><br><p>  Pertimbangkan kasus "terburuk", kami tidak memiliki layanan tugas khusus, dan lansiran menangkap admin yang tidur dengan damai.  Tindakannya: </p><br><ul><li>  menanggapi SMS: di sini seorang istri dengan telinga yang sensitif banyak membantu, berbagai aplikasi untuk telepon, meningkatkan efek menerima SMS (1-5 menit) </li><li>  membuat keputusan bahwa ia akan merangkak keluar dari tempat tidur: jika peringatan tidak diatur dengan benar, seseorang dapat menunggu 2 menit "bagaimana jika tekad datang?"  dan tertidur (1-15 menit) </li><li>  pergi ke laptop, buka mata Anda, bangun, mulai pemantauan, tekan Ack: (1-15 menit) </li></ul><br><p>  Akibatnya, dalam kasus terburuk, kami mendapat 35 menit reaksi.  Menurut pengamatan saya, waktu reaksi seperti itu tampaknya benar. </p><br><p>  Karena pada tahap ini kita berurusan dengan orang, kita harus bertindak sangat hati-hati dan penuh pertimbangan.  Dalam hal apa pun, Anda tidak perlu menulis peraturan yang mengharuskan seseorang yang baru bangun tidur harus pindah!  Mari kita ciptakan kondisinya. </p><br><p>  Mari singkirkan keraguan sang insinyur bahwa masalahnya akan berakhir dengan sendirinya.  Ini dilakukan dengan sangat sederhana: <strong>buat kriteria waspada tidak sensitif terhadap masalah kecil dan beri tahu jika insiden itu berlangsung dalam waktu yang signifikan</strong> .  Ya, kami baru saja meningkatkan durasi tahap "deteksi", tetapi mari kita lihat sebuah contoh: </p><br><ul><li>  menambah waktu deteksi 5 menit </li><li>  jumlah insiden berkurang: semua kesalahan singkat biasanya jatuh dalam 1 menit.  Insiden singkat ini harus dicatat, tetapi tanpa memberi tahu orang.  Seringkali, mereka memberikan total downtime yang sangat besar, tetapi Anda dapat mengatasinya selama jam kerja.  Untuk tugas ini, Anda akan memerlukan granularity tinggi dalam pemantauan, karena masalahnya sudah berakhir, dan alat diagnostik untuk sebagian besar tidak menyimpan sejarah. </li><li>  jika seseorang dipaksa untuk merespons peringatan sebulan sekali atau kurang sering, dan tidak setiap hari, dia akan merespons dengan lebih memadai dan tidak memperlakukan ini sebagai rutin </li><li>  pemberitahuan yang tertunda memungkinkan seseorang untuk tidak berpikir: jika SMS datang, maka semuanya serius dan tidak akan diperbaiki sendiri </li></ul><br><p>  Berpotensi, pendekatan ini akan mengurangi total waktu reaksi hingga 15+ menit.  Jika waktu reaksi seperti itu tidak sesuai dengan Anda, Anda harus memikirkan layanan tugas. </p><br><h2 id="investigation">  Investigasi </h2><br><p>  Mungkin ini adalah tahap kecelakaan yang paling sulit ketika Anda perlu memahami apa yang terjadi dan apa yang harus dilakukan.  Pada kenyataannya, tahap ini sangat sering dikombinasikan dengan tahap pengambilan tindakan, karena biasanya prosesnya seperti ini: </p><br><ul><li>  kami melihat pemantauan, log (jika pemantauan tidak cukup), kami meluncurkan beberapa alat diagnostik lainnya </li><li>  mengajukan hipotesis </li><li>  kami menguji hipotesis, baik dengan metrik, atau dengan melakukan beberapa tindakan (restart semuanya :) </li><li>  mengevaluasi hasil perubahan </li><li>  berkomunikasi dengan kolega jika pengetahuan Anda tentang subsistem tertentu tidak cukup <br>  dan seterusnya sampai pencerahan atau akhir dari kejadian. </li></ul><br><p>  Tahap ini biasanya yang paling signifikan dalam total durasi kejadian.  Bagaimana cara menguranginya? <br>  Semuanya tidak begitu jelas di sini, ada beberapa vektor: </p><br><ul><li>  <strong>Sederhanakan infrastruktur Anda</strong> : Bayangkan seberapa cepat orang yang memiliki satu basis data dan satu layanan macet </li><li>  <strong>penyebaran pengetahuan dalam tim</strong> : ideal jika komunikasi orang tidak berjalan selama kejadian, tetapi selama pekerjaan sehari-hari (komunikasi orang biasanya merupakan proses yang sangat panjang) </li><li>  <strong>pemantauan</strong> : banyak orang berpikir bahwa pemantauan hanya berfungsi pada tahap "deteksi", tetapi sebenarnya pemantauan dapat bertindak sebagai optimisasi proses pengujian hipotesis ("apakah basis data berfungsi dengan baik?", "apakah layanan saya berjalan ke sumber daya?") dan juga sebagai transportasi penyebaran pengetahuan dalam sebuah tim.  <strong>"Serge, periksa apakah ada kesalahan dalam log X tentang deadlock?"</strong>  <strong>dapat diubah menjadi pemicu, deskripsi yang akan menjadi tautan ke wiki dengan instruksi</strong> . </li></ul><br><h2 id="elimination">  Eliminasi </h2><br><p>  Seperti yang saya katakan di atas, tahap ini sering menyatu dengan yang sebelumnya.  Tetapi kebetulan alasannya segera jelas, tetapi pemulihan akan sangat lama.  Misalnya, Anda memiliki server yang mati <del>  tuan </del>  primer (saya tidak akan terbiasa dengannya sejak lama :) dengan database, dan Anda tidak pernah mempromosikan replika, yaitu, Anda akan membaca dokumentasi, meluncurkan konfigurasi aplikasi baru, dll. </p><br><p>  Secara alami, setelah setiap insiden penting, Anda perlu mencari tahu bagaimana mencegah hal ini terjadi lagi atau mempercepat pemulihan.  Tapi mari kita lihat arah apa yang bisa kita coba secara proaktif: </p><br><ul><li>  <strong>alat manajemen infrastruktur</strong> : jika untuk memperbaiki semua yang Anda butuhkan untuk meluncurkan konfigurasi baru, tetapi ini dilakukan setidaknya dalam 20 menit - ini adalah keterbatasan Anda.  Cobalah untuk membuat skenario tentang apa yang mungkin terjadi dan cara untuk mempercepat beberapa proses.  Misalnya, jika Anda telah menetapkan serial (pelaksanaan tugas paralel) = 3, tetapi jika Anda masih berbohong, Anda dapat menggunakan serial = 30, Anda perlu mengajari semua orang untuk mendefinisikan ulang ini (mirip dengan strategi pembaruan bergulir di kubernetes). </li><li>  <strong>latihan</strong> : jika Anda tahu kemungkinan skenario kegagalan dan pemulihan tidak otomatis, Anda harus memiliki instruksi yang <strong>harus diuji</strong> .  Rencanakan waktu istirahat (jika perlu), lakukan latihan.  Seringkali, pada tahap ini, kasus-kasus seperti itu terotomatisasi, karena sebagian besar jebakan bahkan prosedur paling rumit pada pandangan pertama diklarifikasi selama latihan. </li><li>  <strong>interaksi dengan kontraktor</strong> : Anda harus tahu sebelumnya apa yang akan Anda lakukan jika penyedia hosting Anda sakit.  Seringkali, kesadaran akan kemungkinan masalah dan biaya penutupan risiko mengarah pada kesimpulan - "kita hanya akan menunggu pemulihan."  Tetapi di sisi lain, insinyur dan bisnis akan siap untuk skenario seperti itu.  Misalnya, Anda dapat mengatasi masalah pengalihan lalu lintas ke tulisan rintisan yang sudah disiapkan, memberi tahu pengguna dengan surat yang disiapkan sebelumnya, dll.  Atau sebaliknya, Anda membuat instruksi yang menurutnya kami memberi hoster 30 menit untuk pulih, dan kemudian kami mulai pindah ke DC lain, di mana sudah ada replika database, tetapi Anda perlu memperluas yang lainnya.  Dan di sini sekali lagi, ajarannya, kami mencatat waktu untuk bergerak, dll. </li></ul><br><h2 id="mtbf-mean-time-between-failures">  MTBF (Mean Time Between Failures) </h2><br><p>  Metrik umum lain yang disebutkan dalam diskusi uptime.  Sekali lagi, saya mengusulkan untuk tidak rata-rata apa pun, tetapi hanya untuk berbicara tentang jumlah insiden yang terjadi selama interval waktu. </p><br><p>  Inilah pertanyaan utama tentang seberapa banyak Anda telah menjaga toleransi kesalahan layanan Anda: </p><br><ul><li>  Adakah titik kegagalan tunggal (SPOF) dalam infrastruktur, berapa probabilitas kegagalan? </li><li>  Seberapa yakin Anda bahwa tidak ada SPOF yang tidak Anda ketahui?  (Inilah masalah yang dipecahkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kekacauan monyet</a> ) </li><li>  Apakah load balancers berfungsi dengan baik?  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan saya tentang keseimbangan</a> ) </li><li>  seberapa tangguh jaringan? </li><li>  Seberapa andalkah pusat data? </li></ul><br><p>  Terkadang, untuk menghitung / memprediksi semua ini, mereka membuat "peta risiko", di mana setiap skenario (yang bisa diasumsikan, tentu saja selalu ada yang belum kita ketahui) memiliki probabilitas + dampak (downtime pendek / panjang, kehilangan data, kehilangan reputasi , dll.).  Kemudian, mereka secara sistematis bekerja pada kartu semacam itu, pertama-tama menutup semua skenario yang sangat mungkin dan serius dalam hal dampak. </p><br><p>  Teknik lain yang dapat digunakan adalah klasifikasi insiden masa lalu.  Ada banyak pembicaraan sekarang bahwa sangat berguna untuk menulis insiden "post mortem", yang menganalisis penyebab masalah, tindakan orang, mencari kemungkinan tindakan di masa depan.  Tetapi untuk melihat dengan cepat penyebab semua kecelakaan selama periode yang lalu, akan lebih mudah untuk meringkas durasi mereka dengan pengelompokan berdasarkan â€œkelas masalahâ€ dan di mana waktu paling henti adalah mengambil tindakan: </p><br><ul><li>  <strong>kesalahan manusia</strong> : mengurangi jumlah tindakan manual dalam produksi, berbagai perlindungan terhadap kesalahan operator </li><li>  <strong>rilis yang tidak berhasil</strong> : ada baiknya meningkatkan pengujian (termasuk pengujian beban) </li><li>  <strong>kesalahan aplikasi</strong> : memperbaiki kebocoran, kerusakan dan pembekuan lainnya </li><li>  <strong>jaringan</strong> : membeli peralatan, mengatur, merekrut penggiat jejaring, mengganti kontraktor </li><li>  <strong>Database</strong> : pekerjakan DBA, rawat toleransi kesalahan, beli perangkat keras yang lebih baik </li><li>  <strong>DC</strong> : pikirkan cadangan atau relokasi </li><li>  <strong>pengaruh eksternal</strong> (ddos, pemblokiran, ulasan sertifikat, domain): membeli antiddo, persediaan pada proxy, memantau masa berlaku domain / sertifikat, memiliki beberapa sertifikat dari CA yang berbeda. </li></ul><br><p>  Artinya, jika Anda bahkan tidak mencoba memprediksi kemungkinan skenario masalah, maka sudah pasti layak bekerja dengan insiden yang sudah terjadi. </p><br><h2 id="itogo">  Total </h2><br><p>  Semua insiden berbeda: </p><br><img src="https://habrastorage.org/webt/hq/h2/c_/hqh2c_hykjlgpf1jbyznyvnbf4y.png"><br><p>  Algoritma untuk bekerja untuk meningkatkan uptime sangat mirip dengan optimasi lainnya: </p><br><pre><code class="hljs erlang-repl"> -&gt;  -&gt;   -&gt;  </code> </pre> <br><p>  Dari pengalaman saya sendiri, saya dapat mengatakan bahwa untuk peningkatan waktu aktif yang signifikan, cukup dengan mulai mengikutinya dan menganalisis penyebab insiden.  Biasanya terjadi bahwa perubahan paling sederhana membawa efek paling signifikan. </p><br><p>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan pemantauan kami</a> membantu tidak hanya dengan tahap "deteksi", tetapi juga sangat mengurangi "penyelidikan" (pelanggan akan mengonfirmasi)</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id422973/">https://habr.com/ru/post/id422973/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422961/index.html">Sony Xperia Ear Duo Assistant Headset Menerima Pembaruan Penting</a></li>
<li><a href="../id422965/index.html">UniSharping: Konversi C # Code di Java dan Python</a></li>
<li><a href="../id422967/index.html">Habr.com. Laporan transparansi</a></li>
<li><a href="../id422969/index.html">Frango Anomaly, Outset</a></li>
<li><a href="../id422971/index.html">Sistem pakar tentang Rails</a></li>
<li><a href="../id422977/index.html">Mikhail Bessmeltsev dan rekannya mengembangkan algoritma baru untuk vektorisasi gambar</a></li>
<li><a href="../id422979/index.html">Analog Amerika GDPR: apa yang perlu Anda ketahui tentang CCPA</a></li>
<li><a href="../id422981/index.html">Implementasi Sistem Komponen Entitas Sederhana</a></li>
<li><a href="../id422985/index.html">Mulai cepat proyek web (BE - Java Spring, FE - React Redux, interaksi - Istirahat, WebSocket)</a></li>
<li><a href="../id422987/index.html">Dan lagi, hari ke-256 tahun ini</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>