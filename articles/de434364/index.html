<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÉ üçπ ü§ü Hangfire Queue-Unterst√ºtzung üë®üèΩ‚Äçüî¨ üîá üßõüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hangfire ist eine Bibliothek f√ºr .net (Kern), die die asynchrone Ausf√ºhrung von Code nach dem Prinzip "Feuer und Vergessen" erm√∂glicht. Ein Beispiel f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hangfire Queue-Unterst√ºtzung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434364/"><p>  Hangfire ist eine Bibliothek f√ºr .net (Kern), die die asynchrone Ausf√ºhrung von Code nach dem Prinzip "Feuer und Vergessen" erm√∂glicht.  Ein Beispiel f√ºr einen solchen Code kann das Senden von E-Mails, die Videoverarbeitung, die Synchronisierung mit einem anderen System usw. sein.  Neben "Feuer und Vergessen" werden auch verz√∂gerte Aufgaben sowie geplante Aufgaben im Cron-Format unterst√ºtzt. </p><br><p>  Derzeit gibt es viele solcher Bibliotheken.  Einige der Vorteile von Hangfire sind: </p><br><ul><li>  Einfache Konfiguration, bequeme API </li><li>  Zuverl√§ssigkeit  Hangfire garantiert, dass die erstellte Aufgabe mindestens einmal ausgef√ºhrt wird </li><li>  F√§higkeit, Aufgaben parallel auszuf√ºhren und hervorragende Leistung </li><li>  Erweiterbarkeit (hier werden wir es unten verwenden) </li><li>  Ziemlich vollst√§ndige und verst√§ndliche Dokumentation </li><li>  Dashboard, in dem Sie alle Statistiken zu den Aufgaben anzeigen k√∂nnen </li></ul><br><p>  Ich werde nicht zu sehr ins Detail gehen, da es viele gute Artikel √ºber Hangfire und dessen Verwendung gibt.  In diesem Artikel werde ich erl√§utern, wie die Unterst√ºtzung mehrerer Warteschlangen (oder Aufgabenpools) verwendet wird, wie die Standard-Wiederholungsfunktionalit√§t behoben wird und jede Warteschlange eine individuelle Konfiguration erh√§lt. </p><a name="habracut"></a><br><h3 id="suschestvuyuschaya-podderzhka-psevdo-ocheredey">  Bestehende Unterst√ºtzung f√ºr (Pseudo-) Warteschlangen </h3><br><p>  Wichtiger Hinweis: Im Titel habe ich den Begriff Pseudo-Warteschlange verwendet, da Hangfire nicht garantiert, dass Aufgaben in einer bestimmten Reihenfolge ausgef√ºhrt werden.  Das hei√üt,  Das Prinzip "First In First Out" gilt nicht und wir werden uns nicht darauf verlassen.  Dar√ºber hinaus empfiehlt der Autor der Bibliothek, Aufgaben idempotent zu machen, d. H.  stetig gegen unvorhergesehene Mehrfachausf√ºhrung.  Weiter werde ich nur das Wort "Warteschlange" verwenden, weil  Hangfire verwendet den Begriff "Warteschlange". </p><br><p>  Hangfire bietet einfache Unterst√ºtzung f√ºr Warteschlangen.  Obwohl es nicht die Flexibilit√§t von Message Queue-Systemen wie rabbitMQ oder Azure Service Bus bietet, reicht es h√§ufig aus, um eine Vielzahl von Aufgaben zu l√∂sen. </p><br><p>  Jede Aufgabe hat die Eigenschaft "Warteschlange", dh den Namen der Warteschlange, in der sie ausgef√ºhrt werden soll.  Standardm√§√üig wird die Aufgabe mit dem Namen "Standard" an die Warteschlange gesendet, sofern nicht anders angegeben.  Die Unterst√ºtzung mehrerer Warteschlangen ist erforderlich, um die Ausf√ºhrung von Aufgaben unterschiedlicher Art separat zu verwalten.  Beispielsweise m√∂chten wir m√∂glicherweise, dass die Videoverarbeitungsaufgaben in die Warteschlange "video_queue" fallen und E-Mails an die Warteschlange "email_queue" senden.  Auf diese Weise k√∂nnen wir diese beiden Arten von Aufgaben unabh√§ngig voneinander ausf√ºhren.  Wenn Sie die Videoverarbeitung auf einen dedizierten Server verschieben m√∂chten, k√∂nnen Sie dies einfach tun, indem Sie einen separaten Hangfire-Server als Konsolenanwendung ausf√ºhren, die die Warteschlange "video_queue" verarbeitet. </p><br><h3 id="pereydem-k-praktike">  Lass uns weiter √ºben </h3><br><p>  Das Einrichten des Hangfire-Servers im asp.net-Kern ist wie folgt: </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IApplicationBuilder app</span></span></span><span class="hljs-function">)</span></span> { app.UseHangfireServer(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BackgroundJobServerOptions { WorkerCount = <span class="hljs-number"><span class="hljs-number">2</span></span>, Queues = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-string"><span class="hljs-string">"email_queue"</span></span>, <span class="hljs-string"><span class="hljs-string">"video_queue"</span></span> } }); }</code> </pre> <br><h3 id="problema-1---zadachi-pri-povtore-popadayut-v-ochered-default">  Problem 1 - Wiederholungsaufgaben fallen in die Standardwarteschlange </h3><br><p>  Wie oben erw√§hnt, gibt es in Hangfire eine Standardwarteschlange namens "Standard".  Wenn eine in der Warteschlange platzierte Aufgabe, z. B. "video_queue", fehlgeschlagen ist und erneut versucht werden muss, wird sie erneut an die "Standard" -Warteschlange und nicht an "video_queue" gesendet, sodass unsere Aufgabe √ºberhaupt nicht ausgef√ºhrt wird die Instanz des Hangfire-Servers, die wir, wenn √ºberhaupt, m√∂chten.  Dieses Verhalten wurde von mir experimentell festgestellt und ist wahrscheinlich ein Fehler in Hangfire. </p><br><h4 id="job-filters">  Jobfilter </h4><br><p>  Hangfire bietet uns die M√∂glichkeit, die Funktionalit√§t mithilfe von sogenannten Filtern ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jobfiltern</a> ) zu erweitern, die im Prinzip den Aktionsfiltern in ASP.NET MVC √§hnlich sind.  Tatsache ist, dass die interne Logik von Hangfire als State Machine implementiert ist.  Dies ist eine Engine, die die Aufgaben im Pool nacheinander von einem Status in einen anderen √ºbertr√§gt (z. B. erstellt -&gt; in die Warteschlange gestellt -&gt; verarbeitet -&gt; erfolgreich). Mithilfe von Filtern k√∂nnen wir die Task, die bei jeder √Ñnderung ihres Status ausgef√ºhrt wird, "abfangen" und bearbeiten.  Ein Filter wird als Attribut implementiert, das auf eine einzelne Methode, Klasse oder global angewendet werden kann. </p><br><h4 id="job-parameters">  Auftragsparameter </h4><br><p>  Das ElectStateContext-Objekt wird als Argument an die Filtermethode √ºbergeben.  Dieses Objekt enth√§lt vollst√§ndige Informationen zur aktuellen Aufgabe.  Es verf√ºgt unter anderem √ºber die Methoden GetJobParameter &lt;&gt; (...) und SettJobParameter &lt;&gt; (...).  Mit Jobparametern k√∂nnen Sie Informationen zu einer Aufgabe in einer Datenbank speichern.  In den Auftragsparametern wird der Name der Warteschlange gespeichert, an die die Aufgabe urspr√ºnglich gesendet wurde. Nur aus irgendeinem Grund werden diese Informationen bei der n√§chsten Wiederholung ignoriert. </p><br><h3 id="reshenie">  L√∂sung </h3><br><p>  Wir haben also eine Aufgabe, die fehlerhaft endete und zur erneuten Ausf√ºhrung in der richtigen Warteschlange gesendet werden sollte (in derselben, die ihr zum Zeitpunkt der ersten Erstellung zugewiesen wurde).  Die Wiederholung einer Aufgabe, die mit einem Fehler abgeschlossen wurde, ist ein √úbergang vom Status "Fehlgeschlagen" in den Status "In Warteschlange".  Um das Problem zu l√∂sen, erstellen Sie einen Filter, der beim Eintritt der Aufgabe in den Status "Enqueued" pr√ºft, in welcher Warteschlange die Aufgabe urspr√ºnglich gesendet wurde, und den Parameter "QueueName" auf den gew√ºnschten Wert setzt: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HangfireUseCorrectQueueFilter</span></span> : <span class="hljs-title"><span class="hljs-title">JobFilterAttribute</span></span>, <span class="hljs-title"><span class="hljs-title">IElectStateFilter</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnStateElection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ElectStateContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context.CandidateState <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> EnqueuedState enqueuedState) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> queueName = context.GetJobParameter&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"QueueName"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(queueName)) { context.SetJobParameter(<span class="hljs-string"><span class="hljs-string">"QueueName"</span></span>, enqueuedState.Queue); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { enqueuedState.Queue = queueName; } } } }</code> </pre> <br><p>  F√ºgen Sie unserer Konfiguration den folgenden Code hinzu, um den Standardfilter auf alle Aufgaben (d. H. Global) anzuwenden: </p><br><pre> <code class="cs hljs">GlobalJobFilters.Filters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireUseCorrectQueueFilter { Order = <span class="hljs-number"><span class="hljs-number">1</span></span> });</code> </pre> <br><p>  Ein weiterer kleiner Haken ist, dass die GlobalJobFilters-Auflistung standardm√§√üig eine Instanz der AutomaticRetryAttribute-Klasse enth√§lt.  Dies ist ein Standardfilter, der f√ºr die erneute Ausf√ºhrung fehlgeschlagener Aufgaben verantwortlich ist.  Er sendet die Aufgabe auch an die "Standard" -Warteschlange und ignoriert die urspr√ºngliche Warteschlange.  Damit unser Fahrrad fahren kann, m√ºssen Sie diesen Filter aus der Sammlung entfernen und unseren Filter die Verantwortung f√ºr die wiederholten Aufgaben √ºbernehmen lassen.  Infolgedessen sieht der Konfigurationscode folgenderma√üen aus: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defaultRetryFilter = GlobalJobFilters.Filters .FirstOrDefault(f =&gt; f.Instance <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> AutomaticRetryAttribute); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (defaultRetryFilter != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; defaultRetryFilter.Instance != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { GlobalJobFilters.Filters.Remove(defaultRetryFilter.Instance); } GlobalJobFilters.Filters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireUseCorrectQueueFilter { Order = <span class="hljs-number"><span class="hljs-number">1</span></span> });</code> </pre> <br><p>  Es ist zu beachten, dass AutomaticRetryAttribute die Logik implementiert, das Intervall zwischen Versuchen automatisch zu vergr√∂√üern (das Intervall erh√∂ht sich mit jedem nachfolgenden Versuch), und AutomaticRetryAttribute aus der GlobalJobFilters-Auflistung zu entfernen. Diese Funktionalit√§t wird aufgegeben (siehe Implementierung der <a href="">ScheduleAgainLater-</a> Methode). </p><br><p>  Wir haben also erreicht, dass unsere Aufgaben in verschiedenen Warteschlangen ausgef√ºhrt werden k√∂nnen. Auf diese Weise k√∂nnen wir ihre Ausf√ºhrung unabh√§ngig verwalten, einschlie√ülich der Verarbeitung verschiedener Warteschlangen auf verschiedenen Computern.  Erst jetzt wissen wir nicht, wie oft und in welchem ‚Äã‚ÄãIntervall unsere Aufgaben im Fehlerfall wiederholt werden, da wir AutomaticRetryAttribute aus der Filtersammlung entfernt haben. </p><br><h3 id="problema-2---individualnye-nastroyki-dlya-kazhdoy-ocheredi">  Problem 2 - Individuelle Einstellungen f√ºr jede Warteschlange </h3><br><p>  Wir m√∂chten in der Lage sein, das Intervall und die Anzahl der Wiederholungen f√ºr jede Warteschlange separat zu konfigurieren. Wenn wir f√ºr eine Warteschlange keine expliziten Werte angegeben haben, m√∂chten wir, dass die Standardwerte angewendet werden.  Dazu implementieren wir einen anderen Filter und nennen ihn <code>HangfireRetryJobFilter</code> . </p><br><p>  Im Idealfall sollte der Konfigurationscode ungef√§hr so ‚Äã‚Äãaussehen: </p><br><pre> <code class="cs hljs">GlobalJobFilters.Filters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireRetryJobFilter { Order = <span class="hljs-number"><span class="hljs-number">2</span></span>, [<span class="hljs-string"><span class="hljs-string">"email_queue"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireQueueSettings { DelayInSeconds = <span class="hljs-number"><span class="hljs-number">120</span></span>, RetryAttempts = <span class="hljs-number"><span class="hljs-number">3</span></span> }, [<span class="hljs-string"><span class="hljs-string">"video_queue"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireQueueSettings { DelayInSeconds = <span class="hljs-number"><span class="hljs-number">60</span></span>, RetryAttempts = <span class="hljs-number"><span class="hljs-number">5</span></span> } });</code> </pre> <br><h3 id="reshenie-1">  L√∂sung </h3><br><p>  <code>HangfireQueueSettings</code> Sie dazu zuerst die <code>HangfireQueueSettings</code> Klasse hinzu, die als Container f√ºr unsere Einstellungen dient. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HangfireQueueSettings</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RetryAttempts { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> DelayInSeconds { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br><p>  Anschlie√üend f√ºgen wir die Implementierung des Filters selbst hinzu. Wenn die Aufgaben nach einem Fehler wiederholt werden, werden die Einstellungen abh√§ngig von der Konfiguration der Warteschlange angewendet und die Anzahl der Wiederholungsversuche √ºberwacht: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HangfireRetryJobFilter</span></span> : <span class="hljs-title"><span class="hljs-title">JobFilterAttribute</span></span>, <span class="hljs-title"><span class="hljs-title">IElectStateFilter</span></span>, <span class="hljs-title"><span class="hljs-title">IApplyStateFilter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HangfireQueueSettings _defaultQueueSettings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireQueueSettings { RetryAttempts = <span class="hljs-number"><span class="hljs-number">3</span></span>, DelayInSeconds = <span class="hljs-number"><span class="hljs-number">10</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, HangfireQueueSettings&gt; _settings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, HangfireQueueSettings&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HangfireQueueSettings <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> queueName] { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _settings.TryGetValue(queueName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> HangfireQueueSettings queueSettings) ? queueSettings : _defaultQueueSettings; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _settings[queueName] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnStateElection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ElectStateContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(context.CandidateState <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> FailedState failedState)) { <span class="hljs-comment"><span class="hljs-comment">// This filter accepts only failed job state. return; } var retryAttempt = context.GetJobParameter&lt;int&gt;("RetryCount") + 1; var queueName = context.GetJobParameter&lt;string&gt;("QueueName"); if (retryAttempt &lt;= this[queueName].RetryAttempts) { ScheduleAgainLater(context, retryAttempt, failedState, queueName); } else { TransitionToDeleted(context, failedState, queueName); } } public void OnStateApplied( ApplyStateContext context, IWriteOnlyTransaction transaction) { if (context.NewState is ScheduledState &amp;&amp; context.NewState.Reason != null &amp;&amp; context.NewState.Reason.StartsWith("Retry attempt")) { transaction.AddToSet("retries", context.BackgroundJob.Id); } } public void OnStateUnapplied( ApplyStateContext context, IWriteOnlyTransaction transaction) { if (context.OldStateName == ScheduledState.StateName) { transaction.RemoveFromSet("retries", context.BackgroundJob.Id); } } private void ScheduleAgainLater( ElectStateContext context, int retryAttempt, FailedState failedState, string queueName) { context.SetJobParameter("RetryCount", retryAttempt); var delay = TimeSpan.FromSeconds(this[queueName].DelayInSeconds); const int maxMessageLength = 50; var exceptionMessage = failedState.Exception.Message.Length &gt; maxMessageLength ? failedState.Exception.Message.Substring(0, maxMessageLength - 1) + "‚Ä¶" : failedState.Exception.Message; // If attempt number is less than max attempts, we should // schedule the job to run again later. var reason = $"Retry attempt {retryAttempt} of {this[queueName].RetryAttempts}: {exceptionMessage}"; context.CandidateState = delay == TimeSpan.Zero ? (IState)new EnqueuedState { Reason = reason } : new ScheduledState(delay) { Reason = reason }; } private void TransitionToDeleted( ElectStateContext context, FailedState failedState, string queueName) { context.CandidateState = new DeletedState { Reason = this[queueName].RetryAttempts &gt; 0 ? "Exceeded the maximum number of retry attempts." : "Retries were disabled for this job." }; } }</span></span></code> </pre> <br><blockquote>  Hinweis zum Code: Bei der Implementierung der <code>HangfireRetryJobFilter</code> Klasse wurde die <code>AutomaticRetryAttribute</code> Klasse von <code>HangfireRetryJobFilter</code> als Grundlage verwendet, daher stimmt die Implementierung einiger Methoden teilweise mit den entsprechenden Methoden dieser Klasse √ºberein. </blockquote><br><h3 id="problema-3---kak-otpravit-zadachu-na-vypolnenie-v-konkretnuyu-ochered">  Problem 3 - Wie sende ich eine Aufgabe an eine bestimmte Warteschlange? </h3><br><p>  Es gelang mir, zwei M√∂glichkeiten zu finden, um die Aufgabe der Warteschlange zuzuweisen: dokumentiert und - nein. </p><br><p>  <strong>1. Methode</strong> - H√§ngen Sie das entsprechende Attribut an die Methode </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Queue(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"video_queue"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } BackgroundJob.Enqueue(() =&gt; SomeMethod());</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://docs.hangfire.io/en/latest/background-processing/configuring-queues.html</a> </p><br><p>  <strong>2. Methode</strong> (undokumentiert) - Verwenden Sie die <code>BackgroundJobClient</code> Klasse </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BackgroundJobClient(); client.Create(() =&gt; MyMethod(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnqueuedState(<span class="hljs-string"><span class="hljs-string">"video_queue"</span></span>));</code> </pre> <br><p>  Der Vorteil der zweiten Methode besteht darin, dass keine unn√∂tigen Abh√§ngigkeiten von Hangfire entstehen und Sie entscheiden k√∂nnen, in welchem ‚Äã‚ÄãProzess die Aufgabe ausgef√ºhrt werden soll.  Leider wurde in der offiziellen Dokumentation die <code>BackgroundJobClient</code> Klasse und deren Anwendung nicht erw√§hnt.  Ich habe die zweite Methode in meiner L√∂sung verwendet, daher wird sie in der Praxis getestet. </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  In diesem Artikel haben wir die Unterst√ºtzung mehrerer Warteschlangen in Hangfire verwendet, um die Verarbeitung verschiedener Aufgabentypen zu trennen.  Wir haben unseren Mechanismus zum Wiederholen nicht erfolgreich abgeschlossener Aufgaben mit der M√∂glichkeit der individuellen Konfiguration f√ºr jede Warteschlange implementiert, die Funktionalit√§t von Hangfire mithilfe von Jobfiltern erweitert und gelernt, wie Aufgaben zur Ausf√ºhrung an die gew√ºnschte Warteschlange gesendet werden. </p><br><p>  Ich hoffe, dieser Artikel ist f√ºr jemanden n√ºtzlich.  Ich werde gerne einen Kommentar abgeben. </p><br><h3 id="poleznye-ssylki">  N√ºtzliche Links </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hangfire-Dokumentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hangfire-Quellcode</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scott Hanselman - Ausf√ºhren von Hintergrundaufgaben in ASP.NET</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434364/">https://habr.com/ru/post/de434364/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434354/index.html">Erstellen eines Gesichtserkennungsmodells mithilfe von Deep Learning in Python</a></li>
<li><a href="../de434356/index.html">Python Stiller mit E-Mail</a></li>
<li><a href="../de434358/index.html">Importsubstitution von Betriebssystemen. Wie sehe ich ein inl√§ndisches Betriebssystem?</a></li>
<li><a href="../de434360/index.html">Erkl√§rtes Gespr√§ch √ºber asynchrone Programmierung in Javascript</a></li>
<li><a href="../de434362/index.html">NICHT f√ºr 2019 prognostiziert</a></li>
<li><a href="../de434368/index.html">Maschinelles Lernen zum Auffinden von Fehlern im Code: Wie ich bei JetBrains Research interniert habe</a></li>
<li><a href="../de434370/index.html">Ein weiterer Schatteneroberer in Phaser oder die Verwendung von Fahrr√§dern</a></li>
<li><a href="../de434374/index.html">RBAC in Kubernetes √ºberpr√ºfen</a></li>
<li><a href="../de434380/index.html">Grundlagen der Abh√§ngigkeitsinjektion</a></li>
<li><a href="../de434382/index.html">Portierung von Alpine Linux auf RISC-V</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>