<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙃 🍹 🤟 Hangfire Queue-Unterstützung 👨🏽‍🔬 🔇 🧛🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hangfire ist eine Bibliothek für .net (Kern), die die asynchrone Ausführung von Code nach dem Prinzip "Feuer und Vergessen" ermöglicht. Ein Beispiel f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hangfire Queue-Unterstützung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434364/"><p>  Hangfire ist eine Bibliothek für .net (Kern), die die asynchrone Ausführung von Code nach dem Prinzip "Feuer und Vergessen" ermöglicht.  Ein Beispiel für einen solchen Code kann das Senden von E-Mails, die Videoverarbeitung, die Synchronisierung mit einem anderen System usw. sein.  Neben "Feuer und Vergessen" werden auch verzögerte Aufgaben sowie geplante Aufgaben im Cron-Format unterstützt. </p><br><p>  Derzeit gibt es viele solcher Bibliotheken.  Einige der Vorteile von Hangfire sind: </p><br><ul><li>  Einfache Konfiguration, bequeme API </li><li>  Zuverlässigkeit  Hangfire garantiert, dass die erstellte Aufgabe mindestens einmal ausgeführt wird </li><li>  Fähigkeit, Aufgaben parallel auszuführen und hervorragende Leistung </li><li>  Erweiterbarkeit (hier werden wir es unten verwenden) </li><li>  Ziemlich vollständige und verständliche Dokumentation </li><li>  Dashboard, in dem Sie alle Statistiken zu den Aufgaben anzeigen können </li></ul><br><p>  Ich werde nicht zu sehr ins Detail gehen, da es viele gute Artikel über Hangfire und dessen Verwendung gibt.  In diesem Artikel werde ich erläutern, wie die Unterstützung mehrerer Warteschlangen (oder Aufgabenpools) verwendet wird, wie die Standard-Wiederholungsfunktionalität behoben wird und jede Warteschlange eine individuelle Konfiguration erhält. </p><a name="habracut"></a><br><h3 id="suschestvuyuschaya-podderzhka-psevdo-ocheredey">  Bestehende Unterstützung für (Pseudo-) Warteschlangen </h3><br><p>  Wichtiger Hinweis: Im Titel habe ich den Begriff Pseudo-Warteschlange verwendet, da Hangfire nicht garantiert, dass Aufgaben in einer bestimmten Reihenfolge ausgeführt werden.  Das heißt,  Das Prinzip "First In First Out" gilt nicht und wir werden uns nicht darauf verlassen.  Darüber hinaus empfiehlt der Autor der Bibliothek, Aufgaben idempotent zu machen, d. H.  stetig gegen unvorhergesehene Mehrfachausführung.  Weiter werde ich nur das Wort "Warteschlange" verwenden, weil  Hangfire verwendet den Begriff "Warteschlange". </p><br><p>  Hangfire bietet einfache Unterstützung für Warteschlangen.  Obwohl es nicht die Flexibilität von Message Queue-Systemen wie rabbitMQ oder Azure Service Bus bietet, reicht es häufig aus, um eine Vielzahl von Aufgaben zu lösen. </p><br><p>  Jede Aufgabe hat die Eigenschaft "Warteschlange", dh den Namen der Warteschlange, in der sie ausgeführt werden soll.  Standardmäßig wird die Aufgabe mit dem Namen "Standard" an die Warteschlange gesendet, sofern nicht anders angegeben.  Die Unterstützung mehrerer Warteschlangen ist erforderlich, um die Ausführung von Aufgaben unterschiedlicher Art separat zu verwalten.  Beispielsweise möchten wir möglicherweise, dass die Videoverarbeitungsaufgaben in die Warteschlange "video_queue" fallen und E-Mails an die Warteschlange "email_queue" senden.  Auf diese Weise können wir diese beiden Arten von Aufgaben unabhängig voneinander ausführen.  Wenn Sie die Videoverarbeitung auf einen dedizierten Server verschieben möchten, können Sie dies einfach tun, indem Sie einen separaten Hangfire-Server als Konsolenanwendung ausführen, die die Warteschlange "video_queue" verarbeitet. </p><br><h3 id="pereydem-k-praktike">  Lass uns weiter üben </h3><br><p>  Das Einrichten des Hangfire-Servers im asp.net-Kern ist wie folgt: </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IApplicationBuilder app</span></span></span><span class="hljs-function">)</span></span> { app.UseHangfireServer(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BackgroundJobServerOptions { WorkerCount = <span class="hljs-number"><span class="hljs-number">2</span></span>, Queues = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-string"><span class="hljs-string">"email_queue"</span></span>, <span class="hljs-string"><span class="hljs-string">"video_queue"</span></span> } }); }</code> </pre> <br><h3 id="problema-1---zadachi-pri-povtore-popadayut-v-ochered-default">  Problem 1 - Wiederholungsaufgaben fallen in die Standardwarteschlange </h3><br><p>  Wie oben erwähnt, gibt es in Hangfire eine Standardwarteschlange namens "Standard".  Wenn eine in der Warteschlange platzierte Aufgabe, z. B. "video_queue", fehlgeschlagen ist und erneut versucht werden muss, wird sie erneut an die "Standard" -Warteschlange und nicht an "video_queue" gesendet, sodass unsere Aufgabe überhaupt nicht ausgeführt wird die Instanz des Hangfire-Servers, die wir, wenn überhaupt, möchten.  Dieses Verhalten wurde von mir experimentell festgestellt und ist wahrscheinlich ein Fehler in Hangfire. </p><br><h4 id="job-filters">  Jobfilter </h4><br><p>  Hangfire bietet uns die Möglichkeit, die Funktionalität mithilfe von sogenannten Filtern ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jobfiltern</a> ) zu erweitern, die im Prinzip den Aktionsfiltern in ASP.NET MVC ähnlich sind.  Tatsache ist, dass die interne Logik von Hangfire als State Machine implementiert ist.  Dies ist eine Engine, die die Aufgaben im Pool nacheinander von einem Status in einen anderen überträgt (z. B. erstellt -&gt; in die Warteschlange gestellt -&gt; verarbeitet -&gt; erfolgreich). Mithilfe von Filtern können wir die Task, die bei jeder Änderung ihres Status ausgeführt wird, "abfangen" und bearbeiten.  Ein Filter wird als Attribut implementiert, das auf eine einzelne Methode, Klasse oder global angewendet werden kann. </p><br><h4 id="job-parameters">  Auftragsparameter </h4><br><p>  Das ElectStateContext-Objekt wird als Argument an die Filtermethode übergeben.  Dieses Objekt enthält vollständige Informationen zur aktuellen Aufgabe.  Es verfügt unter anderem über die Methoden GetJobParameter &lt;&gt; (...) und SettJobParameter &lt;&gt; (...).  Mit Jobparametern können Sie Informationen zu einer Aufgabe in einer Datenbank speichern.  In den Auftragsparametern wird der Name der Warteschlange gespeichert, an die die Aufgabe ursprünglich gesendet wurde. Nur aus irgendeinem Grund werden diese Informationen bei der nächsten Wiederholung ignoriert. </p><br><h3 id="reshenie">  Lösung </h3><br><p>  Wir haben also eine Aufgabe, die fehlerhaft endete und zur erneuten Ausführung in der richtigen Warteschlange gesendet werden sollte (in derselben, die ihr zum Zeitpunkt der ersten Erstellung zugewiesen wurde).  Die Wiederholung einer Aufgabe, die mit einem Fehler abgeschlossen wurde, ist ein Übergang vom Status "Fehlgeschlagen" in den Status "In Warteschlange".  Um das Problem zu lösen, erstellen Sie einen Filter, der beim Eintritt der Aufgabe in den Status "Enqueued" prüft, in welcher Warteschlange die Aufgabe ursprünglich gesendet wurde, und den Parameter "QueueName" auf den gewünschten Wert setzt: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HangfireUseCorrectQueueFilter</span></span> : <span class="hljs-title"><span class="hljs-title">JobFilterAttribute</span></span>, <span class="hljs-title"><span class="hljs-title">IElectStateFilter</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnStateElection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ElectStateContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context.CandidateState <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> EnqueuedState enqueuedState) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> queueName = context.GetJobParameter&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"QueueName"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(queueName)) { context.SetJobParameter(<span class="hljs-string"><span class="hljs-string">"QueueName"</span></span>, enqueuedState.Queue); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { enqueuedState.Queue = queueName; } } } }</code> </pre> <br><p>  Fügen Sie unserer Konfiguration den folgenden Code hinzu, um den Standardfilter auf alle Aufgaben (d. H. Global) anzuwenden: </p><br><pre> <code class="cs hljs">GlobalJobFilters.Filters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireUseCorrectQueueFilter { Order = <span class="hljs-number"><span class="hljs-number">1</span></span> });</code> </pre> <br><p>  Ein weiterer kleiner Haken ist, dass die GlobalJobFilters-Auflistung standardmäßig eine Instanz der AutomaticRetryAttribute-Klasse enthält.  Dies ist ein Standardfilter, der für die erneute Ausführung fehlgeschlagener Aufgaben verantwortlich ist.  Er sendet die Aufgabe auch an die "Standard" -Warteschlange und ignoriert die ursprüngliche Warteschlange.  Damit unser Fahrrad fahren kann, müssen Sie diesen Filter aus der Sammlung entfernen und unseren Filter die Verantwortung für die wiederholten Aufgaben übernehmen lassen.  Infolgedessen sieht der Konfigurationscode folgendermaßen aus: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defaultRetryFilter = GlobalJobFilters.Filters .FirstOrDefault(f =&gt; f.Instance <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> AutomaticRetryAttribute); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (defaultRetryFilter != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; defaultRetryFilter.Instance != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { GlobalJobFilters.Filters.Remove(defaultRetryFilter.Instance); } GlobalJobFilters.Filters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireUseCorrectQueueFilter { Order = <span class="hljs-number"><span class="hljs-number">1</span></span> });</code> </pre> <br><p>  Es ist zu beachten, dass AutomaticRetryAttribute die Logik implementiert, das Intervall zwischen Versuchen automatisch zu vergrößern (das Intervall erhöht sich mit jedem nachfolgenden Versuch), und AutomaticRetryAttribute aus der GlobalJobFilters-Auflistung zu entfernen. Diese Funktionalität wird aufgegeben (siehe Implementierung der <a href="">ScheduleAgainLater-</a> Methode). </p><br><p>  Wir haben also erreicht, dass unsere Aufgaben in verschiedenen Warteschlangen ausgeführt werden können. Auf diese Weise können wir ihre Ausführung unabhängig verwalten, einschließlich der Verarbeitung verschiedener Warteschlangen auf verschiedenen Computern.  Erst jetzt wissen wir nicht, wie oft und in welchem ​​Intervall unsere Aufgaben im Fehlerfall wiederholt werden, da wir AutomaticRetryAttribute aus der Filtersammlung entfernt haben. </p><br><h3 id="problema-2---individualnye-nastroyki-dlya-kazhdoy-ocheredi">  Problem 2 - Individuelle Einstellungen für jede Warteschlange </h3><br><p>  Wir möchten in der Lage sein, das Intervall und die Anzahl der Wiederholungen für jede Warteschlange separat zu konfigurieren. Wenn wir für eine Warteschlange keine expliziten Werte angegeben haben, möchten wir, dass die Standardwerte angewendet werden.  Dazu implementieren wir einen anderen Filter und nennen ihn <code>HangfireRetryJobFilter</code> . </p><br><p>  Im Idealfall sollte der Konfigurationscode ungefähr so ​​aussehen: </p><br><pre> <code class="cs hljs">GlobalJobFilters.Filters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireRetryJobFilter { Order = <span class="hljs-number"><span class="hljs-number">2</span></span>, [<span class="hljs-string"><span class="hljs-string">"email_queue"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireQueueSettings { DelayInSeconds = <span class="hljs-number"><span class="hljs-number">120</span></span>, RetryAttempts = <span class="hljs-number"><span class="hljs-number">3</span></span> }, [<span class="hljs-string"><span class="hljs-string">"video_queue"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireQueueSettings { DelayInSeconds = <span class="hljs-number"><span class="hljs-number">60</span></span>, RetryAttempts = <span class="hljs-number"><span class="hljs-number">5</span></span> } });</code> </pre> <br><h3 id="reshenie-1">  Lösung </h3><br><p>  <code>HangfireQueueSettings</code> Sie dazu zuerst die <code>HangfireQueueSettings</code> Klasse hinzu, die als Container für unsere Einstellungen dient. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HangfireQueueSettings</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RetryAttempts { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> DelayInSeconds { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br><p>  Anschließend fügen wir die Implementierung des Filters selbst hinzu. Wenn die Aufgaben nach einem Fehler wiederholt werden, werden die Einstellungen abhängig von der Konfiguration der Warteschlange angewendet und die Anzahl der Wiederholungsversuche überwacht: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HangfireRetryJobFilter</span></span> : <span class="hljs-title"><span class="hljs-title">JobFilterAttribute</span></span>, <span class="hljs-title"><span class="hljs-title">IElectStateFilter</span></span>, <span class="hljs-title"><span class="hljs-title">IApplyStateFilter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HangfireQueueSettings _defaultQueueSettings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireQueueSettings { RetryAttempts = <span class="hljs-number"><span class="hljs-number">3</span></span>, DelayInSeconds = <span class="hljs-number"><span class="hljs-number">10</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, HangfireQueueSettings&gt; _settings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, HangfireQueueSettings&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HangfireQueueSettings <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> queueName] { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _settings.TryGetValue(queueName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> HangfireQueueSettings queueSettings) ? queueSettings : _defaultQueueSettings; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _settings[queueName] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnStateElection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ElectStateContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(context.CandidateState <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> FailedState failedState)) { <span class="hljs-comment"><span class="hljs-comment">// This filter accepts only failed job state. return; } var retryAttempt = context.GetJobParameter&lt;int&gt;("RetryCount") + 1; var queueName = context.GetJobParameter&lt;string&gt;("QueueName"); if (retryAttempt &lt;= this[queueName].RetryAttempts) { ScheduleAgainLater(context, retryAttempt, failedState, queueName); } else { TransitionToDeleted(context, failedState, queueName); } } public void OnStateApplied( ApplyStateContext context, IWriteOnlyTransaction transaction) { if (context.NewState is ScheduledState &amp;&amp; context.NewState.Reason != null &amp;&amp; context.NewState.Reason.StartsWith("Retry attempt")) { transaction.AddToSet("retries", context.BackgroundJob.Id); } } public void OnStateUnapplied( ApplyStateContext context, IWriteOnlyTransaction transaction) { if (context.OldStateName == ScheduledState.StateName) { transaction.RemoveFromSet("retries", context.BackgroundJob.Id); } } private void ScheduleAgainLater( ElectStateContext context, int retryAttempt, FailedState failedState, string queueName) { context.SetJobParameter("RetryCount", retryAttempt); var delay = TimeSpan.FromSeconds(this[queueName].DelayInSeconds); const int maxMessageLength = 50; var exceptionMessage = failedState.Exception.Message.Length &gt; maxMessageLength ? failedState.Exception.Message.Substring(0, maxMessageLength - 1) + "…" : failedState.Exception.Message; // If attempt number is less than max attempts, we should // schedule the job to run again later. var reason = $"Retry attempt {retryAttempt} of {this[queueName].RetryAttempts}: {exceptionMessage}"; context.CandidateState = delay == TimeSpan.Zero ? (IState)new EnqueuedState { Reason = reason } : new ScheduledState(delay) { Reason = reason }; } private void TransitionToDeleted( ElectStateContext context, FailedState failedState, string queueName) { context.CandidateState = new DeletedState { Reason = this[queueName].RetryAttempts &gt; 0 ? "Exceeded the maximum number of retry attempts." : "Retries were disabled for this job." }; } }</span></span></code> </pre> <br><blockquote>  Hinweis zum Code: Bei der Implementierung der <code>HangfireRetryJobFilter</code> Klasse wurde die <code>AutomaticRetryAttribute</code> Klasse von <code>HangfireRetryJobFilter</code> als Grundlage verwendet, daher stimmt die Implementierung einiger Methoden teilweise mit den entsprechenden Methoden dieser Klasse überein. </blockquote><br><h3 id="problema-3---kak-otpravit-zadachu-na-vypolnenie-v-konkretnuyu-ochered">  Problem 3 - Wie sende ich eine Aufgabe an eine bestimmte Warteschlange? </h3><br><p>  Es gelang mir, zwei Möglichkeiten zu finden, um die Aufgabe der Warteschlange zuzuweisen: dokumentiert und - nein. </p><br><p>  <strong>1. Methode</strong> - Hängen Sie das entsprechende Attribut an die Methode </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Queue(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"video_queue"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } BackgroundJob.Enqueue(() =&gt; SomeMethod());</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://docs.hangfire.io/en/latest/background-processing/configuring-queues.html</a> </p><br><p>  <strong>2. Methode</strong> (undokumentiert) - Verwenden Sie die <code>BackgroundJobClient</code> Klasse </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BackgroundJobClient(); client.Create(() =&gt; MyMethod(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnqueuedState(<span class="hljs-string"><span class="hljs-string">"video_queue"</span></span>));</code> </pre> <br><p>  Der Vorteil der zweiten Methode besteht darin, dass keine unnötigen Abhängigkeiten von Hangfire entstehen und Sie entscheiden können, in welchem ​​Prozess die Aufgabe ausgeführt werden soll.  Leider wurde in der offiziellen Dokumentation die <code>BackgroundJobClient</code> Klasse und deren Anwendung nicht erwähnt.  Ich habe die zweite Methode in meiner Lösung verwendet, daher wird sie in der Praxis getestet. </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  In diesem Artikel haben wir die Unterstützung mehrerer Warteschlangen in Hangfire verwendet, um die Verarbeitung verschiedener Aufgabentypen zu trennen.  Wir haben unseren Mechanismus zum Wiederholen nicht erfolgreich abgeschlossener Aufgaben mit der Möglichkeit der individuellen Konfiguration für jede Warteschlange implementiert, die Funktionalität von Hangfire mithilfe von Jobfiltern erweitert und gelernt, wie Aufgaben zur Ausführung an die gewünschte Warteschlange gesendet werden. </p><br><p>  Ich hoffe, dieser Artikel ist für jemanden nützlich.  Ich werde gerne einen Kommentar abgeben. </p><br><h3 id="poleznye-ssylki">  Nützliche Links </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hangfire-Dokumentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hangfire-Quellcode</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scott Hanselman - Ausführen von Hintergrundaufgaben in ASP.NET</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434364/">https://habr.com/ru/post/de434364/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434354/index.html">Erstellen eines Gesichtserkennungsmodells mithilfe von Deep Learning in Python</a></li>
<li><a href="../de434356/index.html">Python Stiller mit E-Mail</a></li>
<li><a href="../de434358/index.html">Importsubstitution von Betriebssystemen. Wie sehe ich ein inländisches Betriebssystem?</a></li>
<li><a href="../de434360/index.html">Erklärtes Gespräch über asynchrone Programmierung in Javascript</a></li>
<li><a href="../de434362/index.html">NICHT für 2019 prognostiziert</a></li>
<li><a href="../de434368/index.html">Maschinelles Lernen zum Auffinden von Fehlern im Code: Wie ich bei JetBrains Research interniert habe</a></li>
<li><a href="../de434370/index.html">Ein weiterer Schatteneroberer in Phaser oder die Verwendung von Fahrrädern</a></li>
<li><a href="../de434374/index.html">RBAC in Kubernetes überprüfen</a></li>
<li><a href="../de434380/index.html">Grundlagen der Abhängigkeitsinjektion</a></li>
<li><a href="../de434382/index.html">Portierung von Alpine Linux auf RISC-V</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>