<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÜ üë± üéì Copiar sem√°ntica y gesti√≥n de recursos en C ++ ‚ôåÔ∏è üë∂üèø üí∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En C ++, el programador debe decidir c√≥mo se liberar√°n los recursos utilizados; no hay herramientas autom√°ticas como el recolector de basura. El art√≠c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Copiar sem√°ntica y gesti√≥n de recursos en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425837/"><hr><p>  <i>En C ++, el programador debe decidir c√≥mo se liberar√°n los recursos utilizados; no hay herramientas autom√°ticas como el recolector de basura.</i>  <i>El art√≠culo analiza las posibles soluciones a este problema, examina en detalle los posibles problemas, as√≠ como una serie de problemas relacionados.</i> <i><br></i> </p><hr><br><a name="habracut"></a><br><h1>  Tabla de contenidos </h1><br><div class="spoiler">  <b class="spoiler_title">Tabla de contenidos</b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introduccion</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1. Estrategias b√°sicas de propiedad de copias</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estrategia de prohibici√≥n de copia</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estrategia de propiedad exclusiva</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estrategia de copia profunda</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estrategia de copropiedad</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2. Estrategia de copia profunda: problemas y soluciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copia en el registro</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Definir una funci√≥n de intercambio de estado para una clase</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Eliminar copias intermedias por el compilador</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementaci√≥n de la sem√°ntica del desplazamiento.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alojamiento vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">inserci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Resumen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3. Opciones para implementar una estrategia de propiedad compartida</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4. Estrategia de propiedad exclusiva y sem√°ntica del movimiento.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5. Estrategia de prohibici√≥n de copia - Inicio r√°pido</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6. El ciclo de vida del recurso y el objeto propietario del recurso.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Captura de recursos en la inicializaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Opciones avanzadas de gesti√≥n del ciclo de vida de los recursos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ciclo de vida de recursos extendido</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Captura de recursos √∫nicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mayor indirecci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copropiedad</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7. Resumen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aplicaciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ap√©ndice A. Enlaces de valor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ap√©ndice B. Sem√°ntica del desplazamiento</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Referencias</a> <br></p><br></div></div><br><a name="id-introdaction"></a><br><h1>  Introduccion </h1><br><p> La gesti√≥n de recursos es algo que un programador de C ++ tiene que hacer todo el tiempo.  Los recursos incluyen bloques de memoria, objetos del n√∫cleo del sistema operativo, bloqueos de subprocesos m√∫ltiples, conexiones de red, conexiones de bases de datos y cualquier objeto creado en la memoria din√°mica.  El acceso al recurso es a trav√©s de un descriptor, el tipo de descriptor suele ser un puntero o uno de sus alias ( <code>HANDLE</code> , etc.), a veces todo (descriptores de archivo UNIX).  Despu√©s de usar el recurso, debe liberarlo; de lo contrario, tarde o temprano, una aplicaci√≥n que no libera recursos (y posiblemente otras aplicaciones) se quedar√° sin recursos.  Este problema es muy grave, podemos decir que una de las caracter√≠sticas clave de .NET, Java y varias otras plataformas es un sistema unificado de gesti√≥n de recursos basado en la recolecci√≥n de basura. </p><br><p>  Las caracter√≠sticas orientadas a objetos de C ++ conducen naturalmente a la siguiente soluci√≥n: la clase que gestiona el recurso contiene el descriptor del recurso como miembro, inicializa el descriptor cuando se captura el recurso y lo libera en el destructor.  Pero despu√©s de alg√∫n pensamiento (o experiencia) llega la comprensi√≥n de que no es tan simple.  Y el principal problema es la sem√°ntica de la copia.  Si la clase que administra el recurso utiliza el constructor de copias generado por el compilador predeterminado, luego de copiar el objeto obtendremos dos copias del identificador del mismo recurso.  Si un objeto libera un recurso, entonces el segundo podr√° intentar usar o liberar el recurso ya liberado, que en cualquier caso es incorrecto y puede conducir al llamado comportamiento indefinido, es decir, cualquier cosa puede suceder, por ejemplo, una terminaci√≥n anormal del programa. </p><br><p>  Afortunadamente, en C ++, un programador puede controlar completamente el proceso de copia definiendo un constructor de copia y un operador de asignaci√≥n de copia por s√≠ mismo, lo que nos permite resolver el problema anterior, y generalmente no de una manera.  La implementaci√≥n de la copia debe estar estrechamente relacionada con el mecanismo de liberaci√≥n del recurso, y colectivamente llamaremos a esto la estrategia de propiedad de la copia.  La llamada "regla de los Tres Grandes" es bien conocida, y establece que si un programador define al menos una de las tres operaciones: constructor de copia, operador de asignaci√≥n de copia o destructor, debe definir las tres operaciones.  Las estrategias de propiedad de copia solo especifican c√≥mo hacer esto.  Hay cuatro estrategias b√°sicas de propiedad de copias. </p><br><a name="id-1"></a><br><h1>  1. Estrategias b√°sicas de propiedad de copias </h1><br><p>  Antes de la captura del recurso o despu√©s de su lanzamiento, el descriptor debe tomar un valor especial que indique que no est√° asociado con el recurso.  Por lo general, esto es cero, a veces -1, emitido a un tipo de descriptor.  En cualquier caso, dicho descriptor se llamar√° cero.  La clase que gestiona el recurso debe reconocer el descriptor nulo y no intentar usar o liberar el recurso en este caso. </p><br><a name="id-1-1"></a><br><h2>  1.1.  Estrategia de prohibici√≥n de copia </h2><br><p>  Esta es la estrategia m√°s simple.  En este caso, simplemente est√° prohibido copiar y asignar instancias de clase.  El destructor libera el recurso capturado.  En C ++, prohibir la copia no es dif√≠cil, la clase debe declarar, pero no definir, el constructor de copia cerrada y el operador de asignaci√≥n de copia. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;);    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  El compilador y el enlazador frustran los intentos de copia. </p><br><p>  El est√°ndar C ++ 11 ofrece una sintaxis especial para este caso: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Esta sintaxis es m√°s visual y proporciona mensajes m√°s comprensibles al compilador cuando intenta copiar. </p><br><p>  En la versi√≥n anterior de la biblioteca est√°ndar (C ++ 98), las clases de flujos de entrada / salida ( <code>std::fstream</code> , etc.) usaban la estrategia de prohibici√≥n de copia, y en Windows, muchas clases de MFC ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.).  En la biblioteca est√°ndar de C ++ 11, algunas clases utilizan esta estrategia para admitir la sincronizaci√≥n multiproceso. </p><br><a name="id-1-2"></a><br><h2>  1.2.  Estrategia de propiedad exclusiva </h2><br><p>  En este caso, al implementar la copia y la asignaci√≥n, el descriptor de recursos se mueve del objeto de origen al objeto de destino, es decir, permanece en una sola copia.  Despu√©s de copiar o asignar, el objeto fuente tiene un descriptor nulo y no puede usar el recurso.  El destructor libera el recurso capturado.  Los t√©rminos propiedad exclusiva o estricta [Josuttis] tambi√©n se utilizan para esta estrategia; Andrei Alexandrescu utiliza el t√©rmino copia destructiva.  En C ++ 11, esto se hace de la siguiente manera: la copia regular y la asignaci√≥n de copias est√°n prohibidas como se describe anteriormente, y se implementa la sem√°ntica de movimiento, es decir, se definen el constructor de movimiento y el operador de asignaci√≥n de movimiento.  (M√°s sobre sem√°ntica del movimiento m√°s adelante). </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Por lo tanto, la estrategia de propiedad exclusiva puede considerarse una extensi√≥n de la estrategia de prohibici√≥n de copia. </p><br><p>  En la biblioteca est√°ndar de C ++ 11, esta estrategia utiliza el puntero inteligente <code>std::unique_ptr&lt;&gt;</code> y algunas otras clases, por ejemplo: <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , as√≠ como las clases que anteriormente usaban la estrategia de prohibici√≥n de copia ( <code>std::fstream</code> , etc.).  En Windows, las clases de MFC que anteriormente usaban la estrategia de prohibici√≥n de copia tambi√©n comenzaron a usar la estrategia de propiedad exclusiva ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.). </p><br><a name="id-1-3"></a><br><h2>  1.3.  Estrategia de copia profunda </h2><br><p>  En este caso, puede copiar y asignar instancias de clase.  Es necesario definir el constructor de copia y el operador de asignaci√≥n de copia, de modo que el objeto de destino copie el recurso en s√≠ mismo del objeto de origen.  Despu√©s de eso, cada objeto posee su copia del recurso, puede usar, modificar y liberar el recurso de forma independiente.  El destructor libera el recurso capturado.  A veces, para los objetos que usan la estrategia de copia profunda, se usa el t√©rmino objetos de valor. </p><br><p>  Esta estrategia no se aplica a todos los recursos.  Se puede aplicar a los recursos asociados con un b√∫fer de memoria, como cadenas, pero no est√° muy claro c√≥mo aplicarlo a los objetos del n√∫cleo del sistema operativo, como archivos, mutexes, etc. </p><br><p>  La estrategia de copia profunda se utiliza en todos los tipos de cadenas de objetos, <code>std::vector&lt;&gt;</code> y otros contenedores de la biblioteca est√°ndar. </p><br><a name="id-1-4"></a><br><h2>  1.4.  Estrategia de copropiedad </h2><br><p>  En este caso, puede copiar y asignar instancias de clase.  Debe definir el constructor de copia y el operador de asignaci√≥n de copia en el que se copia el descriptor de recursos (as√≠ como otros datos), pero no el recurso en s√≠.  Despu√©s de eso, cada objeto tiene su propia copia del descriptor, puede usar, modificar, pero no puede liberar el recurso, siempre que haya al menos un objeto m√°s que posea una copia del descriptor.  Un recurso se libera despu√©s de que el √∫ltimo objeto que posee una copia del identificador se salga del alcance.  C√≥mo se puede implementar esto se describe a continuaci√≥n. </p><br><p>  Las estrategias de copropiedad a menudo son utilizadas por los punteros inteligentes, y tambi√©n es natural usarlas para recursos inmutables.  El puntero inteligente <code>std::shared_ptr&lt;&gt;</code> implementa esta estrategia en la biblioteca est√°ndar C ++ 11. </p><br><a name="id-2"></a><br><h1>  2. Estrategia de copia profunda: problemas y soluciones </h1><br><p>  Considere una plantilla para la funci√≥n de intercambio de estado de objetos de tipo <code>T</code> en la biblioteca est√°ndar C ++ 98. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span></span>;    a = b;    b = tmp; }</code> </pre> <br><p>  Si el tipo <code>T</code> posee un recurso y utiliza una estrategia de copia profunda, entonces tenemos tres operaciones para asignar un nuevo recurso, tres operaciones de copia y tres operaciones para liberar recursos.  Si bien en la mayor√≠a de los casos esta operaci√≥n puede llevarse a cabo sin asignar nuevos recursos y copiarlos, es suficiente que los objetos intercambien datos internos, incluido un descriptor de recursos.  Hay muchos ejemplos similares cuando tiene que crear copias temporales de un recurso y liberarlas inmediatamente.  Una implementaci√≥n tan ineficaz de las operaciones cotidianas estimul√≥ la b√∫squeda de soluciones para su optimizaci√≥n.  Consideremos las principales opciones. </p><br><a name="id-2-1"></a><br><h2>  2.1.  Copia en el registro </h2><br><p>  Copia en escritura (COW), tambi√©n llamada copia diferida, puede verse como un intento de combinar una estrategia de copia profunda y una estrategia de propiedad compartida.  Inicialmente, al copiar un objeto, el descriptor del recurso se copia, sin el recurso en s√≠ mismo, y para los propietarios el recurso se vuelve compartido y de solo lectura, pero tan pronto como alg√∫n propietario necesita modificar el recurso compartido, el recurso se copia y luego este propietario trabaja con su una copia  La implementaci√≥n de COW resuelve el problema del intercambio de estados: la asignaci√≥n adicional de recursos y la copia no ocurren.  El uso de COW es bastante popular cuando se implementan cadenas; por ejemplo, <code>CString</code> (MFC, ATL).  Se puede encontrar una discusi√≥n sobre las posibles formas de implementar la VAC y los problemas emergentes en [Meyers1], [Sutter].  [Guntheroth] propuso una implementaci√≥n COW usando <code>std::shared_ptr&lt;&gt;</code> .  Hay problemas al implementar COW en un entorno multiproceso, por lo que est√° prohibido usar COW para cadenas en la biblioteca est√°ndar de C ++ 11, consulte [Josuttis], [Guntheroth]. </p><br><p>  El desarrollo de la idea COW conduce al siguiente esquema de administraci√≥n de recursos: el recurso es inmutable y administrado por objetos que usan la estrategia de propiedad compartida, si es necesario, cambie el recurso, se crea un nuevo recurso modificado adecuadamente y se devuelve un nuevo objeto propietario.  Este esquema se utiliza para cadenas y otros objetos inmutables en las plataformas .NET y Java.  En la programaci√≥n funcional, se usa para estructuras de datos m√°s complejas. </p><br><a name="id-2-2"></a><br><h2>  2.2.  Definir una funci√≥n de intercambio de estado para una clase </h2><br><p>  Se mostr√≥ anteriormente cu√°n ineficiente puede ser la funci√≥n de intercambio de estado, implementada de manera directa, mediante copia y asignaci√≥n.  Y se usa bastante, por ejemplo, muchos algoritmos de la biblioteca est√°ndar lo usan.  Para que los algoritmos utilicen no otro <code>std::swap()</code> , sino otra funci√≥n espec√≠ficamente definida para la clase, se deben realizar dos pasos. </p><br><p>  1. Defina en la clase una funci√≥n miembro <code>Swap()</code> (el nombre no es importante) que implementa el intercambio de estados. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Debe asegurarse de que esta funci√≥n no arroje excepciones; en C ++ 11, dichas funciones deben declararse como <code>noexcept</code> . </p><br><p>  2. En el mismo espacio de nombres que la clase <code>X</code> (generalmente en el mismo archivo de encabezado), defina la funci√≥n <code>swap()</code> libre (no miembro) de la siguiente manera (el nombre y la firma son fundamentales): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; a, X&amp; b)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ a.Swap(b); }</code> </pre> <br><p>  Despu√©s de eso, los algoritmos de la biblioteca est√°ndar lo usar√°n, no <code>std::swap()</code> .  Esto proporciona un mecanismo llamado b√∫squeda dependiente de argumentos (ADL).  Para m√°s informaci√≥n sobre ADL, consulte [Dewhurst1]. </p><br><p>  En la biblioteca est√°ndar de C ++, todos los contenedores, punteros inteligentes, as√≠ como otras clases implementan la funci√≥n de intercambio de estado como se describi√≥ anteriormente. </p><br><p>  La funci√≥n de miembro <code>Swap()</code> generalmente se define f√°cilmente: es necesario aplicar secuencialmente una operaci√≥n de intercambio de estado a las bases de datos y miembros, si lo admiten, y <code>std::swap()</code> contrario. </p><br><p>  La descripci√≥n anterior est√° algo simplificada, una m√°s detallada se puede encontrar en [Meyers2].  Una discusi√≥n de temas relacionados con la funci√≥n de intercambio de estado tambi√©n se puede encontrar en [Sutter / Alexandrescu]. </p><br><p>  La funci√≥n de intercambio de estado se puede atribuir a una de las operaciones b√°sicas de la clase.  Al usarlo, puede definir con gracia otras operaciones.  Por ejemplo, el operador de asignaci√≥n de copia se define mediante copy y <code>Swap()</code> siguiente manera: </p><br><pre> <code class="cpp hljs">X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp; src) {    X tmp(src);    Swap(tmp);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  Esta plantilla se llama modismo de copia e intercambio o modismo de Herb Sutter, para m√°s detalles ver [Sutter], [Sutter / Alexandrescu], [Meyers2].  Su modificaci√≥n se puede aplicar para implementar la sem√°ntica del desplazamiento, ver secciones 2.4, 2.6.1. </p><br><a name="id-2-3"></a><br><h2>  2.3.  Eliminar copias intermedias por el compilador </h2><br><p>  Considera la clase </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Y funcion </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...    return X(/*  */); }</span></span></code> </pre> <br><p>  Con un enfoque directo, el retorno de la funci√≥n <code>Foo()</code> se realiza copiando la instancia de <code>X</code>  Pero los compiladores pueden eliminar la operaci√≥n de copia del c√≥digo, el objeto se crea directamente en el punto de llamada.  Esto se llama optimizaci√≥n del valor de retorno (RVO).  RVO ha sido utilizado por los desarrolladores de compiladores durante bastante tiempo y actualmente est√° arreglado en el est√°ndar C ++ 11.  Aunque la decisi√≥n sobre RVO la toma el compilador, el programador puede escribir c√≥digo en funci√≥n de su uso.  Para hacer esto, es deseable que la funci√≥n tenga un punto de retorno y el tipo de la expresi√≥n devuelta coincida con el tipo del valor de retorno de la funci√≥n.  En algunos casos, es aconsejable definir un constructor cerrado especial llamado "constructor computacional", para m√°s detalles ver [Dewhurst2].  RVO tambi√©n se discute en [Meyers3] y [Guntheroth]. </p><br><p>  Los compiladores pueden eliminar copias intermedias en otras situaciones. </p><br><a name="id-2-4"></a><br><h2>  2.4.  Implementaci√≥n de la sem√°ntica del desplazamiento. </h2><br><p>  La implementaci√≥n de la sem√°ntica de movimiento consiste en definir un constructor de movimiento que tenga un par√°metro de tipo rvalue-reference a la fuente y un operador de asignaci√≥n de movimiento con el mismo par√°metro. </p><br><p>  En la Biblioteca est√°ndar de C ++ 11, la plantilla de funci√≥n de intercambio de estado se define de la siguiente manera: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(a))</span></span></span></span>;    a = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b);    b = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(tmp); }</code> </pre> <br><p>  De acuerdo con las reglas para resolver sobrecargas de funciones que tienen par√°metros del tipo rvalue-reference (ver Ap√©ndice A), en el caso de que el tipo <code>T</code> tenga un constructor m√≥vil y un operador de asignaci√≥n m√≥vil, se utilizar√°n, y no habr√° asignaci√≥n de recursos temporales y copia.  De lo contrario, se utilizar√° el constructor de copia y el operador de asignaci√≥n de copia. </p><br><p>  El uso de la sem√°ntica de la reubicaci√≥n evita la creaci√≥n de copias temporales en un contexto mucho m√°s amplio que la funci√≥n de intercambio de estado descrita anteriormente.  La sem√°ntica de movimiento se aplica a cualquier valor de valor, es decir, un valor temporal sin nombre, as√≠ como al valor de retorno de una funci√≥n si se cre√≥ localmente (incluido lvalue), y no se aplic√≥ RVO.  En todos estos casos, se garantiza que el objeto de origen no se puede usar de ninguna manera despu√©s del movimiento.  La sem√°ntica de movimiento tambi√©n se aplica al valor lvalue al que se aplica la transformaci√≥n <code>std::move()</code> .  Pero en este caso, el programador es responsable de c√≥mo se usar√°n los objetos fuente despu√©s del movimiento (ejemplo <code>std::swap()</code> ). </p><br><p>  La biblioteca est√°ndar de C ++ 11 se ha redise√±ado teniendo en cuenta la sem√°ntica del movimiento.  Muchas clases han agregado un constructor de movimientos y un operador de asignaci√≥n de movimientos, as√≠ como otras funciones miembro, con par√°metros de referencia de tipo rvalue.  Por ejemplo, <code>std::vector&lt;T&gt;</code> tiene una versi√≥n sobrecargada de <code>void push_back(T&amp;&amp; src)</code> .  Todo esto permite en muchos casos evitar crear copias temporales. </p><br><p>  La implementaci√≥n de la sem√°ntica de movimiento no cancela las definiciones de la funci√≥n de intercambio de estado para una clase.  Una funci√≥n de intercambio de estado especialmente definida puede ser m√°s eficiente que el est√°ndar <code>std::swap()</code> .  Adem√°s, el constructor de movimientos y el operador de asignaci√≥n de movimientos se definen muy f√°cilmente usando la funci√≥n miembro del intercambio de estados de la siguiente manera (variaci√≥n del idioma de copia e intercambio): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {<span class="hljs-comment"><span class="hljs-comment">/*    */</span></span>}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/*   */</span></span>}    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X()    {        Swap(src);    }    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>    {        X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//         Swap(tmp);        return *this;    } // ... };</span></span></code> </pre> <br><p>  El constructor de movimientos y el operador de asignaci√≥n de movimientos son aquellas funciones miembro para las cuales es altamente deseable asegurarse de que no arrojen excepciones y, en consecuencia, se declaren como <code>noexcept</code> .  Esto le permite optimizar algunas operaciones de los contenedores de la biblioteca est√°ndar sin violar la estricta garant√≠a de seguridad de las excepciones; consulte [Meyers3] y [Guntheroth] para obtener m√°s detalles.  La plantilla propuesta proporciona dicha garant√≠a, siempre que el constructor predeterminado y la funci√≥n miembro del intercambio de estados no arrojen excepciones. </p><br><p>  El est√°ndar C ++ 11 permite que el compilador genere autom√°ticamente un constructor m√≥vil y un operador de asignaci√≥n m√≥vil. Para ello, deben declararse utilizando la construcci√≥n <code>"=default"</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Las operaciones se implementan aplicando secuencialmente la operaci√≥n de movimiento a las bases y los miembros de la clase, si son compatibles con el movimiento, y copie las operaciones de otra manera.  Est√° claro que esta opci√≥n est√° lejos de ser siempre aceptable.  Los descriptores sin formato no se mueven, pero generalmente no puede copiarlos.  Bajo ciertas condiciones, el compilador puede generar independientemente un constructor m√≥vil y un operador de asignaci√≥n m√≥vil similares, pero es mejor no aprovechar esta oportunidad, estas condiciones son bastante confusas y pueden cambiar f√°cilmente cuando se refina la clase.  Ver [Meyers3] para m√°s detalles. </p><br><p>  En general, la implementaci√≥n y el uso de la sem√°ntica del desplazamiento es bastante "sutil".  El compilador puede aplicar la copia donde el programador espera un movimiento.  Aqu√≠ hay algunas reglas para eliminar o al menos reducir la probabilidad de tal situaci√≥n. </p><br><ol><li>  Si es posible, use la prohibici√≥n de copia. </li><li>  Declare el constructor de movimiento y el operador de asignaci√≥n de movimiento como <code>noexcept</code> . </li><li>  Implementar sem√°ntica de movimiento para clases base y miembros. </li><li>  Aplique la transformaci√≥n <code>std::move()</code> a los par√°metros de las funciones de tipo rvalue reference. </li></ol><br><p>  La regla 2 se discuti√≥ anteriormente.  4   ,   rvalue-  lvalue (.   ).        . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...    B(B&amp;&amp; src) noexcept; }; class D : public B { // ...    D(D&amp;&amp; src) noexcept; }; D::D(D&amp;&amp; src) noexcept    : B(std::move(src)) //  {/* ... */}</span></span></code> </pre> <br><p>      ,     .        6.2.1. </p><br><a name="id-2-5"></a><br><h2>  2.5.  vs.  </h2><br><p>     ,    RVO (.  2.3),        ,    .          ( ),       ,     .        ,    .    C++11  - <code>emplace()</code> , <code>emplace_front()</code> , <code>emplace_back()</code> ,   . ,    -      ‚Äî   (variadic templates),         .  ,      C++11 ‚Äî     . </p><br><p>    : </p><br><ol><li>  ,   ,   . </li><li>  ,  ,     . </li></ol><br><p>  ,         . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; vs; vs.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'X'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//  vs.emplace_back(3, '7');           // </span></span></code> </pre> <br><p>       <code>std::string</code> ,           .        .     ,  ,  .      ,       [Meyers3]. </p><br><a name="id-2-6"></a><br><h2>  2.6.  Resumen </h2><br><p>     ,    ,     .               -  .                   .   ‚Äî     :    ,    .     ,       ,     ,  .      :     ,     ,  ¬´¬ª   . </p><br><p>      :       ,        ,       .NET  Java.             ,      <code>Clone()</code>  <code>Duplicate()</code> . </p><br><p>  -   -       ,         : </p><br><ol><li>    . </li><li>       . </li><li>   -       rvalue-. </li></ol><br><p>   .NET  Java   -    ,         ,   .NET      <code>IClonable</code> .    ,      . </p><br><a name="id-3"></a><br><h1> 3.       </h1><br><p>        ,    .      -    ,    .     ,    .        Windows:   ,   <code>HANDLE</code> ,  COM-.          <code>DuplicateHandle()</code> ,      <code>CloseHandle()</code> .  COM-  - <code>IUnknown::AddRef()</code>  <code>IUnknown::Release()</code> .   ATL    <code>ComPtr&lt;&gt;</code> ,  COM-  .    UNIX,       C,     <code>_dup()</code> ,      . </p><br><p>    C++11   <code>std::shared_ptr&lt;&gt;</code>    .  ,    ,      ,     ,   ,    . ,      .   <code>std::shared_ptr&lt;&gt;</code>    [Josuttis], [Meyers3]. </p><br><p>      :  -       ,          (  ).          (   )      ,              .   <code>std::shared_ptr&lt;&gt;</code>         <code>std::weak_ptr&lt;&gt;</code> .  . [Josuttis], [Meyers3]. </p><br><p>            - [Alexandrescu].    (   ) ,         [Schildt].          ,   . </p><br><p>        ( )    [Alger]. </p><br><p>            -.     [Josuttis]  [Alexandrescu]. </p><br><p>       -   .NET  Java.   ,    ,   ,         . </p><br><a name="id-4"></a><br><h1> 4.       </h1><br><p>          ,  C++   rvalue-   .    C++98    <code>std::auto_ptr&lt;&gt;</code> ,     ,     ,        .   ,       ,       (  ).  C++11   rvalue- ,         ,    .     C++11 <code>std::auto_ptr&gt;&lt;&gt;</code>        <code>std::unique_ptr&lt;&gt;</code> .           ,     [Josuttis], [Meyers3]. </p><br><p>        :   - ( <code>std::fstream</code> , etc.),       ( <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , etc.).  MFC     ,      ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.). </p><br><a name="id-5"></a><br><h1> 5.    ‚Äî   </h1><br><p>         .    ,        . ,   ,  ,          .     ,     ,    ,     (    )    .   , ,     ,   .            ( )  ,    .           ,       .    ‚Äî   .     6. </p><br><p>   ,     -  -,  ¬´  ¬ª,   -     .         -    . ,   ,     ,     ,    -       .      ¬´¬ª. </p><br><a name="id-6"></a><br><h1> 6.     -  </h1><br><p>     ,       - . ,       -.   . </p><br><a name="id-6-1"></a><br><h2> 6.1.     </h2><br><p>        -  .    ,  ,  : </p><br><ol><li>       .     ,    . </li><li>      . </li><li>    . </li></ol><br><p>      ,     , ,    .    C++11         . </p><br><p>          ¬´   ¬ª (resource acquisition is initialization, RAII).  RAII         (          ), .,  [Dewhurst1].      ¬´¬ª RAII.         , , ,     (immutable) RAII. </p><br><a name="id-6-2"></a><br><h2> 6.2.       </h2><br><p> ,      RAII,    ,  ,    .              - ,    ,    -      .  ,       ,       ,        .      . </p><br><a name="id-6-2-1"></a><br><h3> 6.2.1.     </h3><br><p>  ,  ,  ,     ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>       . </li><li>    . </li></ol><br><p>    C++11      , ,  ,     .     ,  - <code>clear()</code> ,     ,    ,      .         . ,   <code>shrink_to_fit()</code> ,    ,     (. ). </p><br><p> ,      RAII,     , ,        .        ,      . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// RAII    X(const X&amp;) = delete;            //      X&amp; operator=(const X&amp;) = delete; //      X(/*  */);              //      ~X();                            //   //     X() noexcept;                    //       X(X&amp;&amp; src) noexcept              //      X&amp; operator=(X&amp;&amp; src) noexcept;  //    // ... };</span></span></code> </pre> <br><p>         . </p><br><pre> <code class="cpp hljs">X x;                    <span class="hljs-comment"><span class="hljs-comment">//  ""  x = X(/*  */); //   x = X(/*  */); //   ,   x = X();                //  </span></span></code> </pre> <br><p>     <code>std::thread</code> . </p><br><p>      2.4,           -  .  , -        -    .    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// RAII // ... public: // ,         X() noexcept;    X(X&amp;&amp; src) noexcept;    X&amp; operator=(X&amp;&amp; src) noexcept;    void Swap(X&amp; other) noexcept; //      void Create(/*  */); //      void Close() noexcept;        //   // ... }; X::X() noexcept {/*    */}</span></span></code> </pre> <br><p>       : </p><br><pre> <code class="cpp hljs">X::X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X() {    Swap(src); } X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {    X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//     Swap(tmp);    return *this; }</span></span></code> </pre> <br><p>   -    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> X::Create(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>) {    <span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*  */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//      Swap(tmp); } void X::Close() noexcept {    X tmp;    Swap(tmp); }</span></span></code> </pre> <br><p>   ,          ,    , -      .           ,  ,       ,   .               ,         . </p><br><p>          -     ¬´  ¬ª,        ,   .         :      ,       ,      ( ).         :    ,   .        ,  :      ,          ,     .  ,            .       [Sutter], [Sutter/Alexandrescu], [Meyers2]. </p><br><p> ,   RAII                 . </p><br><a name="id-6-2-2"></a><br><h3> 6.2.2.    </h3><br><p>        RAII     .  ,  ,  ,    ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>    .    ,  . </li><li>      . </li><li>  . </li></ol><br><p>  ¬´¬ª RAII,   ‚Äî          .      ,     ,    . 3.       .    ¬´¬ª,    . </p><br><a name="id-6-2-3"></a><br><h3> 6.2.3.    </h3><br><p>        ‚Äî    .      RAII   ,       .         ,     .   ,   ,              (   -).  -       ( -).        6.2.1,         . </p><br><a name="id-6-3"></a><br><h2> 6.3.   </h2><br><p>     , -          RAII,     :            .      ,     ,   . </p><br><a name="id-conclusion"></a><br><h1> 7.  </h1><br><p> ,  ,     ,     ,    .  -        -. </p><br><p>  4   -: </p><br><ol><li>   . </li><li>   . </li><li>   . </li><li>   . </li></ol><br><p>         .      ,      - :   ,      , -    . </p><br><p>            ,    .  ,    ,     -,        ,     . </p><br><p>   -      .     .            ,                  (.  6.2.3).     ,      (.  6.2.1).         ,           .    ,       ,      .        ,       <code>std::shared_ptr&lt;&gt;</code> . </p><br><a name="id-apps"></a><br><h1>  Aplicaciones </h1><br><a name="id-app-1"></a><br><h2>  . Rvalue- </h2><br><p> Rvalue-    C++ ,          ,    rvalue-.  rvalue-   <code>T</code>   <code>T&amp;&amp;</code> . </p><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_Value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    Int(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val) : m_Value(val) {}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Value; }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ m_Value = val; } };</code> </pre> <br><p>    , rvalue-  . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r0; <span class="hljs-comment"><span class="hljs-comment">// error C2530: 'r0' : references must be initialized</span></span></code> </pre> <br><p>   rvalue-   ++    ,       lvalue.  Un ejemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Int&amp;&amp; r1 = i; <span class="hljs-comment"><span class="hljs-comment">// error C2440: 'initializing' : cannot convert from 'Int' to 'Int &amp;&amp;'</span></span></code> </pre> <br><p>      rvalue: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r2 = Int(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-comment"><span class="hljs-comment">// OK Int&amp;&amp; r3 = 5;       // OK</span></span></code> </pre> <br><p>  lvalue       rvalue-: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r4 = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Int&amp;&amp;&gt;(i); <span class="hljs-comment"><span class="hljs-comment">// OK</span></span></code> </pre> <br><p>      rvalue-    (  ) <code>std::move()</code> ,     (  <code>&lt;utility&gt;</code> ). </p><br><p> Rvalue      rvalue  ,     . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&amp; r5 = <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// OK int&amp; r6 = 2 * 2;  // error</span></span></code> </pre> <br><p>   rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; r.Get() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// : 7 r.Set(19); std::cout &lt;&lt; r.Get() &lt;&lt; '\n'; // : 19</span></span></code> </pre> <br><p> Rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">5</span></span>; Int&amp; x = r;           <span class="hljs-comment"><span class="hljs-comment">// OK const Int&amp; cx = r;    // OK</span></span></code> </pre> <br><p> Rvalue-     ,      .     ,      rvalue-,       rvalue . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// error, lvalue  Foo(std::move(i)); // OK Foo(Int(4));       // OK Foo(5);            // OK</span></span></code> </pre> <br><p>     ,      rvalue      rvalue-              ,       .        rvalue-. </p><br><p>   ,   ,   ,    rvalue-,   (ambiguous)  rvalue . </p><br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Int&amp;)</span></span></span></span>;</code> </pre> <br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(i)); // Foo(Int&amp;&amp;) Foo(Int(6));       // Foo(Int&amp;&amp;) Foo(9);            // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>       :  rvalue-     lvalue. </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; Foo(r);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(r)); // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>      ,    rvalue-,    lvalue     <code>std::move()</code> . .          2.4. </p><br><p>    ++11,   rvalue- ‚Äî      -.      (lvalue/rvalue)   <code>this</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X();    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoIt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> &amp;</span></span>;  <span class="hljs-comment"><span class="hljs-comment">// this   lvalue    void DoIt() &amp;&amp;; // this   rvalue // ... }; X x; x.DoIt();   // DoIt() &amp; X().DoIt(); // DoIt() &amp;&amp;</span></span></code> </pre> <br><a name="id-app-2"></a><br><h2>  .   </h2><br><p>  ,            ( <code>std::string</code> , <code>std::vector&lt;&gt;</code> , etc.)       .         ‚Äî    .     ,    rvalue-          .    ,   ,   -   ,    - ,    .       ,  ,       ,         rvalue,       lvalue.      ,        rvalue.    .         ,   (    lvalue),       RVO. </p><br><a name="id-refs"></a><br><h1>  Referencias </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> [Alexandrescu] <br> , .    C++.: .  del ingles  - M .: LLC "I.D. ¬ª, 2002. </p><br><p> [Guntheroth] <br> , .    C++.     .: .  del ingles ‚Äî .:  ¬´-¬ª, 2017. </p><br><p> [Josuttis] <br> ,  .   C++:  , 2- .: .  del ingles  - M .: LLC "I.D. ¬ª, 2014. </p><br><p> [Dewhurst1] <br> ,  . C++.  , 2- .: .  del ingles ‚Äî .: -, 2013. </p><br><p> [Dewhurst2] <br> ,  .   C++.         .: .  del ingles ‚Äî .:  , 2012. </p><br><p> [Meyers1] <br> , .    C++. 35        .: .  del ingles ‚Äî .:  , 2000. </p><br><p> [Meyers2] <br> , .   C++. 55        .: .  del ingles ‚Äî .:  , 2014. </p><br><p> [Meyers3] <br> , .    C++: 42    C++11  C ++14.: .  del ingles  - M .: LLC "I.D. ¬ª, 2016. </p><br><p> [Sutter] <br> , .     C++.: .  del ingles ‚Äî :  ¬´.. ¬ª, 2015. </p><br><p> [Sutter/Alexandrescu] <br> , . , .    ++.: .  del ingles  - M .: LLC "I.D. ¬ª, 2015. </p><br><p> [Schildt] <br> , .    C++.: .  del ingles ‚Äî .: -, 2005. </p><br><p> [Alger] <br> , . C++:  .: .  del ingles ‚Äî .:  ¬´ ¬´¬ª, 1999. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425837/">https://habr.com/ru/post/es425837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425827/index.html">Lecci√≥n de Google+: los proyectos deben garantizar que los l√≠mites entre los intereses de los usuarios en la vida real se respeten en l√≠nea</a></li>
<li><a href="../es425829/index.html">C√≥mo peleamos con Roskomnadzor y qu√© sali√≥ de eso</a></li>
<li><a href="../es425831/index.html">Alerta RKN - Base de datos Roskomnadzor en su navegador</a></li>
<li><a href="../es425833/index.html">Una herramienta para ayudarlo a elegir las mejores ideas para su producto.</a></li>
<li><a href="../es425835/index.html">"Breaking Bugs" en Sberbank: c√≥mo solucionar la tasa de errores de siete d√≠as por d√≠a</a></li>
<li><a href="../es425839/index.html">Revisi√≥n de la Conferencia Atlassian</a></li>
<li><a href="../es425843/index.html">Python para el ni√±o: elegir un tutorial</a></li>
<li><a href="../es425845/index.html">Aplicaciones de bloqueo autom√°tico en Google Play</a></li>
<li><a href="../es425847/index.html">Un ejemplo de uso de Microsoft Flow o C√≥mo dar flores a tu esposa</a></li>
<li><a href="../es425849/index.html">Amazon renunci√≥ y aument√≥ los salarios de los empleados</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>