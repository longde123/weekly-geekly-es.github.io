<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌆 👱 🎓 Copiar semántica y gestión de recursos en C ++ ♌️ 👶🏿 💺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En C ++, el programador debe decidir cómo se liberarán los recursos utilizados; no hay herramientas automáticas como el recolector de basura. El artíc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Copiar semántica y gestión de recursos en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425837/"><hr><p>  <i>En C ++, el programador debe decidir cómo se liberarán los recursos utilizados; no hay herramientas automáticas como el recolector de basura.</i>  <i>El artículo analiza las posibles soluciones a este problema, examina en detalle los posibles problemas, así como una serie de problemas relacionados.</i> <i><br></i> </p><hr><br><a name="habracut"></a><br><h1>  Tabla de contenidos </h1><br><div class="spoiler">  <b class="spoiler_title">Tabla de contenidos</b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introduccion</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1. Estrategias básicas de propiedad de copias</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estrategia de prohibición de copia</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estrategia de propiedad exclusiva</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estrategia de copia profunda</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estrategia de copropiedad</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2. Estrategia de copia profunda: problemas y soluciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copia en el registro</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Definir una función de intercambio de estado para una clase</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Eliminar copias intermedias por el compilador</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementación de la semántica del desplazamiento.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alojamiento vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">inserción</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Resumen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3. Opciones para implementar una estrategia de propiedad compartida</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4. Estrategia de propiedad exclusiva y semántica del movimiento.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5. Estrategia de prohibición de copia - Inicio rápido</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6. El ciclo de vida del recurso y el objeto propietario del recurso.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Captura de recursos en la inicialización</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Opciones avanzadas de gestión del ciclo de vida de los recursos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ciclo de vida de recursos extendido</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Captura de recursos únicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mayor indirección</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copropiedad</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7. Resumen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aplicaciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Apéndice A. Enlaces de valor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Apéndice B. Semántica del desplazamiento</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Referencias</a> <br></p><br></div></div><br><a name="id-introdaction"></a><br><h1>  Introduccion </h1><br><p> La gestión de recursos es algo que un programador de C ++ tiene que hacer todo el tiempo.  Los recursos incluyen bloques de memoria, objetos del núcleo del sistema operativo, bloqueos de subprocesos múltiples, conexiones de red, conexiones de bases de datos y cualquier objeto creado en la memoria dinámica.  El acceso al recurso es a través de un descriptor, el tipo de descriptor suele ser un puntero o uno de sus alias ( <code>HANDLE</code> , etc.), a veces todo (descriptores de archivo UNIX).  Después de usar el recurso, debe liberarlo; de lo contrario, tarde o temprano, una aplicación que no libera recursos (y posiblemente otras aplicaciones) se quedará sin recursos.  Este problema es muy grave, podemos decir que una de las características clave de .NET, Java y varias otras plataformas es un sistema unificado de gestión de recursos basado en la recolección de basura. </p><br><p>  Las características orientadas a objetos de C ++ conducen naturalmente a la siguiente solución: la clase que gestiona el recurso contiene el descriptor del recurso como miembro, inicializa el descriptor cuando se captura el recurso y lo libera en el destructor.  Pero después de algún pensamiento (o experiencia) llega la comprensión de que no es tan simple.  Y el principal problema es la semántica de la copia.  Si la clase que administra el recurso utiliza el constructor de copias generado por el compilador predeterminado, luego de copiar el objeto obtendremos dos copias del identificador del mismo recurso.  Si un objeto libera un recurso, entonces el segundo podrá intentar usar o liberar el recurso ya liberado, que en cualquier caso es incorrecto y puede conducir al llamado comportamiento indefinido, es decir, cualquier cosa puede suceder, por ejemplo, una terminación anormal del programa. </p><br><p>  Afortunadamente, en C ++, un programador puede controlar completamente el proceso de copia definiendo un constructor de copia y un operador de asignación de copia por sí mismo, lo que nos permite resolver el problema anterior, y generalmente no de una manera.  La implementación de la copia debe estar estrechamente relacionada con el mecanismo de liberación del recurso, y colectivamente llamaremos a esto la estrategia de propiedad de la copia.  La llamada "regla de los Tres Grandes" es bien conocida, y establece que si un programador define al menos una de las tres operaciones: constructor de copia, operador de asignación de copia o destructor, debe definir las tres operaciones.  Las estrategias de propiedad de copia solo especifican cómo hacer esto.  Hay cuatro estrategias básicas de propiedad de copias. </p><br><a name="id-1"></a><br><h1>  1. Estrategias básicas de propiedad de copias </h1><br><p>  Antes de la captura del recurso o después de su lanzamiento, el descriptor debe tomar un valor especial que indique que no está asociado con el recurso.  Por lo general, esto es cero, a veces -1, emitido a un tipo de descriptor.  En cualquier caso, dicho descriptor se llamará cero.  La clase que gestiona el recurso debe reconocer el descriptor nulo y no intentar usar o liberar el recurso en este caso. </p><br><a name="id-1-1"></a><br><h2>  1.1.  Estrategia de prohibición de copia </h2><br><p>  Esta es la estrategia más simple.  En este caso, simplemente está prohibido copiar y asignar instancias de clase.  El destructor libera el recurso capturado.  En C ++, prohibir la copia no es difícil, la clase debe declarar, pero no definir, el constructor de copia cerrada y el operador de asignación de copia. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;);    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  El compilador y el enlazador frustran los intentos de copia. </p><br><p>  El estándar C ++ 11 ofrece una sintaxis especial para este caso: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Esta sintaxis es más visual y proporciona mensajes más comprensibles al compilador cuando intenta copiar. </p><br><p>  En la versión anterior de la biblioteca estándar (C ++ 98), las clases de flujos de entrada / salida ( <code>std::fstream</code> , etc.) usaban la estrategia de prohibición de copia, y en Windows, muchas clases de MFC ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.).  En la biblioteca estándar de C ++ 11, algunas clases utilizan esta estrategia para admitir la sincronización multiproceso. </p><br><a name="id-1-2"></a><br><h2>  1.2.  Estrategia de propiedad exclusiva </h2><br><p>  En este caso, al implementar la copia y la asignación, el descriptor de recursos se mueve del objeto de origen al objeto de destino, es decir, permanece en una sola copia.  Después de copiar o asignar, el objeto fuente tiene un descriptor nulo y no puede usar el recurso.  El destructor libera el recurso capturado.  Los términos propiedad exclusiva o estricta [Josuttis] también se utilizan para esta estrategia; Andrei Alexandrescu utiliza el término copia destructiva.  En C ++ 11, esto se hace de la siguiente manera: la copia regular y la asignación de copias están prohibidas como se describe anteriormente, y se implementa la semántica de movimiento, es decir, se definen el constructor de movimiento y el operador de asignación de movimiento.  (Más sobre semántica del movimiento más adelante). </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Por lo tanto, la estrategia de propiedad exclusiva puede considerarse una extensión de la estrategia de prohibición de copia. </p><br><p>  En la biblioteca estándar de C ++ 11, esta estrategia utiliza el puntero inteligente <code>std::unique_ptr&lt;&gt;</code> y algunas otras clases, por ejemplo: <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , así como las clases que anteriormente usaban la estrategia de prohibición de copia ( <code>std::fstream</code> , etc.).  En Windows, las clases de MFC que anteriormente usaban la estrategia de prohibición de copia también comenzaron a usar la estrategia de propiedad exclusiva ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.). </p><br><a name="id-1-3"></a><br><h2>  1.3.  Estrategia de copia profunda </h2><br><p>  En este caso, puede copiar y asignar instancias de clase.  Es necesario definir el constructor de copia y el operador de asignación de copia, de modo que el objeto de destino copie el recurso en sí mismo del objeto de origen.  Después de eso, cada objeto posee su copia del recurso, puede usar, modificar y liberar el recurso de forma independiente.  El destructor libera el recurso capturado.  A veces, para los objetos que usan la estrategia de copia profunda, se usa el término objetos de valor. </p><br><p>  Esta estrategia no se aplica a todos los recursos.  Se puede aplicar a los recursos asociados con un búfer de memoria, como cadenas, pero no está muy claro cómo aplicarlo a los objetos del núcleo del sistema operativo, como archivos, mutexes, etc. </p><br><p>  La estrategia de copia profunda se utiliza en todos los tipos de cadenas de objetos, <code>std::vector&lt;&gt;</code> y otros contenedores de la biblioteca estándar. </p><br><a name="id-1-4"></a><br><h2>  1.4.  Estrategia de copropiedad </h2><br><p>  En este caso, puede copiar y asignar instancias de clase.  Debe definir el constructor de copia y el operador de asignación de copia en el que se copia el descriptor de recursos (así como otros datos), pero no el recurso en sí.  Después de eso, cada objeto tiene su propia copia del descriptor, puede usar, modificar, pero no puede liberar el recurso, siempre que haya al menos un objeto más que posea una copia del descriptor.  Un recurso se libera después de que el último objeto que posee una copia del identificador se salga del alcance.  Cómo se puede implementar esto se describe a continuación. </p><br><p>  Las estrategias de copropiedad a menudo son utilizadas por los punteros inteligentes, y también es natural usarlas para recursos inmutables.  El puntero inteligente <code>std::shared_ptr&lt;&gt;</code> implementa esta estrategia en la biblioteca estándar C ++ 11. </p><br><a name="id-2"></a><br><h1>  2. Estrategia de copia profunda: problemas y soluciones </h1><br><p>  Considere una plantilla para la función de intercambio de estado de objetos de tipo <code>T</code> en la biblioteca estándar C ++ 98. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span></span>;    a = b;    b = tmp; }</code> </pre> <br><p>  Si el tipo <code>T</code> posee un recurso y utiliza una estrategia de copia profunda, entonces tenemos tres operaciones para asignar un nuevo recurso, tres operaciones de copia y tres operaciones para liberar recursos.  Si bien en la mayoría de los casos esta operación puede llevarse a cabo sin asignar nuevos recursos y copiarlos, es suficiente que los objetos intercambien datos internos, incluido un descriptor de recursos.  Hay muchos ejemplos similares cuando tiene que crear copias temporales de un recurso y liberarlas inmediatamente.  Una implementación tan ineficaz de las operaciones cotidianas estimuló la búsqueda de soluciones para su optimización.  Consideremos las principales opciones. </p><br><a name="id-2-1"></a><br><h2>  2.1.  Copia en el registro </h2><br><p>  Copia en escritura (COW), también llamada copia diferida, puede verse como un intento de combinar una estrategia de copia profunda y una estrategia de propiedad compartida.  Inicialmente, al copiar un objeto, el descriptor del recurso se copia, sin el recurso en sí mismo, y para los propietarios el recurso se vuelve compartido y de solo lectura, pero tan pronto como algún propietario necesita modificar el recurso compartido, el recurso se copia y luego este propietario trabaja con su una copia  La implementación de COW resuelve el problema del intercambio de estados: la asignación adicional de recursos y la copia no ocurren.  El uso de COW es bastante popular cuando se implementan cadenas; por ejemplo, <code>CString</code> (MFC, ATL).  Se puede encontrar una discusión sobre las posibles formas de implementar la VAC y los problemas emergentes en [Meyers1], [Sutter].  [Guntheroth] propuso una implementación COW usando <code>std::shared_ptr&lt;&gt;</code> .  Hay problemas al implementar COW en un entorno multiproceso, por lo que está prohibido usar COW para cadenas en la biblioteca estándar de C ++ 11, consulte [Josuttis], [Guntheroth]. </p><br><p>  El desarrollo de la idea COW conduce al siguiente esquema de administración de recursos: el recurso es inmutable y administrado por objetos que usan la estrategia de propiedad compartida, si es necesario, cambie el recurso, se crea un nuevo recurso modificado adecuadamente y se devuelve un nuevo objeto propietario.  Este esquema se utiliza para cadenas y otros objetos inmutables en las plataformas .NET y Java.  En la programación funcional, se usa para estructuras de datos más complejas. </p><br><a name="id-2-2"></a><br><h2>  2.2.  Definir una función de intercambio de estado para una clase </h2><br><p>  Se mostró anteriormente cuán ineficiente puede ser la función de intercambio de estado, implementada de manera directa, mediante copia y asignación.  Y se usa bastante, por ejemplo, muchos algoritmos de la biblioteca estándar lo usan.  Para que los algoritmos utilicen no otro <code>std::swap()</code> , sino otra función específicamente definida para la clase, se deben realizar dos pasos. </p><br><p>  1. Defina en la clase una función miembro <code>Swap()</code> (el nombre no es importante) que implementa el intercambio de estados. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Debe asegurarse de que esta función no arroje excepciones; en C ++ 11, dichas funciones deben declararse como <code>noexcept</code> . </p><br><p>  2. En el mismo espacio de nombres que la clase <code>X</code> (generalmente en el mismo archivo de encabezado), defina la función <code>swap()</code> libre (no miembro) de la siguiente manera (el nombre y la firma son fundamentales): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; a, X&amp; b)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ a.Swap(b); }</code> </pre> <br><p>  Después de eso, los algoritmos de la biblioteca estándar lo usarán, no <code>std::swap()</code> .  Esto proporciona un mecanismo llamado búsqueda dependiente de argumentos (ADL).  Para más información sobre ADL, consulte [Dewhurst1]. </p><br><p>  En la biblioteca estándar de C ++, todos los contenedores, punteros inteligentes, así como otras clases implementan la función de intercambio de estado como se describió anteriormente. </p><br><p>  La función de miembro <code>Swap()</code> generalmente se define fácilmente: es necesario aplicar secuencialmente una operación de intercambio de estado a las bases de datos y miembros, si lo admiten, y <code>std::swap()</code> contrario. </p><br><p>  La descripción anterior está algo simplificada, una más detallada se puede encontrar en [Meyers2].  Una discusión de temas relacionados con la función de intercambio de estado también se puede encontrar en [Sutter / Alexandrescu]. </p><br><p>  La función de intercambio de estado se puede atribuir a una de las operaciones básicas de la clase.  Al usarlo, puede definir con gracia otras operaciones.  Por ejemplo, el operador de asignación de copia se define mediante copy y <code>Swap()</code> siguiente manera: </p><br><pre> <code class="cpp hljs">X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp; src) {    X tmp(src);    Swap(tmp);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  Esta plantilla se llama modismo de copia e intercambio o modismo de Herb Sutter, para más detalles ver [Sutter], [Sutter / Alexandrescu], [Meyers2].  Su modificación se puede aplicar para implementar la semántica del desplazamiento, ver secciones 2.4, 2.6.1. </p><br><a name="id-2-3"></a><br><h2>  2.3.  Eliminar copias intermedias por el compilador </h2><br><p>  Considera la clase </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Y funcion </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...    return X(/*  */); }</span></span></code> </pre> <br><p>  Con un enfoque directo, el retorno de la función <code>Foo()</code> se realiza copiando la instancia de <code>X</code>  Pero los compiladores pueden eliminar la operación de copia del código, el objeto se crea directamente en el punto de llamada.  Esto se llama optimización del valor de retorno (RVO).  RVO ha sido utilizado por los desarrolladores de compiladores durante bastante tiempo y actualmente está arreglado en el estándar C ++ 11.  Aunque la decisión sobre RVO la toma el compilador, el programador puede escribir código en función de su uso.  Para hacer esto, es deseable que la función tenga un punto de retorno y el tipo de la expresión devuelta coincida con el tipo del valor de retorno de la función.  En algunos casos, es aconsejable definir un constructor cerrado especial llamado "constructor computacional", para más detalles ver [Dewhurst2].  RVO también se discute en [Meyers3] y [Guntheroth]. </p><br><p>  Los compiladores pueden eliminar copias intermedias en otras situaciones. </p><br><a name="id-2-4"></a><br><h2>  2.4.  Implementación de la semántica del desplazamiento. </h2><br><p>  La implementación de la semántica de movimiento consiste en definir un constructor de movimiento que tenga un parámetro de tipo rvalue-reference a la fuente y un operador de asignación de movimiento con el mismo parámetro. </p><br><p>  En la Biblioteca estándar de C ++ 11, la plantilla de función de intercambio de estado se define de la siguiente manera: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(a))</span></span></span></span>;    a = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b);    b = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(tmp); }</code> </pre> <br><p>  De acuerdo con las reglas para resolver sobrecargas de funciones que tienen parámetros del tipo rvalue-reference (ver Apéndice A), en el caso de que el tipo <code>T</code> tenga un constructor móvil y un operador de asignación móvil, se utilizarán, y no habrá asignación de recursos temporales y copia.  De lo contrario, se utilizará el constructor de copia y el operador de asignación de copia. </p><br><p>  El uso de la semántica de la reubicación evita la creación de copias temporales en un contexto mucho más amplio que la función de intercambio de estado descrita anteriormente.  La semántica de movimiento se aplica a cualquier valor de valor, es decir, un valor temporal sin nombre, así como al valor de retorno de una función si se creó localmente (incluido lvalue), y no se aplicó RVO.  En todos estos casos, se garantiza que el objeto de origen no se puede usar de ninguna manera después del movimiento.  La semántica de movimiento también se aplica al valor lvalue al que se aplica la transformación <code>std::move()</code> .  Pero en este caso, el programador es responsable de cómo se usarán los objetos fuente después del movimiento (ejemplo <code>std::swap()</code> ). </p><br><p>  La biblioteca estándar de C ++ 11 se ha rediseñado teniendo en cuenta la semántica del movimiento.  Muchas clases han agregado un constructor de movimientos y un operador de asignación de movimientos, así como otras funciones miembro, con parámetros de referencia de tipo rvalue.  Por ejemplo, <code>std::vector&lt;T&gt;</code> tiene una versión sobrecargada de <code>void push_back(T&amp;&amp; src)</code> .  Todo esto permite en muchos casos evitar crear copias temporales. </p><br><p>  La implementación de la semántica de movimiento no cancela las definiciones de la función de intercambio de estado para una clase.  Una función de intercambio de estado especialmente definida puede ser más eficiente que el estándar <code>std::swap()</code> .  Además, el constructor de movimientos y el operador de asignación de movimientos se definen muy fácilmente usando la función miembro del intercambio de estados de la siguiente manera (variación del idioma de copia e intercambio): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {<span class="hljs-comment"><span class="hljs-comment">/*    */</span></span>}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/*   */</span></span>}    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X()    {        Swap(src);    }    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>    {        X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//         Swap(tmp);        return *this;    } // ... };</span></span></code> </pre> <br><p>  El constructor de movimientos y el operador de asignación de movimientos son aquellas funciones miembro para las cuales es altamente deseable asegurarse de que no arrojen excepciones y, en consecuencia, se declaren como <code>noexcept</code> .  Esto le permite optimizar algunas operaciones de los contenedores de la biblioteca estándar sin violar la estricta garantía de seguridad de las excepciones; consulte [Meyers3] y [Guntheroth] para obtener más detalles.  La plantilla propuesta proporciona dicha garantía, siempre que el constructor predeterminado y la función miembro del intercambio de estados no arrojen excepciones. </p><br><p>  El estándar C ++ 11 permite que el compilador genere automáticamente un constructor móvil y un operador de asignación móvil. Para ello, deben declararse utilizando la construcción <code>"=default"</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Las operaciones se implementan aplicando secuencialmente la operación de movimiento a las bases y los miembros de la clase, si son compatibles con el movimiento, y copie las operaciones de otra manera.  Está claro que esta opción está lejos de ser siempre aceptable.  Los descriptores sin formato no se mueven, pero generalmente no puede copiarlos.  Bajo ciertas condiciones, el compilador puede generar independientemente un constructor móvil y un operador de asignación móvil similares, pero es mejor no aprovechar esta oportunidad, estas condiciones son bastante confusas y pueden cambiar fácilmente cuando se refina la clase.  Ver [Meyers3] para más detalles. </p><br><p>  En general, la implementación y el uso de la semántica del desplazamiento es bastante "sutil".  El compilador puede aplicar la copia donde el programador espera un movimiento.  Aquí hay algunas reglas para eliminar o al menos reducir la probabilidad de tal situación. </p><br><ol><li>  Si es posible, use la prohibición de copia. </li><li>  Declare el constructor de movimiento y el operador de asignación de movimiento como <code>noexcept</code> . </li><li>  Implementar semántica de movimiento para clases base y miembros. </li><li>  Aplique la transformación <code>std::move()</code> a los parámetros de las funciones de tipo rvalue reference. </li></ol><br><p>  La regla 2 se discutió anteriormente.  4   ,   rvalue-  lvalue (.   ).        . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...    B(B&amp;&amp; src) noexcept; }; class D : public B { // ...    D(D&amp;&amp; src) noexcept; }; D::D(D&amp;&amp; src) noexcept    : B(std::move(src)) //  {/* ... */}</span></span></code> </pre> <br><p>      ,     .        6.2.1. </p><br><a name="id-2-5"></a><br><h2>  2.5.  vs.  </h2><br><p>     ,    RVO (.  2.3),        ,    .          ( ),       ,     .        ,    .    C++11  - <code>emplace()</code> , <code>emplace_front()</code> , <code>emplace_back()</code> ,   . ,    -      —   (variadic templates),         .  ,      C++11 —     . </p><br><p>    : </p><br><ol><li>  ,   ,   . </li><li>  ,  ,     . </li></ol><br><p>  ,         . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; vs; vs.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'X'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//  vs.emplace_back(3, '7');           // </span></span></code> </pre> <br><p>       <code>std::string</code> ,           .        .     ,  ,  .      ,       [Meyers3]. </p><br><a name="id-2-6"></a><br><h2>  2.6.  Resumen </h2><br><p>     ,    ,     .               -  .                   .   —     :    ,    .     ,       ,     ,  .      :     ,     ,  «»   . </p><br><p>      :       ,        ,       .NET  Java.             ,      <code>Clone()</code>  <code>Duplicate()</code> . </p><br><p>  -   -       ,         : </p><br><ol><li>    . </li><li>       . </li><li>   -       rvalue-. </li></ol><br><p>   .NET  Java   -    ,         ,   .NET      <code>IClonable</code> .    ,      . </p><br><a name="id-3"></a><br><h1> 3.       </h1><br><p>        ,    .      -    ,    .     ,    .        Windows:   ,   <code>HANDLE</code> ,  COM-.          <code>DuplicateHandle()</code> ,      <code>CloseHandle()</code> .  COM-  - <code>IUnknown::AddRef()</code>  <code>IUnknown::Release()</code> .   ATL    <code>ComPtr&lt;&gt;</code> ,  COM-  .    UNIX,       C,     <code>_dup()</code> ,      . </p><br><p>    C++11   <code>std::shared_ptr&lt;&gt;</code>    .  ,    ,      ,     ,   ,    . ,      .   <code>std::shared_ptr&lt;&gt;</code>    [Josuttis], [Meyers3]. </p><br><p>      :  -       ,          (  ).          (   )      ,              .   <code>std::shared_ptr&lt;&gt;</code>         <code>std::weak_ptr&lt;&gt;</code> .  . [Josuttis], [Meyers3]. </p><br><p>            - [Alexandrescu].    (   ) ,         [Schildt].          ,   . </p><br><p>        ( )    [Alger]. </p><br><p>            -.     [Josuttis]  [Alexandrescu]. </p><br><p>       -   .NET  Java.   ,    ,   ,         . </p><br><a name="id-4"></a><br><h1> 4.       </h1><br><p>          ,  C++   rvalue-   .    C++98    <code>std::auto_ptr&lt;&gt;</code> ,     ,     ,        .   ,       ,       (  ).  C++11   rvalue- ,         ,    .     C++11 <code>std::auto_ptr&gt;&lt;&gt;</code>        <code>std::unique_ptr&lt;&gt;</code> .           ,     [Josuttis], [Meyers3]. </p><br><p>        :   - ( <code>std::fstream</code> , etc.),       ( <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , etc.).  MFC     ,      ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.). </p><br><a name="id-5"></a><br><h1> 5.    —   </h1><br><p>         .    ,        . ,   ,  ,          .     ,     ,    ,     (    )    .   , ,     ,   .            ( )  ,    .           ,       .    —   .     6. </p><br><p>   ,     -  -,  «  »,   -     .         -    . ,   ,     ,     ,    -       .      «». </p><br><a name="id-6"></a><br><h1> 6.     -  </h1><br><p>     ,       - . ,       -.   . </p><br><a name="id-6-1"></a><br><h2> 6.1.     </h2><br><p>        -  .    ,  ,  : </p><br><ol><li>       .     ,    . </li><li>      . </li><li>    . </li></ol><br><p>      ,     , ,    .    C++11         . </p><br><p>          «   » (resource acquisition is initialization, RAII).  RAII         (          ), .,  [Dewhurst1].      «» RAII.         , , ,     (immutable) RAII. </p><br><a name="id-6-2"></a><br><h2> 6.2.       </h2><br><p> ,      RAII,    ,  ,    .              - ,    ,    -      .  ,       ,       ,        .      . </p><br><a name="id-6-2-1"></a><br><h3> 6.2.1.     </h3><br><p>  ,  ,  ,     ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>       . </li><li>    . </li></ol><br><p>    C++11      , ,  ,     .     ,  - <code>clear()</code> ,     ,    ,      .         . ,   <code>shrink_to_fit()</code> ,    ,     (. ). </p><br><p> ,      RAII,     , ,        .        ,      . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// RAII    X(const X&amp;) = delete;            //      X&amp; operator=(const X&amp;) = delete; //      X(/*  */);              //      ~X();                            //   //     X() noexcept;                    //       X(X&amp;&amp; src) noexcept              //      X&amp; operator=(X&amp;&amp; src) noexcept;  //    // ... };</span></span></code> </pre> <br><p>         . </p><br><pre> <code class="cpp hljs">X x;                    <span class="hljs-comment"><span class="hljs-comment">//  ""  x = X(/*  */); //   x = X(/*  */); //   ,   x = X();                //  </span></span></code> </pre> <br><p>     <code>std::thread</code> . </p><br><p>      2.4,           -  .  , -        -    .    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// RAII // ... public: // ,         X() noexcept;    X(X&amp;&amp; src) noexcept;    X&amp; operator=(X&amp;&amp; src) noexcept;    void Swap(X&amp; other) noexcept; //      void Create(/*  */); //      void Close() noexcept;        //   // ... }; X::X() noexcept {/*    */}</span></span></code> </pre> <br><p>       : </p><br><pre> <code class="cpp hljs">X::X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X() {    Swap(src); } X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {    X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//     Swap(tmp);    return *this; }</span></span></code> </pre> <br><p>   -    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> X::Create(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>) {    <span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*  */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//      Swap(tmp); } void X::Close() noexcept {    X tmp;    Swap(tmp); }</span></span></code> </pre> <br><p>   ,          ,    , -      .           ,  ,       ,   .               ,         . </p><br><p>          -     «  »,        ,   .         :      ,       ,      ( ).         :    ,   .        ,  :      ,          ,     .  ,            .       [Sutter], [Sutter/Alexandrescu], [Meyers2]. </p><br><p> ,   RAII                 . </p><br><a name="id-6-2-2"></a><br><h3> 6.2.2.    </h3><br><p>        RAII     .  ,  ,  ,    ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>    .    ,  . </li><li>      . </li><li>  . </li></ol><br><p>  «» RAII,   —          .      ,     ,    . 3.       .    «»,    . </p><br><a name="id-6-2-3"></a><br><h3> 6.2.3.    </h3><br><p>        —    .      RAII   ,       .         ,     .   ,   ,              (   -).  -       ( -).        6.2.1,         . </p><br><a name="id-6-3"></a><br><h2> 6.3.   </h2><br><p>     , -          RAII,     :            .      ,     ,   . </p><br><a name="id-conclusion"></a><br><h1> 7.  </h1><br><p> ,  ,     ,     ,    .  -        -. </p><br><p>  4   -: </p><br><ol><li>   . </li><li>   . </li><li>   . </li><li>   . </li></ol><br><p>         .      ,      - :   ,      , -    . </p><br><p>            ,    .  ,    ,     -,        ,     . </p><br><p>   -      .     .            ,                  (.  6.2.3).     ,      (.  6.2.1).         ,           .    ,       ,      .        ,       <code>std::shared_ptr&lt;&gt;</code> . </p><br><a name="id-apps"></a><br><h1>  Aplicaciones </h1><br><a name="id-app-1"></a><br><h2>  . Rvalue- </h2><br><p> Rvalue-    C++ ,          ,    rvalue-.  rvalue-   <code>T</code>   <code>T&amp;&amp;</code> . </p><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_Value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    Int(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val) : m_Value(val) {}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Value; }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ m_Value = val; } };</code> </pre> <br><p>    , rvalue-  . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r0; <span class="hljs-comment"><span class="hljs-comment">// error C2530: 'r0' : references must be initialized</span></span></code> </pre> <br><p>   rvalue-   ++    ,       lvalue.  Un ejemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Int&amp;&amp; r1 = i; <span class="hljs-comment"><span class="hljs-comment">// error C2440: 'initializing' : cannot convert from 'Int' to 'Int &amp;&amp;'</span></span></code> </pre> <br><p>      rvalue: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r2 = Int(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-comment"><span class="hljs-comment">// OK Int&amp;&amp; r3 = 5;       // OK</span></span></code> </pre> <br><p>  lvalue       rvalue-: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r4 = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Int&amp;&amp;&gt;(i); <span class="hljs-comment"><span class="hljs-comment">// OK</span></span></code> </pre> <br><p>      rvalue-    (  ) <code>std::move()</code> ,     (  <code>&lt;utility&gt;</code> ). </p><br><p> Rvalue      rvalue  ,     . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&amp; r5 = <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// OK int&amp; r6 = 2 * 2;  // error</span></span></code> </pre> <br><p>   rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; r.Get() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// : 7 r.Set(19); std::cout &lt;&lt; r.Get() &lt;&lt; '\n'; // : 19</span></span></code> </pre> <br><p> Rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">5</span></span>; Int&amp; x = r;           <span class="hljs-comment"><span class="hljs-comment">// OK const Int&amp; cx = r;    // OK</span></span></code> </pre> <br><p> Rvalue-     ,      .     ,      rvalue-,       rvalue . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// error, lvalue  Foo(std::move(i)); // OK Foo(Int(4));       // OK Foo(5);            // OK</span></span></code> </pre> <br><p>     ,      rvalue      rvalue-              ,       .        rvalue-. </p><br><p>   ,   ,   ,    rvalue-,   (ambiguous)  rvalue . </p><br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Int&amp;)</span></span></span></span>;</code> </pre> <br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(i)); // Foo(Int&amp;&amp;) Foo(Int(6));       // Foo(Int&amp;&amp;) Foo(9);            // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>       :  rvalue-     lvalue. </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; Foo(r);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(r)); // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>      ,    rvalue-,    lvalue     <code>std::move()</code> . .          2.4. </p><br><p>    ++11,   rvalue- —      -.      (lvalue/rvalue)   <code>this</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X();    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoIt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> &amp;</span></span>;  <span class="hljs-comment"><span class="hljs-comment">// this   lvalue    void DoIt() &amp;&amp;; // this   rvalue // ... }; X x; x.DoIt();   // DoIt() &amp; X().DoIt(); // DoIt() &amp;&amp;</span></span></code> </pre> <br><a name="id-app-2"></a><br><h2>  .   </h2><br><p>  ,            ( <code>std::string</code> , <code>std::vector&lt;&gt;</code> , etc.)       .         —    .     ,    rvalue-          .    ,   ,   -   ,    - ,    .       ,  ,       ,         rvalue,       lvalue.      ,        rvalue.    .         ,   (    lvalue),       RVO. </p><br><a name="id-refs"></a><br><h1>  Referencias </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> [Alexandrescu] <br> , .    C++.: .  del ingles  - M .: LLC "I.D. », 2002. </p><br><p> [Guntheroth] <br> , .    C++.     .: .  del ingles — .:  «-», 2017. </p><br><p> [Josuttis] <br> ,  .   C++:  , 2- .: .  del ingles  - M .: LLC "I.D. », 2014. </p><br><p> [Dewhurst1] <br> ,  . C++.  , 2- .: .  del ingles — .: -, 2013. </p><br><p> [Dewhurst2] <br> ,  .   C++.         .: .  del ingles — .:  , 2012. </p><br><p> [Meyers1] <br> , .    C++. 35        .: .  del ingles — .:  , 2000. </p><br><p> [Meyers2] <br> , .   C++. 55        .: .  del ingles — .:  , 2014. </p><br><p> [Meyers3] <br> , .    C++: 42    C++11  C ++14.: .  del ingles  - M .: LLC "I.D. », 2016. </p><br><p> [Sutter] <br> , .     C++.: .  del ingles — :  «.. », 2015. </p><br><p> [Sutter/Alexandrescu] <br> , . , .    ++.: .  del ingles  - M .: LLC "I.D. », 2015. </p><br><p> [Schildt] <br> , .    C++.: .  del ingles — .: -, 2005. </p><br><p> [Alger] <br> , . C++:  .: .  del ingles — .:  « «», 1999. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425837/">https://habr.com/ru/post/es425837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425827/index.html">Lección de Google+: los proyectos deben garantizar que los límites entre los intereses de los usuarios en la vida real se respeten en línea</a></li>
<li><a href="../es425829/index.html">Cómo peleamos con Roskomnadzor y qué salió de eso</a></li>
<li><a href="../es425831/index.html">Alerta RKN - Base de datos Roskomnadzor en su navegador</a></li>
<li><a href="../es425833/index.html">Una herramienta para ayudarlo a elegir las mejores ideas para su producto.</a></li>
<li><a href="../es425835/index.html">"Breaking Bugs" en Sberbank: cómo solucionar la tasa de errores de siete días por día</a></li>
<li><a href="../es425839/index.html">Revisión de la Conferencia Atlassian</a></li>
<li><a href="../es425843/index.html">Python para el niño: elegir un tutorial</a></li>
<li><a href="../es425845/index.html">Aplicaciones de bloqueo automático en Google Play</a></li>
<li><a href="../es425847/index.html">Un ejemplo de uso de Microsoft Flow o Cómo dar flores a tu esposa</a></li>
<li><a href="../es425849/index.html">Amazon renunció y aumentó los salarios de los empleados</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>