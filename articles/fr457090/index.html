<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🏭 🧘🏻 🕢 Lits de sécurité: JWT 🤲🏽 💤 🧑🏿‍🤝‍🧑🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De nombreuses applications utilisent des jetons Web JSON (JWT) pour permettre au client de s'identifier pour un échange d'informations ultérieur après...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lits de sécurité: JWT</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acribia/blog/457090/"><img src="https://habrastorage.org/webt/db/hk/3r/dbhk3r8z4e24imgvw6mjwyuat4m.png"><br><br>  De nombreuses applications utilisent des jetons Web JSON (JWT) pour permettre au client de s'identifier pour un échange d'informations ultérieur après l'authentification. <br><br>  JSON Web Token est une norme ouverte (RFC 7519) qui définit une manière compacte et autonome de transférer en toute sécurité des informations entre les parties en tant qu'objet JSON. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/oq/x9/6o/oqx96ozecxiq4qbsrzrk-dw7n5u.png"><br>  Ces informations sont vérifiées et fiables car elles sont signées numériquement. <br>  Les JWT peuvent être signés à l'aide d'un secret (à l'aide de l'algorithme HMAC) ou de paires de clés publiques / privées à l'aide de RSA ou ECDSA. <br><br>  Le jeton Web JSON est utilisé pour transmettre des informations concernant l'identité et les caractéristiques du client.  Ce «conteneur» est signé par le serveur afin que le client n’interfère pas avec lui et ne puisse pas changer, par exemple, les données d’identification ou les caractéristiques (par exemple, le rôle d’un simple utilisateur à un administrateur ou changer la connexion du client). <br><br>  Ce jeton est créé en cas d'authentification réussie et est vérifié par le serveur avant de commencer à exécuter chaque demande client.  Le jeton est utilisé par l'application comme une «carte d'identité» du client (un conteneur contenant toutes les informations le concernant).  Le serveur a la possibilité de vérifier la validité et l'intégrité du jeton de manière sûre.  Cela permet à l'application d'être sans état (l'application sans état n'enregistre pas les données client générées dans une session pour une utilisation dans la prochaine session avec ce client (chaque session est indépendante)), et le processus d'authentification est indépendant des services utilisés (dans le sens où les technologies client et serveur peut varier, y compris même le canal de transport, bien que HTTP soit le plus couramment utilisé). <br><br><h2>  Considérations pour l'utilisation de JWT </h2><br>  Même si le jeton JWT est facile à utiliser et vous permet de fournir des services (principalement REST) ​​sans état (sans état), cette solution ne convient pas à toutes les applications, car elle comporte certaines mises en garde, telles que la question du stockage du jeton. <br><br>  Si l'application ne doit pas être complètement sans état, vous pouvez envisager d'utiliser le système de session traditionnel fourni par toutes les plateformes Web.  Cependant, pour les applications sans état, JWT est une bonne option s'il est implémenté correctement. <br><br><h2>  Problèmes et attaques JWT </h2><br><h4>  Utilisation de l'algorithme de hachage NONE </h4><br>  Une attaque similaire se produit lorsqu'un attaquant modifie le jeton et modifie également l'algorithme de hachage (champ «alg») pour indiquer via le mot clé none que l'intégrité du jeton a déjà été vérifiée.  Certaines bibliothèques ont vu les jetons signés en utilisant l'algorithme none comme un jeton valide avec une signature vérifiée, de sorte qu'un attaquant pourrait modifier la charge utile du jeton et l'application ferait confiance au jeton. <br><br>  Pour empêcher une attaque, vous devez utiliser la bibliothèque JWT, qui n'est pas affectée par cette vulnérabilité.  De plus, lors de la validation du token, vous devez explicitement demander l'utilisation de l'algorithme attendu. <br><br>  <b><u>Exemple d'implémentation:</u></b> <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  HMAC   String   JVM private transient byte[] keyHMAC = ...; ... //        //    HMAC-256 - JWTVerifier verifier = JWT.require(Algorithm.HMAC256(keyHMAC)).build(); //   DecodedJWT decodedToken = verifier.verify(token);</span></span></code> </pre> <br><h4>  Interception de jetons </h4><br>  L'attaque se produit lorsqu'un jeton a été intercepté ou volé par un attaquant et qu'il l'utilise pour accéder au système en utilisant les informations d'identification d'un utilisateur spécifique. <br><br>  La protection consiste à ajouter un «contexte utilisateur» au token.  Le contexte utilisateur comprendra les informations suivantes: <br><br><ol><li>  Une chaîne aléatoire générée au stade de l'authentification et incluse dans le jeton, et également envoyée au client sous forme de cookie plus sécurisé (indicateurs: préfixes HttpOnly + Secure + SameSite + cookie). </li><li>  Le hachage SHA256 de la chaîne aléatoire sera stocké dans le jeton afin qu'aucun problème XSS ne permette à l'attaquant de lire la valeur de la chaîne aléatoire et de définir le cookie attendu. </li></ol><br>  L'adresse IP ne sera pas utilisée dans le contexte, car il existe des situations dans lesquelles l'adresse IP peut changer au cours d'une session, par exemple, lorsqu'un utilisateur accède à l'application via son téléphone portable.  L'adresse IP change alors légitimement en permanence.  De plus, l'utilisation d'une adresse IP peut potentiellement poser des problèmes au niveau de la conformité au RGPD européen. <br><br>  Si, lors de la vérification du jeton, le jeton reçu ne contient pas le contexte correct, il doit être rejeté. <br>  <b><u>Exemple d'implémentation:</u></b> <br><br>  <i>Code pour créer un jeton après une authentification réussie:</i> <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  HMAC   String   JVM private transient byte[] keyHMAC = ...; //    private SecureRandom secureRandom = new SecureRandom(); ... //   ,     byte[] randomFgp = new byte[50]; secureRandom.nextBytes(randomFgp); String userFingerprint = DatatypeConverter.printHexBinary(randomFgp); //    cookie String fingerprintCookie = "__Secure-Fgp=" + userFingerprint + "; SameSite=Strict; HttpOnly; Secure"; response.addHeader("Set-Cookie", fingerprintCookie); // SHA256          // (  )  XSS      //     cookie MessageDigest digest = MessageDigest.getInstance("SHA-256"); byte[] userFingerprintDigest = digest.digest(userFingerprint.getBytes("utf-8")); String userFingerprintHash = DatatypeConverter.printHexBinary(userFingerprintDigest); //      15     Calendar c = Calendar.getInstance(); Date now = c.getTime(); c.add(Calendar.MINUTE, 15); Date expirationDate = c.getTime(); Map&lt;String, Object&gt; headerClaims = new HashMap&lt;&gt;(); headerClaims.put("typ", "JWT"); String token = JWT.create().withSubject(login) .withExpiresAt(expirationDate) .withIssuer(this.issuerID) .withIssuedAt(now) .withNotBefore(now) .withClaim("userFingerprint", userFingerprintHash) .withHeader(headerClaims) .sign(Algorithm.HMAC256(this.keyHMAC));</span></span></code> </pre> <br><br>  <i>Code pour vérifier la validité du jeton:</i> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  HMAC   String   JVM private transient byte[] keyHMAC = ...; ... //     cookie String userFingerprint = null; if (request.getCookies() != null &amp;&amp; request.getCookies().length &gt; 0) { List&lt;Cookie&gt; cookies = Arrays.stream(request.getCookies()).collect(Collectors.toList()); Optional&lt;Cookie&gt; cookie = cookies.stream().filter(c -&gt; "__Secure-Fgp" .equals(c.getName())).findFirst(); if (cookie.isPresent()) { userFingerprint = cookie.get().getValue(); } } //  SHA256      cookie  //       MessageDigest digest = MessageDigest.getInstance("SHA-256"); byte[] userFingerprintDigest = digest.digest(userFingerprint.getBytes("utf-8")); String userFingerprintHash = DatatypeConverter.printHexBinary(userFingerprintDigest); //      JWTVerifier verifier = JWT.require(Algorithm.HMAC256(keyHMAC)) .withIssuer(issuerID) .withClaim("userFingerprint", userFingerprintHash) .build(); //   DecodedJWT decodedToken = verifier.verify(token);</span></span></code> </pre> <br><h4>  Révocation explicite du jeton par l'utilisateur </h4><br>  Étant donné que le jeton ne devient invalide qu'après son expiration, l'utilisateur n'a pas de fonction intégrée qui vous permet d'annuler explicitement le jeton.  Ainsi, en cas de vol, l'utilisateur ne peut pas retirer lui-même le jeton puis bloquer l'attaquant. <br><br>  L'une des méthodes de protection est l'introduction d'une liste noire de jetons, qui conviendra pour simuler la fonction de «déconnexion» qui existe dans un système de session traditionnel. <br><br>  La collection (dans le codage SHA-256 en HEX) du jeton avec la date d'annulation, qui devrait dépasser la période de validité du jeton émis, sera stockée dans la liste noire. <br><br>  Lorsque l'utilisateur souhaite se "déconnecter", il appelle un service spécial qui ajoute le jeton utilisateur fourni à la liste noire, ce qui entraîne l'annulation immédiate du jeton pour une utilisation ultérieure dans l'application. <br><br>  <u><b>Exemple d'implémentation:</b></u> <br><br>  <i>Dépôt de la liste noire:</i> <br>  Pour le stockage centralisé de la liste noire, une base de données avec la structure suivante sera utilisée: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">create table </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> not exists </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">revoked_token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jwt_token_digest varchar(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">255</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> primary key, revokation_date timestamp </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">now</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  <i>Gestion de la révocation des jetons:</i> <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    (logout). //  ,      //         . public class TokenRevoker { //    @Resource("jdbc/storeDS") private DataSource storeDS; //      public boolean isTokenRevoked(String jwtInHex) throws Exception { boolean tokenIsPresent = false; if (jwtInHex != null &amp;&amp; !jwtInHex.trim().isEmpty()) { //   byte[] cipheredToken = DatatypeConverter.parseHexBinary(jwtInHex); //  SHA256   MessageDigest digest = MessageDigest.getInstance("SHA-256"); byte[] cipheredTokenDigest = digest.digest(cipheredToken); String jwtTokenDigestInHex = DatatypeConverter.printHexBinary(cipheredTokenDigest); //     try (Connection con = this.storeDS.getConnection()) { String query = "select jwt_token_digest from revoked_token where jwt_token_digest = ?"; try (PreparedStatement pStatement = con.prepareStatement(query)) { pStatement.setString(1, jwtTokenDigestInHex); try (ResultSet rSet = pStatement.executeQuery()) { tokenIsPresent = rSet.next(); } } } } return tokenIsPresent; } //    HEX      public void revokeToken(String jwtInHex) throws Exception { if (jwtInHex != null &amp;&amp; !jwtInHex.trim().isEmpty()) { //   byte[] cipheredToken = DatatypeConverter.parseHexBinary(jwtInHex); //  SHA256   MessageDigest digest = MessageDigest.getInstance("SHA-256"); byte[] cipheredTokenDigest = digest.digest(cipheredToken); String jwtTokenDigestInHex = DatatypeConverter.printHexBinary(cipheredTokenDigest); //             //   if (!this.isTokenRevoked(jwtInHex)) { try (Connection con = this.storeDS.getConnection()) { String query = "insert into revoked_token(jwt_token_digest) values(?)"; int insertedRecordCount; try (PreparedStatement pStatement = con.prepareStatement(query)) { pStatement.setString(1, jwtTokenDigestInHex); insertedRecordCount = pStatement.executeUpdate(); } if (insertedRecordCount != 1) { throw new IllegalStateException("Number of inserted record is invalid," + " 1 expected but is " + insertedRecordCount); } } } } }</span></span></code> </pre><br><h4>  Divulgation de jetons </h4><br>  Cette attaque se produit lorsqu'un attaquant accède à un jeton (ou à un ensemble de jetons) et extrait les informations qu'il contient (les informations sur le jeton JWT sont codées à l'aide de base64) pour obtenir des informations sur le système.  Les informations peuvent être, par exemple, telles que les rôles de sécurité, le format de connexion, etc. <br><br>  La méthode de protection est assez évidente et consiste à chiffrer le jeton.  Il est également important de protéger les données chiffrées contre les attaques utilisant la cryptanalyse.  Pour atteindre tous ces objectifs, l'algorithme AES-GCM est utilisé, qui fournit le chiffrement authentifié avec les données associées (AEAD).  La primitive AEAD fournit une fonctionnalité de chiffrement authentifié symétrique.  Les implémentations de cette primitive sont protégées contre les attaques adaptatives basées sur un texte chiffré sélectionné.  Lors du cryptage du texte en clair, vous pouvez éventuellement spécifier des données connexes qui doivent être authentifiées mais non cryptées. <br><br>  En d'autres termes, le chiffrement avec les données pertinentes garantit l'authenticité et l'intégrité des données, mais pas leur secret. <br><br>  Cependant, il convient de noter que le chiffrement est ajouté principalement pour masquer les informations internes, mais il est très important de se rappeler que la protection initiale contre la contrefaçon du jeton JWT est la signature.Par conséquent, la signature du jeton et sa vérification doivent toujours être utilisées. <br><br><h4>  Stockage de jetons côté client </h4><br>  Si l'application stocke le jeton de sorte qu'une ou plusieurs des situations suivantes se produisent: <br><br><ul><li>  le token est automatiquement envoyé par le navigateur (stockage des cookies); </li><li>  le jeton est obtenu même si le navigateur est redémarré (en utilisant le conteneur localStorage du navigateur); </li><li>  le jeton est obtenu dans le cas d'une attaque XSS (cookie disponible pour le code JavaScript ou un jeton stocké dans localStorage ou sessionStorage). </li></ul><br>  Pour empêcher une attaque: <br><br><ol><li>  Stockez le jeton dans le navigateur à l'aide du conteneur sessionStorage. </li><li>  Ajoutez-le à l'en-tête d'autorisation à l'aide du schéma de support.  Le titre devrait ressembler à ceci: <br><br><pre> <code class="xml hljs">Authorization: Bearer <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">token</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </li><li>  Ajoutez des informations d'empreintes digitales au jeton. </li></ol><br>  En stockant le jeton dans le conteneur sessionStorage, il fournit un jeton pour le vol dans le cas de XSS.  Cependant, une empreinte digitale ajoutée au jeton empêche un attaquant de réutiliser le jeton volé sur son ordinateur.  Pour fermer les zones d'utilisation maximale d'un attaquant, ajoutez une stratégie de sécurité du contenu pour limiter le contexte d'exécution. <br><br>  Il reste un cas où un attaquant utilise le contexte de navigation de l'utilisateur comme serveur proxy pour utiliser l'application cible via un utilisateur légitime, mais la politique de sécurité du contenu peut empêcher la communication avec des domaines inattendus. <br><br>  Il est également possible d'implémenter un service d'authentification afin que le jeton soit émis à l'intérieur d'un cookie sécurisé, mais dans ce cas, une protection contre CSRF doit être implémentée. <br><br><h4>  Utilisation d'une clé faible pour créer un jeton </h4><br>  Si le secret utilisé dans le cas de l'algorithme HMAC-SHA256, nécessaire à la signature du jeton, est faible, il peut être piraté (récupéré à l'aide d'une attaque par force brute).  En conséquence, un attaquant peut truquer un jeton valide arbitraire en termes de signature. <br><br>  Pour éviter ce problème, vous devez utiliser une clé secrète complexe: alphanumérique (casse mixte) + caractères spéciaux. <br><br>  La clé n'étant nécessaire que pour les calculs informatiques, la taille de la clé secrète peut dépasser 50 positions. <br><br>  Par exemple: <br><br><pre> <code class="plaintext hljs">A&amp;'/}Z57M(2hNg=;LE?~]YtRMS5(yZ&lt;vcZTA3N-($&gt;2j:ZeX-BGftaVk`)jKP~q?,jk)EMbgt*kW'</code> </pre> <br>  Pour évaluer la complexité de la clé secrète utilisée pour votre signature de jeton, vous pouvez appliquer une attaque par dictionnaire de mot de passe au jeton en combinaison avec l'API JWT. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457090/">https://habr.com/ru/post/fr457090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457072/index.html">Comment résoudre un ancien problème en utilisant ML en Python et .Net</a></li>
<li><a href="../fr457074/index.html">L'évolution des développeurs: à quels jeux faut-il s'attendre à l'avenir</a></li>
<li><a href="../fr457078/index.html">Comment transformer votre avatar Telegram en montre</a></li>
<li><a href="../fr457082/index.html">Octroi imperceptible de droits d'administrateur</a></li>
<li><a href="../fr457086/index.html">Motif architectural "Builder" dans l'univers de "Swift" et "iOS" / "macOS"</a></li>
<li><a href="../fr457092/index.html">Nous étudions MITRE ATT & CK. Matrices mobiles: accès aux appareils. Partie 5</a></li>
<li><a href="../fr457094/index.html">Complément Excel qui facilite la définition de filtres lorsque vous travaillez avec des cubes (VBA)</a></li>
<li><a href="../fr457096/index.html">Nous libérons nos mains de plusieurs analystes: API Livy pour l'automatisation des tâches bancaires typiques</a></li>
<li><a href="../fr457098/index.html">Gestion élégante des erreurs JavaScript avec la monade Either</a></li>
<li><a href="../fr457100/index.html">AWS Lambda - Théorie, connaissance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>