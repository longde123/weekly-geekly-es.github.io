<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ∑ üê¶ üë©üèΩ‚Äçüíª Beralih ke Kotlin dalam proyek Android: Kiat dan Trik üõ¨ ‚ûó üëáüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Diposting oleh Sergey Yeshin, Pengembang Android Middle Strong, DataArt 

 Lebih dari satu setengah tahun telah berlalu sejak Google mengumumkan dukun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beralih ke Kotlin dalam proyek Android: Kiat dan Trik</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dataart/blog/433074/"><img src="https://habrastorage.org/webt/ss/no/sd/ssnosdopahysny9zaa0gevj_u54.jpeg"><br>  <i>Diposting oleh Sergey Yeshin, Pengembang Android Middle Strong, DataArt</i> <br><br>  Lebih dari satu setengah tahun telah berlalu sejak Google mengumumkan dukungan resmi untuk Kotlin di Android, dan pengembang yang paling berpengalaman mulai bereksperimen dengan itu dalam pertempuran mereka dan tidak lebih dari tiga tahun yang lalu. <br><br>  Bahasa baru diterima dengan hangat di komunitas Android, dan sebagian besar proyek Android baru akan dimulai dengan Kotlin.  Juga penting bahwa Kotlin mengkompilasi menjadi bytecode JVM, oleh karena itu, sepenuhnya kompatibel dengan Java.  Jadi, dalam proyek Android yang ada yang ditulis di Jawa, ada juga peluang (terlebih lagi, kebutuhan) untuk menggunakan semua fitur Kotlin, berkat itu ia mendapatkan begitu banyak penggemar. <br><br>  Dalam artikel itu, saya akan berbicara tentang pengalaman migrasi aplikasi Android dari Jawa ke Kotlin, kesulitan yang harus diatasi dalam proses, dan menjelaskan mengapa semua ini tidak sia-sia.  Artikel ini lebih ditujukan untuk pengembang Android yang baru mulai mempelajari Kotlin, dan, selain pengalaman pribadi, mengacu pada bahan-bahan anggota masyarakat lainnya. <a name="habracut"></a><br><br><h2>  Kenapa Kotlin? </h2><br>  Jelaskan secara singkat fitur-fitur Kotlin, karena itu saya beralih ke proyek, meninggalkan dunia Jawa yang "nyaman dan sangat akrab": <br><br><ol><li>  Kompatibilitas Java Penuh </li><li>  Keamanan kosong </li><li>  Ketikkan inferensi </li><li>  Metode penyuluhan </li><li>  Berfungsi sebagai objek kelas dan lambda </li><li>  Generik </li><li>  Coroutine </li><li>  Tidak ada pengecualian yang diperiksa </li></ol><br><h2>  Aplikasi DISCO </h2><br>  Ini adalah aplikasi dalam ukuran kecil untuk pertukaran kartu diskon, yang terdiri dari 10 layar.  Menggunakan contohnya, kami akan mempertimbangkan migrasi. <br><br><h3>  Secara singkat tentang arsitektur </h3><br>  Aplikasi ini menggunakan arsitektur MVVM dengan Komponen Arsitektur Google di bawah tenda: ViewModel, LiveData, Room. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oe/n1/e4/oen1e4fepl7q4ff8zdth-jxwjlk.png"></div><br>  Juga, sesuai dengan prinsip-prinsip Arsitektur Bersih dari Paman Bob, saya memilih 3 lapisan dalam aplikasi: data, domain, dan presentasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/em/o4/rz/emo4rzbpvpeadmnhzucuyhhtzpq.png"></div><br>  Di mana untuk memulai?  Jadi, kami membayangkan fitur-fitur utama Kotlin dan memiliki gagasan minimal tentang proyek yang perlu dimigrasi.  Pertanyaan alami adalah "harus mulai dari mana?". <br><br>  Halaman resmi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memulai dengan Kotlin</a> Android dokumentasi mengatakan bahwa jika Anda ingin port aplikasi yang sudah ada ke Kotlin, Anda hanya perlu mulai menulis unit test.  Saat Anda mendapatkan sedikit pengalaman dengan bahasa ini, tulis kode baru di Kotlin, Anda hanya perlu mengonversi kode Java yang ada. <br><br>  Tetapi ada satu "tetapi".  Memang, konversi sederhana biasanya (meskipun tidak selalu) memungkinkan Anda untuk mendapatkan kode yang berfungsi di Kotlin, namun, idiomnya meninggalkan banyak yang diinginkan.  Selanjutnya saya akan memberi tahu Anda cara menghilangkan kesenjangan ini karena fitur yang disebutkan (dan tidak hanya) dari bahasa Kotlin. <br><br><h2>  Migrasi Lapisan </h2><br>  Karena aplikasi sudah berlapis, masuk akal untuk bermigrasi secara berlapis-lapis, mulai dari atas. <br><br>  Urutan lapisan selama migrasi ditunjukkan pada gambar berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kp/oq/k_/kpoqk_8rpc0xg9qstzecyrlp_is.png"></div><br>  Bukan kebetulan bahwa kami memulai migrasi tepatnya dari lapisan atas.  Dengan demikian kami menyelamatkan diri dari menggunakan kode Kotlin dalam kode Java.  Sebaliknya, kita membuat kode Kotlin dari lapisan atas menggunakan kelas Java dari lapisan bawah.  Faktanya adalah bahwa Kotlin pada awalnya dirancang dengan mempertimbangkan kebutuhan untuk berinteraksi dengan Jawa.  Kode Java yang ada dapat dipanggil dari Kotlin dengan cara alami.  Kita dapat dengan mudah mewarisi dari kelas Java yang ada, mengaksesnya dan menerapkan penjelasan Java ke kelas dan metode Kotlin.  Kode Kotlin juga dapat digunakan di Jawa tanpa terlalu banyak kesulitan, tetapi seringkali membutuhkan usaha ekstra, seperti menambahkan anotasi JVM.  Dan mengapa konversi yang tidak perlu dalam kode Java, jika pada akhirnya itu akan tetap ditulis ulang di Kotlin? <br><br>  Sebagai contoh, mari kita lihat generasi yang kelebihan beban. <br><br>  Biasanya, jika Anda menulis fungsi Kotlin dengan nilai parameter default, itu hanya akan terlihat di Jawa sebagai tanda tangan lengkap dengan semua parameter.  Jika Anda ingin memberikan beberapa kelebihan beban ke panggilan Java, Anda dapat menggunakan anotasi @JvmOverloads: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JvmOverloads</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Double</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-number"><span class="hljs-number">0.0</span></span>) { <span class="hljs-meta"><span class="hljs-meta">@JvmOverloads</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: String, b: Int = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, c: String = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"abc"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br>  Untuk setiap parameter dengan nilai default, ini akan membuat satu kelebihan tambahan, yang memiliki parameter ini dan semua parameter di sebelah kanannya, dalam daftar parameter jarak jauh.  Dalam contoh ini, berikut ini akan dibuat: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Constructors: Foo(int x, double y) Foo(int x) // Methods void f(String a, int b, String c) { } void f(String a, int b) { } void f(String a) { }</span></span></code> </pre> <br>  Ada banyak contoh menggunakan anotasi JVM untuk operasi Kotlin yang benar.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halaman dokumentasi ini</a> merinci panggilan ke Kotlin dari Jawa. <br><br>  Sekarang kami menggambarkan proses migrasi lapis demi lapis. <br><br><h3>  Lapisan Presentasi </h3><br>  Ini adalah lapisan antarmuka pengguna yang berisi layar dengan tampilan dan ViewModel, pada gilirannya, berisi properti dalam bentuk LiveData dengan data dari model.  Selanjutnya, kami melihat trik dan alat yang ternyata berguna ketika memigrasi lapisan aplikasi ini. <br><br><h4>  1. Kapt prosesor pengolah anotasi </h4><br>  Seperti halnya MVVM apa pun, View terikat ke properti ViewModel melalui penyatuan data.  Dalam kasus Android, kami berurusan dengan Android Databind Library, yang menggunakan pemrosesan anotasi.  Jadi Kotlin memiliki <b>prosesor anotasi sendiri</b> , dan jika Anda tidak membuat perubahan pada file build.gradle yang sesuai, proyek akan berhenti membangun.  Karena itu, kami akan melakukan perubahan ini: <br><br><pre> <code class="java hljs">apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-kapt'</span></span> android { dataBinding { enabled = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } } dependencies { <span class="hljs-function"><span class="hljs-function">api </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fileTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'libs'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, include: [</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'*.jar'</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">///‚Ä¶ kapt "com.android.databinding:compiler:$android_plugin_version" }</span></span></span></span></code> </pre><br>  Penting untuk diingat bahwa Anda harus sepenuhnya mengganti semua kemunculan konfigurasi anotasiProcessor di build.gradle Anda dengan kapt. <br><br>  Misalnya, jika Anda menggunakan perpustakaan Dagger atau Room dalam proyek, yang juga menggunakan prosesor anotasi di bawah tenda untuk pembuatan kode, Anda harus menetapkan kapt sebagai prosesor anotasi. <br><br><h4>  2. Fungsi sebaris </h4><br>  Saat menandai fungsi sebagai inline, kami meminta kompiler untuk meletakkannya di tempat penggunaan.  Tubuh fungsi menjadi tertanam, dengan kata lain, diganti untuk penggunaan fungsi yang biasa.  Berkat ini, kita dapat menghindari pembatasan penghapusan tipe, yaitu menghapus tipe.  Saat menggunakan fungsi sebaris, kita bisa mendapatkan tipe (kelas) dalam runtime. <br><br>  Fitur Kotlin ini digunakan dalam kode saya untuk "mengekstrak" kelas dari Kegiatan yang diluncurkan. <br><br><pre> <code class="scala hljs">inline fun &lt;reified <span class="hljs-type"><span class="hljs-type">T</span></span> : <span class="hljs-type"><span class="hljs-type">Activity</span></span>&gt; <span class="hljs-type"><span class="hljs-type">Context</span></span>?.startActivity(args: <span class="hljs-type"><span class="hljs-type">Bundle</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>?.let { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> intent = <span class="hljs-type"><span class="hljs-type">Intent</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">intent</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">putExtras</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">args</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">it</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">startActivity</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">intent</span></span></span><span class="hljs-class">) } }</span></span></code> </pre> <br>  reified - sebutan untuk tipe reified. <br><br>  Dalam contoh yang dijelaskan di atas, kami juga menyentuh fitur bahasa Kotlin seperti Extensions. <br><br><h4>  3. Ekstensi </h4><br>  Itu adalah ekstensi.  Metode utilitas diambil dalam ekstensi, yang membantu untuk menghindari utilitas kelas yang membengkak dan mengerikan. <br><br>  Saya akan memberikan contoh ekstensi yang terlibat dalam aplikasi: <br><br><pre> <code class="scala hljs">fun <span class="hljs-type"><span class="hljs-type">Context</span></span>.inflate(res: <span class="hljs-type"><span class="hljs-type">Int</span></span>, parent: <span class="hljs-type"><span class="hljs-type">ViewGroup</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>): <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LayoutInflater</span></span>.from(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).inflate(res, parent, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } fun &lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt; <span class="hljs-type"><span class="hljs-type">Collection</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;?.isNotNullOrEmpty(): <span class="hljs-type"><span class="hljs-type">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; isNotEmpty(); } fun <span class="hljs-type"><span class="hljs-type">Fragment</span></span>.hideKeyboard() { view?.let { hideKeyboard(activity, it.windowToken) } }</code> </pre> <br>  Pengembang Kotlin memikirkan ekstensi Android yang berguna di muka dengan menawarkan plugin Kotlin Android Extensions mereka.  Di antara fitur-fitur yang ia tawarkan adalah View binding dan dukungan Parcelable.  Informasi terperinci tentang fitur-fitur plugin ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h4>  4. Fungsi Lambda dan fungsi urutan lebih tinggi </h4><br>  Menggunakan fungsi lambda dalam kode Android, Anda dapat menyingkirkan ClickListener dan panggilan balik yang canggung, yang di Jawa diimplementasikan melalui antarmuka yang ditulis sendiri. <br><br>  Contoh menggunakan lambda alih-alih onClickListener: <br><br><pre> <code class="java hljs">button.setOnClickListener({ doSomething() })</code> </pre> <br>  Lambdas juga digunakan dalam fungsi tingkat tinggi, misalnya, untuk fungsi pengumpulan. <br><br>  Ambil <b>peta sebagai</b> contoh: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transform: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; {...}</code> </pre> <br>  Ada tempat di kode saya di mana saya perlu "memetakan" kartu id untuk penghapusan berikutnya. <br><br>  Menggunakan ekspresi lambda yang diteruskan ke peta, saya mendapatkan array id yang diinginkan: <br><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ids = cards.map { it.id }.toIntArray() cardDao.deleteCardsByIds(ids)</code> </pre> <br>  Harap perhatikan bahwa tanda kurung dapat dihilangkan sama sekali saat memanggil fungsi, jika lambda adalah satu-satunya argumen, dan kata kunci itu adalah nama implisit dari satu-satunya parameter. <br><br><h4>  5. Jenis platform </h4><br>  Anda pasti harus bekerja dengan SDK yang ditulis dalam Java (termasuk, pada kenyataannya, Android SDK).  Ini berarti Anda harus selalu waspada dengan Kotlin dan Java Interop seperti jenis platform. <br><br>  Tipe platform adalah tipe yang Kotlin tidak dapat menemukan informasi validitas nol.  Faktanya adalah bahwa, secara default, kode Java tidak mengandung informasi tentang validitas null, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">NotNull</a> dan @ Nullable penjelasan tidak selalu digunakan.  Ketika tidak ada penjelasan yang sesuai di Jawa, tipe menjadi platform.  Anda bisa bekerja dengannya baik sebagai tipe yang memungkinkan null, dan sebagai tipe yang tidak mengizinkan null. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/r_/cu/zwr_cuwc3ajqxcsezq1b0zqcwyw.png"></div><br>  Ini berarti seperti di Jawa, pengembang bertanggung jawab penuh untuk operasi dengan tipe ini.  Compiler tidak menambahkan runtime cek nol dan akan memungkinkan Anda untuk melakukan semuanya. <br><br>  Dalam contoh berikut, kami menimpa onActivityResult dalam Aktivitas kami: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(requestCode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, resultCode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Intent</span></span></span></span><span class="hljs-function"><span class="hljs-params">{ </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">super</span></span></span></span><span class="hljs-function"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">onActivityResult</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">requestCode</span></span></span></span><span class="hljs-function"><span class="hljs-params">, resultCode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> randomString = <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.getStringExtra(<span class="hljs-string"><span class="hljs-string">"some_string"</span></span>) }</code> </pre> <br>  Dalam hal ini, data adalah tipe platform yang mungkin mengandung null.  Namun, dari sudut pandang kode Kotlin, data tidak boleh nol dalam keadaan apa pun, dan terlepas dari apakah Anda menentukan jenis Intent sebagai nullable, Anda tidak akan menerima peringatan atau kesalahan dari kompiler, karena kedua versi tanda tangan valid .  Tetapi karena menerima data yang tidak kosong tidak dijamin, karena dalam kasus dengan SDK Anda tidak dapat mengontrol ini, mendapatkan null dalam kasus ini akan mengarah ke NPE. <br><br>  Juga, sebagai contoh, kita dapat membuat daftar tempat-tempat berikut untuk kemungkinan munculnya jenis platform: <br><br><ol><li>  Service.onStartCommand (), di mana Intent mungkin nol. </li><li>  BroadcastReceiver.onReceive (). </li><li>  Activity.onCreate (), Fragment.onViewCreate () dan metode serupa lainnya. </li></ol><br>  Selain itu, kebetulan bahwa parameter metode ini dijelaskan, tetapi untuk beberapa alasan studio kehilangan Nullability ketika menghasilkan override. <br><br><h3>  Lapisan Domain </h3><br>  Lapisan ini mencakup semua logika bisnis, yang bertanggung jawab atas interaksi antara lapisan data dan lapisan presentasi.  Peran kunci di sini dimainkan oleh Repositori.  Dalam Repositori, kami melakukan manipulasi data yang diperlukan, baik sisi server maupun lokal.  Di lantai atas, ke lapisan Presentasi, kami hanya memberikan metode antarmuka Repositori, yang menyembunyikan kerumitan operasi data. <br><br>  Seperti yang dinyatakan di atas, RxJava digunakan untuk implementasi. <br><br><h4>  1. RxJava </h4><br>  Kotlin sepenuhnya kompatibel dengan RxJava dan lebih ringkas dalam hubungannya dengan itu daripada Java.  Namun, bahkan di sini saya harus menghadapi satu masalah yang tidak menyenangkan.  Kedengarannya seperti ini: jika Anda melewatkan lambda sebagai parameter dari metode <b>andThen</b> , lambda ini tidak akan berfungsi! <br><br>  Untuk memverifikasi ini, cukup tulis tes sederhana: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Completable</span></span> .fromCallable { cardRepository.uploadDataToServer() } .andThen { cardRepository.markLocalDataAsSynced() } .subscribe()</code> </pre> <br>  <b>Dan kemudian</b> konten <b>akan</b> gagal.  Ini adalah kasus dengan sebagian besar operator (seperti <b>flatMap</b> , <b>defer</b> , <b>fromAction</b> dan banyak lainnya), benar-benar lambda diharapkan sebagai argumen.  Dan dengan catatan seperti itu dengan <b>andThen</b> , <b>Completable / Observable / SingleSource diharapkan</b> .  Masalahnya diselesaikan dengan menggunakan tanda kurung biasa () alih-alih keriting {}. <br><br>  Masalah ini dijelaskan secara rinci dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">‚ÄúKotlin dan Rx2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Betapa aku menghabiskan 5 jam karena kurung yang salah</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a> <br><br><h4>  2. Restrukturisasi </h4><br>  Kami juga menyentuh sintaks Kotlin yang menarik seperti <i>penugasan perusakan</i> atau <i>perusakan</i> .  Ini memungkinkan Anda untuk menetapkan objek ke beberapa variabel sekaligus, memecahnya menjadi beberapa bagian. <br><br>  Bayangkan kita memiliki metode dalam API yang mengembalikan beberapa entitas sekaligus: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/foo/api/sync"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBrandsAndCards</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Single&lt;BrandAndCardResponse&gt; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BrandAndCardResponse</span></span></span></span>(<span class="hljs-meta"><span class="hljs-meta">@SerializedName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cards"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cards: List&lt;Card&gt;?, <span class="hljs-meta"><span class="hljs-meta">@SerializedName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"brands"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> brands: List&lt;Brand&gt;?)</code> </pre><br>  Cara ringkas untuk mengembalikan hasil dari metode ini adalah merusak, seperti yang ditunjukkan dalam contoh berikut: <br><br><pre> <code class="scala hljs">syncRepository.getBrandsAndCards() .flatMapCompletable {it-&gt; <span class="hljs-type"><span class="hljs-type">Completable</span></span>.fromAction{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (cards, brands) = it syncCards(cards) syncBrands(brands) } } }</code> </pre> <br>  Perlu disebutkan bahwa multi-deklarasi didasarkan pada konvensi: kelas yang seharusnya dihancurkan harus mengandung fungsi componentN (), di mana N adalah nomor komponen yang sesuai - anggota kelas.  Artinya, contoh di atas diterjemahkan ke dalam kode berikut: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cards = it.component1() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> brands = it.component2()</code> </pre> <br>  Contoh kami menggunakan kelas data yang secara otomatis mendeklarasikan fungsi componentN ().  Oleh karena itu, multi-deklarasi bekerja dengannya di luar kotak. <br><br>  Kita akan berbicara lebih banyak tentang kelas data di bagian selanjutnya, dikhususkan untuk lapisan Data. <br><br><h3>  Lapisan data </h3><br>  Lapisan ini termasuk POJO untuk data dari server dan pangkalan, antarmuka untuk bekerja dengan data lokal dan data yang diterima dari server. <br><br>  Untuk bekerja dengan data lokal, Room digunakan, yang memberi kami pembungkus yang nyaman untuk bekerja dengan database SQLite. <br><br>  Tujuan pertama untuk migrasi, yang menunjukkan dirinya sendiri, adalah POJO, yang dalam kode Java standar adalah kelas massal dengan banyak bidang dan metode get / set yang sesuai.  Anda dapat membuat POJO lebih ringkas dengan bantuan kelas Data.  Satu baris kode akan cukup untuk menggambarkan entitas dengan beberapa bidang: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Card</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id:String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardNumber:String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> brandId:String,<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> barCode:String)</code> </pre><br>  Selain keringkasan, kita mendapatkan: <br><br><ul><li>  Mengganti metode <b>equals ()</b> , <b>hashCode (),</b> dan <b>toString () di</b> bawah tenda.  Menghasilkan yang sama untuk semua properti dari kelas data sangat nyaman saat menggunakan DiffUtil dalam adaptor yang menghasilkan tampilan untuk RecyclerView.  Faktanya adalah bahwa DiffUtil membandingkan dua set data, dua daftar: yang lama dan yang baru, mencari tahu perubahan apa yang telah terjadi, dan menggunakan metode notifikasi yang memperbarui adaptor secara optimal.  Dan biasanya, daftar item dibandingkan menggunakan sama dengan. <br><br>  Dengan demikian, setelah menambahkan bidang baru ke kelas, kita tidak perlu menambahkannya sama dengan sehingga DiffUtil memperhitungkan bidang baru. </li><li>  Kelas yang tidak bisa diubah </li><li>  Dukungan untuk nilai default, yang dapat diganti dengan penggunaan pola Builder. <br><br>  Contoh: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Card</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id : <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> = <span class="hljs-number"><span class="hljs-number">0L</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardNumber: String=<span class="hljs-string"><span class="hljs-string">"99"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> barcode: String = <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brandId: String=<span class="hljs-string"><span class="hljs-string">"1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newCard = Card(id =<span class="hljs-number"><span class="hljs-number">1L</span></span>,cardNumber = <span class="hljs-string"><span class="hljs-string">"123"</span></span>)</code> </pre> </li></ul><br>  Berita baik lainnya: dengan kapt yang dikonfigurasi (seperti dijelaskan di atas), kelas Data berfungsi dengan baik dengan anotasi Kamar, yang memungkinkan Anda menerjemahkan semua entitas basis data ke dalam kelas Data.  Kamar juga mendukung properti yang dapat dibatalkan.  Benar, Room belum mendukung nilai default dari Kotlin, tetapi bug yang sesuai telah dilembagakan untuk ini. <br><br><h2>  Kesimpulan </h2><br>  Kami hanya memeriksa beberapa perangkap yang mungkin timbul selama migrasi dari Jawa ke Kotlin.  Adalah penting bahwa, meskipun masalah muncul, terutama dengan kurangnya pengetahuan teoritis atau pengalaman praktis, mereka semua dapat dipecahkan. <br><br>  Namun, kesenangan menulis kode ekspresif dan aman ringkas di Kotlin akan lebih dari melunasi semua kesulitan yang timbul pada jalur transisi.  Saya dapat mengatakan dengan yakin bahwa contoh proyek DISCO tentu saja menegaskan hal ini. <br><br><h3>  Buku, tautan bermanfaat, sumber daya </h3><br><ol><li>  Landasan teoritis pengetahuan bahasa akan memungkinkan peletakan buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotlin in Action</a> dari pencipta bahasa Svetlana Isakova dan Dmitry Zhemerov. <br><br>  Laconicism, informativeness, cakupan topik yang luas, fokus pada pengembang Java dan ketersediaan versi Rusia menjadikannya yang terbaik dari manual yang mungkin pada awal pembelajaran bahasa.  Saya mulai dengan dia. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> Kotlin dengan developer.android. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Kotlin dalam Bahasa Rusia</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel yang luar biasa dari</a> Konstantin Mikhailovsky, pengembang Android dari Genesis, tentang pengalaman beralih ke Kotlin. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433074/">https://habr.com/ru/post/id433074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433062/index.html">AXIS P1367 vs IDIS DC-B3303X: Bandingkan Kamera CCTV</a></li>
<li><a href="../id433064/index.html">Manajemen insiden: "Anda tidak bisa menyerah" atau seni menempatkan koma</a></li>
<li><a href="../id433066/index.html">HighLoad Cup # 2. Kejuaraan untuk pengembang backend kembali beroperasi</a></li>
<li><a href="../id433070/index.html">Bagaimana membedakan sampo dari sampanye, dan tusuk sate dari sampanye ... Elasticsearch - mencari produk di database toko</a></li>
<li><a href="../id433072/index.html">Cara meretas perlindungan salinan konsol Sega Dreamcast</a></li>
<li><a href="../id433076/index.html">Bagaimana kami membuat pustaka Galeri Android kami untuk melihat konten media</a></li>
<li><a href="../id433078/index.html">Kami menulis robot perdagangan menggunakan kerangka kerja grafis StockSharp. Bagian 2</a></li>
<li><a href="../id433082/index.html">Memompa akun orang lain telah menjadi pelanggaran pidana di Korea Selatan</a></li>
<li><a href="../id433084/index.html">Buka pelajaran "Rekayasa Fitur pada contoh dataset Titanic klasik"</a></li>
<li><a href="../id433086/index.html">Tinkoff dan segalanya, segalanya, segalanya: IoT, analitik, dan pengawasan bank</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>