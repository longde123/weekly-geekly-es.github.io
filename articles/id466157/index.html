<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêã üë©üèª‚Äçü§ù‚Äçüë®üèæ ‚úãüèº Blockchain: apa yang harus kita bangun PoC? üôç üë©üèø‚Äçüíª üßó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mata takut, dan tangan gatal! 

 Pada artikel sebelumnya, kami menemukan teknologi yang digunakan untuk membangun blockchain (Untuk apa kita membangun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blockchain: apa yang harus kita bangun PoC?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466157/">  <i>Mata takut, dan tangan gatal!</i> <br><br>  Pada artikel sebelumnya, kami menemukan teknologi yang digunakan untuk membangun blockchain (Untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apa kita membangun blockchain?</a> ) Dan case yang dapat diimplementasikan dengan bantuan mereka (Untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apa kita membuat case?</a> ).  Saatnya bekerja dengan tangan Anda!  Untuk implementasi pilot dan PoC (Proof of Concept), saya lebih suka menggunakan cloud, karena  mereka dapat diakses dari mana saja di dunia dan, seringkali, Anda tidak perlu menghabiskan waktu untuk pemasangan lingkungan yang membosankan, karena  Ada konfigurasi yang telah ditentukan.  Jadi, mari kita lakukan sesuatu yang sederhana, misalnya, jaringan untuk mentransfer koin antara peserta dan menyebutnya sebagai Citcoin sederhana.  Untuk ini, kami akan menggunakan cloud IBM dan universal blockchain Hyperledger Fabric.  Pertama, mari kita lihat mengapa Hyperledger Fabric disebut blockchain universal. <br><br><img src="https://habrastorage.org/webt/f6/tc/q3/f6tcq3wp6dn1kaity-mtv9xkkik.png" alt="gambar"><br><a name="habracut"></a><br><h2>  Hyperledger Fabric - blockchain universal </h2><br>  Secara umum, sistem informasi universal adalah: <br><br><ul><li>  Seperangkat server dan inti perangkat lunak yang melakukan logika bisnis; </li><li>  Antarmuka untuk berinteraksi dengan sistem; </li><li>  Sarana untuk pendaftaran, otentikasi, dan otorisasi perangkat / orang; </li><li>  Database menyimpan data operasional dan arsip: </li></ul><br><img src="https://habrastorage.org/webt/ha/dt/cr/hadtcr9siyz1oy-ouwou9gwhyzs.png" alt="gambar"><br><br>  Versi resmi dari apa Hyperledger Fabric dapat dibaca di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs</a> , dan singkatnya, Hyperledger Fabric adalah platform opensource yang memungkinkan Anda untuk membangun blockchains tertutup dan menjalankan kontrak pintar sewenang-wenang yang ditulis dalam bahasa pemrograman JS dan Go.  Mari kita lihat arsitektur Hyperledger Fabric secara terperinci dan pastikan itu adalah sistem universal yang hanya memiliki kekhususan menyimpan dan merekam data.  Kekhususan adalah bahwa data, seperti di semua blockchain, disimpan dalam blok yang ditempatkan di blockchain hanya jika peserta mencapai konsensus dan setelah merekam data tidak dapat diam-diam dikoreksi atau dihapus. <br><br><h2>  Arsitektur Kain Hyperledger </h2><br>  Diagram menunjukkan arsitektur Fabric Hyperledger: <br><br><img src="https://habrastorage.org/webt/lt/av/n_/ltavn_otc0ix7lspm1wqvvz2zl4.png" alt="gambar"><br><br>  <b>Organisasi</b> - organisasi mengandung teman sebaya, mis.  blockchain ada karena dukungan organisasi.  Organisasi yang berbeda dapat menjadi anggota saluran yang sama. <br><br>  <b>Saluran</b> - struktur logis yang menyatukan rekan-rekan ke dalam kelompok, mis.  Blockchain sudah diatur.  Hyperledger Fabric dapat secara bersamaan memproses beberapa blockchains dengan logika bisnis yang berbeda. <br><br>  <b>Penyedia Layanan Keanggotaan (MSP)</b> adalah CA (Otoritas Sertifikat) untuk mengeluarkan identitas dan menugaskan peran.  Untuk membuat simpul, Anda perlu berinteraksi dengan MSP. <br><br>  <b>Peer node</b> - memverifikasi transaksi, menyimpan blockchain, menjalankan kontrak pintar dan berinteraksi dengan aplikasi.  Peer memiliki identitas (sertifikat digital) yang mengeluarkan MSP.  Berbeda dengan jaringan Bitcoin atau Etherium, di mana semua node sama, di Hyperledger Fabric node memainkan peran yang berbeda: <br><br><ul><li>  Peer dapat <b>mendukung rekan</b> (EP) dan menjalankan kontrak pintar. </li><li>  <b>Committing peer</b> (CP) - hanya menyimpan data di blockchain dan memperbarui "Negara dunia". </li><li>  <b>Anchor Peer</b> (AP) - jika beberapa organisasi berpartisipasi dalam blockchain, maka anchor peer digunakan untuk berkomunikasi di antara mereka.  Setiap organisasi harus memiliki satu atau lebih sejawat.  Dengan bantuan AP, rekan kerja mana pun dalam organisasi dapat memperoleh informasi tentang semua rekan di organisasi lain.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Protokol gosip</a> digunakan untuk menyinkronkan informasi antara AP. </li><li>  <b>Leader Peer</b> - jika organisasi memiliki beberapa rekan, maka hanya pemimpin rekan yang akan menerima blok dari layanan Pemesanan dan memberikannya kepada rekan-rekan lainnya.  Seorang pemimpin dapat ditetapkan secara statis atau dipilih secara dinamis oleh rekan-rekan dalam suatu organisasi.  Protokol gosip juga digunakan untuk menyinkronkan informasi pemimpin. </li></ul><br>  <b>Aset</b> adalah entitas nilai yang disimpan di blockchain.  Lebih khusus lagi, ini adalah data nilai kunci dalam format JSON.  Ini adalah data yang dicatat di Blockchain.  Mereka memiliki kisah yang disimpan di blockchain dan status saat ini, yang disimpan dalam basis data keadaan dunia.  Struktur data diisi secara acak tergantung pada tugas bisnis.  Tidak ada bidang wajib, satu-satunya rekomendasi adalah bahwa aset harus memiliki pemilik dan bernilai. <br><br>  <b>Buku Besar</b> - terdiri dari blockchain "Blockchain" dan basis data "Word state", yang menyimpan status aset saat ini.  Negara dunia menggunakan LevelDB atau CouchDB. <br><br>  <b>Kontrak pintar</b> - menggunakan kontrak pintar, logika bisnis dari sistem diimplementasikan.  Dalam Hyperledger Fabric, kontrak pintar disebut chaincode.  Dengan bantuan chaincode, aset dan transaksi ditetapkan.  Berbicara dalam bahasa teknis, kontrak pintar adalah modul perangkat lunak yang diimplementasikan dalam bahasa pemrograman JS atau Go. <br><br>  <b>Kebijakan</b> pengesahan - untuk setiap kode rantai, Anda dapat menentukan berapa banyak kebijakan dan dari siapa Anda ingin konfirmasi untuk transaksi.  Jika kebijakan tidak disetel, maka secara default digunakan: "transaksi harus dikonfirmasikan oleh anggota organisasi mana pun di saluran".  Contoh kebijakan: <br><br><ul><li>  Setiap administrator organisasi harus mengkonfirmasi transaksi; </li><li>  Setiap anggota atau klien organisasi harus mengkonfirmasi; </li><li>  Harus mengkonfirmasi organisasi rekan mana pun. </li></ul><br>  <b>Layanan pemesanan</b> - mengemas transaksi ke dalam blok dan mengirim rekan ke saluran.  Menjamin pengiriman pesan ke semua rekan di jaringan.  Untuk sistem industri, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">broker pesan Kafka</a> digunakan untuk mengembangkan dan menguji <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solo</a> . <br><br><h2>  Callflow </h2><br><img src="https://habrastorage.org/webt/we/9m/wt/we9mwttlva0u7k0-zv2r6998rss.png" alt="gambar"><br><br><ul><li>  Aplikasi berinteraksi dengan Hyperledger Fabric menggunakan Go, Node.js atau Java SDK; </li><li>  Klien membuat transaksi tx dan mengirimkannya ke endorsing peer; </li><li>  Peer memverifikasi tanda tangan klien, menyelesaikan transaksi, dan mengirimkan tanda tangan pengesahan kembali ke klien.  Chaincode dieksekusi hanya pada peer endorsing, dan hasil eksekusinya dikirim ke semua rekan.  Algoritma kerja ini disebut - PBFT (Practical Byzantine Fault Tolerant) konsensus.  Ini berbeda dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BFT klasik</a> di mana pesan dikirim dan konfirmasi tidak diharapkan dari semua peserta, tetapi hanya dari set tertentu; </li><li>  Setelah klien menerima jumlah tanggapan yang sesuai dengan kebijakan pengesahan, klien mengirim transaksi ke layanan Pemesanan; </li><li>  Memesan layanan membentuk blok dan mengirimkannya ke semua rekan yang melakukan.  Layanan pemesanan menyediakan penulisan blok secara berurutan, yang mengecualikan apa yang disebut garpu buku besar ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat bagian "</a> Garpu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a> ); </li><li>  Peer menerima blok, periksa kembali kebijakan pengesahan, tulis blok ke blockchain dan ubah status di DB "World state". </li></ul><br>  Yaitu  ternyata pemisahan peran antara node.  Ini memberikan skalabilitas dan keamanan blockchain: <br><br><ul><li>  Kontrak pintar (chaincode) melakukan peer endorsing.  Ini memastikan kerahasiaan kontrak pintar, seperti  itu tidak disimpan oleh semua peserta, tetapi hanya pada rekan-rekan yang mendukung. </li><li>  Pemesanan harus bekerja cepat.  Ini dipastikan oleh fakta bahwa Pemesanan hanya membentuk blok dan mengirimkannya ke sekumpulan rekan pemimpin tetap. </li><li>  Rekan sebaya yang berkomitmen hanya menyimpan blockchain - mungkin ada banyak dari mereka dan mereka tidak memerlukan banyak tenaga dan kerja instan. </li></ul><br>  Untuk informasi lebih lanjut tentang solusi arsitektur Hyperledger Fabric dan mengapa ia bekerja dengan cara ini, lihat di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur Asal</a> atau di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hyperledger Fabric: Sistem Operasi Terdistribusi untuk Blockchains yang Diizinkan</a> . <br><br>  Jadi, Hyperledger Fabric adalah sistem yang benar-benar universal yang dengannya Anda dapat: <br><br><ul><li>  Menerapkan logika bisnis yang sewenang-wenang menggunakan mekanisme kontrak pintar; </li><li>  Tulis dan terima data dari database blockchain dalam format JSON; </li><li>  Berikan dan verifikasi akses ke API menggunakan Otoritas Sertifikat. </li></ul><br>  Sekarang setelah kami mengetahui secara spesifik dari Kain Hyperledger, mari kita lakukan sesuatu yang bermanfaat! <br><br><h2>  Luaskan Blockchain </h2><br><h3>  Pernyataan masalah </h3><br>  Tugasnya adalah mengimplementasikan jaringan Citcoin dengan fungsi-fungsi berikut: membuat akun, mendapatkan saldo, mengisi kembali akun, mentransfer koin dari satu akun ke akun lainnya.  Mari kita menggambar model objek, yang selanjutnya akan kita terapkan dalam kontrak pintar.  Jadi, kami akan memiliki akun yang diidentifikasi dengan nama dan berisi saldo dan daftar akun.  Akun dan daftar akun dalam hal aset Fabric Hyperledger.  Dengan demikian, mereka memiliki riwayat dan status saat ini.  Saya akan mencoba menggambarnya dengan jelas: <br><br><img src="https://habrastorage.org/webt/wj/vx/uc/wjvxuc7wn8q8z8ob7efborjwfeu.png" alt="gambar"><br><br>  Angka-angka atas adalah keadaan saat ini, yang disimpan dalam basis data Negara Dunia.  Di bawah mereka adalah gambar yang menunjukkan cerita yang disimpan di blockchain.  Keadaan aset saat ini diubah oleh transaksi.  Aset hanya berubah secara keseluruhan, oleh karena itu, sebagai hasil dari transaksi, objek baru dibuat, dan nilai saat ini dari aset masuk ke dalam sejarah. <br><br><h3>  IBM Cloud </h3><br>  Kami membuat akun di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cloud IBM</a> .  Untuk menggunakan platform blockchain, Anda perlu memutakhirkannya ke Pay-As-You-Go.  Proses ini mungkin tidak cepat, karena  IBM meminta informasi tambahan dan memverifikasinya secara manual.  Dari sisi positif, saya dapat mengatakan bahwa IBM memiliki materi pelatihan yang baik yang memungkinkan Anda untuk menggunakan Hyperledger Fabric di cloud mereka.  Saya menyukai serangkaian artikel dan contoh berikut: <br><br><ul><li>  <a href="">Buat jaringan blockchain dasar menggunakan Platform Blockchain</a> </li><li>  <a href="">Buat dan laksanakan kontrak pintar blockchain</a> </li><li>  <a href="">Keluarkan acara dari Platform Blockchain</a> </li></ul><br>  Berikut ini adalah screenshot dari platform IBM Blockchain.  Ini bukan instruksi untuk membuat blockchain, tetapi hanya demonstrasi ruang lingkup tugas.  Jadi, untuk tujuan kami, kami membuat satu Organisasi: <br><br><img src="https://habrastorage.org/webt/vw/gr/co/vwgrcodh-v21eslmmfe_1nkruhk.png" alt="gambar"><br><br>  Di dalamnya kita membuat node: Orderer CA, Org1 CA, Orderer Peer: <br><br><img src="https://habrastorage.org/webt/f7/1x/g2/f71xg2fhmy258ihqyaunufjgas4.png" alt="gambar"><br><br>  Kami memulai pengguna: <br><br><img src="https://habrastorage.org/webt/1t/k5/_i/1tk5_ihjhcimki8xaeuxenwszh0.png" alt="gambar"><br><br>  Buat Saluran dan sebut itu citcoin: <br><br><img src="https://habrastorage.org/webt/hv/y-/av/hvy-av3p4pjrpgonz47bcj0qebq.png" alt="gambar"><br><br>  Intinya, Saluran adalah blockchain, jadi itu dimulai dengan blok nol (blok Genesis): <br><br><img src="https://habrastorage.org/webt/9x/n0/c0/9xn0c0ihpxzmytycm9olkqi6klm.png" alt="gambar"><br><br><h3>  Menulis Kontrak yang Cerdas </h3><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Citcoin smart-contract v1.5 for Hyperledger Fabric * (c) Alexey Sushkov, 2019 */</span></span> <span class="hljs-string"><span class="hljs-string">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Contract } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fabric-contract-api'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> maxAccounts = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CitcoinEvents</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Contract</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> instantiate(ctx) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.info(<span class="hljs-string"><span class="hljs-string">'instantiate'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> emptyList = []; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ctx.stub.putState(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>, Buffer.from(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(emptyList))); } <span class="hljs-comment"><span class="hljs-comment">// Get all accounts async GetAccounts(ctx) { // Get account list: let accounts = '{}' let accountsData = await ctx.stub.getState('accounts'); if (accountsData) { accounts = JSON.parse(accountsData.toString()); } else { throw new Error('accounts not found'); } return accountsData.toString() } // add a account object to the blockchain state identifited by their name async AddAccount(ctx, name, balance) { // this is account data: let account = { name: name, balance: Number(balance), type: 'account', }; // create account: await ctx.stub.putState(name, Buffer.from(JSON.stringify(account))); // Add account to list: let accountsData = await ctx.stub.getState('accounts'); if (accountsData) { let accounts = JSON.parse(accountsData.toString()); if (accounts.length &lt; maxAccounts) { accounts.push(name); await ctx.stub.putState('accounts', Buffer.from(JSON.stringify(accounts))); } else { throw new Error('Max accounts number reached'); } } else { throw new Error('accounts not found'); } // return object return JSON.stringify(account); } // Sends money from Account to Account async SendFrom(ctx, fromAccount, toAccount, value) { // get Account from let fromData = await ctx.stub.getState(fromAccount); let from; if (fromData) { from = JSON.parse(fromData.toString()); if (from.type !== 'account') { throw new Error('wrong from type'); } } else { throw new Error('Accout from not found'); } // get Account to let toData = await ctx.stub.getState(toAccount); let to; if (toData) { to = JSON.parse(toData.toString()); if (to.type !== 'account') { throw new Error('wrong to type'); } } else { throw new Error('Accout to not found'); } // update the balances if ((from.balance - Number(value)) &gt;= 0 ) { from.balance -= Number(value); to.balance += Number(value); } else { throw new Error('From Account: not enought balance'); } await ctx.stub.putState(from.name, Buffer.from(JSON.stringify(from))); await ctx.stub.putState(to.name, Buffer.from(JSON.stringify(to))); // define and set Event let Event = { type: "SendFrom", from: from.name, to: to.name, balanceFrom: from.balance, balanceTo: to.balance, value: value }; await ctx.stub.setEvent('SendFrom', Buffer.from(JSON.stringify(Event))); // return to object return JSON.stringify(from); } // get the state from key async GetState(ctx, key) { let data = await ctx.stub.getState(key); let jsonData = JSON.parse(data.toString()); return JSON.stringify(jsonData); } // GetBalance async GetBalance(ctx, accountName) { let data = await ctx.stub.getState(accountName); let jsonData = JSON.parse(data.toString()); return JSON.stringify(jsonData); } // Refill own balance async RefillBalance(ctx, toAccount, value) { // get Account to let toData = await ctx.stub.getState(toAccount); let to; if (toData) { to = JSON.parse(toData.toString()); if (to.type !== 'account') { throw new Error('wrong to type'); } } else { throw new Error('Accout to not found'); } // update the balance to.balance += Number(value); await ctx.stub.putState(to.name, Buffer.from(JSON.stringify(to))); // define and set Event let Event = { type: "RefillBalance", to: to.name, balanceTo: to.balance, value: value }; await ctx.stub.setEvent('RefillBalance', Buffer.from(JSON.stringify(Event))); // return to object return JSON.stringify(from); } } module.exports = CitcoinEvents;</span></span></code> </pre> <br>  Secara intuitif, semuanya harus jelas di sini: <br><br><ul><li>  Ada beberapa fungsi (AddAccount, GetAccounts, SendFrom, GetBalance, RefillBalance) yang akan dipanggil oleh program demo menggunakan Hyperledger Fabric API. </li><li>  Fungsi SendFrom dan RefillBalance menghasilkan acara (Acara) yang akan diterima oleh program demo. </li><li>  Function instantiate - dipanggil satu kali selama instantiation dari kontrak pintar.  Bahkan, ini disebut bukan sekali, tetapi setiap kali versi kontrak pintar diubah.  Oleh karena itu, menginisialisasi daftar dengan array kosong adalah ide yang buruk, karena  Sekarang, ketika mengubah versi kontrak pintar, kita akan kehilangan daftar saat ini.  Tapi tidak ada, saya hanya belajar). </li><li>  Akun dan daftar akun (akun) adalah struktur data JSON.  Untuk manipulasi data, JS digunakan. </li><li>  Anda bisa mendapatkan nilai aset saat ini dengan memanggil fungsi getState, dan memperbaruinya menggunakan putState. </li><li>  Saat membuat Akun, fungsi AddAccount dipanggil, di mana perbandingan dibuat untuk jumlah maksimum akun di blockchain (maxAccounts = 5).  Dan ada jamb (perhatikan?), Yang mengarah pada peningkatan jumlah akun yang tak terbatas.  Kesalahan seperti itu harus dihindari) </li></ul><br>  Selanjutnya, unggah kontrak pintar ke Saluran dan instal: <br><br><img src="https://habrastorage.org/webt/ew/3a/ok/ew3aok9gsgrcaadaor-b0xwxllg.png" alt="gambar"><br><br>  Kami melihat transaksi untuk menginstal Kontrak Cerdas: <br><br><img src="https://habrastorage.org/webt/om/m4/x9/omm4x9np0s1i8wjki6guvvyc46o.png" alt="gambar"><br><br>  Kami melihat detail tentang Saluran kami: <br><br><img src="https://habrastorage.org/webt/tj/bd/eb/tjbdebruoky86aiwhx5t7ayqljq.png" alt="gambar"><br><br>  Hasilnya, kami mendapatkan diagram jaringan blockchain berikut di cloud IBM.  Ada juga program demo yang berjalan di cloud Amazon pada server virtual (lihat bagian selanjutnya untuk detail): <br><br><img src="https://habrastorage.org/webt/bx/sb/1s/bxsb1s6s0c36u_2vh0lmjqmqj9u.png" alt="gambar"><br><br><h2>  Membuat GUI untuk Panggilan API Fabric Hyperledger </h2><br>  Hyperledger Fabric memiliki API yang dapat digunakan untuk: <br><br><ul><li>  Saluran kreasi; </li><li>  Koneksi sebaya ke saluran; </li><li>  Pemasangan dan instantiasi kontrak pintar di saluran; </li><li>  Panggilan transaksi; </li><li>  Minta informasi tentang blockchain. </li></ul><br><h3>  Pengembangan aplikasi </h3><br>  Dalam program demo kami, kami akan menggunakan API hanya untuk memohon transaksi dan meminta informasi, karena  Kami telah mengambil langkah-langkah yang tersisa menggunakan platform blockchain IBM.  Kami menulis GUI menggunakan tumpukan teknologi standar: Express.js + Vue.js + Node.js.  Anda dapat menulis artikel terpisah tentang cara mulai membuat aplikasi web modern.  Di sini saya akan meninggalkan tautan ke seri kuliah yang paling saya sukai: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aplikasi Web Stack Lengkap menggunakan Vue.js &amp; Express.js</a> .  Hasilnya adalah aplikasi klien-server dengan antarmuka grafis yang akrab dalam gaya Desain Bahan dari Google.  API REST antara klien dan server terdiri dari beberapa panggilan: <br><br><ul><li>  HyperledgerDemo / v1 / init - menginisialisasi blockchain; </li><li>  HyperledgerDemo / v1 / accounts / list - dapatkan daftar semua akun </li><li>  HyperledgerDemo / v1 / akun? Name = Bob &amp; balance = 100 - buat akun Bob; </li><li>  HyperledgerDemo / v1 / info? Akun = Bob - dapatkan informasi tentang akun Bob; </li><li>  HyperledgerDemo / v1 / transaction? Dari = Bob &amp; ke = Alice &amp; volume = 2 - transfer dua koin dari Bob ke Alice; </li><li>  HyperledgerDemo / v1 / disconnect - tutup koneksi ke blockchain. </li></ul><br>  Saya memasukkan deskripsi API dengan contoh-contoh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web Postman</a> , sebuah program terkenal untuk menguji HTTP API. <br><br><h3>  Aplikasi Demo Cloud Amazon </h3><br>  Aplikasi itu diunggah ke Amazon, karena  IBM sejauh ini gagal memutakhirkan akun saya dan mengizinkan pembuatan server virtual.  Bagaimana cherry melampirkan domain: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.citcoin.info</a> .  Saya akan membiarkan server dinyalakan sebentar, lalu mematikannya, karena  sen untuk disewakan menetes, dan koin citcoin belum dikutip di bursa) Saya menaruh screenshot demo di artikel sehingga logika kerjanya jelas.  Aplikasi demo dapat: <br><br><ul><li>  Inisialisasi blockchain; </li><li>  Buat Akun (tapi sekarang jangan buat Akun baru, karena jumlah maksimum akun yang ditentukan dalam kontrak pintar telah tercapai di blockchain); </li><li>  Dapatkan daftar Akun; </li><li>  Transfer koin citcoin antara Alice, Bob dan Alex; </li><li>  Terima acara (tetapi sekarang tidak ada cara untuk menampilkan acara, oleh karena itu, untuk kesederhanaan, antarmuka mengatakan bahwa acara tidak didukung); </li><li>  Tindakan log. </li></ul><br>  Pertama, inisialisasi blockchain: <br><br><img src="https://habrastorage.org/webt/o8/j5/te/o8j5tev3u9drgclmlfzluoys-e4.png" alt="gambar"><br><br>  Selanjutnya, mulai akun Anda, jangan remehkan dengan saldo: <br><br><img src="https://habrastorage.org/webt/e1/eo/ck/e1eockzjedclvktadadhnbsgkem.png" alt="gambar"><br><br>  Kami mendapatkan daftar semua akun yang tersedia: <br><br><img src="https://habrastorage.org/webt/_0/ih/o-/_0iho-vlhsg0v6abggskdshpmow.png" alt="gambar"><br><br>  Kami memilih pengirim dan penerima, kami mendapatkan saldo mereka.  Jika pengirim dan penerima sama, maka akun mereka akan diisi ulang: <br><br><img src="https://habrastorage.org/webt/c7/go/vu/c7govuxmtn4wkcc_4byqz5dzgd8.png" alt="gambar"><br><br>  Dalam log, kami memantau pelaksanaan transaksi: <br><br><img src="https://habrastorage.org/webt/lw/sj/tb/lwsjtbmwe8oplpok_mg8ocvjirq.png" alt="gambar"><br><br>  Sebenarnya, dengan program demo, itu saja.  Selanjutnya, Anda dapat melihat transaksi kami di blockchain: <br><br><img src="https://habrastorage.org/webt/cp/cu/ik/cpcuikr02wqi_nwht9liarcpkhk.png" alt="gambar"><br><br>  Dan daftar transaksi umum: <br><br><img src="https://habrastorage.org/webt/_z/1t/ej/_z1tejxfntvmmqugqzf04plkrae.png" alt="gambar"><br><br>  Dengan ini, kami berhasil menyelesaikan implementasi PoC untuk membuat jaringan Citcoin.  Apa lagi yang perlu dilakukan agar Citcoin menjadi jaringan transfer koin yang lengkap?  Sedikit saja: <br><br><ul><li>  Pada tahap membuat akun, terapkan pembuatan kunci privat / publik.  Kunci pribadi harus disimpan di pengguna akun, publik di blockchain. </li><li>  Lakukan transfer koin yang menggunakan kunci publik untuk mengidentifikasi pengguna, bukan nama. </li><li>  Enkripsi transaksi pergi dari pengguna ke server dengan kunci pribadinya. </li></ul><br><h2>  Kesimpulan </h2><br>  Kami telah mengimplementasikan jaringan Citcoin dengan fungsi: menambah akun, mendapatkan saldo, mengisi kembali akun Anda, mentransfer koin dari satu akun ke akun lainnya.  Jadi, berapa biaya yang harus dikeluarkan untuk membangun PoC? <br><br><ul><li>  Kita perlu mempelajari blockchain secara umum dan Hyperledger Fabric pada khususnya; </li><li>  Pelajari cara menggunakan cloud IBM atau Amazon; </li><li>  Pelajari bahasa pemrograman JS dan beberapa kerangka kerja web; </li><li>  Jika beberapa data perlu disimpan bukan di blockchain, tetapi di database terpisah, maka pelajari cara mengintegrasikan, misalnya, dengan PostgreSQL; </li><li>  Dan last but not least - tanpa pengetahuan Linux di dunia modern, di mana saja!) </li></ul><br>  Tentu saja, bukan ilmu roket, tetapi Anda harus berkeringat! <br><br><h3>  Sumber GitHub </h3><br>  Dia meletakkan kode sumber di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .  Deskripsi singkat tentang repositori: <br>  Direktori " <b>server</b> " - server Node.js <br>  Direktori " <b>klien</b> " - klien Node.js <br>  Direktori " <b>blockchain</b> " (nilai parameter dan kunci, tentu saja, tidak beroperasi dan hanya diberikan sebagai contoh): <br><br><ul><li>  kontrak - sumber dari kontrak pintar </li><li>  wallet - kunci pengguna untuk menggunakan Hyperledger Fabric API. </li><li>  * .cds - versi kompilasi kontrak pintar </li><li>  * .json file - contoh file konfigurasi untuk menggunakan Hyperledger Fabric API </li></ul><br>  <b><font color="#B22222">Itu baru permulaan!</font></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466157/">https://habr.com/ru/post/id466157/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466147/index.html">Manajer Tampilan Data Reaktif. Pendahuluan</a></li>
<li><a href="../id466149/index.html">Membuat simbol konektor dengan teks "dinamis" di OrCAD</a></li>
<li><a href="../id466151/index.html">Investigasi: program aneh dalam Daftar perangkat lunak domestik</a></li>
<li><a href="../id466153/index.html">Membuat dokumen desain misi game naratif menggunakan contoh Last of Us</a></li>
<li><a href="../id466155/index.html">Arsitektur dan Fitur Tarantool Data Grid</a></li>
<li><a href="../id466159/index.html">Mengapa kecepatan penting dalam pertukaran modern dan cara menyalip pesaing: 3 cara praktis</a></li>
<li><a href="../id466165/index.html">Bagaimana Kecerdasan Buatan Membantu Mengelola Proyek</a></li>
<li><a href="../id466169/index.html">Penawaran khusus untuk siswa yang bekerja dari JetBrains</a></li>
<li><a href="../id466171/index.html">Lima alasan untuk menggunakan JUG.EKB</a></li>
<li><a href="../id466179/index.html">fform: React & JSONSchema - fleksibilitas maksimum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>