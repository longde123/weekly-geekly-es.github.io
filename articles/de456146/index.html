<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌵 👚 🍫 DevOps in der Entwicklung: Automatisierung von Webanwendungscode 😮 👇🏾 👩🏿‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag, lieber Habrazhiteli! 

 Heute ist DevOps auf der Erfolgswelle. In fast jeder Konferenz, die sich der Automatisierung widmet, können Sie vom...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DevOps in der Entwicklung: Automatisierung von Webanwendungscode</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456146/">  Guten Tag, lieber Habrazhiteli! <br><br>  Heute ist DevOps auf der Erfolgswelle.  In fast jeder Konferenz, die sich der Automatisierung widmet, können Sie vom Redner hören: „Wir haben hier und da DevOps implementiert, dies und das angewendet, es wurde viel einfacher, Projekte usw. usw. durchzuführen.“  Und es ist lobenswert.  In der Regel endet die Implementierung von DevOps in vielen Unternehmen jedoch in der Phase der Automatisierung des IT-Betriebs, und nur sehr wenige Menschen sprechen davon, DevOps direkt im Entwicklungsprozess selbst zu implementieren. <br><br>  Ich möchte dieses kleine Missverständnis korrigieren.  DevOps kann durch die Formalisierung der Codebasis entwickelt werden, beispielsweise beim Schreiben einer GUI für die REST-API. <br><br>  In diesem Artikel möchte ich Ihnen die Lösung für den nicht standardmäßigen Fall vorstellen, auf den unser Unternehmen gestoßen ist - wir konnten die Erstellung der Webanwendungsschnittstelle automatisieren.  Ich werde Ihnen erzählen, wie wir zu dieser Aufgabe gekommen sind und wie wir sie gelöst haben.  Wir glauben nicht, dass unser Ansatz der einzig wahre ist, aber wir mögen ihn wirklich. <br><br>  Ich hoffe, dieses Material wird für Sie interessant und nützlich sein. <br><br>  Nun, fangen wir an! <br><a name="habracut"></a><br><h2>  Hintergrund </h2><br>  Diese Geschichte begann vor ungefähr einem Jahr: Es war ein wunderschöner Sommertag und unsere Entwicklungsabteilung erstellte die nächste Webanwendung.  Auf der Tagesordnung stand die Aufgabe, eine neue Funktion in die Anwendung einzuführen - es war notwendig, die Möglichkeit hinzuzufügen, benutzerdefinierte Hooks zu erstellen. <br><br><img src="https://habrastorage.org/webt/qi/lf/ot/qilfotaamoa_fpuerti3np8chlm.png" alt="Der Prozess des Funktionss neuer Funktionen zur alten Architektur"><br><br>  Zu diesem Zeitpunkt wurde die Architektur unserer Webanwendung so erstellt, dass wir zur Implementierung einer neuen Funktion Folgendes tun mussten: <br><br><ol><li>  Im Back-End: Erstellen Sie ein Modell für eine neue Entität (Hooks), beschreiben Sie die Felder dieses Modells, beschreiben Sie die gesamte Logik der Aktionen, die das Modell ausführen kann usw. <br></li><li>  Am Frontend: Erstellen Sie eine Präsentationsklasse, die dem neuen Modell in der API entspricht, beschreiben Sie manuell alle Felder dieses Modells, fügen Sie alle Arten von Aktionen hinzu, die diese Ansicht ausführen kann usw. <br></li></ol><br>  Es stellt sich heraus, dass wir gleichzeitig an zwei Stellen gleichzeitig sehr ähnliche Änderungen am Code vornehmen mussten, auf die eine oder andere Weise, um uns gegenseitig zu "duplizieren".  Und das ist, wie Sie wissen, nicht gut, da Entwickler bei weiteren Änderungen Änderungen an derselben Stelle an zwei Stellen gleichzeitig vornehmen müssten. <br><br>  Angenommen, wir müssen den Typ des Felds "Name" von "Zeichenfolge" in "Textbereich" ändern.  Dazu müssen wir diese Änderung im Modellcode auf dem Server vornehmen und dann ähnliche Änderungen am Präsentationscode auf dem Client vornehmen. <br><br>  Ist es zu kompliziert? <br><br>  Zuvor haben wir uns mit dieser Tatsache abgefunden, da viele Anwendungen nicht sehr groß waren und es einen Ort gab, an dem der Code auf dem Server und auf dem Client „dupliziert“ werden konnte.  Aber an diesem Sommertag, vor der Einführung der neuen Funktion, klickte etwas in uns und wir stellten fest, dass wir so nicht mehr arbeiten konnten.  Der derzeitige Ansatz war sehr unvernünftig und erforderte viel Zeit und Arbeit.  Darüber hinaus könnte das „Duplizieren“ von Code im Back-End und Front-End in Zukunft zu unerwarteten Fehlern führen: Entwickler könnten Änderungen am Server vornehmen und vergessen, ähnliche Änderungen am Client vorzunehmen, und dann würde nicht alles gut gehen nach Plan. <br><br><h2>  Wie vermeide ich Codeduplizierungen?  Suche nach einer Lösung </h2><br>  Wir fragten uns, wie wir den Prozess der Einführung neuer Funktionen optimieren können. <br><br>  Wir haben uns die Frage gestellt: "Können wir sofort vermeiden, Änderungen in der Darstellung des Modells am Front-End zu duplizieren, nachdem sich die Struktur am Back-End geändert hat?" <br><br>  Wir dachten und antworteten: "Nein, das können wir nicht." <br><br>  Dann stellten wir uns eine andere Frage: "OK, was ist dann der Grund für eine solche Vervielfältigung von Code?" <br><br>  Und dann wurde uns klar: Das Problem ist tatsächlich, dass unser Front-End keine Daten zur aktuellen API-Struktur empfängt.  Das Front-End weiß nichts über die Modelle, die in der API vorhanden sind, bis wir es selbst darüber informieren. <br><br>  Und dann kamen wir auf die Idee: Was ist, wenn wir die Anwendungsarchitektur so erstellen, dass: <br><br><ul><li>  Von der API empfangenes Front-End nicht nur Modelldaten, sondern auch die Struktur dieser Modelle; </li><li>  Dynamisch geformte Front-End-Darstellungen basierend auf der Struktur von Modellen; </li><li>  Jede Änderung in der Struktur der API wurde automatisch im Frontend angezeigt. </li></ul><br>  Das Implementieren einer neuen Funktion nimmt viel weniger Zeit in Anspruch, da Änderungen nur auf der Back-End-Seite erforderlich sind und das Front-End automatisch alles aufnimmt und dem Benutzer ordnungsgemäß präsentiert. <br><br><h2>  Die Vielseitigkeit der neuen Architektur </h2><br>  Und dann haben wir uns entschlossen, etwas breiter zu denken: Ist die neue Architektur nur für unsere aktuelle Anwendung geeignet oder können wir sie woanders verwenden? <br><br><img src="https://habrastorage.org/webt/og/ay/ju/ogayjuenpbmvwxxlrxpm09banza.png" alt="Funktionen, die vielen Webansetzungen werden sind"><br><br>  In der Tat haben fast alle Anwendungen auf die eine oder andere Weise einen Teil einer ähnlichen Funktionalität: <br><br><ul><li>  Fast alle Anwendungen haben Benutzer, und in dieser Hinsicht ist es erforderlich, über Funktionen zu verfügen, die mit der Registrierung und Autorisierung von Benutzern verbunden sind. </li><li>  Fast alle Anwendungen haben verschiedene Arten von Ansichten: Es gibt eine Ansicht zum Anzeigen einer Liste von Objekten eines Modells, es gibt eine Ansicht zum Anzeigen einer detaillierten Aufzeichnung eines einzelnen Modellobjekts; </li><li>  Fast alle Modelle haben ähnliche Typattribute: Zeichenfolgendaten, Zahlen usw. In dieser Hinsicht müssen Sie in der Lage sein, sowohl im Backend als auch im Frontend mit ihnen zu arbeiten. </li></ul><br>  Und da unser Unternehmen häufig benutzerdefinierte Webanwendungen entwickelt, haben wir uns gedacht: Warum müssen wir das Rad jedes Mal neu erfinden und jedes Mal ähnliche Funktionen von Grund auf neu entwickeln, wenn wir einmal ein Framework schreiben können, das alle für viele gemeinsamen Grundlagen beschreibt Anwendungen, Dinge und dann, wenn Sie ein neues Projekt erstellen, verwenden Sie vorgefertigte Entwicklungen als Abhängigkeiten und ändern Sie sie gegebenenfalls deklarativ in einem neuen Projekt. <br><br>  So hatten wir im Verlauf einer langen Diskussion die Idee, VSTUtils zu erstellen - ein Framework, das: <br><br><ol><li>  Es enthielt die Grundfunktionen, die den meisten Anwendungen am ähnlichsten waren. </li><li>  Erlaubt das Front-End im laufenden Betrieb basierend auf der Struktur der API. </li></ol><br><h2>  Wie finde ich Freunde im Backend und Frontend? </h2><br>  Na dann müssen wir machen, dachten wir.  Wir hatten bereits ein Back-End, ein Front-End auch, aber weder der Server noch der Client verfügten über ein Tool, mit dem Daten zur Struktur der API gemeldet oder empfangen werden konnten. <br><br>  Bei der Suche nach einer Lösung für dieses Problem fiel unser Blick auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenAPI-</a> Spezifikation, die basierend auf der Beschreibung der Modelle und den Beziehungen zwischen ihnen einen riesigen JSON generiert, der all diese Informationen enthält. <br><br>  Und wir dachten, dass das Front-End beim Initialisieren der Anwendung auf dem Client theoretisch diesen JSON von der API empfangen und alle erforderlichen Ansichten auf seiner Basis erstellen kann.  Es bleibt nur, unserem Front-End beizubringen, all dies zu tun. <br><br>  Und nach einiger Zeit haben wir ihn unterrichtet. <br><br><h2>  Version 1.0 - was dabei herauskam </h2><br>  Die Architektur des VSTUtils-Frameworks der ersten Versionen bestand aus 3 bedingten Teilen und sah ungefähr so ​​aus: <br><br><ol><li>  <b>Backend:</b> <br><ul><li>  <u>Django und Python</u> sind alle modellbezogene Logik.  Basierend auf dem Basis-Django-Modell haben wir mehrere Klassen von VSTUtils-Kernmodellen erstellt.  Alle Aktionen, die diese Modelle ausführen können, wurden mit Python implementiert. <br></li><li>  <u>Django REST Framework</u> - REST-API-Generierung.  Basierend auf der Beschreibung der Modelle wird eine REST-API gebildet, dank derer Server und Client kommunizieren. <br></li></ul></li><li>  <b>Zwischenschicht zwischen Backend und Frontend:</b> <br><ul><li>  <u>OpenAPI</u> - JSON-Generierung mit einer Beschreibung der API-Struktur.  Nachdem alle Modelle im Backend beschrieben wurden, werden Ansichten für sie erstellt.  Durch Hinzufügen jeder der Ansichten werden die erforderlichen Informationen in den resultierenden JSON eingefügt: <br><div class="spoiler">  <b class="spoiler_title">JSON-Beispiel - OpenAPI-Schema</b> <div class="spoiler_text"><pre><code class="json hljs">{ // ,     (, ), //   -  , //  -     . definitions: { //    Hook. Hook: { // ,     (, ), //   -   , //  -       (,    ..). properties: { id: { title: <span class="hljs-string"><span class="hljs-string">"Id"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"integer"</span></span>, readOnly: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }, name: { title: <span class="hljs-string"><span class="hljs-string">"Name"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, minLength:<span class="hljs-number"><span class="hljs-number">1</span></span>, maxLength: <span class="hljs-number"><span class="hljs-number">512</span></span>, }, type: { title: <span class="hljs-string"><span class="hljs-string">"Type"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, enum: [<span class="hljs-string"><span class="hljs-string">"HTTP"</span></span>,<span class="hljs-string"><span class="hljs-string">"SCRIPT"</span></span>], }, when: { title: <span class="hljs-string"><span class="hljs-string">"When"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, enum: [<span class="hljs-string"><span class="hljs-string">"on_object_add"</span></span>,<span class="hljs-string"><span class="hljs-string">"on_object_upd"</span></span>,<span class="hljs-string"><span class="hljs-string">"on_object_del"</span></span>], }, enable: { title:<span class="hljs-string"><span class="hljs-string">"Enable"</span></span>, type:<span class="hljs-string"><span class="hljs-string">"boolean"</span></span>, }, recipients: { title: <span class="hljs-string"><span class="hljs-string">"Recipients"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, minLength: <span class="hljs-number"><span class="hljs-number">1</span></span>, } }, // ,     ,    . required: [<span class="hljs-string"><span class="hljs-string">"type"</span></span>,<span class="hljs-string"><span class="hljs-string">"recipients"</span></span>], } }, // ,     (, ), //   -   ( URL), //  -     . paths: { //      '/hook/'. '/hook/': { //    get    /hook/. //  ,       Hook. get: { operationId: <span class="hljs-string"><span class="hljs-string">"hook_list"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Return all hooks."</span></span>, // ,       ,     . parameters: [ { name: <span class="hljs-string"><span class="hljs-string">"id"</span></span>, in: <span class="hljs-string"><span class="hljs-string">"query"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"A unique integer value (or comma separated list) identifying this instance."</span></span>, required: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, }, { name: <span class="hljs-string"><span class="hljs-string">"name"</span></span>, in: <span class="hljs-string"><span class="hljs-string">"query"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"A name string value (or comma separated list) of instance."</span></span>, required: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, }, { name: <span class="hljs-string"><span class="hljs-string">"type"</span></span>, in: <span class="hljs-string"><span class="hljs-string">"query"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Instance type."</span></span>, required: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, }, ], // ,     (, ), //   -   ; //  -   . responses: { 200: { description: <span class="hljs-string"><span class="hljs-string">"Action accepted."</span></span>, schema: { properties: { results: { type: <span class="hljs-string"><span class="hljs-string">"array"</span></span>, items: { //   ,       . $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Hook"</span></span>, }, }, }, }, }, 400: { description: <span class="hljs-string"><span class="hljs-string">"Validation error or some data error."</span></span>, schema: { $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Error"</span></span>, }, }, 401: { // ... }, 403: { // ... }, 404: { // ... }, }, tags: [<span class="hljs-string"><span class="hljs-string">"hook"</span></span>], }, //    post    /hook/. //  ,       Hook. post: { operationId: <span class="hljs-string"><span class="hljs-string">"hook_add"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Create a new hook."</span></span>, parameters: [ { name: <span class="hljs-string"><span class="hljs-string">"data"</span></span>, in: <span class="hljs-string"><span class="hljs-string">"body"</span></span>, required: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, schema: { $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Hook"</span></span>, }, }, ], responses: { 201: { description: <span class="hljs-string"><span class="hljs-string">"Action accepted."</span></span>, schema: { $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Hook"</span></span>, }, }, 400: { description: <span class="hljs-string"><span class="hljs-string">"Validation error or some data error."</span></span>, schema: { $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Error"</span></span>, }, }, 401: { // ... }, 403: { // ... }, 404: { // ... }, }, tags: [<span class="hljs-string"><span class="hljs-string">"hook"</span></span>], }, } } }</code> </pre> </div></div></li></ul></li><li>  <b>Frontend:</b> <br><ul><li>  <u>JavaScript</u> ist ein Mechanismus, der ein OpenAPI-Schema analysiert und Ansichten generiert.  Dieser Mechanismus wird einmal gestartet, wenn die Anwendung auf dem Client initialisiert wird.  Durch das Senden einer Anforderung an die API erhält sie den angeforderten JSON als Antwort mit einer Beschreibung der API-Struktur und erstellt bei ihrer Analyse alle erforderlichen JS-Objekte, die die Parameter der Modelldarstellungen enthalten.  Diese API-Anforderung ist ziemlich umfangreich, daher werden sie zwischengespeichert und erst beim Aktualisieren der Anwendungsversion erneut angefordert. </li><li>  <u>JavaScript SPA-Bibliotheken</u> - Rendern von Ansichten und Weiterleiten zwischen ihnen.  Diese Bibliotheken wurden von einem unserer Front-End-Entwickler geschrieben.  Wenn ein Benutzer auf eine bestimmte Seite zugreift, zeichnet die Rendering-Engine die Seite basierend auf den in JS-Darstellungsobjekten gespeicherten Parametern. </li></ul></li></ol><br>  Was wir also haben: Wir haben ein Back-End, das die gesamte mit Modellen verbundene Logik beschreibt.  Dann betritt OpenAPI das Spiel, das basierend auf der Modellbeschreibung JSON mit einer Beschreibung der API-Struktur generiert.  Als nächstes wird der Staffelstab an den Client übertragen, der bei der Analyse des generierten OpenAPI JSON automatisch eine Webschnittstelle generiert. <br><br><h2>  Einbetten von Funktionen in die Anwendung in die neue Architektur - wie es funktioniert </h2><br>  Erinnern Sie sich an die Aufgabe, benutzerdefinierte Hooks hinzuzufügen?  So würden wir es in einer auf VSTUtils basierenden Anwendung implementieren: <br><br><img src="https://habrastorage.org/webt/ud/yr/af/udyrafi5o5grqlzqovkat8ursko.png" alt="Der Prozess des Funktionsens neuer Funktionen zur neuen Architektur"><br><br>  Dank VSTUtils müssen wir jetzt nichts mehr von Grund auf neu schreiben.  Folgendes tun wir, um die Möglichkeit zum Erstellen benutzerdefinierter Hooks hinzuzufügen: <br><br><ol><li>  Am Backend: Wir übernehmen und erben von der am besten geeigneten Klasse in VSTUtils und fügen neue Funktionen hinzu, die für das neue Modell spezifisch sind. </li><li>  Am vorderen Ende: <br><ul><li>  Wenn sich die Ansicht für dieses Modell nicht von der Basisansicht von VSTUtils unterscheidet, tun wir nichts, alles wird automatisch richtig angezeigt. </li><li>  Wenn Sie das Verhalten der Ansicht mithilfe des Signalmechanismus irgendwie ändern müssen, erweitern wir das grundlegende Verhalten der Ansicht deklarativ oder ändern es vollständig. <br></li></ul></li></ol><br>  Als Ergebnis haben wir eine ziemlich gute Lösung erhalten, wir haben unser Ziel erreicht, unser Front-End wurde automatisch generiert.  Der Prozess der Einführung neuer Funktionen in bestehende Projekte hat sich spürbar beschleunigt: Alle zwei Wochen wurden Veröffentlichungen veröffentlicht, während wir zuvor alle zwei bis drei Monate Veröffentlichungen mit einer viel geringeren Anzahl neuer Funktionen veröffentlicht haben.  Ich möchte darauf hinweisen, dass das Entwicklungsteam das gleiche geblieben ist. Es war die neue Anwendungsarchitektur, die uns die Früchte getragen hat. <br><br><h2>  Version 1.0 - unsere Herzen fordern Veränderung </h2><br>  Aber wie Sie wissen, gibt es keine Grenzen für die Perfektion, und VSTUtils war keine Ausnahme. <br><br>  Trotz der Tatsache, dass wir die Bildung des Frontends automatisieren konnten, war das Ergebnis nicht die direkte Lösung, die wir ursprünglich wollten. <br><br>  Die clientseitige Anwendungsarchitektur wurde nicht gründlich durchdacht und erwies sich als nicht so flexibel wie möglich: <br><br><ul><li>  Der Prozess der Einführung funktionaler Überlastungen war nicht immer bequem. </li><li>  Der OpenAPI-Parsing-Mechanismus war nicht optimal. </li><li>  Das Rendern von Darstellungen und das Weiterleiten zwischen ihnen wurde mit selbstgeschriebenen Bibliotheken durchgeführt, was uns aus mehreren Gründen ebenfalls nicht zusagte: <br><ul><li>  Diese Bibliotheken wurden nicht durch Tests abgedeckt; </li><li>  Für diese Bibliotheken gab es keine Dokumentation. </li><li>  Sie hatten keine Community - im Falle der Entdeckung von Fehlern in ihnen oder der Abreise des Mitarbeiters, der sie geschrieben hat, wäre die Unterstützung für einen solchen Code sehr schwierig. </li></ul></li></ul><br>  Und da wir in unserem Unternehmen am DevOps-Ansatz festhalten und versuchen, unseren Code so weit wie möglich zu standardisieren und zu formalisieren, haben wir uns im Februar dieses Jahres entschlossen, ein globales Refactoring des VSTUtils-Front-End-Frameworks durchzuführen.  Wir hatten mehrere Aufgaben: <br><br><ul><li>  Um nicht nur Präsentationsklassen am Frontend, sondern auch Modellklassen zu bilden, haben wir erkannt, dass es korrekter ist, Daten (und ihre Struktur) von ihrer Präsentation zu trennen.  Darüber hinaus würde das Vorhandensein mehrerer Abstraktionen in Form einer Darstellung und eines Modells das Hinzufügen von Überladungen der Grundfunktionalität in Projekten, die auf VSTUtils basieren, erheblich erleichtern. </li><li>  Verwenden Sie ein getestetes Framework mit einer großen Community (Angular, React, Vue) zum Rendern und Weiterleiten. Auf diese Weise können wir alle Kopfschmerzen beseitigen und Code für das Rendern und Weiterleiten in unserer Anwendung unterstützen. </li></ul><br><h2>  Refactoring - Auswahl des JS-Frameworks </h2><br>  Unter den beliebtesten JS-Frameworks: Angular, React, Vue fiel unsere Wahl auf Vue, weil: <br><br><ul><li>  Die Codebasis von Vue wiegt weniger als React and Angular. <br><br>  <i>Gzipped Framework Größenvergleichstabelle</i> <br><div class="scrollable-table"><table><tbody><tr><th>  Framework </th><th>  Größe, kb </th></tr><tr><td>  Winkel 2 </td><td>  111 </td></tr><tr><td>  Winkel 2 + RX </td><td>  143 </td></tr><tr><td>  Winkel 1.4.5 </td><td>  51 </td></tr><tr><td>  Reagiere 0.14.5 + Reagiere DOM </td><td>  40 </td></tr><tr><td>  Reagiere 0.14.5 + Reagiere DOM + Redux </td><td>  42 </td></tr><tr><td>  Reagiere 15.3.0 + Reagiere DOM </td><td>  43 </td></tr><tr><td>  Vue 2.4.2 </td><td>  21 </td></tr></tbody></table></div></li><li>  Der Seitenrenderprozess von Vue dauert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">weniger lange</a> als der von React und Angular. <br><img src="https://habrastorage.org/webt/lo/eu/6m/loeu6mow9u1qbcz3nbanmldjmwu.png" alt="Vergleichen der Konflikte beim Rendern von Seiten mit verschiedenen Javascript-Frameworks im Vergleich zu reinem Javascript"></li><li>  Die Eintrittsschwelle in Vue ist viel niedriger als in React und Angular. </li><li>  Nativ verständliche Syntax von Vorlagen; </li><li>  Elegante, detaillierte Dokumentation in mehreren Sprachen, einschließlich Russisch; </li><li>  Ein entwickeltes Ökosystem, das neben der Vue-Kernbibliothek Bibliotheken für das Routing und die Erstellung eines reaktiven Data Warehouse bereitstellt. </li></ul><br><h2>  Version 2.0 - das Ergebnis des Front-End-Refactorings </h2><br>  Der Prozess der globalen Umgestaltung des Frontends von VSTUtils dauerte ungefähr 4 Monate, und am Ende haben wir Folgendes erreicht: <br><br><img src="https://habrastorage.org/webt/6a/wr/9k/6awr9kuruhmeq9gey-isefn_21u.png" alt="neue Front-End-VSTUtils-Architektur"><br><br>  Das Front-End-Framework von VSTUtils besteht immer noch aus zwei großen Blöcken: Der erste befasst sich mit dem Parsen des OpenAPI-Schemas, der zweite mit dem Rendern von Ansichten und dem Routing zwischen ihnen, aber beide Blöcke haben eine Reihe bedeutender Änderungen erfahren. <br><br>  Der Mechanismus, der das OpenAPI-Schema analysiert, wurde vollständig neu geschrieben.  Der Ansatz zum Parsen dieses Schemas hat sich geändert.  Wir haben versucht, die Front-End-Architektur der Back-End-Architektur so ähnlich wie möglich zu gestalten.  Jetzt haben wir auf der Client-Seite nicht nur eine einzige Abstraktion in Form von Darstellungen, sondern auch Abstraktionen in Form von Modellen und QuerySets: <br><br><ul><li>  Objekte der Model-Klasse und ihrer Nachkommen sind Objekte, die den serverseitigen Abstraktionen von Django Models entsprechen.  Objekte dieses Typs enthalten Daten zur Struktur des Modells (Modellname, Modellfelder usw.); </li><li>  Objekte der QuerySet-Klasse und ihrer Nachkommen sind Objekte, die der serverseitigen Django QuerySets-Abstraktion entsprechen.  Objekte dieses Typs enthalten Methoden, mit denen Sie API-Anforderungen ausführen können (Hinzufügen, Ändern, Empfangen, Löschen von Daten von Modellobjekten). </li><li>  Objekte der View-Klasse - Objekte, die Daten darüber speichern, wie das Modell auf einer bestimmten Seite dargestellt werden soll, welche Vorlage zum „Rendern“ der Seite verwendet werden soll, mit welchen anderen Darstellungen der Modelle diese Seite verknüpft werden kann usw. </li></ul><br>  Die für das Rendern und Routing zuständige Einheit hat sich ebenfalls erheblich geändert.  Wir haben die selbstgeschriebenen JS SPA-Bibliotheken zugunsten von Vue.js aufgegeben.  Wir haben unsere eigenen Vue-Komponenten entwickelt, aus denen alle Seiten unserer Webanwendung bestehen.  Das Routing zwischen Ansichten erfolgt mithilfe der Vue-Router-Bibliothek, und wir verwenden Vuex als reaktiven Speicher für den Anwendungsstatus. <br><br>  Ich möchte auch darauf hinweisen, dass die Implementierung der Klassen Model, QuerySet und View auf der Front-End-Seite nicht von den Render- und Routing-Mitteln abhängt, dh wenn wir plötzlich von Vue zu einem anderen Framework wechseln möchten, z. B. React oder Etwas Neues, dann müssen wir nur noch die Vue-Komponenten in die Komponenten des neuen Frameworks umschreiben, den Router und das Repository neu schreiben und das ist alles - das VSTUtils-Framework funktioniert wieder.  Die Implementierung der Klassen Model, QuerySet und View bleibt unverändert, da sie nicht von Vue.js abhängt.  Wir glauben, dass dies eine sehr gute Hilfe für mögliche zukünftige Änderungen ist. <br><br><h2>  Zusammenfassend </h2><br>  Die Zurückhaltung, „doppelten“ Code zu schreiben, führte daher zu der Aufgabe, die Bildung des Frontends einer Webanwendung zu automatisieren, was durch die Erstellung des VSTUtils-Frameworks gelöst wurde.  Wir haben es geschafft, die Architektur der Webanwendung so zu gestalten, dass sich Back-End und Front-End harmonisch ergänzen und jede Änderung der API-Struktur automatisch erfasst und ordnungsgemäß auf dem Client angezeigt wird. <br><br>  Die Vorteile, die wir durch die Formalisierung der Architektur der Webanwendung erhalten haben: <br><br><ul><li>  Veröffentlichungen von Anwendungen, die auf der Basis von VSTUtils ausgeführt wurden, wurden zweimal häufiger veröffentlicht.  Dies liegt an der Tatsache, dass wir für die Einführung einer neuen Funktion häufig nur Code im Back-End hinzufügen müssen. Das Front-End wird automatisch generiert. Dies spart Zeit. </li><li>  Vereinfachte Aktualisierung der Grundfunktionalität.  Da jetzt alle grundlegenden Funktionen in einem Framework zusammengefasst sind, müssen einige Änderungen nur an einer Stelle vorgenommen werden, um einige wichtige Abhängigkeiten zu aktualisieren oder die grundlegenden Funktionen zu verbessern - in der VSTUtils-Codebasis.  Beim Aktualisieren der Version von VSTUtils in untergeordneten Projekten werden alle Innovationen automatisch übernommen. </li><li>  Die Suche nach neuen Mitarbeitern ist einfacher geworden.  Stimmen Sie zu, es ist viel einfacher, einen Entwickler für einen formalisierten Technologie-Stack (Django, Vue) zu finden, als nach einer Person zu suchen, die sich bereit erklärt, mit einem unbekannten Rekorder zu arbeiten.  Suchergebnisse für Entwickler, die Django oder Vue in HeadHunter in ihren Lebensläufen erwähnt haben (über alle Regionen hinweg): <br><ul><li>  Django - 3.454 Lebensläufe wurden für 3.136 Bewerber gefunden; </li><li>  Vue - 4.092 Lebensläufe wurden für 3.747 Arbeitssuchende gefunden. </li></ul></li></ul><br>  Die Nachteile einer solchen Formalisierung der Architektur einer Webanwendung umfassen Folgendes: <br><br><ul><li>  Aufgrund des Parsens des OpenAPI-Schemas dauert die Initialisierung der Anwendung auf dem Client etwas länger als zuvor (etwa 20 bis 30 Millisekunden länger). </li><li>  Unwichtige Suchindizierung.  Tatsache ist, dass wir derzeit kein Server-Rendering im Rahmen von VSTUtils verwenden und der gesamte Inhalt der Anwendung in der endgültigen Form bereits auf dem Client erstellt wird.  Für unsere Projekte werden jedoch häufig keine hohen Suchergebnisse benötigt, und für uns ist dies nicht so kritisch. </li></ul><br>  Damit endet meine Geschichte, danke für Ihre Aufmerksamkeit! <br><br><h2>  Nützliche Links </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenAPI-Spezifikation</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VSTUtils-Repository</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Beispielprojekt, das auf Basis von VSTUtils erstellt wurde</a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456146/">https://habr.com/ru/post/de456146/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456132/index.html">Informationen zum Aufzeichnen von Fehlern oder zum Finden einer Katze</a></li>
<li><a href="../de456134/index.html">Vertrauen, aber überprüfen! So testen Sie Ihr Modell mithilfe der IBM Cloud (Watson OpenScale)</a></li>
<li><a href="../de456136/index.html">Warum machen wir Enterprise Service Mesh?</a></li>
<li><a href="../de456140/index.html">Treffen Sie Codeception 3.0</a></li>
<li><a href="../de456144/index.html">KubeCon EU 2019: 10 wichtige Ergebnisse</a></li>
<li><a href="../de456148/index.html">News der Woche: Facebook lehnt Huawei in Anwendungen ab, Aurora OS statt Android, Mining-Strafen</a></li>
<li><a href="../de456150/index.html">Kleine Freude # 4: Radon - Codequalität gemessen in Zahlen</a></li>
<li><a href="../de456154/index.html">Core UX Features & MVP beim Erstellen eines Produkts</a></li>
<li><a href="../de456156/index.html">Deshalb wird Schulalgebra benötigt.</a></li>
<li><a href="../de456158/index.html">Ein bisschen über Kernbrennstoffquellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>