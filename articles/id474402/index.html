<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòá ‚òÇÔ∏è ü§æüèΩ Panduan API Koleksi Vavr üî∏ üë®üèø‚Äçüé® ‚õÑÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="VAVR (sebelumnya dikenal sebagai Javaslang) adalah perpustakaan fungsional nirlaba untuk Java 8+. Ini memungkinkan Anda untuk menulis kode mirip Scala...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan API Koleksi Vavr</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474402/">  <b>VAVR</b> (sebelumnya dikenal sebagai Javaslang) adalah perpustakaan fungsional nirlaba untuk Java 8+.  Ini memungkinkan Anda untuk menulis kode mirip Scala fungsional di Jawa dan berfungsi untuk mengurangi jumlah kode dan meningkatkan kualitasnya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Situs perpustakaan</a> . <br><br>  Di bawah potongan adalah terjemahan dari artikel yang mensistematisasikan informasi pada <b>Vavr Collections API</b> . <br><a name="habracut"></a><br>  Diterjemahkan oleh <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@middle_java</a></b> <br><br>  Artikel Asli Yang Dimodifikasi Terakhir: 15 Agustus 2019 <br><br><h2>  1. Ikhtisar </h2><br>  Perpustakaan Vavr, sebelumnya dikenal sebagai Javaslang, adalah perpustakaan fungsional untuk Jawa.  Pada artikel ini, kami mengeksplorasi API koleksi yang kuat. <br><br>  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini untuk</a> informasi lebih lanjut tentang perpustakaan ini. <br><br><h2>  2. Koleksi Persisten </h2><br>  Koleksi persisten, saat dimodifikasi, membuat versi baru koleksi tanpa mengubah versi saat ini. <br><br>  Dukungan untuk beberapa versi dari koleksi yang sama dapat menyebabkan penggunaan CPU dan memori yang tidak efisien.  Namun, perpustakaan koleksi Vavr mengatasi ini dengan berbagi struktur data antara versi koleksi yang berbeda. <br><br>  Ini pada dasarnya berbeda dari <code>unmodifiableCollection()</code> dari <code>Collections</code> kelas utilitas Java, yang hanya menyediakan pembungkus untuk koleksi basis. <br><br>  Mencoba mengubah koleksi seperti itu <code>UnsupportedOperationException</code> alih-alih membuat versi baru.  Selain itu, koleksi basis masih bisa berubah melalui tautan langsung ke sana. <br><br><h2>  3. Dapat dilewati </h2><br>  <code>Traversable</code> adalah tipe dasar dari semua koleksi VAVR.  Antarmuka ini mendefinisikan metode umum untuk semua struktur data. <br><br>  Ini memberikan beberapa metode default yang berguna, seperti <code>size()</code> , <code>get()</code> , <code>filter()</code> , <code>isEmpty()</code> dan lainnya yang diwarisi oleh sub-interface. <br><br>  Kami lebih jauh menjelajahi perpustakaan koleksi. <br><br><h2>  4. Seq </h2><br>  Mari kita mulai dengan urutannya. <br><br>  Antarmuka <code>Seq</code> adalah struktur data berurutan.  Ini adalah antarmuka induk untuk <code>List</code> , <code>Stream</code> , <code>Queue</code> , <code>Array</code> , <code>Vector</code> dan <code>CharSeq</code> .  Semua struktur data ini memiliki sifat uniknya sendiri, yang akan kita bahas di bawah ini. <br><br><h3>  4.1.  Daftar </h3><br>  <code>List</code> adalah operasi yang dihitung dengan penuh semangat (dievaluasi dengan penuh semangat, dilakukan segera setelah nilai <code>LinearSeq</code> diketahui) urutan elemen yang memperluas antarmuka <code>LinearSeq</code> . <br><br>  <code>List</code> Persistent dibangun secara rekursif menggunakan <b>kepala</b> dan <b>ekor</b> : <br><br><ul><li>  <b>Kepala</b> adalah elemen pertama </li><li>  <b>Ekor</b> - daftar yang mengandung elemen yang tersisa (daftar ini juga dibentuk dari kepala dan ekor) </li></ul><br>  <code>List</code> API berisi metode pabrik statis yang dapat Anda gunakan untuk membuat <code>List</code> .  Anda dapat menggunakan metode statis <code>of()</code> untuk membuat instance <code>List</code> dari satu atau lebih objek. <br><br>  Anda juga dapat menggunakan metode static <code>empty()</code> untuk membuat <code>List</code> kosong dan metode <code>ofAll()</code> untuk membuat <code>List</code> tipe <code>Iterable</code> : <br><br><pre> <code class="java hljs">List &lt; String &gt; list = List.of( <span class="hljs-string"><span class="hljs-string">"Java"</span></span>, <span class="hljs-string"><span class="hljs-string">"PHP"</span></span>, <span class="hljs-string"><span class="hljs-string">"Jquery"</span></span>, <span class="hljs-string"><span class="hljs-string">"JavaScript"</span></span>, <span class="hljs-string"><span class="hljs-string">"JShell"</span></span>, <span class="hljs-string"><span class="hljs-string">"JAVA"</span></span>);</code> </pre> <br>  Mari kita lihat beberapa contoh manipulasi daftar. <br><br>  Kita dapat menggunakan metode <code>drop()</code> dan variannya untuk menghapus elemen <code>N</code> pertama: <br><br><pre> <code class="java hljs">List list1 = list.drop(<span class="hljs-number"><span class="hljs-number">2</span></span>); assertFalse(list1.contains(<span class="hljs-string"><span class="hljs-string">"Java"</span></span>) &amp;&amp; list1.contains(<span class="hljs-string"><span class="hljs-string">"PHP"</span></span>)); List list2 = list.dropRight(<span class="hljs-number"><span class="hljs-number">2</span></span>); assertFalse(list2.contains(<span class="hljs-string"><span class="hljs-string">"JAVA"</span></span>) &amp;&amp; list2.contains(<span class="hljs-string"><span class="hljs-string">"JShell"</span></span>)); List list3 = list.dropUntil(s - &gt; s.contains(<span class="hljs-string"><span class="hljs-string">"Shell"</span></span>)); assertEquals(list3.size(), <span class="hljs-number"><span class="hljs-number">2</span></span>); List list4 = list.dropWhile(s - &gt; s.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); assertTrue(list4.isEmpty());</code> </pre> <br>  <code>drop(int n)</code> menghapus <code>n</code> item dari daftar, mulai dari item pertama, sementara <code>dropRight()</code> melakukan hal yang sama, mulai dari item terakhir dalam daftar. <br><br>  <code>dropUntil()</code> menghapus item dari daftar sampai predikat <code>true</code> , sementara <code>dropWhile()</code> menghapus item sampai predikat <code>true</code> . <br><br>  Ada juga <code>dropRightWhile()</code> dan <code>dropRightUntil()</code> yang menghapus item mulai dari kanan. <br><br>  Selanjutnya, <code>take(int n)</code> digunakan untuk mengambil item dari daftar.  Dibutuhkan <code>n</code> item dari daftar dan kemudian berhenti.  Ada juga <code>takeRight(int n)</code> , yang mengambil elemen dari akhir daftar: <br><br><pre> <code class="java hljs">List list5 = list.take(<span class="hljs-number"><span class="hljs-number">1</span></span>); assertEquals(list5.single(), <span class="hljs-string"><span class="hljs-string">"Java"</span></span>); List list6 = list.takeRight(<span class="hljs-number"><span class="hljs-number">1</span></span>); assertEquals(list5.single(), <span class="hljs-string"><span class="hljs-string">"Java"</span></span>); List list7 = list.takeUntil(s - &gt; s.length() &gt; <span class="hljs-number"><span class="hljs-number">6</span></span>); assertEquals(list3.size(), <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Akhirnya, <code>takeUntil()</code> mengambil elemen dari daftar sampai predikat menjadi <code>true</code> .  Ada varian <code>takeWhile()</code> yang juga menggunakan argumen predikat. <br><br>  Selain itu, API memiliki metode lain yang bermanfaat, misalnya, bahkan <code>distinct()</code> , yang mengembalikan daftar elemen dengan duplikat yang dihapus, dan <code>distinctBy()</code> , yang menerima <code>Comparator</code> untuk menentukan kesetaraan. <br><br>  Sangat menarik bahwa ada juga <code>intersperse()</code> , yang menyisipkan elemen di antara setiap elemen daftar.  Ini bisa sangat nyaman untuk operasi dengan <code>String</code> : <br><br><pre> <code class="java hljs">List list8 = list .distinctBy((s1, s2) - &gt; s1.startsWith(s2.charAt(<span class="hljs-number"><span class="hljs-number">0</span></span>) + <span class="hljs-string"><span class="hljs-string">""</span></span>) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>); assertEquals(list3.size(), <span class="hljs-number"><span class="hljs-number">2</span></span>); String words = List.of(<span class="hljs-string"><span class="hljs-string">"Boys"</span></span>, <span class="hljs-string"><span class="hljs-string">"Girls"</span></span>) .intersperse(<span class="hljs-string"><span class="hljs-string">"and"</span></span>) .reduce((s1, s2) - &gt; s1.concat(<span class="hljs-string"><span class="hljs-string">" "</span></span> + s2)) .trim(); assertEquals(words, <span class="hljs-string"><span class="hljs-string">"Boys and Girls"</span></span>);</code> </pre> <br>  Ingin membagi daftar menjadi beberapa kategori?  Dan untuk ini ada API: <br><br><pre> <code class="java hljs">Iterator &lt; List &lt; String &gt;&gt; iterator = list.grouped(<span class="hljs-number"><span class="hljs-number">2</span></span>); assertEquals(iterator.head().size(), <span class="hljs-number"><span class="hljs-number">2</span></span>); Map &lt; Boolean, List &lt; String &gt;&gt; map = list.groupBy(e - &gt; e.startsWith(<span class="hljs-string"><span class="hljs-string">"J"</span></span>)); assertEquals(map.size(), <span class="hljs-number"><span class="hljs-number">2</span></span>); assertEquals(map.get(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).get().size(), <span class="hljs-number"><span class="hljs-number">1</span></span>); assertEquals(map.get(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).get().size(), <span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br>  Metode <code>group(int n)</code> membagi <code>List</code> menjadi kelompok-kelompok elemen <code>n</code> masing-masing.  Metode <code>groupdBy()</code> mengambil <code>Function</code> yang berisi logika untuk memisahkan daftar dan mengembalikan <code>Map</code> dengan dua elemen: <code>true</code> dan <code>false</code> . <br><br>  Kunci sebenarnya dipetakan ke <code>List</code> elemen yang memenuhi kondisi yang ditentukan dalam <code>Function</code> .  Kunci <code>false</code> memetakan ke <code>List</code> elemen yang tidak memenuhi kondisi ini. <br><br>  Seperti yang diharapkan, ketika mengubah <code>List</code> , <code>List</code> asli tidak benar-benar berubah.  Sebaliknya, versi baru <code>List</code> selalu dikembalikan. <br><br>  Kita juga dapat berinteraksi dengan <code>List</code> menggunakan semantik stack - mengekstraksi elemen sesuai dengan prinsip "last in, first out" (LIFO).  Dalam pengertian ini, metode API seperti <code>peek()</code> , <code>pop()</code> dan <code>push()</code> ada untuk memanipulasi tumpukan: <br><br><pre> <code class="java hljs">List &lt; Integer &gt; intList = List.empty(); List &lt; Integer &gt; intList1 = intList.pushAll(List.rangeClosed(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)); assertEquals(intList1.peek(), Integer.valueOf(<span class="hljs-number"><span class="hljs-number">10</span></span>)); List intList2 = intList1.pop(); assertEquals(intList2.size(), (intList1.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre> <br>  Fungsi <code>pushAll()</code> digunakan untuk memasukkan berbagai bilangan bulat pada stack, dan fungsi <code>peek()</code> digunakan untuk mengambil elemen head stack.  Ada juga metode <code>peekOption()</code> yang dapat membungkus hasilnya dalam objek <code>Option</code> . <br><br>  Ada metode lain yang menarik dan sangat berguna dalam antarmuka <code>List</code> yang didokumentasikan secara menyeluruh dalam dokumen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java</a> . <br><br><h3>  4.2.  Antrian </h3><br>  <code>Queue</code> tidak berubah menyimpan elemen, memungkinkan Anda untuk mengambilnya sesuai dengan prinsip FIFO (masuk pertama, keluar pertama). <br><br>  <code>Queue</code> dalam <code>Queue</code> terdiri dari dua daftar tertaut: <code>List</code> depan dan <code>List</code> belakang.  <code>List</code> depan berisi item yang dihapus dari antrian, dan <code>List</code> belakang berisi item yang antri. <br><br>  Ini memungkinkan Anda untuk menempatkan operasi antrian dan menghapus dari antrian ke kompleksitas <b>O (1)</b> .  Ketika <code>List</code> berakhir di <code>List</code> depan ketika dihapus dari antrian, <code>List</code> belakang terbalik dan menjadi <code>List</code> depan baru. <br><br>  Mari kita membuat antrian: <br><br><pre> <code class="java hljs">Queue &lt; Integer &gt; queue = Queue.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); Queue &lt; Integer &gt; secondQueue = queue.enqueueAll(List.of(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)); assertEquals(<span class="hljs-number"><span class="hljs-number">3</span></span>, queue.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">5</span></span>, secondQueue.size()); Tuple2 &lt; Integer, Queue &lt; Integer &gt;&gt; result = secondQueue.dequeue(); assertEquals(Integer.valueOf(<span class="hljs-number"><span class="hljs-number">1</span></span>), result._1); Queue &lt; Integer &gt; tailQueue = result._2; assertFalse(tailQueue.contains(secondQueue.get(<span class="hljs-number"><span class="hljs-number">0</span></span>)));</code> </pre> <br>  Fungsi <code>dequeue()</code> menghilangkan elemen head dari <code>Queue</code> dan mengembalikan <code>Tuple2&lt;T, Q&gt;</code> .  Elemen pertama dari tuple adalah elemen head yang dihapus dari antrian, elemen kedua dari tuple adalah elemen <code>Queue</code> tersisa. <br><br>  Kita bisa menggunakan <code>combination(n)</code> untuk mendapatkan semua kemungkinan kombinasi <code>N</code> elemen dalam <code>Queue</code> : <br><br><pre> <code class="java hljs">Queue &lt; Queue &lt; Integer &gt;&gt; queue1 = queue.combinations(<span class="hljs-number"><span class="hljs-number">2</span></span>); assertEquals(queue1.get(<span class="hljs-number"><span class="hljs-number">2</span></span>).toCharSeq(), CharSeq.of(<span class="hljs-string"><span class="hljs-string">"23"</span></span>));</code> </pre> <br>  Sekali lagi, <code>Queue</code> asli tidak berubah saat menambah / menghapus item dari antrian. <br><br><h3>  4.3.  Aliran </h3><br>  <code>Stream</code> adalah implementasi dari daftar yang ditautkan secara malas yang sangat berbeda dari <code>java.util.stream</code> .  Tidak seperti <code>java.util.stream</code> , <code>Stream</code> Vavr menyimpan data dan dengan malas menghitung elemen berikutnya. <br>  Katakanlah kita memiliki bilangan bulat <code>Stream</code> : <br><br><pre> <code class="java hljs">Stream &lt; Integer &gt; s = Stream.of(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Saat mencetak hasil <code>s.toString()</code> di konsol, hanya <b>Stream (2 ,?) yang</b> akan ditampilkan.  Ini berarti bahwa hanya elemen Head <code>Stream</code> yang dihitung, sedangkan elemen ekor tidak. <br><br>  Memanggil <code>s.get(3)</code> dan kemudian menampilkan hasil <code>s.tail()</code> mengembalikan <b>Stream (1, 3, 4 ,?)</b> .  Sebaliknya, jika Anda tidak memanggil <code>s.get(3)</code> - yang akan membuat <code>Stream</code> menghitung elemen terakhir - hanya <b>Stream (1 ,?)</b> Akan menjadi hasil dari <code>s.tail()</code> <b>)</b> .  Ini berarti bahwa hanya elemen ekor pertama yang dihitung. <br><br>  Perilaku ini dapat meningkatkan kinerja dan memungkinkan <code>Stream</code> untuk digunakan untuk mewakili urutan yang (secara teoritis) sangat panjang. <br>  <code>Stream</code> di Vavr tidak dapat diubah dan dapat berupa <code>Empty</code> atau <code>Cons</code> .  <code>Cons</code> terdiri dari elemen kepala dan ekor <code>Stream</code> dihitung malas.  Tidak seperti <code>List</code> , <code>Stream</code> menyimpan elemen kepala dalam memori.  Elemen ekor dihitung sesuai kebutuhan. <br><br>  Mari kita buat <code>Stream</code> 10 bilangan bulat positif dan hitung jumlah bilangan genap: <br><br><pre> <code class="java hljs">Stream &lt; Integer &gt; intStream = Stream.iterate(<span class="hljs-number"><span class="hljs-number">0</span></span>, i - &gt; i + <span class="hljs-number"><span class="hljs-number">1</span></span>) .take(<span class="hljs-number"><span class="hljs-number">10</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">10</span></span>, intStream.size()); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> evenSum = intStream.filter(i - &gt; i % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) .sum() .longValue(); assertEquals(<span class="hljs-number"><span class="hljs-number">20</span></span>, evenSum);</code> </pre> <br>  Berbeda dengan <code>Stream</code> API dari Java 8, <code>Stream</code> di Vavr adalah struktur data untuk menyimpan urutan elemen. <br><br>  Oleh karena itu, ia memiliki metode seperti <code>get()</code> , <code>append()</code> , <code>insert()</code> dan lainnya untuk memanipulasi elemen-elemennya.  <code>drop()</code> , <code>distinct()</code> dan beberapa metode lain yang dibahas sebelumnya juga tersedia. <br><br>  Akhirnya, mari kita cepat tunjukkan <code>tabulate()</code> di <code>Stream</code> .  Metode ini mengembalikan <code>Stream</code> panjang <code>n</code> mengandung elemen yang merupakan hasil dari penerapan fungsi: <br><br><pre> <code class="java hljs">Stream &lt; Integer &gt; s1 = Stream.tabulate(<span class="hljs-number"><span class="hljs-number">5</span></span>, (i) - &gt; i + <span class="hljs-number"><span class="hljs-number">1</span></span>); assertEquals(s1.get(<span class="hljs-number"><span class="hljs-number">2</span></span>).intValue(), <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Kita juga dapat menggunakan <code>zip()</code> untuk membuat <code>Stream</code> dari <code>Tuple2&lt;Integer, Integer&gt;</code> , yang berisi elemen yang dibentuk dengan menggabungkan dua <code>Stream</code> : <br><br><pre> <code class="java hljs">Stream &lt; Integer &gt; s = Stream.of(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); Stream &lt; Tuple2 &lt; Integer, Integer &gt;&gt; s2 = s.zip(List.of(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>)); Tuple2 &lt; Integer, Integer &gt; t1 = s2.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); assertEquals(t1._1().intValue(), <span class="hljs-number"><span class="hljs-number">2</span></span>); assertEquals(t1._2().intValue(), <span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre> <br><h3>  4.4.  Array </h3><br>  <code>Array</code> adalah urutan indeks yang tidak berubah yang menyediakan akses acak yang efisien.  Ini didasarkan pada <b>array</b> Java objek.  Intinya, ini adalah pembungkus <code>Traversable</code> untuk berbagai objek bertipe <code>T</code> <br><br>  Anda dapat membuat turunan <code>Array</code> menggunakan metode statis <code>of()</code> .  Selain itu, Anda dapat membuat berbagai elemen menggunakan <code>range()</code> metode statis <code>range()</code> dan <code>rangeBy()</code> .  Metode <code>rangeBy()</code> memiliki parameter ketiga, yang memungkinkan Anda menentukan langkah. <br><br>  Metode <code>range()</code> dan <code>rangeBy()</code> akan membuat elemen, mulai dari nilai awal ke nilai akhir dikurangi satu.  Jika kita perlu memasukkan nilai akhir, kita dapat menggunakan <code>rangeClosed()</code> atau <code>rangeClosedBy()</code> : <br><br><pre> <code class="java hljs">Array &lt; Integer &gt; rArray = Array.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); assertFalse(rArray.contains(<span class="hljs-number"><span class="hljs-number">5</span></span>)); Array &lt; Integer &gt; rArray2 = Array.rangeClosed(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); assertTrue(rArray2.contains(<span class="hljs-number"><span class="hljs-number">5</span></span>)); Array &lt; Integer &gt; rArray3 = Array.rangeClosedBy(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); assertEquals(list3.size(), <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Mari kita bekerja dengan elemen menggunakan indeks: <br><br><pre> <code class="java hljs">Array &lt; Integer &gt; intArray = Array.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); Array &lt; Integer &gt; newArray = intArray.removeAt(<span class="hljs-number"><span class="hljs-number">1</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">3</span></span>, intArray.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, newArray.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">3</span></span>, newArray.get(<span class="hljs-number"><span class="hljs-number">1</span></span>).intValue()); Array &lt; Integer &gt; array2 = intArray.replace(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); assertEquals(s1.get(<span class="hljs-number"><span class="hljs-number">0</span></span>).intValue(), <span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br><h3>  4.5.  Vektor </h3><br>  <code>Vector</code> adalah persilangan antara <code>Array</code> dan <code>List</code> , menyediakan urutan elemen yang diindeks, memungkinkan akses acak dan modifikasi dalam waktu konstan: <br><br><pre> <code class="java hljs">Vector &lt; Integer &gt; intVector = Vector.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); Vector &lt; Integer &gt; newVector = intVector.replace(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">4</span></span>, intVector.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">4</span></span>, newVector.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, intVector.get(<span class="hljs-number"><span class="hljs-number">1</span></span>).intValue()); assertEquals(<span class="hljs-number"><span class="hljs-number">6</span></span>, newVector.get(<span class="hljs-number"><span class="hljs-number">1</span></span>).intValue());</code> </pre> <br><h3>  4.6.  Charseq </h3><br>  <code>CharSeq</code> adalah objek koleksi untuk mewakili urutan karakter primitif.  Intinya, ini adalah pembungkus untuk <code>String</code> dengan penambahan operasi pengumpulan. <br><br>  Untuk membuat <code>CharSeq</code> Anda harus melakukan yang berikut ini. <br><br><pre> <code class="java hljs">CharSeq chars = CharSeq.of(<span class="hljs-string"><span class="hljs-string">"vavr"</span></span>); CharSeq newChars = chars.replace(<span class="hljs-string"><span class="hljs-string">'v'</span></span>, <span class="hljs-string"><span class="hljs-string">'V'</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">4</span></span>, chars.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">4</span></span>, newChars.size()); assertEquals(<span class="hljs-string"><span class="hljs-string">'v'</span></span>, chars.charAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); assertEquals(<span class="hljs-string"><span class="hljs-string">'V'</span></span>, newChars.charAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); assertEquals(<span class="hljs-string"><span class="hljs-string">"Vavr"</span></span>, newChars.mkString());</code> </pre> <br><h2>  5. Atur </h2><br>  Bagian ini membahas berbagai implementasi <code>Set</code> di perpustakaan koleksi.  Fitur unik dari struktur data <code>Set</code> adalah tidak mengijinkan nilai duplikat. <br><br>  Ada berbagai implementasi <code>Set</code> .  Yang utama adalah <code>HashSet</code> .  <code>TreeSet</code> tidak memungkinkan elemen duplikat dan dapat diurutkan.  <code>LinkedHashSet</code> mempertahankan urutan elemen penyisipan. <br><br>  Mari kita lihat lebih dekat implementasi ini satu demi satu. <br><br><h3>  5.1.  Hashset </h3><br>  <code>HashSet</code> memiliki metode pabrik statis untuk membuat instance baru.  Beberapa di antaranya kami pelajari sebelumnya dalam artikel ini, misalnya <code>of()</code> , <code>ofAll()</code> dan variasi pada <code>range()</code> metode. <br><br>  Perbedaan antara dua <b>set</b> dapat diperoleh dengan menggunakan metode <code>diff()</code> .  Juga, metode <code>union()</code> dan <code>intersect()</code> mengembalikan union dan persimpangan dua <b>set</b> : <br><br><pre> <code class="java hljs">HashSet &lt; Integer &gt; set0 = HashSet.rangeClosed(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); HashSet &lt; Integer &gt; set0 = HashSet.rangeClosed(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); assertEquals(set0.union(set1), HashSet.rangeClosed(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)); assertEquals(set0.diff(set1), HashSet.rangeClosed(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); assertEquals(set0.intersect(set1), HashSet.rangeClosed(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>));</code> </pre> <br>  Kami juga dapat melakukan operasi dasar, seperti menambah dan menghapus elemen: <br><br><pre> <code class="java hljs">HashSet &lt; String &gt; set = HashSet.of(<span class="hljs-string"><span class="hljs-string">"Red"</span></span>, <span class="hljs-string"><span class="hljs-string">"Green"</span></span>, <span class="hljs-string"><span class="hljs-string">"Blue"</span></span>); HashSet &lt; String &gt; newSet = set.add(<span class="hljs-string"><span class="hljs-string">"Yellow"</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">3</span></span>, set.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">4</span></span>, newSet.size()); assertTrue(newSet.contains(<span class="hljs-string"><span class="hljs-string">"Yellow"</span></span>));</code> </pre> <br>  Implementasi <code>HashSet</code> didasarkan pada <b>hash array mapped trie (HAMT)</b> , yang menawarkan kinerja yang unggul dibandingkan dengan <code>HashTable</code> biasa dan strukturnya membuatnya cocok untuk mendukung koleksi persisten. <br><br><h3>  5.2.  Treeset </h3><br>  Immutable <code>TreeSet</code> adalah implementasi dari antarmuka <code>SortedSet</code> .  Ini menyimpan satu set elemen yang diurutkan dan diimplementasikan menggunakan pohon pencarian biner.  Semua operasinya dilakukan selama waktu <b>O (log n)</b> . <br><br>  Secara default, elemen <code>TreeSet</code> diurutkan dalam urutan alami mereka. <br>  Mari kita membuat <code>SortedSet</code> menggunakan urutan sortir alami: <br><br><pre> <code class="java hljs">SortedSet &lt; String &gt; set = TreeSet.of(<span class="hljs-string"><span class="hljs-string">"Red"</span></span>, <span class="hljs-string"><span class="hljs-string">"Green"</span></span>, <span class="hljs-string"><span class="hljs-string">"Blue"</span></span>); assertEquals(<span class="hljs-string"><span class="hljs-string">"Blue"</span></span>, set.head()); SortedSet &lt; Integer &gt; intSet = TreeSet.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, intSet.average().get().intValue());</code> </pre> <br>  Untuk mengatur item dengan cara kustom, berikan instance <code>Comparator</code> saat membuat <code>TreeSet</code> .  Anda juga dapat membuat string dari serangkaian elemen: <br><br><pre> <code class="java hljs">SortedSet &lt; String &gt; reversedSet = TreeSet.of(Comparator.reverseOrder(), <span class="hljs-string"><span class="hljs-string">"Green"</span></span>, <span class="hljs-string"><span class="hljs-string">"Red"</span></span>, <span class="hljs-string"><span class="hljs-string">"Blue"</span></span>); assertEquals(<span class="hljs-string"><span class="hljs-string">"Red"</span></span>, reversedSet.head()); String str = reversedSet.mkString(<span class="hljs-string"><span class="hljs-string">" and "</span></span>); assertEquals(<span class="hljs-string"><span class="hljs-string">"Red and Green and Blue"</span></span>, str);</code> </pre> <br><h3>  5.3.  Bitset </h3><br>  Koleksi VAVR juga memiliki implementasi <code>BitSet</code> tidak berubah.  Antarmuka <code>BitSet</code> memperluas antarmuka <code>SortedSet</code> .  <code>BitSet</code> dapat dibuat menggunakan metode statis di <code>BitSet.Builder</code> . <br>  Seperti dengan implementasi lain dari struktur <code>Set</code> data, <code>BitSet</code> tidak memungkinkan Anda untuk menambahkan rekaman duplikat ke set. <br><br>  Ini mewarisi metode untuk manipulasi dari antarmuka <code>Traversable</code> .  Perhatikan bahwa ini berbeda dari <code>java.util.BitSet</code> dari perpustakaan Java standar.  Data <code>BitSet</code> tidak dapat berisi nilai-nilai <code>String</code> . <br><br>  Pertimbangkan untuk membuat instance <code>BitSet</code> menggunakan metode <code>of()</code> factory: <br><br><pre> <code class="java hljs">BitSet &lt; Integer &gt; bitSet = BitSet.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>); BitSet &lt; Integer &gt; bitSet1 = bitSet.takeUntil(i - &gt; i &gt; <span class="hljs-number"><span class="hljs-number">4</span></span>); assertEquals(list3.size(), <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Untuk memilih empat elemen <code>BitSet</code> pertama <code>BitSet</code> kami menggunakan perintah <code>takeUntil()</code> .  Operasi mengembalikan contoh baru.  Perhatikan bahwa metode <code>takeUntil()</code> didefinisikan dalam antarmuka <code>Traversable</code> , yang merupakan antarmuka induk untuk <code>BitSet</code> . <br><br>  Metode dan operasi lain yang dijelaskan di atas didefinisikan dalam antarmuka <code>Traversable</code> juga berlaku untuk <code>BitSet</code> . <br><br><h2>  6. Peta </h2><br>  <code>Map</code> adalah struktur data nilai kunci.  <code>Map</code> di Vavr tidak dapat diubah dan memiliki implementasi untuk <code>HashMap</code> , <code>TreeMap</code> dan <code>LinkedHashMap</code> . <br><br>  Biasanya, kontrak <b>peta</b> tidak memungkinkan kunci duplikat, sementara nilai duplikat dipetakan ke kunci yang berbeda mungkin. <br><br><h3>  6.1.  Hashmap </h3><br>  <code>HashMap</code> adalah implementasi dari antarmuka <code>Map</code> tidak dapat diubah.  Ini menyimpan pasangan nilai kunci menggunakan hash kunci. <br><br>  <code>Map</code> di Vavr menggunakan <code>Tuple2</code> untuk mewakili pasangan nilai kunci dan bukan tipe <code>Entry</code> tradisional: <br><br><pre> <code class="java hljs">Map &lt; Integer, List &lt; Integer &gt;&gt; map = List.rangeClosed(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) .groupBy(i - &gt; i % <span class="hljs-number"><span class="hljs-number">2</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, map.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">6</span></span>, map.get(<span class="hljs-number"><span class="hljs-number">0</span></span>).get().size()); assertEquals(<span class="hljs-number"><span class="hljs-number">5</span></span>, map.get(<span class="hljs-number"><span class="hljs-number">1</span></span>).get().size());</code> </pre> <br>  Seperti <code>HashSet</code> , implementasi <code>HashMap</code> didasarkan pada <b>Hash array mapped trie (HAMT)</b> , yang mengarah ke waktu yang konstan untuk hampir semua operasi. <br>  Elemen <b>peta</b> dapat disaring dengan kunci menggunakan metode <code>filterKeys()</code> atau dengan nilai menggunakan metode <code>filterValues()</code> .  Kedua metode menggunakan <code>Predicate</code> sebagai argumen: <br><br><pre> <code class="java hljs">Map &lt; String, String &gt; map1 = HashMap.of(<span class="hljs-string"><span class="hljs-string">"key1"</span></span>, <span class="hljs-string"><span class="hljs-string">"val1"</span></span>, <span class="hljs-string"><span class="hljs-string">"key2"</span></span>, <span class="hljs-string"><span class="hljs-string">"val2"</span></span>, <span class="hljs-string"><span class="hljs-string">"key3"</span></span>, <span class="hljs-string"><span class="hljs-string">"val3"</span></span>); Map &lt; String, String &gt; fMap = map1.filterKeys(k - &gt; k.contains(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) || k.contains(<span class="hljs-string"><span class="hljs-string">"2"</span></span>)); assertFalse(fMap.containsKey(<span class="hljs-string"><span class="hljs-string">"key3"</span></span>)); Map &lt; String, String &gt; map1 = map1.filterValues(v - &gt; v.contains(<span class="hljs-string"><span class="hljs-string">"3"</span></span>)); assertEquals(list3.size(), <span class="hljs-number"><span class="hljs-number">1</span></span>); assertTrue(fMap2.containsValue(<span class="hljs-string"><span class="hljs-string">"val3"</span></span>));</code> </pre> <br>  Anda juga dapat mengubah elemen <b>peta</b> menggunakan metode <code>map()</code> .  Misalnya, mari kita konversi <b>map1</b> ke <code>Map&lt;String, Integer&gt;</code> : <br><br><pre> <code class="java hljs">Map &lt; String, Integer &gt; map2 = map1.map( (k, v) - &gt; Tuple.of(k, Integer.valueOf(v.charAt(v.length() - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-string"><span class="hljs-string">""</span></span>))); assertEquals(map2.get(<span class="hljs-string"><span class="hljs-string">"key1"</span></span>).get().intValue(), <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><h3>  6.2.  Treemap </h3><br>  Immutable <code>TreeMap</code> adalah implementasi dari antarmuka <code>SortedMap</code> .  Seperti <code>TreeSet</code> , instance kustom <code>Comparator</code> digunakan untuk menyesuaikan pengurutan elemen <code>TreeMap</code> . <br>  <code>SortedMap</code> tunjukkan pembuatan <code>SortedMap</code> : <br><br><pre> <code class="java hljs">SortedMap &lt; Integer, String &gt; map = TreeMap.of(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"Three"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"Two"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"Four"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"One"</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">1</span></span>, map.keySet().toJavaArray()[<span class="hljs-number"><span class="hljs-number">0</span></span>]); assertEquals(<span class="hljs-string"><span class="hljs-string">"Four"</span></span>, map.get(<span class="hljs-number"><span class="hljs-number">4</span></span>).get());</code> </pre> <br>  Secara default, entri <code>TreeMap</code> diurutkan dalam urutan kunci alami.  Namun, Anda dapat menentukan <code>Comparator</code> akan digunakan untuk menyortir: <br><br><pre> <code class="java hljs">TreeMap &lt; Integer, String &gt; treeMap2 = TreeMap.of(Comparator.reverseOrder(), <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"three"</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"six"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"one"</span></span>); assertEquals(treeMap2.keySet().mkString(), <span class="hljs-string"><span class="hljs-string">"631"</span></span>);</code> </pre> <br>  Seperti dalam kasus <code>TreeSet</code> , implementasi <code>TreeMap</code> juga dibuat menggunakan pohon, oleh karena itu, operasinya punya waktu <b>O (log n)</b> .  Metode <code>map.get(key)</code> mengembalikan <code>Option</code> , yang berisi nilai kunci <b>peta yang</b> ditentukan. <br><br><h2>  7. Kompatibilitas Java </h2><br>  API Koleksi Vavr sepenuhnya kompatibel dengan Java Collection Framework.  Mari kita lihat bagaimana hal ini dilakukan dalam praktek. <br><br><h3>  7.1.  Konversi dari Java ke Vavr </h3><br>  Setiap implementasi pengumpulan di Vavr memiliki pabrik statis metode <code>ofAll()</code> yang menerima <code>java.util.Iterable</code> .  Ini memungkinkan Anda untuk membuat koleksi <b>VAVR</b> dari koleksi <b>Java</b> .  Demikian pula, metode factory <code>ofAll()</code> langsung menerima Java <code>Stream</code> . <br><br>  Untuk mengonversi <code>List</code> Java ke <code>List</code> yang tidak dapat diubah: <br><br><pre> <code class="java hljs">java.util.List &lt; Integer &gt; javaList = java.util.Arrays.asList(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); List &lt; Integer &gt; vavrList = List.ofAll(javaList); java.util.stream.Stream &lt; Integer &gt; javaStream = javaList.stream(); Set &lt; Integer &gt; vavrSet = HashSet.ofAll(javaStream);</code> </pre> <br>  Fungsi lain yang berguna adalah <code>collector()</code> , yang dapat digunakan bersama dengan <code>Stream.collect()</code> untuk mendapatkan koleksi Vavr: <br><br><pre> <code class="java hljs">List &lt; Integer &gt; vavrList = IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) .boxed() .filter(i - &gt; i % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) .collect(List.collector()); assertEquals(<span class="hljs-number"><span class="hljs-number">4</span></span>, vavrList.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, vavrList.head().intValue());</code> </pre> <br><h3>  7.2.  Konversi dari Vavr ke Java </h3><br>  Antarmuka <code>Value</code> memiliki banyak metode untuk mengkonversi dari tipe <b>Vavr</b> ke tipe <b>Java</b> .  Metode ini memiliki format <code>toJavaXXX()</code> . <br><br>  Perhatikan beberapa contoh: <br><br><pre> <code class="java hljs">Integer[] array = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .toJavaArray(Integer.class); assertEquals(<span class="hljs-number"><span class="hljs-number">3</span></span>, array.length); java.util.Map &lt; String, Integer &gt; map = List.of(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-string"><span class="hljs-string">"3"</span></span>) .toJavaMap(i - &gt; Tuple.of(i, Integer.valueOf(i))); assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, map.get(<span class="hljs-string"><span class="hljs-string">"2"</span></span>).intValue());</code> </pre> <br>  Kami juga dapat menggunakan Java 8 <code>Collectors</code> untuk mengumpulkan item dari koleksi Vavr: <br><br><pre> <code class="java hljs">java.util.Set &lt; Integer &gt; javaSet = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .collect(Collectors.toSet()); assertEquals(<span class="hljs-number"><span class="hljs-number">3</span></span>, javaSet.size()); assertEquals(<span class="hljs-number"><span class="hljs-number">1</span></span>, javaSet.toArray()[<span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre> <br><h3>  7.3.  Tampilan Koleksi Java </h3><br>  Selain itu, perpustakaan menyediakan apa yang disebut <b>tampilan koleksi</b> yang berfungsi paling baik ketika dikonversi ke koleksi Java.  Metode transformasi di bagian sebelumnya iterate over (iterate) semua elemen untuk membuat koleksi Java. <br><br>  Tampilan, di sisi lain, mengimplementasikan antarmuka Java standar dan mendelegasikan panggilan metode ke koleksi basis Vavr. <br><br>  Pada saat penulisan ini, hanya tampilan <code>List</code> yang didukung.  Setiap kumpulan berurutan memiliki dua metode: satu untuk membuat representasi yang tidak dapat diubah, yang lain untuk bisa berubah. <br><br>  Metode panggilan untuk mengubah pada tampilan yang tidak berubah <code>UnsupportedOperationException</code> . <br><br>  Mari kita lihat sebuah contoh: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span>(expected = UnsupportedOperationException.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">givenVavrList_whenViewConverted_thenException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ java.util.List &lt; Integer &gt; javaList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .asJava(); assertEquals(<span class="hljs-number"><span class="hljs-number">3</span></span>, javaList.get(<span class="hljs-number"><span class="hljs-number">2</span></span>).intValue()); javaList.add(<span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre> <br>  Untuk membuat tampilan yang tidak berubah: <br><br><pre> <code class="java hljs">java.util.List &lt; Integer &gt; javaList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .asJavaMutable(); javaList.add(<span class="hljs-number"><span class="hljs-number">4</span></span>); assertEquals(<span class="hljs-number"><span class="hljs-number">4</span></span>, javaList.get(<span class="hljs-number"><span class="hljs-number">3</span></span>).intValue());</code> </pre> <br><h2>  8. Kesimpulan </h2><br>  Dalam tutorial ini, kami belajar tentang berbagai struktur data fungsional yang disediakan oleh Vavr Collections API.  Ada juga metode API yang bermanfaat dan produktif yang dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java doc</a> dan Panduan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengguna</a> Koleksi Vavr. <br><br>  Akhirnya, penting untuk dicatat bahwa pustaka juga mendefinisikan <code>Try</code> , <code>Option</code> , <code>Either</code> dan <code>Future</code> , yang memperluas antarmuka <code>Value</code> dan, sebagai hasilnya, mengimplementasikan antarmuka Java <code>Iterable</code> .  Ini berarti bahwa dalam beberapa situasi mereka dapat berperilaku seperti koleksi. <br><br>  Kode sumber lengkap untuk semua contoh dalam artikel ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> . <br><br>  Bahan tambahan: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/en/post/421839</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.baeldung.com/vavr</a> <br><br>  Diterjemahkan oleh <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@middle_java</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474402/">https://habr.com/ru/post/id474402/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474390/index.html">Acara digital di St. Petersburg dari 4 hingga 10 November</a></li>
<li><a href="../id474392/index.html">Instal CentOS 8 pada VDS 256</a></li>
<li><a href="../id474394/index.html">Menggunakan coroutine asli di Jawa</a></li>
<li><a href="../id474396/index.html">Dell akan mengumpulkan superkomputer industri paling kuat untuk industri minyak dalam sejarah</a></li>
<li><a href="../id474400/index.html">Mitos tentang ketersediaan kontras warna</a></li>
<li><a href="../id474404/index.html">Analisis masalah yang dipecahkan dari kejuaraan pemrograman dari Yandex (pengembangan front-end) 2019</a></li>
<li><a href="../id474406/index.html">Penampilan pertama BlueKeep di alam direkam</a></li>
<li><a href="../id474408/index.html">Revolusi atau evolusi Model Obyek Halaman?</a></li>
<li><a href="../id474414/index.html">Kami menulis mesin voxel kami sendiri</a></li>
<li><a href="../id474418/index.html">Konferensi DEFCON 27. Manfaat dari produk-produk peretas untuk macOS. Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>