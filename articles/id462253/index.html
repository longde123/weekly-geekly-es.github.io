<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕🏻 🎨 🍣 Eksperimen pertama menggunakan protokol streaming pada contoh CPU dan komunikasi prosesor di Redd FPGA 👷 🍌 👩🏾‍🤝‍👩🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel sebelumnya, kami sudah bertemu dengan bus Avalon-MM , di mana MM adalah singkatan dari Memory Mapped, yang diproyeksikan ke memori. Ban i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eksperimen pertama menggunakan protokol streaming pada contoh CPU dan komunikasi prosesor di Redd FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462253/"><img src="https://habrastorage.org/webt/hx/9r/u0/hx9ru01kpi9-x1z8jztv7uaemjm.jpeg"><br><br>  Pada artikel sebelumnya, kami sudah bertemu dengan bus <b>Avalon-MM</b> , di mana MM adalah singkatan dari Memory Mapped, yang diproyeksikan ke memori.  Ban ini cukup serbaguna.  Beberapa master (Master) dan beberapa perangkat slave dapat dihubungkan ke sana.  Kami sudah menghubungkan dua perangkat terkemuka sekaligus (Master Instruksi dan Data Master), karena prosesor NIOS II memiliki arsitektur Harvard, sehingga perintah dan bus data berbeda, tetapi banyak penulis menghubungkannya ke perangkat yang sama untuk menyederhanakan pengembangan perangkat lunak dari luar. ke bus. <br><br>  Jika sebuah blok di bus memiliki fungsi akses memori langsung (DMA), itu juga akan berisi master untuk bus. <br><br>  Sebenarnya, ketidaknyamanan utama ban ini didasarkan pada fakta ini (banyak pengikut terkemuka, banyak pengikut).  Ketika kami merancang budak kami, kami harus memecahkan kode alamatnya.  Ketika saya kebetulan menjadi pemimpin saya, ada lebih banyak keributan dengan arbitrasi.  Tetapi benang merah melalui seluruh seri artikel adalah pernyataan bahwa pengembangan untuk Redd adalah bagian tambahan dari proyek, seharusnya tidak memerlukan terlalu banyak pekerjaan.  Dan jika kita dapat membebaskan diri kita dari rutinitas, kita harus membebaskan diri dari itu. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/ns/cc/m1/nsccm1g4bldwl-4okgx-puukhyk.png"><br><br>  Semua artikel siklus: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd, dan debugging menggunakan tes memori sebagai contoh</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2. Kode program</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan intinya sendiri untuk ditanamkan dalam sistem prosesor berbasis FPGA</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan program untuk prosesor pusat Redd pada contoh akses ke FPGA</a> </li></ol><br>  Dokumen <b>Spesifikasi Antarmuka Avalon</b> sudah diketahui oleh kami (secara umum, saya tidak memberikan tautan langsung, karena selalu berubah, sehingga seluruh jaringan dipenuhi artikel dengan tautan mati, lebih mudah untuk menemukan posisi saat ini dengan mengarahkan nama ke mesin pencari) melaporkan bahwa selain bus <b>Avalon-MM</b> , ada juga bus <b>Avalon-ST</b> , di mana ST adalah singkatan dari Stream, yaitu streaming.  Faktanya adalah bahwa sangat sering data yang dikirimkan memiliki struktur aliran.  Ya, bahkan sektor klasik hard drive.  Ini memiliki ukuran tetap.  Itu harus diteruskan dari awal sampai akhir.  Bahkan jika kita mempertimbangkannya di area yang bisa dialamatkan, maka alamat akan meningkat secara linear.  Dan jika Anda menggunakan blok FIFO untuk penyimpanan, maka alamat di dalamnya sepenuhnya tersembunyi dari kami.  Memang, tapi bekerja dengan mereka bukan urusan kita. <br><br>  Hal yang sama berlaku untuk banyak data streaming lainnya: mereka selalu pergi dari awal hingga akhir, ditempatkan dalam repositori berurutan.  Inilah yang digunakan protokol streaming untuk mentransfer data tersebut.  Selain kurangnya pengalamatan eksplisit, bus <b>Avalon-ST</b> menarik karena selalu menghubungkan dua perangkat: sumber dan penerima.  Selalu ada dua dari mereka.  Satu perangkat selalu sumber, yang kedua selalu penerima.  Karena itu, masalah dengan arbitrase bus ini tidak menjadi perhatian.  Ini adalah pasangan perangkat yang terhubung ke bus ini: <br><br><img src="https://habrastorage.org/webt/z_/ix/tz/z_ixtzpnxmb0fhhyoxgsqnydhvc.png"><br><br>  Dan inilah sinyal khas dari bus ini: <br><br><img src="https://habrastorage.org/webt/ua/bh/ku/uabhkulgiofulvfomh0mw-mdz7g.png"><br><br>  Selain itu, garis <b>kesalahan</b> adalah opsional, mereka mengirimkan kode kesalahan biner yang diberikan oleh kami, dan kita dapat mengatakan bahwa tidak ada kode kesalahan.  Dan garis nomor saluran, seperti yang kita lihat di atas, diperlukan hanya jika demultiplex dilakukan lebih lanjut.  Jika tidak, nomor saluran tidak diperlukan.  Kami akan melakukannya tanpanya untuk saat ini.  Tiga baris tetap: pada kenyataannya, data, sinyal siap dan sinyal konfirmasi data (strobo).  Sinyal jam lain, karena bus itu sinkron. <br><br>  Dari dokumentasi itu juga berikut bahwa tiga sinyal lebih mungkin, menambah bus sifat transmisi paket yang jelas: <br><br><img src="https://habrastorage.org/webt/ix/wa/rc/ixwarc27-jx3cqndio3gzxaim_g.png"><br><br>  Secara umum, bannya sangat menarik, dan hari ini kita akan mulai bereksperimen dengannya.  Seperti yang telah kita ketahui, FPGA terhubung ke bus USB dari kompleks Redd melalui jembatan <b>FT2232H yang</b> beroperasi dalam mode <b>FT245-SYNC</b> .  Sebenarnya, data yang melewati antarmuka ini sepenuhnya streaming data.  Hari ini kita akan belajar bagaimana mentransfer data ini ke sistem prosesor kami berdasarkan NIOS II.  Sangat disayangkan bahwa protokol <b>FT245-SYNC</b> , meskipun streaming, tidak sepenuhnya mematuhi bus <b>Avalon-ST</b> .  Untuk menghemat kaki chip, ia memiliki bus data dua arah, dan bus <b>Avalon-ST</b> searah.  Jadi, kita harus membuat blok yang mengkoordinasikan tutup tetapi tidak cocok protokol. <br><br>  Kami sudah berkenalan dengan protokol <b>FT245-SYNC</b> di salah satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> .  Biarkan saya mengingatkan Anda bahwa deskripsinya dapat ditemukan di dokumen <b>AN_130 FT2232H Digunakan dalam Mode FIFO Sinkron Gaya FT245</b> .  Berikut ini adalah diagram waktu khas dari transmisi dari jembatan ke FPGA <br><br><img src="https://habrastorage.org/webt/ea/-y/ly/ea-ylyf7hie2zal-gfjzyp_ehwy.png"><br><br>  Secara umum, sebagai seorang programmer, saya sangat tertarik pada kenyataan bahwa paket yang dikirimkan akan ditandai dengan jelas mulai dan berakhir.  Nah, untuk membuatnya lebih logis dalam logika protokol UDP, karena jika transfer menggunakan gaya TCP, Anda harus menambahkan data benchmark khusus ke stream, yang akan dihabiskan untuk pemrograman, upaya, dan siklus prosesor ... Sepertinya garis RXF dapat membantu kami dengan ini.  Kami memeriksa ... Kami mengisi "firmware" di FPGA untuk mengukur kinerja, yang dibuat pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> , dan menghubungkan probe osiloskop ke jalur RXF.  Sebagai program uji untuk prosesor pusat Redd, kami menggunakan basis, juga digunakan untuk mengukur kinerja, alih-alih mengirim sejumlah besar data, kami mengirim blok monolitik 0x400 byte. <br><br><pre><code class="plaintext hljs">uint8_t temp [maxBlockSize]; memset (temp,0,sizeof (temp)); uint32_t dwWritten; FT_Write(ftHandle0, temp, 0x400, &amp;dwWritten);</code> </pre> <br>  Kami mendapatkan gambar berikut di jalur RXF: <br><br><img src="https://habrastorage.org/webt/0-/yc/ic/0-ycici6rpo4urdmg8nlvyuem3w.png"><br><br>  Jelas bahwa microcircuit menerima 0x200 byte buffer (yaitu berapa banyak yang bisa datang dalam satu paket USB2.0 HS), kemudian mengirimkannya ke saluran.  Secara umum, ini aneh, karena dokumentasi menyatakan bahwa dua buffer digunakan di setiap arah.  Selama transmisi, buffer kedua seharusnya memiliki waktu untuk diisi.  Sayang  Akhir pengisiannya jelas terlambat.  Sebenarnya, ini menunjukkan mengapa kinerja tidak mencapai teoritis 52 megabyte per detik: sebagian besar waktu (walaupun tidak 50%) tidak ditransmisikan. <br><br>  Tetapi dengan satu atau lain cara, dan kami menemukan bahwa mungkin untuk mendeteksi permulaan paket pada tepi RXF negatif hanya jika ukuran paket tidak melebihi 0x200 byte.  Jika kami hanya mengirim perintah dengan sejumlah kecil data ke perangkat, ini cukup dapat dicapai.  Tetapi jika kita mengirim aliran data yang besar, kita harus menggunakan saluran kontinu, serupa dalam logikanya dengan UART (atau, katakanlah, ke saluran TCP), dengan menyoroti batas-batas paket secara murni secara terprogram. <br><br>  Secara umum, untuk kesederhanaan presentasi, kami menggunakan versi streaming sebagai dasarnya.  Kami tidak akan mempertimbangkan paket hari ini.  Nah, versi bis <b>Avalon-ST yang</b> kami ambil sebagai dasar sudah jelas.  Kami mulai merancang blok kami.  Seperti disebutkan di atas, kita harus membuat tidak hanya jembatan, tetapi saklar, karena bus <b>FT245FIFO adalah</b> dua arah, dan bus <b>Avalon-ST</b> adalah searah.  Artinya, perlu membuat dua bus <b>Avalon-ST</b> sekaligus: output dan input. <br><br><img src="https://habrastorage.org/webt/hr/hl/fm/hrhlfm67sw8-xemukkwo47lg3va.png"><br><br>  Kami mulai perlahan mengembangkan otomat yang akan mengimplementasikan logika yang kita butuhkan.  Tentu saja, dalam artikel ini, logika ini akan disederhanakan secara maksimal.  Mari kita mulai dengan mentransfer data dari FPGA ke PC, karena proses ini sedikit lebih sederhana (Anda tidak perlu mengubah status jalur OE, yang telah kita bicarakan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terakhir</a> ).  Artinya, kami menerapkan port Sink. <br><br>  Dari sisi bus <b>Avalon-ST</b> , saya memilih mode operasi berikut (ada banyak sekali di dokumen, tapi yang ini paling dekat dengan antarmuka dengan <b>FT245-SYNC</b> ): <br><br><img src="https://habrastorage.org/webt/f_/rh/nm/f_rhnmctxwtl01xdlaiioun81jk.png"><br><br>  Biarkan saya mengingatkan Anda arah sinyal: <br><br><img src="https://habrastorage.org/webt/sd/cc/r-/sdccr--rw2vsk1xitskseckafiq.png"><br><br>  Artinya, kita tinggal menunggu konfirmasi pada bus ( <b>valid</b> ), klik pada data dan gerbang fakta ini dengan garis <b>ready</b> . <br><br>  Dari sisi <b>FT245_FIFO,</b> protokolnya terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/d-/nf/ki/d-nfkirvzei94d3kvkhntyea7pi.png"><br><br>  Ternyata kita harus menunggu sinyal TXE dan gerbang data dengan sinyal WR # (polaritasnya terbalik untuk kedua sinyal ini). <br><br>  TXE # sangat mirip fungsinya dengan <b>ready</b> , dan WR # <b>valid</b> .  Detailnya sedikit berbeda, tetapi logikanya serupa. <br><br>  Ternyata kita dapat memilih satu status tunggal toPC, di mana pergantian paling sederhana dari beberapa baris akan dilakukan.  Kondisi untuk memasuki kondisi ini adalah kesiapan kedua belah pihak untuk transmisi, yaitu (TXE # == 0) AND (valid == 1).  Segera setelah beberapa kesiapan hilang, kami keluar kembali ke siaga. <br><br>  Grafik transisi automaton masih sederhana: <br><br><img src="https://habrastorage.org/webt/ci/gb/j9/cigbj9hrioumzbnck6pyeevv1ia.png"><br><br>  Dan tabel switching adalah seperti ini (di mana nama-nama sinyalnya ambigu, indeks ditambahkan padanya, di mana namanya unik - tidak ada indeks): <br><br><div class="scrollable-table"><table><tbody><tr><th>  Sinyal </th><th>  Status ToPC </th><th>  Kondisi lainnya </th></tr><tr><td>  WR # </td><td>  TIDAK (validSink) </td><td>  1 </td></tr><tr><td>  readySink </td><td>  BUKAN (TXE #) </td><td>  0 </td></tr><tr><td>  DATAFT245_FIFO </td><td>  DataSink </td><td>  Z </td></tr></tbody></table></div><br><br>  Pindah ke transfer yang sedikit lebih kompleks dari Source ke FT245_FIFO.  Seperti yang kita lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di artikel sebelumnya</a> , komplikasinya adalah beralih arah dengan sinyal OE #: <br><br><img src="https://habrastorage.org/webt/al/xu/1-/alxu1-uqzen0dpj4n8bbgcruyck.png"><br><br>  Untuk bus <b>Avalon_ST,</b> semuanya sama seperti sebelumnya, sehingga gambar tidak ditampilkan untuk kedua kalinya, tetapi sekarang kita berada di posisi Sumber. <br><br>  Di sini, baris RXF # sesuai dengan baris yang <b>valid</b> , dan baris RD # sesuai dengan baris <b>siap</b> .  Baiklah, tambahkan beberapa status ke mesin: <br><br><img src="https://habrastorage.org/webt/pu/gs/fm/pugsfmp11c6b79fi8cwfud-wm-q.png"><br><br>  dan logika berikut untuk sinyal yang aktif di negara ini: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Sinyal </th><th>  jatuhkan </th><th>  dari PC </th><th>  Kondisi lainnya </th></tr><tr><td>  OE # </td><td>  0 </td><td>  0 </td><td>  1 </td></tr><tr><td>  RD # </td><td>  1 </td><td>  BUKAN (readySource) </td><td>  1 </td></tr><tr><td>  sumber data </td><td>  Nilai apa pun </td><td>  DATAFT245_FIFO </td><td>  Nilai apa pun </td></tr><tr><td>  sumber yang valid </td><td>  0 </td><td>  BUKAN (RXF #) </td><td>  0 </td></tr></tbody></table></div><br>  Jelas bahwa skema itu bukan yang paling ideal.  Ada berbagai nuansa yang terkait dengan buffer overruns atau underruns.  Tetapi tidak boleh ada kehilangan data apa pun, tetapi untuk optimalitas, Anda harus memulai suatu tempat! <br><br>  Kami mulai mentransfer teori yang dikembangkan ke kode SystemVerilog.  Benar, kami tidak dapat menggunakan semua fitur SystemVerilog.  Ada sebuah kasus, saya menulis sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel besar</a> , di mana saya menguji kemampuan praktis dari fitur yang indah dari bahasa ini dengan lingkungan pengembangan yang nyata.  Di sini kita hanya meminta penggunaan antarmuka, karena sistem akan memiliki dua contoh tipe <b>Avalon-ST</b> .  Alas dan ah.  Ini adalah kode tes: <br><pre> <code class="plaintext hljs">interface AvalonST #(parameter width=8)(input clk); logic [width-1:0] data; logic ready; logic valid; modport source (input clk, ready, output data,valid); modport sink (input clk, data, valid, output ready); endinterface module FT245toAvalonST ( AvalonST.source source, AvalonST.sink sink ); //assign source.ready = sink.valid; assign sink.ready = source.valid; endmodule</code> </pre><br>  Itu sempurna disintesis dalam kompiler utama (baris komentar ketika menghapus komentar memprovokasi kesalahan untuk memastikan bahwa synthesizer menginterpretasikan semuanya dengan benar), tetapi ketika memeriksa tombol <b>Menganalisis File Sintesis</b> untuk komponen untuk kode ini, kesalahan <b>dihasilkan</b> bahwa tipe <b>AvalonST tidak</b> diketahui.  Artinya, analisis tidak ada pada SystemVerilog, tetapi pada Verilog murni.  Sayang sekali. <br><br><img src="https://habrastorage.org/webt/4x/ju/ma/4xjumaitxzkw5tig_pdponziq38.png"><br><br>  Selain itu, bahasa ditentukan dengan benar, hanya alat analisa tidak mengerti antarmuka antar port. <br><br><img src="https://habrastorage.org/webt/tp/vm/gn/tpvmgnmidvtcb1e5ngfteokprpi.png"><br><br>  Secara umum, Anda harus menggunakan sintaks tua yang jelek. <br><br><div class="spoiler">  <b class="spoiler_title">Dengan sintaks ini kita mendapatkan antarmuka modul berikut:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module FT245toAvalonST ( input clk, input reset, inout [7:0] ft245_data, input logic ft245_rxf, input logic ft245_txe, output logic ft245_rd, output logic ft245_wr, output logic ft245_oe, output logic ft245_siwu, input logic source_ready, output logic source_valid, output logic[7:0] source_data, output logic sink_ready, input logic sink_valid, input logic[7:0] sink_data );</code> </pre><br></div></div><br>  Kasar, vintage, tetapi apa yang bisa Anda lakukan. <br><br><div class="spoiler">  <b class="spoiler_title">Kami menyadari grafik transisi otomat tanpa embel-embel:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">//    enum {idle, toPC, dropOE, fromPC} state = idle; //     always_ff @(posedge clk,posedge reset) begin if (reset == 1) begin state &lt;= idle; end else begin case (state) idle: begin if ((ft245_txe == 0) &amp;&amp; (sink_valid == 1)) state &lt;= toPC; else if ((ft245_rxf == 0)&amp;&amp;(source_ready == 1)) state &lt;= dropOE; end toPC: begin if (!((ft245_txe == 0) &amp;&amp; (sink_valid == 1))) state &lt;= idle; end dropOE: begin state &lt;= fromPC; end fromPC: begin if (!((ft245_rxf == 0)&amp;&amp;(source_ready == 1))) state &lt;= idle; end endcase end end</code> </pre><br></div></div><br>  Kontrol output, bagaimanapun, memerlukan beberapa penjelasan. <br><br><div class="spoiler">  <b class="spoiler_title">Bagian dari instalasi dilakukan "di dahi":</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">//    //   ,        , //  -    . always_comb begin ft245_oe &lt;= 1; ft245_rd &lt;= 1; ft245_wr &lt;= 1; source_valid &lt;= 0; sink_ready &lt;= 0; //     , //     assign- case (state) idle: begin end toPC: begin ft245_wr &lt;= !(sink_valid); sink_ready &lt;= !(ft245_txe); end dropOE: begin ft245_oe &lt;= 0; end fromPC: begin ft245_oe &lt;= 0; ft245_rd &lt;= !(source_ready); source_valid &lt;= !(ft245_rxf); end endcase end</code> </pre><br></div></div><br>  Tetapi, katakanlah, untuk bus data dua arah, solusi tipikal harus diterapkan.  Seperti yang kita ingat, itu dinyatakan di bagian antarmuka sebagai berikut: <br><br><pre> <code class="plaintext hljs"> inout [7:0] ft245_data,</code> </pre><br>  dan membaca darinya bisa dilakukan dengan cara biasa.  Untuk kasus kami, kami cukup membungkus semua data pada data bus <b>Avalon-ST yang</b> keluar: <br><br><pre> <code class="plaintext hljs">//          assign source_data = ft245_data;</code> </pre><br>  Tetapi secara umum, Anda selalu dapat membaca dari bus dan dengan cara apa pun yang Anda suka.  Tetapi Anda harus menulis untuk itu menggunakan multiplexer.  Ketika kami menulis data ke bus, data ini harus berasal dari bus lain yang sudah disiapkan sebelumnya.  Biasanya, variabel tipe <b>reg</b> (atau <b>logika</b> bermodel) <b>berakhir</b> di modul.  Dalam kasus kami, bus semacam itu sudah ada.  Ini adalah bus <b>sink_data</b> .  Dalam kasus lain, negara Z adalah output. Jika Anda terbiasa dengan sirkuit, Anda sangat menyadari buffer output khas.  Entah melewatkan data input apa pun, atau masuk ke Z-state.  Dalam kode kami, multiplexer ini terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">//      inout- assign ft245_data = (state == toPC) ? sink_data : 8'hzz;</code> </pre><br>  Dan ft245_siwu sinyal lain.  Kami tidak pernah menggunakannya, jadi menurut dokumentasi di FT2232H, tarik ke persatuan: <br><br><pre> <code class="plaintext hljs">//   FTDI : // Tie this pin to VCCIO if not used. assign ft245_siwu = 1;</code> </pre><br>  Sebenarnya itu saja. <br><br><div class="spoiler">  <b class="spoiler_title">Seluruh modul terlihat seperti ini:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module FT245toAvalonST ( input clk, input reset, inout [7:0] ft245_data, input logic ft245_rxf, input logic ft245_txe, output logic ft245_rd, output logic ft245_wr, output logic ft245_oe, output logic ft245_siwu, input logic source_ready, output logic source_valid, output logic[7:0] source_data, output logic sink_ready, input logic sink_valid, input logic[7:0] sink_data ); //    enum {idle, toPC, dropOE, fromPC} state = idle; //     always_ff @(posedge clk,posedge reset) begin if (reset == 1) begin state &lt;= idle; end else begin case (state) idle: begin if ((ft245_txe == 0) &amp;&amp; (sink_valid == 1)) state &lt;= toPC; else if ((ft245_rxf == 0)&amp;&amp;(source_ready == 1)) state &lt;= dropOE; end toPC: begin if (!((ft245_txe == 0) &amp;&amp; (sink_valid == 1))) state &lt;= idle; end dropOE: begin state &lt;= fromPC; end fromPC: begin if (!((ft245_rxf == 0)&amp;&amp;(source_ready == 1))) state &lt;= idle; end endcase end end //    //   ,        , //  -    . always_comb begin ft245_oe &lt;= 1; ft245_rd &lt;= 1; ft245_wr &lt;= 1; source_valid &lt;= 0; sink_ready &lt;= 0; //     , //     assign- case (state) idle: begin end toPC: begin ft245_wr &lt;= !(sink_valid); sink_ready &lt;= !(ft245_txe); end dropOE: begin ft245_oe &lt;= 0; end fromPC: begin ft245_oe &lt;= 0; ft245_rd &lt;= !(source_ready); source_valid &lt;= !(ft245_rxf); end endcase end // -  c  ,   ... //   FTDI : // Tie this pin to VCCIO if not used. assign ft245_siwu = 1; //      inout- assign ft245_data = (state == toPC) ? sink_data : 8'hzz; //          assign source_data = ft245_data; endmodule</code> </pre><br></div></div><br>  Cara memasukkan modul dalam daftar yang tersedia untuk digunakan dalam sistem prosesor, kami memeriksa secara rinci di salah satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> , jadi saya hanya menunjukkan hasilnya pada gambar.  Saya ingat bahwa untuk mencapainya, saya harus menambahkan dua bus <b>AVALON-ST</b> , satu bus <b>Conduit</b> , menarik sinyal dari bus <b>AVALON-MM yang</b> didefinisikan secara keliru, dan ketika tidak ada satu sinyal pun yang tersisa di bus itu, hapus saja.  Sepanjang jalan, gambar menunjukkan pengaturan yang saya pilih untuk bus <b>AVALON-ST</b> (8 bit per simbol, tidak ada kesalahan, saluran maksimum adalah nol, latensi adalah nol). <br><br><img src="https://habrastorage.org/webt/-v/9t/ml/-v9tmldj2eyv4rsv8lb3reokzoa.png"><br><br>  Dengan pengembangan modul untuk docking ban - itu saja.  Tapi sayang sekali, ah.  Berkembang hanyalah awal dari pekerjaan.  Implementasi jauh lebih sulit.  Seperti yang bisa dilihat dari posisi scroller di layar, akhir artikel masih jauh.  Jadi, kami mulai membuat proyek sederhana yang menggunakan bus <b>FT245-SYNC</b> bersama dengan bus <b>AVALON-ST</b> .  Itu yang paling sederhana.  Sebuah proyek serius tidak cocok dengan kerangka kerja satu artikel dengan ukuran yang masuk akal.  Saya sekarang akan membuat penyederhanaan setelah penyederhanaan hanya agar perhatian pembaca cukup untuk sisa teks sehingga mereka tidak berhenti membaca dalam sepatah kata pun.  Penyederhanaan pertama adalah bahwa 60 MHz <b>clock</b> untuk <b>FT245_SYNC</b> dihasilkan oleh chip <b>FT2232H itu sendiri</b> .  Saya bisa menambahkan dua garis jam ke sistem, tetapi begitu semua orang melihatnya, kita akan memiliki jaring laba-laba sedemikian rupa sehingga ibu saya tidak berduka.  Jika saya masih memperhatikan garis jam yang berbeda, kita semua akan bingung.  Oleh karena itu, saya hanya mengumumkan bahwa hari ini sistem prosesor kami akan clock dari chip <b>FT2232H</b> , dan bukan dari generator biasa. <br><br>  Kenapa kamu tidak bisa selalu melakukan itu?  Sangat sederhana: selama <b>FT2232H</b> tidak dalam mode 245_SYNC, ia tidak memiliki pulsa ini pada output.  Artinya, Anda harus terlebih dahulu menjalankan program untuk prosesor sentral, dan hanya kemudian memuat semuanya ke dalam FPGA.  Jika kita membuat sistem untuk pelanggan eksternal, solusi seperti itu akan menciptakan banyak masalah.  Saya tahu dari pengalaman bahwa mereka akan secara teratur menghubungi kami dan mengatakan bahwa tidak ada yang berhasil, kami akan mengingatkan tentang bar, tetapi itu akan membantu untuk sementara waktu.  Tetapi kami sedang melakukan hal internal, dan kami hanya akan menggunakannya dalam kondisi laboratorium.  Artinya, dalam kerangka tugas ini, ini diizinkan. <br><br>  Tapi ini membawa tantangan baru.  Kami memiliki frekuensi 60 MHz, dan blok jam SDRAM yang saat ini kami gunakan terkait erat dengan frekuensi 50 MHz.  Ya, saya telah memeriksa, 60 dapat dikirimkan, tetapi mari kita berpura-pura bahwa kita mencoba untuk tidak melampaui mode yang diizinkan.  Dalam artikel selanjutnya saya akan mencoba menunjukkan bagaimana cara mengganti blok keras ini, tetapi hari ini kami hanya mengatakan bahwa karena unit jam kami dari SDRAM tidak dapat bekerja pada frekuensi yang digunakan, kami mengecualikannya dari sistem prosesor SDRAM.  Program dan datanya akan sepenuhnya terletak di memori internal FPGA.  Secara eksperimental ditemukan bahwa dalam konfigurasi hari ini, FPGA dapat mengambil maksimum 28 kilobyte RAM untuk bisnis ini.  Ternyata Anda dapat mengambil volume dan bukan kekuatan ganda dari dua ... <br><br>  Selain itu, kami akan menggunakan jam standar dan unit reset.  Ini diatur ulang sedikit berbeda dari yang kami gunakan untuk SDRAM.  Agar tidak menyulitkan artikel, saya akan mengambil keuntungan dari kenyataan bahwa sistem yang sedang dikembangkan akan selalu bekerja di bawah kendali debugger, jadi saya akan memulai reset dari subsistem JTAG untuk debugging. <br><br>  Secara total, kami mendapatkan sketsa sistem prosesor basis (garis Reset paling sulit disorot saat ini, penanda biru ada pada sumber sinyal): <br><br><img src="https://habrastorage.org/webt/zx/ug/nk/zxugnk3v9rhownqtdorprzuvqc8.png"><br><br>  di mana frekuensi telah disesuaikan untuk jam dan setel ulang blok: <br><br><img src="https://habrastorage.org/webt/dj/hq/ap/djhqapk0jpgumyp0qrp34ucszhw.png"><br><br>  dan untuk RAM - volumenya: <br><br><img src="https://habrastorage.org/webt/pm/k2/vn/pmk2vngq6jhbl3yhydiarxcsm2i.png"><br><br>  Hari ini kita perlu menampilkan teks di terminal.  Karena itu, kami akan menambahkan blok yang menarik ke sistem: <br><br><img src="https://habrastorage.org/webt/9q/nx/r-/9qnxr-5owicrjxhlqmkeckfxxn8.png"><br><br>  Dengan blok ini, kita akan dapat memanggil fungsi yang mirip dengan printf.  Selain bus AVALON_MM, itu juga harus menghubungkan output permintaan interupsi. <br><br><img src="https://habrastorage.org/webt/gp/h6/rg/gph6rg59lvarzmtdeaq9wvsiohu.png"><br><br>  Itu saja, pengadaan untuk sistem prosesor selesai.  Saatnya menanamkan unit kami.  Di mana dia akan mengirim data?  Di antara blok yang tersedia untuk kita, ada memori FIFO dua port yang sangat menarik.  Pesonanya terletak pada kenyataan bahwa satu port dapat dikonfigurasi ke mode <b>AVALON-ST</b> dan menghubungkannya ke unit kami, dan yang kedua ke mode <b>AVALON_MM</b> dan bekerja dengannya menggunakan prosesor NIOS II.  Blok indah ini terletak di sini: <br><br><img src="https://habrastorage.org/webt/fe/9o/ur/fe9ourutodpbj31wm9av_-pkfc4.png"><br><br>  Kami memiliki dua <b>bus Avalon-ST</b> (satu untuk membaca, yang lain untuk menulis), jadi kami juga membutuhkan dua blok FIFO.  Sekarang saya akan membahas salah satu dari mereka dengan sangat terperinci, kami memutar beberapa kilometer web (dan banyak layar teks dengan gambar), dan tentang yang kedua kami mengatakan bahwa "itu dapat dilakukan dengan analogi", hanya menunjukkan perbedaan.  Karena itu, untuk saat ini, kami hanya menambahkan satu blok ke sistem dan melihat-lihat pengaturannya.  Ada banyak pengaturan.  Adalah mungkin untuk hanya menunjukkan nilai-nilai yang diperlukan sehingga semua orang merujuk ke artikel sebagai referensi, tetapi tiba-tiba seseorang masuk ke situasi yang perlu dikonfigurasi, tetapi tidak ada akses ke jaringan (dan, karena itu, artikel).  Oleh karena itu, saya akan menambahkan pengaturan secara iteratif.  Pertama jelas, kemudian - sesuai tuntutan sistem, jalankan melalui dialog lagi dan lagi.  Jadi setiap orang akan merasakan prosesnya dan akan dapat mengulanginya kapan saja.  Jadi  Secara default, kami diberi pengaturan berikut: <br><br><img src="https://habrastorage.org/webt/yl/bt/14/ylbt14u32cw8xeqherwazdx8nx4.png"><br><br>  Sekarang saya akan melakukan FIFO, yang mengumpulkan data dari <b>Avalon-ST</b> , dan mengunggahnya ke <b>Avalon-MM</b> .  Ternyata hasil edit pertama akan seperti ini: <br><br><img src="https://habrastorage.org/webt/1w/m0/xx/1wm0xx_bdp9gjk9nqmb6sooxop0.png"><br><br>  Saya mendapat peringatan yang menarik ini: <br><br><img src="https://habrastorage.org/webt/1u/a8/qs/1ua8qsawychkqv0nxjg_l5u3f4q.png"><br><br>  Ternyata ketika setidaknya satu port diproyeksikan ke memori, lebar bus <b>Avalon-ST</b> harus benar-benar 32 bit.  Dan kami memiliki bus 8-bit.  Bagaimana menyepakati kedalaman bit, saya akan memberi tahu Anda sedikit lebih rendah, tetapi untuk sekarang kami melakukan bus 32-bit dengan karakter delapan-bit di sini.  Nah, nonaktifkan mode batch, seperti yang diputuskan di bagian teoretis. <br><br><img src="https://habrastorage.org/webt/oi/jh/k0/oijhk02tjofxdavtznc1m1es8w4.png"><br><br>  Berikutnya adalah kapasitas.  Misalkan saya mengantri 256 kata (mis., 1024 byte): <br><br><img src="https://habrastorage.org/webt/s4/ca/vl/s4cavlmtxomzl0gsc2dfwn2ovmg.png"><br><br>  Sekarang statusnya.  Pada awalnya, saya tidak mementingkan itu, dan saya membekukan program dengan ketat.  Jadi sekarang saya tahu status itu diperlukan.  Karena kami akan bekerja dengan port keluaran secara terprogram, kami menambahkan status untuk itu. <br><br><img src="https://habrastorage.org/webt/0_/hc/hp/0_hchpmkhfrlg8pg3tjaqg3vpsi.png"><br><br>  dan tangkap kesalahan: <br><br><img src="https://habrastorage.org/webt/xk/e7/lg/xke7lgan6dpoohxssnvglenuhog.png"><br><br>  Baiklah kalau begitu.  Tambahkan pencatatan jam kerja ganda.  Cukup sambungkan kedua input ke saluran jam yang sama, karena kami memiliki satu. <br>  Uhhhh  Total yang kami miliki: <br><br><img src="https://habrastorage.org/webt/iv/nv/pv/ivnvpvdfov3zeo6owfevsdhrq6k.png"><br><br>  Tetapi masih terlalu dini untuk menghubungkan bisnis ini ke sistem umum.  Seperti yang kami <b>ketahui,</b> bus <b>Avalon-ST</b> 8-bit meninggalkan blok yang kami kembangkan, dan ini harus termasuk yang 32-bit.  Bagaimana kita?  Merombak blok Anda?  Tidak!  Semuanya sudah dilakukan sebelum kita.  Inilah yang akan membantu kami: <br><br><img src="https://habrastorage.org/webt/3g/2j/q7/3g2jq74qwjbcgmnvhdchryqi9xm.png"><br><br>  Tambahkan ke sistem.  Selain itu, karena ini adalah lapisan, murni untuk kecantikan, kami menempatkannya di antara blok kami dan FIFO, menggunakan panah yang sesuai: <br><br><img src="https://habrastorage.org/webt/lt/pd/9q/ltpd9qytvl60ez2znbxu1qsudyq.png"><br><br>  Kami melakukan pengaturan berikut: pada input kami memiliki bus 8-bit, pada output 32-bit.  Sinyal paket tidak digunakan, sinyal <b>siap</b> dan <b>valid</b> digunakan. <br><br><img src="https://habrastorage.org/webt/bo/-e/h1/bo-eh154mbqqyr0owj9vn96his8.png"><br><br>  Saatnya menenun web.  Pertama, saya akan meletakkan garis streaming (pada gambar keduanya disorot, penanda ada pada penerima data): <br><br><img src="https://habrastorage.org/webt/br/xu/uj/brxuujnbnsiazm3pxfnnr3tb-cc.png"><br><br>  Artinya, sinyal dari Sumber blok kami menuju ke input adaptor.  Dan dari output adaptor ke input FIFO.  Seperti yang saya katakan, semua koneksi dalam protokol streaming berjalan secara point-to-point. <br>  Nah, sekarang kita menggantung garis reset, garis jam, dan juga menghubungkan semuanya ke bus sistem dan untuk mengganggu ... <br><br><img src="https://habrastorage.org/webt/dc/tj/1g/dctj1gqgwbbs7-pcdf4urfbhvsy.png"><br><br>  Yah ... Dan sekarang, dengan prinsip yang sama, kami menambahkan FIFO untuk mengeluarkan data ke <b>FT245SYNC</b> .  Hanya di sana, data masuk ke FIFO dari <b>Avalon-MM</b> dalam bentuk 32-bit.  Mereka melewati adaptor 32-in-8 dan kemudian mendapatkan input SINK dari blok kami, yang tidak terhubung di sirkuit saat ini ... Kami mendapatkan bagian berikut dari rangkaian terakhir (memori di sana ternyata dengan satu jam): <br><br><img src="https://habrastorage.org/webt/eg/e5/kc/ege5kckjc4x5vwtsfaxmlp32rqo.png"><br><br>  Formalitas lebih lanjut yang telah kami lakukan dengan baik dalam percobaan yang dijelaskan dalam artikel sebelumnya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebagian besar - di sini</a> ).  Kami menetapkan vektor ke prosesor.  Untuk sistem, kami menyebut penetapan angka dan alamat interupsi secara otomatis.  Kami menyimpan sistem ... Semua orang ingat bahwa nama sistem yang disimpan harus cocok dengan nama proyek sehingga sistem berada di tingkat atas hierarki?  Tambahkan sistem ke proyek, buat konsep kasar proyek, tetapkan kaki.  Secara pribadi, saya curang: Saya menyalin tugas dari file * .qsf dari proyek draft ke proyek finishing saat ini (dan Anda dapat mengambil proyek saya dan menyalin baris * .qsf yang sesuai dengan Anda, tetapi Anda dapat dengan mudah menetapkan semua kaki melalui GUI).  Saya menaruh perhatian khusus pada fakta bahwa sinyal CLK terhubung ke leg 23, bukan 25, seperti dalam proyek-proyek sebelumnya.  Saya mengingatkan Anda bahwa di sini kita berdetak dari output FT2232. <br><br><img src="https://habrastorage.org/webt/9z/bx/sb/9zbxsbgsn4m_9wewmjestkse0fi.png"><br><br>  Hebat!  Perangkat keras sudah siap.  Kami lolos ke perangkat lunak.  Di mana kita mulai?  Hari ini pertanyaan ini tidak sepadan.  Jika kita mulai dengan program yang berjalan pada prosesor NIOS II, tidak ada yang berhasil bagi kita.  Pertama, kita harus meletakkan FT2232 ke mode 245-SYNC, hanya kemudian sistem prosesor kami akan menerima pulsa clock.  Oleh karena itu, kita mulai dengan kode untuk prosesor pusat. <br><br><div class="spoiler">  <b class="spoiler_title">Kami mendapatkan sesuatu seperti ini:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;sys/time.h&gt; #include &lt;unistd.h&gt; #include "ftd2xx.h" FT_HANDLE OpenFT2232H() { FT_HANDLE ftHandle0; static FT_DEVICE ftDevice; //      int nDevice = 0; while (true) { //     if (FT_Open(nDevice, &amp;ftHandle0) != FT_OK) { printf("No FT2232 found\n"); //  ,      return 0; } //     ? if (FT_GetDeviceInfo(ftHandle0, &amp;ftDevice, NULL, NULL, NULL, NULL) == FT_OK) { // ,    if (ftDevice == FT_DEVICE_2232H) { // ,     AN130 FT_SetBitMode(ftHandle0, 0xff, 0x00); usleep(1000000); //Sync FIFO mode FT_SetBitMode(ftHandle0, 0xff, 0x40); FT_SetLatencyTimer(ftHandle0, 2); FT_SetUSBParameters(ftHandle0, 0x10000, 0x10000); return ftHandle0; } } //    FT_Close(ftHandle0); //    nDevice += 1; } printf("No FT2232 found\n"); } int main() { FT_HANDLE ftHandle0 = OpenFT2232H(); if (ftHandle0 == 0) { printf("Cannot open device\n"); return -1; } int item; bool bWork = true; while (bWork) { printf("1 - Send 16 bytes\n"); printf("2 - Send 256 bytes\n"); printf("3 - Receive loop\n"); printf("0 - Exit\n"); scanf("%d", &amp;item); switch (item) { case 0: bWork = false; break; case 1: { static const unsigned char data[0x10] = { 0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f }; DWORD dwWritten; FT_Write(ftHandle0, (void*)data, sizeof(data), &amp;dwWritten); } break; case 2: { unsigned char data[0x100]; for (size_t i = 0; i &lt; sizeof(data); i++) { data[i] = (unsigned char)i; } DWORD dwWritten; FT_Write(ftHandle0, (void*)data, sizeof(data), &amp;dwWritten); } break; case 3: { DWORD dwRxBytes; DWORD dwRead; DWORD buf[0x100]; while (true) { FT_GetQueueStatus(ftHandle0, &amp;dwRxBytes); if (dwRxBytes != 0) { printf("Received %d bytes (%d DWORDs)\n", dwRxBytes, dwRxBytes / sizeof(buf[0])); if (dwRxBytes &gt; sizeof(buf)) { dwRxBytes = sizeof(buf); } FT_Read(ftHandle0, buf, dwRxBytes, &amp;dwRead); for (DWORD i = 0; i &lt; dwRxBytes / sizeof(buf[0]);i++) { printf("0x%X, ",buf[i]); } printf("\n"); } } } break; } } // ,    FT_Close(ftHandle0); return 0; }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenFT2232H () tidak</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> asing bagi kita dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel terakhir</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dialah yang membuka perangkat FT2232 dan menempatkannya dalam mode yang kita butuhkan. Segera setelah peluncuran program yang sukses, kami mendapatkan pulsa clock, dan dengan mereka kemampuan untuk debug program untuk NIOS II. Nah, fungsi dari fungsi utama sesederhana bangku. Kirim beberapa data (1), kirim banyak data (2), terima data (3). Harap dicatat bahwa semua data dikirim dalam blok yang kelipatan empat byte. Ini semua karena kami memiliki adaptor 8-in-32. Di pintu keluar dari itu, data harus dalam kata-kata ganda. Kalau tidak, semuanya jelas.</font></font><br><br>     NIOS II      BSP. ,        Hello World Small.    BSP       (        BSP,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ). ,     ,  ,  Settings,       . <br><br><img src="https://habrastorage.org/webt/lc/mg/jh/lcmgjhu3udg8njitretcj5wp4vm.png"><br><br>  Generate BSP ,    ,     <b>hello_world_small.c</b>  <b>hello_world_small.cpp</b> ,     ,         . <br><br>        (         ,   FIFO,    —   ,    ,        ).         .   —        NIOS II.      : <br><br><pre> <code class="plaintext hljs">extern "C" { #include "sys/alt_stdio.h" #include &lt;system.h&gt; #include &lt;altera_avalon_fifo_util.h&gt; } #include &lt;stdint.h&gt; int main() { while (1) { int level = IORD_ALTERA_AVALON_FIFO_LEVEL(FIFO_0_OUT_CSR_BASE); if (level != 0) { alt_printf("0x%x words received:\n",level); for (int i=0;i&lt;level;i++) { alt_printf("0x%x,",IORD_ALTERA_AVALON_FIFO_DATA (FIFO_0_OUT_BASE)); } alt_printf("\n"); } } /* Event loop never exits. */ while (1); return 0; }</code> </pre><br>       FIFO.    ,  . <br>   .    ,    .    Redd   «» ,        NIOS II.   : <br><br><img src="https://habrastorage.org/webt/88/1c/xk/881cxkj95xirw_0rdrrhyaf0ffm.png"><br><br>      ,        .    ,    .   ,     ,      .        FT2232,      ,       .            .      :      <b>FT245-SYNC</b> . <br><br>       1.    ,    : <br><br> <b>0x2 words received: <br> 0x3020100,0x7060504, <br> 0x2 words received: <br> 0xb0a0908,0xf0e0d0c,</b> <br><br> : <br><br> <b>0x3 words received: <br> 0x3020100,0x7060504,0xb0a0908, <br> 0x1 words received: <br> 0xf0e0d0c,</b> <br><br>  ,    1,  3  ,      .    ,      ,      .     ,          ,      JTAG —   .       ,          .   ,   (  ,   ?    ),    (FIFO —   ,         ,         ). <br><br>         Little Endian. ,    : <br><br><pre> <code class="plaintext hljs">static const unsigned char data[0x10] = { 0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f };</code> </pre><br>  Benar juga.         2,    (  ,     ): <br><br><pre> <code class="plaintext hljs">0x3 words received: 0x3020100,0x7060504,0xb0a0908, 0x3d words received: 0xf0e0d0c, 0x13121110,0x17161514,0x1b1a1918,0x1f1e1d1c, 0x23222120,0x27262524,0x2b2a2928,0x2f2e2d2c, 0x33323130,0x37363534,0x3b3a3938,0x3f3e3d3c, 0x43424140,0x47464544,0x4b4a4948,0x4f4e4d4c, 0x53525150,0x57565554,0x5b5a5958,0x5f5e5d5c, 0x63626160,0x67666564,0x6b6a6968,0x6f6e6d6c, 0x73727170,0x77767574,0x7b7a7978,0x7f7e7d7c, 0x83828180,0x87868584,0x8b8a8988,0x8f8e8d8c, 0x93929190,0x97969594,0x9b9a9998,0x9f9e9d9c, 0xa3a2a1a0,0xa7a6a5a4,0xabaaa9a8,0xafaeadac, 0xb3b2b1b0,0xb7b6b5b4,0xbbbab9b8,0xbfbebdbc, 0xc3c2c1c0,0xc7c6c5c4,0xcbcac9c8,0xcfcecdcc, 0xd3d2d1d0,0xd7d6d5d4,0xdbdad9d8,0xdfdedddc, 0xe3e2e1e0,0xe7e6e5e4,0xebeae9e8,0xefeeedec, 0xf3f2f1f0,0xf7f6f5f4,0xfbfaf9f8,0xfffefdfc,</code> </pre><br>   .     .    NIOS II  : <br><br><pre> <code class="plaintext hljs"> /*  -  2 */ uint32_t buf[] = {0x11223344,0x55667788,0x99aabbcc,0xddeeff00}; for (uint32_t i=0;i&lt;sizeof(buf)/sizeof(buf[0]);i++) { IOWR_ALTERA_AVALON_FIFO_DATA (FIFO_1_IN_BASE,buf[i]); }</code> </pre><br>        3       NIOS II. : <br><br> <b>Received 16 bytes (4 DWORDs) <br><br> 0x11223344, 0x55667788, 0x99AABBCC, 0xDDEEFF00,</b> <br><br>    .    -   . <br><br><h3>  Kesimpulan </h3><br>        <b>Avalon-ST</b> .        Redd   ,   .           .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br>           .     ,          ,    Redd. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462253/">https://habr.com/ru/post/id462253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462221/index.html">Betapa kecewanya saya di Google Play</a></li>
<li><a href="../id462227/index.html">Moskow, 9 Agustus - Cerita Backend 4.0</a></li>
<li><a href="../id462243/index.html">Meningkatkan Kinerja Front-end Magento Dengan ReactJS</a></li>
<li><a href="../id462245/index.html">auto git membagi dua sebagai contoh dari kernel Linux</a></li>
<li><a href="../id462251/index.html">Apakah mode penyamaran di browser adalah fiksi?</a></li>
<li><a href="../id462257/index.html">Kafka di Kubernetes - apakah itu bagus?</a></li>
<li><a href="../id462259/index.html">Membuat pengontrol untuk rumah pintar</a></li>
<li><a href="../id462263/index.html">Pedal ke lantai: buat manipulator kaki lain untuk PC</a></li>
<li><a href="../id462265/index.html">Python dan kubus</a></li>
<li><a href="../id462267/index.html">Mengenal Penganalisis Statis PVS-Studio untuk Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>