<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüé® ‚úçüèæ üöÄ 9 tips untuk menggunakan perpustakaan Kucing di Scala ‚ò£Ô∏è üç∏ üåé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pemrograman fungsional dalam Scala mungkin sulit untuk dikuasai karena beberapa fitur sintaksis dan semantik bahasa. Secara khusus, beberapa alat baha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>9 tips untuk menggunakan perpustakaan Kucing di Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/448128/">  Pemrograman fungsional dalam Scala mungkin sulit untuk dikuasai karena beberapa fitur sintaksis dan semantik bahasa.  Secara khusus, beberapa alat bahasa dan cara untuk mengimplementasikan apa yang Anda rencanakan dengan bantuan perpustakaan utama tampak jelas ketika Anda terbiasa dengan mereka - tetapi pada awal belajar, terutama pada Anda sendiri, tidak begitu mudah untuk mengenali mereka. <br><br>  Untuk alasan ini, saya memutuskan akan berguna untuk berbagi beberapa tips pemrograman fungsional di Scala.  Contoh dan nama sesuai dengan kucing, tetapi sintaksis dalam scalaz harus sama karena dasar teoretis umum. <br><br><img src="https://habrastorage.org/webt/wf/n0/92/wfn0925sgvde-jv71ogsic_xuwk.jpeg"><br><a name="habracut"></a><br><h3>  <b>9) Konstruktor metode ekstensi</b> </h3><br>  Mari kita mulai dengan, mungkin, alat paling dasar - metode ekstensi dari jenis apa pun yang mengubah instance menjadi Option, Either, dll., Khususnya: <br><br><ul><li> <code>.some</code> dan <code>none</code> metode konstruktor yang sesuai untuk <code>Option</code> ; </li><li>  <code>.asRight</code> , <code>.asLeft</code> for <code>Either</code> ; </li><li>  <code>.valid</code> , <code>.invalid</code> , <code>.validNel</code> , <code>.invalidNel</code> untuk <code>Validated</code> </li></ul><br>  Dua keuntungan utama penggunaannya: <br><br><ol><li>  Ini lebih ringkas dan mudah dimengerti (karena urutan pemanggilan metode disimpan). </li><li>  Tidak seperti opsi konstruktor, tipe kembalinya metode ini diperluas ke supertype, yaitu: </li></ol><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-string"><span class="hljs-string">"a"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//Some[String] "a".some //Option[String]</span></span></code> </pre> <br>  Meskipun inferensi tipe telah meningkat selama bertahun-tahun, dan jumlah situasi yang memungkinkan perilaku ini membantu programmer untuk tetap tenang telah menurun, kesalahan kompilasi karena pengetikan yang terlalu khusus masih dimungkinkan di Scala hari ini.  Cukup sering, keinginan untuk membenturkan kepala ke meja muncul ketika bekerja dengan salah <code>Either</code> (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>Scala dengan Kucing</u></a> bab 4.4.2). <br><br>  Satu hal lagi pada topik: <code>.asRight</code> dan <code>.asLeft</code> masih memiliki satu parameter tipe lagi.  Misalnya, <code>"1".asRight[Int]</code> adalah <code>Either[Int, String]</code> .  Jika parameter ini tidak disediakan, kompiler akan mencoba untuk mengeluarkannya dan tidak mendapatkan <code>Nothing</code> .  Namun demikian, ini lebih nyaman daripada memberikan kedua parameter setiap kali atau tidak menyediakan, seperti dalam kasus konstruktor. <br><br><h3>  <b>8) Lima puluh warna *&gt;</b> </h3><br>  Operator *&gt; yang didefinisikan dalam setiap metode <code>Apply</code> (yaitu, dalam <code>Applicative</code> , <code>Monad</code> , dll.) Secara sederhana berarti "memproses perhitungan awal dan mengganti hasilnya dengan apa yang ditentukan dalam argumen kedua".  Dalam bahasa kode (dalam kasus <code>Monad</code> ): <br><br><pre> <code class="scala hljs">fa.flatMap(_ =&gt; fb)</code> </pre> <br>  Mengapa menggunakan operator simbolis yang tidak jelas untuk operasi yang tidak memiliki efek nyata?  Mulai menggunakan ApplicativeError dan / atau MonadError, Anda akan menemukan bahwa operasi mempertahankan efek kesalahan untuk seluruh alur kerja.  Ambil <code>Either</code> sebagai contoh: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> success1 = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.asRight[<span class="hljs-type"><span class="hljs-type">Int</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> success2 = <span class="hljs-string"><span class="hljs-string">"b"</span></span>.asRight[<span class="hljs-type"><span class="hljs-type">Int</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> failure = <span class="hljs-number"><span class="hljs-number">400.</span></span>asLeft[<span class="hljs-type"><span class="hljs-type">String</span></span>] success1 *&gt; success2 <span class="hljs-comment"><span class="hljs-comment">//Right(b) success2 *&gt; success1 //Right(a) success1 *&gt; failure //Left(400) failure *&gt; success1 //Left(400)</span></span></code> </pre> <br>  Seperti yang Anda lihat, bahkan jika terjadi kesalahan, perhitungannya tetap pendek.  *&gt; akan membantu Anda dengan pekerjaan dengan perhitungan yang ditangguhkan dalam <code>Monix</code> , <code>IO</code> dan sejenisnya. <br><br>  Ada operasi simetris, &lt;*.  Jadi, dalam kasus contoh sebelumnya: <br><br><pre> <code class="scala hljs">success1 &lt;* success2 <span class="hljs-comment"><span class="hljs-comment">//Right(a)</span></span></code> </pre> <br>  Akhirnya, jika penggunaan simbol adalah asing bagi Anda, tidak perlu menggunakan itu.  *&gt; Hanya alias untuk <code>productR</code> , dan * &lt;adalah alias untuk <code>productL</code> . <br><br><h3>  <b>Catatan</b> </h3><br>  Dalam percakapan pribadi, Adam Warski (terima kasih, Adam!) Dengan tepat mengatakan bahwa selain *&gt; ( <code>productR</code> ) juga ada &gt;&gt; dari <code>FlatMapSyntax</code> .  &gt;&gt; didefinisikan dengan cara yang sama dengan <code>fa.flatMap(_ =&gt; fb)</code> , tetapi dengan dua nuansa: <br><br><ul><li>  itu didefinisikan secara independen dari <code>productR</code> , dan oleh karena itu, jika karena alasan tertentu kontrak metode ini berubah (secara teoritis, itu dapat diubah tanpa melanggar hukum monadik, tetapi saya tidak yakin tentang <code>MonadError</code> ), Anda tidak akan menderita; </li><li>  yang lebih penting, &gt;&gt; memiliki operan kedua yang dipanggil oleh panggilan-dengan-nama, yaitu  <code>fb: =&gt; F[B]</code> .  Perbedaan dalam semantik menjadi mendasar jika Anda melakukan perhitungan yang dapat menyebabkan ledakan tumpukan. </li></ul><br>  Berdasarkan ini, saya mulai menggunakan *&gt; lebih sering.  Dengan satu atau lain cara, jangan lupa tentang faktor-faktor yang tercantum di atas. <br><br><h3>  <b>7) Angkat layar!</b> </h3><br>  Banyak yang meluangkan waktu untuk memasukkan konsep <code>lift</code> ke dalam kepala mereka.  Tetapi ketika Anda berhasil, Anda akan menemukan bahwa dia ada di mana-mana. <br><br>  Seperti banyak istilah menjulang di udara pemrograman fungsional, <code>lift</code> datang dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teori kategori</a> .  Saya akan mencoba menjelaskan: melakukan operasi, mengubah tanda tangan dari tipenya sehingga menjadi terkait langsung dengan tipe abstrak F. <br><br>  Dalam Kucing, contoh paling sederhana adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Functor</a> : <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lift</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] =&gt; <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>] = map(_)(f)</code> </pre> <br>  Ini berarti: ubah fungsi ini sehingga bekerja pada tipe functor F. <br><br>  Fungsi lift seringkali identik dengan konstruktor bersarang untuk jenis tertentu.  Jadi, <code>EitherT.liftF</code> pada dasarnya <code>EitherT.right.</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh dari Scaladoc</a> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.data.<span class="hljs-type"><span class="hljs-type">EitherT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-type"><span class="hljs-type">EitherT</span></span>.liftF(<span class="hljs-string"><span class="hljs-string">"a"</span></span>.some) <span class="hljs-comment"><span class="hljs-comment">//EitherT(Some(Right(a))) EitherT.liftF(none[String]) //EitherT(None)</span></span></code> </pre> <br>  Cherry on the cake: <code>lift</code> hadir di mana-mana di perpustakaan standar Scala.  Contoh paling populer (dan mungkin yang paling berguna dalam pekerjaan sehari-hari) adalah <code>PartialFunction</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> intMatcher: <span class="hljs-type"><span class="hljs-type">PartialFunction</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"jak siƒô masz!"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> liftedIntMatcher: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = intMatcher.lift liftedIntMatcher(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//Some(jak siƒô masz!) liftedIntMatcher(0) //None intMatcher(1) //jak siƒô masz! intMatcher(0) //Exception in thread "main" scala.MatchError: 0</span></span></code> </pre> <br>  Sekarang kita bisa beralih ke masalah yang lebih mendesak. <br><br><h3>  <b>6) petaN</b> </h3><br>  <code>mapN</code> adalah fungsi pembantu yang berguna untuk bekerja dengan tuple.  Sekali lagi, ini bukan hal baru, tetapi pengganti operator tua yang baik <code>|@|</code>  Dia adalah Jeritan. <br><br>  Inilah yang terlihat seperti mapN dalam hal dua elemen: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// where t2: Tuple2[F[A0], F[A1]] def mapN[Z](f: (A0, A1) =&gt; Z)(implicit functor: Functor[F], semigroupal: Semigroupal[F]): F[Z] = Semigroupal.map2(t2._1, t2._2)(f)</span></span></code> </pre> <br>  Pada dasarnya, ini memungkinkan kita untuk memetakan nilai-nilai di dalam tuple dari F apa pun yang merupakan kelompok (produk) dan functor (peta).  Jadi: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ (<span class="hljs-string"><span class="hljs-string">"a"</span></span>.some, <span class="hljs-string"><span class="hljs-string">"b"</span></span>.some).mapN(_ ++ _) <span class="hljs-comment"><span class="hljs-comment">//Some(ab) (List(1, 2), List(3, 4), List(0, 2).mapN(_ * _ * _)) //List(0, 6, 0, 8, 0, 12, 0, 16)</span></span></code> </pre> <br>  Ngomong-ngomong, jangan lupa bahwa dengan kucing Anda mendapatkan peta dan peta <code>leftmap</code> untuk tupel: <br><br><pre> <code class="scala hljs">(<span class="hljs-string"><span class="hljs-string">"a"</span></span>.some, <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-string"><span class="hljs-string">"b"</span></span>,<span class="hljs-string"><span class="hljs-string">"c"</span></span>).mapN(_ ++ _)) <span class="hljs-comment"><span class="hljs-comment">//won't compile, because outer type is not the same ("a".some, List("b", "c")).leftMap(_.toList).mapN(_ ++ _) //List(ab, ac)</span></span></code> </pre> <br>  Fungsi <code>.mapN</code> berguna lainnya adalah instantiating kelas kasus: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mead</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, honeyRatio: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span><span class="hljs-class"><span class="hljs-params">, agingYears: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span></span><span class="hljs-class">) (</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">"p√≥≈Çtorak".some, 0.5.some, 3d.some</span></span></span><span class="hljs-class">).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mapN</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Mead</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//Some</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Mead</span></span></span></span><span class="hljs-class"><span class="hljs-params">(p√≥≈Çtorak,0.5,3.0</span></span></span><span class="hljs-class">))</span></span></code> </pre> <br>  Tentu saja, Anda lebih suka menggunakan operator loop untuk ini, tetapi mapN menghindari transformator monadik dalam kasus sederhana. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.effect.<span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-comment"><span class="hljs-comment">//interchangable with eg Monix's Task type Query[T] = IO[Option[T]] def defineMead(qName: Query[String], qHoneyRatio: Query[Double], qAgingYears: Query[Double]): Query[Mead] = (for { name &lt;- OptionT(qName) honeyRatio &lt;- OptionT(qHoneyRatio) agingYears &lt;- OptionT(qAgingYears) } yield Mead(name, honeyRatio, agingYears)).value def defineMead2(qName: Query[String], qHoneyRatio: Query[Double], qAgingYears: Query[Double]): Query[Mead] = for { name &lt;- qName honeyRatio &lt;- qHoneyRatio agingYears &lt;- qAgingYears } yield (name, honeyRatio, agingYears).mapN(Mead)</span></span></code> </pre> <br>  Metode memiliki hasil yang serupa, tetapi yang terakhir dikeluarkan dengan trafo monadik. <br><br><h3>  <b>5) Bersarang</b> </h3><br>  <code>Nested</code> pada dasarnya adalah double umum dari trafo monad.  Seperti namanya, ini memungkinkan Anda untuk melakukan operasi lampiran dalam kondisi tertentu.  Ini adalah contoh untuk <code>.map(_.map( :</code> <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.data.<span class="hljs-type"><span class="hljs-type">Nested</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someValue: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]] = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.asRight.some <span class="hljs-type"><span class="hljs-type">Nested</span></span>(someValue).map(_ * <span class="hljs-number"><span class="hljs-number">3</span></span>).value <span class="hljs-comment"><span class="hljs-comment">//Some(Right(aaa))</span></span></code> </pre> <br>  Selain <code>Functor</code> , <code>Nested</code> menggeneralisasikan <code>Applicative</code> , <code>ApplicativeError</code> dan <code>Traverse</code> .  Informasi dan contoh tambahan ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h3>  <b>4) .recover / .recoverWith / .handleError / .handleErrorWith / .valueOr</b> </h3><br>  Pemrograman fungsional dalam Scala banyak berkaitan dengan penanganan efek kesalahan.  <code>ApplicativeError</code> dan <code>MonadError</code> memiliki beberapa metode yang berguna, dan mungkin berguna bagi Anda untuk mengetahui perbedaan halus antara empat yang utama.  Jadi, dengan <code>ApplicativeError F[A]:</code> <br><br><ul><li>  <code>handleError</code> mengubah <u>semua</u> kesalahan pada titik panggilan ke A sesuai dengan fungsi yang ditentukan. </li><li>  <code>recover</code> tindakan dengan cara yang serupa, tetapi menerima fungsi parsial, dan karenanya dapat mengubah kesalahan yang Anda pilih menjadi A. </li><li>  <code>handleErrorWith</code> mirip dengan <code>handleError</code> , tetapi hasilnya akan terlihat seperti <code>F[A]</code> , yang artinya membantu Anda mengonversi kesalahan. </li><li>  <code>recoverWith</code> bertindak seperti memulihkan, tetapi juga membutuhkan <code>F[A]</code> sebagai hasilnya. </li></ul><br>  Seperti yang Anda lihat, Anda dapat membatasi <code>handleErrorWith</code> untuk <code>handleErrorWith</code> dan <code>recoverWith</code> , yang mencakup semua fungsi yang mungkin.  Namun, masing-masing metode memiliki kelebihan dan nyaman dengan caranya sendiri. <br><br>  Secara umum, saya menyarankan Anda untuk membiasakan diri dengan API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ApplicativeError</a> , yang merupakan salah satu yang terkaya di Kucing dan diwarisi di MonadError - yang berarti didukung di <code>cats.effect.IO</code> , <code>monix.Task</code> , dll. <br><br>  Ada metode lain untuk <code>Either/EitherT</code> , <code>Validated</code> dan <code>Ior</code> - <code>.valueOr</code> .  Pada dasarnya, ini berfungsi seperti <code>.getOrElse</code> untuk <code>Option</code> , tetapi generik untuk kelas yang berisi sesuatu "ke kiri". <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> failure = <span class="hljs-number"><span class="hljs-number">400.</span></span>asLeft[<span class="hljs-type"><span class="hljs-type">String</span></span>] failure.valueOr(code =&gt; <span class="hljs-string"><span class="hljs-string">s"Got error code </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$code</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//"Got error code 400"</span></span></code> </pre> <br><h3>  <b>3) kucing gang</b> </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gang-kucing</a> adalah solusi yang mudah untuk dua kasus: <br><br><ul><li>  contoh kelas ubin yang tidak mengikuti hukumnya 100%; </li><li>  Typklassy tambahan yang tidak biasa, yang dapat digunakan dengan benar. </li></ul><br>  Secara historis, contoh monad untuk <code>Try</code> paling populer di proyek ini, karena <code>Try</code> , seperti yang Anda tahu, tidak memenuhi semua hukum monadik dalam hal kesalahan fatal.  Sekarang dia benar-benar diperkenalkan dengan Kucing. <br><br>  Meskipun demikian, saya sarankan Anda membiasakan diri dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>modul ini</u></a> , mungkin terasa bermanfaat bagi Anda. <br><br><h3>  <b>2) Perlakukan impor secara bertanggung jawab</b> </h3><br>  Anda harus tahu - dari dokumentasi, buku, atau dari tempat lain - bahwa kucing menggunakan hierarki impor tertentu: <br><br>  <code>cats.x</code> untuk <code>cats.x</code> dasar (kernel); <br>  <code>cats.data</code> untuk tipe data seperti Validated, monad transformers, dll. <br>  cats.syntax.x._ untuk mendukung metode ekstensi sehingga Anda dapat memanggil sth.asRight, sth.pure, dll.; <br> <code>cats.instances.x.</code>  _ untuk secara langsung mengimpor implementasi dari berbagai typclass ke dalam lingkup implisit untuk tipe beton individu sehingga ketika memanggil, misalnya, sth.pure, kesalahan "implisit tidak ditemukan" tidak terjadi. <br><br>  Tentu saja, Anda memperhatikan impor <code>cats.implicits._</code> , yang mengimpor semua sintaks dan semua instance dari kelas tipe dalam cakupan implisit. <br><br>  Pada prinsipnya, saat mengembangkan dengan Kucing, Anda harus mulai dengan urutan impor tertentu dari FAQ, yaitu: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.data._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._</code> </pre> <br>  Jika Anda mengenal perpustakaan dengan lebih baik, Anda bisa memadukannya dengan selera Anda.  Ikuti aturan sederhana: <br><br><ul><li>  <code>cats.syntax.x</code> menyediakan sintaksis ekstensi yang terkait dengan x; </li><li>  <code>cats.instances.x</code> menyediakan kelas instan. </li></ul><br>  Misalnya, jika Anda memerlukan <code>.asRight</code> , yang merupakan metode ekstensi untuk <code>Either</code> , lakukan hal berikut: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.syntax.either._ <span class="hljs-string"><span class="hljs-string">"a"</span></span>.asRight[<span class="hljs-type"><span class="hljs-type">Int</span></span>] <span class="hljs-comment"><span class="hljs-comment">//Right[Int, String](a)</span></span></code> </pre> <br>  Di sisi lain, untuk mendapatkan <code>Option.pure</code> Anda harus mengimpor <code>cats.syntax.monad</code> <b>DAN</b> <code>cats.instances.option</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.syntax.applicative._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.instances.option._ <span class="hljs-string"><span class="hljs-string">"a"</span></span>.pure[<span class="hljs-type"><span class="hljs-type">Option</span></span>] <span class="hljs-comment"><span class="hljs-comment">//Some(a)</span></span></code> </pre> <br>  Dengan mengoptimalkan impor secara manual, Anda akan membatasi cakupan implisit dalam file Scala Anda dan dengan demikian mengurangi waktu kompilasi. <br><br>  Namun, tolong: jangan lakukan ini jika kondisi berikut tidak terpenuhi: <br><br><ul><li>  Anda sudah menguasai Kucing dengan baik </li><li>  tim Anda memiliki perpustakaan di tingkat yang sama </li></ul><br>  Mengapa  Karena: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   `pure`, //    import cats.implicits._ import cats.instances.option._ "a".pure[Option] //could not find implicit value for parameter F: cats.Applicative[Option]</span></span></code> </pre> <br>  Ini karena baik <code>cats.implicits</code> maupun <code>cats.instances.option</code> adalah ekstensi dari <code>cats.instances.OptionInstances</code> .  Bahkan, kami mengimpor cakupan implisitnya dua kali, daripada kami mengacaukan kompiler. <br><br>  Selain itu, tidak ada keajaiban dalam hierarki implisit - ini adalah urutan ekstensi tipe yang jelas.  Anda hanya perlu merujuk definisi <code>cats.implicits</code> dan memeriksa hierarki jenis. <br><br>  Selama 10-20 menit Anda dapat mempelajarinya cukup untuk menghindari masalah seperti ini - percayalah, investasi ini pasti akan terbayar. <br><br><h3>  <b>1) Jangan lupa tentang pembaruan kucing!</b> </h3><br>  Anda mungkin berpikir perpustakaan FP Anda tidak lekang oleh waktu, tetapi sebenarnya <code>cats</code> dan <code>scalaz</code> memperbarui secara aktif.  Ambil contoh kucing.  Berikut ini hanyalah perubahan terbaru: <br><br><ul><li>  sekarang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda tidak perlu menghubungkan pengecualian Throwable saat menggunakan raisError</a> ; </li><li>  Sekarang ada contoh untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Durasi</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FiniteDuration</a> , yang berarti Anda dapat menggunakan d1&gt; d2 tanpa menggunakan perpustakaan eksternal; </li><li>  serta banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inovasi kecil dan besar lainnya</a> . </li></ul><br>  Karena itu, ketika bekerja dengan proyek, jangan lupa untuk memeriksa versi perpustakaan, baca catatan untuk versi baru dan perbarui dalam waktu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448128/">https://habr.com/ru/post/id448128/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448118/index.html">SEO dan iklan kontekstual - mengarah untuk 175 ribu rubel sehari di Izhevsk</a></li>
<li><a href="../id448120/index.html">Tentang kedekatan puncak</a></li>
<li><a href="../id448122/index.html">Bagaimana ReactJS Bekerja Paket Bereaksi</a></li>
<li><a href="../id448124/index.html">Mikrotik. Kontrol SMS menggunakan server WEB</a></li>
<li><a href="../id448126/index.html">Rahasia API perangkat Android. Laporan Yandex</a></li>
<li><a href="../id448130/index.html">Desain deckbuilding video game</a></li>
<li><a href="../id448136/index.html">Instruksi: cara menguji peran yang dimungkinkan dan mencari tahu tentang masalah sebelum produksi</a></li>
<li><a href="../id448140/index.html">SNA Hackathon 2019 - hasil</a></li>
<li><a href="../id448142/index.html">Di mana bukti, fakta, dan imajinasi bertemu</a></li>
<li><a href="../id448144/index.html">NASA: perubahan genetik yang disebabkan oleh perjalanan ruang angkasa bersifat sementara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>