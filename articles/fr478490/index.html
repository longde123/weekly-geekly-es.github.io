<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚻 👦🏿 👩🏽‍🚒 Distance Levenshtein et recherche de contrôleurs 👨‍💻 👩🏿‍💼 😂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Probablement, dans chaque ville du Bélarus où il y a des trolleybus, il y a des groupes VK ou des chats sur Telegram dans lesquels les gens suivent l'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Distance Levenshtein et recherche de contrôleurs</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478490/">  Probablement, dans chaque ville du Bélarus où il y a des trolleybus, il y a des groupes VK ou des chats sur Telegram dans lesquels les gens suivent l'emplacement des contrôleurs.  Ceci est principalement fait afin de ne pas payer les voyages et les voyages gratuits, bien que la description des groupes contienne presque toujours le post-scriptum «Payer pour les voyages». <br><a name="habracut"></a><br>  Dans VC, cela ressemble généralement à ceci: <br><br><img src="https://habrastorage.org/webt/ti/eh/cd/tiehcdyeskmccfofp3adt2ko_qe.png" alt="image"><br><br>  Un commentaire typique ressemble à ceci: <br><br><img src="https://habrastorage.org/webt/ki/kp/s0/kikps0wwqqptfwyro8hrf81rtzg.png" alt="image"><br><br>  La structure est extrêmement simple.  Dans le commentaire, il y a des noms de l'arrêt où les contrôleurs étaient actuellement remarqués, il y a aussi la direction dans laquelle ils se trouvent: <br><br><img src="https://habrastorage.org/webt/no/gy/2l/nogy2l1lrraa8gte90lcyuwsume.png" alt="image"><br><br>  En conséquence, le commentaire est un objet avec un arrêt, une heure et une date, ainsi qu'un identifiant unique permettant de l'identifier.  Avec cela, vous pouvez calculer l'emplacement le plus probable de l'emplacement actuel des contrôleurs. <br><br><h4>  La préparation </h4><br>  Vous devez d'abord déterminer le public cible, à partir duquel nous analyserons les données.  Le groupe devrait avoir beaucoup d'activité dans les commentaires, sinon nous risquons d'obtenir trop peu de données <br><br>  Dans mon cas, c'est le groupe «Control Gomel». <br><br>  Nous analyserons les commentaires à l'aide de l'API VKontakte officielle pour Python <br><br>  Nous nous authentifions avec la clé d'accès de l'utilisateur, car certains groupes peuvent être fermés et l'accès à leurs commentaires ne peut être obtenu que si vous avez été accepté dans le groupe. <br>  Après cela, vous pouvez commencer à extraire des commentaires: <br><br><h4>  Recevoir des commentaires </h4><br>  Pour commencer, nous obtenons le dernier message disponible dans le groupe pour extraire les commentaires via vk.wall.getComments et initialiser le DataFrame, dans lequel nous enregistrerons les données. <br><br>  Chaque article de commentaire a l'inscription «Passez une bonne journée, payez le prix et ne tombez pas sous le contrôle», alors téléchargez les commentaires, vérifiez le contenu de l'article et obtenez un tableau de commentaires à partir duquel vous pouvez prendre des données. <br><br>  J'ai pris les commentaires des articles au cours des 3 derniers mois, étant donné qu'un article est publié chaque jour (maintenant fin novembre, l'année scolaire commence en septembre, et les contrôleurs en tiennent probablement compte et changent de place).  En principe, d'autres signes peuvent être pris en compte, comme par exemple la période de l'année. <br><br>  Certains des commentaires sont bouchés par des messages comme «Y a-t-il quelqu'un sur Barykin?»  Si vous regardez ces commentaires (inutiles), vous pouvez mettre en évidence certains signes: <br><br><ul><li>  Le texte contient les mots «propre», «gauche», «personne» et similaires </li><li>  Les mots «dites-moi», «qui», «quoi», «comment» </li><li>  Des symboles, comme des émoticônes, par exemple </li></ul><br>  Après cela, nous passons en revue un tableau de commentaires et en retirons un identifiant, un texte, une heure, une date et un jour de la semaine uniques, que nous mettons dans le DataFrame déjà créé. <br><br><div class="spoiler">  <b class="spoiler_title">Recevoir des commentaires</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> vk_api <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> check_correctness <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">auth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> vk_session = vk_api.VkApi(lp.login, lp.password) vk_session.auth() vk = vk_session.get_api() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vk <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataFromComments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vk, groupID)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#     posts = vk.wall.get(owner_id=groupID, offset=1, count=90) print("\n") data = pd.DataFrame(columns=['text', 'post_id', "date", "day_in_week", "hour","minute", "day_in_month"]) for post in posts.get("items"): # id     postID = post.get("id") if "  ,       " not in post.get("text"): continue #  commentary       comments = vk.wall.getComments(owner_id=groupID, post_id=postID, count=200) #           dataframe for comment in comments.get("items"): text = comment.get("text") text = re.sub(r"A-Za-z--0123456789 ", "", str(text)) commentaryIsNice = check_correctness.detection(text) if commentaryIsNice: print(text) date = comment.get("date") time_struct = time.gmtime(date) post_id = comment.get("post_id") data = data.append({"text": text, "post_id" : post_id, "date": date,"day_in_week" : time_struct.tm_wday, "hour": (time_struct.tm_hour+3), "minute": time_struct.tm_min, "day_in_month": time_struct.tm_mday}, ignore_index=True) # print(data[:10]) # print(data.info()) print("dataset is ready") return data</span></span></code> </pre> <br></div></div><br>  Ainsi, nous avons reçu un DataFrame avec le texte des commentaires, leur identifiant, le jour de la semaine, l'heure et la minute dans laquelle le commentaire a été écrit.  Nous n'avons besoin que du jour de la semaine, de l'heure d'écriture et du texte.  Cela ressemble à ceci: <br><br><img src="https://habrastorage.org/webt/cd/hs/cy/cdhscyg3rx4f5kejgvjdguuscui.png" alt="image"><br><br><h4>  Nettoyage des données </h4><br>  Maintenant, nous devons effacer les données.  Il est nécessaire de supprimer la direction du commentaire afin de faire moins d'erreurs lors de la recherche de la distance Levenshtein.  Nous trouvons les expressions «sur le côté», «aller», «comment», «près», car elles sont généralement suivies du nom du deuxième arrêt, et nous les supprimons avec ce qui vient après, ainsi que remplacer certains noms de jargon des arrêts par l'habituel . <br><br><div class="spoiler">  <b class="spoiler_title">Effacer les données</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> fuzzywuzzy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> process <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear_commentary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(text)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    -     """</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span> splitted = text.split(<span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(splitted): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(splitted) == <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.NaN <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ( <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ( <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s)) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>): index = i <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> index <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> index &lt; len(splitted) - <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>): splitted.remove(splitted[index]) string = <span class="hljs-string"><span class="hljs-string">" "</span></span>.join(splitted) text = (string.lower()) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> index <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: splitted = splitted[:index] string = <span class="hljs-string"><span class="hljs-string">" "</span></span>.join(splitted) text = string.lower() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: text = <span class="hljs-string"><span class="hljs-string">" "</span></span>.join(splitted).lower() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clean_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> data.dropna(inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) data[<span class="hljs-string"><span class="hljs-string">"text"</span></span>] = data[<span class="hljs-string"><span class="hljs-string">"text"</span></span>].map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> s: clear_commentary(s)) data.dropna(inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) print(<span class="hljs-string"><span class="hljs-string">"cleaned"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br></div></div><br><h4>  Conversion à l'aide de la distance de Levenshtein </h4><br>  Nous allons directement à la distance Levenshane.  Un peu d'aide: distance Levenshtein - le nombre minimum d'opérations pour insérer un caractère, supprimer un caractère et remplacer un caractère par un autre, nécessaire pour transformer une ligne en une autre. <br><br>  Nous le trouverons en utilisant la bibliothèque <a href="https://github.com/seatgeek/fuzzywuzzy">fuzzywuzzy</a> .  Il vous aide à calculer rapidement et facilement la distance Levenshtein.  Pour accélérer le travail, les auteurs de la bibliothèque recommandent également d'installer la bibliothèque python-Levenshtein. <br><br>  Afin d'obtenir des arrêts à partir des commentaires, nous avons besoin d'une liste d'arrêts.  Il m'a été gracieusement fourni par le développeur de l'application GoTrans, Alexander Kozlov. <br><br>  La liste a dû être élargie, en y ajoutant des arrêts qui n'étaient pas là, et en changeant une partie des noms afin qu'ils soient mieux localisés. <br><br><div class="spoiler">  <b class="spoiler_title">Arrête</b> <div class="spoiler_text">  stops = ['supermarché', 'prairie', 'remybtekhnika', 'Leningrad', 'Yaroslavl', 'Polesskaya', <br>  «Yaroslavl», «timofeenko», «8 mars», <br>  «Rechitsky trading house», «Rechitsky avenue», «circus», «department store», «Chongarskaya», <br>  «chongarka», «ggu», «skorina», «université», «appareil», «1000 petites choses», «maya», «station», <br>  «parc des diplômés», «commerce et économie», «anniversaire», «microdistrict 18», «aéroport», «venant en sens inverse», <br>  «gomelgeodezcentr», «cristal», «lac lyubenskoye», «marché davydovsky», «davydovka», <br>  «rivière sozh», «gomeldrev», <br>  «Sevruki», «gmu n ° 1», «etc. Rechitsky», «costume», «hôpital des maladies infectieuses», «camp de goélands», <br>  Volotova, Coral, Gomeltorgmash, Gomelproekt, Vneshgomelstroy, Journal, <br>  «Kalenikova», «Eremino», «distillerie», «spécialisation industrielle», «2nd School», «Barykina», <br>  «unités de machine», «jeunesse», «corps de coulée», «chimistes», «golovatsky», «budenny», <br>  'spu67', '35th', 'gagarin', '50 years to the Gomselmash plant ',' hill ',' radio factory ', <br>  «grand-mère», «verrerie», «châtaignier», «démarrage des moteurs», «astronautes», <br>  «rtsrm initial», «bykhovskaya», «institut du ministère des situations d'urgence», «dk gomselmash», «magasin», «rechitsky», <br>  'Sevruks', 'Osovtsy', 'tourist', 'meat factory', 'Holy Trinity', 'medical town', 'octobre', <br>  «dépôt d'huile», «gomelloblavtotrans», «milkavita», «bakunin», «zip», «oma», «résine», <br>  «construction market ksk», «road builder», «field», «kamenetskaya», «bolchevik», «jakubovka», <br>  «Borodina», «hypermarché hippopotame», «héros souterrains», «9 mai», «châtaignier», «prothésiste», <br>  'iput station', 'communist international', 'music pedagogical college', 'farm firm', 'bypass road', 'victoire', <br>  «western», «pearl», «Vladimir», «dry», «dispensary», «Ivanova», <br>  «construction de machines», «bouleaux», «60 ans», «ingénieur électricien», «centrolite», <br>  «clinique oncologique», «champ de tir», «golovintsy», «corail», «sud», «printemps», <br>  Efremova, Border, Belgut, Gomelstroy, Borisenko, Athletics Palace, <br>  «Michurinsky», «solaire», «gastello», «militaire», «centre automobile», «plomberie», «uza», <br>  «collège médical», «maternelle 11», «bolchevik», «chiots», «Davydovsky», «océan», «progrès», <br>  «Dobrushskaya», «blanc», «GSK», «davydovka», «équipement électrique», «amitié», <br>  «70 ans», «réparation automobile», «colline suédoise», «circuit», «canal d'eau», «machine gomel», <br>  Volotova, Pioneer, RCM, Khimtorg, 2nd Meadow Lane, Bochkina, Baths, <br>  «clinique oncologique», «carré», «Lénine», «1ère école», «magasin sud», <br>  «gomelagrotrans», «meuniers», «lyubensky», «bureau d'enrôlement militaire», «hôpital», «uza», «rtsrm», <br>  «lysyukovyh», «shop iput», «raton», «gas station», «randovsky», «farmhouse», «châtaignier», «ropovsky», <br>  «Romanovichi», «Ilyich», «aviron», «entreprise de construction», «infectieux», <br>  «fat factory», «car service», «agroservice», «sticky», «Nikolskaya», <br>  «abatteuses automotrices», «maçons», «matériaux de construction», «machines de réparation», «administration», <br>  «Octobre», «conte de fées forestier», «Tatiana», «Boris Tsarikov», «Zharkovsky», «Zaitseva», <br>  «délocalisation», «Karpovich», «usine de construction de maisons», «transports électriques urbains», «zlin», <br>  «stade gomselmash», «ap 6», «entraînement hydraulique», «dépôt de locomotives», «marché automobile osovtsy», <br>  «nouvelle vie», «Zhukova», «unité militaire», «3e école», «forêt», «phare rouge», <br>  «régional», «Davydovskaya», «Karbysheva», «satellite du monde», «jeunesse», «locomotive du stade», <br>  «solaire», «Ladaservice», «μR 21», «Aresa», «internationalistes», «Kosareva», <br>  «Bogdanova», «Gomel iron-concrete», «μr 20a», «μr Rechitsky», «medical equipment», «Juraeva», <br>  «collège d'artisanat d'art», «glace», «festival dk», «centre commercial», <br>  'Kuibyshevsky', 'festival', 'garage koop 27', 'génie sismique', 'milcha', 'tube hospital', <br>  «ptu179», «produits chimiques», «pompiers», «hôpital», «dépôt de bus», <br>  «complexe de journaux», «victoire», «klenkovsky», «diamant», «réparation de moteur», «mkr 19»] <br></div></div><br>  En utilisant .map et fuzzywuzzy.process.extractOne, nous trouvons l'arrêt avec la distance Levenshtein minimale dans la liste, après quoi nous remplaçons le texte du commentaire par le nom de l'arrêt, ce qui nous permet d'obtenir un ensemble de données avec les noms des arrêts. <br><br>  L'ensemble de données résultant ressemble à ceci: <br><br><img src="https://habrastorage.org/webt/gd/pd/c8/gdpdc8lwdppzpastghnasxbqsbi.png"><br><br><div class="spoiler">  <b class="spoiler_title">Les commentaires se transforment en arrêts</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_category_from_comment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(text)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""              """</span></span> dict = process.extractOne(text.lower(), stops) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dict[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">75</span></span>: text = dict[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: text = np.nan print(<span class="hljs-string"><span class="hljs-string">"wait"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_category_dataset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""      """</span></span> print(<span class="hljs-string"><span class="hljs-string">"remap started. wait"</span></span>) data.text = data.text.map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> comment: get_category_from_comment(str(comment))) print(<span class="hljs-string"><span class="hljs-string">"remap ends"</span></span>) data.dropna(inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) data[<span class="hljs-string"><span class="hljs-string">"text"</span></span>] = data.text.map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> s: <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s==<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> s) data[<span class="hljs-string"><span class="hljs-string">"text"</span></span>] = data.text.map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> s: <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s==<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> s) data[<span class="hljs-string"><span class="hljs-string">"text"</span></span>] = data.text.map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> s: <span class="hljs-string"><span class="hljs-string">" "</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s==<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> s) data[<span class="hljs-string"><span class="hljs-string">"text"</span></span>] = data.text.map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> s: <span class="hljs-string"><span class="hljs-string">" "</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s==<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> s) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br></div></div><br><h4>  Sortie de données </h4><br>  Nous pouvons maintenant supposer où les contrôleurs seront le plus probablement à l'heure donnée. <br><br>  Nous recherchons dans les enregistrements de données résultants pour une heure et un jour spécifiques de la semaine.  Par exemple, le mardi à 9 h: <br><br><pre> <code class="python hljs">&lt;code&gt;data[(data[<span class="hljs-string"><span class="hljs-string">"day_in_week"</span></span>] == day) &amp; (data[<span class="hljs-string"><span class="hljs-string">"hour"</span></span>] == hour)]&lt;/code&gt;</code> </pre> <br><img src="https://habrastorage.org/webt/t4/gg/dg/t4ggdgmwezje8lgllisorbqrqwa.png"><br>  <i>(ce ne sont pas toutes les données)</i> <br><br>  Après cela, nous trouvons le nombre d'arrêts uniques et affichons uniquement les arrêts et leur nombre: <br><br><pre> <code class="python hljs">df[(df[<span class="hljs-string"><span class="hljs-string">"day_in_week"</span></span>] == <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp; (df[<span class="hljs-string"><span class="hljs-string">"hour"</span></span>] == <span class="hljs-number"><span class="hljs-number">9</span></span>)][<span class="hljs-string"><span class="hljs-string">"text"</span></span>].value_counts()</code> </pre> <br><img src="https://habrastorage.org/webt/yq/az/if/yqazifl3gkclyqw4ifykvemsrky.png"><br><br>  Maintenant, nous pouvons dire qu'à 9 heures du matin, le mardi, les contrôleurs seront très probablement repérés aux arrêts Myasokombinat, ul.  Lugovaya, BelGUT, TD «Oma». <br><br>  Le principal défaut de cette méthode est le manque de données.  Pas pour tous les jours et heures, il y a des entrées dans les commentaires donnés aux heures de pointe, lorsque les gens utilisent plus les transports publics que les données aux heures moins populaires, mais si vous ajoutez des données, par exemple, non seulement à partir des commentaires d'un groupe, mais aussi à partir de groupes alternatifs ou de chats télégrammes, avec le nombre d'entrées, tout deviendra plus facile. <br><br><h4>  Bot avec VK LongPoll API </h4><br>  Pour donner la possibilité de recevoir des données sur l'emplacement des contrôleurs, selon l'heure, et sans être lié à un ordinateur, j'ai créé un bot pour un groupe sur VKontakte qui répond à n'importe quel message en envoyant le nombre d'arrêts dans les enregistrements, compte tenu de l'heure et du jour de la semaine. <br><br><div class="spoiler">  <b class="spoiler_title">Code Bot</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> randint <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> vk_api <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> get_stops_from_data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> get_stops_by_time <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_bot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data, token)</span></span></span><span class="hljs-function">:</span></span> vk_session = vk_api.VkApi(token=token) vk = vk_session.get_api() print(<span class="hljs-string"><span class="hljs-string">"bot started"</span></span>) longPoll = vk.groups.getLongPollServer(group_id=<span class="hljs-number"><span class="hljs-number">183524419</span></span>) server, key, ts = longPoll[<span class="hljs-string"><span class="hljs-string">'server'</span></span>], longPoll[<span class="hljs-string"><span class="hljs-string">'key'</span></span>], longPoll[<span class="hljs-string"><span class="hljs-string">'ts'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-comment"><span class="hljs-comment">#  :   ts longPoll = post('%s' % server, data={'act': 'a_check', 'key': key, 'ts': ts, 'wait': 25}).json() if longPoll['updates'] and len(longPoll['updates']) != 0: for update in longPoll['updates']: if update['type'] == 'message_new': #        vk.messages.markAsRead(peer_id=update['object']['user_id']) user = update['object']["user_id"] text = get_stops_by_time(data) if text is None or text == {}: message = "íåò çàïèñåé" vk.messages.send(user_id=user, random_id=randint(-2147483648, 2147483647), message=message) print(message) ts = longPoll['ts'] continue message = "   -     \n" \ "\n \n" for i in text.items(): message += i[0] + " " message += str(i[1]) message += "\n" #    vk.messages.send(user_id=user, random_id=randint(-2147483648, 2147483647), message=message) ts = longPoll['ts']</span></span></code> </pre> <br></div></div><br><h4>  Conclusion </h4><br>  La qualité de telles hypothèses a été testée par moi plus d'une fois dans la pratique, et tout fonctionne bien.  Il s'est avéré que les contrôleurs, au fond, sont aux mêmes arrêts, bien que des prévisions absolument correctes ne puissent pas être données, et la probabilité de succès n'est pas de 100%.  La distance de Levenshtein a des dizaines d'applications différentes, de la correction d'erreurs en un mot, à la comparaison de gènes, de chromosomes et de protéines, mais elle a également un potentiel dans de tels problèmes appliqués. <br><br>  Passez une bonne journée et payez le prix. <br><br>  Toutes les manipulations de code bot et de données sont publiées <a href="https://github.com/dingdongyouarewrong/vk_controllers_bot">ici</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr478490/">https://habr.com/ru/post/fr478490/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr478474/index.html">Le frère Pablo Escobar a également sorti un smartphone flexible</a></li>
<li><a href="../fr478480/index.html">Intelligence artificielle, ITSM et, en général, d'où vient LEAN?</a></li>
<li><a href="../fr478482/index.html">Le développeur a ouvert un bar pour les développeurs et y accueille des réunions sur Angular, layout, PHP</a></li>
<li><a href="../fr478484/index.html">SCADA sur la framboise: mythe ou réalité?</a></li>
<li><a href="../fr478486/index.html">L'ère des puces 10 nm - qui développe de tels processeurs et ce qui attend l'industrie à l'avenir</a></li>
<li><a href="../fr478492/index.html">Escherichia coli au régime CO2: un nouvel outil pour lutter contre le réchauffement climatique?</a></li>
<li><a href="../fr478494/index.html">Solution de traitement thermique Winnum TRP: configuration et utilisation</a></li>
<li><a href="../fr478496/index.html">Il y a 50 ans, dans la pièce 3420, Internet était né</a></li>
<li><a href="../fr478498/index.html">1. Mise en route de Fortinet v 6.0. Présentation</a></li>
<li><a href="../fr478500/index.html">Pourquoi y a-t-il si peu de conférences en été?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>