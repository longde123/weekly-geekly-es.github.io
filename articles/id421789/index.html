<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™ğŸ¿ ğŸ’‡ ğŸ‘©ğŸ½â€ğŸš€ Buat frontend "backend" lagi ğŸ– ğŸ‘³ ğŸ¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nikolai Ryzhikov mengusulkan versi jawabannya untuk pertanyaan mengapa sangat sulit untuk mengembangkan antarmuka pengguna. Pada contoh proyeknya, ia ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buat frontend "backend" lagi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/421789/">  Nikolai Ryzhikov mengusulkan versi jawabannya untuk pertanyaan mengapa sangat sulit untuk mengembangkan antarmuka pengguna.  Pada contoh proyeknya, ia akan menunjukkan bahwa aplikasi di frontend dari beberapa ide dari backend mempengaruhi pengurangan kompleksitas pengembangan dan testability dari frontend. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XBfi3Q74BnE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Materi disusun berdasarkan laporan oleh Nikolai Ryzhikov pada musim semi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HolyJS 2018 Piter</a> conference. <br><a name="habracut"></a><br>  Saat ini, Nikolai Ryzhikov bekerja di sektor Kesehatan-TI untuk membuat sistem informasi medis.  Anggota komunitas programmer fungsional St. Petersburg FPROG.  Anggota aktif dari komunitas Clojure Online, anggota dari standar pertukaran informasi medis HL7 FHIR.  Telah pemrograman selama 15 tahun. <br><br><hr><br>  - Saya selalu tersiksa oleh pertanyaan: mengapa grafis UI selalu sulit dilakukan?  Mengapa ini selalu menimbulkan banyak pertanyaan? <br><br>  Hari ini saya akan mencoba untuk berspekulasi tentang apakah mungkin untuk mengembangkan antarmuka pengguna secara efektif.  Bisakah kita mengurangi kompleksitas perkembangannya. <br><br><h3>  Apa itu efisiensi? </h3><br>  Mari kita tentukan apa itu efisiensi.  Dari sudut pandang pengembangan antarmuka pengguna, efisiensi berarti: <br><br><ul><li>  kecepatan pengembangan </li><li>  jumlah bug </li><li>  jumlah uang yang dihabiskan ... </li></ul><br>  Ada definisi yang sangat bagus: <br><br><blockquote>  Efisiensi adalah melakukan lebih banyak dengan lebih sedikit </blockquote><br>  Setelah penentuan ini, Anda dapat meletakkan apa pun yang Anda inginkan - menghabiskan lebih sedikit waktu, lebih sedikit usaha.  Misalnya, "jika Anda menulis lebih sedikit kode, izinkan lebih sedikit bug" dan mencapai tujuan yang sama.  Secara umum, kami menghabiskan banyak usaha dengan sia-sia.  Dan efisiensi adalah tujuan yang agak tinggi - untuk menghilangkan kerugian ini dan hanya melakukan apa yang dibutuhkan. <br><br><h3>  Apa itu kompleksitas? </h3><br>  Menurut saya, kompleksitas adalah masalah utama dalam pembangunan. <br><br>  Fred Brooks menulis sebuah artikel pada tahun 1986 berjudul No silver bullet.  Di dalamnya, ia merenungkan perangkat lunak.  Dalam perangkat keras, kemajuan sangat cepat, dan dengan perangkat lunak semuanya jauh lebih buruk.  Pertanyaan utama Fred Brooks - dapatkah ada teknologi yang mempercepat kita dengan urutan besarnya?  Dan dia sendiri memberikan jawaban pesimistis, menyatakan bahwa dalam perangkat lunak tidak mungkin untuk mencapai ini, menjelaskan posisinya.  Saya sangat merekomendasikan membaca artikel ini. <br><br>  Seorang teman saya mengatakan pemrograman UI adalah "masalah kotor".  Anda tidak dapat duduk sekali dan menghasilkan opsi yang tepat sehingga masalah terpecahkan selamanya.  Selain itu, selama 10 tahun terakhir, kompleksitas pembangunan hanya meningkat. <br><br><h3>  12 tahun yang lalu ... </h3><br>  Kami mulai mengembangkan sistem informasi medis 12 tahun yang lalu.  Pertama dengan flash.  Lalu kami melihat apa yang mulai dilakukan Gmail.  Kami menyukainya dan kami ingin beralih ke JavaScript dengan HTML. <br><br>  Faktanya, saat itu kami jauh di depan.  Kami mengambil dojo, dan sebenarnya kami memiliki semua yang sama seperti yang kami miliki sekarang.  Ada beberapa komponen yang cukup bagus di widget dojo, ada sistem modular build dan mengharuskan Google Clojure Compiler dibangun dan dikecilkan (RequireJS dan CommonJS bahkan tidak tercium saat itu). <br><br>  Semuanya berhasil.  Kami melihat Gmail, terinspirasi, berpikir bahwa semuanya baik-baik saja.  Pada awalnya, kami hanya menulis pembaca kartu pasien.  Kemudian mereka secara bertahap beralih ke otomatisasi alur kerja lain di rumah sakit.  Dan semuanya menjadi rumit.  Tim tampaknya profesional - tetapi setiap fitur mulai berderit.  Sensasi ini muncul 12 tahun yang lalu - dan masih tidak meninggalkan saya. <br><br><h3>  Cara rel + jQuery </h3><br>  Kami melakukan sertifikasi sistem, dan itu perlu untuk menulis portal pasien.  Ini adalah sistem di mana pasien dapat pergi dan melihat data medis mereka. <br><br>  Backend kami kemudian ditulis dalam Ruby on Rails.  Meskipun komunitas Ruby on Rails tidak terlalu besar, itu memiliki dampak besar pada industri.  Dari komunitas kecil Anda yang penuh gairah, semua manajer paket Anda, GitHub, Git, make-up otomatis, dll. Telah datang. <br><br>  Inti dari tantangan yang kami hadapi adalah bahwa kami harus mengimplementasikan portal pasien dalam dua minggu.  Dan kami memutuskan untuk mencoba cara Rails - untuk melakukan segalanya di server.  Web 2.0 yang klasik.  Dan mereka melakukannya - mereka benar-benar melakukannya dalam dua minggu. <br><br>  Kami berada di depan seluruh planet: kami melakukan SPA, kami memiliki API REST, tetapi untuk beberapa alasan itu tidak efektif.  Beberapa fitur sudah dapat membuat unit, karena hanya mereka yang mampu mengakomodasi semua kompleksitas komponen ini, hubungan backend dengan frontend.  Dan ketika kami mengambil Rails way - sedikit ketinggalan jaman oleh standar kami, fitur tiba-tiba mulai memukau.  Pengembang rata-rata mulai meluncurkan fitur dalam beberapa hari.  Dan kami bahkan mulai menulis tes sederhana. <br><br>  Atas dasar ini, saya sebenarnya masih mengalami cedera: ada pertanyaan.  Ketika kami beralih dari Java ke Rails di backend, efisiensi pengembangan meningkat sekitar 10 kali lipat.  Tetapi ketika kami mencetak skor di SPA, efisiensi pengembangan juga meningkat secara signifikan.  Bagaimana bisa begitu? <br><br><h3>  Mengapa Web 2.0 efektif? </h3><br>  Mari kita mulai dengan pertanyaan lain: mengapa kita membuat satu aplikasi halaman, mengapa kita meyakininya? <br><br>  Mereka hanya memberi tahu kami: kami perlu melakukan ini - dan kami melakukannya.  Dan sangat jarang mempertanyakannya.  Apakah arsitektur REST API dan SPA benar?  Apakah ini benar-benar cocok untuk kasing tempat kami menggunakannya?  Kami tidak berpikir. <br><br>  Di sisi lain, ada contoh-contoh sebaliknya yang luar biasa.  Semua orang menggunakan GitHub.  Apakah Anda tahu bahwa GitHub bukan aplikasi satu halaman?  GitHub adalah aplikasi "rail" reguler yang diberikan di server dan di mana ada beberapa widget.  Adakah yang mengalami tepung dari ini?  Saya pikir ada tiga orang.  Sisanya bahkan tidak memperhatikan.  Ini tidak mempengaruhi pengguna dengan cara apa pun, tetapi pada saat yang sama, untuk beberapa alasan, kami harus membayar 10 kali lebih banyak untuk pengembangan aplikasi lain (baik kekuatan, kompleksitas, dll.).  Contoh lain adalah Basecamp.  Twitter dulunya hanya aplikasi Rails. <br><br>  Bahkan, ada begitu banyak aplikasi Rails.  Ini sebagian ditentukan oleh jenius DHH (David Heinemeier Hansson, pencipta Ruby on Rails).  Ia mampu menciptakan alat yang berfokus pada bisnis, yang memungkinkan Anda untuk segera melakukan apa yang Anda butuhkan, tanpa terganggu oleh masalah teknis. <br><br>  Ketika kami menggunakan cara Rails, tentu saja, ada banyak ilmu hitam.  Ketika kami secara bertahap berkembang, kami beralih dari Ruby ke Clojure, praktis mempertahankan efisiensi yang sama, tetapi membuat semuanya menjadi lebih mudah.  Dan itu luar biasa. <br><br><h3>  12 tahun telah berlalu </h3><br>  Seiring waktu, tren baru mulai muncul di frontend. <br><br>  Kami sepenuhnya mengabaikan Backbone, karena aplikasi dojo yang kami tulis sebelumnya bahkan lebih canggih daripada yang ditawarkan Backbone. <br><br>  Lalu datanglah Angular.  Itu adalah "sinar cahaya" yang agak menarik - dari sudut pandang efisiensi, Angular sangat bagus.  Anda mengambil pengembang rata-rata, dan dia memusatkan fitur.  Namun dari sudut pandang kesederhanaan, Angular membawa banyak masalah - itu buram, rumit, ada arloji, pengoptimalan, dll. <br><br>  Bereaksi muncul, yang membawa sedikit kesederhanaan (setidaknya keterusterangan render, yang, karena Virtual DOM, memungkinkan kita setiap saat seolah-olah hanya menggambar ulang, hanya memahami dan hanya menulis).  Tetapi dalam hal efisiensi, jujur â€‹â€‹saja, Bereaksi secara signifikan mendorong kami kembali. <br><br>  Yang terburuk adalah bahwa tidak ada yang berubah dalam 12 tahun.  Kami masih melakukan hal yang sama seperti itu.  Sudah waktunya untuk berpikir - ada yang salah di sini. <br><br>  Fred Brooks mengatakan ada dua masalah dengan pengembangan perangkat lunak.  Tentu saja, ia melihat masalah utama dalam kompleksitas, tetapi ia membaginya menjadi dua kelompok: <br><br><ul><li>  kompleksitas signifikan yang berasal dari tugas itu sendiri.  Itu tidak bisa dibuang begitu saja, karena itu adalah bagian dari tugas. </li><li>  kompleksitas acak adalah yang kami bawa untuk menyelesaikan masalah ini. </li></ul><br>  Pertanyaannya adalah, apa keseimbangan di antara mereka.  Inilah tepatnya yang sedang kita diskusikan. <br><br><h3>  Mengapa begitu menyakitkan untuk melakukan User Interface? </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d22/667/d4e/d22667d4e3249034be27b07250a635ff.png"><br><br>  Menurut saya alasan pertama adalah model aplikasi mental kita.  Komponen yang bereaksi adalah pendekatan OOP murni.  Sistem kami adalah grafik dinamis dari objek yang bisa berubah yang saling berhubungan.  Jenis yang menyelesaikan Turing secara konstan menghasilkan simpul-simpul pada grafik ini, beberapa simpul hilang.  Pernahkah Anda mencoba membayangkan aplikasi Anda di kepala Anda?  Ini menakutkan!  Saya biasanya menyajikan aplikasi OOP seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cd/7b4/c7a/7cd7b4c7a846d2e973b012d566945a19.png"><br><br>  Saya merekomendasikan membaca tesis Roy Fielding (penulis arsitektur REST).  Disertasinya berjudul "Gaya Arsitektur dan Desain Perangkat Lunak Berbasis Jaringan."  Pada awalnya ada pengantar yang sangat baik, di mana ia berbicara tentang bagaimana untuk sampai ke arsitektur secara umum, dan memperkenalkan konsep-konsep: memecah sistem menjadi komponen dan hubungan antara komponen-komponen ini.  Ini memiliki arsitektur "nol", di mana semua komponen berpotensi dikaitkan dengan semua.  Ini adalah kekacauan arsitektur.  Ini adalah representasi objek kami dari antarmuka pengguna. <br><br>  Roy Fielding merekomendasikan mencari dan memaksakan serangkaian kendala, karena itu adalah serangkaian kendala yang menentukan arsitektur Anda. <br><br>  Mungkin yang paling penting adalah bahwa pembatasan adalah teman arsitek.  Cari batasan nyata ini dan rancang sebuah sistem darinya.  Karena kebebasan itu jahat.  Kebebasan berarti Anda memiliki sejuta opsi yang dapat Anda pilih, dan bukan kriteria tunggal yang dengannya Anda dapat menentukan apakah pilihan itu benar.  Cari kendala dan bangunlah. <br><br>  Ada artikel bagus yang disebut OUT OF THE TAR PIT ("Lebih mudah daripada lubang tar"), di mana orang-orang setelah Brooks memutuskan untuk menganalisis apa yang sebenarnya berkontribusi pada kompleksitas aplikasi.  Mereka sampai pada kesimpulan yang mengecewakan bahwa sistem yang dapat berubah dan menyebar negara adalah sumber utama kompleksitas.  Di sini dimungkinkan untuk menjelaskan secara murni kombinasi - jika Anda memiliki dua sel, dan di masing-masingnya sebuah bola bisa berbohong (atau tidak berbohong), berapa banyak keadaan yang mungkin?  - Empat. <br><br>  Jika tiga sel - 2 <sup>3</sup> , jika 100 sel - 2 <sup>100</sup> .  Jika Anda mempresentasikan aplikasi Anda dan memahami seberapa banyak status kabur, Anda menyadari bahwa ada sejumlah kemungkinan kondisi sistem Anda.  Jika pada saat yang sama Anda tidak dibatasi oleh apa pun, itu terlalu sulit.  Dan otak manusia lemah, ini sudah dibuktikan oleh berbagai penelitian.  Kita dapat memegang hingga tiga elemen di kepala kita sekaligus.  Ada yang mengatakan tujuh, tetapi bahkan untuk ini otak menggunakan peretasan.  Karena itu, kompleksitas adalah masalah bagi kami. <br><br>  Saya sarankan membaca artikel ini, di mana orang-orang sampai pada kesimpulan bahwa sesuatu harus dilakukan dengan keadaan yang bisa berubah ini.  Misalnya, ada database relasional, Anda dapat menghapus seluruh status yang bisa berubah di sana.  Dan sisanya dilakukan dengan gaya fungsional murni.  Dan mereka hanya datang dengan ide pemrograman fungsional-relasional. <br><br>  Jadi masalahnya berasal dari fakta bahwa: <br><br><ul><li>  pertama, kami tidak memiliki model antarmuka pengguna tetap yang baik.  Pendekatan komponen membawa kita ke neraka yang ada.  Kami tidak memaksakan batasan apa pun, kami menyebarkan keadaan yang bisa berubah, akibatnya, kompleksitas sistem pada titik tertentu hanya menghancurkan kami; <br></li><li>  kedua, jika kita menulis aplikasi backend - frontend klasik, itu sudah merupakan sistem terdistribusi.  Dan aturan pertama dari sistem terdistribusi adalah jangan membuat sistem terdistribusi (Hukum Pertama Desain Objek Terdistribusi: Jangan mendistribusikan objek Anda - oleh Martin Fowler), karena Anda segera meningkatkan kompleksitas dengan urutan besarnya.  Siapa pun yang menulis integrasi memahami bahwa segera setelah Anda memasuki interaksi antar sistem, semua perkiraan proyek dapat dikalikan dengan 10. Tetapi kami hanya melupakannya dan beralih ke sistem terdistribusi.  Ini mungkin pertimbangan utama ketika kami beralih ke Rails, mengembalikan semua kontrol ke server. <br></li></ul><br>  Semua ini terlalu keras bagi otak manusia yang buruk.  Mari kita pikirkan apa yang dapat kita lakukan dengan dua masalah ini - kurangnya batasan dalam arsitektur (grafik objek yang bisa berubah) dan transisi ke sistem terdistribusi yang begitu rumit sehingga para akademisi masih bingung bagaimana melakukannya dengan benar (pada saat yang sama, kami bunuh diri kita sendiri terhadap siksaan-siksaan ini dalam aplikasi bisnis yang paling sederhana)? <br><br><h3>  Bagaimana backend berevolusi? </h3><br>  Jika kita menulis backend dengan gaya yang sama seperti kita menciptakan UI sekarang, akan ada "kekacauan berdarah" yang sama.  Kami akan menghabiskan banyak waktu untuk itu.  Jadi benar-benar pernah mencoba melakukannya.  Kemudian secara bertahap mereka mulai memberlakukan batasan. <br><br>  Penemuan backend besar pertama adalah database. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/777/d5a/8aa/777d5a8aa62a6623e0918cdc57abdbee.png"><br><br>  Pada awalnya, dalam program itu, seluruh negara bagian tergantung secara tidak dapat dijelaskan di mana, dan sulit untuk mengelolanya.  Seiring waktu, para pengembang datang dengan database dan menghapus seluruh status di sana. <br><br>  Perbedaan menarik pertama antara database adalah bahwa data tidak ada beberapa objek dengan perilaku mereka sendiri, ini adalah informasi murni.  Ada tabel atau beberapa struktur data lainnya (misalnya, JSON).  Mereka tidak memiliki perilaku, dan ini juga sangat penting.  Karena perilaku adalah interpretasi informasi, dan mungkin ada banyak interpretasi.  Dan fakta dasar - mereka tetap mendasar. <br><br>  Poin penting lainnya adalah bahwa pada database ini kami memiliki bahasa query seperti SQL.  Dari sudut pandang keterbatasan, dalam kebanyakan kasus SQL bukan bahasa Turing-lengkap, itu lebih sederhana.  Di sisi lain, ini deklaratif - lebih ekspresif, karena dalam SQL Anda mengatakan "apa", bukan "bagaimana".  Misalnya, ketika Anda menggabungkan dua label dalam SQL, SQL memutuskan bagaimana melakukan operasi ini secara efisien.  Ketika Anda mencari sesuatu, dia mengambil indeks untuk Anda.  Anda tidak pernah secara eksplisit menyatakan ini.  Jika Anda mencoba menggabungkan sesuatu dalam JavaScript, Anda harus menulis banyak kode untuk ini. <br><br>  Di sini, sekali lagi, penting bahwa kita telah memberlakukan batasan dan sekarang kita pergi ke pangkalan ini melalui bahasa yang lebih sederhana dan lebih ekspresif.  Kompleksitas yang didistribusikan kembali. <br><br>  Setelah backend memasuki pangkalan, aplikasi menjadi stateless.  Ini mengarah ke efek menarik - sekarang, misalnya, kita mungkin tidak takut untuk memperbarui aplikasi (keadaan tidak menggantung di lapisan aplikasi dalam memori, yang akan hilang jika aplikasi restart).  Untuk lapisan aplikasi, stateless adalah fitur yang bagus dan kendala yang sangat baik.  Kenakan jika Anda bisa.  Selain itu, aplikasi baru dapat ditarik ke pangkalan lama, karena fakta dan interpretasi mereka bukan hal yang terkait. <br><br>  Dari sudut pandang ini, objek dan kelas mengerikan karena merekatkan perilaku dan informasi.  Informasi lebih kaya, ia hidup lebih lama.  Basis data dan fakta bertahan kode ditulis dalam Delphi, Perl, atau JavaScript. <br><br>  Ketika backend datang ke arsitektur seperti itu, semuanya menjadi lebih sederhana.  Era emas Web 2.0 telah tiba.  Dimungkinkan untuk mendapatkan sesuatu dari basis data, mengarahkan data ke templating (fungsi murni) dan mengembalikan HTML-ku, yang dikirim ke browser. <br><br>  Kami belajar cara menulis aplikasi yang cukup kompleks di backend.  Dan sebagian besar aplikasi ditulis dengan gaya ini.  Tapi begitu backend mengambil langkah ke samping - ke dalam ketidakpastian - masalah mulai lagi. <br><br>  Orang-orang mulai memikirkannya dan muncul dengan ide membuang PLO dan ritual. <br><br>  Apa yang sebenarnya dilakukan sistem kita?  Mereka mengambil informasi dari suatu tempat - dari pengguna, dari sistem lain dan sejenisnya - memasukkannya ke dalam basis data, mengubahnya, entah bagaimana memeriksanya.  Dari pangkalan mereka mengeluarkannya dengan pertanyaan licik (analitik atau sintetik) dan mengembalikannya.  Itu saja.  Dan ini penting untuk dipahami.  Dari sudut pandang ini, simulasi adalah konsep yang sangat salah dan buruk. <br><br>  Tampak bagi saya bahwa secara umum seluruh OOP sebenarnya lahir dari UI.  Orang-orang mencoba mensimulasikan dan mensimulasikan antarmuka pengguna.  Mereka melihat objek grafis tertentu pada monitor dan berpikir: akan menyenangkan untuk merangsangnya dalam runtime kita, beserta propertinya, dll.  Seluruh cerita ini sangat terkait erat dengan OOP.  Tetapi simulasi adalah cara yang paling mudah dan naif untuk menyelesaikan tugas.  Hal-hal menarik dilakukan ketika Anda minggir.  Dari sudut pandang ini, lebih penting untuk memisahkan informasi dari perilaku, menyingkirkan benda-benda aneh ini, dan semuanya akan menjadi lebih mudah: server web Anda menerima string HTTP, mengembalikan string respons HTTP.  Jika Anda menambahkan basis ke persamaan, Anda mendapatkan fungsi umumnya murni: server menerima basis dan permintaan, mengembalikan basis dan respons baru (data yang dimasukkan - data tersisa). <br><br>  Sepanjang penyederhanaan ini, fungsionaris membuang â…” bagasi yang telah menumpuk di backend.  Dia tidak dibutuhkan, itu hanya ritual.  Kami masih bukan game dev - kami tidak membutuhkan pasien dan dokter untuk hidup dalam runtime, bergerak dan melacak koordinat mereka.  Model informasi kami adalah sesuatu yang lain.  Kami tidak berpura-pura menjadi obat, penjualan, atau apa pun.  Kami menciptakan sesuatu yang baru di persimpangan.  Misalnya, Uber tidak mensimulasikan perilaku operator dan mesin - ia memperkenalkan model informasi baru.  Di bidang kami, kami juga menciptakan sesuatu yang baru, sehingga Anda dapat merasakan kebebasan. <br><br>  Tidak perlu mencoba untuk mensimulasikan sepenuhnya - buat. <br><br><h3>  Clojure = JS-- </h3><br>  Saatnya untuk memberi tahu Anda dengan tepat bagaimana Anda bisa membuang semuanya.  Dan di sini saya ingin menyebutkan Clojure Script.  Bahkan, jika Anda tahu JavaScript, Anda tahu Clojure.  Di Clojure, kami tidak menambahkan fitur ke JavaScript, tetapi menghapusnya. <br><br><ul><li>  Kami membuang sintaks - di Clojure (dalam Lisp) tidak ada sintaks.  Dalam bahasa biasa, kami menulis beberapa kode, yang kemudian diuraikan dan AST diperoleh, yang dikompilasi dan dieksekusi.  Di Lisp, kami segera menulis AST yang dapat dieksekusi - ditafsirkan atau dikompilasi. <br></li><li>  Kami membuang sifat berubah-ubah.  Tidak ada objek atau array yang dapat berubah di Clojure.  Setiap operasi menghasilkan seolah-olah salinan baru.  Apalagi salinan ini sangat murah.  Itu cerdik dibuat menjadi murah.  Dan ini memungkinkan kita untuk bekerja, seperti dalam matematika, dengan nilai-nilai.  Kami tidak mengubah apa pun - kami menciptakan sesuatu yang baru.  Aman, mudah. <br></li><li>  Kami melempar kelas, game dengan prototipe, dll.  Ini tidak ada. </li></ul><br>  Akibatnya, kami masih memiliki fungsi dan struktur data yang kami operasikan, serta primitif.  Ini seluruh Clojure.  Dan di atasnya Anda dapat melakukan hal yang sama dengan yang Anda lakukan dalam bahasa lain, di mana ada banyak alat tambahan yang tidak ada yang tahu cara menggunakannya. <br><br><h4>  Contohnya </h4><br>  Bagaimana kita bisa sampai ke Lisp melalui AST?  Berikut ini adalah ungkapan klasik: <br><br><pre><code class="hljs lisp">(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>) - <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Jika kita mencoba menulis AST-nya, misalnya, dalam bentuk array, di mana head adalah tipe node, dan apa yang berikutnya adalah parameter, kita akan mendapatkan sesuatu yang serupa (kita mencoba menulis ini dalam Java Script): <br><br><pre> <code class="hljs json">['minus', ['plus', <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre><br>  Sekarang buang tanda kutip ekstra, kita dapat mengganti tanda minus dengan <code>-</code> , dan tanda tambah dengan <code>+</code> .  Buang koma yang merupakan spasi putih di Lisp.  Kami akan mendapatkan AST yang sama: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">-</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Dan di Lisp, kita semua menulis seperti ini.  Kita dapat memeriksa - ini adalah fungsi matematika murni (emacs saya terhubung ke browser; Saya letakkan script di sana, itu mengevaluasi perintah di sana dan mengirimkannya kembali ke emacs - Anda melihat nilai setelah simbol <code>=&gt;</code> ): <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">-</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Kami juga dapat mendeklarasikan fungsi: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> xplus [ab] (<span class="hljs-name"><span class="hljs-name">+</span></span> ab)) ((<span class="hljs-name"><span class="hljs-name">fn</span></span> [xy] (<span class="hljs-name"><span class="hljs-name">*</span></span> xy)) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Atau fungsi anonim.  Mungkin ini terlihat sedikit menakutkan: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">type</span></span> xplus)</code> </pre><br>  Jenisnya adalah fungsi JavaScript: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> xplus) =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">Function</span></span>]</code> </pre><br>  Kita bisa menyebutnya dengan mengirimkan parameter: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">xplus</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br>  Artinya, semua yang kita lakukan adalah menulis AST, yang kemudian dikompilasi ke dalam JS atau bytecode, atau ditafsirkan. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> mymin [ab] (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">a</span></span> &gt; b) ba))</code> </pre><br>  Clojure adalah bahasa yang di-host.  Oleh karena itu, diperlukan primitif dari runtime induk, yaitu, dalam kasus Clojure Script, kita akan memiliki tipe JavaScript: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[Number]</code> </pre><br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> "string") =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[String]</code> </pre><br>  Jadi regexp ditulis: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> #"^Cl.*$") =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[RegExp]</code> </pre><br>  Fungsi yang kami miliki adalah fungsi: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> (fn [x] x)) =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">Function</span></span>]</code> </pre><br>  Selanjutnya kita membutuhkan beberapa jenis komposit. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> user {<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-string"><span class="hljs-string">"niquola"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:city</span></span> <span class="hljs-string"><span class="hljs-string">"SPb"</span></span>} <span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> [{<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"github"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://â€¦.."</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"twitter"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://â€¦.."</span></span>}] <span class="hljs-symbol"><span class="hljs-symbol">:age</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span>} (<span class="hljs-name"><span class="hljs-name">type</span></span> user)</code> </pre><br>  Ini dapat dibaca seolah-olah Anda sedang membuat objek dalam JavaScript: <br><br><pre> <code class="hljs pgsql">(def <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> {<span class="hljs-type"><span class="hljs-type">name</span></span>: "niquola" â€¦</code> </pre><br>  Di Clojure, ini disebut hashmap.  Ini adalah wadah di mana nilai-nilai terletak.  Jika tanda kurung digunakan - maka ini disebut vektor - ini adalah array Anda: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> user {<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-string"><span class="hljs-string">"niquola"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:city</span></span> <span class="hljs-string"><span class="hljs-string">"SPb"</span></span>} <span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> [{<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"github"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://â€¦.."</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"twitter"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://â€¦.."</span></span>}] <span class="hljs-symbol"><span class="hljs-symbol">:age</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span>} =&gt; #'intro/user (<span class="hljs-name"><span class="hljs-name">type</span></span> user)</code> </pre><br>  Kami mencatat informasi apa pun dengan hashmaps dan vektor. <br><br>  Nama titik dua yang aneh ( <code>:name</code> ) adalah karakter yang disebut: string konstan yang dibuat untuk digunakan sebagai kunci dalam hashmaps.  Dalam bahasa yang berbeda mereka disebut berbeda - simbol, sesuatu yang lain.  Tapi ini bisa diambil hanya sebagai string konstan.  Mereka cukup efektif - Anda dapat menulis nama panjang dan tidak menghabiskan banyak sumber daya untuk itu, karena mereka terhubung (mis. Mereka tidak diulang). <br><br>  Clojure menyediakan ratusan fungsi untuk menangani struktur data generik dan primitif ini.  Kami dapat menambahkan, menambahkan kunci baru.  Selain itu, kami selalu memiliki salinan semantik, yaitu, setiap kali kami mendapatkan salinan baru.  Pertama, Anda harus terbiasa dengannya, karena Anda tidak lagi dapat menyimpan sesuatu, seperti sebelumnya, di suatu tempat dalam variabel, dan kemudian mengubah nilai ini.  Perhitungan Anda harus selalu langsung - semua argumen harus diteruskan ke fungsi secara eksplisit. <br><br>  Ini mengarah pada hal yang penting.  Dalam bahasa fungsional, fungsi adalah komponen yang ideal karena ia menerima semuanya secara eksplisit pada input.  Tidak ada tautan tersembunyi yang menyimpang dalam sistem.  Anda dapat mengambil fungsi dari satu tempat, memindahkannya ke tempat lain, dan menggunakannya di sana. <br><br>  Di Clojure, kami memiliki operasi kesetaraan yang sangat baik dalam nilai bahkan untuk tipe komposit kompleks: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">=</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:a</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:a</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>}) =&gt; true</code> </pre><br>  Dan operasi ini murah karena fakta bahwa struktur tidak berujung yang licik dapat dibandingkan hanya dengan referensi.  Karena itu, bahkan sebuah hashmap dengan jutaan kunci dapat kita bandingkan dalam satu operasi. <br><br>  Ngomong-ngomong, orang-orang dari React hanya menyalin implementasi Clojure dan membuat JS abadi. <br><br>  Clojure juga memiliki banyak operasi, misalnya, mendapatkan sesuatu dari jalan bersarang di hashmap: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">get-in</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:city</span></span>])</code> </pre><br>  Masukkan sesuatu di sepanjang jalan bersarang di hashmap: <br><br><pre> <code class="hljs ruby">(assoc-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:city</span></span>] <span class="hljs-string"><span class="hljs-string">"LA"</span></span>) =&gt; {<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-string"><span class="hljs-string">"niquola"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:city</span></span> <span class="hljs-string"><span class="hljs-string">"LA"</span></span>}, <span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> [{<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"github"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://â€¦.."</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"twitter"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://â€¦.."</span></span>}], <span class="hljs-symbol"><span class="hljs-symbol">:age</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span>}</code> </pre><br>  Perbarui beberapa nilai: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">update-in</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span>] (<span class="hljs-name"><span class="hljs-name">fn</span></span> [old] (<span class="hljs-name"><span class="hljs-name">str</span></span> old <span class="hljs-string"><span class="hljs-string">"+++++"</span></span>)))</code> </pre><br>  Pilih hanya kunci tertentu: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">select-keys</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span>])</code> </pre><br>  Hal yang sama dengan vektor: <br><br><pre> <code class="hljs pgsql">(def clojurists [{:<span class="hljs-type"><span class="hljs-type">name</span></span> "Rich"} {:<span class="hljs-type"><span class="hljs-type">name</span></span> "Micael"}]) (first clojurists) (second clojurists) =&gt; {:<span class="hljs-type"><span class="hljs-type">name</span></span> "Michael"}</code> </pre><br>  Ada ratusan operasi dari pustaka dasar yang memungkinkan Anda untuk beroperasi pada struktur data ini.  Ada interop dengan tuan rumah.  Anda harus terbiasa sedikit: <br><br><pre> <code class="hljs pgsql">(js/alert "Hello!") =&gt; nil &lt;/csource&gt;         "".    <span class="hljs-keyword"><span class="hljs-keyword">location</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>: &lt;source lang="clojure"&gt; (.-<span class="hljs-keyword"><span class="hljs-keyword">location</span></span> js/<span class="hljs-keyword"><span class="hljs-keyword">window</span></span>)</code> </pre><br>  Ada setiap gula yang harus dikonsumsi: <br><br><pre> <code class="hljs pgsql">(.. js/<span class="hljs-keyword"><span class="hljs-keyword">window</span></span> -<span class="hljs-keyword"><span class="hljs-keyword">location</span></span> -href) =&gt; "http://localhost:3000/#/billing/dashboard"</code> </pre><br><pre> <code class="hljs pgsql">(.. js/<span class="hljs-keyword"><span class="hljs-keyword">window</span></span> -<span class="hljs-keyword"><span class="hljs-keyword">location</span></span> -host) =&gt; "localhost:3000"</code> </pre><br>  Saya dapat mengambil tanggal JS dan mengembalikan tahun darinya: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">let</span></span> [d (<span class="hljs-name"><span class="hljs-name">js/Date</span></span>.)] (.getFullYear d)) =&gt; <span class="hljs-number"><span class="hljs-number">2018</span></span></code> </pre><br>  Rich Hickey, pencipta Clojure, telah sangat membatasi kami.  Kami benar-benar tidak memiliki hal lain, jadi kami melakukan semuanya melalui struktur data umum.  Misalnya, ketika kita menulis SQL, kita biasanya menulisnya dengan struktur data.  Jika Anda perhatikan dengan teliti, Anda akan melihat bahwa ini hanyalah sebuah hashmap di mana sesuatu tertanam.  Lalu ada beberapa fungsi yang menerjemahkan semua ini menjadi string SQL: <br><br><pre> <code class="hljs ruby">{select [<span class="hljs-symbol"><span class="hljs-symbol">:*</span></span>] <span class="hljs-symbol"><span class="hljs-symbol">:from</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:users</span></span>] <span class="hljs-symbol"><span class="hljs-symbol">:where</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>= <span class="hljs-symbol"><span class="hljs-symbol">:id</span></span> <span class="hljs-string"><span class="hljs-string">"user-1"</span></span>]} =&gt; {<span class="hljs-symbol"><span class="hljs-symbol">:select</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:*</span></span>], <span class="hljs-symbol"><span class="hljs-symbol">:from</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:users</span></span>], <span class="hljs-symbol"><span class="hljs-symbol">:where</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>= <span class="hljs-symbol"><span class="hljs-symbol">:id</span></span> <span class="hljs-string"><span class="hljs-string">"user-1"</span></span>]}</code> </pre><br>  Kami juga menulis routings dengan struktur data dan struktur data typeset: <br><br><pre> <code class="hljs ruby">{<span class="hljs-string"><span class="hljs-string">"users"</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:get</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:handler</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:users-list</span></span>}} <span class="hljs-symbol"><span class="hljs-symbol">:get</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:handler</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:welcome-page</span></span>}}</code> </pre><br><pre> <code class="hljs json">[:div.row [:div {:on-click #(.log js/console <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>)} <span class="hljs-string"><span class="hljs-string">"User "</span></span>]]</code> </pre><br><h3>  DB di UI </h3><br>  Jadi, kami membahas Clojure.  Tapi saya sebutkan sebelumnya bahwa pencapaian besar di backend adalah database.  Jika Anda melihat apa yang terjadi di frontend sekarang, kita akan melihat bahwa orang-orang menggunakan pola yang sama - mereka memasukkan basis data di Antarmuka Pengguna (dalam satu aplikasi halaman). <br><br>  Database diperkenalkan dalam elm-architecture, dalam Clojure-scripted re-frame, dan bahkan dalam beberapa bentuk terbatas dalam fluks dan redux (plugin tambahan harus diatur di sini untuk mengajukan permintaan).  Arsitektur Elm, bingkai ulang dan fluks diluncurkan pada waktu yang hampir bersamaan dan dipinjam dari satu sama lain.  Kami menulis di bingkai ulang.  Selanjutnya, saya akan berbicara sedikit tentang cara kerjanya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ff/11e/ddf/8ff11eddf7c9e2eb3254a3d9eee47d3d.png"><br><br>  Event (ini mirip redux) terbang keluar dari view-chi, yang ditangkap oleh pengontrol tertentu.  Kontroler yang kami sebut event-handler.  Event-handler memancarkan efek, yang juga seseorang ditafsirkan oleh struktur data. <br><br>  Salah satu jenis efek adalah memperbarui basis data.  Artinya, dibutuhkan nilai database saat ini dan mengembalikan yang baru.  Kami juga memiliki langganan - analog permintaan di backend.  Yaitu, ini adalah beberapa pertanyaan reaktif yang bisa kita lemparkan ke database ini.  Permintaan-permintaan reaktif ini, kami kemudian menyatukan pandangan.  Dalam kasus reaksi, kami tampaknya sepenuhnya menggambar ulang, dan jika hasil dari permintaan ini telah berubah - ini nyaman. <br>  Bereaksi hadir dengan kita hanya di suatu tempat di bagian paling akhir, dan secara umum arsitektur tidak terhubung dengan itu.  Itu terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42b/655/922/42b65592288ba93676e13b086f3f48b7.png"><br><br>  Di sini ditambahkan apa yang hilang, misalnya, di redux-s. <br><br>  Pertama, kami memisahkan efeknya.  Aplikasi frontend tidak mandiri.  Dia memiliki backend tertentu - sejenis, "sumber kebenaran".  Aplikasi harus terus menulis sesuatu di sana dan membaca sesuatu dari sana.  Lebih buruk lagi, jika ia memiliki beberapa backend yang seharusnya.  Dalam implementasi paling sederhana, ini bisa dilakukan langsung di action creater - di controller Anda, tetapi ini buruk.  Oleh karena itu, orang-orang dari bingkai ulang memperkenalkan tingkat tipuan tambahan: struktur data tertentu terbang keluar dari controller, yang mengatakan apa yang perlu dilakukan.  Dan posting ini memiliki penangan sendiri yang melakukan pekerjaan kotor.  Ini adalah pengantar yang sangat penting, yang akan kita bahas nanti. <br><br>  Ini juga penting (kadang-kadang mereka melupakannya) - beberapa fakta dasar harus ada di pangkalan.  Segala sesuatu yang lain dapat dihapus dari database - dan permintaan biasanya melakukan ini, mereka mengubah data - mereka tidak menambahkan informasi baru, tetapi dengan benar menyusun yang sudah ada.  Kami membutuhkan pertanyaan ini.  Dalam redux, menurut pendapat saya, ini sekarang menyediakan pilihan kembali, dan dalam bingkai kami memilikinya di luar kotak (built-in). <br><br>  Lihatlah diagram arsitektur kami.  Kami mereproduksi backend kecil (dalam gaya Web 2.0) dengan basis, pengontrol, tampilan.  Satu-satunya hal yang ditambahkan adalah reaktivitas.  Ini sangat mirip dengan MVC, kecuali bahwa semuanya ada di satu tempat.  Setelah MVC awal untuk setiap widget dibuat model mereka sendiri, tetapi di sini semuanya dilipat menjadi satu basis.  Pada prinsipnya, Anda dapat menyinkronkan dengan backend dari controller melalui efek, Anda bisa tampil dengan tampilan yang lebih umum sehingga database berfungsi seperti proxy ke backend.  Bahkan ada beberapa jenis algoritma generik: Anda menulis ke database lokal Anda, dan menyinkronkannya dengan yang utama. <br><br>  Sekarang dalam kebanyakan kasus, basis hanyalah beberapa jenis objek di mana kita menulis sesuatu dalam redux.  Tetapi pada prinsipnya, orang dapat membayangkan bahwa lebih lanjut ia akan berkembang menjadi basis data lengkap dengan bahasa query yang kaya.  Mungkin dengan semacam sinkronisasi umum.  Sebagai contoh, ada datomik - database logis tiga-toko yang berjalan langsung di browser.  Anda mengambilnya dan menempatkan seluruh negara Anda di sana.  Datomic memiliki bahasa query yang cukup kaya, sebanding dengan kekuatan SQL, dan bahkan menang di suatu tempat.  Contoh lain adalah Google menulis lovefield.  Semuanya akan pindah ke suatu tempat di sana. <br><br>  Selanjutnya saya akan menjelaskan mengapa kita perlu berlangganan reaktif. <br><br>  Sekarang kita mendapatkan persepsi naif pertama - kita mendapatkan pengguna dari backend, menaruhnya di database, dan kemudian kita perlu menggambarnya.  Pada saat rendering, banyak logika tertentu terjadi, tetapi kami mencampurnya dengan rendering, dengan view.  Jika kami segera mulai merender pengguna ini, kami mendapatkan bagian besar yang rumit yang melakukan sesuatu dengan Virtual DOM dan yang lainnya.  Dan itu dicampur dengan model logis dari pandangan kita. <br><br>  Konsep yang sangat penting yang perlu dipahami: karena kompleksitas UI, itu juga perlu dimodelkan.  Adalah perlu untuk memisahkan bagaimana itu ditarik (seperti yang terlihat) dari model logisnya.  Maka model logis akan lebih stabil.  Anda tidak dapat membebani dengan ketergantungan pada kerangka kerja tertentu - Angular, React atau VueJS.  Model adalah warga negara kelas satu yang biasa di runtime Anda.  Idealnya, jika itu hanya beberapa data dan satu set fungsi di atasnya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7b/52f/9c3/c7b52f9c3c048a91276c3ae8dcd33771.png"><br><br>  Artinya, dari model backend (objek), kita bisa mendapatkan model tampilan di mana, tanpa menggunakan rendering apa pun, kita dapat membuat kembali model logis.  Jika ada semacam menu atau yang serupa - semua ini dapat dilakukan dalam model tampilan. <br><br><h3>  Mengapa </h3><br>  Kenapa kita semua melakukan ini? <br><br>  Saya telah melihat tes UI yang baik hanya di mana ada staf 10 penguji. <br>  Biasanya tidak ada pengujian UI.  Oleh karena itu, kami mencoba untuk mendorong logika ini keluar dari komponen dalam model tampilan.  Kurangnya tes adalah pertanda sangat buruk, menunjukkan bahwa ada sesuatu yang salah di sana, entah bagaimana semuanya terstruktur dengan buruk. <br><br>  Mengapa UI sulit diuji?  Mengapa orang-orang di backend belajar cara menguji kode mereka, memberikan cakupan yang sangat besar dan sangat membantu untuk hidup dengan kode backend?  Mengapa UI salah?  Kemungkinan besar, kami melakukan sesuatu yang salah.  Dan semua yang saya jelaskan di atas benar-benar menggerakkan kami ke arah testabilitas. <br><br><h3>  Bagaimana cara kita melakukan tes? </h3><br>  Jika Anda melihat lebih dekat, bagian dari arsitektur kami, yang berisi pengontrol, berlangganan, dan basis data, bahkan tidak terkait dengan JS.  Artinya, ini adalah semacam model yang beroperasi hanya pada struktur data: kami menambahkannya di suatu tempat, entah bagaimana mengubah, mengeluarkan kueri.  Melalui efek, kita terputus dari interaksi dengan dunia luar.  Dan bagian ini sepenuhnya portabel.  Ini dapat ditulis dalam apa yang disebut cljc - ini adalah subset umum antara Clojure Script dan Clojure, yang berperilaku dengan cara yang sama di sana-sini.  Kita bisa memotong bagian ini dari frontend dan meletakkannya di JVM - di mana backend tinggal.  Kemudian kita dapat menulis efek lain di JVM, yang langsung mengenai titik akhir - itu menarik router tanpa konversi http-string, parsing, dll. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b2/b23/d1d/5b2b23d1d90d589a6cff9d99582d416d.png"><br><br>  Sebagai hasilnya, kita dapat menulis tes yang sangat sederhana - tes integral fungsional yang sama dengan yang orang-orang tulis di backend.  Kami melempar acara tertentu, itu melempar efek yang langsung menyentuh titik akhir di backend.  Dia mengembalikan sesuatu kepada kami, meletakkannya di database, menghitung langganan, dan di langganan terletak tampilan logis (kami menempatkan logika antarmuka pengguna di sana secara maksimal).  Kami menegaskan pandangan ini. <br><br>  Dengan demikian, kita dapat menguji 80% dari kode di backend, sementara semua alat pengembangan backend tersedia untuk kita.  Menggunakan perlengkapan atau beberapa pabrik, kita dapat menciptakan kembali situasi tertentu dalam database. <br><br>  Misalnya, kami memiliki pasien baru atau ada sesuatu yang tidak dibayar, dll.  Kita bisa melalui banyak kombinasi yang mungkin. <br><br>  Dengan demikian, kita dapat menangani masalah kedua - dengan sistem terdistribusi.  Karena kontrak antara sistem justru merupakan titik sakit utama, karena ini adalah dua runtime yang berbeda, dua sistem yang berbeda: backend mengubah sesuatu, dan sesuatu pecah pada frontend kami (Anda tidak dapat memastikan bahwa ini tidak akan terjadi). <br><br><h3>  Demonstrasi </h3><br>  Beginilah tampilannya dalam praktik.  Ini adalah pembantu backend yang membersihkan pangkalan dan menulis sedikit dunia ke dalamnya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/919/ef0/e23/919ef0e23883707631e051ff6c62acf6.png"><br><br>  Selanjutnya kita langganan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a1/bcb/35a/2a1bcb35a77444806d276e859f7aaebb.png"><br><br>  Biasanya URL sepenuhnya mendefinisikan halaman dan beberapa peristiwa dilemparkan - Anda sekarang pada halaman ini dan itu dengan seperangkat parameter.  Di sini kami masuk ke alur kerja baru dan langganan kami dikembalikan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/956/34e/776/95634e7760690ebbef5ce5bbc51de9d6.png"><br><br>  Di belakang layar, dia pergi ke pangkalan, mengambil sesuatu, memasukkannya ke pangkalan UI kami.  Berlangganan di atasnya berhasil dan disimpulkan dari itu Lihat model logis. <br><br>  Kami menginisialisasi itu.  Dan ini adalah model logis kami: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d84/ee7/e0a/d84ee7e0a7e22ab8da638d8488df8833.png"><br><br>  Bahkan tanpa melihat antarmuka Pengguna, kita dapat menebak apa yang akan ditarik sesuai dengan model ini: beberapa peringatan akan datang, beberapa informasi tentang pasien, pertemuan dan serangkaian tautan akan berbohong (ini adalah widget alur kerja yang mengarah di meja depan) dalam langkah-langkah tertentu ketika pasien tiba). <br><br>  Di sini kita datang dengan dunia yang lebih kompleks.  Mereka melakukan beberapa pembayaran dan juga diuji setelah inisialisasi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ea/032/f24/4ea032f24871cc57608dddf4687c30d7.png"><br><br>  Jika dia sudah membayar untuk kunjungan tersebut, dia akan melihat ini di antarmuka pengguna: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b8/71a/910/0b871a910ae3741ebd45e2b442f76d9c.png"><br><br>  Jalankan tes, setel ke CI.  Sinkronisasi antara backend dan frontend akan dijamin oleh tes, dan tidak jujur. <br><br><h3>  Kembali ke backend? </h3><br>  Kami memperkenalkan tes enam bulan lalu, dan kami benar-benar menyukainya.  Masalah logika kabur masih ada.  Semakin cerdas aplikasi bisnis, semakin banyak informasi yang diperlukan untuk beberapa langkah.  Jika Anda mencoba menjalankan semacam alur kerja dari dunia nyata di sana, dependensi akan muncul pada segalanya: untuk setiap antarmuka pengguna Anda perlu mendapatkan sesuatu dari berbagai bagian database di backend.  Jika kita menulis sistem akuntansi, ini tidak dapat dihindari.  Akibatnya, seperti yang saya katakan, semua logika dioleskan. <br><br>  Dengan bantuan tes seperti itu, kita dapat membuat ilusi setidaknya di dev-time - pada saat pengembangan - bahwa kita, seperti di masa lalu web 2.0, duduk di server dalam satu runtime dan semuanya nyaman. <br><br>  Gagasan gila lainnya muncul (belum diimplementasikan).  Mengapa tidak menurunkan bagian ini ke backend?  Mengapa tidak pergi sepenuhnya dari aplikasi yang didistribusikan sekarang?  Biarkan langganan ini dan model tampilan kami dihasilkan di backend?  Di sana basis tersedia, semuanya sinkron.  Semuanya sederhana dan jelas. <br><br>  Nilai tambah pertama yang saya lihat di sini adalah bahwa kita akan memiliki kendali di satu tempat.  Kami hanya menyederhanakan semuanya segera dibandingkan dengan aplikasi terdistribusi kami.  Tes menjadi sederhana, validasi ganda menghilang.  Dunia modis dari sistem multi-user interaktif terbuka (jika dua pengguna pergi ke bentuk yang sama, kami memberi tahu mereka tentang hal itu; mereka dapat mengeditnya pada saat yang sama). <br><br>  Sebuah fitur menarik muncul: dengan membuka backend dan prospek sesi, kita dapat memahami siapa yang saat ini ada dalam sistem dan apa yang sedang dia lakukan.  Ini agak mirip game dev, di mana server bekerja seperti ini.  Di sana dunia tinggal di server, dan front-end hanya merender.  Hasilnya, kita bisa mendapatkan klien tipis tertentu. <br><br>  Di sisi lain, ini menciptakan tantangan.  Kita harus memiliki server statefull di mana sesi ini hidup.  Jika kami memiliki beberapa server aplikasi, akan perlu untuk entah bagaimana menyeimbangkan beban atau mereplikasi sesi dengan benar.  Namun, ada kecurigaan bahwa masalah ini kurang dari jumlah plus yang kita dapatkan. <br><br>  Oleh karena itu, saya kembali ke slogan utama: ada banyak jenis aplikasi yang dapat ditulis tidak didistribusikan, untuk membuang kerumitan dari mereka.  Dan Anda bisa mendapatkan beberapa peningkatan dalam efisiensi jika Anda sekali lagi merevisi postulat dasar yang menjadi andalan kami dalam pengembangan. <br><br><blockquote>  Jika Anda menyukai laporan ini, perhatikan: pada 24-25 November, <b>HolyJS</b> baru akan diadakan di Moskow, dan juga akan ada banyak hal menarik di sana.  Informasi yang sudah diketahui tentang program ini ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di situs</a> , dan tiket dapat dibeli di sana. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421789/">https://habr.com/ru/post/id421789/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421775/index.html">Jaringan saraf dilatih untuk mengenali depresi dengan cara bicara sewenang-wenang seseorang tanpa konteks</a></li>
<li><a href="../id421779/index.html">OceanLotus: backdoor baru, skema lama</a></li>
<li><a href="../id421783/index.html">Kerangka Huex Manajemen Negara yang Menyenangkan</a></li>
<li><a href="../id421785/index.html">California berada di ambang penolakan lengkap karbon dalam produksi energi</a></li>
<li><a href="../id421787/index.html">Pengembangan arsitektur proyek, kapal dan JavaScript</a></li>
<li><a href="../id421791/index.html">Masalah Etis Kecerdasan Buatan</a></li>
<li><a href="../id421793/index.html">Mencari yang terbaik atau bagaimana kami memilih jaringan blockchain untuk proyek tersebut</a></li>
<li><a href="../id421795/index.html">Keputusan berdasarkan data tentang contoh pemilihan warna untuk lukisan dinding</a></li>
<li><a href="../id421797/index.html">Mengapa Anda perlu Splunk? Memantau infrastruktur TI</a></li>
<li><a href="../id421799/index.html">Bagaimana cara mendapatkan pekerjaan dari jarak jauh di perusahaan yang tidak mengambil karyawan jarak jauh?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>