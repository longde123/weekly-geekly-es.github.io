<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍄 👨🏼‍🎨 ⚖️ 检查Roslyn的源代码 🔛 🤶🏾 ⚡️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="有时，我们会返回到之前使用PVS-Studio测试过的项目，并撰写了有关该项目的文章。 这样做有两个原因。 首先，要了解我们的分析仪变得更好了。 其次，跟踪项目的作者是否关注我们的文章以及我们通常提供给他们的错误报告。 当然，没有我们的参与就可以纠正错误。 但是，只要我们的努力能使一个项目变得更好，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>检查Roslyn的源代码</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/446592/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/833/abb/d94/833abbd94d6e48526a175b89fffc9dd5.png" alt="PVS-Studio VS罗斯林"></div><br> 有时，我们会返回到之前使用PVS-Studio测试过的项目，并撰写了有关该项目的文章。 这样做有两个原因。 首先，要了解我们的分析仪变得更好了。 其次，跟踪项目的作者是否关注我们的文章以及我们通常提供给他们的错误报告。 当然，没有我们的参与就可以纠正错误。 但是，只要我们的努力能使一个项目变得更好，那总是很好。 罗斯林也不例外。 之前有关该项目的评论文章可追溯到2015年12月23日。 考虑到我们的分析仪在这段时间内的发展历程，这已经是很长的时间了。 对于我们个人而言，罗斯林（C＃分析仪PVS-Studio的核心就是基于它的事实）也引起了人们的极大兴趣。 因此，我们对该项目的代码质量非常感兴趣。 我们将安排第二次检查，以发现新的和有趣的（但我们希望没什么大不了的）PVS-Studio在那里可以找到。 <br><a name="habracut"></a><br>  Roslyn（或.NET编译器平台）可能是我们许多读者熟悉的。 简而言之，它是一组用于Microsoft C＃和Visual Basic .NET语言代码分析的开源编译器和API。 该项目的源代码可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">找到</a> 。 <br><br> 我不会对此平台进行详细说明，但我会向所有感兴趣的人推荐我的同事Sergey Vasiliev的文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">罗斯林简介。使用静态分析工具进行开发”</a> 。 从本文中，您不仅可以了解Roslyn架构的功能，还可以了解我们如何使用该平台。 <br><br> 正如我前面提到的，自从我的同事Andrei Karpov撰写上一篇有关Roslyn检查“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio 6.00的新年发布：检查Roslyn</a> ”的文章以来，已经过去了三年多。 在此期间，C＃PVS-Studio分析仪获得了许多新功能。 通常，Andrey的文章是一种“测试球”，因为C＃分析器仅在那时才添加到PVS-Studio中。 尽管如此，即便如此，罗斯林还是在一个无条件的高质量项目中设法找到了有趣的错误。 到目前为止，C＃代码分析器中发生了哪些变化，这可能允许进行更深入的分析？ <br><br> 在过去的时间里，分析仪核心和基础设施都得到了发展。 添加了对Visual Studio 2017和Roslyn 2.0的支持，以及与MSBuild的深度集成。 您可以在我的同事Pavel Yeremeyev的文章中了解有关我们与MSBuild集成的方法的更多信息，以及导致我们接受它的原因，“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在PVS-Studio中对Visual Studio 2017和Roslyn 2.0的支持：有时使用现成的解决方案似乎并不容易一目了然</a> 。“ <br><br> 现在，我们正在按照最初支持Visual Studio 2017的相同方案（即通过我们自己的工具集）积极地过渡到Roslyn 3.0，该工具集包含在PVS-Studio分发工具包中，带有空MSBuild.exe文件形式的“存根”。 尽管它看起来像个“拐杖”（由于库的可移植性很低，MSBuild API对于在第三批项目中重用不是很友好），但是这种方法已经帮助我们在Visual Studio 2017的生命周期中相对轻松地重现了多个Roslyn更新。现在，尽管有大量覆盖，但在升级到Visual Studio 2019的过程中仍然可以生存，并在具有旧版本MSBuild的系统上保持完全的向后兼容性和性能。 <br><br> 分析仪核心也进行了许多改进。 主要创新之一是全面的过程间分析，其中考虑了方法的输入和输出值，并根据这些参数考虑了执行分支和返回点的可达性。 <br><br> 跟踪方法内部参数的任务已经接近完成，同时保留了有关这些参数在那里发生的情况的自动注释（例如，潜在的危险取消引用）。 这将允许使用数据流机制进行任何诊断，以考虑将参数传递给方法时发生的危险情况。 以前，在分析此类危险场所时，不会生成警告，因为我们无法知道该方法的所有可能输入值。 现在我们可以检测出危险了，因为在调用此方法的所有地方，这些输入参数都将被考虑在内。 <br><br> 注意：您可以通过文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio代码分析器中用于查找错误和潜在漏洞的技术</a> ”来熟悉分析器的主要机制，例如数据流和其他机制。 <br><br>  PVS-Studio C＃中的过程间分析不受输入参数或深度的限制。 唯一的限制是类中的虚拟方法，这些类没有为继承而关闭并且没有递归递归（当我们在堆栈上看到对已计算方法的重复调用时，让我们停下来）。 而且，递归方法本身最终将在假设其自递归的返回值未知的情况下进行计算。 <br><br>  C＃分析器的另一个重大创新是可以取消引用潜在的空指针。 以前，如果确定在所有执行分支中变量的值将为null，则分析器会发誓可能会出现null引用异常。 当然，有时他会误会，因此以前将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3080</a>诊断称为潜在的空引用。 <br><br> 现在，分析器会记住该变量在执行分支之一中可能为null（例如，在if中的特定条件下）。 如果他不经检查即可访问此变量，则将显示消息V3080，但重要性低于在所有分支中均看到null的重要性。 结合改进的过程间分析，这种机制可以发现很难检测到的错误。 一个例子是一长串方法调用，您不熟悉其中的最后一个方法调用，例如在某些情况下返回空值，但是您并未对此加以保护，因为您根本不知道该方法。 在这种情况下，分析仪仅在准确看到空值分配时发誓。 我们认为，这在质量上将我们的方法与C＃8.0的可空引用类型的创新区分开来，实际上，归结为每种方法中都设置了空检查。 我们提供了一种替代方法-仅在真正可能出现null的地方进行检查，而我们的分析仪现在可以查找这种情况。 <br><br> 因此，我们毫不拖延地进行“汇报”-分析罗斯林检查的结果。 首先，让我们看看由于上述创新而发现的错误。 总体而言，这次针对Roslyn代码发布了许多警告。 我认为这是由于该平台正在非常积极地进行开发的事实（当前的代码库大约为277万行代码，不包括空代码行），并且我们很长一段时间都没有对该项目进行分析。 但是，没有那么多关键错误，即它们是本文所关注的。 是的，Roslyn中有很多测试，像往常一样，我被排除在测试之外。 <br><br> 我将以中等严重性级别的V3080错误开始，在该错误中，分析仪检测到通过零链路的可能访问，但并非在所有可能的情况下（代码分支）。 <br><br>  <b>可能的空取消引用-中</b> <br><br>  V3080可能为空的取消引用。 考虑检查“当前”。  CSharpSyntaxTreeFactoryService.PositionalSyntaxReference.cs 70 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SyntaxNode root)</span></span></span><span class="hljs-function"> </span></span>{ var current = root; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current.FullSpan.Contains(....)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... var nodeOrToken = current.ChildThatContainsPosition(....); .... current = nodeOrToken.AsNode(); // &lt;= } .... } public SyntaxNode AsNode() { if (_token != null) { return null; } return _nodeOrParent; }</span></span></code> </pre> <br> 考虑<i>GetNode</i>方法。 分析器认为在<i>while</i>块的情况下可以通过空引用进行访问。 在<i>while</i>块的主体中​​，将为<i>当前</i>变量分配一个值-执行<i>AsNode</i>方法的结果。 在某些情况下，此值将为<i>null</i> 。 实际的过程间分析的一个很好的例子。 <br><br> 现在考虑类似的情况，其中通过两个方法调用执行过程间分析。 <br><br>  V3080可能为空的取消引用。 考虑检查“目录”。  CommonCommandLineParser.cs 911 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerable&lt;CommandLineSourceFile&gt; ExpandFileNamePattern(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> baseDirectory, ....) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> directory = PathUtilities.GetDirectoryName(path); .... var resolvedDirectoryPath = (directory.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-comment"><span class="hljs-comment">// &lt;= baseDirectory : FileUtilities.ResolveRelativePath(directory, baseDirectory); .... } public static string GetDirectoryName(string path) { return GetDirectoryName(path, IsUnixLikePlatform); } internal static string GetDirectoryName(string path, bool isUnixLike) { if (path != null) { .... } return null; }</span></span></code> </pre> <br>  <i>ExpandFileNamePattern</i>方法主体中的<i>目录</i>变量从<i>GetDirectoryName（字符串）</i>方法获取值。 依次将返回重载的<i>GetDirectoryName（字符串，布尔）</i>方法的结果，该方法的值可以为<i>null</i> 。 由于在<i>ExpandFileNamePattern</i>方法的主体中进一步使用了<i>目录</i>变量，而没有对<i>空</i>相等性进行初步检查，因此我们可以讨论分析器发出的警告是否合法。 这是一个潜在的不安全设计。 <br><br> 更准确地说，另一段错误为V3080的代码针对一行代码立即发出了两个错误。 在这里，不需要过程间分析。 <br><br>  V3080可能为空的取消引用。 考虑检查“ spanStartLocation”。  TestWorkspace.cs 574 <br><br>  V3080可能为空的取消引用。 考虑检查“ spanEndLocationExclusive”。  TestWorkspace.cs 574 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapMarkupSpans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { .... foreach (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanStartLocation = null; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanEndLocationExclusive = null; foreach (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanStartLocation == null &amp;&amp; positionInMarkup &lt;= markupSpanStart &amp;&amp; ....) { .... spanStartLocation = ....; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanEndLocationExclusive == null &amp;&amp; positionInMarkup &lt;= markupSpanEndExclusive &amp;&amp; ....) { .... spanEndLocationExclusive = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... } .... } tempMappedMarkupSpans[key]. Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextSpan( spanStartLocation.Value, <span class="hljs-comment"><span class="hljs-comment">// &lt;= spanEndLocationExclusive.Value - // &lt;= spanStartLocation.Value)); } } .... }</span></span></code> </pre> <br>  <i>spanStartLocation</i>和<i>spanEndLocationExclusive变量</i>的类型为<i>nullable int</i> ，并初始化为<i>null</i> 。 在代码中进一步可以为它们分配值，但前提是要满足某些条件。 在某些情况下，它们的值将保持等于<i>null</i> 。 如代码分析器所指出的那样，在代码的进一步部分中，这些变量是通过引用来访问的，而无需首先检查<i>空</i>相等性。 <br><br>  Roslyn代码包含很多这样的错误，超过100个。这些错误的模式通常是相同的。 有一些通用方法可能会返回<i>null</i> 。 此方法的结果在很多地方使用，有时通过数十个中间方法调用或其他检查使用。 重要的是要了解这些错误不是致命的，但它们可能会导致通过空链接进行访问。 而且要检测此类错误非常困难。 因此，在某些情况下，您应该考虑重构代码，如果该方法返回<i>null，</i>则将引发异常。 否则，您只能通过全面检查来保护代码，这很繁琐且不可靠。 当然，在每种情况下，都应根据项目的特征来做出决定。 <br><br> 注意事项 碰巧的是，目前没有任何情况（输入数据）中方法返回<i>null</i>并且没有实际错误。 但是，这样的代码仍然不可靠，因为当对代码进行更改时，所有内容都会更改。 <br><br> 为了用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3080</a>结束本主题，让我们看一下通过置信度链接进行访问的可能性更高甚至是不可避免的情况下，高置信水平下的明显错误。 <br><br>  <b>可能的空取消引用-高</b> <br><br>  V3080可能为空的取消引用。 考虑检查“ collectionType.Type”。  137第137章 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override async Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeRefactoringsAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeRefactoringContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... var collectionType = semanticModel.GetTypeInfo(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br> 由于条件中有错别字（而不是我们使用<i>&amp;&amp;</i>的<i>||</i>运算符），因此代码无法按预期运行，如果<i>collectionType.Type</i>变量为<i>null，</i>则将对其进行访问。 该条件必须更正如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null || collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br> 顺便说一下，事件发展的第二种变体也是可能的：在第一部分中，条件由运算符<i>==</i>和<i>！=</i>混合在一起。 然后，更正后的代码将是： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type != null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br> 此版本的代码逻辑性较差，但也可以纠正错误。 最终决定权取决于项目的作者。 <br><br> 另一个类似的错误。 <br><br>  V3080可能为空的取消引用。 考虑检查“动作”。 文字检视视窗_InProc.cs 372 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Func&lt;IWpfTextView, Task&gt; GetLightBulbApplicationAction(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( $<span class="hljs-string"><span class="hljs-string">"Unable to find FixAll in {fixAllScope.ToString()} code fix for suggested action '{action.DisplayText}'."</span></span>); } .... }</code> </pre> <br> 编写异常消息时出错。 同时，尝试通过<i>action</i>变量（显然为<i>null）</i>访问<i>action.DisplayText</i>属性。 <br><br> 最后一个错误是V3080高电平。 <br><br>  V3080可能为空的取消引用。 考虑检查“类型”。  ObjectFormatterHelpers.cs 91 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsApplicableAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeInfo type, TypeInfo targetType, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetTypeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName; }</code> </pre> <br> 该方法很小，所以我给出了它的完整代码。  <i>返回</i>块中的条件不正确。 在某些情况下，访问<i>type.FullName</i>时可能会抛出<i>NullReferenceException</i> 。 我使用方括号（此处将不会更改其行为）来澄清这种情况： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (type != null &amp;&amp; AreEquivalent(targetType, type)) || (targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br> 这样，根据操作的优先级，此代码将起作用。 如果<i>类型</i>变量为<i>null</i> ，则进入else检查，其中，确保<i>targetTypeName</i>变量为<i>null</i> ，我们使用空<i>类型</i>引用。 您可以修复代码，例如： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; (AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br> 我认为您可以在这里完成V3080错误的研究，并查看在Roslyn代码中还能找到的有趣的PVS-Studio分析仪。 <br><br>  <b>错字</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3005</a>将'SourceCodeKind'变量分配给它自己。  DynamicFileInfo.cs 17 <br><br><pre> <code class="cpp hljs">internal sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filePath, SourceCodeKind sourceCodeKind, TextLoader textLoader, IDocumentServiceProvider documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = filePath; SourceCodeKind = SourceCodeKind; <span class="hljs-comment"><span class="hljs-comment">// &lt;= TextLoader = textLoader; DocumentServiceProvider = documentServiceProvider; } .... }</span></span></code> </pre> <br> 由于变量名不成功，因此在<i>DynamicFileInfo</i>类的构造函数中输入了错误。 为<i>SourceCodeKind字段</i>分配了自己的值，而不是使用<i>sourceCodeKind</i>参数。 为了最大程度地减少此类错误的可能性，建议在这种情况下对参数名称使用下划线前缀。 我将给出一个更正后的代码示例： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _filePath, SourceCodeKind _sourceCodeKind, TextLoader _textLoader, IDocumentServiceProvider _documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = _filePath; SourceCodeKind = _sourceCodeKind; TextLoader = _textLoader; DocumentServiceProvider = _documentServiceProvider; }</code> </pre> <br>  <b>粗心</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3006</a>已创建对象， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">但未使用</a>该对象。  'throw'关键字可能丢失：抛出新的InvalidOperationException（FOO）。  ProjectBuildManager.cs 61 <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br> 在特定条件下，析构函数应该抛出异常，但这不会发生，并且仅创建异常对象。  <i>throw</i>关键字被省略。 更正的代码版本： <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br> 在C＃中使用析构函数并从中引发异常的问题是单独讨论的主题，这不在本文的讨论范围之内。 <br><br>  <b>当结果不重要时</b> <br><br> 对于在所有情况下均返回相同值的方法，已收到许多<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3009</a>警告。 有时这并不重要，或者根本没有在调用代码中检查返回代码。 我错过了这样的警告。 但是一些代码对我来说似乎很可疑。 我会引用其中之一： <br><br>  V3009这种方法总是返回一个相同的'true'值，这很奇怪。  GoToDefinitionCommandHandler.cs 62 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (context.OperationContext.AddScope(....)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  <i>TryExecuteCommand</i>方法仅返回<i>true</i> ，而仅返回<i>true</i> 。 同时，返回值涉及调用代码中的某些检查： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (caretPos.HasValue &amp;&amp; TryExecuteCommand(....)) { .... } .... }</code> </pre> <br> 很难说这种行为有多危险。 但是，如果不需要结果，则可能值得用void代替返回类型并对调用方法进行最少的更改。 这将使代码更易于理解和安全。 <br><br> 其他类似的警告： <br><br><ul><li>  V3009这种方法总是返回一个相同的'true'值，这很奇怪。  CommentUncommentSelectionCommandHandler.cs 86 </li><li>  V3009这种方法总是返回一个相同的'true'值，这很奇怪。  RenameTrackingTaggerProvider.RenameTrackingCommitter.cs 99 </li><li>  V3009这种方法总是返回一个相同的'true'值，这很奇怪。 第138章 </li><li>  V3009这种方法总是返回一个相同的'true'值，这很奇怪。 第164章 </li><li>  V3009奇怪的是，此方法总是返回一个相同的'false'值。  TriviaDataFactory.CodeShapeAnalyzer.cs 254 </li><li>  V3009这种方法总是返回一个相同的'true'值，这很奇怪。 物件清单.cs 173 </li><li>  V3009这种方法总是返回一个相同的'true'值，这很奇怪。 物件清单.cs 249 </li></ul><br>  <b>未检查</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3019</a>可能在使用'as'关键字进行类型转换后将不正确的变量与null进行比较。 检查变量“值”，“ valueToSerialize”。 漫游VisualStudioProfileOptionPersister.cs 277 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryPersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OptionKey optionKey, object value)</span></span></span><span class="hljs-function"> </span></span>{ .... var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != null) { value = valueToSerialize.CreateXElement().ToString(); } .... }</code> </pre> <br> 变量<i>值为</i> <i>NamingStylePreferences</i>类型。 问题出在此检查之后。 即使<i>value</i>变量不为null，也不能保证类型转换成功并且<i>valueToSerialize</i>不包含<i>null</i> 。  <i>可能抛出NullReferenceException</i> 。 该代码需要固定如下： <br><br><pre> <code class="cpp hljs">var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueToSerialize != null) { value = valueToSerialize.CreateXElement().ToString(); }</code> </pre> <br> 还有一个类似的错误。 <br><br>  V3019可能在使用'as'关键字进行类型转换后将不正确的变量与null进行比较。 检查变量“ columnState”，“ columnState2”。  StreamingFindUsagesPresenter.cs 181 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDefinitionGroupingPriority</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (var columnState in ....) { var columnState2 = columnState as ColumnState2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columnState?.Name == <span class="hljs-comment"><span class="hljs-comment">// &lt;= StandardTableColumnDefinitions2.Definition) { newColumns.Add(new ColumnState2( columnState2.Name, // &lt;= ....)); } .... } .... }</span></span></code> </pre> <br> 变量<i>columnState</i>的类型为<i>ColumnState2</i> 。 但是，操作结果变量<i>columnState2</i>不会进一步检查是否为<i>null</i> 。 而是使用条件<i>空</i>语句检查变量<i>columnState</i> 。 此代码有什么危险？ 与前面的示例一样，使用<i>as</i>运算符的类型转换可能会失败，并且<i>columnState2</i>变量将为<i>null</i> ，这将进一步引发异常。 顺便说一句，错字可能是罪魁祸首。 注意<i>if</i>块中的条件。 也许他们想编写<i>columnState2？.Name</i>而不是<i>columnState？.Name</i> 。 考虑到非常不幸的变量名称<i>columnState和columnState2，</i>这很有可能<i>。</i> <br><br>  <b>冗余检查</b> <br><br> 对于非关键但与冗余检查相关联的潜在不安全构造，发出了大量警告（超过100个）。 例如，我将给他们之一。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3022</a>表达式'navInfo == null'始终为false。  AbstractSyncClassViewCommandHandler.cs 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... IVsNavInfo navInfo = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (symbol != null) { navInfo = libraryService.NavInfoFactory.CreateForSymbol(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) { navInfo = libraryService.NavInfoFactory.CreateForProject(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { return true; } .... } public IVsNavInfo CreateForSymbol(....) { .... return null; } public IVsNavInfo CreateForProject(....) { return new NavInfo(....); }</span></span></code> </pre> <br> 也许这里没有真正的错误。 这是充分证明“过程间分析+数据流分析”技术相结合的充分理由。 分析器认为第二次检查<i>navInfo == null是</i>多余的。 实际上，在此之前，将从<i>libraryService.NavInfoFactory.CreateForProject</i>方法获得分配<i>navInfo</i>的值，该方法将构造并返回<i>NavInfo</i>类的新对象。 但无论如何都不为<i>null</i> 。 问题是，为什么分析器没有为第一次检查<i>navInfo == null生成</i>警告？ 对此有一个解释。 首先，如果<i>符号</i>变量结果为<i>null</i> ，则<i>navInfo</i>的值将保持为空引用。 其次，即使<i>navInfo</i>从<i>libraryService.NavInfoFactory.CreateForSymbol</i>方法接收到一个值，该值也可能为<i>null</i> 。 因此，首先需要对<i>navInfo == null</i>进行第一次检查。 <br><br>  <b>没有足够的支票</b> <br><br> 现在情况与上述情况相反。 收到了一些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3042</a>警告，提示可以通过空引用访问的代码。 而且，只有一两个小支票可以解决所有问题。 <br><br> 考虑包含两个此类错误的一段有趣的代码。 <br><br>  V3042可能为NullReferenceException。  '？。' 和“。” 运算符用于访问“接收器”对象Binder_Expressions.cs 7770的成员 <br><br>  V3042可能为NullReferenceException。  '？。' 和“。” 运算符用于访问“接收器”对象Binder_Expressions.cs 7776的成员 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != <span class="hljs-comment"><span class="hljs-comment">// &lt;= GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver.Type; // &lt;= if (receiverType?.IsNullableType() == true) { .... } receiver = new BoundConditionalReceiver(receiver.Syntax, 0, // &lt;= receiverType ?? CreateErrorType(), hasErrors: receiver.HasErrors) // &lt;= { WasCompilerGenerated = true }; return receiver; }</span></span></code> </pre> <br>  <i>接收器</i>变量可以为<i>null</i> 。 代码的作者知道这一点，因为他在<i>if</i>块的条件下使用条件<i>空运算符</i>来访问<i>接收方？.Syntax</i> 。 在代码的进一步部分，不经任何检查即可使用变量<i>接收器</i>来访问<i>receive.Type</i> ， <i>receiver.Syntax</i>和<i>receive.HasErrors</i> 。 这些错误需要修复： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver?.Type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiverType?.IsNullableType() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { .... } receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BoundConditionalReceiver(receiver?.Syntax, <span class="hljs-number"><span class="hljs-number">0</span></span>, receiverType ?? CreateErrorType(), hasErrors: receiver?.HasErrors) { WasCompilerGenerated = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> receiver; }</code> </pre> <br> 您还需要确保<i>BoundConditionalReceiver</i>构造函数支持为其参数获取<i>空</i>值，或执行其他重构。 <br><br> 其他类似错误： <br><br><ul><li>  V3042可能为NullReferenceException。  '？。' 和“。” 运算符用于访问“ containsType”对象的成员SyntaxGeneratorExtensions_Negate.cs 240 </li><li>  V3042可能为NullReferenceException。  '？。' 和“。”  349运算符用于访问“表达式”对象ExpressionSyntaxExtensions.cs的成员 </li><li>  V3042可能为NullReferenceException。  '？。' 和“。”  349运算符用于访问“表达式”对象ExpressionSyntaxExtensions.cs的成员 </li></ul><br>  <b>条件错误</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3057</a> “子字符串”功能可以接收“ -1”值，而预期为非负值。 检查第二个参数。  CommonCommandLineParser.cs 109 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryParseOption</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { name = arg.Substring(<span class="hljs-number"><span class="hljs-number">1</span></span>, colon - <span class="hljs-number"><span class="hljs-number">1</span></span>); value = arg.Substring(colon + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br> 如果<i>冒号</i>变量为0（这允许代码中有条件），则<i>Substring</i>方法<i>将</i>抛出<i>ArgumentOutOfRangeException</i> 。 需要更正： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <b>错字是可能的</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3065</a>方法的内部未使用参数't2'。  CSharpCodeGenerationHelpers.cs 84 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDeclarationSyntax </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceUnterminatedConstructs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var updatedToken = lastToken.ReplaceTrivia(lastToken.TrailingTrivia, (t1, t2) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.MultiLineCommentTrivia) { var text = t1.ToString(); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.SkippedTokensTrivia) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReplaceUnterminatedConstructs(t1); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1; }); .... }</code> </pre> <br> 两个参数传递给lambda表达式：t1和t2。 但是，仅使用t1。 考虑到在使用具有这些名称的变量时犯错有多么容易，这看起来很可疑。 <br><br>  <b>粗心</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3083</a>事件'TagsChanged'的不安全调用，可能会发生NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  PreviewUpdater.Tagger.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTextBufferChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PreviewUpdater.SpanToShow != <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TagsChanged != null) { var span = _textBuffer.CurrentSnapshot.GetFullSpan(); TagsChanged(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(span)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  <i>TagsChanged</i>事件<i>是</i>不安全触发的。 在检查<i>null</i>相等性和调用事件之间，他们可能有时间取消订阅该事件，然后将引发异常。 此外，在<i>if</i>块的主体中​​，紧接事件调用之前，已完成了一些其他操作。 我将此错误称为“注意力不集中”，因为在代码的其他地方，它们可以更准确地处理此事件，例如，如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTrackingSpansChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leafChanged)</span></span></span><span class="hljs-function"> </span></span>{ var handler = TagsChanged; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != null) { var snapshot = _buffer.CurrentSnapshot; handler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(snapshot.GetFullSpan())); } }</code> </pre> <br> 使用可选的<i>处理程序</i>变量可以消除此问题。 在<i>OnTextBufferChanged</i>方法中， <i>您</i>需要对与事件相同的安全操作进行编辑。 <br><br>  <b>相交范围</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3092</a>在条件表达式中可能<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">存在</a>范围交点。 示例：if（A&gt; 0 &amp;&amp; A &lt;5）{...}否则if（A&gt; 3 &amp;&amp; A &lt;9）{...}。  ILBuilderEmit.cs 677 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue &amp;&amp; value &lt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= uint.MinValue &amp;&amp; value &lt;= uint.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br> 为了更好地理解，我将重写此代码片段，将常量名称替换为其实际值： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">-2147483648</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">2147483648</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">4294967295</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br> 可能没有真正的错误，但条件看起来很奇怪。 第二部分（ <i>否则为</i> ）将仅对2147483648 +1到4294967295范围内的值执行。 <br><br> 其中一些警告： <br><br><ul><li>  V3092在条件表达式中可能存在范围交点。 示例：if（A&gt; 0 &amp;&amp; A &lt;5）{...}否则if（A&gt; 3 &amp;&amp; A &lt;9）{...}。 本地重写器_Literal.cs 109 </li><li>  V3092在条件表达式中可能存在范围交点。 示例：if（A&gt; 0 &amp;&amp; A &lt;5）{...}否则if（A&gt; 3 &amp;&amp; A &lt;9）{...}。  LocalRewriter_Literal.cs 66 </li></ul><br>  <b>有关空相等检查（或缺少空检查）的更多信息</b> <br><br> 有关在使用变量后检查变量是否为<i>null的</i>一些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3095</a>错误。 首先是模棱两可，考虑一下代码。 <br><br>  V3095在对null进行验证之前，已使用'displayName'对象。 检查行：498，503。FusionAssemblyIdentity.cs 498 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IAssemblyName </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToAssemblyNameObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> displayName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (displayName.IndexOf(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } Debug.Assert(displayName != null); .... }</code> </pre> <br> 假定<i>displayName</i>引用可以为null。 为此，请检查<i>Debug.Assert</i> 。 目前尚不清楚为什么在使用字符串后会继续。 还应<i>注意</i> ，对于除Debug以外的其他配置，编译器将<i>完全</i>从代码中<i>删除Debug.Assert</i> 。 这是否意味着仅对于Debug，才可以获取空引用？ 如果不是这样，那么为什么不检查<i>string.IsNullOrEmpty（字符串）</i> ，例如。 这些是代码作者的问题。 <br><br> 以下错误更加明显。 <br><br>  V3095在验证是否为null之前，已使用'scriptArgsOpt'对象。 检查行：321、325。CommonCommandLineParser.cs 321 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt.Add(arg); <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } if (scriptArgsOpt != null) { .... } .... } }</span></span></code> </pre> <br> 我认为这段代码不需要解释。 我将给出更正的版本： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt?.Add(arg); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scriptArgsOpt != null) { .... } .... } }</code> </pre> <br>  Roslyn代码发现了另外15个此类错误： <br><br><ul><li>  V3095在对null进行验证之前，已使用'LocalFunctions'对象。 检查行：289、317。ControlFlowGraphBuilder.RegionBuilder.cs 289 </li><li>  V3095在对null进行验证之前，已使用'resolution.OverloadResolutionResult'对象。 检查行：579、588。Binder_Invocation.cs 579 </li><li>  V3095在对null进行验证之前，已使用'resolution.MethodGroup'对象。 检查行：592、621。Binder_Invocation.cs 592 </li><li>  V3095在对null进行验证之前，已使用'touchedFilesLogger'对象。 检查行：111，126。CSharpCompiler.cs 111 </li><li>  V3095在对null进行验证之前，已使用'newExceptionRegionsOpt'对象。 检查行：736、743。AbstractEditAndContinueAnalyzer.cs 736 </li><li>  V3095在验证是否为null之前，已使用'symbol'对象。 检查行：422、427。AbstractGenerateConstructorService.Editor.cs 422 </li><li>  V3095在验证空值之前使用了'_state.BaseTypeOrInterfaceOpt'对象。 检查行：132，140。AbstractGenerateTypeService.GenerateNamedType.cs 132 </li><li>  V3095在对null进行验证之前，已使用'element'对象。 检查线：232，233。ProjectUtil.cs 232 </li><li>  V3095在验证是否为null之前，已使用“语言”对象。 检查行：22，28。ExportCodeCleanupProvider.cs 22 </li><li>  V3095在对null进行验证之前，已使用'memberType'对象。 检查行：183，184。SyntaxGeneratorExtensions_CreateGetHashCodeMethod.cs 183 </li><li>  V3095在对null进行验证之前，已使用'validTypeDeclarations'对象。 Check lines: 223, 228. SyntaxTreeExtensions.cs 223 </li><li> V3095 The 'text' object was used before it was verified against null. Check lines: 376, 385. MSBuildWorkspace.cs 376 </li><li> V3095 The 'nameOrMemberAccessExpression' object was used before it was verified against null. Check lines: 206, 223. CSharpGenerateTypeService.cs 206 </li><li> V3095 The 'simpleName' object was used before it was verified against null. Check lines: 83, 85. CSharpGenerateMethodService.cs 83 </li><li> V3095 The 'option' object was used before it was verified against null. Check lines: 23, 28. OptionKey.cs 23 </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的错误</font><font style="vertical-align: inherit;">。这里，我们</font><font style="vertical-align: inherit;">在初始化变量时</font><font style="vertical-align: inherit;">使用条件</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空运</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算符</font><font style="vertical-align: inherit;">，以下在代码中使用变量时不检查</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相等性</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一个错误由两个警告立即发出信号。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105通过空条件运算符分配了'documentId'变量后，就使用了该变量。 NullReferenceException是可能的。 CodeLensReferencesService.cs 138 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105通过空条件运算符分配了'documentId'变量后，就使用了该变量。 NullReferenceException是可能的。 CodeLensReferencesService.cs 139</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;ReferenceLocationDescriptor&gt; GetDescriptorOfEnclosingSymbolAsync(....) { .... var documentId = solution.GetDocument(location.SourceTree)?.Id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId.ProjectId.Id, documentId.Id, ....); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentId</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以初始化为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">结果，创建</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReferenceLocationDescriptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最终将引发异常。</font><font style="vertical-align: inherit;">该代码需要修复：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId?.ProjectId.Id, documentId?.Id, ....);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，在代码中，还必须提供</font><font style="vertical-align: inherit;">传递给构造函数</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">相等的可能性</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码中的其他类似错误：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105通过空条件运算符分配了'symbol'变量后，即可使用。</font><font style="vertical-align: inherit;">NullReferenceException是可能的。</font><font style="vertical-align: inherit;">SymbolFinder_Hierarchy.cs 44</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105通过空条件运算符分配了'symbol'变量后，即可使用。</font><font style="vertical-align: inherit;">NullReferenceException是可能的。</font><font style="vertical-align: inherit;">SymbolFinder_Hierarchy.cs 51</font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优先级和括号</font></font></b> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3123</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也许'？：'运算符的工作方式与预期的不同。在此条件下，它的优先级低于其他运营商的优先级。 Edit.cs 70</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Edit&lt;TNode&gt; other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; (_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode) &amp;&amp; (_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回块中的条件根本不像开发人员所想的那样计算。</font><font style="vertical-align: inherit;">假定第一个条件为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_kind == other._kin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d（因此，在此条件之后进行换行），然后将依次计算带有“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><font style="vertical-align: inherit;">运算符的条件块</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">实际上，第一个条件将是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_kind == other._kind &amp;&amp;（_oldNode == null）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是因为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp;&amp;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运算符</font><font style="vertical-align: inherit;">的优先级高于“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><font style="vertical-align: inherit;">运算符</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">要解决该错误，必须将“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><font style="vertical-align: inherit;">运算符的所有表达式括起来</font><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; ((_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode)) &amp;&amp; ((_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 到此结束对发现的错误的描述。 </font></font><br><br>  <b>结论</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管我能够检测到大量错误，但是就Roslyn项目代码的大小（2,770,000行）而言，这将是很小的数目。像上一篇文章中的Andrei一样，我也准备承认这个项目的高质量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我想指出的是，这种偶然的代码检查与静态分析的方法无关，实际上并没有带来任何好处。应当定期进行静态分析，而不是个案研究。然后，许多错误将在最早的阶段得到纠正，因此，修复它们的成本将降低十倍。在这篇小</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中将详细介绍这种想法</font><font style="vertical-align: inherit;">，我请您熟悉一下。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以在所考虑的项目以及任何其他项目中独立搜索更多错误。</font><font style="vertical-align: inherit;">为此，您只需</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并试用我们的分析仪。</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果您想与讲英语的读者分享这篇文章，请使用以下链接：Sergey Khrenov。 </font></font> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">检查Roslyn源代码</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446592/">https://habr.com/ru/post/zh-CN446592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN446578/index.html">基于明信片的编程语言</a></li>
<li><a href="../zh-CN446582/index.html">关于养蜂养蜂的思考</a></li>
<li><a href="../zh-CN446586/index.html">通过DHCP从FreeRadius进行网络设置</a></li>
<li><a href="../zh-CN446588/index.html">检查Roslyn源代码</a></li>
<li><a href="../zh-CN446590/index.html">Java 12将提供39种新功能</a></li>
<li><a href="../zh-CN446598/index.html">重新创建CRT字体</a></li>
<li><a href="../zh-CN446602/index.html">通过场效应晶体管的最大直流电流</a></li>
<li><a href="../zh-CN446604/index.html">ESET：新的OceanLotus Cyber​​group后门交付方案</a></li>
<li><a href="../zh-CN446606/index.html">检查您在添加剂技术方面的表现如何</a></li>
<li><a href="../zh-CN446608/index.html">克服组织引力的第三定律</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>