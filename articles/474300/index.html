<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè† üï≥Ô∏è ü¶ï Respaldo confiable, seguro y vers√°til para U2F üçª üò¨ üïî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Realmente me gusta el nivel de seguridad proporcionado por U2F, pero junto con la seguridad, debe considerar un plan de recuperaci√≥n. Perder el acceso...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Respaldo confiable, seguro y vers√°til para U2F</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474300/">  Realmente me gusta el nivel de seguridad proporcionado por U2F, pero junto con la seguridad, debe considerar un plan de recuperaci√≥n.  Perder el acceso a sus cuentas m√°s importantes, si algo sucede con el token U2F principal, es un problema grave.  Al mismo tiempo, me gustar√≠a evitar usar una copia de seguridad que comprometa la seguridad proporcionada por U2F. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ede/ae9/0a7/edeae90a73189ed879d63056d56afda5.jpg" alt="yubikey"></div><br><h2>  M√©todos de respaldo populares </h2><br>  Hasta la fecha, ha sido una buena pr√°ctica tener un segundo token U2F independiente para respaldo;  este token debe agregarse manualmente a cada servicio y almacenarse en un lugar "seguro".  Otra pr√°ctica com√∫n es utilizar el m√©todo no U2F como respaldo (OTP, c√≥digos de recuperaci√≥n).  Honestamente, ambos m√©todos dejan mucho que desear. <br><a name="habracut"></a><br><h3>  Token U2F independiente </h3><br>  Esto significa que cada vez que me registro en alg√∫n servicio nuevo, necesito agregar mis dos tokens.  Este hecho plantea una serie de problemas: <br><br><ul><li>  Un token de respaldo debe ser bastante f√°cil de acceder.  A pesar de que no lo llevar√© conmigo en un llavero, deber√≠a poder alcanzarlo r√°pidamente, por lo que dif√≠cilmente puedo encontrar algo mejor que guardarlo en casa.  Cu√°n real es seguro, incluso si se usa una caja fuerte, puede hablar durante mucho tiempo; </li><li>  Cuando tengo que registrarme para un servicio mientras estoy fuera de casa, no puedo agregar un token de respaldo.  Por lo tanto, debe intentar recordar que necesita agregarlo m√°s tarde, y hasta que esto suceda, no hay copia de seguridad.  En el peor de los casos, puedo olvidarme completamente de √©l; </li><li>  Cuando estoy en casa, mis dos fichas est√°n en el mismo lugar.  Este m√©todo de copia de seguridad est√° lejos de ser ideal: ambos tokens pueden no estar disponibles debido a un incidente (ser destruido o robado); </li><li>  El hecho de que el token de respaldo se almacene en casa es completamente obvio.  Si alguien realmente quiere llegar a mi ficha, ya sabe d√≥nde buscarla; </li><li>  M√©todo no universal: no todos los servicios le permiten agregar m√°s de una clave a su cuenta. </li></ul><br>  En mi opini√≥n, esta "pr√°ctica ejemplar" no es muy confiable y m√°s bien gravosa.  Veamos otra pr√°ctica com√∫n. <br><br><h3>  M√©todo no U2F como respaldo </h3><br>  OTP: <br><br><ul><li>  Usar OTP como respaldo es mejor que usarlo como el m√©todo 2FA principal, pero el hecho de tener OTP de alguna manera abre un vector de ataque adicional; </li><li>  Los tel√©fonos se descomponen, se pierden y son robados, y si despu√©s de su p√©rdida existe la posibilidad de que est√© en manos de extra√±os, entonces debe recuperar manualmente esta copia de seguridad en todas las cuentas; </li><li>  Siempre llevo un tel√©fono <b>y un</b> token U2F conmigo, as√≠ que de nuevo, este m√©todo de respaldo est√° lejos de ser ideal: la probabilidad de perderlos de inmediato es mucho mayor que si el respaldo se almacenara por separado.  Pero este elemento puede compensarse ligeramente utilizando, por ejemplo, Authy, que almacena la copia de seguridad cifrada en su servidor; </li><li>  M√©todo no universal: desafortunadamente, hay una cantidad suficiente de servicios que ofrecen solo aplicaciones personalizadas y no son compatibles con TOTP est√°ndar. </li></ul><br>  C√≥digos de recuperaci√≥n: <br><br><ul><li>  Los c√≥digos de recuperaci√≥n deben almacenarse en un lugar seguro.  Una vez m√°s, este "lugar seguro" probablemente ser√° mi hogar, con casi los mismos problemas que un token U2F separado; </li><li>  Una vez m√°s, un m√©todo no universal: cada servicio tiene su propio enfoque de copia de seguridad </li></ul><br>  Para resumir, todos estos m√©todos son no universales, pesados ‚Äã‚Äãy no demasiado seguros. <br><br><h2>  El mejor m√©todo de respaldo </h2><br>  Ahora, despu√©s de haber criticado suficientemente el estado actual de las cosas, finalmente dir√© lo que realmente quiero.  Realmente quiero tener dos tokens U2F: primario y de respaldo, pero deben configurarse de cierta manera: <br><br><ul><li>  Cuando registro el token principal en cualquier dispositivo, el token de respaldo se vuelve operativo autom√°ticamente para este servicio; </li><li>  Tan pronto como use un token de respaldo en cualquier servicio, el token principal no es v√°lido para este servicio. </li></ul><br>  Antes de discutir la viabilidad t√©cnica de esto dentro de U2F, explicar√© por qu√© es genial y c√≥mo lo uso. <br><br><h3>  Porque es genial </h3><br>  Si observamos las cr√≠ticas al token de copia de seguridad independiente descrito anteriormente, podemos ver que se eliminan todas las deficiencias de este m√©todo: <br><br><ul><li>  El token de respaldo ya no deber√≠a ser f√°cilmente accesible.  Ejemplos extremos pueden ser: tapar una ficha dentro de una pared de ladrillos, o enterrar un metro y medio en un jard√≠n o en otro lugar.  No es broma, estoy bastante listo para hacerlo; </li><li>  Independientemente de d√≥nde est√© ubicado, si me registro en alg√∫n servicio, no necesito hacer nada para agregar un token de respaldo a este servicio.  Solo uso mi token principal, y estoy tranquilo, sabiendo que tengo una copia de seguridad; </li><li>  Para los extra√±os, no est√° completamente claro d√≥nde se encuentra mi token de respaldo.  Incluso sabiendo que existe, tratar de encontrarlo usted mismo apenas tiene sentido; </li><li>  Es lo suficientemente seguro.  Incluso si algo malo le sucede a mi token principal, es muy poco probable que el mismo incidente afecte al token de respaldo; </li><li>  Es universal.  Este m√©todo de respaldo funcionar√° en cualquier servicio que admita U2F, independientemente de qu√© m√°s admita este servicio. </li></ul><br>  Y si algo malo sucede realmente con el token principal, entonces hago lo siguiente: <br><br><ul><li>  Excavo / no tengo claro un token de respaldo; </li><li>  Autenticarme en todos mis servicios con U2F, cancelando as√≠ el token principal; </li><li>  Ordeno un nuevo par de tokens y, una vez recibido, agrego un nuevo token principal en todos los servicios y revoco el antiguo. </li></ul><br>  Al menos para m√≠ personalmente, esta estrategia es un gran compromiso para un alto nivel de seguridad y una carga f√°cil de respaldo.  Es m√°s seguro y m√°s confiable que cualquier otro m√©todo. <br><br><h2>  Implementaci√≥n </h2><br><h3>  Descripci√≥n general del protocolo U2F </h3><br>  Antes de que podamos hablar sobre la implementaci√≥n, debemos entender en cierto nivel c√≥mo funciona U2F.  La mayor√≠a de los fabricantes lo implementan de la siguiente manera (no todos los siguientes est√°n presentes en el est√°ndar; algunas cosas son detalles de implementaci√≥n, pero la mayor√≠a de las implementaciones existentes, hasta donde yo s√©, funcionan de esa manera): <br><br>  <code>device_secret</code> programa en el token U2F, junto con un <code>counter</code> 32 bits, que solo se puede incrementar.  Cuando registramos un token U2F en un servicio, sucede lo siguiente: <br><br><ul><li>  El navegador env√≠a el <code>AppID</code> (de hecho, el nombre de dominio) al dispositivo U2F; </li><li>  El dispositivo genera un n√∫mero aleatorio ( <code>nonce</code> ), lo combina con el <code>AppID</code> , lo pasa todo a trav√©s de HMAC-SHA256 usando <code>device_secret</code> como clave, y el hash resultante se convierte en la clave privada para este servicio en particular: <code>service_private_key</code> ; </li><li>  Desde <code>service_private_key</code> , <code>service_public_key</code> genera la clave p√∫blica <code>service_public_key</code> ; </li><li>  El dispositivo toma el <code>AppID</code> nuevamente, lo combina con <code>service_private_key</code> , y lo pasa nuevamente a trav√©s del HMAC-SHA256 usando <code>device_secret</code> como clave.  El resultado ( <code>MAC</code> ), junto con el <code>nonce</code> que se gener√≥ anteriormente, se convierte en <code>key_handle</code> ; </li><li>  El dispositivo <code>key_handle</code> y <code>service_public_key</code> al navegador, y el navegador pasa al servicio, que guarda estos datos para futuras autenticaciones. </li></ul><br>  La autenticaci√≥n posterior se realiza de la siguiente manera: <br><br><ul><li>  El servicio genera un <code>challenge</code> (datos generados aleatoriamente) y lo env√≠a al navegador junto con <code>key_handle</code> (que consiste en <code>nonce</code> y <code>MAC</code> ).  El navegador pasa todo esto al dispositivo, junto con el <code>AppID</code> (es decir, el nombre de dominio); </li><li>  El dispositivo, que tiene <code>nonce</code> y <code>AppID</code> , genera <code>service_private_key</code> de la misma manera que se gener√≥ durante el registro; </li><li>  El dispositivo genera un <code>MAC</code> de la misma manera que durante el registro, y al compararlo con el <code>MAC</code> recibido del navegador, se asegura de que <code>nonce</code> no sea reemplazado y, por lo tanto, <code>service_private_key</code> confiable; </li><li>  El dispositivo incrementa el <code>counter</code> ; </li><li>  El dispositivo firma el <code>challenge</code> , el <code>AppID</code> y el <code>counter</code> utilizando <code>service_private_key</code> , y env√≠a la firma resultante ( <code>signature</code> ) y el <code>counter</code> navegador, que transfiere estos datos al servicio; </li><li>  El servicio verifica la <code>signature</code> usando <code>service_public_key</code> que tiene despu√©s del registro.  Adem√°s, la mayor√≠a de los servicios verifican que el <code>counter</code> mayor que el valor anterior (si esta no es la primera autenticaci√≥n).  El prop√≥sito de esta prueba es hacer que la clonaci√≥n de dispositivos U2F sea inaccesible.  Como resultado, si la <code>signature</code> coincide y el <code>counter</code> mayor que el valor anterior, la autenticaci√≥n se considera completada con √©xito y el servicio guarda el nuevo valor del <code>counter</code> . </li></ul><br>  Ahora describamos los detalles que est√°n directamente relacionados con la discusi√≥n. <br><br><h3>  Detalles de interes </h3><br>  El primero es que el dispositivo no almacena <code>service_private_key</code> para cada servicio: en su lugar, muestra <code>service_private_key</code> cada vez que usa HMAC-SHA256.  Esto es muy importante para nosotros: es obvio que si cada dispositivo almacenar√≠a claves √∫nicas por separado para cada servicio, solo este dispositivo podr√≠a autenticarse posteriormente. <br><br>  <i>Esto, por cierto, no es un requisito de U2F: U2F no indica c√≥mo deben almacenarse las claves, y algunas implementaciones tempranas de U2F, de hecho, almacenaron claves para cada servicio por separado.</i>  <i>Este enfoque tiene la desventaja de que el n√∫mero de servicios para los cuales se puede usar el dispositivo es limitado.</i>  <i>La derivaci√≥n de <code>service_private_key</code> elimina este inconveniente.</i> <br><br>  Y en segundo lugar, el dispositivo tiene un <code>counter</code> para evitar la clonaci√≥n. <br><br>  A primera vista, puede parecer que este <code>counter</code> no nos permite implementar la estrategia de respaldo discutida (al menos eso me pareci√≥ cuando trat√© de encontrar una soluci√≥n), pero de hecho, ¬°solo nos ayuda!  Te lo explicar√© ahora. <br><br><h3>  Idea principal </h3><br>  La idea es esta: en la etapa de producci√≥n, programe dos tokens de manera que ambos tengan el mismo <code>device_secret</code> , pero el token de respaldo necesita alguna correcci√≥n: en lugar de usar el <code>counter</code> en su forma pura (como lo hacen los tokens ordinarios), deber√≠a agregar alguna gran constante para <code>counter</code> .  Por ejemplo, la mitad del rango de 32 bits, es decir  aproximadamente <code>2 000 000 000</code> , parece razonable: es poco probable que agote tantas autenticaciones en toda mi vida. <br><br>  De hecho, eso es todo.  Simple y efectivo. <br><br>  Con dos tokens programados de esta manera, oculto el token de respaldo en un lugar <i>realmente</i> dif√≠cil de alcanzar y nunca lo toco.  Si sucede algo terrible y pierdo el acceso al token principal, a√∫n accedo al token de respaldo, y puedo usarlo de inmediato en todos los servicios donde registr√© el token principal, porque  La copia de seguridad tiene el mismo <code>device_secret</code> , y su <code>counter</code> comienza con un n√∫mero realmente grande, que no obtendr√© por el resto de mi vida. <br><br>  Adem√°s, llamo la atenci√≥n sobre el hecho de que <b>no propongo hacer tokens clonados</b> .  Dos tokens, aunque tienen el mismo <code>device_secret</code> , tienen contadores diferentes, y despu√©s de programar <code>device_secret</code> no deber√≠a haber forma de recuperarlo del dispositivo o crear un clon de otra manera. <br><br><h3>  Una nota sobre el contador </h3><br>  Un lector atento puede notar que existe el siguiente problema de seguridad: ¬øqu√© sucede si un atacante obtiene acceso al token principal e inicia de alguna manera 2,000,000,000 de autenticaciones?  Luego obtiene acceso al servicio incluso despu√©s de que el token de copia de seguridad se haya utilizado en este servicio. <br><br>  Afortunadamente, este problema tiene una soluci√≥n simple.  En cualquier caso, el contador debe implementarse en hardware (presumiblemente en alg√∫n procesador criptogr√°fico), y para una implementaci√≥n segura, este contador de hardware debe tener un rango de menos de 32 bits.  Por ejemplo, en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ATECC508A, los</a> contadores solo pueden contar hasta 2097151, por lo que al establecer la constante agregada al contador en cualquier valor mayor que el valor m√°ximo del contador, podemos estar seguros de que el token principal nunca puede contar para el contador en el token de respaldo. <br><br>  Para aclarar: supongamos que nuestro token U2F usa ATECC508A y denota el contador dentro del ATECC508A como <code>hw_counter</code> .  Entonces: <br><br><ul><li>  En el token principal, usamos para los c√°lculos: <code>hw_counter</code> ; </li><li>  En el token de respaldo, usamos para los c√°lculos: <code>hw_counter + 2000000000</code> . </li></ul><br>  Tenga en cuenta que no modificamos el <code>hw_counter</code> real dentro del procesador de cifrado;  seguir√° contando de 0 a 2097151. En cambio, cada vez que necesitamos obtener el valor del contador, leemos <code>hw_counter</code> de ATECC508A, luego agregamos nuestra constante y la devolvemos (para c√°lculos adicionales para U2F). <br><br>  Por lo tanto, el rango de valores de contador en el token principal ser√° [0, 2097151], mientras que el rango de valores de contador en el token de respaldo ser√° [2000000000, 2002097151].  El hecho de que estos rangos no se superpongan garantiza la cancelaci√≥n del token principal cuando se usa la copia de seguridad (si el servicio usa <code>counter</code> ; los servicios principales que verifiqu√© lo usan). <br><br><h3>  Implementaci√≥n real </h3><br>  Ninguno de los fabricantes de tokens U2F que conozco admite la personalizaci√≥n requerida hoy.  Pero afortunadamente, hay una implementaci√≥n de c√≥digo abierto del token U2F: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SoloKeys</a> . <br><br>  Escrib√≠ mi art√≠culo original (en ingl√©s) hace un a√±o, y esta parte est√° un poco anticuada: entonces SoloKeys estaba en la etapa de creaci√≥n de prototipos, y utilic√© la iteraci√≥n anterior del proyecto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">u2f-zero</a> .  Por lo tanto, no traducir√© esta parte ahora, ya que la √∫nica forma de obtener un dispositivo u2f-zero es soldarlo usted mismo, y no es aconsejable hacerlo (aunque hay instrucciones en el github). <br><br>  Sin embargo, todos los detalles de la modificaci√≥n necesaria de u2f-zero se dan en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo original</a> . <br><br>  Cuando mis manos lleguen a los solos, escribir√© instrucciones para su modificaci√≥n. <br><br>  De una forma u otra, esta es la √∫nica forma que conozco hoy para obtener un token U2F que funcione con una copia de seguridad confiable.  La comprobaci√≥n de varios servicios (al menos google y github) mostr√≥ que funciona: al registrar el token principal en el servicio, tambi√©n podemos usar la copia de seguridad, y despu√©s del primer uso de la copia de seguridad, el token principal deja de funcionar.  Awwwwwww.  &lt;3 <br><br><h3>  Advertencia </h3><br>  A pesar de que esta estrategia de respaldo es genial, no estoy tan seguro de su implementaci√≥n espec√≠fica a trav√©s de u2f-zero o solokey.  Este camino es la √∫nica forma de obtener lo que quieres, as√≠ que fui por ese camino;  pero suponiendo que el atacante obtenga acceso f√≠sico al dispositivo U2F, no estoy seguro de que piratear el dispositivo (es decir, obtener <code>device_secret</code> de √©l) sea tan dif√≠cil como lo ser√≠a en el caso de Yubikey u otros fabricantes importantes.  Los autores de solokey afirman que "el nivel de seguridad es el mismo que en la llave de un autom√≥vil moderno", pero no realic√© ning√∫n examen para confirmarlo. <br><br>  Sin embargo, para ser honesto, no estoy realmente preocupado por esto.  Si un atacante simplemente roba un token sin la intenci√≥n de devolverlo, entonces la complejidad de romperlo no importa, porque  un atacante puede simplemente usar este token para acceder a una cuenta y, por ejemplo, simplemente revocar este token y agregar otro.  Sin embargo, para esto tambi√©n debo tener otros problemas de seguridad graves.  El token U2F es solo el segundo factor. <br><br>  Por lo tanto, el √∫nico escenario en el que solokey puede ser menos seguro que otra cosa es cuando un atacante intenta acceder al dispositivo durante un corto per√≠odo de tiempo, obtener <code>device_secret</code> de √©l y devolverme el dispositivo, invisible para m√≠.  Para hacer esto, necesita leer el contenido del microcontrolador flash (o RAM en el momento adecuado), y esto no es muy trivial. <br><br>  Teniendo en cuenta todos los factores, creo que para m√≠ personalmente tener una copia de seguridad confiable es mucho m√°s importante que tener una implementaci√≥n de hardware ultra segura de un dispositivo U2F.  La probabilidad de problemas con una implementaci√≥n tan segura y la falta de una buena copia de seguridad es mayor que la probabilidad de problemas con u2f-zero (solokey) y la copia de seguridad. <br><br><h2>  Conclusi√≥n </h2><br>  La estrategia de respaldo considerada supera a las alternativas en todas las dimensiones: es universal, m√°s segura y m√°s confiable que cualquier otro m√©todo. <br><br>  Me alegrar√° si al menos uno de los principales fabricantes implementa esto en sus productos, pero a√∫n no hay certeza.  Un tipo de soporte de Yubico, James A., incluso me dijo que la copia de seguridad es lo que necesito, "no es posible con la forma en que est√° dise√±ado U2F", y despu√©s de establecer los detalles de implementaci√≥n, simplemente dej√≥ de responder. <br><br>  Afortunadamente, esto no fue tan imposible como cree Yubico. <br><br><hr><br>  <i>Mi art√≠culo original en ingl√©s: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copia de seguridad confiable, segura y universal para el token U2F</a> .</i>  <i>Porque</i>  <i>el autor del art√≠culo original es yo mismo, entonces, con su permiso, no puse este art√≠culo en la categor√≠a de "traducci√≥n"</i> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/474300/">https://habr.com/ru/post/474300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../474286/index.html">An√°lisis detallado del m√©todo simplex</a></li>
<li><a href="../474292/index.html">Tutorial JavaFX: Primeros pasos</a></li>
<li><a href="../474294/index.html">Compatibilidad binaria: ahora o nunca</a></li>
<li><a href="../474298/index.html">Implementaci√≥n de una puerta de enlace P2P Operaciones de transferencia de tarjeta a tarjeta</a></li>
<li><a href="../474302/index.html">C√≥mo escribir un script de prueba de usabilidad de aplicaci√≥n efectiva</a></li>
<li><a href="../474306/index.html">Haga que los estilos de apuntar, enfocar y estado activo sean diferentes.</a></li>
<li><a href="../474308/index.html">Tipos de API HTTP escritas en Python: experiencia de Instagram</a></li>
<li><a href="../474310/index.html">¬øHay n√∫meros aleatorios en CSS?</a></li>
<li><a href="../474312/index.html">Instalaci√≥n de la GUI en Windows Server Core</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>