<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ö üçµ üçª Compter la vitesse de t√©l√©chargement dans votre application üëáüèª üöπ ‚òÑÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Contexte 


 J'ai un petit et confortable projet pour animaux de compagnie, qui vous permet de t√©l√©charger des fichiers depuis Internet. Les fichiers ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compter la vitesse de t√©l√©chargement dans votre application</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465669/"><h2 id="predystoriya">  Contexte </h2><br><p>  J'ai un petit et confortable projet pour animaux de compagnie, qui vous permet de t√©l√©charger des fichiers depuis Internet.  Les fichiers sont regroup√©s et l'utilisateur ne voit pas chaque fichier, mais un certain regroupement.  Et l'ensemble du processus de t√©l√©chargement (et l'affichage de ce processus) d√©pendait fortement des donn√©es.  Les donn√©es ont √©t√© obtenues √† la vol√©e, c'est-√†-dire  l'utilisateur commence √† t√©l√©charger et il n'y a aucune information sur le montant √† t√©l√©charger en r√©alit√©. </p><br><p>  La mise en ≈ìuvre na√Øve d'au moins une sorte d'information est simplifi√©e - la progression du t√©l√©chargement est affich√©e sous la forme du rapport entre le nombre de t√©l√©chargements et le nombre total.  Il n'y a pas beaucoup d'informations pour l'utilisateur - juste une bande rampante, mais c'est mieux que rien, et c'est nettement mieux que le m√©canisme de chargement actuellement populaire sans indiquer de progr√®s. </p><br><p>  Et puis un utilisateur appara√Æt avec un probl√®me logique - dans un grand groupe, il n'est pas clair pourquoi les progr√®s progressent √† peine - dois-je t√©l√©charger beaucoup de fichiers ou √† faible vitesse?  Comme je l'ai mentionn√© ci-dessus - le nombre de fichiers n'est pas connu √† l'avance.  J'ai donc d√©cid√© d'ajouter un compteur de vitesse. </p><br><h2 id="analiz">  Analyse </h2><br><p>  C‚Äôest une bonne pratique de voir ceux qui ont d√©j√† r√©solu un probl√®me similaire afin de ne pas r√©inventer la roue.  Un logiciel diff√©rent ferme ces diff√©rentes t√¢ches, mais l'affichage est √† peu pr√®s le m√™me: </p><br><div class="scrollable-table"><table><thead><tr><th>  uTorrent </th><th>  Downloadmaster </th></tr></thead><tbody><tr><td><img src="https://habrastorage.org/webt/gb/af/1o/gbaf1ooewqcrbnsuyafn1dyxzvk.png" alt="uTorrent"></td><td><img src="https://habrastorage.org/webt/qg/mc/fa/qgmcfangfeegvjjtkcy6w-vloxe.png" alt="Downloadmaster"></td></tr></tbody></table></div><br><p>  Le point cl√© que je me suis identifi√© est que le premier affichage de la vitesse est n√©cessaire √† l'heure actuelle.  Pas quelle vitesse √©tait moyenne, pas quelle vitesse dans son ensemble √©tait moyenne depuis le d√©but, √† savoir ce que ce chiffre est au moment actuel.  En fait, c'est important lorsque j'arrive au code - je l'expliquerai s√©par√©ment. </p><br><p> Donc, nous avons besoin d'un simple chiffre comme <code>10 MB/s</code> ou quelque chose comme √ßa.  Comment le calculons-nous? </p><a name="habracut"></a><br><h2 id="teoriya-i-praktika">  Th√©orie et pratique </h2><br><p>  L'impl√©mentation de t√©l√©chargement existante a utilis√© <code>HttpWebRequest</code> et j'ai d√©cid√© de ne pas refaire le t√©l√©chargement lui-m√™me - ne touchez pas au m√©canisme de travail. </p><br><p>  Donc, l'impl√©mentation initiale sans aucun calcul: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = WebRequest.Create(uri); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> request.GetResponseAsync(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ms = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream()) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.GetResponseStream().CopyToAsync(ms); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ms.ToArray(); }</code> </pre> <br><p>  Au niveau d'une telle API, vous ne pouvez r√©pondre qu'√† un t√©l√©chargement de fichier complet, pour de petits groupes (ou m√™me pour un seul fichier), la vitesse ne peut en fait pas √™tre calcul√©e.  Nous suivons le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code</a> source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CopyToAsync</a> , copier-coller la logique simple √† partir de l√†: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[bufferSize]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytesRead; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((bytesRead = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ReadAsync(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer.Length, cancellationToken).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> destination.WriteAsync(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, bytesRead, cancellationToken).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><p>  Nous pouvons maintenant r√©pondre √† chaque tampon qui nous est donn√© sur le r√©seau. </p><br><p>  Donc, premi√®rement, ce que nous faisons au lieu du CopyToAsync encadr√©: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]&gt; GetBytesAsync(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Stream <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream()) { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">81920</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytesRead; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((bytesRead = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.ReadAsync(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer.Length).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> memory.WriteAsync(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, bytesRead).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); NetworkSpeed.AddInfo(bytesRead); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memory.ToArray(); } }</code> </pre> <br><p>  La seule chose vraiment ajout√©e est <code>NetworkSpeed.AddInfo</code> .  Et la seule chose que nous transmettons est le nombre d'octets t√©l√©charg√©s. </p><br><p>  Le code lui-m√™me pour le t√©l√©chargement ressemble √† ceci: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = WebRequest.Create(uri); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> request.GetResponseAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.GetResponseStream().GetBytesAsync();</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Option pour WebClient</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastRecorded = <span class="hljs-number"><span class="hljs-number">0L</span></span>; client.DownloadProgressChanged += (sender, eventArgs) =&gt; { NetworkSpeed.AddInfo(eventArgs.BytesReceived - lastRecorded); lastRecorded = eventArgs.BytesReceived; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.DownloadDataTaskAsync(uri);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Option pour HttpClient</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> httpClient.GetStreamAsync(uri); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> content.GetBytesAsync();</code> </pre> </div></div><br><p>  Eh bien, la moiti√© du probl√®me est r√©solu - nous savons <em>combien</em> nous avons t√©l√©charg√©.  Nous nous tournons vers la vitesse. </p><br><p>  Selon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wikipedia</a> : </p><br><blockquote>  Taux de transfert de donn√©es - la quantit√© de donn√©es transmises par unit√© de temps. </blockquote><br><h3 id="pervyy-naivnyy-podhod">  Premi√®re approche na√Øve </h3><br><p>  Nous avons un volume.  Le temps peut √™tre pris litt√©ralement au d√©marrage et faire la diff√©rence avec <code>DateTime.Now</code> .  Prendre et partager? <br>  Pour les utilitaires de console comme <strong>curl,</strong> cela est possible et logique. <br>  Mais si votre application est un peu plus compliqu√©e, le bouton de pause compliquera litt√©ralement votre vie. </p><br><p>  <strong><em>Un peu sur la pause</em></strong> <br>  Peut-√™tre que je suis tr√®s na√Øf, ou peut-√™tre que la question n'est vraiment pas si simple - mais la pause me fait r√©fl√©chir constamment.  Une pause pendant le t√©l√©chargement peut se comporter d'au moins trois fa√ßons: </p><br><ul><li>  interrompre le t√©l√©chargement du fichier, recommencer apr√®s </li><li>  ne t√©l√©chargez simplement pas le fichier plus loin, esp√©rons que le serveur continuera apr√®s </li><li>  t√©l√©chargez les fichiers d√©j√† d√©marr√©s, n'en t√©l√©chargez pas de nouveaux, t√©l√©chargez-en de nouveaux apr√®s </li></ul><br><p>  √âtant donn√© que les deux premiers entra√Ænent la perte d'informations d√©j√† t√©l√©charg√©es, j'utilise le troisi√®me. <br>  Un peu plus haut, j'ai remarqu√© que la vitesse est n√©cessaire pr√©cis√©ment √† un moment donn√©.  Donc, une pause complique cette affaire: </p><br><ul><li>  vous ne pouvez pas calculer correctement la vitesse moyenne en prenant simplement le volume pendant un certain temps </li><li>  Une pause peut avoir des raisons externes qui changeront la vitesse et le canal (se reconnecter au r√©seau du fournisseur, passer au VPN, mettre fin √† uTorrent qui prend tout le canal), ce qui entra√Ænera un changement de la vitesse r√©elle <br>  En fait, une pause divise tous les indicateurs en avant et apr√®s.  Cela n'affecte pas particuli√®rement le code ci-dessous, juste une minute d'informations amusantes √† penser. </li></ul><br><h3 id="vtoroy-naivnyy-podhod">  Seconde approche na√Øve </h3><br><p>  Ajoutez une minuterie.  La minuterie √† chaque p√©riode prendra toutes les derni√®res informations sur le volume t√©l√©charg√© et recalculera l'indicateur de vitesse.  Et si vous d√©finissez le minuteur par seconde, toutes les informations re√ßues pour cette seconde sur le volume t√©l√©charg√© seront √©gales √† la vitesse pour cette seconde: </p><br><div class="spoiler">  <b class="spoiler_title">L'impl√©mentation compl√®te de la classe NetworkSpeed</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NetworkSpeed</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> TotalSpeed { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> totalSpeed; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> totalSpeed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> TimerInterval = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Timer speedTimer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(state =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> now = <span class="hljs-number"><span class="hljs-number">0L</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ReceivedStorage.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> added)) now += added; totalSpeed = now; }, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, TimerInterval); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt; ReceivedStorage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ReceivedStorage.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> _)) { } totalSpeed = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> received</span></span></span><span class="hljs-function">)</span></span> { ReceivedStorage.Enqueue(received); } }</code> </pre> </div></div><br><p>  Par rapport √† la premi√®re option, une telle impl√©mentation commence √† r√©pondre √† une pause - la vitesse tombe √† 0 dans la seconde suivante apr√®s l'arriv√©e des donn√©es √† l'ext√©rieur. <br>  Mais il y a aussi des inconv√©nients.  Nous travaillons avec une m√©moire tampon de 80 Ko, ce qui signifie que le t√©l√©chargement d√©marr√© en une seconde ne sera affich√© que la prochaine.  Et avec un grand flux de t√©l√©chargements parall√®les, de telles erreurs de mesure afficheront n'importe quoi - j'avais un √©cart allant jusqu'√† 30% des nombres r√©els.  Je ne l'avais peut-√™tre pas remarqu√©, mais d√©passer 100 Mbit semblait <em>trop suspect</em> . </p><br><h3 id="tretiy-podhod">  Troisi√®me approche </h3><br><p>  La deuxi√®me option est d√©j√† assez proche de la v√©rit√©, et son erreur a √©t√© davantage observ√©e au d√©but du t√©l√©chargement, et non tout au long du cycle de vie. <br>  Par cons√©quent, une solution simple consiste √† prendre comme indicateur non pas le chiffre par seconde, mais la moyenne des trois derni√®res secondes.  Trois ici est une constante magique assortie √† l'≈ìil.  D'une part, je voulais un affichage agr√©able de la croissance et du d√©clin de la vitesse, d'autre part - pour que la vitesse soit plus proche de la v√©rit√©. </p><br><p>  L'impl√©mentation est un peu compliqu√©e, mais en g√©n√©ral, rien de tel: </p><br><div class="spoiler">  <b class="spoiler_title">L'impl√©mentation compl√®te de la classe NetworkSpeed</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NetworkSpeed</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> TotalSpeed { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> totalSpeed; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> totalSpeed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Seconds = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> TimerInterval = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Timer speedTimer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(state =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> now = <span class="hljs-number"><span class="hljs-number">0L</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ReceivedStorage.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> added)) now += added; LastSpeeds.Enqueue(now); totalSpeed = LastSpeeds.Average(); OnUpdated(totalSpeed); }, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, TimerInterval); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> LimitedConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; LastSpeeds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LimitedConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(Seconds); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt; ReceivedStorage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ReceivedStorage.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> _)) { } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (LastSpeeds.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> _)) { } totalSpeed = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> received</span></span></span><span class="hljs-function">)</span></span> { ReceivedStorage.Enqueue(received); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; Updated; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LimitedConcurrentQueue</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">ConcurrentQueue</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Limit { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> new </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Count &gt;= Limit) TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> _); <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enqueue(item); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LimitedConcurrentQueue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> limit</span></span></span><span class="hljs-function">)</span></span> { Limit = limit; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnUpdated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { Updated?.Invoke(obj); } }</code> </pre> </div></div><br><p>  Quelques points: </p><br><ul><li>  au moment de la mise en ≈ìuvre, je n'ai pas trouv√© la file d'attente termin√©e avec une limite sur le nombre d'√©l√©ments et l'ai prise sur Internet, dans le code ci-dessus c'est <code>LimitedConcurrentQueue</code> . </li><li>  au lieu d'impl√©menter <code>INotifyPropertyChanged</code> pour une raison quelconque, <code>Action</code> , l'utilisation est pratiquement la m√™me, je ne me souviens pas des raisons.  La logique est simple - l'indicateur change, les utilisateurs doivent en √™tre inform√©s.  L'impl√©mentation peut √™tre n'importe laquelle, m√™me <code>IObservable</code> , √† qui elle est plus pratique. </li></ul><br><h2 id="i-nemnogo-chitabelnosti">  Et un peu de lisibilit√© </h2><br><p>  L'API donne la vitesse en octets, pour plus de lisibilit√© une simple (prise sur Internet) est utile </p><br><div class="spoiler">  <b class="spoiler_title">convertisseur</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HumanizeByteSize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> byteCount</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] suf = { <span class="hljs-string"><span class="hljs-string">"B"</span></span>, <span class="hljs-string"><span class="hljs-string">"KB"</span></span>, <span class="hljs-string"><span class="hljs-string">"MB"</span></span>, <span class="hljs-string"><span class="hljs-string">"GB"</span></span>, <span class="hljs-string"><span class="hljs-string">"TB"</span></span>, <span class="hljs-string"><span class="hljs-string">"PB"</span></span>, <span class="hljs-string"><span class="hljs-string">"EB"</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//Longs run out around EB if (byteCount == 0) return "0" + suf[0]; long bytes = Math.Abs(byteCount); int place = Convert.ToInt32(Math.Floor(Math.Log(bytes, 1024))); double num = Math.Round(bytes / Math.Pow(1024, place), 1); return Math.Sign(byteCount) * num + suf[place]; } public static string HumanizeByteSize(this double byteCount) { if (double.IsNaN(byteCount) || double.IsInfinity(byteCount) || byteCount == 0) return string.Empty; return HumanizeByteSize((long)byteCount); }</span></span></code> </pre> </div></div><br><p>  Permettez-moi de vous rappeler que la vitesse en octets, c'est-√†-dire  par canal de 100 Mbits ne devrait pas √©mettre plus de 12,5 Mo. </p><br><p>  √Ä quoi cela ressemble finalement: </p><br><div class="spoiler">  <b class="spoiler_title">T√©l√©chargez l'image ubuntu</b> <div class="spoiler_text"><blockquote>  Vitesse actuelle 904,5 Ko / s <br>  Vitesse actuelle 1,8 Mo / s <br>  Vitesse actuelle 2,9 Mo / s <br>  Vitesse actuelle 3,2 Mo / s <br>  Vitesse actuelle 2,9 Mo / s <br>  Vitesse actuelle 2,8 Mo / s <br>  Vitesse actuelle 3MB / s <br>  Vitesse actuelle 3,1 Mo / s <br>  Vitesse actuelle 3,2 Mo / s <br>  Vitesse actuelle 3,3 Mo / s <br>  Vitesse actuelle 3,5 Mo / s <br>  Vitesse actuelle 3,6 Mo / s <br>  Vitesse actuelle 3,6 Mo / s <br>  Vitesse actuelle 3,6 Mo / s <br>  ... </blockquote></div></div><br><div class="spoiler">  <b class="spoiler_title">Eh bien, plusieurs images √† la fois</b> <div class="spoiler_text"><blockquote>  Vitesse actuelle 1,2 Mo / s <br>  Vitesse actuelle 3,8 Mo / s <br>  Vitesse actuelle 7,3 Mo / s <br>  Vitesse actuelle 10 Mo / s <br>  Vitesse actuelle 10,3 Mo / s <br>  Vitesse actuelle 10 Mo / s <br>  Vitesse actuelle 9,7 Mo / s <br>  Vitesse actuelle 9,8 Mo / s <br>  Vitesse actuelle 10,1 Mo / s <br>  Vitesse actuelle 9,8 Mo / s <br>  Vitesse actuelle 9,1 Mo / s <br>  Vitesse actuelle 8,6 Mo / s <br>  Vitesse actuelle 8,4 Mo / s <br>  ... </blockquote></div></div><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  C'√©tait int√©ressant de faire face √† une t√¢che apparemment banale de compter la vitesse.  Et m√™me si le code fonctionne et donne quelques chiffres, je veux √©couter les critiques - ce que j'ai manqu√©, comment pourrais-je faire mieux, peut-√™tre qu'il existe des solutions toutes faites. </p><br><p>  Je veux dire merci √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stack Overflow en russe</a> et en particulier √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">VladD-exrabbit</a> - bien qu'il y ait la moiti√© de la r√©ponse dans une bonne question, tous les conseils et toute aide vous font toujours avancer. </p><br><p>  Je veux vous rappeler qu'il s'agit d'un projet pour animaux de compagnie - c'est pourquoi la classe est statique et unique, donc la pr√©cision n'est pas vraiment.  Je vois beaucoup de petites choses qui pourraient √™tre mieux faites, mais ... il y a toujours autre chose √† faire, donc pour l'instant je pense que c'est la vitesse et je pense que ce n'est pas une mauvaise option. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr465669/">https://habr.com/ru/post/fr465669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr465657/index.html">Loi sur la maladie de Parkinson: vous pouvez la battre</a></li>
<li><a href="../fr465659/index.html">R√©ponse √† l'article ¬´La conqu√™te de la Sib√©rie par les Moscovites¬ª ou vingt ans plus tard</a></li>
<li><a href="../fr465661/index.html">Avez-vous aussi un tel ami? Ou peut-√™tre que c'est toi?</a></li>
<li><a href="../fr465663/index.html">FAQ sur l'API Superjob (Offre d'emploi)</a></li>
<li><a href="../fr465667/index.html">Spring Cache: de la connexion de la mise en cache en 1 minute √† la configuration flexible du gestionnaire de cache</a></li>
<li><a href="../fr465673/index.html">Hedi Lamarr: inventeur d'Hollywood</a></li>
<li><a href="../fr465675/index.html">Comment la NASA se soucie de la s√©curit√© et du renseignement de ses astronautes</a></li>
<li><a href="../fr465677/index.html">Oubliez le Walkman: tout tourne autour des √©couteurs</a></li>
<li><a href="../fr465679/index.html">Que peut faire une montre en plus d'afficher l'heure et comment choisir votre premi√®re montre</a></li>
<li><a href="../fr465681/index.html">Comme un feu cr√©pitant, le grincement des portes et le bruit le plus ordinaire deviennent de la musique et tombent sur des pistes √©lectro-acoustiques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>