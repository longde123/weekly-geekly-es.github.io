<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😽 ⏪ 😓 Apollo: 9 bulan - penerbangan normal 🍹 📝 🏚️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya, nama saya Semyon Levenson, saya bekerja sebagai pemimpin tim di proyek Stream dari Rambler Group dan saya ingin berbicara tentang penga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apollo: 9 bulan - penerbangan normal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/rambler-co/blog/418417/"><p><img src="https://habrastorage.org/webt/ww/0p/je/ww0pjeoegdfxhlx-zfh54jbxvyw.png" alt="gambar"></p><br><p>  Halo semuanya, nama saya Semyon Levenson, saya bekerja sebagai pemimpin tim di proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Stream</a> dari Rambler Group dan saya ingin berbicara tentang pengalaman kami dengan Apollo. </p><br><p>  Saya akan menjelaskan apa "Stream" itu.  Ini adalah layanan otomatis untuk pengusaha, yang memungkinkan Anda untuk menarik pelanggan dari Internet ke bisnis Anda tanpa terlibat dalam periklanan, dan dengan cepat membuat situs sederhana tanpa menjadi ahli tata letak. </p><a name="habracut"></a><br><p>  Tangkapan layar menunjukkan salah satu langkah untuk membuat halaman arahan. </p><br><p><img src="https://habrastorage.org/webt/rf/vg/dj/rfvgdjmcvzpwydgz9qcdu8_3eay.png"></p><br><h3 id="chto-bylo-vnachale">  Apa awalnya? </h3><br><p> Dan pada awalnya ada MVP, banyak Twig, jQuery dan tenggat waktu yang sangat ketat.  Tapi kami pergi dengan cara yang tidak standar dan memutuskan untuk membuat desain ulang.  Desain ulang tidak dalam arti "gaya ditambal", tetapi memutuskan untuk sepenuhnya meninjau sistem.  Dan ini adalah tahap yang baik bagi kami untuk merakit frontend yang sempurna.  Bagaimanapun, kami, tim pengembangan, harus terus mendukung ini dan melaksanakan tugas-tugas lain atas dasar ini, untuk mencapai tujuan baru yang ditetapkan oleh tim produk. </p><br><p>  Departemen kami telah mengumpulkan cukup banyak keahlian dalam menggunakan React.  Saya tidak ingin menghabiskan 2 minggu menyiapkan webpack, jadi saya memutuskan untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CRA</a> (Buat Aplikasi Bereaksi).  Untuk style, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Styled Components</a> diambil, dan di mana tanpa mengetik - mereka mengambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flow</a> .  Mereka menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redux</a> untuk Manajemen Negara, tetapi sebagai hasilnya ternyata kami sama sekali tidak membutuhkannya, tetapi lebih pada itu nanti. </p><br><p>  Kami menyusun frontend sempurna kami dan menyadari bahwa kami telah melupakan sesuatu.  Ternyata, kami lupa tentang backend, atau lebih tepatnya tentang interaksi dengannya.  Ketika Anda memikirkan tentang apa yang dapat kita gunakan untuk mengatur interaksi ini, hal pertama yang terlintas dalam pikiran - tentu saja, adalah Istirahat.  Tidak, kami tidak pergi untuk beristirahat (tersenyum), tetapi mulai berbicara tentang API yang tenang.  Pada prinsipnya, cerita itu akrab, membentang untuk waktu yang lama, tetapi kita juga tahu tentang masalah dengannya.  Kami akan membicarakannya. </p><br><p>  Masalah pertama adalah dokumentasi.  Tenang, tentu saja, tidak mengatakan bagaimana mengatur dokumentasi.  Di sini ada opsi untuk menggunakan kesombongan yang sama, tetapi sebenarnya itu adalah pengenalan entitas tambahan dan kerumitan proses. </p><br><p>  Masalah kedua adalah bagaimana mengatur dukungan untuk versi API. </p><br><p>  Masalah penting ketiga adalah sejumlah besar kueri atau titik akhir khusus yang dapat kami berikan penghargaan.  Misalkan kita perlu meminta posting, untuk posting ini - komentar dan lebih banyak penulis dari komentar ini.  Dalam Rest klasik, kita harus membuat setidaknya 3 pertanyaan.  Ya, kami dapat menghargai titik akhir khusus, dan semua ini dapat dikurangi menjadi 1 permintaan, tetapi ini sudah merupakan komplikasi. </p><br><p><img src="https://habrastorage.org/webt/mo/os/uv/moosuvdayfwhr7r2dqswlg9nuuk.png"><br>  <em>Terima kasih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sashko Stubailo</a> untuk ilustrasinya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.</a></em> </p><br><h3 id="reshenie">  Solusi </h3><br><p>  Dan saat ini, Facebook membantu kami dengan GraphQL.  Apa itu GraphQL?  Ini adalah platform, tetapi hari ini kita akan melihat salah satu bagiannya - ini adalah Bahasa Query untuk API Anda, hanya sebuah bahasa, dan yang cukup primitif.  Dan itu bekerja sesederhana mungkin - saat kami meminta semacam entitas, kami juga mendapatkannya. </p><br><p>  Minta: </p><br><pre><code class="hljs objectivec">{ me { <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> isAcceptedFreeOffer balance } }</code> </pre> <br><p>  Jawabannya adalah: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"me"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"isAcceptedFreeOffer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"balance"</span></span>: <span class="hljs-number"><span class="hljs-number">100000</span></span> } }</code> </pre> <br><p>  Tapi GraphQL tidak hanya tentang membaca, tetapi juga tentang mengubah data.  Untuk melakukan ini, ada mutasi di GraphQL.  Mutasi penting karena kita dapat mendeklarasikan respons yang diinginkan dari backend, dengan perubahan yang berhasil.  Namun, ada beberapa nuansa.  Misalnya, jika mutasi kami memengaruhi data di luar batas grafik. </p><br><p>  Contoh mutasi di mana kami menggunakan penawaran gratis: </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">mutation</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">acceptOffer</span></span> (_type: FREE) { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> isAcceptedFreeOffer } }</code> </pre> <br><p>  Sebagai tanggapan, kami mendapatkan struktur yang sama dengan yang diminta </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"acceptOffer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"isAcceptedFreeOffer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> <br><p>  Interaksi dengan backend GraphQL dapat dilakukan menggunakan pengambilan biasa. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/graphql'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, headers: { <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span> }, body: <span class="hljs-type"><span class="hljs-type">JSON</span></span>.stringify({ query: <span class="hljs-string"><span class="hljs-string">'{me { id balance } }'</span></span> }) });</code> </pre> <br><h3 id="kakie-zhe-plyusy-u-graphql">  Apa kelebihan GraphQL? </h3><br><p>  Plus pertama dan sangat keren yang dapat dihargai ketika Anda mulai bekerja dengannya adalah bahwa bahasa ini sangat diketik dan didokumentasikan sendiri.  Dengan mendesain skema GraphQL di server, kita dapat langsung menggambarkan tipe dan atribut langsung dalam kode. </p><br><p><img src="https://habrastorage.org/webt/7l/oh/ze/7lohze1ioujv7qchctics80_qd8.png"></p><br><p>  Seperti disebutkan di atas, RESTful memiliki masalah versi.  GraphQL menerapkan solusi yang sangat elegan untuk ini - usang. </p><br><p><img src="https://habrastorage.org/webt/zr/la/rr/zrlarrevkaenkyjdx7yzm6wbm5a.png"></p><br><p>  Misalkan kita punya Film, kita perluas, jadi kita punya sutradara.  Dan pada titik tertentu kami hanya menjadikan sutradara sebagai tipe terpisah.  Pertanyaannya adalah, apa yang harus dilakukan dengan bidang direktur terakhir?  Ada dua jawaban untuk itu: kita menghapus bidang ini, atau menandainya sudah usang, dan secara otomatis menghilang dari dokumentasi. </p><br><p>  Kami memutuskan secara mandiri apa yang kami butuhkan. </p><br><p>  Kami ingat gambar sebelumnya, di mana semuanya berjalan dengan REST, di sini kami memiliki semuanya digabungkan menjadi satu permintaan dan tidak memerlukan penyesuaian dari pengembangan backend.  Begitu mereka semua menggambarkannya, dan kita memelintir, memelintir, menyulap. </p><br><p><img src="https://habrastorage.org/webt/k2/rs/rp/k2rsrp234e3xoe6gs8jmwpy1rse.png"></p><br><p>  Tapi bukan tanpa lalat di salep.  Pada prinsipnya, tidak ada begitu banyak kelemahan pada GraphQL di frontend, karena pada awalnya dikembangkan untuk menyelesaikan masalah frontend.  Tetapi backend tidak berjalan dengan lancar ... Mereka memiliki masalah seperti N +1.  Ambil kueri sebagai contoh: </p><br><pre> <code class="hljs objectivec">{ landings(_page: <span class="hljs-number"><span class="hljs-number">0</span></span>, limit: <span class="hljs-number"><span class="hljs-number">20</span></span>) { nodes { <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> title } totalCount } }</code> </pre> <br><p>  Permintaan sederhana, kami meminta 20 situs dan jumlah situs yang kami miliki.  Dan di backend, ini bisa berubah menjadi 21 permintaan basis data.  Masalah ini diketahui, dipecahkan.  Untuk Node JS ada paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dataloader</a> dari Facebook.  Untuk bahasa lain, Anda dapat menemukan solusi Anda sendiri. </p><br><p>  Ada juga masalah sarang yang dalam.  Misalnya, kami memiliki album, album ini memiliki lagu, dan melalui lagu kami juga bisa mendapatkan album.  Untuk melakukan ini, buat pertanyaan berikut: </p><br><pre> <code class="hljs objectivec">{ album(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>) { songs { title artists } } }</code> </pre> <br><pre> <code class="hljs dos">{ song(id: <span class="hljs-number"><span class="hljs-number">1337</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> album { <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> } } }</code> </pre> <br><p>  Dengan demikian, kita mendapatkan kueri rekursif, yang juga secara mendasar menempatkan kita sebagai basis. </p><br><pre> <code class="hljs objectivec">query evil { album(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>) { songs { album { songs { album {</code> </pre> <br><p>  Masalah ini juga diketahui, solusi untuk Node JS adalah batas kedalaman GraphQL, untuk bahasa lain ada juga solusi. </p><br><p>  Jadi, kami memutuskan pada GraphQL.  Saatnya memilih perpustakaan yang akan berfungsi dengan GraphQL API.  Contoh dalam beberapa baris dengan fetch, yang diperlihatkan di atas, hanyalah transport.  Namun berkat skema dan deklaratifnya, kami juga dapat men-cache permintaan di depan, dan bekerja dengan kinerja yang lebih baik dengan backend GraphQL. </p><br><p>  Jadi kami memiliki dua pemain utama - Relay dan Apollo. </p><br><h3 id="relay">  Relay </h3><br><p>  Relay adalah pengembangan Facebook, mereka menggunakannya sendiri.  Seperti Oculus, Circle CI, Arsti dan Friday. </p><br><h4 id="kakie-plyusy-est-u-relay">  Apa kelebihan Relay? </h4><br><p>  Nilai tambah langsungnya adalah pengembangnya adalah Facebook.  React, Flow, dan GraphQL adalah perkembangan Facebook, yang semuanya adalah teka-teki jigsaw yang dirancang satu sama lain.  Di mana kita tanpa bintang di Github, Relay memiliki hampir 11.000, Apollo memiliki 7600 untuk perbandingan. Relay yang keren adalah Relay-compiler, alat yang mengoptimalkan dan menganalisis permintaan GraphQL Anda pada tingkat pembangunan proyek Anda .  Kita dapat mengasumsikan bahwa ini hanya untuk GraphQL: </p><br><pre> <code class="hljs scala">#  <span class="hljs-type"><span class="hljs-type">Relay</span></span>-compiler foo { # <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooType</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">on</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooType</span></span></span><span class="hljs-class"> </span></span>{ # matches the parent <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extraneous</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> } } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">#</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class"> </span></span>{ id }</code> </pre> <br><h4 id="kakie-minusy-u-relay">  Apa kontra dari Relay? </h4><br><p>  Minus pertama * adalah kurangnya SSR di luar kotak.  Github masih memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah</a> terbuka.  Mengapa di bawah tanda bintang - karena sudah ada solusi, tetapi mereka pihak ketiga, dan di samping itu, cukup ambigu. </p><br><p><img src="https://habrastorage.org/webt/ee/1b/rc/ee1brchbmmgdpqka4kpf3ogo2my.png"></p><br><p>  Sekali lagi, Relay adalah spesifikasi.  Faktanya adalah GraphQL sudah menjadi spesifikasi, dan Relay adalah spesifikasi di atas spesifikasi. </p><br><p><img src="https://habrastorage.org/webt/f6/ds/nl/f6dsnlwzog77hrwpboaru95u7_y.png"></p><br><p>  Misalnya, Relay pagination diterapkan secara berbeda, kursor muncul di sini. </p><br><pre> <code class="hljs pgsql">{ friends(first: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">after</span></span>: "opaqueCursor") { edges { <span class="hljs-keyword"><span class="hljs-keyword">cursor</span></span> node { id <span class="hljs-type"><span class="hljs-type">name</span></span> } } pageInfo { hasNextPage } } }</code> </pre> <br><p>  Kami tidak lagi menggunakan offset dan batas yang biasa.  Untuk feed di feed, ini adalah topik yang bagus, tetapi ketika kita mulai melakukan semua jenis grid, maka ada rasa sakit. </p><br><p>  Facebook memecahkan masalahnya dengan menulis perpustakaan untuk React.  Ada solusi untuk perpustakaan lain, untuk vue.js, misalnya - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vue-relay</a> .  Tetapi jika kita memperhatikan jumlah bintang dan komit, maka di sini juga, tidak semuanya begitu lancar dan bisa tidak stabil.  Sebagai contoh, Buat Bereaksi Aplikasi keluar dari kotak CRA mencegah Anda menggunakan Relay-compiler.  Tetapi Anda dapat mengatasi batasan ini dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">reaksi-aplikasi-rewired</a> . </p><br><p><img src="https://habrastorage.org/webt/dj/wb/i2/djwbi2it6brz4qxdipg0wcdyhpa.png"></p><br><h2 id="apollo">  Apollo </h2><br><p>  Kandidat kedua kami adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apollo</a> .  Dikembangkan oleh timnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Meteor</a> .  Apollo menggunakan perintah terkenal seperti: AirBnB, ticketmaster, Opentable, dll. </p><br><h3 id="kakie-est-plyusy-u-apollo">  Apa kelebihan Apollo? </h3><br><p>  Nilai tambah penting pertama adalah bahwa Apollo dikembangkan sebagai kerangka kerja agnostik perpustakaan.  Misalnya, jika kita sekarang ingin menulis ulang semua yang ada di Angular, maka ini tidak akan menjadi masalah, Apollo bekerja dengan ini.  Dan Anda bahkan dapat menulis semuanya di Vanilla. </p><br><p>  Apollo memiliki dokumentasi yang keren, ada solusi siap pakai untuk masalah umum. </p><br><p><img src="https://habrastorage.org/webt/tq/wu/ko/tqwukoydh-b7fem6dwusyuwklgw.png"></p><br><p>  Plus lainnya Apollo - API yang kuat.  Pada prinsipnya, mereka yang bekerja dengan Redux akan menemukan pendekatan umum di sini: ada ApolloProvider (seperti Provux untuk Redux), dan alih-alih menyimpan untuk Apollo ini disebut klien: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ApolloProvider } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-apollo'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ApolloClient } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./ApolloClient'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ApolloProvider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">client</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{ApolloClient}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ... </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ApolloProvider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> );</code> </pre> <br><p>  Pada tingkat komponen itu sendiri, kami memiliki graphql HOC yang disediakan sebagai terhubung.  Dan kami menulis permintaan GraphQL yang sudah ada di dalam, seperti MapStateToProps di Redux. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { graphql } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-apollo'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gql <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-tag'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Landing } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Landing'</span></span>; graphql(gql<span class="hljs-string"><span class="hljs-string">` { landing(id: 1) { id title } } `</span></span>)(Landing);</code> </pre> <br><p>  Tetapi ketika kita melakukan MapStateToProps di Redux, kita mengambil data lokal.  Jika tidak ada data lokal, maka Apollo sendiri pergi ke server untuk mereka.  Alat peraga yang sangat nyaman jatuh ke dalam komponen itu sendiri. </p><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Landing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ data, loading, error, refetch, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...other</span></span></span></span><span class="hljs-function"><span class="hljs-params"> })</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Ini adalah: <br>  • data; <br>  • status unduhan; <br>  • kesalahan jika terjadi; <br>  fungsi pembantu seperti mengambil ulang untuk memuat kembali data atau mengambil lebih ke pagination.  Ada juga nilai tambah yang besar untuk Apollo dan Relay, yang merupakan UI Optimis.  Ini memungkinkan Anda untuk melakukan undo / redo di tingkat permintaan: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.setNotificationStatusMutation({ variables: { … }, optimisticResponse: { … } });</code> </pre> <br><p>  Misalnya, pengguna mengklik tombol "suka", dan "suka" segera dihitung.  Dalam hal ini, permintaan ke server akan dikirim di latar belakang.  Jika beberapa kesalahan terjadi selama proses pengiriman, maka data yang dapat diubah akan kembali ke kondisi aslinya sendiri. </p><br><p>  Render sisi server diimplementasikan dengan baik, kami menetapkan satu flag pada klien dan semuanya siap. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">new</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ApolloClient</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">ssrMode</span></span>: true, ... });</code> </pre> <br><p>  Tetapi di sini saya ingin berbicara tentang Initial State.  Ketika Apollo memasaknya untuk dirinya sendiri, semuanya bekerja dengan baik. </p><br><pre> <code class="hljs javascript">&lt;script&gt; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__APOLLO_STATE__ = client.extract(); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApolloClient({ <span class="hljs-attr"><span class="hljs-attr">cache</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMemoryCache().restore(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__APOLLO_STATE__), link });</code> </pre> <br><p>  Tetapi kami tidak memiliki rendering sisi Server, dan backend mendorong kueri GraphQL tertentu ke variabel global.  Di sini Anda memerlukan kruk kecil, Anda perlu menulis fungsi Transform yang respons GraphQL dari backend akan berubah menjadi format yang diperlukan untuk Apollo. </p><br><pre> <code class="hljs javascript">&lt;script&gt; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__APOLLO_STATE__ = transform({…}); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApolloClient({ <span class="hljs-attr"><span class="hljs-attr">cache</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMemoryCache().restore(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__APOLLO_STATE__), link });</code> </pre> <br><p>  Kelebihan lain dari Apollo adalah dapat disesuaikan dengan baik.  Kita semua ingat middleware dari Redux, semuanya sama di sini, hanya ini yang disebut tautan. </p><br><p><img src="https://habrastorage.org/webt/va/gw/-z/vagw-zeeg2j0t7pjuawtw4tllq8.png"></p><br><p>  Saya ingin mencatat dua tautan secara terpisah: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apollo-link-state</a> , yang diperlukan untuk menyimpan keadaan lokal tanpa adanya Redux, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apollo-link-rest</a> , jika kita ingin menulis permintaan GraphQL ke API Istirahat.  Namun, dengan yang terakhir Anda harus sangat berhati-hati, karena  masalah tertentu mungkin timbul. </p><br><h4 id="minusy-u-apollo-tozhe-est">  Apollo juga memiliki kontra </h4><br><p>  Mari kita lihat sebuah contoh.  Ada masalah kinerja yang tidak terduga: 2.000 item diminta di frontend (itu adalah direktori), dan masalah kinerja dimulai.  Setelah melihatnya di debugger, ternyata Apollo memakan banyak sumber daya saat membaca, masalah ini pada dasarnya ditutup, sekarang semuanya baik-baik saja, tetapi ada dosa seperti itu. </p><br><p>  Juga, pembuatan ulang ternyata sangat tidak jelas ... </p><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Landing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ loading, refetch, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...other</span></span></span></span><span class="hljs-function"><span class="hljs-params"> })</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Tampaknya ketika kami melakukan permintaan ulang data, terlebih lagi, jika permintaan sebelumnya berakhir dengan kesalahan, maka pemuatan akan menjadi benar.  Tapi tidak! </p><br><p>  Agar ini terjadi, Anda perlu menentukan notifyOnNetworkStatusChange: true di graphql HOC, atau menyimpan keadaan pengambilan kembali secara lokal. </p><br><h3 id="apollo-vs-relay">  Apollo vs  Relay </h3><br><p>  Jadi, kami mendapat meja seperti itu, kami semua menimbang, menghitung, dan kami memiliki 76% di belakang Apollo. </p><br><p><img src="https://habrastorage.org/webt/ry/if/wx/ryifwxtkdmb4yvc2xczme5xoqkc.png"></p><br><p>  Jadi kami memilih perpustakaan dan mulai bekerja. </p><br><p>  Tetapi saya ingin mengatakan lebih banyak tentang toolchain. </p><br><p>  Semuanya sangat baik di sini, ada berbagai tambahan untuk editor, di tempat yang lebih baik, di tempat yang lebih buruk.  Ada juga apollo-codegen, yang menghasilkan file-file berguna, misalnya tipe-aliran, dan pada dasarnya menarik skema dari GraphQL API. </p><br><h3 id="rubrika-ochumelye-ruchki-ili-chto-my-sdelali-u-sebya">  Judulnya "Gila tangan" atau apa yang kami lakukan di rumah </h3><br><p>  Hal pertama yang kami temui adalah bahwa pada dasarnya kami perlu meminta data. </p><br><pre> <code class="hljs lisp">graphql(<span class="hljs-name"><span class="hljs-name">BalanceQuery</span></span>)(<span class="hljs-name"><span class="hljs-name">BalanceItem</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Kami memiliki kondisi umum: memuat, penanganan kesalahan.  Kami menulis elang kami sendiri (asyncCard), yang terhubung melalui komposisi graqhql dan asyncCard. </p><br><pre> <code class="hljs lisp">compose( <span class="hljs-name"><span class="hljs-name">graphql</span></span>(<span class="hljs-name"><span class="hljs-name">BalanceQuery</span></span>), AsyncCard )(<span class="hljs-name"><span class="hljs-name">BalanceItem</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Saya juga ingin berbicara tentang fragmen.  Ada komponen LandingItem dan ia tahu data apa yang dibutuhkannya dari GraphQL API.  Kami menetapkan properti fragmen, tempat kami menentukan bidang dari entitas Landing. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LandingItem = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ content }: Props</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStyle</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> … </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStyle</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); LandingItem.fragment = gql<span class="hljs-string"><span class="hljs-string">` fragment LandingItem on Landing { ... } `</span></span>;</code> </pre> <br><p>  Sekarang, pada tingkat penggunaan komponen, kami menggunakan fragmennya dalam permintaan akhir. </p><br><pre> <code class="hljs bash">query LandingsDashboard { landings(...) { nodes { ...LandingItem } totalCount } <span class="hljs-variable"><span class="hljs-variable">${LandingItem.Fragment}</span></span> }</code> </pre> <br><p>  Dan katakanlah sebuah tugas terbang untuk menambahkan status ke halaman arahan ini - bukan masalah.  Kami menambahkan properti ke render dan fragmen.  Dan semuanya sudah siap.  Prinsip tanggung jawab tunggal dalam semua kemuliaan. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LandingItem = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ content }: Props</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStyle</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> … </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStatus</span></span></span></span><span class="xml"><span class="hljs-tag"> … /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStyle</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); LandingItem.fragment = gql` fragment LandingItem on Landing { ... status } `;</span></span></code> </pre> <br><h4 id="kakaya-u-nas-esche-byla-problema">  Masalah apa lagi yang kita miliki? </h4><br><p>  Kami memiliki sejumlah widget di situs kami yang mengajukan permintaan individual. </p><br><p><img src="https://habrastorage.org/webt/ab/li/-x/abli-xjzcmoq9_p2rtnorl-y3qu.png"></p><br><p>  Selama pengujian, ternyata semua ini melambat.  Kami memiliki pemeriksaan keamanan yang sangat panjang, dan setiap permintaan sangat mahal.  Ini juga ternyata tidak ada masalah, ada Apollo-link-batch-http </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">new</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BatchHttpLink</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">batchMax</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, batchInterval: <span class="hljs-number"><span class="hljs-number">10</span></span> });</code> </pre> <br><p>  Ini dikonfigurasikan sebagai berikut: kami mengirimkan sejumlah permintaan yang dapat kami gabungkan dan berapa lama tautan ini akan menunggu setelah permintaan pertama muncul. <br>  Dan ternyata seperti ini: pada saat yang sama semuanya memuat, dan pada saat yang sama semuanya datang.  Perlu dicatat bahwa jika selama ini menggabungkan salah satu subqueries kembali dengan kesalahan, maka kesalahan hanya akan bersamanya, dan tidak dengan seluruh permintaan. </p><br><h4 id="hochetsya-otdelno-rasskazat-chto-proshloy-osenyu-proizoshlo-obnovlenie-s-pervogo-apollo-na-vtoroy">  Saya ingin mengatakan secara terpisah bahwa musim gugur yang lalu ada pembaruan dari Apollo pertama ke yang kedua </h4><br><p>  Pada awalnya adalah Apollo dan Redux </p><br><pre> <code class="hljs cs"><span class="hljs-string"><span class="hljs-string">'react-apollo'</span></span> <span class="hljs-string"><span class="hljs-string">'redux'</span></span></code> </pre> <br><p>  Kemudian Apollo menjadi lebih modular dan diperluas, modul-modul ini dapat dikembangkan secara mandiri.  Memori apollo-cache-sama. </p><br><pre> <code class="hljs cs"><span class="hljs-string"><span class="hljs-string">'react-apollo'</span></span> <span class="hljs-string"><span class="hljs-string">'apollo-client'</span></span> <span class="hljs-string"><span class="hljs-string">'apollo-link-batch-http'</span></span> <span class="hljs-string"><span class="hljs-string">'apollo-cache-inmemory'</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-tag'</span></span></code> </pre> <br><p>  Perlu dicatat bahwa Redux tidak, dan ternyata, pada prinsipnya, tidak diperlukan. </p><br><h2 id="vyvody">  Kesimpulan: </h2><br><ol><li>  Waktu pengiriman fitur menurun, kami tidak membuang waktu untuk menggambarkan tindakan, mengurangi di Redux, dan kurang menyentuh backend </li><li>  Antifragilitas muncul karena  Analisis statis API memungkinkan Anda untuk menghapus masalah ketika frontend mengharapkan satu hal dan backend mengembalikan yang sama sekali berbeda. </li><li>  Jika Anda mulai bekerja dengan GraphQL - coba Apollo, jangan kecewa. </li></ol><br><p>  PS Anda juga dapat menonton video dari presentasi saya di Rambler Front &amp; Meet up # 4 </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rCEoy-V3x8k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418417/">https://habr.com/ru/post/id418417/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418403/index.html">Contoh Pemrograman Akselerator FPGA</a></li>
<li><a href="../id418405/index.html">Prinsip piramida terbalik dalam analitik. Kami membangun dasbor yang bisa dimengerti</a></li>
<li><a href="../id418407/index.html">Penambangan awan Hashflare telah ditutup. Uang tidak kembali</a></li>
<li><a href="../id418411/index.html">Penembak jaringan browser di Node.js</a></li>
<li><a href="../id418415/index.html">Telegram memperkenalkan layanan Paspornya sendiri untuk verifikasi dan otorisasi pengguna</a></li>
<li><a href="../id418419/index.html">Bagaimana Dodo Pizza Memecahkan Masalah Bisnis Menggunakan Pembelajaran Mesin</a></li>
<li><a href="../id418423/index.html">Rumah pintar: dimensi baru kenyamanan dan pengejaran keunggulan. Bagian satu</a></li>
<li><a href="../id418427/index.html">Pengindeksan seluler-pertama. Bagaimana dan mengapa grafik tautan berubah?</a></li>
<li><a href="../id418429/index.html">Pengalaman Kerja Saya untuk Peran Pelatih Agile di Eropa, Bagian Dua</a></li>
<li><a href="../id418431/index.html">Masalah imajiner - akar dari perangkat lunak yang buruk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>