<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñ®Ô∏è üë©üèæ‚Äçü§ù‚Äçüë®üèª üèÜ Debugging und Fehlerbehebung in PostgreSQL Streaming Replication üë®üèª‚Äç‚úàÔ∏è ü•ü üñåÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Stream-Replikation, die 2010 ver√∂ffentlicht wurde, ist zu einer der bahnbrechenden Funktionen von PostgreSQL geworden. Derzeit kann fast keine Ins...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Debugging und Fehlerbehebung in PostgreSQL Streaming Replication</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/414111/">  Die Stream-Replikation, die 2010 ver√∂ffentlicht wurde, ist zu einer der bahnbrechenden Funktionen von PostgreSQL geworden. Derzeit kann fast keine Installation ohne die Verwendung der Streaming-Replikation auskommen.  Es ist zuverl√§ssig, einfach zu konfigurieren und ressourcenschonend.  Bei allen positiven Eigenschaften k√∂nnen jedoch w√§hrend des Betriebs verschiedene Probleme und unangenehme Situationen auftreten. <br><br>  <strong>Alexey Lesovsky</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@lesovsky</a> ) auf der Highload ++ 2017 erkl√§rte, wie <strong>verschiedene Arten von Problemen</strong> mithilfe integrierter Tools <strong>und</strong> Tools von Drittanbietern <strong>diagnostiziert und</strong> behoben werden <strong>k√∂nnen</strong> .  Unter den K√ºrzungen basiert die Dekodierung dieses Berichts auf einem Spiralprinzip: Zuerst listen wir alle m√∂glichen Diagnosewerkzeuge auf, dann f√ºhren wir allgemeine Probleme auf und diagnostizieren sie, dann sehen wir, welche Sofortma√ünahmen ergriffen werden k√∂nnen, und schlie√ülich, wie das Problem radikal behandelt werden kann. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/on2yVvKejwc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>√úber den Sprecher</strong> : Alexei Lesovsky, Datenbankadministrator bei Data Egret.  Eines der beliebtesten Themen von Alexey in PostgreSQL ist das Streaming von Replikationen und das Arbeiten mit Statistiken. Daher befasste sich der Bericht auf Highload ++ 2017 mit der Suche nach Problemen mithilfe von Statistiken und den Methoden zu deren L√∂sung. <br><br><h2>  Planen <br></h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein bisschen Theorie oder wie die Replikation in PostgreSQL funktioniert</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tools zur Fehlerbehebung oder was PostgreSQL und die Community haben</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehlerbehebungsf√§lle:</a> <br><ul><li>  Probleme: ihre Symptome und Diagnose </li><li>  Entscheidungen </li><li>  Ma√ünahmen zu ergreifen, damit diese Probleme nicht auftreten. </li></ul></li></ol><br>  <strong>Warum das alles?</strong>  Dieser Artikel hilft Ihnen dabei, die Streaming-Replikation besser zu verstehen und Probleme schnell zu finden und zu beheben, um die Reaktionszeit auf unangenehme Vorf√§lle zu verk√ºrzen. <br><a name="habracut"></a><a name="replicationSql"></a><br><h2>  Ein bisschen Theorie <br></h2><br>  PostgreSQL verf√ºgt √ºber eine Entit√§t wie das Write-Ahead-Protokoll (XLOG), ein Transaktionsprotokoll.  <em>Fast</em> alle √Ñnderungen, die an Daten und Metadaten in der Datenbank auftreten, werden in diesem Protokoll aufgezeichnet.  Wenn pl√∂tzlich ein Unfall auftritt, startet PostgreSQL, liest das Transaktionsprotokoll und stellt die aufgezeichneten √Ñnderungen an den Daten wieder her.  Dies gew√§hrleistet Zuverl√§ssigkeit - eine der wichtigsten Eigenschaften von DBMS und PostgreSQL. <br><br>  Das Transaktionsprotokoll kann auf zwei Arten ausgef√ºllt werden: <br><br><ol><li>  Wenn Backends einige √Ñnderungen in der Datenbank vornehmen (INSERT, UPDATE, DELETE usw.), werden standardm√§√üig alle √Ñnderungen <strong>synchron</strong> im Transaktionsprotokoll aufgezeichnet: <br><ul><li>  Der Client hat einen COMMIT-Befehl gesendet, um die Daten zu best√§tigen. <br></li><li>  Daten werden im Transaktionsprotokoll aufgezeichnet. <br></li><li>  Sobald die Fixierung erfolgt ist, wird das Backend gesteuert und es kann weiterhin Befehle vom Client empfangen. <br></li></ul></li><li>  Die zweite Option ist das <strong>asynchrone Schreiben</strong> in das Transaktionsprotokoll, wenn ein separater dedizierter WAL-Writer-Prozess √Ñnderungen mit einem bestimmten Zeitintervall in das Transaktionsprotokoll schreibt.  Dadurch wird eine Steigerung der Backend-Leistung erreicht, da nicht gewartet werden muss, bis der Befehl COMMIT abgeschlossen ist. <br></li></ol><br>  Am wichtigsten ist, dass die Streaming-Replikation auf diesem Transaktionsprotokoll basiert.  Wir haben mehrere Streaming-Replikationsmitglieder: <br><br><ul><li>  Meister, wo alle √Ñnderungen stattfinden; <br></li><li>  Mehrere Replikate, die das Transaktionsprotokoll vom Master akzeptieren und alle diese √Ñnderungen in ihren lokalen Daten reproduzieren.  Dies ist eine Streaming-Replikation. <br></li></ul><br>  Beachten Sie, dass alle diese Transaktionsprotokolle im Verzeichnis pg_xlog in $ DATADIR gespeichert sind - dem Verzeichnis mit den wichtigsten DBMS-Datendateien.  In der 10. Version von PostgreSQL wurde dieses Verzeichnis in pg_wal / umbenannt, da pg_xlog / nicht selten viel Speicherplatz beansprucht und Entwickler oder Administratoren, die es unwissentlich mit den Protokollen verwechseln, es unachtsam l√∂schen und alles schlecht wird. <br><br>  PostgreSQL verf√ºgt √ºber mehrere Hintergrunddienste, die an der Streaming-Replikation beteiligt sind.  Betrachten wir sie aus Sicht des Betriebssystems. <br><br><ul><li>  Von der Seite des Master-WAL-Absenderprozesses.  Dies ist ein Prozess, der Transaktionsprotokolle an Replikate sendet. Jedes Replikat verf√ºgt √ºber einen eigenen WAL-Absender. <br></li><li>  Das Replikat f√ºhrt wiederum den WAL-Empf√§ngerprozess aus, der Transaktionsprotokolle √ºber die Netzwerkverbindung vom WAL-Absender empf√§ngt und an den Startprozess weiterleitet. <br></li><li>  Der Startvorgang liest die Protokolle und reproduziert im Datenverzeichnis alle √Ñnderungen, die im Transaktionsprotokoll aufgezeichnet sind. <br></li></ul><br><img src="https://habrastorage.org/webt/ek/g2/rd/ekg2rdtwkvfjw8hlpj0rhhzhogu.jpeg"><br>  Schematisch sieht es ungef√§hr so ‚Äã‚Äãaus: <br><br><ul><li>  √Ñnderungen werden in WAL-Puffer geschrieben, die dann in das Transaktionsprotokoll geschrieben werden. <br></li><li>  Protokolle werden im Verzeichnis pg_wal / gespeichert. <br></li><li>  WAL Sender liest das Transaktionsprotokoll aus dem Repository und √ºbertr√§gt es √ºber das Netzwerk. <br></li><li>  Der WAL-Empf√§nger empf√§ngt und speichert in seinem Speicher - im lokalen pg_wal /; <br></li><li>  Der Startvorgang liest alles, was akzeptiert und reproduziert wird. <br></li></ul><br>  Das Schema ist einfach.  Die Stream-Replikation funktioniert sehr zuverl√§ssig und wird seit vielen Jahren hervorragend genutzt. <br><a name="tools"></a><br><h2>  Tools zur Fehlerbehebung <br></h2><br>  Lassen Sie uns sehen, welche Tools und Dienstprogramme die Community und PostgreSQL anbieten, um die Probleme bei der Streaming-Replikation zu untersuchen. <br><br><h3>  Tools von Drittanbietern <br></h3><br>  Beginnen wir mit Tools von Drittanbietern.  Diese Dienstprogramme haben einen eher <strong>universellen Plan</strong> und k√∂nnen nicht nur zur Untersuchung von Vorf√§llen im Zusammenhang mit der Streaming-Replikation verwendet werden.  Dies sind im Allgemeinen <strong>Dienstprogramme eines Systemadministrators</strong> . <br><br><ul><li>  <strong>oben</strong> aus dem procps-Paket.  Als Ersatz f√ºr top k√∂nnen Sie alle Dienstprogramme wie atop, htop und dergleichen verwenden.  Sie bieten √§hnliche Funktionen. </li></ul><br>  Mit Hilfe von top betrachten wir: Auslastung der Prozessoren (CPU), durchschnittliche Auslastung (durchschnittliche Auslastung) sowie Speicher- und Swap-Speicherplatznutzung. <br><br><ul><li>  iostat von sysstat und iotop.  Diese Dienstprogramme zeigen die Auslastung von Festplattenger√§ten und welche E / A von Prozessen im Betriebssystem erstellt werden. </li></ul><br>  Mit Hilfe von iostat untersuchen wir: Speichernutzung, wie viele Iops im Moment, welcher Durchsatz auf Ger√§ten, welche Verz√∂gerungen bei der Verarbeitung von E / A-Anforderungen (Latenz).  Diese ziemlich detaillierten Informationen stammen aus dem procfs-Dateisystem und werden dem Benutzer in visueller Form zur Verf√ºgung gestellt. <br><br><ul><li>  nicstat ist ein Analogon von iostat, nur f√ºr Netzwerkschnittstellen.  In diesem Dienstprogramm k√∂nnen Sie die Verwendung von Schnittstellen √ºberwachen. </li></ul><br>  Mit nicstat sehen wir so aus: Ebenso ist die Schnittstellennutzung, einige Fehler, die an Schnittstellen auftreten, der Durchsatz ein sehr n√ºtzliches Dienstprogramm. <br><br><ul><li>  pgCenter ist ein Dienstprogramm, das nur mit PostgreSQL funktioniert.  Es zeigt PostgreSQL-Statistiken in einer top√§hnlichen Oberfl√§che an, und Sie k√∂nnen auch Statistiken zur Streaming-Replikation darin anzeigen. </li></ul><br>  Mit Hilfe von pgCenter schauen wir: Statistiken zur Replikation.  Sie k√∂nnen die Replikationsverz√∂gerung beobachten, sie irgendwie bewerten und zuk√ºnftige Arbeiten vorhersagen. <br><br><ul><li>  perf ist ein Hilfsprogramm f√ºr eine eingehendere Untersuchung der Ursachen von "Untergrundklopfen", wenn im Betrieb seltsame Probleme auf der PostgreSQL-Codeebene auftreten. </li></ul><br>  Mit Hilfe von Perf suchen wir: Underground Knocks.  Damit perf vollst√§ndig mit PostgreSQL funktioniert, muss letzteres mit Debug-Zeichen kompiliert werden, damit Sie den Funktionsstapel in Prozessen anzeigen k√∂nnen und welche Funktionen die meiste CPU-Zeit in Anspruch nehmen. <br><br>  Alle diese Dienstprogramme werden ben√∂tigt, <strong>um Hypothesen</strong> zu <strong>testen</strong> , die bei der Fehlerbehebung auftreten - wo und was langsamer wird, wo und was Sie reparieren m√ºssen, √ºberpr√ºfen.  Diese Dienstprogramme stellen sicher, dass wir auf dem richtigen Weg sind. <br><br><h3>  Eingebettete Tools <br></h3><br>  Was bietet PostgreSQL selbst? <br><br><h4>  Systemansichten <br></h4><br>  Im Allgemeinen gibt es viele Tools f√ºr die Arbeit mit PostgreSQL.  Jedes Anbieterunternehmen, das PostgreSQL-Support bietet, bietet seine eigenen Tools an.  In der Regel basieren diese Tools jedoch auf internen PostgreSQL-Statistiken.  In dieser Hinsicht bietet PostgreSQL Systemansichten, in denen Sie verschiedene Auswahlen treffen und die ben√∂tigten Informationen abrufen k√∂nnen.  Das hei√üt, mit einem regul√§ren Client, normalerweise psql, k√∂nnen wir Abfragen durchf√ºhren und sehen, was in der Statistik passiert. <br><br>  Es gibt einige Systemansichten.  Um mit der Streaming-Replikation zu arbeiten und Probleme zu untersuchen, ben√∂tigen wir nur: pg_stat_replication, pg_stat_wal_receiver, pg_stat_databases, pg_stat_databases_conflicts und pg_stat_activity und pg_stat_archiver. <br><br>  Es gibt nur wenige davon, aber dieses Set reicht aus, um zu √ºberpr√ºfen, ob es Probleme gibt. <br><br><h4>  Hilfsfunktionen <br></h4><br>  Mithilfe von Zusatzfunktionen k√∂nnen Sie Daten aus statistischen Systemdarstellungen entnehmen und in eine f√ºr Sie bequemere Form umwandeln.  Hilfsfunktionen sind ebenfalls nur wenige Teile. <br><br><ul><li>  pg_current_wal_lsn () (das alte Analogon von pg_current_xlog_location ()) ist die wichtigste Funktion, mit der Sie die aktuelle Position im Transaktionsprotokoll anzeigen k√∂nnen.  Ein Transaktionsprotokoll ist eine fortlaufende Folge von Daten.  Mit dieser Funktion k√∂nnen Sie den letzten Punkt sehen und die Position abrufen, an der das Transaktionsprotokoll jetzt gestoppt wurde. <br></li><li>  pg_last_wal_receive_lsn (), pg_last_xlog_receive_location () ist eine √§hnliche Funktion wie oben, nur f√ºr Replikate.  Das Replikat empf√§ngt das Transaktionsprotokoll, und Sie k√∂nnen die Position des zuletzt empfangenen Transaktionsprotokolls anzeigen. <br></li><li>  pg_wal_lsn_diff (), pg_xlog_location_diff () ist eine weitere n√ºtzliche Funktion.  Wir geben ihr zwei Positionen aus dem Transaktionsprotokoll und sie zeigt diff - den Abstand zwischen diesen beiden Punkten in Bytes.  Diese Funktion ist immer n√ºtzlich, um die Verz√∂gerung zwischen dem Master und den Replikaten in Bytes zu bestimmen. <br></li></ul><br>  Eine vollst√§ndige Liste der Funktionen kann mit dem Meta-Befehl psql abgerufen werden: \ df * (wal | xlog | lsn | location) *. <br><br>  Sie k√∂nnen es in psql eingeben und alle Funktionen anzeigen, die wal, xlog, Isn, location enthalten.  Es wird ungef√§hr 20 bis 30 solcher Funktionen geben, und sie liefern auch verschiedene Informationen im Transaktionsprotokoll.  Ich empfehle Ihnen, sich vertraut zu machen. <br><br><h4>  Dienstprogramm Pg_waldump <br></h4><br>  Vor Version 10.0 hie√ü es pg_xlogdump.  Das Dienstprogramm pg_waldump wird ben√∂tigt, wenn wir in die Segmente des Transaktionsprotokolls schauen, herausfinden m√∂chten, welche Ressourceneintr√§ge dort angekommen sind und was PostgreSQL dort geschrieben hat, dh f√ºr eine detailliertere Studie. <br><br><blockquote>  In Version 10.0 wurden alle Systemansichten, Funktionen und Dienstprogramme, die das Wort xlog enthielten, umbenannt.  Alle Vorkommen der W√∂rter xlog und location wurden durch die W√∂rter wal bzw. lsn ersetzt.  Dasselbe wurde mit dem Verzeichnis pg_xlog gemacht, das zum Verzeichnis pg_wal wurde. <br></blockquote><br>  Das Dienstprogramm pg_waldump dekodiert einfach den Inhalt von XLOG-Segmenten in ein f√ºr Menschen lesbares Format.  Sie k√∂nnen sehen, welche sogenannten Ressourceneintr√§ge w√§hrend der Arbeit von PostgreSQL in die Segmentprotokolle fallen, welche Indizes und Heap-Dateien ge√§ndert wurden und welche Informationen f√ºr den Standby-Modus dort angekommen sind.  Daher k√∂nnen mit pg_waldump viele Informationen angezeigt werden. <br><br><blockquote>  Es gibt jedoch einen Haftungsausschluss, der in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation geschrieben ist</a> : pg_waldump zeigt m√∂glicherweise leicht falsche Daten an, wenn PostgreSQL ausgef√ºhrt wird (Kann falsche Ergebnisse liefern, wenn der Server ausgef√ºhrt wird - was auch immer das bedeutet) </blockquote><br>  Sie k√∂nnen den folgenden Befehl verwenden: <br><br><pre><code class="sql hljs">pg_waldump -f - /wal_10 \ $(psql -qAtX - "<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_walfile_name(pg_current_wal_lsn())<span class="hljs-string"><span class="hljs-string">")</span></span></code> </pre> <br>  Dies ist ein Analogon des Befehls tail -f nur f√ºr Transaktionsprotokolle.  Dieser Befehl zeigt das Ende des Transaktionsprotokolls an, das gerade ausgef√ºhrt wird.  Sie k√∂nnen diesen Befehl ausf√ºhren. Er findet das letzte Segment mit dem letzten Transaktionsprotokolleintrag, stellt eine Verbindung dazu her und zeigt den Inhalt des Transaktionsprotokolls an.  Ein etwas kniffliges Team, aber es funktioniert trotzdem.  Ich benutze es oft. <br><a name="cases"></a><br><h2>  Fehlerbehebung bei F√§llen <br></h2><br>  Hier betrachten wir die h√§ufigsten Probleme, die in der Praxis von Beratern auftreten, welche Symptome auftreten k√∂nnen und wie sie diagnostiziert werden k√∂nnen: <br><br>  <strong>Replikationsverz√∂gerungen sind das h√§ufigste Problem</strong> .  In j√ºngerer Zeit hatten wir Korrespondenz mit dem Kunden: <br><br><blockquote>  - <em>Wir haben die Master-Slave-Replikation zwischen den beiden Servern unterbrochen.</em> <br><br>  - Verz√∂gerung 2 Stunden erkannt, pg_dump gestartet. <br><br>  - <em>OK, ich verstehe.</em>  <em>Was ist unsere zul√§ssige Verz√∂gerung?</em> <br><br>  - 16 Stunden bei max_standby_streaming_delay. <br><br>  <em>- Was passiert, wenn diese Verz√∂gerung √ºberschritten wird?</em>  <em>Heulende Sirene?</em> <br><br>  - Nein, Transaktionen werden geschlagen und der WAL-Wurf wird fortgesetzt. <br></blockquote><br>  Wir haben st√§ndig Probleme mit Replikationsverz√∂gerungen und l√∂sen diese fast jede Woche. <br><br>  <strong>Das Anschwellen des Verzeichnisses pg_wal /,</strong> in dem Transaktionsprotokollsegmente gespeichert sind, ist ein Problem, das weniger h√§ufig auftritt.  In diesem Fall m√ºssen jedoch sofort Ma√ünahmen ergriffen werden, damit das Problem nicht zu einer Notsituation wird, wenn die Replikate abfallen. <br><br>  <strong>Lange Abfragen</strong> , die auf dem Replikat ausgef√ºhrt werden, f√ºhren zu <strong>Konflikten w√§hrend der Wiederherstellung</strong> .  Dies ist eine Situation, in der das Replikat geladen wird. Sie k√∂nnen Leseabfragen f√ºr die Replikate ausf√ºhren. In diesem Moment beeintr√§chtigen diese Abfragen die Reproduktion des Transaktionsprotokolls.  Es liegt ein Konflikt vor, und PostgreSQL muss entscheiden, ob auf den Abschluss der Abfrage gewartet oder diese abgeschlossen werden soll, und das Transaktionsprotokoll weiter abspielen soll.  Dies ist ein Replikationskonflikt oder ein Wiederherstellungskonflikt. <br><br>  <strong>Wiederherstellungsprozess: 100% CPU-Auslastung - Das</strong> Wiederherstellen eines Transaktionsprotokolls auf Replikaten dauert 100% der Prozessorzeit.  Dies ist auch eine seltene Situation, aber es ist ziemlich unangenehm, weil  f√ºhrt zu einer Erh√∂hung der Replikationsverz√∂gerung und ist im Allgemeinen schwer zu untersuchen. <br><br><h3>  Replikationsverz√∂gerungen <br></h3><br>  Replikationsverz√∂gerungen treten auf, wenn dieselbe Anforderung, die auf dem Master und auf dem Replikat ausgef√ºhrt wird, unterschiedliche Daten zur√ºckgibt.  Dies bedeutet, dass die Daten zwischen dem Master und den Replikaten inkonsistent sind und es zu Verz√∂gerungen kommt.  Das Replikat muss einen Teil der Transaktionsprotokolle reproduzieren, um den Assistenten zu erreichen.  Das Hauptsymptom sieht genau so aus: Es gibt eine Abfrage und sie geben unterschiedliche Ergebnisse zur√ºck. <br><br>  <strong>Wie kann man nach solchen Problemen suchen?</strong> <br><br><ul><li>  Es gibt eine grundlegende Ansicht des Assistenten und der Replikate - <strong>pg_stat_replication</strong> .  Es werden Informationen zu allen WAL-Absendern angezeigt, dh zu Prozessen, die Transaktionsprotokolle senden.  Jedes Replikat verf√ºgt √ºber eine separate Zeile, in der Statistiken f√ºr dieses bestimmte Replikat angezeigt werden. <br></li><li>  Mit der Hilfsfunktion <strong>pg_wal_lsn_diff ()</strong> k√∂nnen Sie verschiedene Positionen im Transaktionsprotokoll vergleichen und dieselbe Verz√∂gerung berechnen.  Mit seiner Hilfe k√∂nnen wir bestimmte Zahlen ermitteln und feststellen, wo wir eine gro√üe Verz√∂gerung haben, wo eine kleine und bereits irgendwie auf das Problem reagieren. <br></li><li>  Die Funktion <strong>pg_last_xact_replay_timestamp ()</strong> funktioniert nur auf dem Replikat und erm√∂glicht es Ihnen, den Zeitpunkt <strong>anzuzeigen</strong> , zu dem die letzte verlorene Transaktion ausgef√ºhrt wurde.  Es gibt eine bekannte Funktion now (), die die aktuelle Zeit anzeigt. Wir subtrahieren die Zeit, die uns von der Funktion pg_last_xact_replay_timestamp () angezeigt wird, von der Funktion now () und ermitteln die Zeitverz√∂gerung. <br></li></ul><br>  In der 10. Version von pg_stat_replication wurden zus√§tzliche Felder angezeigt, die die Zeitverz√∂gerung anzeigen, die bereits im Assistenten vorhanden ist. Daher ist diese Methode bereits veraltet, kann jedoch verwendet werden. <br><br>  Es gibt eine kleine Falle.  Wenn der Assistent l√§ngere Zeit keine Transaktionen enth√§lt und keine Transaktionsprotokolle generiert, zeigt die letzte Funktion eine zunehmende Verz√∂gerung an.  Tats√§chlich ist das System einfach im Leerlauf, es gibt keine Aktivit√§t, aber bei der √úberwachung k√∂nnen wir sehen, dass die Verz√∂gerung zunimmt.  Diese Falle ist es wert, in Erinnerung zu bleiben. <br><br>  Die Ansicht ist wie folgt. <br><br><img src="https://habrastorage.org/webt/sb/jg/6k/sbjg6kswtdtymuecundldk180r8.jpeg"><br><br>  Es enth√§lt Informationen zu jedem WAL-Absender und mehrere Felder, die f√ºr uns wichtig sind.  Dies ist in erster Linie <strong>client_addr</strong> - die Netzwerkadresse des verbundenen Replikats (normalerweise eine IP-Adresse) und eine Reihe von <strong>lsn-</strong> Feldern (in √§lteren Versionen wird dies als Standort bezeichnet). Ich werde etwas weiter darauf <strong>eingehen</strong> . <br><br>  In der 10. Version wurden <strong>Verz√∂gerungsfelder</strong> angezeigt - dies ist eine zeitliche Verz√∂gerung, dh ein besser lesbares Format.  Die Verz√∂gerung kann entweder in Bytes oder in der Zeit ausgedr√ºckt werden - Sie k√∂nnen w√§hlen, was Ihnen am besten gef√§llt. <br><br>  In der Regel verwende ich diese Anfrage. <br><br><img src="https://habrastorage.org/webt/ff/8g/kv/ff8gkvz-kzdihuxabphcb0rfd4e.jpeg"><br><br>  Dies ist nicht die komplexeste Abfrage, die pg_stat_replication in einem bequemeren und verst√§ndlicheren Format druckt.  Hier benutze ich folgende Funktionen: <br><br><ul><li>  <strong>pg_wal_lsn_diff ()</strong> zum Lesen von Diffs.  Aber zwischen was denke ich, sind Unterschiede?  Wir haben mehrere Felder - sent_lsn, write_lsn, flush_lsn, replay_lsn.  Durch die Berechnung des Unterschieds zwischen dem aktuellen und dem vorherigen Feld k√∂nnen wir genau verstehen, wo wir zur√ºckgeblieben sind und wo genau die Verz√∂gerung auftritt. <br></li><li>  <strong>pg_current_wal_lsn ()</strong> , das die aktuelle Position des Transaktionsprotokolls anzeigt.  Hier sehen wir uns den Abstand zwischen der aktuellen Position im Protokoll und der gesendeten an - wie viele Transaktionsprotokolle generiert, aber nicht gesendet wurden. <br></li><li>  <strong>sent_lsn</strong> , <strong>write_lsn</strong> - So viel wird an das Replikat gesendet, aber nicht aufgezeichnet.  Das hei√üt, es befindet sich jetzt irgendwo im Netzwerk oder wurde von einem Replikat empfangen, aber noch nicht aus Netzwerkpuffern in den Festplattenspeicher geschrieben. <br></li><li>  <strong>write_lsn, flush_lsn</strong> - dies wird geschrieben, aber nicht vom Befehl fsync ausgegeben - als ob geschrieben, kann sich aber irgendwo im RAM im Seiten-Cache des Betriebssystems befinden.  Sobald wir fsync ausf√ºhren, werden die Daten mit der Festplatte synchronisiert, werden dauerhaft gespeichert und alles scheint zuverl√§ssig zu sein. <br></li><li>  <strong>replay_lsn, flush_lsn</strong> - Daten werden ausgegeben, fsync ausgef√ºhrt, aber nicht repliziert. <br></li><li>  <strong>current_wal_lsn</strong> und <strong>replay_lsn</strong> sind eine Art Gesamtverz√∂gerung, die alle vorherigen Positionen umfasst. <br></li></ul><br><h4>  <strong>Einige Beispiele</strong> <br></h4><br><img src="https://habrastorage.org/webt/7c/9n/tt/7c9nttg6yp-uyimrxa4ji3ll1ha.jpeg"><br><br>  Das Replikat 10.6.6.8 ist oben hervorgehoben.  Sie hat eine <strong>ausstehende Verz√∂gerung</strong> , sie hat einige Transaktionsprotokolle erstellt, aber sie werden immer noch nicht gesendet und liegen auf dem Master.  H√∂chstwahrscheinlich gibt es ein Problem mit der Netzwerkleistung.  Wir werden dies mit dem Dienstprogramm nicstat √ºberpr√ºfen. <br><br>  Wir werden nicstat starten, siehe Schnittstellenauslastung, wenn es dort Probleme und Fehler gibt.  Wir k√∂nnen diese Hypothese also testen. <br><br><img src="https://habrastorage.org/webt/co/-m/fj/co-mfjznunlrsuurikvz7xy9gh0.jpeg"><br><br>  Die <strong>Schreibverz√∂gerung ist</strong> oben markiert.  Tats√§chlich ist diese Verz√∂gerung ziemlich selten, ich sehe sie fast nicht als gro√ü an.  Das Problem kann bei Festplatten liegen, und wir verwenden das Dienstprogramm iostat oder iotop. Wir untersuchen die Verwendung von Festplattenspeichern, die von den Prozessen erstellt werden, und finden dann heraus, warum. <br><br><img src="https://habrastorage.org/webt/to/xw/2j/toxw2jutr7yaof38fwbohph9lva.jpeg"><br><br>  Verz√∂gerungen beim <strong>L√∂schen und Wiedergeben</strong> - Meistens tritt die Verz√∂gerung dort auf, wenn das Festplattenger√§t auf dem Replikat keine Zeit hat, einfach alle vom Master eingehenden √Ñnderungen zu verlieren. <br><br>  Auch mit den Dienstprogrammen iostat und iotop untersuchen wir, was mit der Festplattenauslastung passiert und warum die Bremsen. <br><br>  Und der letzte <strong>total_lag</strong> ist eine n√ºtzliche Metrik f√ºr √úberwachungssysteme.  Wenn unser Schwellenwert total_lag √ºberschritten wird, wird ein Kontrollk√§stchen in der √úberwachung aktiviert und wir beginnen zu untersuchen, was dort passiert. <br><br><h4>  <strong>Hypothesentest</strong> <br></h4><br>  Jetzt m√ºssen Sie herausfinden, wie Sie ein bestimmtes Problem weiter untersuchen k√∂nnen.  Ich habe bereits gesagt, wenn dies eine Netzwerkverz√∂gerung ist, m√ºssen wir √ºberpr√ºfen, ob mit dem Netzwerk alles in Ordnung ist. <br><br>  Mittlerweile bieten fast alle Hoster 1 Gbit / s oder sogar 10 Gbit / s an, sodass eine <strong>verstopfte Bandbreite das unwahrscheinlichste Szenario ist</strong> .  In der Regel m√ºssen Sie sich die Fehler ansehen.  nicstat enth√§lt Informationen zu Fehlern an den Schnittstellen. Sie k√∂nnen feststellen, dass Probleme mit Treibern auftreten, entweder mit der Netzwerkkarte selbst oder mit Kabeln. <br><br>  Wir untersuchen <strong>Speicherprobleme</strong> mit iostat und iotop.  iostat wird ben√∂tigt, um das allgemeine Bild des Festplattenspeichers anzuzeigen: Ger√§terecycling, Ger√§tebandbreite, Latenz.  iotop - f√ºr genauere Recherchen, wenn wir herausfinden m√ºssen, welcher Prozess das Festplattensubsystem l√§dt.  Wenn es sich um einen Prozess eines Drittanbieters handelt, kann dieser einfach erkannt und abgeschlossen werden, und m√∂glicherweise verschwindet das Problem. <br><br>  Zun√§chst betrachten wir <strong>Wiederherstellungsverz√∂gerungen und Replikationskonflikte</strong> durch top oder pg_stat_activity: Welche Prozesse werden ausgef√ºhrt, welche Anforderungen werden ausgef√ºhrt, ihre Ausf√ºhrungszeit wird ausgef√ºhrt, wie lange sie ausgef√ºhrt werden.  Wenn es sich um lange Abfragen handelt, schauen wir uns an, warum sie lange funktionieren, nehmen sie auf, verstehen und <strong>optimieren sie</strong> - wir werden die Abfragen selbst untersuchen. <br><br>  Wenn dies eine <strong>gro√üe Anzahl von Transaktionsprotokollen ist,</strong> die vom Assistenten generiert wurden, k√∂nnen wir dies an <strong>pg_stat_activity erkennen</strong> .  M√∂glicherweise werden dort einige Sicherungsprozesse gestartet, eine Art Vakuum wurde gestartet (pg_stat_progress_vacuum) oder der Pr√ºfpunkt wird ausgef√ºhrt.  Das hei√üt, wenn zu viele Transaktionsprotokolle generiert werden und das Replikat einfach keine Zeit hat, es zu verarbeiten, kann es irgendwann einfach abfallen, und dies wird ein Problem f√ºr uns sein. <br><br>  Und nat√ºrlich <strong>pg_wal_lsn_diff ()</strong> , um die Verz√∂gerung zu bestimmen und festzustellen, wo wir die Verz√∂gerung speziell haben - im Netzwerk, auf Festplatten oder auf Prozessoren. <br><br><h4>  <strong>L√∂sungsoptionen</strong> <br></h4><br>  <strong>Netzwerk- / Speicherprobleme</strong> <br><br>  Hier ist alles recht einfach, aber aus Sicht der Konfiguration ist dies normalerweise nicht gel√∂st.  Sie k√∂nnen einige Muttern festziehen, aber im Allgemeinen gibt es zwei M√∂glichkeiten: <br><br><ul><li>  √úberpr√ºfen Sie die Arbeitslast </li></ul><br>  √úberpr√ºfen Sie, welche Anforderungen ausgef√ºhrt werden.  M√∂glicherweise werden Migrationen gestartet, die viele Transaktionsprotokolle generieren, oder es kann sich um Daten√ºbertragung, L√∂schung oder Einf√ºgung handeln.  <strong>Jeder Prozess, der Transaktionsprotokolle generiert, kann zu Transaktionsverz√∂gerungen f√ºhren</strong> .  Alle Daten im Assistenten werden so schnell wie m√∂glich generiert. Wir haben eine √Ñnderung an den Daten vorgenommen, sie an das Replikat gesendet, und das Replikat kann damit umgehen oder fehlschlagen. Dies betrifft den Assistenten nicht.  Hier kann eine Verz√∂gerung auftreten, und Sie m√ºssen etwas damit tun. <br><br><ul><li>  Hardware aktualisieren <br></li></ul><br>  Die d√ºmmste Option - vielleicht sind wir auf die Leistung von Eisen gesto√üen, und Sie m√ºssen sie nur √§ndern.  Dies k√∂nnen alte Festplatten oder SSDs von schlechter Qualit√§t oder ein Plug-in f√ºr die Leistung eines RAID-Controllers sein.  Hier erkunden wir nicht mehr die Basis selbst, sondern √ºberpr√ºfen die Leistung unserer Dr√ºsen. <br><br>  <strong>Wiederherstellungsverz√∂gerungen</strong> <br><br>  Wenn aufgrund langer Anforderungen Replikationskonflikte auftreten, die zu einer Erh√∂hung der Wiedergabeverz√∂gerung f√ºhren, werden <strong>zun√§chst lange Anforderungen gesendet</strong> , die auf dem Replikat ausgef√ºhrt werden, da sie die Wiedergabe von Transaktionsprotokollen verz√∂gern. <br><br>  Wenn lange Abfragen mit der Nichtoptimalit√§t der SQL-Abfrage selbst zusammenh√§ngen (wir finden dies mithilfe von EXPLAIN ANALYZE heraus), m√ºssen Sie diese Abfrage nur anders angehen und neu schreiben.  Oder es besteht die M√∂glichkeit, ein <strong>separates Replikat f√ºr die Berichterstellung von Abfragen</strong> zu konfigurieren.  Wenn wir Berichte erstellen, die lange funktionieren, m√ºssen sie an ein separates Replikat gesendet werden. <br><br>  Es besteht immer noch die M√∂glichkeit, <strong>nur zu warten</strong> .  Wenn wir eine Verz√∂gerung von einigen Kilobyte oder sogar zehn Megabyte haben, dies jedoch f√ºr akzeptabel halten, warten wir nur, bis die Anforderung abgeschlossen ist, und die Verz√∂gerung l√∂st sich von selbst auf.  Dies ist auch eine Option, und es kommt h√§ufig vor, dass dies akzeptabel ist. <br><br>  <strong>High Volume WAL</strong> <br><br>  Wenn wir ein gro√ües Volumen an Transaktionsprotokollen generieren, m√ºssen wir dieses <strong>Volumen pro Zeiteinheit</strong> reduzieren, damit das Replikat weniger Transaktionsprotokolle kauen muss. <br><br>  Dies erfolgt normalerweise <strong>√ºber die Konfiguration</strong> .  Teill√∂sung beim Setzen des Parameters full_page_writes = off.  Diese Option aktiviert / deaktiviert die Aufzeichnung vollst√§ndiger Bilder wechselnder Seiten im Transaktionsprotokoll.  Dies bedeutet, dass, wenn wir den Servicevorgang zum Schreiben eines Pr√ºfpunkts (CHECKPOINT) hatten und das n√§chste Mal, wenn wir einen Datenblock im Bereich der gemeinsam genutzten Puffer √§ndern, das vollst√§ndige Bild dieser Seite in das Transaktionsprotokoll aufgenommen wird und nicht nur die √Ñnderung selbst.  Bei allen nachfolgenden √Ñnderungen auf derselben Seite werden nur √Ñnderungen im Transaktionsprotokoll protokolliert.  Und so weiter zum n√§chsten Kontrollpunkt. <br><br>  Nach dem Pr√ºfpunkt zeichnen wir das vollst√§ndige Bild der Seite auf. Dies wirkt sich auf das Volumen des aufgezeichneten Transaktionsprotokolls aus.  Wenn es pro Zeiteinheit ziemlich viele Checkpoints gibt, nehmen wir an, dass 4 Checkpoints pro Stunde durchgef√ºhrt werden und es viele ganzseitige Bilder gibt, ist dies ein Problem.  Sie k√∂nnen die Aufnahme von Vollbildern deaktivieren. Dies wirkt sich auf die Lautst√§rke der WAL aus.  Aber auch dies ist eine halbe Sache. <br><br>  <i>Hinweis: Die Empfehlung zum Deaktivieren von full_page_writes sollte sorgf√§ltig gepr√ºft werden, da der Autor w√§hrend des Berichts vergessen hat zu kl√§ren, dass das Deaktivieren eines Parameters unter bestimmten Umst√§nden in Notfallsituationen auftreten kann (Besch√§digung des Dateisystems oder seines Protokolls, teilweises Schreiben in Bl√∂cke usw.). potenziell besch√§digte Datenbankdateien.</i>  <i>Seien Sie daher vorsichtig, wenn Sie den Parameter deaktivieren, kann dies das Risiko einer Datenbesch√§digung in Notfallsituationen erh√∂hen.</i> <br><br>  Eine weitere halbe Ma√ünahme besteht darin <strong>, das Intervall zwischen den Kontrollpunkten zu verl√§ngern</strong> .  Standardm√§√üig wird der Pr√ºfpunkt alle 5 Minuten durchgef√ºhrt, was h√§ufig vorkommt.  In der Regel wird dieses Intervall auf 30 bis 60 Minuten erh√∂ht. Dies ist eine akzeptable Zeit, f√ºr die alle schmutzigen Seiten mit der Festplatte synchronisiert werden k√∂nnen. <br><br>  Die Hauptl√∂sung besteht nat√ºrlich darin, <strong>unsere Arbeitsbelastung zu untersuchen</strong> - welche schweren Vorg√§nge dort stattfinden, die mit dem √Ñndern der Daten verbunden sind, und m√∂glicherweise zu versuchen, diese √Ñnderungen in Stapeln vorzunehmen. <br><br>  Angenommen, wir haben eine Tabelle, wir m√∂chten mehrere Millionen Datens√§tze daraus l√∂schen.  Die beste Option besteht darin, diese Millionen nicht sofort mit einer Anfrage zu l√∂schen, sondern sie in Packungen von 100 bis 200.000 zu zerlegen, damit zum einen kleine WAL-Mengen erzeugt werden, zum anderen hat das Vakuum Zeit, die gel√∂schten Daten zu durchlaufen, und daher war die Verz√∂gerung nicht so gro√ü und kritisch. <br><br><h3>  Schwellung pg_wal / <br></h3><br>  Lassen Sie uns nun dar√ºber sprechen, wie Sie feststellen k√∂nnen, dass das Verzeichnis pg_wal / geschwollen ist. <br><br>  Theoretisch h√§lt PostgreSQL es auf der Ebene bestimmter Konfigurationsdateien immer in einem f√ºr sich optimalen Zustand und sollte in der Regel nicht √ºber bestimmte Grenzen hinauswachsen. <br><br>  Es gibt einen Parameter max_wal_size, der den Maximalwert bestimmt.  Au√üerdem gibt es den Parameter wal_keep_segments - eine zus√§tzliche Anzahl von Segmenten, die der Master f√ºr das Replikat speichert, wenn das Replikat pl√∂tzlich l√§ngere Zeit nicht verf√ºgbar ist. <br><br>  Nachdem wir die Summe von max_wal_size und wal_keep_segments berechnet haben, k√∂nnen wir grob absch√§tzen, wie viel Speicherplatz das Verzeichnis pg_wal / belegt.  Wenn es schnell w√§chst und viel mehr Platz als der berechnete Wert einnimmt, bedeutet dies, dass ein Problem vorliegt und Sie etwas dagegen tun m√ºssen. <br><br><h4>  Wie erkennt man solche Probleme? <br></h4><br>  Unter dem Linux-Betriebssystem gibt es den <strong>Befehl du -csh</strong> .  Wir k√∂nnen einfach den Wert √ºberwachen und √ºberwachen, wie viele Transaktionsprotokolle wir dort haben.  Behalte ein kalkuliertes Etikett, wie viel er schuldet und wie viel er tats√§chlich nimmt, und reagiere irgendwie auf √Ñnderungen der Zahlen. <br><br>  Ein weiterer Ort, den wir uns ansehen, sind die <strong>Ansichten</strong> <strong>pg_replication_slots</strong> und <strong>pg_stat_archiver</strong> .  Die h√§ufigsten Gr√ºnde, warum pg_wal / viel Speicherplatz beansprucht, sind vergessene Replikationssteckpl√§tze oder fehlerhafte Archivierung.  Andere Gr√ºnde haben auch einen Platz zu sein, aber in meiner Praxis waren sie sehr selten. <br><br>  Und nat√ºrlich gibt es immer Fehler in den PostgreSQL-Protokollen, die dem Archivierungsbefehl zugeordnet sind.  Leider gibt es keine weiteren Gr√ºnde f√ºr pg_wal / overflow.  Wir k√∂nnen dort nur Archivfehler abfangen. <br><br><h4>  Optionen f√ºr Probleme: <br></h4><br>  <strong>Schweres CRUD</strong> - schwere Datenaktualisierungsvorg√§nge - schweres INSERT, DELETE, UPDATE, verbunden mit dem √Ñndern mehrerer Millionen Zeilen.  Wenn PostgreSQL eine solche Operation ausf√ºhren muss, ist klar, dass eine gro√üe Menge an Transaktionsprotokoll generiert wird.  Es wird in pg_wal / gespeichert, wodurch der belegte Speicherplatz vergr√∂√üert wird.  Das hei√üt, wie ich bereits sagte, ist es eine gute Praxis, sie einfach in Pakete zu zerlegen und nicht das gesamte Array, sondern jeweils 100, 200, 300 Tausend zu aktualisieren. <br><br>  <strong>Ein vergessener oder nicht verwendeter Replikationssteckplatz</strong> ist ein weiteres h√§ufiges Problem.  Menschen verwenden h√§ufig die logische Replikation f√ºr einige ihrer Aufgaben: Sie konfigurieren Busse, die Daten an Kafka senden, senden Daten an eine Drittanbieteranwendung, die die logische Replikation in ein anderes Format dekodiert und sie irgendwie verarbeitet.  <strong>Die logische Replikation funktioniert normalerweise √ºber Slots</strong> .  Es kommt vor, dass wir einen Replikationssteckplatz eingerichtet, mit der Anwendung gespielt, festgestellt haben, dass diese Anwendung nicht zu uns passt, die Anwendung deaktiviert, gel√∂scht haben <strong>und die Replikationssteckpl√§tze weiterhin aktiv sind</strong> . <br><br>  PostgreSQL f√ºr jeden Replikationssteckplatz speichert Segmente des Transaktionsprotokolls, falls eine Remoteanwendung oder ein Replikat erneut eine Verbindung zu diesem Steckplatz herstellt, und der Assistent kann ihnen diese Transaktionsprotokolle senden. <br><br>  Aber die Zeit vergeht, niemand stellt eine Verbindung zum Slot her, Transaktionsprotokolle werden gesammelt und irgendwann nehmen sie 90% des Speicherplatzes ein.  Wir m√ºssen herausfinden, was es ist, warum so viel Platz ben√∂tigt wird.  In der Regel muss dieser vergessene und nicht verwendete Steckplatz nur entfernt werden, und das Problem wird gel√∂st.  Aber dazu sp√§ter mehr. <br><br>  Eine andere Option k√∂nnte ein <strong>defekter archive_command sein</strong> .  Wenn wir eine Art externes Transaktionsprotokoll-Repository haben, das wir f√ºr Disaster Recovery-Aufgaben aufbewahren, wird normalerweise ein Archivierungsbefehl eingerichtet, seltener wird pg_receivexlog eingerichtet.  Der in archive_command registrierte Befehl ist sehr oft entweder ein separater Befehl oder ein Skript, das Segmente des Transaktionsprotokolls aus pg_wal / entnimmt und in den Archivspeicher kopiert. <br><br>  Es kommt vor, dass wir eine Art Upgrade von Systempaketen durchgef√ºhrt haben, zum Beispiel in rsync die Version ge√§ndert, die Flags aktualisiert oder ge√§ndert wurden oder in einem anderen Befehl, der im Archivbefehl verwendet wurde, das Format ebenfalls ge√§ndert hat - und das Skript oder das Programm selbst, das in angegeben ist archive_command bricht ab.  Folglich werden Archive nicht mehr kopiert. <br><br>  Wenn der Archivierungsbefehl mit einer Ausgabe von nicht 0 gearbeitet hat, wird eine entsprechende Meldung in das Protokoll geschrieben, und das Segment verbleibt im Verzeichnis pg_wal /.  <strong>Bis wir feststellen, dass unser Archivteam kaputt ist, werden sich Segmente ansammeln</strong> und der Ort wird auch irgendwann enden. <br><br>  <strong>Reihe von Notfallma√ünahmen (100% genutzter Raum):</strong> <br><br> 1. <strong>   CRUD </strong> ,        ‚Äî pg_terminate_backend(). <br>    -  ,  , ,      ..       ,      pg_wal/,     . <br><br> 2. <strong>    </strong>    root ‚Äî reserved space ratio (ext filesystems). <br>       ext      ext     5%.  ,         ,  5% ‚Äî  . ,   ,     1%  ,     tune2fs -m 1.       PostgreSQL     ,    .      100%     . <br><br> 3. <strong>  </strong> (LVM, ZFS,...). <br>    LVM  ZFS,        LVM  ZFS,            ,   ,           .       ,   . <br><br> 4.    ‚Äî <strong>, , HE    pg_wal/</strong> . <br>          ,     ,   ,   .     ! PostgreSQL     ,   .     ,  ,   ,    . <br><br> , pg_xlog/   pg_wal/     ‚Äî  log    ,   , , ,  -   ‚Äî  ! <br><br><h4>    <br></h4><br>  ,         100%  CPU,      . <br><br>   <strong> workload  </strong> .    ,       ?  ,     - ,      -.         :   ,   tablespace,    tablespace. <br><br>   <strong> </strong> .       ,  ,    ,    , ,  ,            . <strong>   ‚Äî      .</strong> <br><br>   <strong>  checkpoints_segments/max_wal_size, wal_keep_segments</strong> .  ,    ,      ‚Äî 10-20   wal_keep_segments,     max_wal_size.  ,        .  PostgreSQL       pg_wal/  . <br><br>  <strong>  </strong>   pg_replication_slots ‚Äî     .   ,   <strong> </strong> ,        ‚Äî      .   ,    ,    .    . <br><br>      WAL,       ,  <strong>    pg_stat_archiver</strong> ,    . ,  <strong>  </strong> , ,    ,    . <br><br>    <strong>   checkpoint</strong> .       ,        ,      . , PostgreSQL        . <strong>   ,    checkpoint</strong> . <br><br><h3>       <br></h3><br>    ,   ,   ‚Äî        .   -             ,       .      ,         . <br><br> <strong> </strong> ‚Äî    PostgreSQL  : <br><br><ul><li> User was holding shared bufer pin for too long. <br></li><li> User query might have needed to see row versions that must be removed. <br></li><li> User was holding a relation lock for too long. <br></li><li> User was or might have been using table space that must be dropped. <br></li><li> User transaction caused bufer deadlock with recovery. <br></li><li> User was connected to a database that must be dropped. <br></li></ul><br>  2  ‚Äî    ,       ,      .   :  ,   ,      .        (  30 ),  <strong>PostgreSQL       </strong> ‚Äî  . <br><br>    .  ,    ,             .    -    ,     timeout     .     ‚Äî    ALTER,    ,    . <br><br>     .     ,  tablespace     ,            tablespace.   ,    ,  -   ‚Äî   . <br><br><h4> <strong> ?</strong> <br></h4><br>       <strong>pg_stat_databases, pg_stat_databases_conflicts</strong> .         ,    .     ,    . <br><br>  <strong>  </strong> ,       <strong> </strong> .  ,      .   ,    . ,       ,    ,    . <br><br><h4>  <strong>Was zu tun ist?</strong> <br></h4><br>   ,    ‚Äî    : <br><br><ol><li> <strong> max_standby_streaming_delay</strong> (  ).     ,       .    <strong>   </strong> . <br></li><li> <strong> hot_stadby_feedback</strong> (  /).  ,  vacuum   - ,       .     <strong> bloat  </strong> .     ,    ,  ,   hot_stadby_feedback  . <br></li><li>     DBA     ‚Äî  <strong>  </strong> .   <strong> </strong> ,    .  ,    ,     ,   -    ,  . <br></li><li>  , ,  ,   ,  DBA ‚Äî  <strong>     </strong> , ,  .    max_standby_streaming_delay  .       ,   .      ,  ,    ,  .  <strong>   </strong> ‚Äî    ,     . <br></li></ol><br><h2> Recovery process: 100% CPU usage <br></h2><br>  ,  ,    , <strong> 100%   </strong> .  ,      ,      100%.  ,    pg_stat_replication,  ,     replay,       ,    . <br><br> <strong></strong>  : <br><br><ul><li> <strong>top</strong> ‚Äî       ‚Äî    100% CPU usage  recovery process; <br></li><li> <strong>pg_stat_replication</strong> ‚Äî  ,   ,     . <br></li></ul><br><h4> <strong>   </strong> <br></h4><br>      ,    .  ,     : <br><br><ul><li> perf top/record/report ( debug‚Äî); <br></li><li> GDB; <br></li><li>  pg_waldump. <br></li></ul><br>  ,   ,       .     workload,   <strong>        </strong> .  ,    , PostgreSQL     shared buffers       ( ).        . <br><br><h4> <strong></strong> <br></h4><br>    ,      <strong>   </strong> . -   workload, - , -    : ¬´      ,  -  ¬ª. <br><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pgsql-hackers</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pgsql-bugs</a> ,   ,   .  ,    . <br><br>     ‚Äî <strong>-   ,  , </strong> . <br><br><h2>  Zusammenfassung <br></h2><br> <strong>      </strong> .  ,             ,    ,      . <br><br> <strong>     </strong> .    , ,  ,    ,   ,   ‚Äî . <br><br>  , <strong>  </strong> ,   ‚Äî .   ,   ,  ,         . <br><br>  ,    ,  <strong>  </strong> ‚Äî  ,      ,   . <br><br><h3>  N√ºtzliche Links <br></h3><br><ul><li> PostgreSQL official documentation ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Statistics Collector</a> </li><li> PostgreSQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mailing Lists</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">general</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">performance</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hackers</a> ) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PostgreSQL-Consulting company blog</a> </li></ul><br><blockquote>             , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Highload++ Siberia</a> ,   <strong>25  26   </strong> .   ,     ,  . <br><br><ul><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>     MySQL  ClickHouse. </li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,            Oracle. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nikolay Golov </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erkl√§rt Ihnen,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wie </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Sie</font></a><font style="vertical-align: inherit;"> Transaktionen implementieren, wenn sich Geld in einem Dienst befindet, Dienste in einem anderen und jeder Dienst seine eigene isolierte Basis hat.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yuri Nasretdinov wird ausf√ºhrlich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erkl√§ren,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> warum VK ClickHouse ben√∂tigt, wie viele Daten gespeichert sind und vieles mehr.</font></font></li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414111/">https://habr.com/ru/post/de414111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414095/index.html">[√úbersetzung] Elasticsearch 6.3.0 ver√∂ffentlicht</a></li>
<li><a href="../de414097/index.html">Apple-Computer schlie√üen die von Experten von Positive Technologies festgestellte Sicherheitsl√ºcke</a></li>
<li><a href="../de414103/index.html">Offenes Webinar: ‚ÄûNeuronale Netze f√ºr pharmazeutische Aufgaben‚Äú</a></li>
<li><a href="../de414105/index.html">Vorhersage der Ergebnisse der Weltmeisterschaft 2018 mithilfe eines Algorithmus f√ºr zuf√§llige W√§lder</a></li>
<li><a href="../de414109/index.html">Verwenden von Docker zum Erstellen und Ausf√ºhren eines C ++ - Projekts</a></li>
<li><a href="../de414115/index.html">Was ist Lazy FP State Restore? Eine neue Sicherheitsanf√§lligkeit, die in Intel-Prozessoren entdeckt wurde</a></li>
<li><a href="../de414117/index.html">Gemischtes Dezimal-Bin√§rformat gegen IEEE754</a></li>
<li><a href="../de414119/index.html">Gelegenheit schlief aufgrund eines Sandsturms auf dem Mars ein. Es ist unklar, ob der Rover wieder arbeiten kann</a></li>
<li><a href="../de414121/index.html">DIY Standalone-Drohne mit Internetsteuerung</a></li>
<li><a href="../de414123/index.html">Wir aktualisieren die Textprotokolle auf Bin√§r und bek√§mpfen den Legacy-Code bei einem C ++ - Benutzergruppentreffen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>