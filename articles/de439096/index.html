<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐛 👨🏼‍🎨 🗻 Buildbot: eine Geschichte mit Beispielen eines anderen kontinuierlichen Integrationssystems 👨‍🚒 👴🏾 📀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(Bild von der offiziellen Seite ) 

 Buildbot ist, wie der Name schon sagt, ein kontinuierliches Integrationssystem (ci). Es gab bereits mehrere Artik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buildbot: eine Geschichte mit Beispielen eines anderen kontinuierlichen Integrationssystems</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439096/"><img src="https://habrastorage.org/webt/so/qs/u1/soqsu1skae_0xuktzdemfv-n3yq.png"><br>  <i><font color="#aaaaaa">(Bild von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Seite</a> )</font></i> <br><br>  Buildbot ist, wie der Name schon sagt, ein kontinuierliches Integrationssystem (ci).  Es gab bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehrere</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> über ihn auf dem Habré, aber aus meiner Sicht sind die Vorteile dieses Werkzeugs nicht sehr klar.  Außerdem gibt es fast keine Beispiele, was es schwierig macht, die volle Leistungsfähigkeit des Programms zu erkennen.  In meinem Artikel werde ich versuchen, diese Mängel auszugleichen, über das interne Gerät Buildbot'a zu sprechen und Beispiele für einige nicht standardmäßige Skripte zu geben. <br><a name="habracut"></a><br><h3>  Gemeinsame Wörter </h3><br>  Derzeit gibt es eine große Anzahl kontinuierlicher Integrationssysteme, und wenn es um eines davon geht, stellen sich ganz logische Fragen im Sinne von "Warum wird es benötigt, wenn Sie bereits einen &lt;Programmname&gt; haben und jeder ihn verwendet?"  Ich werde versuchen, eine solche Frage zu Buildbot zu beantworten.  Einige der Informationen werden mit vorhandenen Artikeln dupliziert, andere sind in der offiziellen Dokumentation beschrieben, dies ist jedoch für die Konsistenz der Erzählung erforderlich. <br><br>  Der Hauptunterschied zu anderen kontinuierlichen Integrationssystemen besteht darin, dass Buildbot ein Python-Framework zum Schreiben von ci ist und keine sofort einsatzbereite Lösung.  Dies bedeutet, dass Sie zum Verbinden eines Projekts mit Buildbot zunächst ein separates Python-Programm mit dem Buildbot-Framework schreiben müssen, das die für Ihr Projekt erforderliche kontinuierliche Integrationsfunktion implementiert.  Dieser Ansatz bietet enorme Flexibilität und ermöglicht es Ihnen, knifflige Testszenarien zu implementieren, die aufgrund von Architekturbeschränkungen für Out-of-Box-Lösungen nicht möglich sind. <br><br>  Außerdem ist Buildbot kein Dienst, und daher müssen Sie ihn ehrlich in Ihrer Infrastruktur bereitstellen.  Hier stelle ich fest, dass das Framework den Ressourcen des Systems sehr treu ist.  Dies ist sicherlich nicht C oder C ++, aber Python gewinnt gegen seine Java-Konkurrenten.  Hier zum Beispiel der Vergleich des Speicherverbrauchs mit GoCD (und ja, trotz des Namens ist dies ein Java-System): <br><br>  Buildbot: <br><br><img src="https://habrastorage.org/webt/q1/tg/wu/q1tgwuy-ef8bl6au-s7lc07da-c.png"><br><br>  GoCD: <br><br><img src="https://habrastorage.org/webt/lg/ci/bk/lgcibk9si78bjzf_gfqrgktcgug.png"><br><br>  Das Bereitstellen und Schreiben eines separaten Testprogramms selbst kann Sie bei dem Gedanken an die Ersteinrichtung traurig machen.  Die Skripterstellung wird jedoch durch die schiere Anzahl der integrierten Klassen erheblich vereinfacht.  Diese Klassen decken viele Standardoperationen ab, unabhängig davon, ob Änderungen vom Github-Repository abgerufen oder das Projekt mit CMake erstellt werden.  Daher sind Standardskripte für kleine Projekte für einige Travis-CI nicht komplizierter als YML-Dateien.  Ich werde nicht über die Bereitstellung schreiben, dies wird in bestehenden Artikeln ausführlich behandelt und es gibt dort auch nichts Kompliziertes. <br><br>  Als nächstes von Buildbot stelle ich fest, dass die Testlogik standardmäßig auf der Seite des ci-Servers implementiert ist.  Dies steht im Widerspruch zu dem mittlerweile beliebten Ansatz „Pipeline als Code“, bei dem die Testlogik in einer Datei (wie .travis.yml) beschrieben wird, die sich zusammen mit dem Projektquellcode im Repository befindet, und der ci-Server diese Datei nur liest und ausführt was es sagt.  Auch dies ist nur das Standardverhalten.  Mit den Funktionen des Buildbot-Frameworks können Sie den beschriebenen Ansatz implementieren, indem Sie das Testskript im Repository speichern.  Es gibt sogar eine fertige Lösung - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bb-travis</a> , die versucht, das Beste aus Buildbot und travis-ci herauszuholen.  Darüber hinaus werde ich später in diesem Artikel beschreiben, wie Sie etwas Ähnliches wie dieses Verhalten selbst implementieren können. <br><br>  Buildbot sammelt standardmäßig jedes Commit beim Push.  Es mag wie ein kleines unnötiges Merkmal erscheinen, aber für mich ist es im Gegenteil einer der Hauptvorteile geworden.  Viele gängige Lösungen (travis-ci, gitlab-ci) bieten überhaupt keine solche Möglichkeit und arbeiten nur mit dem letzten Commit in der Branche.  Stellen Sie sich vor, dass Sie während der Entwicklung häufig Commits auswählen müssen.  Es wird unangenehm sein, ein nicht funktionierendes Commit durchzuführen, das vom Build-System nicht überprüft wurde, da es zusammen mit einer Reihe von Commits von oben gestartet wurde.  Natürlich können Sie in Buildbot nur das letzte Commit erstellen, und dies erfolgt durch Festlegen nur eines Parameters. <br><br>  Das Framework verfügt über eine recht gute Dokumentation, die alles detailliert beschreibt, von der allgemeinen Architektur bis zu den Richtlinien für die Erweiterung der integrierten Klassen.  Selbst mit einer solchen Dokumentation müssen Sie möglicherweise einige Dinge im Quellcode betrachten.  Es ist unter der GPL v2-Lizenz vollständig geöffnet und leicht zu lesen.  Von den Minuspunkten - die Dokumentation ist nur in englischer Sprache verfügbar, in russischer Sprache gibt es nur sehr wenige Informationen im Netzwerk.  Das Tool ist gestern nicht erschienen, mit seiner Hilfe werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wireshark</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LLVM</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele andere</a> bekannte Projekte zusammengestellt.  Updates werden veröffentlicht, das Projekt wird von vielen Entwicklern unterstützt, sodass wir über Zuverlässigkeit und Stabilität sprechen können. <br><br><img src="https://habrastorage.org/webt/22/we/zg/22wezgyvqnccjmk2sl_ehs954bg.png"><br>  <i><font color="#aaaaaa">(Python Buildbot Homepage)</font></i> <br><br><h3>  Theormin </h3><br>  Dieser Teil ist im Wesentlichen eine freie Übersetzung des Kapitels der offiziellen Dokumentation zur Architektur des Frameworks.  Es zeigt die gesamte Aktionskette vom Empfang von Änderungen durch das ci-System bis zum Senden von Benachrichtigungen über das Ergebnis an Benutzer.  Sie haben also Änderungen am Quellcode des Projekts vorgenommen und diese an das Remote-Repository gesendet.  Was als nächstes passiert, ist im Bild schematisch dargestellt: <br><br><img src="https://habrastorage.org/webt/hq/ue/na/hquenaedpe7hdlulfnmctiew2b8.png"><br>  <i><font color="#aaaaaa">(Bild aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizieller Dokumentation</a> )</font></i> <br><br>  Zunächst sollte Buildbot irgendwie herausfinden, dass Änderungen im Repository vorgenommen wurden.  Es gibt zwei Hauptmethoden - Webhooks und Umfragen, obwohl niemand verbietet, sich etwas Anspruchsvolleres auszudenken.  Im ersten Fall sind in Buildbot die BaseHookHandler-Nachkommenklassen dafür verantwortlich.  Es gibt viele vorgefertigte Lösungen, zum Beispiel <i>GitHubHandler</i> oder <i>GitoriusHandler</i> .  Die Schlüsselmethode in diesen Klassen ist <b>getChanges ()</b> .  Die Logik ist äußerst einfach: Sie muss die HTTP-Anforderung in eine Liste von Änderungsobjekten konvertieren. <br><br>  Für den zweiten Fall benötigen Sie <i>PollingChangeSource-</i> Nachkommenklassen.  Auch hier gibt es vorgefertigte Lösungen wie <i>GitPoller</i> oder <i>HgPoller</i> .  Die Schlüsselmethode ist <b>poll ()</b> .  Es wird mit einer bestimmten Häufigkeit aufgerufen und muss irgendwie eine Liste der Änderungen im Repository erstellen.  Im Fall eines Git kann dies ein Aufruf zum Abrufen von Git und ein Vergleich mit dem zuvor gespeicherten Status sein.  Wenn die integrierten Funktionen nicht ausreichen, erstellen Sie einfach Ihre eigene Vererbungsklasse und überladen Sie die Methode.  Ein Beispiel für die Verwendung von Polling: <br><br><pre><code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'change_source'</span></span>] = [changes.GitPoller( repourl = <span class="hljs-string"><span class="hljs-string">'git@git.example.com:project'</span></span>, project = <span class="hljs-string"><span class="hljs-string">'My Project'</span></span>, branches = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-comment"><span class="hljs-comment">#      pollInterval = 60 )]</span></span></code> </pre> <br>  Webhook ist noch einfacher zu bedienen, die Hauptsache ist, nicht zu vergessen, es auf der Git-Server-Seite zu konfigurieren.  Dies ist nur eine Zeile in der Konfigurationsdatei: <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'www'</span></span>][<span class="hljs-string"><span class="hljs-string">'change_hook_dialects'</span></span>] = { <span class="hljs-string"><span class="hljs-string">'github'</span></span>: {} }</code> </pre> <br>  Im nächsten Schritt werden die Änderungsobjekte in die Scheduler-Objekte ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler</a> ) eingegeben.  Beispiele für integrierte Scheduler: <i>AnyBranchScheduler</i> , <i>NightlyScheduler</i> , <i>ForceScheduler</i> usw.  Jeder Scheduler empfängt alle Änderungsobjekte als Eingabe, wählt jedoch nur diejenigen aus, die den Filter bestehen.  Der Filter wird über das Argument <i>change_filter</i> an den Scheduler im Konstruktor <i>übergeben</i> .  Am Ausgang erstellen die Planer Build-Anforderungen.  Der Scheduler wählt die Builder basierend auf dem Builder-Argument aus. <br><br>  Einige Planer haben ein kniffliges Argument namens <i>treeStableTimer</i> .  Dies funktioniert wie folgt: Wenn eine Änderung eingeht, erstellt der Scheduler nicht sofort eine neue Build-Anforderung, sondern startet einen Timer.  Wenn neue Änderungen eintreffen und der Timer nicht abgelaufen ist, wird die alte Änderung durch eine neue ersetzt und der Timer aktualisiert.  Wenn der Timer endet, erstellt der Scheduler nur eine Build-Anforderung aus der zuletzt gespeicherten Änderung. <br><br>  Somit ist die Logik implementiert, nur das letzte Commit beim Push zusammenzusetzen.  Beispiel für die Scheduler-Konfiguration: <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>] = [schedulers.AnyBranchScheduler( name = <span class="hljs-string"><span class="hljs-string">'My Scheduler'</span></span>, treeStableTimer = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, change_filter = util.ChangeFilter(project = <span class="hljs-string"><span class="hljs-string">'My Project'</span></span>), builderNames = [<span class="hljs-string"><span class="hljs-string">'My Builder'</span></span>] )]</code> </pre> <br>  Build-Anforderungen, so seltsam sie auch klingen mögen, gehen an die Eingabe der Builder.  Die Aufgabe des Sammlers besteht darin, die Assembly auf einem zugänglichen „Worker“ auszuführen.  Worker ist eine Build-Umgebung wie Stretch64 oder Ubuntu1804x64.  Die Liste der Arbeiter wird durch das <i>Arbeiterargument geleitet</i> .  Alle Arbeiter in der Liste sollten gleich sein (d. H. Die Namen sind natürlich unterschiedlich, aber die Umgebung im Inneren ist die gleiche), da der Sammler frei ist, einen der verfügbaren auszuwählen.  Das Festlegen mehrerer Werte dient hier dazu, die Last auszugleichen und nicht in unterschiedlichen Umgebungen zu bauen.  Mit dem Argument <i>Faktor</i> y erhält der Kollektor eine Folge von Schritten zum Erstellen des Projekts.  Ich werde weiter unten ausführlich darüber schreiben. <br><br>  Beispiel für die Konfiguration des Kollektors <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>] = [util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'My Builder'</span></span>, workernames = [<span class="hljs-string"><span class="hljs-string">'stretch32'</span></span>], factory = factory )]</code> </pre> <br>  Das Projekt ist also fertig.  Der letzte Schritt von Buildbot besteht darin, den Build zu benachrichtigen.  Reporterklassen sind dafür verantwortlich.  Ein klassisches Beispiel ist die <i>MailNotifier-</i> Klasse, die eine E-Mail mit Build-Ergebnissen sendet.  <i>Beispiel für eine MailNotifier-</i> Verbindung: <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'services'</span></span>] = [reporters.MailNotifier( fromaddr = <span class="hljs-string"><span class="hljs-string">'buildbot@example.com'</span></span>, relayhost = <span class="hljs-string"><span class="hljs-string">'mail.example.com'</span></span>, smtpPort = <span class="hljs-number"><span class="hljs-number">25</span></span>, extraRecipients = [<span class="hljs-string"><span class="hljs-string">'devel@example.com'</span></span>], sendToInterestedUsers = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> )]</code> </pre> <br>  Nun, es ist Zeit, zu vollwertigen Beispielen überzugehen.  Ich stelle fest, dass Buildbot selbst mit dem Twisted-Framework geschrieben wurde und daher die Kenntnis des Buildbot-Skripts das Schreiben und Verstehen von Buildbot-Skripten erheblich erleichtert.  Wir werden einen Prügelknaben für ein Projekt namens Pet Project haben.  Lassen Sie es in C ++ schreiben, mit CMake zusammenstellen, und der Quellcode liegt im Git-Repository.  Wir waren nicht zu faul und haben Tests für ihn geschrieben, die vom ctest-Team durchgeführt werden.  Zuletzt haben wir diesen Artikel gelesen und festgestellt, dass wir das frisch gewonnene Wissen auf unser Projekt anwenden möchten. <br><br><h3>  Beispiel eins: damit es funktioniert </h3><br>  Eigentlich ist die Konfigurationsdatei: <br><br><div class="spoiler">  <b class="spoiler_title">100 Zeilen Python-Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> buildbot.plugins <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-comment"><span class="hljs-comment"># shortcut c = BuildmasterConfig = {} # create workers c['workers'] = [worker.Worker('stretch32', 'example_password')] # general settings c['title'] = 'Buildbot: test' c['titleURL'] = 'https://buildbot.example.com/' c['buildbotURL'] = 'https://buildbot.example.com/' # setup database c['db'] = { 'db_url': 'sqlite:///state.sqlite' } # port to communicate with workers c['protocols'] = { 'pb': { 'port': 9989 } } # make buildbot developers a little bit happier c['buildbotNetUsageData'] = 'basic' # webserver setup c['www'] = dict(plugins = dict(waterfall_view={}, console_view={}, grid_view={})) c['www']['authz'] = util.Authz( allowRules = [util.AnyEndpointMatcher(role = 'admins')], roleMatchers = [util.RolesFromUsername(roles = ['admins'], usernames = ['root'])] ) c['www']['auth'] = util.UserPasswordAuth([('root', 'root_password')]) # mail notification c['services'] = [reporters.MailNotifier( fromaddr = 'buildbot@example.com', relayhost = 'mail.example.com', smtpPort = 25, extraRecipients = ['devel@example.com'], sendToInterestedUsers = False )] c['change_source'] = [changes.GitPoller( repourl = 'git@git.example.com:pet-project', project = 'Pet Project', branches = True, pollInterval = 60 )] c['schedulers'] = [schedulers.AnyBranchScheduler( name = 'Pet Project Scheduler', treeStableTimer = None, change_filter = util.ChangeFilter(project = 'Pet Project'), builderNames = ['Pet Project Builder'] )] factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property('repository'), workdir = 'sources', haltOnFailure = True, submodules = True, progress = True) ) factory.addStep(steps.ShellSequence( name = 'create builddir', haltOnFailure = True, hideStepIf = lambda results, s: results == util.SUCCESS, commands = [ util.ShellArg(command = ['rm', '-rf', 'build']), util.ShellArg(command = ['mkdir', 'build']) ]) ) factory.addStep(steps.CMake( workdir = 'build', path = '../sources', haltOnFailure = True) ) factory.addStep(steps.Compile( name = 'build project', workdir = 'build', haltOnFailure = True, warnOnWarnings = True, command = ['make']) ) factory.addStep(steps.ShellCommand( name = 'run tests', workdir = 'build', haltOnFailure = True, command = ['ctest']) ) c['builders'] = [util.BuilderConfig( name = 'Pet Project Builder', workernames = ['stretch32'], factory = factory )]</span></span></code> </pre> <br></div></div><br>  Durch das Schreiben dieser Zeilen erhalten wir eine automatische Assemblierung beim Pushing in das Repository, ein schönes Webface, E-Mail-Benachrichtigungen und andere Attribute eines sich selbst respektierenden ci.  Das meiste davon sollte klar sein: Die Einstellungen der Scheduler, Collectors und anderer Objekte werden ähnlich wie in den zuvor angegebenen Beispielen vorgenommen. Der Wert der meisten Parameter ist intuitiv.  Im Detail werde ich mich nur auf die Schaffung einer Fabrik konzentrieren, was ich früher versprochen habe. <br><br>  Die Factory besteht aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Build-Schritten</a> , die Buildbot für das Projekt ausführen muss.  Wie bei anderen Klassen gibt es viele vorgefertigte Lösungen.  Unsere Fabrik besteht aus fünf Schritten.  In der Regel besteht der erste Schritt darin, den aktuellen Status des Repositorys abzurufen. Hier machen wir keine Ausnahme.  Dazu verwenden wir die Standard- <i>Git-</i> Klasse: <br><br><div class="spoiler">  <b class="spoiler_title">Erster Schritt</b> <div class="spoiler_text"><pre> <code class="python hljs">factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, submodules = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, progress = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) )</code> </pre> <br></div></div><br>  Als nächstes müssen wir ein Verzeichnis erstellen, in dem das Projekt zusammengestellt wird - wir werden einen vollständigen Build aus dem Quellcode erstellen.  Zuvor müssen Sie daran denken, das Verzeichnis zu löschen, falls es bereits vorhanden ist.  Daher müssen wir zwei Befehle ausführen.  Die <i>ShellSequence-</i> Klasse hilft uns dabei: <br><br><div class="spoiler">  <b class="spoiler_title">Zweiter Schritt</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.ShellSequence( name = <span class="hljs-string"><span class="hljs-string">'create builddir'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS, commands = [ util.ShellArg(command = [<span class="hljs-string"><span class="hljs-string">'rm'</span></span>, <span class="hljs-string"><span class="hljs-string">'-rf'</span></span>, <span class="hljs-string"><span class="hljs-string">'build'</span></span>]), util.ShellArg(command = [<span class="hljs-string"><span class="hljs-string">'mkdir'</span></span>, <span class="hljs-string"><span class="hljs-string">'build'</span></span>]) ]) )</code> </pre> <br></div></div><br>  Jetzt müssen Sie CMake starten.  Dazu ist es logisch, eine von zwei Klassen zu verwenden - <i>ShellCommand</i> oder <i>CMake</i> .  Wir werden letzteres verwenden, aber die Unterschiede sind minimal: Es ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einfacher Wrapper</a> über die erste Klasse, was es etwas bequemer macht, CMake-spezifische Argumente zu übergeben. <br><br><div class="spoiler">  <b class="spoiler_title">Dritter Schritt</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.CMake( workdir = <span class="hljs-string"><span class="hljs-string">'build'</span></span>, path = <span class="hljs-string"><span class="hljs-string">'../sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) )</code> </pre> <br></div></div><br>  Zeit, das Projekt zu kompilieren.  Wie im vorherigen Fall können Sie <i>ShellCommand verwenden</i> .  Ebenso gibt es die <i>Compile-</i> Klasse, die einen Wrapper über <i>ShellCommand darstellt</i> .  Dies ist jedoch ein schwierigerer Wrapper: Die <i>Compile-</i> Klasse überwacht Warnungen während der Kompilierung und zeigt sie genau in einem separaten Protokoll an.  Deshalb werden wir die <i>Compile-</i> Klasse verwenden: <br><br><div class="spoiler">  <b class="spoiler_title">Vierter Schritt</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.Compile( name = <span class="hljs-string"><span class="hljs-string">'build project'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'build'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, warnOnWarnings = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, command = [<span class="hljs-string"><span class="hljs-string">'make'</span></span>]) )</code> </pre> <br></div></div><br>  Führen Sie zum Schluss unsere Tests durch.  Hier verwenden wir die <i>zuvor</i> erwähnte <i>ShellCommand-</i> Klasse: <br><br><div class="spoiler">  <b class="spoiler_title">Fünfter Schritt</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.ShellCommand( name = <span class="hljs-string"><span class="hljs-string">'run tests'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'build'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, command = [<span class="hljs-string"><span class="hljs-string">'ctest'</span></span>]) )</code> </pre> <br></div></div><br><h3>  Beispiel zwei: Pipeline als Code </h3><br>  Hier werde ich zeigen, wie eine Budgetoption zum Speichern der Testlogik zusammen mit dem Projektquellcode und nicht in der ci-Server-Konfigurationsdatei implementiert wird.  <i>Fügen Sie dazu</i> die <i>.buildbot-</i> Datei mit dem Code in das Repository ein, in dem jede Zeile aus Wörtern besteht, von denen die erste als Verzeichnis für die Ausführung des Befehls und der Rest als Befehl mit ihren Argumenten interpretiert wird.  Für unser Haustierprojekt <i>sieht</i> die <i>.buildbot-</i> Datei folgendermaßen aus: <br><br><div class="spoiler">  <b class="spoiler_title">.Buildbot-Datei mit Befehlen</b> <div class="spoiler_text"> <code>. rm -rf build <br> . mkdir build <br> build cmake ../sources <br> build make <br> build ctest</code> <br> </div></div><br>  Jetzt müssen wir die Buildbot-Konfigurationsdatei ändern.  Um die <i>.buildbot-</i> Datei zu analysieren, müssen wir eine Klasse unseres eigenen Schritts schreiben.  In diesem Schritt wird die <i>.buildbot-</i> Datei gelesen. <i>Anschließend</i> wird für jede Zeile der <i>ShellCommand-</i> Schritt mit den erforderlichen Argumenten <i>hinzugefügt</i> .  Um Schritte dynamisch hinzuzufügen, verwenden wir die Methode <b>build.addStepsAfterCurrentStep ()</b> .  Es sieht überhaupt nicht beängstigend aus: <br><br><div class="spoiler">  <b class="spoiler_title">Klasse AnalyseSchritt</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyseStep</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ShellMixin, BuildStep)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, workdir, **kwargs)</span></span></span><span class="hljs-function">:</span></span> kwargs = self.setupShellMixin(kwargs, prohibitArgs = [<span class="hljs-string"><span class="hljs-string">'command'</span></span>, <span class="hljs-string"><span class="hljs-string">'workdir'</span></span>, <span class="hljs-string"><span class="hljs-string">'want_stdout'</span></span>]) BuildStep.__init__(self, **kwargs) self.workdir = workdir @defer.inlineCallbacks <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.stdio_log = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.addLog(<span class="hljs-string"><span class="hljs-string">'stdio'</span></span>) cmd = RemoteShellCommand( command = [<span class="hljs-string"><span class="hljs-string">'cat'</span></span>, <span class="hljs-string"><span class="hljs-string">'.buildbot'</span></span>], workdir = self.workdir, want_stdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, want_stderr = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, collectStdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> ) cmd.useLog(self.stdio_log) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.runCommand(cmd) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cmd.didFail(): defer.returnValue(util.FAILURE) results = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cmd.stdout.splitlines(): lst = row.split() dirname = lst.pop(<span class="hljs-number"><span class="hljs-number">0</span></span>) results.append(steps.ShellCommand( name = lst[<span class="hljs-number"><span class="hljs-number">0</span></span>], command = lst, workdir = dirname ) ) self.build.addStepsAfterCurrentStep(results) defer.returnValue(util.SUCCESS)</code> </pre> <br></div></div><br>  Dank dieses Ansatzes ist die Fabrik für den Sammler einfacher und vielseitiger geworden: <br><br><div class="spoiler">  <b class="spoiler_title">Factory zum Analysieren der .buildbot-Datei</b> <div class="spoiler_text"><pre> <code class="python hljs">factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, submodules = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, progress = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, mode = <span class="hljs-string"><span class="hljs-string">'incremental'</span></span>) ) factory.addStep(AnalyseStep( name = <span class="hljs-string"><span class="hljs-string">'Analyse .buildbot file'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS) )</code> </pre> <br></div></div><br><h3>  Beispiel drei: Arbeiter als Code </h3><br>  Stellen Sie sich nun vor, dass wir neben dem Projektcode nicht die Reihenfolge der Befehle bestimmen müssen, sondern die Umgebung für die Assembly.  In der Tat definieren wir Arbeiter.  <i>Die .buildbot-</i> Datei könnte <i>ungefähr so</i> aussehen: <br><br><div class="spoiler">  <b class="spoiler_title">.Buildbot-Umgebungsdatei</b> <div class="spoiler_text"> <code>{ <br> "workers": ["stretch32", "wheezy32"] <br> }</code> <br> </div></div><br>  In diesem Fall wird die Buildbot-Konfigurationsdatei komplizierter, da die Assemblys in verschiedenen Umgebungen miteinander verbunden werden sollen (wenn mindestens eine Umgebung ausfällt, wurde das gesamte Commit als nicht funktionsfähig angesehen).  Zwei Ebenen helfen uns, das Problem zu lösen.  Wir werden einen lokalen Mitarbeiter haben, der die <i>.buildbot-</i> Datei analysiert und die Builds für die gewünschten Mitarbeiter <i>ausführt</i> .  Zunächst schreiben wir wie im vorherigen Beispiel unseren Schritt zur Analyse der <i>.buildbot-</i> Datei.  Um die Assembly für einen bestimmten Worker zu starten, werden ein Bundle aus dem <i>Trigger-</i> Schritt und eine spezielle Art von <i>TriggerableScheduler-</i> Schedulern <i>verwendet</i> .  Unser Schritt ist etwas komplizierter, aber durchaus verständlich geworden: <br><br><div class="spoiler">  <b class="spoiler_title">Klasse AnalyseSchritt</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyseStep</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ShellMixin, BuildStep)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, workdir, **kwargs)</span></span></span><span class="hljs-function">:</span></span> kwargs = self.setupShellMixin(kwargs, prohibitArgs = [<span class="hljs-string"><span class="hljs-string">'command'</span></span>, <span class="hljs-string"><span class="hljs-string">'workdir'</span></span>, <span class="hljs-string"><span class="hljs-string">'want_stdout'</span></span>]) BuildStep.__init__(self, **kwargs) self.workdir = workdir @defer.inlineCallbacks <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_getWorkerList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> cmd = RemoteShellCommand( command = [<span class="hljs-string"><span class="hljs-string">'cat'</span></span>, <span class="hljs-string"><span class="hljs-string">'.buildbot'</span></span>], workdir = self.workdir, want_stdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, want_stderr = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, collectStdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> ) cmd.useLog(self.stdio_log) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.runCommand(cmd) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cmd.didFail(): defer.returnValue([]) <span class="hljs-comment"><span class="hljs-comment"># parse JSON try: payload = json.loads(cmd.stdout) workers = payload.get('workers', []) except json.decoder.JSONDecodeError as e: raise ValueError('Error loading JSON from .buildbot file: {}' .format(str(e))) defer.returnValue(workers) @defer.inlineCallbacks def run(self): self.stdio_log = yield self.addLog('stdio') try: workers = yield self._getWorkerList() except ValueError as e: yield self.stdio_log.addStdout(str(e)) defer.returnValue(util.FAILURE) results = [] for worker in workers: results.append(steps.Trigger( name = 'check on worker "{}"'.format(worker), schedulerNames = ['Pet Project ({}) Scheduler'.format(worker)], waitForFinish = True, haltOnFailure = True, warnOnWarnings = True, updateSourceStamp = False, alwaysUseLatest = False ) ) self.build.addStepsAfterCurrentStep(results) defer.returnValue(util.SUCCESS)</span></span></code> </pre> <br></div></div><br>  Wir werden diesen Schritt auf den lokalen Arbeiter anwenden.  Bitte beachten Sie, dass wir das Tag auf unseren Sammler "Pet Project Builder" gesetzt haben.  Damit können wir <i>MailNotifier</i> filtern und <i>festlegen</i> , dass Briefe nur an bestimmte Sammler gesendet werden sollen.  Wenn diese Filterung nicht durchgeführt wird, erhalten wir beim Erstellen des Commits in zwei Umgebungen drei Buchstaben. <br><br><div class="spoiler">  <b class="spoiler_title">Allgemeiner Sammler</b> <div class="spoiler_text"><pre> <code class="python hljs">factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, submodules = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, progress = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, mode = <span class="hljs-string"><span class="hljs-string">'incremental'</span></span>) ) factory.addStep(AnalyseStep( name = <span class="hljs-string"><span class="hljs-string">'Analyse .buildbot file'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>] = [util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Builder'</span></span>, tags = [<span class="hljs-string"><span class="hljs-string">'generic_builder'</span></span>], workernames = [<span class="hljs-string"><span class="hljs-string">'local'</span></span>], factory = factory )]</code> </pre> <br></div></div><br>  Wir müssen nur die Sammler und die gleichen auslösbaren Scheduler für alle unsere echten Arbeiter hinzufügen: <br><br><div class="spoiler">  <b class="spoiler_title">Sammler in der richtigen Umgebung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> worker <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> allWorkers: c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>].append(schedulers.Triggerable( name = <span class="hljs-string"><span class="hljs-string">'Pet Project ({}) Scheduler'</span></span>.format(worker), builderNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project ({}) Builder'</span></span>.format(worker)]) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>].append(util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project ({}) Builder'</span></span>.format(worker), workernames = [worker], factory = specific_factory) )</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/iq/_n/n4/iq_nn4nhvj07vcina32c2244o6a.png"><br>  <i><font color="#aaaaaa">(Seite unseres Projekts in zwei Umgebungen erstellen)</font></i> <br><br><h3>  Beispiel 4: Ein Buchstabe pro mehrere Commits </h3><br>  Wenn Sie eines der obigen Beispiele verwenden, können Sie eine unangenehme Funktion feststellen.  Da für jedes Commit ein Buchstabe erstellt wird, erhalten wir 20 Buchstaben, wenn wir den Zweig mit 20 neuen Commits verschieben.  Wenn Sie dies vermeiden, wie im vorherigen Beispiel, helfen wir auf zwei Ebenen.  Wir müssen auch die Klasse ändern, um die Änderungen zu erhalten.  Anstatt viele Änderungsobjekte zu erstellen, erstellen wir nur ein solches Objekt, in dessen Eigenschaften eine Liste aller Commits übertragen wird.  In Eile kann dies folgendermaßen geschehen: <br><br><div class="spoiler">  <b class="spoiler_title">Klasse MultiGitHubHandler</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiGitHubHandler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(GitHubHandler)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> new_changes = GitHubHandler.getChanges(self, request) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> new_changes: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ([], <span class="hljs-string"><span class="hljs-string">'git'</span></span>) change = new_changes[<span class="hljs-number"><span class="hljs-number">-1</span></span>] change[<span class="hljs-string"><span class="hljs-string">'revision'</span></span>] = <span class="hljs-string"><span class="hljs-string">'{}..{}'</span></span>.format( new_changes[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">'revision'</span></span>], new_changes[<span class="hljs-number"><span class="hljs-number">-1</span></span>][<span class="hljs-string"><span class="hljs-string">'revision'</span></span>]) commits = [c[<span class="hljs-string"><span class="hljs-string">'revision'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_changes] change[<span class="hljs-string"><span class="hljs-string">'properties'</span></span>][<span class="hljs-string"><span class="hljs-string">'commits'</span></span>] = commits <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ([change], <span class="hljs-string"><span class="hljs-string">'git'</span></span>) c[<span class="hljs-string"><span class="hljs-string">'www'</span></span>][<span class="hljs-string"><span class="hljs-string">'change_hook_dialects'</span></span>] = { <span class="hljs-string"><span class="hljs-string">'base'</span></span>: { <span class="hljs-string"><span class="hljs-string">'custom_class'</span></span>: MultiGitHubHandler } }</code> </pre> <br></div></div><br>  Um mit solch einem ungewöhnlichen Änderungsobjekt arbeiten zu können, benötigen wir unseren eigenen speziellen Schritt, der dynamisch Schritte erstellt, die ein bestimmtes Commit erfassen: <br><br><div class="spoiler">  <b class="spoiler_title">Klasse GenerateCommitSteps</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenerateCommitSteps</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BuildStep)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> commits = self.getProperty(<span class="hljs-string"><span class="hljs-string">'commits'</span></span>) results = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> commit <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> commits: results.append(steps.Trigger( name = <span class="hljs-string"><span class="hljs-string">'Checking commit {}'</span></span>.format(commit), schedulerNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project Commits Scheduler'</span></span>], waitForFinish = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, warnOnWarnings = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, sourceStamp = { <span class="hljs-string"><span class="hljs-string">'branch'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'branch'</span></span>), <span class="hljs-string"><span class="hljs-string">'revision'</span></span>: commit, <span class="hljs-string"><span class="hljs-string">'codebase'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'codebase'</span></span>), <span class="hljs-string"><span class="hljs-string">'repository'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), <span class="hljs-string"><span class="hljs-string">'project'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'project'</span></span>) } ) ) self.build.addStepsAfterCurrentStep(results) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> util.SUCCESS</code> </pre> <br></div></div><br>  Fügen Sie unseren gemeinsamen Sammler hinzu, der nur für die Ausführung von Assemblys einzelner Commits zuständig ist.  Es sollte markiert werden, um dann das Senden von Briefen nach diesem Tag selbst zu filtern. <br><br><div class="spoiler">  <b class="spoiler_title">General Mail Fetcher</b> <div class="spoiler_text"><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>] = [schedulers.AnyBranchScheduler( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Branches Scheduler'</span></span>, treeStableTimer = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, change_filter = util.ChangeFilter(project = <span class="hljs-string"><span class="hljs-string">'Pet Project'</span></span>), builderNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project Branches Builder'</span></span>] )] branches_factory = util.BuildFactory() branches_factory.addStep(GenerateCommitSteps( name = <span class="hljs-string"><span class="hljs-string">'Generate commit steps'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>] = [util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Branches Builder'</span></span>, tags = [<span class="hljs-string"><span class="hljs-string">'branch_builder'</span></span>], workernames = [<span class="hljs-string"><span class="hljs-string">'local'</span></span>], factory = branches_factory )]</code> </pre> <br></div></div><br>  Es bleibt nur der Kollektor für einzelne Commits hinzuzufügen.  Wir kennzeichnen diesen Sammler nur nicht mit einem Tag, daher werden keine Buchstaben dafür erstellt. <br><br><div class="spoiler">  <b class="spoiler_title">General Mail Fetcher</b> <div class="spoiler_text"><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>].append(schedulers.Triggerable( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Commits Scheduler'</span></span>, builderNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project Commits Builder'</span></span>]) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>].append(util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Commits Builder'</span></span>, workernames = [<span class="hljs-string"><span class="hljs-string">'stretch32'</span></span>], factory = specific_factory) )</code> </pre> <br></div></div><br><h3>  Letzte Worte </h3><br>  Dieser Artikel ersetzt in keiner Weise das Lesen der offiziellen Dokumentation. Wenn Sie also an Buildbot interessiert sind, sollten Sie ihn als Nächstes lesen.  Vollversionen der Konfigurationsdateien aller Beispiele sind auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github</a> verfügbar.  Verwandte Links, von denen die meisten Materialien für den Artikel stammen: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielle Dokumentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projektquellcode</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439096/">https://habr.com/ru/post/de439096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439080/index.html">Das nicht offensichtliche RabbitMQ in Yii2 oder warum RabbitMQ gleichzeitig in alle Warteschlangen schreibt</a></li>
<li><a href="../de439082/index.html">Wünschen Sie Factory Walk</a></li>
<li><a href="../de439086/index.html">Ursachen von ANR und wie man es vermeidet</a></li>
<li><a href="../de439090/index.html">Die IBM 5150. Wo das Monopol begann</a></li>
<li><a href="../de439094/index.html">Wissenschaftler haben das älteste lebende Wirbeltier der Erde gefunden</a></li>
<li><a href="../de439098/index.html">Sasha Memus, Chatfuel: Wie man nach Beratung eine Karriere in Produkten aufbaut, ist es gefährlich zu meditieren und wie man Verhalten ändert</a></li>
<li><a href="../de439100/index.html">So passen Sie UX / UI unter Berechtigungen an</a></li>
<li><a href="../de439102/index.html">Russen sind 20% häufiger im Internet beleidigt</a></li>
<li><a href="../de439104/index.html">Redux Einfach wie ein Rechen</a></li>
<li><a href="../de439108/index.html">Amateurfunkmessungen: Wenn kein Frequenzmesser vorhanden ist</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>