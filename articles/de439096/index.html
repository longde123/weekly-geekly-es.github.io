<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêõ üë®üèº‚Äçüé® üóª Buildbot: eine Geschichte mit Beispielen eines anderen kontinuierlichen Integrationssystems üë®‚Äçüöí üë¥üèæ üìÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(Bild von der offiziellen Seite ) 

 Buildbot ist, wie der Name schon sagt, ein kontinuierliches Integrationssystem (ci). Es gab bereits mehrere Artik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buildbot: eine Geschichte mit Beispielen eines anderen kontinuierlichen Integrationssystems</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439096/"><img src="https://habrastorage.org/webt/so/qs/u1/soqsu1skae_0xuktzdemfv-n3yq.png"><br>  <i><font color="#aaaaaa">(Bild von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Seite</a> )</font></i> <br><br>  Buildbot ist, wie der Name schon sagt, ein kontinuierliches Integrationssystem (ci).  Es gab bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehrere</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> √ºber ihn auf dem Habr√©, aber aus meiner Sicht sind die Vorteile dieses Werkzeugs nicht sehr klar.  Au√üerdem gibt es fast keine Beispiele, was es schwierig macht, die volle Leistungsf√§higkeit des Programms zu erkennen.  In meinem Artikel werde ich versuchen, diese M√§ngel auszugleichen, √ºber das interne Ger√§t Buildbot'a zu sprechen und Beispiele f√ºr einige nicht standardm√§√üige Skripte zu geben. <br><a name="habracut"></a><br><h3>  Gemeinsame W√∂rter </h3><br>  Derzeit gibt es eine gro√üe Anzahl kontinuierlicher Integrationssysteme, und wenn es um eines davon geht, stellen sich ganz logische Fragen im Sinne von "Warum wird es ben√∂tigt, wenn Sie bereits einen &lt;Programmname&gt; haben und jeder ihn verwendet?"  Ich werde versuchen, eine solche Frage zu Buildbot zu beantworten.  Einige der Informationen werden mit vorhandenen Artikeln dupliziert, andere sind in der offiziellen Dokumentation beschrieben, dies ist jedoch f√ºr die Konsistenz der Erz√§hlung erforderlich. <br><br>  Der Hauptunterschied zu anderen kontinuierlichen Integrationssystemen besteht darin, dass Buildbot ein Python-Framework zum Schreiben von ci ist und keine sofort einsatzbereite L√∂sung.  Dies bedeutet, dass Sie zum Verbinden eines Projekts mit Buildbot zun√§chst ein separates Python-Programm mit dem Buildbot-Framework schreiben m√ºssen, das die f√ºr Ihr Projekt erforderliche kontinuierliche Integrationsfunktion implementiert.  Dieser Ansatz bietet enorme Flexibilit√§t und erm√∂glicht es Ihnen, knifflige Testszenarien zu implementieren, die aufgrund von Architekturbeschr√§nkungen f√ºr Out-of-Box-L√∂sungen nicht m√∂glich sind. <br><br>  Au√üerdem ist Buildbot kein Dienst, und daher m√ºssen Sie ihn ehrlich in Ihrer Infrastruktur bereitstellen.  Hier stelle ich fest, dass das Framework den Ressourcen des Systems sehr treu ist.  Dies ist sicherlich nicht C oder C ++, aber Python gewinnt gegen seine Java-Konkurrenten.  Hier zum Beispiel der Vergleich des Speicherverbrauchs mit GoCD (und ja, trotz des Namens ist dies ein Java-System): <br><br>  Buildbot: <br><br><img src="https://habrastorage.org/webt/q1/tg/wu/q1tgwuy-ef8bl6au-s7lc07da-c.png"><br><br>  GoCD: <br><br><img src="https://habrastorage.org/webt/lg/ci/bk/lgcibk9si78bjzf_gfqrgktcgug.png"><br><br>  Das Bereitstellen und Schreiben eines separaten Testprogramms selbst kann Sie bei dem Gedanken an die Ersteinrichtung traurig machen.  Die Skripterstellung wird jedoch durch die schiere Anzahl der integrierten Klassen erheblich vereinfacht.  Diese Klassen decken viele Standardoperationen ab, unabh√§ngig davon, ob √Ñnderungen vom Github-Repository abgerufen oder das Projekt mit CMake erstellt werden.  Daher sind Standardskripte f√ºr kleine Projekte f√ºr einige Travis-CI nicht komplizierter als YML-Dateien.  Ich werde nicht √ºber die Bereitstellung schreiben, dies wird in bestehenden Artikeln ausf√ºhrlich behandelt und es gibt dort auch nichts Kompliziertes. <br><br>  Als n√§chstes von Buildbot stelle ich fest, dass die Testlogik standardm√§√üig auf der Seite des ci-Servers implementiert ist.  Dies steht im Widerspruch zu dem mittlerweile beliebten Ansatz ‚ÄûPipeline als Code‚Äú, bei dem die Testlogik in einer Datei (wie .travis.yml) beschrieben wird, die sich zusammen mit dem Projektquellcode im Repository befindet, und der ci-Server diese Datei nur liest und ausf√ºhrt was es sagt.  Auch dies ist nur das Standardverhalten.  Mit den Funktionen des Buildbot-Frameworks k√∂nnen Sie den beschriebenen Ansatz implementieren, indem Sie das Testskript im Repository speichern.  Es gibt sogar eine fertige L√∂sung - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bb-travis</a> , die versucht, das Beste aus Buildbot und travis-ci herauszuholen.  Dar√ºber hinaus werde ich sp√§ter in diesem Artikel beschreiben, wie Sie etwas √Ñhnliches wie dieses Verhalten selbst implementieren k√∂nnen. <br><br>  Buildbot sammelt standardm√§√üig jedes Commit beim Push.  Es mag wie ein kleines unn√∂tiges Merkmal erscheinen, aber f√ºr mich ist es im Gegenteil einer der Hauptvorteile geworden.  Viele g√§ngige L√∂sungen (travis-ci, gitlab-ci) bieten √ºberhaupt keine solche M√∂glichkeit und arbeiten nur mit dem letzten Commit in der Branche.  Stellen Sie sich vor, dass Sie w√§hrend der Entwicklung h√§ufig Commits ausw√§hlen m√ºssen.  Es wird unangenehm sein, ein nicht funktionierendes Commit durchzuf√ºhren, das vom Build-System nicht √ºberpr√ºft wurde, da es zusammen mit einer Reihe von Commits von oben gestartet wurde.  Nat√ºrlich k√∂nnen Sie in Buildbot nur das letzte Commit erstellen, und dies erfolgt durch Festlegen nur eines Parameters. <br><br>  Das Framework verf√ºgt √ºber eine recht gute Dokumentation, die alles detailliert beschreibt, von der allgemeinen Architektur bis zu den Richtlinien f√ºr die Erweiterung der integrierten Klassen.  Selbst mit einer solchen Dokumentation m√ºssen Sie m√∂glicherweise einige Dinge im Quellcode betrachten.  Es ist unter der GPL v2-Lizenz vollst√§ndig ge√∂ffnet und leicht zu lesen.  Von den Minuspunkten - die Dokumentation ist nur in englischer Sprache verf√ºgbar, in russischer Sprache gibt es nur sehr wenige Informationen im Netzwerk.  Das Tool ist gestern nicht erschienen, mit seiner Hilfe werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wireshark</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LLVM</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele andere</a> bekannte Projekte zusammengestellt.  Updates werden ver√∂ffentlicht, das Projekt wird von vielen Entwicklern unterst√ºtzt, sodass wir √ºber Zuverl√§ssigkeit und Stabilit√§t sprechen k√∂nnen. <br><br><img src="https://habrastorage.org/webt/22/we/zg/22wezgyvqnccjmk2sl_ehs954bg.png"><br>  <i><font color="#aaaaaa">(Python Buildbot Homepage)</font></i> <br><br><h3>  Theormin </h3><br>  Dieser Teil ist im Wesentlichen eine freie √úbersetzung des Kapitels der offiziellen Dokumentation zur Architektur des Frameworks.  Es zeigt die gesamte Aktionskette vom Empfang von √Ñnderungen durch das ci-System bis zum Senden von Benachrichtigungen √ºber das Ergebnis an Benutzer.  Sie haben also √Ñnderungen am Quellcode des Projekts vorgenommen und diese an das Remote-Repository gesendet.  Was als n√§chstes passiert, ist im Bild schematisch dargestellt: <br><br><img src="https://habrastorage.org/webt/hq/ue/na/hquenaedpe7hdlulfnmctiew2b8.png"><br>  <i><font color="#aaaaaa">(Bild aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizieller Dokumentation</a> )</font></i> <br><br>  Zun√§chst sollte Buildbot irgendwie herausfinden, dass √Ñnderungen im Repository vorgenommen wurden.  Es gibt zwei Hauptmethoden - Webhooks und Umfragen, obwohl niemand verbietet, sich etwas Anspruchsvolleres auszudenken.  Im ersten Fall sind in Buildbot die BaseHookHandler-Nachkommenklassen daf√ºr verantwortlich.  Es gibt viele vorgefertigte L√∂sungen, zum Beispiel <i>GitHubHandler</i> oder <i>GitoriusHandler</i> .  Die Schl√ºsselmethode in diesen Klassen ist <b>getChanges ()</b> .  Die Logik ist √§u√üerst einfach: Sie muss die HTTP-Anforderung in eine Liste von √Ñnderungsobjekten konvertieren. <br><br>  F√ºr den zweiten Fall ben√∂tigen Sie <i>PollingChangeSource-</i> Nachkommenklassen.  Auch hier gibt es vorgefertigte L√∂sungen wie <i>GitPoller</i> oder <i>HgPoller</i> .  Die Schl√ºsselmethode ist <b>poll ()</b> .  Es wird mit einer bestimmten H√§ufigkeit aufgerufen und muss irgendwie eine Liste der √Ñnderungen im Repository erstellen.  Im Fall eines Git kann dies ein Aufruf zum Abrufen von Git und ein Vergleich mit dem zuvor gespeicherten Status sein.  Wenn die integrierten Funktionen nicht ausreichen, erstellen Sie einfach Ihre eigene Vererbungsklasse und √ºberladen Sie die Methode.  Ein Beispiel f√ºr die Verwendung von Polling: <br><br><pre><code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'change_source'</span></span>] = [changes.GitPoller( repourl = <span class="hljs-string"><span class="hljs-string">'git@git.example.com:project'</span></span>, project = <span class="hljs-string"><span class="hljs-string">'My Project'</span></span>, branches = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-comment"><span class="hljs-comment">#      pollInterval = 60 )]</span></span></code> </pre> <br>  Webhook ist noch einfacher zu bedienen, die Hauptsache ist, nicht zu vergessen, es auf der Git-Server-Seite zu konfigurieren.  Dies ist nur eine Zeile in der Konfigurationsdatei: <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'www'</span></span>][<span class="hljs-string"><span class="hljs-string">'change_hook_dialects'</span></span>] = { <span class="hljs-string"><span class="hljs-string">'github'</span></span>: {} }</code> </pre> <br>  Im n√§chsten Schritt werden die √Ñnderungsobjekte in die Scheduler-Objekte ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler</a> ) eingegeben.  Beispiele f√ºr integrierte Scheduler: <i>AnyBranchScheduler</i> , <i>NightlyScheduler</i> , <i>ForceScheduler</i> usw.  Jeder Scheduler empf√§ngt alle √Ñnderungsobjekte als Eingabe, w√§hlt jedoch nur diejenigen aus, die den Filter bestehen.  Der Filter wird √ºber das Argument <i>change_filter</i> an den Scheduler im Konstruktor <i>√ºbergeben</i> .  Am Ausgang erstellen die Planer Build-Anforderungen.  Der Scheduler w√§hlt die Builder basierend auf dem Builder-Argument aus. <br><br>  Einige Planer haben ein kniffliges Argument namens <i>treeStableTimer</i> .  Dies funktioniert wie folgt: Wenn eine √Ñnderung eingeht, erstellt der Scheduler nicht sofort eine neue Build-Anforderung, sondern startet einen Timer.  Wenn neue √Ñnderungen eintreffen und der Timer nicht abgelaufen ist, wird die alte √Ñnderung durch eine neue ersetzt und der Timer aktualisiert.  Wenn der Timer endet, erstellt der Scheduler nur eine Build-Anforderung aus der zuletzt gespeicherten √Ñnderung. <br><br>  Somit ist die Logik implementiert, nur das letzte Commit beim Push zusammenzusetzen.  Beispiel f√ºr die Scheduler-Konfiguration: <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>] = [schedulers.AnyBranchScheduler( name = <span class="hljs-string"><span class="hljs-string">'My Scheduler'</span></span>, treeStableTimer = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, change_filter = util.ChangeFilter(project = <span class="hljs-string"><span class="hljs-string">'My Project'</span></span>), builderNames = [<span class="hljs-string"><span class="hljs-string">'My Builder'</span></span>] )]</code> </pre> <br>  Build-Anforderungen, so seltsam sie auch klingen m√∂gen, gehen an die Eingabe der Builder.  Die Aufgabe des Sammlers besteht darin, die Assembly auf einem zug√§nglichen ‚ÄûWorker‚Äú auszuf√ºhren.  Worker ist eine Build-Umgebung wie Stretch64 oder Ubuntu1804x64.  Die Liste der Arbeiter wird durch das <i>Arbeiterargument geleitet</i> .  Alle Arbeiter in der Liste sollten gleich sein (d. H. Die Namen sind nat√ºrlich unterschiedlich, aber die Umgebung im Inneren ist die gleiche), da der Sammler frei ist, einen der verf√ºgbaren auszuw√§hlen.  Das Festlegen mehrerer Werte dient hier dazu, die Last auszugleichen und nicht in unterschiedlichen Umgebungen zu bauen.  Mit dem Argument <i>Faktor</i> y erh√§lt der Kollektor eine Folge von Schritten zum Erstellen des Projekts.  Ich werde weiter unten ausf√ºhrlich dar√ºber schreiben. <br><br>  Beispiel f√ºr die Konfiguration des Kollektors <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>] = [util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'My Builder'</span></span>, workernames = [<span class="hljs-string"><span class="hljs-string">'stretch32'</span></span>], factory = factory )]</code> </pre> <br>  Das Projekt ist also fertig.  Der letzte Schritt von Buildbot besteht darin, den Build zu benachrichtigen.  Reporterklassen sind daf√ºr verantwortlich.  Ein klassisches Beispiel ist die <i>MailNotifier-</i> Klasse, die eine E-Mail mit Build-Ergebnissen sendet.  <i>Beispiel f√ºr eine MailNotifier-</i> Verbindung: <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'services'</span></span>] = [reporters.MailNotifier( fromaddr = <span class="hljs-string"><span class="hljs-string">'buildbot@example.com'</span></span>, relayhost = <span class="hljs-string"><span class="hljs-string">'mail.example.com'</span></span>, smtpPort = <span class="hljs-number"><span class="hljs-number">25</span></span>, extraRecipients = [<span class="hljs-string"><span class="hljs-string">'devel@example.com'</span></span>], sendToInterestedUsers = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> )]</code> </pre> <br>  Nun, es ist Zeit, zu vollwertigen Beispielen √ºberzugehen.  Ich stelle fest, dass Buildbot selbst mit dem Twisted-Framework geschrieben wurde und daher die Kenntnis des Buildbot-Skripts das Schreiben und Verstehen von Buildbot-Skripten erheblich erleichtert.  Wir werden einen Pr√ºgelknaben f√ºr ein Projekt namens Pet Project haben.  Lassen Sie es in C ++ schreiben, mit CMake zusammenstellen, und der Quellcode liegt im Git-Repository.  Wir waren nicht zu faul und haben Tests f√ºr ihn geschrieben, die vom ctest-Team durchgef√ºhrt werden.  Zuletzt haben wir diesen Artikel gelesen und festgestellt, dass wir das frisch gewonnene Wissen auf unser Projekt anwenden m√∂chten. <br><br><h3>  Beispiel eins: damit es funktioniert </h3><br>  Eigentlich ist die Konfigurationsdatei: <br><br><div class="spoiler">  <b class="spoiler_title">100 Zeilen Python-Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> buildbot.plugins <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-comment"><span class="hljs-comment"># shortcut c = BuildmasterConfig = {} # create workers c['workers'] = [worker.Worker('stretch32', 'example_password')] # general settings c['title'] = 'Buildbot: test' c['titleURL'] = 'https://buildbot.example.com/' c['buildbotURL'] = 'https://buildbot.example.com/' # setup database c['db'] = { 'db_url': 'sqlite:///state.sqlite' } # port to communicate with workers c['protocols'] = { 'pb': { 'port': 9989 } } # make buildbot developers a little bit happier c['buildbotNetUsageData'] = 'basic' # webserver setup c['www'] = dict(plugins = dict(waterfall_view={}, console_view={}, grid_view={})) c['www']['authz'] = util.Authz( allowRules = [util.AnyEndpointMatcher(role = 'admins')], roleMatchers = [util.RolesFromUsername(roles = ['admins'], usernames = ['root'])] ) c['www']['auth'] = util.UserPasswordAuth([('root', 'root_password')]) # mail notification c['services'] = [reporters.MailNotifier( fromaddr = 'buildbot@example.com', relayhost = 'mail.example.com', smtpPort = 25, extraRecipients = ['devel@example.com'], sendToInterestedUsers = False )] c['change_source'] = [changes.GitPoller( repourl = 'git@git.example.com:pet-project', project = 'Pet Project', branches = True, pollInterval = 60 )] c['schedulers'] = [schedulers.AnyBranchScheduler( name = 'Pet Project Scheduler', treeStableTimer = None, change_filter = util.ChangeFilter(project = 'Pet Project'), builderNames = ['Pet Project Builder'] )] factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property('repository'), workdir = 'sources', haltOnFailure = True, submodules = True, progress = True) ) factory.addStep(steps.ShellSequence( name = 'create builddir', haltOnFailure = True, hideStepIf = lambda results, s: results == util.SUCCESS, commands = [ util.ShellArg(command = ['rm', '-rf', 'build']), util.ShellArg(command = ['mkdir', 'build']) ]) ) factory.addStep(steps.CMake( workdir = 'build', path = '../sources', haltOnFailure = True) ) factory.addStep(steps.Compile( name = 'build project', workdir = 'build', haltOnFailure = True, warnOnWarnings = True, command = ['make']) ) factory.addStep(steps.ShellCommand( name = 'run tests', workdir = 'build', haltOnFailure = True, command = ['ctest']) ) c['builders'] = [util.BuilderConfig( name = 'Pet Project Builder', workernames = ['stretch32'], factory = factory )]</span></span></code> </pre> <br></div></div><br>  Durch das Schreiben dieser Zeilen erhalten wir eine automatische Assemblierung beim Pushing in das Repository, ein sch√∂nes Webface, E-Mail-Benachrichtigungen und andere Attribute eines sich selbst respektierenden ci.  Das meiste davon sollte klar sein: Die Einstellungen der Scheduler, Collectors und anderer Objekte werden √§hnlich wie in den zuvor angegebenen Beispielen vorgenommen. Der Wert der meisten Parameter ist intuitiv.  Im Detail werde ich mich nur auf die Schaffung einer Fabrik konzentrieren, was ich fr√ºher versprochen habe. <br><br>  Die Factory besteht aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Build-Schritten</a> , die Buildbot f√ºr das Projekt ausf√ºhren muss.  Wie bei anderen Klassen gibt es viele vorgefertigte L√∂sungen.  Unsere Fabrik besteht aus f√ºnf Schritten.  In der Regel besteht der erste Schritt darin, den aktuellen Status des Repositorys abzurufen. Hier machen wir keine Ausnahme.  Dazu verwenden wir die Standard- <i>Git-</i> Klasse: <br><br><div class="spoiler">  <b class="spoiler_title">Erster Schritt</b> <div class="spoiler_text"><pre> <code class="python hljs">factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, submodules = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, progress = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) )</code> </pre> <br></div></div><br>  Als n√§chstes m√ºssen wir ein Verzeichnis erstellen, in dem das Projekt zusammengestellt wird - wir werden einen vollst√§ndigen Build aus dem Quellcode erstellen.  Zuvor m√ºssen Sie daran denken, das Verzeichnis zu l√∂schen, falls es bereits vorhanden ist.  Daher m√ºssen wir zwei Befehle ausf√ºhren.  Die <i>ShellSequence-</i> Klasse hilft uns dabei: <br><br><div class="spoiler">  <b class="spoiler_title">Zweiter Schritt</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.ShellSequence( name = <span class="hljs-string"><span class="hljs-string">'create builddir'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS, commands = [ util.ShellArg(command = [<span class="hljs-string"><span class="hljs-string">'rm'</span></span>, <span class="hljs-string"><span class="hljs-string">'-rf'</span></span>, <span class="hljs-string"><span class="hljs-string">'build'</span></span>]), util.ShellArg(command = [<span class="hljs-string"><span class="hljs-string">'mkdir'</span></span>, <span class="hljs-string"><span class="hljs-string">'build'</span></span>]) ]) )</code> </pre> <br></div></div><br>  Jetzt m√ºssen Sie CMake starten.  Dazu ist es logisch, eine von zwei Klassen zu verwenden - <i>ShellCommand</i> oder <i>CMake</i> .  Wir werden letzteres verwenden, aber die Unterschiede sind minimal: Es ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einfacher Wrapper</a> √ºber die erste Klasse, was es etwas bequemer macht, CMake-spezifische Argumente zu √ºbergeben. <br><br><div class="spoiler">  <b class="spoiler_title">Dritter Schritt</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.CMake( workdir = <span class="hljs-string"><span class="hljs-string">'build'</span></span>, path = <span class="hljs-string"><span class="hljs-string">'../sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) )</code> </pre> <br></div></div><br>  Zeit, das Projekt zu kompilieren.  Wie im vorherigen Fall k√∂nnen Sie <i>ShellCommand verwenden</i> .  Ebenso gibt es die <i>Compile-</i> Klasse, die einen Wrapper √ºber <i>ShellCommand darstellt</i> .  Dies ist jedoch ein schwierigerer Wrapper: Die <i>Compile-</i> Klasse √ºberwacht Warnungen w√§hrend der Kompilierung und zeigt sie genau in einem separaten Protokoll an.  Deshalb werden wir die <i>Compile-</i> Klasse verwenden: <br><br><div class="spoiler">  <b class="spoiler_title">Vierter Schritt</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.Compile( name = <span class="hljs-string"><span class="hljs-string">'build project'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'build'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, warnOnWarnings = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, command = [<span class="hljs-string"><span class="hljs-string">'make'</span></span>]) )</code> </pre> <br></div></div><br>  F√ºhren Sie zum Schluss unsere Tests durch.  Hier verwenden wir die <i>zuvor</i> erw√§hnte <i>ShellCommand-</i> Klasse: <br><br><div class="spoiler">  <b class="spoiler_title">F√ºnfter Schritt</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.ShellCommand( name = <span class="hljs-string"><span class="hljs-string">'run tests'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'build'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, command = [<span class="hljs-string"><span class="hljs-string">'ctest'</span></span>]) )</code> </pre> <br></div></div><br><h3>  Beispiel zwei: Pipeline als Code </h3><br>  Hier werde ich zeigen, wie eine Budgetoption zum Speichern der Testlogik zusammen mit dem Projektquellcode und nicht in der ci-Server-Konfigurationsdatei implementiert wird.  <i>F√ºgen Sie dazu</i> die <i>.buildbot-</i> Datei mit dem Code in das Repository ein, in dem jede Zeile aus W√∂rtern besteht, von denen die erste als Verzeichnis f√ºr die Ausf√ºhrung des Befehls und der Rest als Befehl mit ihren Argumenten interpretiert wird.  F√ºr unser Haustierprojekt <i>sieht</i> die <i>.buildbot-</i> Datei folgenderma√üen aus: <br><br><div class="spoiler">  <b class="spoiler_title">.Buildbot-Datei mit Befehlen</b> <div class="spoiler_text"> <code>. rm -rf build <br> . mkdir build <br> build cmake ../sources <br> build make <br> build ctest</code> <br> </div></div><br>  Jetzt m√ºssen wir die Buildbot-Konfigurationsdatei √§ndern.  Um die <i>.buildbot-</i> Datei zu analysieren, m√ºssen wir eine Klasse unseres eigenen Schritts schreiben.  In diesem Schritt wird die <i>.buildbot-</i> Datei gelesen. <i>Anschlie√üend</i> wird f√ºr jede Zeile der <i>ShellCommand-</i> Schritt mit den erforderlichen Argumenten <i>hinzugef√ºgt</i> .  Um Schritte dynamisch hinzuzuf√ºgen, verwenden wir die Methode <b>build.addStepsAfterCurrentStep ()</b> .  Es sieht √ºberhaupt nicht be√§ngstigend aus: <br><br><div class="spoiler">  <b class="spoiler_title">Klasse AnalyseSchritt</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyseStep</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ShellMixin, BuildStep)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, workdir, **kwargs)</span></span></span><span class="hljs-function">:</span></span> kwargs = self.setupShellMixin(kwargs, prohibitArgs = [<span class="hljs-string"><span class="hljs-string">'command'</span></span>, <span class="hljs-string"><span class="hljs-string">'workdir'</span></span>, <span class="hljs-string"><span class="hljs-string">'want_stdout'</span></span>]) BuildStep.__init__(self, **kwargs) self.workdir = workdir @defer.inlineCallbacks <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.stdio_log = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.addLog(<span class="hljs-string"><span class="hljs-string">'stdio'</span></span>) cmd = RemoteShellCommand( command = [<span class="hljs-string"><span class="hljs-string">'cat'</span></span>, <span class="hljs-string"><span class="hljs-string">'.buildbot'</span></span>], workdir = self.workdir, want_stdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, want_stderr = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, collectStdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> ) cmd.useLog(self.stdio_log) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.runCommand(cmd) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cmd.didFail(): defer.returnValue(util.FAILURE) results = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cmd.stdout.splitlines(): lst = row.split() dirname = lst.pop(<span class="hljs-number"><span class="hljs-number">0</span></span>) results.append(steps.ShellCommand( name = lst[<span class="hljs-number"><span class="hljs-number">0</span></span>], command = lst, workdir = dirname ) ) self.build.addStepsAfterCurrentStep(results) defer.returnValue(util.SUCCESS)</code> </pre> <br></div></div><br>  Dank dieses Ansatzes ist die Fabrik f√ºr den Sammler einfacher und vielseitiger geworden: <br><br><div class="spoiler">  <b class="spoiler_title">Factory zum Analysieren der .buildbot-Datei</b> <div class="spoiler_text"><pre> <code class="python hljs">factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, submodules = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, progress = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, mode = <span class="hljs-string"><span class="hljs-string">'incremental'</span></span>) ) factory.addStep(AnalyseStep( name = <span class="hljs-string"><span class="hljs-string">'Analyse .buildbot file'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS) )</code> </pre> <br></div></div><br><h3>  Beispiel drei: Arbeiter als Code </h3><br>  Stellen Sie sich nun vor, dass wir neben dem Projektcode nicht die Reihenfolge der Befehle bestimmen m√ºssen, sondern die Umgebung f√ºr die Assembly.  In der Tat definieren wir Arbeiter.  <i>Die .buildbot-</i> Datei k√∂nnte <i>ungef√§hr so</i> aussehen: <br><br><div class="spoiler">  <b class="spoiler_title">.Buildbot-Umgebungsdatei</b> <div class="spoiler_text"> <code>{ <br> "workers": ["stretch32", "wheezy32"] <br> }</code> <br> </div></div><br>  In diesem Fall wird die Buildbot-Konfigurationsdatei komplizierter, da die Assemblys in verschiedenen Umgebungen miteinander verbunden werden sollen (wenn mindestens eine Umgebung ausf√§llt, wurde das gesamte Commit als nicht funktionsf√§hig angesehen).  Zwei Ebenen helfen uns, das Problem zu l√∂sen.  Wir werden einen lokalen Mitarbeiter haben, der die <i>.buildbot-</i> Datei analysiert und die Builds f√ºr die gew√ºnschten Mitarbeiter <i>ausf√ºhrt</i> .  Zun√§chst schreiben wir wie im vorherigen Beispiel unseren Schritt zur Analyse der <i>.buildbot-</i> Datei.  Um die Assembly f√ºr einen bestimmten Worker zu starten, werden ein Bundle aus dem <i>Trigger-</i> Schritt und eine spezielle Art von <i>TriggerableScheduler-</i> Schedulern <i>verwendet</i> .  Unser Schritt ist etwas komplizierter, aber durchaus verst√§ndlich geworden: <br><br><div class="spoiler">  <b class="spoiler_title">Klasse AnalyseSchritt</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyseStep</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ShellMixin, BuildStep)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, workdir, **kwargs)</span></span></span><span class="hljs-function">:</span></span> kwargs = self.setupShellMixin(kwargs, prohibitArgs = [<span class="hljs-string"><span class="hljs-string">'command'</span></span>, <span class="hljs-string"><span class="hljs-string">'workdir'</span></span>, <span class="hljs-string"><span class="hljs-string">'want_stdout'</span></span>]) BuildStep.__init__(self, **kwargs) self.workdir = workdir @defer.inlineCallbacks <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_getWorkerList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> cmd = RemoteShellCommand( command = [<span class="hljs-string"><span class="hljs-string">'cat'</span></span>, <span class="hljs-string"><span class="hljs-string">'.buildbot'</span></span>], workdir = self.workdir, want_stdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, want_stderr = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, collectStdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> ) cmd.useLog(self.stdio_log) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.runCommand(cmd) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cmd.didFail(): defer.returnValue([]) <span class="hljs-comment"><span class="hljs-comment"># parse JSON try: payload = json.loads(cmd.stdout) workers = payload.get('workers', []) except json.decoder.JSONDecodeError as e: raise ValueError('Error loading JSON from .buildbot file: {}' .format(str(e))) defer.returnValue(workers) @defer.inlineCallbacks def run(self): self.stdio_log = yield self.addLog('stdio') try: workers = yield self._getWorkerList() except ValueError as e: yield self.stdio_log.addStdout(str(e)) defer.returnValue(util.FAILURE) results = [] for worker in workers: results.append(steps.Trigger( name = 'check on worker "{}"'.format(worker), schedulerNames = ['Pet Project ({}) Scheduler'.format(worker)], waitForFinish = True, haltOnFailure = True, warnOnWarnings = True, updateSourceStamp = False, alwaysUseLatest = False ) ) self.build.addStepsAfterCurrentStep(results) defer.returnValue(util.SUCCESS)</span></span></code> </pre> <br></div></div><br>  Wir werden diesen Schritt auf den lokalen Arbeiter anwenden.  Bitte beachten Sie, dass wir das Tag auf unseren Sammler "Pet Project Builder" gesetzt haben.  Damit k√∂nnen wir <i>MailNotifier</i> filtern und <i>festlegen</i> , dass Briefe nur an bestimmte Sammler gesendet werden sollen.  Wenn diese Filterung nicht durchgef√ºhrt wird, erhalten wir beim Erstellen des Commits in zwei Umgebungen drei Buchstaben. <br><br><div class="spoiler">  <b class="spoiler_title">Allgemeiner Sammler</b> <div class="spoiler_text"><pre> <code class="python hljs">factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, submodules = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, progress = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, mode = <span class="hljs-string"><span class="hljs-string">'incremental'</span></span>) ) factory.addStep(AnalyseStep( name = <span class="hljs-string"><span class="hljs-string">'Analyse .buildbot file'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>] = [util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Builder'</span></span>, tags = [<span class="hljs-string"><span class="hljs-string">'generic_builder'</span></span>], workernames = [<span class="hljs-string"><span class="hljs-string">'local'</span></span>], factory = factory )]</code> </pre> <br></div></div><br>  Wir m√ºssen nur die Sammler und die gleichen ausl√∂sbaren Scheduler f√ºr alle unsere echten Arbeiter hinzuf√ºgen: <br><br><div class="spoiler">  <b class="spoiler_title">Sammler in der richtigen Umgebung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> worker <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> allWorkers: c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>].append(schedulers.Triggerable( name = <span class="hljs-string"><span class="hljs-string">'Pet Project ({}) Scheduler'</span></span>.format(worker), builderNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project ({}) Builder'</span></span>.format(worker)]) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>].append(util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project ({}) Builder'</span></span>.format(worker), workernames = [worker], factory = specific_factory) )</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/iq/_n/n4/iq_nn4nhvj07vcina32c2244o6a.png"><br>  <i><font color="#aaaaaa">(Seite unseres Projekts in zwei Umgebungen erstellen)</font></i> <br><br><h3>  Beispiel 4: Ein Buchstabe pro mehrere Commits </h3><br>  Wenn Sie eines der obigen Beispiele verwenden, k√∂nnen Sie eine unangenehme Funktion feststellen.  Da f√ºr jedes Commit ein Buchstabe erstellt wird, erhalten wir 20 Buchstaben, wenn wir den Zweig mit 20 neuen Commits verschieben.  Wenn Sie dies vermeiden, wie im vorherigen Beispiel, helfen wir auf zwei Ebenen.  Wir m√ºssen auch die Klasse √§ndern, um die √Ñnderungen zu erhalten.  Anstatt viele √Ñnderungsobjekte zu erstellen, erstellen wir nur ein solches Objekt, in dessen Eigenschaften eine Liste aller Commits √ºbertragen wird.  In Eile kann dies folgenderma√üen geschehen: <br><br><div class="spoiler">  <b class="spoiler_title">Klasse MultiGitHubHandler</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiGitHubHandler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(GitHubHandler)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> new_changes = GitHubHandler.getChanges(self, request) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> new_changes: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ([], <span class="hljs-string"><span class="hljs-string">'git'</span></span>) change = new_changes[<span class="hljs-number"><span class="hljs-number">-1</span></span>] change[<span class="hljs-string"><span class="hljs-string">'revision'</span></span>] = <span class="hljs-string"><span class="hljs-string">'{}..{}'</span></span>.format( new_changes[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">'revision'</span></span>], new_changes[<span class="hljs-number"><span class="hljs-number">-1</span></span>][<span class="hljs-string"><span class="hljs-string">'revision'</span></span>]) commits = [c[<span class="hljs-string"><span class="hljs-string">'revision'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_changes] change[<span class="hljs-string"><span class="hljs-string">'properties'</span></span>][<span class="hljs-string"><span class="hljs-string">'commits'</span></span>] = commits <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ([change], <span class="hljs-string"><span class="hljs-string">'git'</span></span>) c[<span class="hljs-string"><span class="hljs-string">'www'</span></span>][<span class="hljs-string"><span class="hljs-string">'change_hook_dialects'</span></span>] = { <span class="hljs-string"><span class="hljs-string">'base'</span></span>: { <span class="hljs-string"><span class="hljs-string">'custom_class'</span></span>: MultiGitHubHandler } }</code> </pre> <br></div></div><br>  Um mit solch einem ungew√∂hnlichen √Ñnderungsobjekt arbeiten zu k√∂nnen, ben√∂tigen wir unseren eigenen speziellen Schritt, der dynamisch Schritte erstellt, die ein bestimmtes Commit erfassen: <br><br><div class="spoiler">  <b class="spoiler_title">Klasse GenerateCommitSteps</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenerateCommitSteps</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BuildStep)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> commits = self.getProperty(<span class="hljs-string"><span class="hljs-string">'commits'</span></span>) results = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> commit <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> commits: results.append(steps.Trigger( name = <span class="hljs-string"><span class="hljs-string">'Checking commit {}'</span></span>.format(commit), schedulerNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project Commits Scheduler'</span></span>], waitForFinish = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, warnOnWarnings = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, sourceStamp = { <span class="hljs-string"><span class="hljs-string">'branch'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'branch'</span></span>), <span class="hljs-string"><span class="hljs-string">'revision'</span></span>: commit, <span class="hljs-string"><span class="hljs-string">'codebase'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'codebase'</span></span>), <span class="hljs-string"><span class="hljs-string">'repository'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), <span class="hljs-string"><span class="hljs-string">'project'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'project'</span></span>) } ) ) self.build.addStepsAfterCurrentStep(results) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> util.SUCCESS</code> </pre> <br></div></div><br>  F√ºgen Sie unseren gemeinsamen Sammler hinzu, der nur f√ºr die Ausf√ºhrung von Assemblys einzelner Commits zust√§ndig ist.  Es sollte markiert werden, um dann das Senden von Briefen nach diesem Tag selbst zu filtern. <br><br><div class="spoiler">  <b class="spoiler_title">General Mail Fetcher</b> <div class="spoiler_text"><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>] = [schedulers.AnyBranchScheduler( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Branches Scheduler'</span></span>, treeStableTimer = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, change_filter = util.ChangeFilter(project = <span class="hljs-string"><span class="hljs-string">'Pet Project'</span></span>), builderNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project Branches Builder'</span></span>] )] branches_factory = util.BuildFactory() branches_factory.addStep(GenerateCommitSteps( name = <span class="hljs-string"><span class="hljs-string">'Generate commit steps'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>] = [util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Branches Builder'</span></span>, tags = [<span class="hljs-string"><span class="hljs-string">'branch_builder'</span></span>], workernames = [<span class="hljs-string"><span class="hljs-string">'local'</span></span>], factory = branches_factory )]</code> </pre> <br></div></div><br>  Es bleibt nur der Kollektor f√ºr einzelne Commits hinzuzuf√ºgen.  Wir kennzeichnen diesen Sammler nur nicht mit einem Tag, daher werden keine Buchstaben daf√ºr erstellt. <br><br><div class="spoiler">  <b class="spoiler_title">General Mail Fetcher</b> <div class="spoiler_text"><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>].append(schedulers.Triggerable( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Commits Scheduler'</span></span>, builderNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project Commits Builder'</span></span>]) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>].append(util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Commits Builder'</span></span>, workernames = [<span class="hljs-string"><span class="hljs-string">'stretch32'</span></span>], factory = specific_factory) )</code> </pre> <br></div></div><br><h3>  Letzte Worte </h3><br>  Dieser Artikel ersetzt in keiner Weise das Lesen der offiziellen Dokumentation. Wenn Sie also an Buildbot interessiert sind, sollten Sie ihn als N√§chstes lesen.  Vollversionen der Konfigurationsdateien aller Beispiele sind auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github</a> verf√ºgbar.  Verwandte Links, von denen die meisten Materialien f√ºr den Artikel stammen: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielle Dokumentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projektquellcode</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439096/">https://habr.com/ru/post/de439096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439080/index.html">Das nicht offensichtliche RabbitMQ in Yii2 oder warum RabbitMQ gleichzeitig in alle Warteschlangen schreibt</a></li>
<li><a href="../de439082/index.html">W√ºnschen Sie Factory Walk</a></li>
<li><a href="../de439086/index.html">Ursachen von ANR und wie man es vermeidet</a></li>
<li><a href="../de439090/index.html">Die IBM 5150. Wo das Monopol begann</a></li>
<li><a href="../de439094/index.html">Wissenschaftler haben das √§lteste lebende Wirbeltier der Erde gefunden</a></li>
<li><a href="../de439098/index.html">Sasha Memus, Chatfuel: Wie man nach Beratung eine Karriere in Produkten aufbaut, ist es gef√§hrlich zu meditieren und wie man Verhalten √§ndert</a></li>
<li><a href="../de439100/index.html">So passen Sie UX / UI unter Berechtigungen an</a></li>
<li><a href="../de439102/index.html">Russen sind 20% h√§ufiger im Internet beleidigt</a></li>
<li><a href="../de439104/index.html">Redux Einfach wie ein Rechen</a></li>
<li><a href="../de439108/index.html">Amateurfunkmessungen: Wenn kein Frequenzmesser vorhanden ist</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>