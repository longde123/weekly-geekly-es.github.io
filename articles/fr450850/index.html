<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø üë∞üèæ üì∑ Vers un avenir meilleur pour les compilateurs intelligents üï¥Ô∏è ‚ò∫Ô∏è ‚òùüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Maintenant, le sujet de l'apprentissage automatique et de l'intelligence artificielle est extr√™mement populaire, en ce moment, gr√¢ce √† la puissance de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vers un avenir meilleur pour les compilateurs intelligents</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450850/">  Maintenant, le sujet de l'apprentissage automatique et de l'intelligence artificielle est extr√™mement populaire, en ce moment, gr√¢ce √† la puissance de calcul des ordinateurs, des id√©es et des algorithmes qui sont apparus depuis longtemps peuvent √™tre mis en ≈ìuvre et consid√©rablement am√©lior√©s.  Presque tous les jours, vous pouvez lire des nouvelles sur les nouvelles r√©alisations dans ce domaine.  De plus, l'apprentissage automatique est utilis√© dans presque tous les domaines ... et le d√©veloppement de compilateurs ne fait pas exception.  Cependant, le domaine est assez sp√©cifique et a ses propres caract√©ristiques et difficult√©s √† cr√©er des compilateurs intelligents.  Dans le m√™me temps, il existe de nombreuses √©tudes sur ce sujet et elles sont men√©es depuis longtemps tant dans le milieu acad√©mique que dans diff√©rentes entreprises. <br><br>  O√π exactement essayez-vous d'appliquer des m√©thodes d'apprentissage automatique lors de la cr√©ation de compilateurs?  Et pourquoi jusqu'√† pr√©sent les compilateurs ¬´intelligents¬ª ne font-ils pas partie du quotidien du d√©veloppeur? <br><a name="habracut"></a><br><h2>  Options d'utilisation de l'apprentissage automatique dans le d√©veloppement de compilateurs </h2><br>  Commen√ßons par la premi√®re question sur les utilisations sp√©cifiques de l'apprentissage automatique.  Le fait est que les compilateurs modernes sont des syst√®mes complexes avec un grand nombre d'optimisations qui vous permettent d'obtenir un code machine plus efficace.  Cependant, certaines optimisations et autres t√¢ches, telles que l'allocation de registres, sont NP-complete, ce qui oblige les d√©veloppeurs de compilateurs √† utiliser des algorithmes heuristiques.  Par cons√©quent, la plupart des compilateurs ont un grand nombre d'indicateurs d'optimisation qui vous permettent de configurer l'heuristique utilis√©e.  Dans LLVM, presque chaque passage a plusieurs options cach√©es qui peuvent affecter son fonctionnement, elles peuvent √™tre utilis√©es soit en utilisant l'indicateur ‚Äìmllvm lors de l'appel de clang, soit dans l'utilitaire opt.  Cependant, cette vari√©t√© d'indicateurs est cach√©e derri√®re les options beaucoup plus fr√©quemment utilis√©es, qui contiennent de nombreux param√®tres √† la fois et sont g√©n√©ralement appel√©es niveaux d'optimisation.  Pour les compilateurs C / C ++, ceux-ci sont connus de la plupart des -O1, -O2, -O3 pour optimiser le runtime et -Os pour optimiser la taille du code.  Mais, malheureusement, le code optimal n'est pas toujours le r√©sultat (les experts assembleurs peuvent r√©√©crire le code g√©n√©r√© de la meilleure fa√ßon), beaucoup d√©pend du code source dans un langage de haut niveau, de l'architecture du processeur, des fonctionnalit√©s du langage, etc. <br><br>  Malgr√© le fait qu'aujourd'hui les processeurs modernes ont suffisamment de RAM et des performances assez √©lev√©es, il existe encore des domaines o√π les performances des applications, l'efficacit√© √©nerg√©tique et la taille du code machine jouent un r√¥le cl√©.  Des exemples de tels domaines comprennent le d√©veloppement de logiciels pour les syst√®mes embarqu√©s avec une quantit√© limit√©e de RAM, le traitement num√©rique du signal, les syst√®mes en temps r√©el, etc.  Par cons√©quent, dans les cas o√π vous avez besoin d'obtenir du code machine hautes performances pour des syst√®mes suffisamment grands, la s√©lection des options de compilation correctes qui donnent le meilleur r√©sultat est une t√¢che importante.  De plus, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">probl√®me</a> du pire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cas d'</a> ex√©cution ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WCET</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">n'a</a> pas disparu lorsque les syst√®mes en temps r√©el doivent calculer et minimiser, si possible, le temps d'ex√©cution d'une t√¢che sp√©cifique sur la plate-forme.  Jusqu'√† pr√©sent, les programmeurs travaillant avec des syst√®mes avec une quantit√© limit√©e de RAM ne peuvent pas enti√®rement compter sur des compilateurs et optimisent souvent ind√©pendamment le code machine g√©n√©r√©. <br><br>  Il est difficile pour une personne de pr√©dire quelles optimisations donneront un bon r√©sultat et qui peuvent conduire √† des r√©gressions, car pour cela, vous devez avoir une bonne compr√©hension des subtilit√©s des algorithmes heuristiques utilis√©s, une bonne connaissance de la structure et des passages du compilateur utilis√©, et conna√Ætre √©galement pleinement le code du programme compil√©, qui Le processus de d√©veloppement d'applications actuel est impossible.  En cons√©quence, l'identification des meilleures options de compilation pour un programme pour une personne devient une t√¢che de recherche exhaustive de diverses combinaisons d'options et de mesures des performances et des tailles de code. <br><br>  De plus, il existe une limitation sous la forme d'une unit√© de compilation avec laquelle vous pouvez travailler et pour laquelle vous pouvez choisir des options.  Donc, pour C / C ++, c'est toujours un fichier qui peut contenir beaucoup de code, qu'il serait peut-√™tre utile d'optimiser de diff√©rentes mani√®res, mais pour le moment ce n'est pas possible.  Par cons√©quent, un compilateur ¬´intelligent¬ª qui pourrait former puis obtenir du code bien optimis√© pour une vari√©t√© de cas est un r√™ve pour certains d√©veloppeurs. <br><br><h2>  Recherche et solutions existantes </h2><br>  Naturellement, le probl√®me de la s√©lection automatis√©e des options de compilation int√©resse les chercheurs depuis de nombreuses ann√©es.  L'un des projets les plus c√©l√®bres est le d√©veloppement de G. Fursin et des chercheurs de son √©quipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MILEPOST GCC</a> , qui est une version du compilateur gcc qui peut lui-m√™me s√©lectionner des passes d'optimisation bas√©es sur une formation pr√©c√©dente sur l'√©chantillon de donn√©es obtenu.  Dans ce travail, nous avons utilis√© un ensemble de 55 caract√©ristiques pour r√©soudre le probl√®me et un mod√®le assez simple bas√© sur l'id√©e de distribuer de bonnes solutions bas√©es sur l'algorithme K des plus proches voisins.  C'est ce d√©veloppement qui a montr√© que les passes d'optimisation de l'optimisation peuvent conduire √† un code deux fois plus rapide que le code obtenu en utilisant l'option d'optimisation maximale standard -O3. <br><br>  Il existe √©galement des √©tudes de G.Pekhimenko et A.D.  Brown pour TPO d'IBM ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Toronto Portable Optimizer</a> ).  Leur t√¢che principale √©tait de s√©lectionner des valeurs s√©lectionnables heuristiquement pour les optimisations et l'ensemble m√™me des transformations de code.  Pour la mise en ≈ìuvre, une r√©gression logistique a √©t√© utilis√©e, ce qui a permis de d√©finir des amendes efficaces pour une formation plus rapide.  Le classificateur a √©t√© construit dans Matlab.  La probabilit√© d'utilisation a √©t√© calcul√©e pour chaque passage, et elle a √©t√© utilis√©e si elle √©tait sup√©rieure √† 50%.  En raison de la caract√©ristique qu'ils ont essay√© de r√©duire dans cette √©tude, c'√©tait le temps de compilation statique. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">A.Askhari a</a> √©t√© engag√© dans la s√©lection directe des options de compilation pour l'ensemble du programme afin de minimiser le temps d'ex√©cution, le temps de compilation, la taille du code et la consommation d'√©nergie.  Pour cela, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cTuning Framework</a> et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Collective Mind Framework</a> d√©velopp√© par G. Fursin et A. Lokhmotov (√©galement d√©velopp√© sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> ) ont √©t√© utilis√©s. <br><br>  Il y a aussi des √©tudes par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">M. Stephenson et S. Amarasinge sur la</a> s√©lection des optimisations pour certains algorithmes particuli√®rement importants (allocation des registres, PREFETCHING DES DONNEES, FORMATION HYPERBLOC).  Pour chaque fonction, ses propres caract√©ristiques ont √©t√© utilis√©es en cons√©quence.  Pour la solution, un algorithme g√©n√©tique a √©t√© utilis√©.  Le test du produit d√©velopp√© a √©t√© effectu√© par l'Open Research Compiler (ORC). <br><br>  Il existe √©galement un projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MAGEEC</a> (Machine Guided Energy Efficient Compiler) dont les objectifs sont quelque peu diff√©rents.  L'infrastructure d√©velopp√©e utilise l'apprentissage automatique pour s√©lectionner les optimisations n√©cessaires pour g√©n√©rer le code avec une efficacit√© √©nerg√©tique maximale pour les syst√®mes informatiques hautes performances.  MAGEEC est con√ßu pour fonctionner avec gcc et LLVM.  Ce compilateur fait partie du plus grand projet TSERO (Total Software Energy Reporting and Optimization). <br><br>  Une recherche directement li√©e √† LLVM est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LLVMTuner</a> , un produit logiciel d√©velopp√© √† l'Universit√© de l'Illinois par I. Chen et W. Adwe.  En 2017, un rapport a √©t√© pr√©sent√© d√©crivant les r√©sultats disponibles √† l'√©poque.  Dans ce travail, nous avons optimis√© les cycles ¬´chauds¬ª individuels.  Ce cadre est con√ßu pour la configuration automatis√©e de grands programmes.  LLVMTuner s'ex√©cute sur le middleware LLVM IR, utilise le profilage pour identifier les boucles actives, puis ajuste automatiquement l'heuristique √† leur place.  L'accent est mis sur les cycles de niveau sup√©rieur.  Les cycles s√©lectionn√©s et toutes les fonctions d'appel sont transf√©r√©s vers un module s√©par√©, qui est en outre soumis aux optimisations n√©cessaires.  Cette solution vous permet d'obtenir des performances am√©lior√©es sur des programmes volumineux. <br><br><h2>  Probl√®mes existants </h2><br>  Cependant, il n'existe aucun compilateur largement utilis√© qui ajuste ind√©pendamment l'heuristique de l'optimisation des passes.  Quel est le probl√®me?  Comme vous le savez, l'efficacit√© des m√©thodes d'apprentissage automatique et la qualit√© des mod√®les obtenus d√©pendent du choix correct des fonctionnalit√©s et de la qualit√© des donn√©es de formation (malgr√© l'existence d'algorithmes moins sensibles aux donn√©es ¬´bruyantes¬ª).  Sans conna√Ætre la structure et les algorithmes utilis√©s dans le compilateur, il n'est pas facile de s√©lectionner un ensemble complet et suffisant de caract√©ristiques pour la formation, bien qu'il y en ait des assez claires et logiques, par exemple, la taille du cycle, le nombre de sorties du cycle, etc.  Par cons√©quent, il est difficile de d√©velopper une solution universelle adapt√©e √† de nombreux compilateurs √† la fois, et ce n'est pas un fait que cela est g√©n√©ralement possible.  De plus, il est probable que cela ne soit pas n√©cessaire. <br><br>  Le d√©veloppement des compilateurs devant √™tre efficace et r√©alisable dans un d√©lai assez court, il est naturel que m√™me les grandes entreprises d√©veloppent leurs compilateurs industriels √† partir de solutions toutes faites.  La plupart des solutions modernes peuvent √™tre divis√©es en deux cat√©gories: s'ex√©cuter sur des machines virtuelles, par exemple, des compilateurs JVM - JIT et des compilateurs bas√©s sur LLVM, un syst√®me qui impl√©mente une machine virtuelle avec des instructions de type RISC - des compilateurs statiques et dynamiques.  Bien s√ªr, il existe encore des solutions propres aux entreprises, mais elles deviennent moins comp√©titives en raison du manque d'une grande communaut√© impliqu√©e dans le d√©veloppement des technologies qui y sont utilis√©es.  En cons√©quence, de nombreuses grandes entreprises telles que Google, Apple, Adobe et ARM utilisent aujourd'hui LLVM pour d√©velopper leurs propres solutions.  Bien s√ªr, gcc reste le principal compilateur pour C / C ++, d'autres solutions existent pour d'autres langages, mais de toute fa√ßon, si, par exemple, une solution pour LLVM est trouv√©e, elle couvrira d√©j√† une bonne partie des compilateurs existants. <br><br>  La collecte de caract√©ristiques pour la formation devient √©galement un gros probl√®me, car les compilateurs multi-passes transforment fortement la repr√©sentation interm√©diaire, et les caract√©ristiques collect√©es au stade initial ne sont pas tout √† fait pertinentes pour les optimisations ult√©rieures du compilateur, ces caract√©ristiques peuvent changer avec une forte probabilit√©.  Caract√©ristiques, en outre, il est logique de collecter s√©par√©ment pour diff√©rents types d'√©l√©ments: modules, cycles, blocs de base, car les optimisations sont g√©n√©ralement con√ßues pour changer un type particulier d'√©l√©ment, dans LLVM, m√™me selon ce crit√®re, les passages sont divis√©s. <br><br>  Mais, tout d'abord, la question se pose d'identifier les √©l√©ments pour lesquels il est n√©cessaire de collecter des caract√©ristiques.  Il existe de nombreuses fa√ßons de calculer des identifiants uniques qui peuvent √™tre enregistr√©s lors de toutes les optimisations, par exemple: <br><br><ul><li>  Hachage frontal bas√© sur AST </li><li>  num√©ros uniques attribu√©s dans l'analyse frontale </li><li>  Nombre 64 bits g√©n√©r√© sur la base d'arcs dans CFG (graphique de flux de contr√¥le) √† l'aide d'une somme de contr√¥le (similaire √† PGO (optimisation guid√©e par profil) dans LLVM) </li></ul><br>  Cependant, vous devez enregistrer correctement ces identifiants lors des transformations, lorsque les √©l√©ments peuvent fusionner en un, se diviser, en cr√©er de nouveaux et supprimer ceux d'origine, ce qui n'est pas une t√¢che facile. <br><br>  Deuxi√®mement, il est difficile en principe d'√©valuer les limites des cycles source, blocs de base, etc. √©crits dans le code source, sur l'IR d√©j√† converti.  Par exemple, en raison de la g√©n√©ration en plusieurs √©tapes du code machine adopt√©e par LLVM, les informations sur les unit√©s de base de la machine sont perdues apr√®s la g√©n√©ration du code sur la base des instructions machine dans AsmPrinter.  Et en cons√©quence, des informations sur les identifiants des blocs de base et des cycles sont √©galement perdues, pour lesquelles, par exemple, le d√©calage depuis le d√©but de la fonction est mesur√©.Par cons√©quent, avec cette m√©thode, ce n'est qu'au stade de la g√©n√©ration du code machine que le d√©calage peut √™tre obtenu sous la forme du nombre d'octets selon les instructions.  Cependant, aux √©tapes ult√©rieures de la g√©n√©ration de code machine lors de l'utilisation de fragments de machine, divers alignements peuvent y √™tre ajout√©s, ce qui modifie la taille des instructions prises en compte pr√©c√©demment, et des instructions nop sont √©galement ajout√©es.  De ce fait, pour les blocs de base √† la fin de grandes fonctions, l'erreur de calcul peut √™tre tr√®s importante, jusqu'√† un passage complet √† un autre bloc / cycle.  Et bien que certaines des transformations des √©tapes ult√©rieures puissent √™tre suivies et prises en compte, cela ne garantit pas la pr√©cision des mesures, car la taille des instructions peut varier jusqu'√† l'√©diteur de liens. <br><br><img src="https://habrastorage.org/webt/af/xw/2-/afxw2-jziob0rhikr1nqaw_wmai.png"><br><br>  Comme vous pouvez le voir, m√™me la collecte d'attributs sur la base de laquelle une formation est n√©cessaire est assez compliqu√©e et prend du temps, et qui, √† l'avenir, deviendra probablement l'ensemble d'entr√©e pour le mod√®le form√© pour la prise de d√©cision.  Et il n'y a pas de solutions √©videntes √† ces probl√®mes, ce qui complique le travail imm√©diat associ√© √† l'apprentissage automatique et attire un grand nombre de personnes en raison du manque d'ensembles de donn√©es suffisants.  Eh bien, les difficult√©s typiques de trouver des solutions aux probl√®mes d'apprentissage automatique, de choisir des mod√®les, des m√©thodes, de d√©terminer le bon sous-ensemble d'attributs avec un grand nombre d'entre eux, etc.  existent dans ce cas.  Presque tous ceux qui ont rencontr√© l'apprentissage automatique les connaissent et, peut-√™tre, quelque chose d'unique et sp√©cifique pour les compilateurs n'est pas l√†. <br><br>  Il est difficile de pr√©dire quand les compilateurs intelligents se r√©pandront.  Les compilateurs modernes ont √©galement d'autres probl√®mes qui ne seront probablement pas r√©solus par cette m√©thode et qui, √† l'heure actuelle, sont probablement plus prioritaires.  Cependant, les compilateurs sont d√©j√† devenus beaucoup plus intelligents qu'ils ne l'√©taient √† l'aube de leur apparition, et ce processus se poursuivra, bien qu'il puisse √™tre un peu plus lent que la plupart des d√©veloppeurs ne le souhaiteraient. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr450850/">https://habr.com/ru/post/fr450850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr450838/index.html">Pourquoi l'unit√© n'est pas attribu√©e aux nombres premiers et quand elle √©tait g√©n√©ralement consid√©r√©e comme un nombre</a></li>
<li><a href="../fr450840/index.html">La derni√®re lampe de poche est fatigu√©e ou le scintillement sauvera-t-il la Bi√©lorussie (upd. Spinner?)</a></li>
<li><a href="../fr450844/index.html">Introduction √† l'exemple de mappage</a></li>
<li><a href="../fr450846/index.html">Les merveilles de l'emballage de Microsoft: le noyau Linux dans Windows 10 et le moteur IE dans Chromium Edge</a></li>
<li><a href="../fr450848/index.html">√Ä propos du phosphore jaune et de la nature paniqu√©e de l'homme</a></li>
<li><a href="../fr450854/index.html">Exp√©rience dans le d√©veloppement d'un atout Unity pour trouver un chemin dans l'espace 3D</a></li>
<li><a href="../fr450858/index.html">R√©union de r√©seautage Open Source - maintenant dans Yandex.Cloud # 3.2019</a></li>
<li><a href="../fr450860/index.html">Prise intelligente REDMOND SkyPort 100S</a></li>
<li><a href="../fr450862/index.html">@Pythonetc avril 2019</a></li>
<li><a href="../fr450864/index.html">Trucs et astuces de ma cha√Æne Telegram @pythonetc, avril 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>