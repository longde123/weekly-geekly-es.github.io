<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëè üïâÔ∏è üë®‚Äçüë®‚Äçüëß TrustZone: SO confi√°vel e seus aplicativos üëàüèø üë®üèΩ‚Äçüîß üç†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nos artigos anteriores, vimos o dispositivo de hardware TrustZone e a opera√ß√£o do mecanismo Secure Monitor. Hoje vamos nos concentrar no SO confi√°vel ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TrustZone: SO confi√°vel e seus aplicativos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/aladdinrd/blog/428311/">  Nos artigos anteriores, vimos o dispositivo de hardware TrustZone e a opera√ß√£o do mecanismo Secure Monitor.  Hoje vamos nos concentrar no SO confi√°vel (TEE) e em seus aplicativos.  E se da √∫ltima vez houve coisas de n√≠vel bastante baixo, agora tudo estar√° em um n√≠vel muito alto - no n√≠vel do sistema operacional. <a name="habracut"></a><br><br><h2>  O que √© TEE? </h2><br>  O que √© TEE?  Este √© o ambiente de execu√ß√£o confi√°vel (Trusted Execution Environment), em primeiro lugar - este √© o ambiente de execu√ß√£o dos programas.  N√≥s o descrevemos em termos de fun√ß√£o e propriedades, mas n√£o no sentido de programa√ß√£o, mas no sentido filos√≥fico. <br><br>  Por exemplo, um trem de longa dist√¢ncia, trem e t√°xi t√™m uma das fun√ß√µes mais importantes - transportar pessoas.  Mas de acordo com suas propriedades, elas diferem, por exemplo: um trem transporta entre cidades, um trem el√©trico - fora da cidade e um t√°xi - principalmente na cidade.  Treinar e treinar para bilhetes, t√°xi - n√£o.  E assim por diante <br><br>  A fun√ß√£o TEE √© armazenar com seguran√ßa alguns dados para n√≥s e iniciar aplicativos para n√≥s.  Queremos transmitir comandos TEE: inicie tal e qual aplica√ß√£o, pegue esses e tais dados e fa√ßa isso e aquilo com eles.  Ao mesmo tempo, n√£o podemos ver o c√≥digo do aplicativo, nem os dados.  N√≥s apenas obteremos o resultado.  A intera√ß√£o com o TEE √© muito semelhante ao RPC. <br><br>  Essa fun√ß√£o √© ideal para v√°rias criptografia, por exemplo, para assinatura eletr√¥nica: as chaves s√£o armazenadas no TEE, e solicitamos ao TEE que assine os dados transmitidos com uma chave armazenada no TEE.  Obtemos o resultado, mas n√£o temos acesso √† chave. <br><br>  O TEE possui v√°rias propriedades, mas as principais s√£o: a) confiamos em sua implementa√ß√£o eb) √© separado de forma confi√°vel do sistema operacional principal do dispositivo, protegido, √© dif√≠cil de quebrar ou quebrar.  Existem outras propriedades, mas chamamos isso de sistema operacional confi√°vel para isso.  Propriedade b) o mais importante √© que o ETE √© separado e dif√≠cil de quebrar, ou seja, √© protegido. <br><br>  Se voc√™ observar o TEE atrav√©s do prisma de fun√ß√µes e propriedades, fica claro que o TEE n√£o √© nem um pouco sobre TrustZone.  O TrustZone √© uma das maneiras de separar o TEE do sistema operacional principal (convidado). <br><br><h2>  Op√ß√µes de implementa√ß√£o de TEE </h2><br>  Se as principais propriedades do TEE s√£o separadas e dif√≠ceis de serem quebradas, podemos criar op√ß√µes diferentes para implementar o TEE: <br><br><ul><li>  Use o TrustZone - obtemos a separa√ß√£o do TEE e do SO principal no mesmo n√∫cleo do processador. </li><li>  Execute o TEE em um n√∫cleo separado dentro do sistema em um chip e se comunique com ele por meio de uma interface de hardware.  Alguns processadores especializados t√™m n√∫cleos confi√°veis ‚Äã‚Äãseparados para executar o TEE, mas voc√™ tamb√©m n√£o pode compr√°-los na loja.  Mas voc√™ pode pegar um cristal de n√∫cleo duplo, por exemplo, Cortex-A + Cortex-M0 / M4 e execut√°-lo no Cortex-M TEE. </li><li>  Execute o TEE em um chip separado e estabele√ßa uma conex√£o segura com ele por meio de uma interface externa, por exemplo, SPI ou SMbus.  Para proteger a comunica√ß√£o, use m√©todos criptogr√°ficos. <br>  Esse m√©todo √© usado quando voc√™ estabelece uma conex√£o com um cart√£o inteligente, como um cart√£o de pagamento pl√°stico com chip.  Em certo sentido, o TEE √© executado no chip, porque, a nosso pedido, realiza transa√ß√µes financeiras com muita confian√ßa, armazena dados etc. <br>  O mesmo m√©todo √© usado no TPM (Trusted Platform Module) da arquitetura moderna de PC. </li></ul><br>  Falaremos apenas sobre a implementa√ß√£o do TEE no TrustZone, porque esta √© uma vers√£o muito comum da implementa√ß√£o do TEE.  Mas grande parte dos itens acima se aplica ao ETE em geral. <br><br><h2>  TEE como SO </h2><br>  Em artigos anteriores, sempre chamamos o TEE de um sistema operacional confi√°vel e dizemos que ele √© muito parecido com sistemas operacionais reais. <br><br>  Sem pretender ser geral, dizemos que a maior parte dos ETE tem: <br><ul><li> aplicativos e processos: o TEE pode baixar aplicativos e execut√°-los; </li><li>  separa√ß√£o de processo e mem√≥ria do kernel: usada pela MMU para proteger o espa√ßo da mem√≥ria do processo e para proteger a mem√≥ria principal do TEE; </li><li>  threads, intera√ß√µes de processos; </li><li>  armazenamento de dados. </li></ul><br>  Voc√™ pode criar vers√µes mais truncadas do TEE, por exemplo, sem carregamento din√¢mico de aplicativo, sem intera√ß√£o do processo, sem encadeamentos, mas os aplicativos em si, armazenamento de dados e separa√ß√£o da mem√≥ria do processo e do espa√ßo do kernel permanecer√£o. <div class="spoiler">  <b class="spoiler_title">Texto oculto</b> <div class="spoiler_text">  Um exemplo de TEE truncado pode ser visto agora no projeto ARM Trusted Firmware-M para a nova gera√ß√£o de microcontroladores Cortex-M na plataforma ARMv8-M.  Este √© um TEE simplificado, agora h√° suporte para microcontroladores nos n√∫cleos Cortex-M23 e Cortex-M33.  Estes s√£o microcontroladores baseados em flash, aproximadamente equivalentes ao Cortex-M0 e Cortex-M3, mas com suporte da TrustZone.  Eles t√™m pouca RAM, o programa √© executado principalmente a partir do Flash e, portanto, no TEE n√£o h√° carregamento din√¢mico de programas.  No momento, o TF-M tamb√©m √© de rosca √∫nica. <br></div></div><br><h2>  Interface de software TEE </h2><br>  Para interagir com outros componentes de software, o TEE possui uma API: <br><br><ul><li>  O TEE fornece uma API para programas por meio de chamadas do sistema (Supervisor Call, comando SVC); </li><li>  O TEE fornece a API para o mundo normal por meio de chamadas para o Secure Monitor (comando SMC). </li></ul><br>  Atrav√©s de chamadas do sistema, os programas salvam dados e chamam as fun√ß√µes do SO.  Como qualquer sistema operacional decente, o TEE tenta abstrair programas de hardware em um grau ou outro. <br>  Por exemplo, os resumos do Linux funcionam com arquivos por meio de chamadas de abertura, leitura, grava√ß√£o e fechamento - todas as fun√ß√µes do stdio recaem basicamente nas chamadas do sistema OS.  E o TEE tamb√©m permite que seus aplicativos trabalhem com dados armazenados por meio de chamadas que abstraem armazenam e carregam objetos (blocos de dados) no armazenamento.  O TEE tamb√©m pode fornecer algumas fun√ß√µes criptogr√°ficas no n√≠vel do sistema, etc. <br><br>  H√° um conjunto de especifica√ß√µes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GlobalPlatform</a> para TEE, que descrevem APIs, requisitos, cen√°rios de uso etc. <br>  As principais APIs do TEE para seus programas s√£o descritas na Especifica√ß√£o interna da API do TEE.  Ele descreve fun√ß√µes de armazenamento de dados, fun√ß√µes criptogr√°ficas, etc. E a "API do cliente TEE" descreve como chamar aplicativos do Mundo Normal. <br><br>  Se o seu TEE implementar essas APIs, escrever um aplicativo para ele ser√° bastante f√°cil.  Gra√ßas a uma API, a portabilidade dos programas tamb√©m √© implementada. <br><br><h2>  Diferen√ßas entre o TEE e o SO normal </h2><br>  As duas principais diferen√ßas entre o TEE e o Linux e outros sistemas operacionais comuns que nos s√£o familiares s√£o: <br><br><ol><li>  O TEE executa a√ß√µes n√£o no comando do usu√°rio, mas no comando do Mundo Normal; </li><li>  O TEE no TrustZone n√£o possui seu pr√≥prio agendador. </li></ol><br>  Em um sistema operacional normal, o usu√°rio gera alguns comandos de entrada de entrada, clica nos √≠cones e o sistema operacional processa essa entrada, a transfere para programas e os programas s√£o processados.  Na vers√£o do servidor, a entrada n√£o vem do usu√°rio, mas de certos clientes, provavelmente pela rede.  Mas o sistema operacional, no entanto, atua com base em informa√ß√µes externas. <br><br>  O TEE n√£o processa dados externos nem os transfere para aplicativos.  Em vez disso, processa os comandos e dados transmitidos do Normal World por meio da API do cliente TEE, e isso √© quase tudo.  Acontece que o TEE atua no sistema operacional como uma biblioteca com uma interface RPC, cujas fun√ß√µes s√£o chamadas.  Ap√≥s o processamento das fun√ß√µes, o TEE pode n√£o fazer nada. <br><br>  A segunda diferen√ßa segue da primeira.  O TEE do administrador compartilha o tempo da CPU com o Normal World e √© chamado como uma biblioteca.  O TEE n√£o aloca constantemente o tempo do processador, gasta o tempo necess√°rio para concluir a solicita√ß√£o e depois transfere o controle para o Mundo Normal.  E, nesse caso, ela n√£o deve ter seu pr√≥prio agendador - ela precisa de um agendador de sistema operacional convidado. <br><br>  O agendador principal do SO transfere o controle para o TEE indiretamente: <br><br><ul><li>  o planejador define a tarefa a ser conclu√≠da; </li><li>  a tarefa chama a chamada de sistema do kernel; </li><li>  uma chamada do sistema chama TEE, se necess√°rio; </li><li>  O TEE trabalha o tempo necess√°rio para concluir a solicita√ß√£o e retorna o controle ao Mundo Normal. </li></ul><br><h2>  Aplica√ß√µes TEE </h2><br>  Os aplicativos em execu√ß√£o no TEE s√£o chamados de trustlets - semelhantes aos applets executados em cart√µes inteligentes. <br>  Cita√ß√£o da Wikipedia: <br><blockquote>  Applet (Eng. Applet do aplicativo - application e -let - diminuto sufixo) √© um componente de software independente que trabalha no contexto de outro aplicativo com peso total, projetado para uma tarefa restrita e sem valor isolado do aplicativo base. </blockquote><br>  Trustlet √© um Applet Confi√°vel.  Este √© um programa para o ETE, como j√° descobrimos, ele se comunica com o ETE atrav√©s de chamadas do sistema, possui um ciclo de vida, etc. <br><br>  Mas, ainda assim, o nome indica que √© um componente n√£o independente.  Aqui, a independ√™ncia √© expressa no fato de que o trustlet far√° chamadas do Mundo Normal e depois ser√° desconectado junto com o TEE.  Se girar em um loop infinito, o n√∫cleo do processador deixar√° de funcionar como um sistema operacional e tudo acabar√° travando.  Mas o programa para um sistema operacional normal pode girar em um loop sem fim e o meu para contar algumas tarefas, isso √© completamente normal para o programa.  A este respeito, √© independente do trustlet. <br><br>  O trustlet deve ter algum tipo de identificador para que o Mundo Normal possa cham√°-lo.  √â habitual fornecer trustlets como UUIDs - identificadores exclusivos. <br><br><h2>  Ciclo de vida do Trustlet </h2><br>  Considere como o trastlet √© iniciado e os comandos s√£o executados. <br><br>  Seria l√≥gico carregar o trustlet na mem√≥ria e come√ßar a trabalhar, mas na API do cliente GlobalPlatform TEE, para iniciar o trustlet, √© necess√°rio criar um contexto e estabelecer uma sess√£o com o trustlet. <br><br>  Criar um contexto √© o estabelecimento de uma conex√£o entre o Mundo Normal e o TEE.  Nesse caso, a especifica√ß√£o GlobalPlatform sup√µe que o dispositivo possa ter v√°rias TEEs e, no momento da cria√ß√£o do contexto, voc√™ pode escolher qual TEE entrar em contato. <br><br>  Na API do cliente GlobalPlatform TEE, uma fun√ß√£o √© fornecida para isso: <br><br><pre> TEEC_Result TEEC_InitializeContext (const char * name, contexto TEEC_Context *)
</pre><br>  Essa fun√ß√£o √© chamada do aplicativo Mundo Normal.  Aqui o nome indica o TEE selecion√°vel.  Se queremos o TEE por padr√£o ou temos certeza de que temos apenas um TEE, substitu√≠mos NULL.  No contexto, o contexto criado √© salvo. <br><br>  Depois de criar o contexto, voc√™ precisa estabelecer uma sess√£o com a confian√ßa.  Aqui, o UUID do trustlet √© √∫til para n√≥s.  Para fazer isso, a fun√ß√£o √© chamada: <br><br><pre> TEEC_Result TEEC_OpenSession (
	 Contexto TEEC_Context *, sess√£o TEEC_Session *,
	 const TEEC_UUID * destino, uint32_t connectionMethod,
	 const void * connectionData, opera√ß√£o TEEC_Operation *,
	 uint32_t * returnOrigin)
</pre><br>  Uma sess√£o √© equivalente a trabalhar com uma inst√¢ncia de programa em um sistema operacional regular: pode haver muitas inst√¢ncias do mesmo programa no sistema operacional e elas funcionar√£o independentemente.  Mas h√° muitas sess√µes no TEE e, em ess√™ncia, essas s√£o conex√µes com inst√¢ncias exclusivas do trustlet na mem√≥ria.  Nesse caso, a √°rea de c√≥digo provavelmente ser√° a mesma, mapeada via MMU para a mem√≥ria de diferentes processos.  Mas cada processo ter√° sua pr√≥pria √°rea de dados, permitindo que as inst√¢ncias funcionem independentemente.  Assim como no Linux. <br><br>  Quando TEEC_OpenSession √© chamado, o contexto e o UUID da confian√ßa de destino s√£o transmitidos como entrada.  A sess√£o estabelecida ser√° salva em "sess√£o".  Alguns par√¢metros a seguir n√£o ser√£o considerados, eles n√£o s√£o t√£o importantes para a compreens√£o. <br><br>  No momento em que a sess√£o √© criada, o trustlet pode ser carregado na mem√≥ria.  √â o que acontece com os aplicativos no sistema operacional.  No TEE grande, o vinculador √© respons√°vel por isso, faz o download da imagem bin√°ria do trustlet, esse √© um arquivo ELF assinado.  Se for um TEE pequeno, o trustlet j√° dever√° estar carregado na mem√≥ria - ele pode ser vinculado estaticamente ou, para microcontroladores flash, gravado na mem√≥ria flash no endere√ßo especificado. <br><br>  Vamos supor que temos um TEE grande e precisamos carregar o trustlet na mem√≥ria.  De onde ele veio?  Em princ√≠pio, o TEE no momento do carregamento precisa de um objeto com um determinado UUID, e o mecanismo para obter esse objeto pode ser qualquer: <br><br><ul><li>  o objeto j√° pode estar na mem√≥ria; </li><li>  o objeto pode ser colocado estaticamente na mem√≥ria flash (para microcontroladores flash); </li><li>  o objeto pode ser vinculado estaticamente ao TEE - para trustlets do sistema; </li><li>  finalmente, voc√™ pode fazer o download do arquivo para a RAM do sistema de arquivos ou mesmo pela rede. </li></ul><br>  Pergunte a si mesmo mais tarde, como esse TEE baixa dados de um sistema de arquivos ou de uma rede? !!! <br><br>  Depois de baixar a imagem do trustlet, sua assinatura digital √© verificada.  Um sistema de certifica√ß√£o √© usado e o TEE verificar√° se a confian√ßa √© assinada por uma parte em que o TEE confia.  Isso √© muito importante porque elimina a possibilidade de baixar um trustlet falsificado com algum malware. <br><br>  Quando a imagem do trustlet √© recebida e a assinatura √© verificada, o TEE cria o espa√ßo de endere√ßo para a inst√¢ncia do trustlet na MMU e o vinculador carrega a √°rea de c√≥digo na mem√≥ria, mapeia-a para o espa√ßo de endere√ßo do trustlet e inicializa a √°rea de dados.  O resultado √© uma inst√¢ncia totalmente inicializada do trustlet para trabalhar com o aplicativo de chamada espec√≠fico - essa √© a cria√ß√£o da sess√£o. <br><br>  Depois que a sess√£o √© criada, o trustlet fica pronto e pode executar solicita√ß√µes do aplicativo de chamada.  Para chamar as fun√ß√µes de confian√ßa do sistema operacional, a fun√ß√£o √© usada: <br><br><pre> TEEC_Result TEEC_InvokeCommand (
	 Sess√£o TEEC_Session *,
	 uint32_t commandID,
	 Opera√ß√£o TEEC_Operation *,
	 uint32_t * returnOrigin) 
</pre><br>  Aqui, "session" indica nossa sess√£o, ou seja, a inst√¢ncia TEE e a inst√¢ncia de trustlet com a qual estamos trabalhando. <br><br>  "CommandID" indica a fun√ß√£o chamada do trustlet.  Esta √© a fun√ß√£o trustlet, n√£o a fun√ß√£o TEE.  Tudo que o TEE se importa √© iniciar o trustlet e enviar comandos, e quais os n√∫meros de ID do comando a serem atribu√≠dos para se comunicar com o trustlet s√£o com voc√™, n√£o h√° regra ou lista global de fun√ß√µes. <br><br>  Se voc√™ precisar passar par√¢metros para a fun√ß√£o chamada, eles ser√£o passados ‚Äã‚Äãpela opera√ß√£o - este √© um ponteiro para a estrutura TEEC_Operation.  Agora n√£o entraremos em detalhes demais, apenas observe que essa estrutura cont√©m at√© 4 par√¢metros de fun√ß√£o (tipo TEEC_Parameter).  Os par√¢metros podem ser um simples TEEC_Value ou um ponteiro para a mem√≥ria.  Os par√¢metros tamb√©m t√™m tipifica√ß√£o na dire√ß√£o: TEEC_VALUE_INPUT (entrada), TEEC_VALUE_OUTPUT (sa√≠da) ou TEEC_VALUE_INOUT (bidirecional). <br><br>  Se passarmos um ponteiro para a estrutura TEEC_Operation, devemos primeiro inicializ√°-lo: defina todos os valores e dire√ß√µes.  Ap√≥s a conclus√£o da chamada, podemos verificar os valores retornados nesta estrutura (para TEEC_VALUE_OUTPUT e TEEC_VALUE_INOUT). <br><br>  Durante a sess√£o, podemos chamar as fun√ß√µes do trustlet quantas vezes for necess√°rio.  No final do trabalho, voc√™ precisar√° finalizar a sess√£o e liberar o contexto chamando TEEC_CloseSession e TEEC_FinalizeContext. <br><br>  Tudo isso lembra muito o RPC, certo?  Em princ√≠pio, todas as opera√ß√µes com o TEE s√£o projetadas como RPC e, gra√ßas a isso, voc√™ pode trabalhar com uma variedade de implementa√ß√µes do TEE: no TrustZone, em um n√∫cleo separado, em um chip separado. <br><br><h2>  Suplicante </h2><br>  Acima, nos perguntamos: como o TEE baixa dados de um sistema de arquivos ou de uma rede? <br>  Se voc√™ pensar bem, o pr√≥prio TEE n√£o ter√° acesso ao sistema de arquivos do SO.  Ou seja, o TEE implementado no TrustZone poderia ter esse acesso, mas seria necess√°rio compartilh√°-lo com o Normal World, e isso n√£o √© t√£o simples.  Por exemplo, o Linux trabalha constantemente com o sistema de arquivos, e seu estado atual est√° apenas na mem√≥ria do kernel do Linux, e n√£o no disco.  Se o TEE quiser intervir e trabalhar com o sistema de arquivos em paralelo, ser√° muito dif√≠cil.  Com a rede compartilhando o mesmo. <br><br>  Al√©m disso, o TEE √© um sistema operacional bastante pequeno e n√£o seria lucrativo implementar drivers de baixo n√≠vel para trabalhar com m√≠dia, com um controlador de rede e dar suporte a uma pilha de rede ou driver FS.  Al√©m disso, isso aumenta muito a superf√≠cie de ataque - haveria uma chance de quebrar o TEE ao deslizar um inode incomum no ext2 ou algo parecido.  N√≥s n√£o queremos isso. <br>  Portanto, quando o sistema operacional √© iniciado, o suplicante √© carregado - um programa assistente.  Ele est√° sempre conectado ao TEE, e o TEE o utiliza para acessar os recursos do Mundo Normal. <br><br>  Portanto, se o TEE desejar fazer o download da imagem do trustlet do sistema de arquivos, ele chamar√° Suplicante: <br><br>  <i>TEE: E quanto a um objeto com esse UUID?</i> <i><br></i>  <i>Requerente: (Carrega um objeto do sistema de arquivos) Desculpe, senhor!</i> <br><br>  Obviamente, essas chamadas devem ser verificadas quanto √† seguran√ßa.  Nesse caso, verificamos a assinatura no trustlet e n√£o assumimos quase nenhum risco - a assinatura est√° correta e o trustlet vai funcionar ou a assinatura est√° incorreta.  Ou seja, corremos o risco - pode n√£o haver um trustlet, o suplicante pode n√£o ser iniciado, mas essa √© outra parte do modelo de amea√ßa. <br><br><h2>  Biblioteca do espa√ßo do usu√°rio </h2><br>  A interface do programa (chamadas para TEEC_OpenSession, etc.) √© implementada usando uma biblioteca que transmite uma chamada do n√≠vel do aplicativo para o TEE. <br><br>  Ao implementar o TEE no TrustZone, para isso, a biblioteca deve primeiro transferir a chamada para o n√≠vel do kernel do SO, pois somente o kernel do SO pode chamar SMC (Secure Monitor Call). <br>  No pacote configur√°vel Linux + OP-TEE, a biblioteca userspace √© libteec.  Ele converte as chamadas da API do cliente GlobalPlatform TEE para o driver do kernel atrav√©s de opera√ß√µes ioctl no arquivo do dispositivo: quando o sistema operacional √© iniciado, o m√≥dulo do kernel (driver) √© carregado, o driver cria o arquivo do dispositivo.  Ao abrir o arquivo do dispositivo com libteec, o programa do usu√°rio pode trabalhar com a API do cliente TEE. <br><br>  Ou seja, esse design funciona: <br><blockquote>  <b>Aplicativo&gt; libteec&gt; arquivo de dispositivo&gt; driver do kernel&gt; SMC&gt; TEE&gt; trust.</b> </blockquote><br><h2>  Um exemplo de um trustlet </h2><br>  Veja como funciona em um aplicativo real: <br><img src="https://habrastorage.org/webt/td/yg/s6/tdygs6hnze62ralshuabjivepr4.png" alt="imagem"><br>  Aqui, o trustlet √© usado para assinar documentos eletronicamente.  Um programa do Linux chama o trustlet, para o qual √© criado um contexto TEE, uma sess√£o com o trustlet, os dados para assinatura s√£o transmitidos e a assinatura eletr√¥nica √© retornada. <br><br><h2>  Conclus√£o </h2><br>  Neste artigo, descobrimos o que s√£o TEE e trustlets.  N√≥s nos encontramos com a API do TEE e aprendemos como os trustlets s√£o chamados. <br><br>  Deixamos de lado muitas coisas deliberadamente, como o uso de Mem√≥ria compartilhada e a escrita de trastlets, porque o artigo n√£o pretende ser um guia completo. <br><br>  Se voc√™ est√° interessado no t√≥pico do TEE, continue estudando por conta pr√≥pria: pode come√ßar estudando as especifica√ß√µes do GlobalPlatform ou explorando o OP-TEE.  Voc√™ tamb√©m pode nos enviar um curr√≠culo marcado como "TrustZone". </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428311/">https://habr.com/ru/post/pt428311/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428299/index.html">Mensageiros vs redes sociais vs ... - Continua√ß√£o</a></li>
<li><a href="../pt428301/index.html">Kaspersky Start Russia: competi√ß√£o de projetos do futuro</a></li>
<li><a href="../pt428303/index.html">Um dia na vida de um engenheiro de sistemas</a></li>
<li><a href="../pt428305/index.html">Voce estuda ingles Quadrinhos para o resgate</a></li>
<li><a href="../pt428307/index.html">Desafiantes Java # 1: Sobrecarga de m√©todo na JVM</a></li>
<li><a href="../pt428313/index.html">O telegrama no MacOS [presumivelmente] tamb√©m armazena correspond√™ncia localmente de forma acess√≠vel</a></li>
<li><a href="../pt428315/index.html">5 medos de desenvolvedores que superamos</a></li>
<li><a href="../pt428317/index.html">Reagir ganchos - ganhar ou perder?</a></li>
<li><a href="../pt428321/index.html">An√°lise preditiva de dados - modelagem e valida√ß√£o</a></li>
<li><a href="../pt428327/index.html">O que procurar: Regulamento Europeu de Identifica√ß√£o Eletr√¥nica eIDAS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>