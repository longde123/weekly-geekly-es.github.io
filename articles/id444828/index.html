<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤼 ⚔️ 🙅 Penjelasan sederhana tentang algoritma pencarian jalur dan A * 🎀 🌒 😺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian 1. Algoritma pencarian umum 
 Pendahuluan 
 Menemukan jalan adalah salah satu topik yang biasanya paling sulit bagi pengembang game. Terutama o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penjelasan sederhana tentang algoritma pencarian jalur dan A *</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444828/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/iz/nb/pbiznbkynw8pju8unbz6xyqnqqq.gif" alt="gambar"></div><br><h2>  Bagian 1. Algoritma pencarian umum </h2><br><h2>  Pendahuluan </h2><br>  Menemukan jalan adalah salah satu topik yang biasanya paling sulit bagi pengembang game.  Terutama orang-orang miskin memahami algoritma <strong>A *</strong> , dan banyak yang berpikir bahwa ini adalah semacam sihir yang tidak dapat dipahami. <br><br>  Tujuan artikel ini adalah untuk menjelaskan pencarian jalur secara umum dan <strong>A *</strong> khususnya dengan cara yang sangat mudah dipahami dan dapat diakses, sehingga mengakhiri kesalahpahaman yang tersebar luas bahwa topik ini kompleks.  Dengan penjelasan yang tepat, semuanya cukup sederhana. <br><br>  Harap perhatikan bahwa dalam artikel ini kami akan mempertimbangkan pencarian cara <em>untuk game</em> ;  tidak seperti artikel akademis lainnya, kami akan menghilangkan algoritma pencarian seperti Kedalaman-Pertama atau Luas-Pertama.  Sebagai gantinya, kami akan mencoba untuk beralih dari nol ke <strong>A *</strong> secepat mungkin. <br><a name="habracut"></a><br>  Pada bagian pertama kami akan menjelaskan konsep paling sederhana untuk menemukan jalan.  Dengan memahami konsep-konsep dasar ini, Anda akan menyadari bahwa <strong>A *</strong> ternyata sangat jelas. <br><br><h2>  Sirkuit sederhana </h2><br>  Meskipun Anda dapat menerapkan konsep-konsep ini ke lingkungan 3D kompleks yang arbitrer, mari kita mulai dengan skema yang sangat sederhana: kotak persegi 5 x 5. Untuk kenyamanan, saya menandai setiap sel dengan huruf besar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2d/66c/ed8/e2d66ced82a4c1d4ed739583bd782245.png"></div><br>  <i>Jaring sederhana.</i> <br><br>  Hal pertama yang akan kita lakukan adalah membayangkan lingkungan ini sebagai grafik.  Saya tidak akan menjelaskan secara rinci apa itu grafik;  sederhananya, ini adalah satu set lingkaran yang terhubung dengan panah.  Lingkaran disebut <em>"knot,"</em> dan panah <em>disebut "ujung</em> . <em>"</em> <br><br>  Setiap node mewakili <em>"keadaan"</em> di mana karakter mungkin.  Dalam kasus kami, status karakter adalah posisinya, jadi kami membuat satu simpul untuk setiap sel kisi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68a/d4b/4db/68ad4b4db470c1ce34434e6489a5a986.png"></div><br>  <i>Node mewakili sel kisi.</i> <br><br>  Sekarang tambahkan tulang rusuk.  Mereka menunjukkan negara-negara yang dapat <em>"dijangkau"</em> dari masing-masing negara;  dalam kasus kami, kami dapat beralih dari sel mana saja ke sel berikutnya, kecuali yang diblokir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f73/56c/9be/f7356c9be0171d61c31e3e4c21bf9385.png"></div><br>  <i>Busur menunjukkan gerakan yang diizinkan antara sel-sel kotak.</i> <br><br>  Jika kita dapat berpindah dari <strong>A</strong> ke <strong>B</strong> , maka kita mengatakan bahwa <strong>B</strong> adalah <em>"tetangga"</em> ke simpul <strong>A.</strong> <br><br>  Perlu dicatat bahwa tulang rusuk memiliki <em>arah</em> ;  kita membutuhkan tepian dari <strong>A</strong> ke <strong>B</strong> , dan dari <strong>B</strong> ke <strong>A.</strong>  Ini mungkin tampak berlebihan, tetapi tidak ketika “kondisi” yang lebih kompleks mungkin muncul.  Misalnya, karakter dapat jatuh dari atap ke lantai, tetapi tidak dapat melompat dari lantai ke atap.  Anda bisa beralih dari keadaan "hidup" ke keadaan "mati", tetapi tidak sebaliknya.  Dan sebagainya. <br><br><h2>  Contoh </h2><br>  Misalkan kita ingin pindah dari <strong>A</strong> ke <strong>T.</strong>  Kita mulai dengan <strong>A.</strong>  Anda dapat melakukan dua tindakan tepat: pergi ke <strong>B</strong> atau pergi ke <strong>F.</strong> <br><br>  Katakanlah kita pindah ke <strong>B.</strong>  Sekarang kita dapat melakukan dua hal: kembali ke <strong>A</strong> atau pergi ke <strong>C.</strong>  Kami ingat bahwa kami sudah berada di <strong>A</strong> dan mempertimbangkan opsi di sana, jadi tidak masuk akal untuk melakukannya lagi (kalau tidak kita bisa menghabiskan sepanjang hari bergerak <strong>A</strong> → <strong>B</strong> → <strong>A</strong> → <strong>B</strong> ...).  Karena itu kita akan pergi ke <strong>C.</strong> <br><br>  Berada di <strong>C</strong> , kita tidak punya tempat untuk bergerak.  Kembali ke <strong>B tidak</strong> ada gunanya, yaitu jalan buntu.  Memilih transisi ke <strong>B</strong> ketika kami berada di <strong>A</strong> adalah ide yang buruk;  mungkin Anda harus mencoba <strong>F</strong> sebagai gantinya? <br><br>  Kami terus mengulangi proses ini sampai kami berakhir di <strong>T.</strong>  Saat ini, kami cukup membuat ulang jalur dari <strong>A</strong> , kembali ke langkah kami.  Kami berada di <strong>T</strong> ;  bagaimana kita sampai di sana?  Dari <strong>o</strong> ?  Artinya, ujung jalan memiliki bentuk <strong>O</strong> → <strong>T.</strong>  Bagaimana kami bisa sampai ke <strong>O</strong> ?  Dan sebagainya. <br><br>  Ingatlah bahwa kita tidak benar <em>-</em> benar <em>bergerak</em> ;  semua ini hanyalah proses berpikir.  Kami terus berdiri di <strong>A</strong> , dan kami tidak akan keluar dari sana sampai kami menemukan seluruh jalan.  Ketika saya mengatakan "pindah ke <strong>B</strong> ", maksud saya "bayangkan bahwa kita pindah ke <strong>B</strong> ". <br><br><h2>  Algoritma umum </h2><br>  <strong>Bagian ini adalah bagian terpenting dari keseluruhan artikel</strong> .  Anda benar <em>-</em> benar <em>harus</em> memahaminya untuk dapat mewujudkan pencarian jalan;  sisanya (termasuk <strong>A *</strong> ) hanyalah detail.  Di bagian ini, Anda akan mengerti sampai Anda <em>mengerti artinya</em> . <br><br>  Selain itu, bagian ini sangat sederhana. <br><br>  Mari kita coba memformalkan contoh kita, mengubahnya menjadi kode semu. <br><br>  Kita perlu melacak titik-titik yang kita tahu bagaimana mencapainya dari simpul awal.  Pada awalnya, ini hanya simpul awal, tetapi dalam proses "menjelajahi" grid kita akan belajar bagaimana untuk sampai ke node lain.  Sebut saja daftar node yang <code>reachable</code> : <br><br><pre> <code class="python hljs">reachable = [start_node]</code> </pre> <br>  Kita juga perlu melacak node yang sudah ditinjau agar tidak mempertimbangkannya lagi.  <code>explored</code> mereka yang <code>explored</code> : <br><br><pre> <code class="python hljs">explored = []</code> </pre> <br>  <strong>Selanjutnya, saya akan menguraikan inti dari algoritma</strong> : pada setiap langkah pencarian, kami memilih salah satu node yang kami tahu cara menjangkau dan melihat node baru yang bisa kami dapatkan dari itu.  Jika kita menentukan bagaimana mencapai simpul (target) akhir, maka masalahnya terpecahkan!  Kalau tidak, kami akan melanjutkan pencarian. <br><br>  Sangat sederhana, apa yang bahkan mengecewakan?  Dan ini benar.  Tapi ini keseluruhan algoritma.  Mari kita menuliskannya langkah demi langkah dengan pseudo-code. <br><br>  Kami terus mencari hingga kami sampai ke simpul akhir (dalam hal ini, kami menemukan jalur dari awal ke simpul terakhir), atau sampai kami kehabisan simpul tempat Anda dapat mencari (dalam hal ini, tidak ada jalan antara simpul awal dan akhir) . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty:</code> </pre> <br>  Kami memilih salah satu simpul yang kami tahu cara mendapatkannya, dan yang belum diselidiki: <br><br><pre> <code class="python hljs"> node = choose_node(reachable)</code> </pre> <br>  Jika kita baru belajar cara mencapai simpul akhir, maka tugasnya selesai!  Kita hanya perlu membangun jalur dengan mengikuti tautan <code>previous</code> kembali ke simpul awal: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == goal_node: path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(node) node = node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  Tidak masuk akal untuk memeriksa node lebih dari sekali, jadi kami akan melacak ini: <br><br><pre> <code class="python hljs"> reachable.remove(node) explored.add(node)</code> </pre> <br>  Kami mengidentifikasi node yang tidak dapat kami jangkau dari sini.  Kita mulai dengan daftar node yang berdekatan dengan yang sekarang dan menghapus yang sudah kita periksa: <br><br><pre> <code class="python hljs"> new_reachable = get_adjacent_nodes(node) - explored</code> </pre> <br>  Kami mengambil masing-masing: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_reachable:</code> </pre> <br>  Jika kita sudah tahu cara mencapai node, abaikan saja.  Jika tidak, tambahkan ke daftar yang <code>reachable</code> , lacak bagaimana ia masuk ke dalamnya: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: adjacent.previous = node <span class="hljs-comment"><span class="hljs-comment"># Remember how we got there. reachable.add(adjacent)</span></span></code> </pre> <br>  Menemukan simpul akhir adalah salah satu cara untuk keluar dari loop.  Yang kedua adalah ketika <code>reachable</code> menjadi kosong: kami telah kehabisan node yang dapat dieksplorasi, dan kami belum mencapai simpul akhir, yaitu, tidak ada jalan dari awal ke simpul akhir: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Dan ... itu dia.  Ini adalah keseluruhan algoritme, dan kode konstruksi jalur dialokasikan dalam metode terpisah: <br><br><pre> <code class="python hljs">function find_path (start_node, end_node): reachable = [start_node] explored = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: <span class="hljs-comment"><span class="hljs-comment"># Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don't repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: if adjacent not in reachable adjacent.previous = node # Remember how we got there. reachable.add(adjacent) # If we get here, no path was found :( return None</span></span></code> </pre> <br>  Berikut adalah fungsi yang membangun jalur, mengikuti tautan <code>previous</code> kembali ke simpul awal: <br><br><pre> <code class="python hljs">function build_path (to_node): path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(to_node) to_node = to_node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  Itu saja.  <em>Ini adalah</em> pseudocode dari <em>setiap</em> algoritma pencarian jalur, termasuk <strong>A *</strong> . <br><br>  Baca kembali bagian ini hingga Anda memahami cara kerja semuanya, dan, yang lebih penting, <em>mengapa</em> semuanya bekerja.  Akan ideal untuk mengambil contoh dengan tangan di atas kertas, tetapi Anda juga dapat menonton demo interaktif: <br><br><h2>  Demo interaktif </h2><br>  Berikut ini adalah demo dan contoh implementasi algoritma yang ditunjukkan di atas (Anda dapat menjalankannya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman artikel asli</a> ).  <code>choose_node</code> hanya memilih simpul acak.  Anda dapat memulai algoritme langkah demi langkah dan melihat daftar <code>explored</code> <code>reachable</code> dan <code>explored</code> , serta ke mana tautan <code>previous</code> mengarah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vt/jk/cb/vtjkcb4tflduq7zu5p-oph2i73s.gif"></div><br>  Perhatikan bahwa pencarian berakhir segera setelah jalur terdeteksi;  mungkin saja beberapa node bahkan tidak dipertimbangkan. <br><br><h2>  Kesimpulan </h2><br>  Algoritma yang disajikan di sini adalah algoritma umum untuk <em>semua</em> algoritma pencarian jalur. <br><br>  Tapi apa yang membedakan masing-masing algoritma dari yang lain, mengapa <strong>A *</strong> adalah <strong>A *</strong> ? <br><br>  Berikut ini tip: jika Anda menjalankan pencarian di demo beberapa kali, Anda akan melihat bahwa algoritma tersebut tidak selalu selalu menemukan jalur yang sama.  Dia menemukan jalan, dan jalan ini belum tentu yang <em>terpendek</em> .  Mengapa <br><br><h2>  Bagian 2. Strategi Pencarian </h2><br>  Jika Anda tidak sepenuhnya memahami algoritma yang dijelaskan di bagian sebelumnya, maka kembalilah ke sana dan baca lagi, karena itu perlu untuk memahami informasi lebih lanjut.  Ketika Anda mengetahuinya, <strong>A *</strong> akan tampak sepenuhnya alami dan logis bagi Anda. <br><br><h2>  Bahan rahasia </h2><br>  Di akhir bagian sebelumnya, saya membiarkan dua pertanyaan terbuka: jika setiap algoritma pencarian menggunakan kode yang sama, mengapa <strong>A *</strong> berperilaku seperti <strong>A *</strong> ?  Dan mengapa demo terkadang menemukan jalur yang berbeda? <br><br>  Jawaban untuk kedua pertanyaan terkait satu sama lain.  Meskipun algoritme didefinisikan dengan baik, saya meninggalkan satu aspek yang belum terpecahkan, dan ternyata, itu adalah kunci untuk menjelaskan perilaku algoritma pencarian: <br><br><pre> <code class="python hljs">node = choose_node(reachable)</code> </pre> <br>  Ini adalah string yang terlihat polos yang membedakan semua algoritma pencarian dari satu sama lain.  <code>choose_node</code> tergantung pada metode implementasi <code>choose_node</code> . <br><br>  Jadi mengapa demo menemukan jalur yang berbeda?  Karena metode <code>choose_node</code> memilih sebuah node secara acak. <br><br><h2>  Masalah panjang </h2><br>  Sebelum menyelam ke perbedaan dalam perilaku fungsi fungsi <code>choose_node</code> , kita perlu memperbaiki kesalahan kecil dalam algoritma yang dijelaskan di atas. <br><br>  Ketika kami mempertimbangkan node yang berdekatan dengan arus, kami mengabaikan mereka yang sudah tahu cara mencapai: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: adjacent.previous = node <span class="hljs-comment"><span class="hljs-comment"># Remember how we got there. reachable.add(adjacent)</span></span></code> </pre> <br>  Ini adalah kesalahan: bagaimana jika kita baru saja menemukan cara <em>terbaik</em> untuk mencapainya?  Dalam hal ini, perlu untuk mengubah tautan simpul <code>previous</code> untuk mencerminkan jalur yang lebih pendek ini. <br><br>  Untuk melakukan ini, kita perlu mengetahui panjang jalur dari titik awal ke titik mana pun yang dapat dijangkau.  Kami akan menyebut ini biaya jalan.  Untuk saat ini, kami mengasumsikan bahwa berpindah dari satu node ke salah satu node yang berdekatan memiliki biaya konstan <code>1</code> . <br><br>  Sebelum memulai pencarian, kami menetapkan nilai <code>cost</code> setiap node hingga <code>infinity</code> ;  berkat ini, jalan <em>apa pun</em> akan lebih pendek dari ini.  Kami juga akan menetapkan <code>cost</code> simpul <code>start_node</code> menjadi <code>0</code> . <br><br>  Maka beginilah tampilan kode: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: reachable.add(adjacent) <span class="hljs-comment"><span class="hljs-comment"># If this is a new path, or a shorter path than what we have, keep it. if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1</span></span></code> </pre> <br><h2>  Biaya pencarian yang sama </h2><br>  Sekarang mari kita lihat metode <code>choose_node</code> .  Jika kami berusaha menemukan jalur terpendek yang mungkin, maka memilih simpul secara acak bukanlah ide yang baik. <br><br>  Lebih baik memilih simpul yang bisa kita capai dari simpul awal di sepanjang jalur terpendek;  Berkat ini, kami umumnya memilih jalur yang lebih pendek daripada jalur yang lebih panjang.  Ini tidak berarti bahwa jalur yang lebih panjang tidak akan dipertimbangkan sama sekali, itu berarti bahwa jalur yang lebih pendek akan dipertimbangkan terlebih dahulu.  Karena algoritma berakhir segera setelah menemukan jalur yang sesuai, ini akan memungkinkan kita untuk menemukan jalur pendek. <br><br>  Berikut adalah contoh yang mungkin dari fungsi <code>choose_node</code> : <br><br><pre> <code class="python hljs">function choose_node (reachable): best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> best_node == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> best_node.cost &gt; node.cost: best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Secara intuitif, pencarian untuk algoritma ini diperluas "secara radial" dari simpul awal hingga mencapai simpul akhir.  Berikut ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">demo interaktif</a> perilaku ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nh/fn/jd/nhfnjd_ztdx3fbuqy5v5_am5hxw.gif"></div><br><h2>  Kesimpulan </h2><br>  Perubahan sederhana dalam metode memilih simpul yang dipertimbangkan oleh yang berikut memungkinkan kami untuk mendapatkan algoritma yang cukup baik: ia menemukan jalur terpendek dari awal hingga akhir. <br><br>  Tetapi algoritma ini, sampai batas tertentu, tetap "bodoh."  Dia terus mencari ke mana-mana hingga menemukan terminal node.  Misalnya, apa gunanya contoh yang ditunjukkan di atas untuk mencari di arah <strong>A</strong> , jika jelas bahwa kita <em>bergerak</em> menjauh dari simpul akhir? <br><br>  Apakah mungkin membuat <code>choose_node</code> lebih pintar?  Bisakah kita <em>mengarahkan pencarian ke node akhir</em> , tanpa mengetahui jalur yang benar sebelumnya? <br><br>  Ternyata kita bisa - di bagian selanjutnya, kita akhirnya <code>choose_node</code> , yang memungkinkan kita untuk mengubah algoritma pencarian jalur umum menjadi <strong>A *</strong> . <br><br><h2>  Bagian 3. Lepaskan tabir kerahasiaan dari A * </h2><br>  Algoritma yang diperoleh pada bagian sebelumnya cukup baik: ia menemukan jalur terpendek dari titik awal ke titik akhir.  Namun, ia membuang-buang energinya: ia menganggap cara-cara yang seseorang jelas sebut salah - mereka biasanya <em>menjauh</em> dari tujuan.  Bagaimana ini bisa dihindari? <br><br><h2>  Algoritma ajaib </h2><br>  Bayangkan kita menjalankan algoritma pencarian di komputer khusus dengan chip yang bisa melakukan <em>sihir</em> .  Berkat chip yang luar biasa ini, kami dapat mengekspresikan <code>choose_node</code> cara yang sangat sederhana yang dijamin untuk membuat jalur terpendek tanpa membuang waktu menjelajahi jalur sebagian yang mengarah ke mana-mana: <br><br><pre> <code class="python hljs">function choose_node (reachable): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> magic(reachable, <span class="hljs-string"><span class="hljs-string">" ,     "</span></span>)</code> </pre> <br>  Kedengarannya menggoda, tetapi chip ajaib masih membutuhkan semacam kode tingkat rendah.  Berikut ini perkiraan yang baik: <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = magic(node, <span class="hljs-string"><span class="hljs-string">"   "</span></span>) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Ini adalah cara terbaik untuk memilih simpul berikutnya: Anda memilih simpul yang memberi kita jalur terpendek dari awal hingga akhir, yang merupakan apa yang kita butuhkan. <br><br>  Kami juga meminimalkan jumlah sihir yang digunakan: kami tahu persis berapa biaya bergerak dari node awal ke setiap node (ini <code>node.cost</code> ), dan kami hanya menggunakan magic untuk memprediksi biaya perpindahan dari node ke node terakhir. <br><br><h2>  Tidak ajaib, tapi cukup luar biasa A * </h2><br>  Sayangnya, chip ajaib baru, dan kami membutuhkan dukungan dari peralatan yang sudah ketinggalan zaman.  Sebagian besar kode cocok untuk kita, dengan pengecualian pada baris ini: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Throws MuggleProcessorException cost_node_to_goal = magic(node, "   ")</span></span></code> </pre> <br>  Artinya, kita tidak bisa menggunakan sihir untuk mengetahui biaya jalan yang belum dijelajahi.  Kalau begitu, mari kita membuat prediksi.  Kami akan optimis dan menganggap bahwa tidak ada apa pun antara node saat ini dan yang terakhir, dan kami dapat langsung pindah: <br><br><pre> <code class="python hljs">cost_node_to_goal = distance(node, goal_node)</code> </pre> <br>  Perhatikan bahwa <em>jalur terpendek</em> dan <em>jarak minimum</em> berbeda: jarak minimum menyiratkan bahwa sama sekali tidak ada hambatan antara node saat ini dan akhir. <br><br>  Perkiraan ini cukup mudah diperoleh.  Dalam contoh kisi kami, ini adalah <em>jarak blok kota</em> antara dua node (mis. <code>abs(Ax - Bx) + abs(Ay - By)</code> ).  Jika kita bisa bergerak secara diagonal, maka nilainya akan sama dengan <code>sqrt( (Ax - Bx)^2 + (Ay - By)^2 )</code> , dan seterusnya.  Yang terpenting, kami tidak pernah mendapatkan estimasi nilai <em>terlalu</em> tinggi. <br><br>  Jadi di sini adalah versi non- <code>choose_node</code> dari <code>choose_node</code> : <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Sebuah fungsi yang memperkirakan jarak dari arus ke simpul akhir disebut <em>heuristik</em> , dan algoritma pencarian ini, nyonya-nyonya, disebut ... <strong>A *</strong> . <br><br><h2>  Demo interaktif </h2><br>  Saat Anda pulih dari keterkejutan yang disebabkan oleh kesadaran bahwa <strong>A *</strong> misterius sebenarnya <em>sangat sederhana</em> , Anda dapat melihat demo (atau menjalankannya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel asli</a> ).  Anda akan melihat bahwa, tidak seperti contoh sebelumnya, pencarian menghabiskan sedikit waktu untuk bergerak ke arah yang salah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/iz/nb/pbiznbkynw8pju8unbz6xyqnqqq.gif"></div><br><h2>  Kesimpulan </h2><br>  Akhirnya, kami sampai pada algoritma <strong>A *</strong> , yang tidak lebih dari algoritma pencarian umum yang dijelaskan di bagian pertama artikel dengan beberapa perbaikan yang dijelaskan di bagian kedua dan menggunakan fungsi <code>choose_node</code> , yang memilih node yang, menurut perkiraan kami, membawa kami lebih dekat ke simpul akhir.  Itu saja. <br><br>  Berikut adalah pseudo-code lengkap dari metode utama untuk referensi Anda: <br><br><pre> <code class="python hljs">function find_path (start_node, end_node): reachable = [start_node] explored = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: <span class="hljs-comment"><span class="hljs-comment"># Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don't repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here that we haven't explored before? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: # First time we see this node? if adjacent not in reachable: reachable.add(adjacent) # If this is a new path, or a shorter path than what we have, keep it. if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1 # If we get here, no path was found :( return None</span></span></code> </pre> <br>  Metode <code>build_path</code> : <br><br><pre> <code class="python hljs">function build_path (to_node): path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(to_node) to_node = to_node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  Dan di sini adalah metode <code>choose_node</code> , yang mengubahnya menjadi <strong>A *</strong> : <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Itu saja. <br><br>  Tetapi mengapa kita membutuhkan <strong>bagian 4</strong> ? <br><br>  Sekarang setelah Anda memahami cara kerja <strong>A *</strong> , saya ingin berbicara tentang beberapa area penerapannya yang menakjubkan, yang jauh dari terbatas pada menemukan jalur dalam kisi-kisi sel. <br><br><h2>  Bagian 4. A * dalam praktek </h2><br>  Tiga bagian pertama artikel dimulai dengan dasar-dasar algoritma pencarian jalur dan diakhiri dengan deskripsi yang jelas tentang algoritma <strong>A *</strong> .  Semua ini bagus dalam teori, tetapi memahami bagaimana ini berlaku dalam praktik adalah topik yang sama sekali berbeda. <br><br>  Misalnya, apa yang terjadi jika dunia kita bukan kisi? <br><br>  Bagaimana jika suatu karakter tidak dapat langsung memutar 90 derajat? <br><br>  Bagaimana membangun grafik jika dunia tidak ada habisnya? <br><br>  Bagaimana jika kita tidak peduli tentang panjangnya jalan, tetapi kita bergantung pada energi matahari dan kita harus berada di bawah sinar matahari sebanyak mungkin? <br><br>  Bagaimana menemukan jalur terpendek ke salah satu dari dua node ujung? <br><br><h2>  Fungsi biaya </h2><br>  Pada contoh pertama, kami mencari jalur terpendek antara titik awal dan akhir.  Namun, alih-alih menyimpan panjang jalur parsial dalam <code>length</code> variabel, kami menyebutnya <code>cost</code> .  Mengapa <br><br>  Kita dapat membuat <strong>A *</strong> mencari tidak hanya jalan <em>terpendek</em> , tetapi juga jalan <em>terbaik</em> , dan definisi "terbaik" dapat dipilih berdasarkan tujuan kita.  Ketika kita membutuhkan jalur terpendek, biaya adalah panjang jalur, tetapi jika kita ingin meminimalkan, misalnya konsumsi bahan bakar, maka kita perlu menggunakannya sebagai biaya.  Jika kita ingin memaksimalkan "waktu yang dihabiskan di bawah matahari", maka biaya adalah waktu yang dihabiskan tanpa matahari.  Dan sebagainya. <br><br>  Dalam kasus umum, ini berarti bahwa biaya terkait dikaitkan dengan setiap sisi grafik.  Dalam contoh yang ditunjukkan di atas, nilai ditetapkan secara implisit dan selalu dianggap sama dengan <code>1</code> , karena kami menghitung langkah-langkah di sepanjang jalan.  Tetapi kita dapat mengubah biaya iga sesuai dengan apa yang ingin kita meminimalkan. <br><br><h2>  Fungsi kriteria </h2><br>  Katakanlah objek kita adalah mobil, dan dia harus pergi ke pompa bensin.  Pengisian bahan bakar apa pun akan cocok untuk kita.  Dibutuhkan rute terpendek ke pompa bensin terdekat. <br><br>  Pendekatan naif adalah menghitung jalur terpendek untuk setiap pengisian bahan bakar secara bergantian dan memilih jalur terpendek.  Ini akan berhasil, tetapi itu akan menjadi proses yang cukup mahal. <br><br>  Bagaimana jika kita bisa mengganti satu <code>goal_node</code> dengan metode yang, pada node tertentu, dapat mengetahui apakah itu terbatas atau tidak.  Berkat ini, kami dapat mencari beberapa tujuan secara bersamaan.  Kita juga perlu memodifikasi heuristik sehingga mengembalikan perkiraan biaya minimum dari semua node akhir yang mungkin. <br><br>  Bergantung pada spesifikasi situasinya, kita mungkin tidak dapat mencapai tujuan dengan <em>sempurna</em> , atau biayanya terlalu mahal (jika kita mengirim karakter melalui setengah peta besar, apakah perbedaan satu inci itu penting?), Jadi metode <code>is_goal_node</code> dapat kembali <code>true</code> ketika kita Kami "cukup dekat." <br><br><h2>  Kepastian penuh tidak diperlukan. </h2><br>  Mewakili dunia sebagai grid diskrit mungkin tidak cukup untuk banyak game.  Ambil, misalnya, penembak orang pertama atau game balap.  Dunia itu diskrit, tetapi tidak bisa direpresentasikan sebagai kisi. <br><br>  Tetapi ada masalah yang lebih serius: bagaimana jika dunia ini tidak ada habisnya?  Dalam hal ini, bahkan jika kita dapat menyajikannya dalam bentuk kisi, maka kita tidak akan dapat membuat grafik yang sesuai dengan kisi, karena itu harus tak terbatas. <br><br>  Namun, tidak semuanya hilang.  Tentu saja, untuk algoritma pencarian grafik, kita pasti membutuhkan grafik.  Tetapi tidak ada yang mengatakan bahwa grafik harus <em>komprehensif</em> ! <br><br>  Jika Anda mengamati algoritma dengan cermat, Anda akan melihat bahwa kami tidak melakukan apa pun dengan grafik secara keseluruhan;  kami memeriksa grafik secara lokal, mendapatkan node yang dapat kami capai dari node yang dimaksud.  Seperti yang dapat dilihat dari demo <strong>A *</strong> , beberapa node grafik tidak diselidiki sama sekali. <br><br>  Jadi mengapa kita tidak membuat grafik saja dalam proses penelitian? <br><br>  Kami menjadikan posisi karakter saat ini sebagai simpul awal.  Saat memanggil <code>get_adjacent_nodes</code> ia dapat menentukan cara yang memungkinkan di mana karakter dapat bergerak dari node yang diberikan, dan membuat node tetangga dengan cepat. <br><br><h2>  Melampaui Tiga Dimensi </h2><br>  Bahkan jika dunia Anda <i>benar</i> - <i>benar</i> mesh 2D, ada aspek lain yang perlu dipertimbangkan.  Sebagai contoh, bagaimana jika sebuah karakter tidak dapat langsung memutar 90 atau 180 derajat, seperti biasanya? <br><br>  <em>Keadaan yang</em> diwakili oleh setiap node pencarian tidak harus hanya <em>posisi</em> ;  sebaliknya, itu mungkin mencakup serangkaian nilai yang rumit dan semena-mena.  Misalnya, jika belokan 90 derajat membutuhkan waktu sebanyak transisi dari satu sel ke sel lainnya, maka status karakter dapat diatur sebagai <code>[position, heading]</code> .  Setiap node dapat mewakili tidak hanya posisi karakter, tetapi juga arah pandangannya;  dan tepi-tepi baru grafik (eksplisit atau tidak langsung) mencerminkan hal ini. <br><br>  Jika Anda kembali ke kisi 5x5 asli, maka posisi pencarian awal sekarang dapat <code>[A, East]</code> .  Node yang bertetangga sekarang adalah <code>[B, East]</code> dan <code>[A, South]</code> - jika kita ingin mencapai <strong>F</strong> , kita pertama-tama perlu menyesuaikan arah sehingga jalannya berbentuk <code>[A, East]</code> , <code>[A, South]</code> , <code>[F, South]</code> . <br><br>  Penembak orang pertama?  Setidaknya empat dimensi: <code>[X, Y, Z, Heading]</code> .  Mungkin bahkan <code>[X, Y, Z, Heading, Health, Ammo]</code> . <br><br>  Perhatikan bahwa semakin kompleks keadaannya, semakin kompleks fungsi heuristiknya.  <strong>A * itu sendiri</strong> sederhana;  seni sering muncul dari heuristik yang baik. <br><br><h2>  Kesimpulan </h2><br>  Tujuan artikel ini adalah untuk menghilangkan mitos sekali dan untuk semua itu <strong>A *</strong> adalah algoritma mistik yang tidak dapat diuraikan.  Sebaliknya, saya menunjukkan bahwa tidak ada yang misterius di dalamnya, dan sebenarnya dapat disimpulkan dengan sederhana dengan mulai dari awal. <br><br><h3>  Bacaan lebih lanjut </h3><br>  Amit Patel memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pengantar algoritma A *" yang sangat baik</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan</a> di Habré] (dan artikel-artikelnya yang lain tentang berbagai topik juga sangat bagus!). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444828/">https://habr.com/ru/post/id444828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444816/index.html">Pertukangan DIY: harapan dan kenyataan</a></li>
<li><a href="../id444818/index.html">Citymobil - panduan bagi startup untuk meningkatkan stabilitas di tengah pertumbuhan. Bagian 1</a></li>
<li><a href="../id444820/index.html">Mockdown: cara tercepat untuk membuat wireframes</a></li>
<li><a href="../id444822/index.html">JDK 9 / JEP 280: penggabungan string tidak akan pernah sama lagi</a></li>
<li><a href="../id444824/index.html">Apa yang Diperhatikan Robot Kurir Amazon dan FedEx</a></li>
<li><a href="../id444830/index.html">Cloud elektronik signature di Rusia dan dunia</a></li>
<li><a href="../id444832/index.html">“No Deployments on Friday” dan tiga aturan pengembangan lainnya yang tidak diucapkan</a></li>
<li><a href="../id444836/index.html">Tidak perlu memikirkan ingatan, kata mereka ... Lokakarya CLRium # 5: Pengumpul Sampah</a></li>
<li><a href="../id444838/index.html">Pertemuan OWASP Rusia</a></li>
<li><a href="../id444840/index.html">3. Periksa Titik Memulai R80.20. Persiapan tata letak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>