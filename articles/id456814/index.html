<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍟 🔦 🎅🏾 Pelajari Pemrograman Fungsional dalam Python dalam 10 Menit 👩🏼‍🎨 👂🏻 📚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foto: Chris Ried 

 Pada artikel ini, Anda akan memahami apa itu paradigma fungsional dan bagaimana menggunakan pemrograman fungsional dengan Python. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pelajari Pemrograman Fungsional dalam Python dalam 10 Menit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456814/"><img src="https://habrastorage.org/getpro/habr/post_images/539/971/24e/53997124e1acc9aa28c273b0daa540b3.jpg" alt="gambar"><br>  <i>Foto:</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chris Ried</a> <br><br>  Pada artikel ini, Anda akan memahami apa itu paradigma fungsional dan bagaimana menggunakan pemrograman fungsional dengan Python.  Anda juga akan belajar tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">abstraksi daftar</a> dan pemahaman daftar lainnya. <br><br><h3>  Paradigma fungsional </h3><br>  Dalam paradigma imperatif, Anda menulis sebuah program dengan menentukan urutan tindakan yang kemudian dilakukan.  Pada saat ini, status ( <i>kira-kira Penerjemah: variabel, array, dll.</i> ) Berubah.  Misalnya, biarkan variabel A menyimpan nilai 5, nanti Anda mengubah nilai variabel ini.  Anda menggunakan variabel sehingga nilainya berubah. <a name="habracut"></a><br><br>  Dalam paradigma fungsional, Anda tidak memberi tahu komputer apa yang harus dilakukan, melainkan menentukan sifat tindakan itu sendiri.  Apa pembagi umum terbesar dari suatu angka, hasil perhitungan dari 1 ke n, dll. <br><br>  Oleh karena itu, variabel tidak berubah.  Setelah variabel diinisialisasi, nilainya disimpan selamanya (perhatikan bahwa dalam bahasa fungsional murni mereka bahkan tidak disebut variabel).  Oleh karena itu, dalam paradigma fungsional, fungsi tidak memiliki <i>efek samping</i> .  Efek samping dapat didefinisikan sebagai momen di mana suatu fungsi mengubah sesuatu di luar batasnya.  Lihatlah sebuah contoh: <br><br><pre><code class="python hljs">a = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">some_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> a a = <span class="hljs-number"><span class="hljs-number">5</span></span> some_func() print(a)</code> </pre> <br>  Hasil dari eksekusi kode ini adalah 5. Dalam pemrograman fungsional, mengubah variabel dilarang, dan mengubah fungsi sesuatu di luar batas mereka juga.  Semua fungsi dapat dilakukan adalah untuk menghitung / memproses sesuatu dan mengembalikan hasilnya. <br><br>  Sekarang, Anda mungkin berpikir: “Tidak ada variabel, tidak ada efek samping?  Kenapa itu bagus? "  Pertanyaan yang sangat bagus. <br><br>  Jika suatu fungsi telah dipanggil dua kali dengan parameter yang sama, jelas itu akan mengembalikan hasil yang sama.  Jika Anda telah mempelajari sesuatu tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi matematika</a> , maka Anda akan menghargai kesempatan ini.  Ini disebut transparansi tautan atau transparansi referensial.  Karena fungsi tidak memiliki efek samping, jika Anda mengembangkan program perhitungan, Anda dapat mempercepat proses eksekusi.  Jika program mengetahui bahwa func (2) adalah 3, kita dapat mengingat ini.  Ini mencegah fungsi dipanggil lagi ketika kita sudah tahu hasilnya. <br><br>  Biasanya, dalam pemrograman fungsional, loop tidak digunakan.  Rekursi digunakan.  Rekursi adalah konsep matematika, pada kenyataannya, itu berarti "memberi makan sesuatu kepada diri sendiri."  Dalam fungsi rekursif, fungsi itu sendiri menyebut dirinya peran sub-fungsi.  Berikut adalah contoh fungsi rekursif dengan Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial_recursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Base case: 1! = 1 #   if n == 1: return 1 # Recursive case: n! = n * (n-1)! #    else: return n * factorial_recursive(n-1)</span></span></code> </pre> <br>  Beberapa bahasa pemrograman <b>malas</b> .  Ini berarti mereka menghitung semuanya pada saat terakhir.  Misalkan jika kode harus mengeksekusi 2 + 2, program fungsional akan menghitung hasilnya hanya ketika hasilnya diperlukan.  Kita akan belajar tentang kemalasan Python sedikit kemudian. <br><br><h3>  <font color="#9933FF">Peta</font> </h3><br>  Untuk memahami peta, Anda harus terlebih dahulu berurusan dengan wadah yang dapat diubah.  Ini adalah wadah tempat Anda bisa "pergi".  Ini sering daftar atau array, tetapi ada banyak wadah seperti itu di Python.  Anda bahkan dapat membuat wadah sendiri dengan memperkenalkan <i>metode sihir</i> .  Metode-metode ini, seperti API, membantu objek menjadi lebih pythonic.  Ada 2 metode seperti itu untuk membuat objek dapat diubah: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, low, high)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># set class attributes inside the magic method __init__ # for "inistalise" #      self.current = low self.high = high def __iter__(self): # first magic method to make this object iterable #    return self def __next__(self): # second magic method #    if self.current &gt; self.high: raise StopIteration else: self.current += 1 return self.current - 1</span></span></code> </pre> <br>  Metode sulap pertama adalah "___iter__" atau dunder (digarisbawahi ganda oleh garis bawah) iter mengembalikan objek iterable, ini sering digunakan pada awal loop.  Dunder next (__next__) mengembalikan objek berikutnya. <br><br>  Lihat ini: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Counter(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>): print(c)</code> </pre> <br>  Hasil Eksekusi: <br><br> <code>3 <br> 4 <br> 5 <br> 6 <br> 7 <br> 8</code> <br> <br>  Dalam Python, iterator adalah objek yang hanya memiliki metode __iter__.  Ini berarti bahwa Anda dapat mengakses tempat sel-sel objek (wadah), tetapi Anda tidak bisa "berjalan" melaluinya.  Beberapa objek hanya memiliki metode __next__ yang indah, tanpa metode __iter__ ajaib, misalnya, atur (lebih banyak tentang itu nanti).  Pada artikel ini, kita akan membahas segala sesuatu yang berhubungan dengan objek yang dapat diubah. <br><br>  Sekarang kita tahu apa itu objek yang dapat diubah, mari kembali ke fungsi peta.  Fungsi ini memungkinkan kita untuk menerapkan aksi beberapa fungsi lainnya ke setiap elemen dalam wadah yang diulang.  Kami ingin menerapkan fungsi ke setiap elemen dalam daftar, ini dimungkinkan untuk hampir semua wadah yang dapat diubah.  Peta, membutuhkan dua argumen: fungsi yang akan diterapkan, dan wadah (daftar, dll.). <br><br><pre> <code class="python hljs">map(function, iterable)</code> </pre> <br>  Misalkan kita memiliki daftar dengan elemen-elemen berikut: <br><br> <code>[1, 2, 3, 4, 5]</code> <br> <br>  Dan kami ingin mengkuadratkan setiap elemen, ini bisa dilakukan seperti ini: <br><br><pre> <code class="python hljs">x = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">square</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num*num print(list(map(square, x)))</code> </pre> <br>  Fungsi fungsional dalam Python malas.  Jika kita tidak menambahkan "daftar ()", fungsi akan menyimpan deskripsi wadah (daftar), dan bukan daftar itu sendiri.  Kami secara langsung perlu memberi tahu Python untuk mengonversikan ini ke daftar. <br><br>  Agak aneh untuk berpindah dari definisi yang tidak malas ke definisi yang malas begitu tiba-tiba.  Anda akan terbiasa jika Anda berpikir lebih dalam cara fungsional daripada keharusan. <br><br>  Fungsi penulisan, misalnya, "kuadrat (num)" adalah normal, tetapi tidak sepenuhnya benar.  Apakah kita perlu mendeklarasikan seluruh fungsi hanya untuk menggunakannya di peta?  Ini dapat disederhanakan dengan memperkenalkan fungsi lambda (anonim). <br><br><h3>  <font color="#9933FF">Ekspresi Lambda</font> </h3><br>  Ekspresi Lambda adalah fungsi dalam satu baris, misalnya, di sini adalah ekspresi lambda yang mengkuadratkan angka yang dihasilkan: <br><br><pre> <code class="python hljs">square = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x * x</code> </pre> <br>  Dan, jalankan ini: <br><br> <code>&gt;&gt;&gt; square(3) <br> 9</code> <br> <br>  Aku bisa mendengarmu.  "Brandon, di mana argumennya?"  Tentang apa semua ini?  Ini bukan seperti fungsi. " <br><br>  Ya, ini bisa membingungkan, tetapi bisa dijelaskan.  Di baris ini, kami menetapkan sesuatu ke variabel "kuadrat".  Bagian ini: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x * x</code> </pre> <br>  Memberitahu Python bahwa kita menggunakan fungsi lambda, dan inputnya bernama x.  Semuanya setelah titik dua adalah apa yang akan terjadi pada input, dan kami akan secara otomatis mendapatkan hasilnya nanti. <br><br>  Untuk program kami dalam bentuk one-line, Anda perlu melakukan ini: <br><br><pre> <code class="python hljs">x = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] print(list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num * num, x)))</code> </pre> <br>  Jadi, dalam ungkapan lambda, argumennya ada di sebelah kiri, dan tindakan atas mereka ada di kanan.  Ini sedikit berantakan, tidak ada yang menyangkal.  Yang benar adalah bahwa ada sesuatu di dalamnya, untuk menulis kode fungsional seperti itu.  Selain itu, sangat keren untuk mengonversi fungsi menjadi satu baris. <br><br><h3>  <font color="#9933FF">Kurangi</font> </h3><br>  Reduce adalah fungsi yang mengubah wadah yang dapat diubah menjadi satu hal.  Artinya, perhitungan dibuat yang mengubah daftar menjadi satu nomor.  Ini terlihat seperti ini: <br><br><pre> <code class="python hljs">reduce(function, list)</code> </pre> <br>  Kita dapat (dan sering akan) menggunakan fungsi lambda sebagai argumen fungsi. <br><br>  Jika kita ingin melipatgandakan semua angka dalam daftar, ini bisa dilakukan seperti ini: <br><br><pre> <code class="python hljs">product = <span class="hljs-number"><span class="hljs-number">1</span></span> x = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x: product = product * num</code> </pre> <br>  Dan dengan mengurangi akan terlihat seperti ini: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> reduce product = reduce((<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x, y: x * y),[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>])</code> </pre> <br>  Hasilnya akan sama, tetapi kode lebih pendek dan dengan pengetahuan pemrograman fungsional untuk menggunakannya lebih akurat. <br><br><h3>  <font color="#9933FF">Saring</font> </h3><br>  Fungsi filter mengambil wadah yang dapat diulang dan memfilternya sesuai dengan aturan yang diberikan (juga fungsi). <br><br>  Biasanya dibutuhkan fungsi dan daftar sebagai input.  Kemudian itu berlaku fungsi untuk setiap elemen dalam daftar, jika fungsi mengembalikan Benar, tidak ada yang terjadi, dan jika Salah, elemen dihapus dari daftar. <br><br>  Sintaks: <br><br><pre> <code class="python hljs">filter(function, list)</code> </pre> <br>  Mari kita lihat contoh tanpa menggunakan filter: <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) new_list = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>: new_list.append(num)</code> </pre> <br>  Bersama dengan filter: <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = list(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, x))</code> </pre> <br><h3>  <font color="#9933FF">Fungsi Orde Tinggi</font> </h3><br>  Fungsi tingkat tinggi dapat menggunakan fungsi sebagai argumen dan mengembalikannya.  Contoh sederhana akan terlihat seperti ini: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nums)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum(nums) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func, numbers)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func(numbers) print(action(summation, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>])) <span class="hljs-comment"><span class="hljs-comment"># Output is 6 #  6</span></span></code> </pre><br>  Atau sebuah contoh bahkan lebih sederhana: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rtnBrandon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"brandon"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rtnJohn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"john"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rtnPerson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> age = int(input(<span class="hljs-string"><span class="hljs-string">"What's your age?"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> age == <span class="hljs-number"><span class="hljs-number">21</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rtnBrandon() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rtnJohn()</code> </pre> <br>  Ingat sebelumnya saya mengatakan bahwa pemrograman fungsional nyata tidak menggunakan variabel.  Fungsi tingkat tinggi memungkinkan ini.  Anda tidak perlu menyimpan variabel di suatu tempat jika Anda melewatkan informasi melalui "terowongan" fungsi yang panjang. <br><br>  Semua fungsi dalam Python adalah objek kelas satu.  Objek kelas pertama didefinisikan seperti itu, yang sesuai dengan satu atau lebih dari parameter berikut: <br><br><ul><li>  Menciptakan siklus tugas </li><li>  Ditugaskan ke variabel atau item dalam struktur data </li><li>  Diberikan sebagai argumen fungsi </li><li>  Kembali sebagai hasil dari eksekusi fungsi </li></ul><br>  Jadi semua fungsi dalam Python adalah objek kelas satu, dan dapat digunakan sebagai fungsi tingkat tinggi. <br><br><h3>  <font color="#9933FF">Aplikasi sebagian</font> </h3><br>  Penggunaan sebagian (juga interupsi) agak aneh, tetapi sangat keren.  Anda dapat memanggil fungsi tanpa menggunakan semua argumen yang diberikan.  Mari kita lihat sebuah contoh.  Kami ingin membuat fungsi yang membutuhkan 2 argumen, basis dan derajat, dan mengembalikan basis yang diangkat ke kekuasaan, tampilannya seperti ini: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">power</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base, exponent)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base ** exponent</code> </pre><br>  Sekarang kita perlu membuat fungsi terpisah untuk mengkuadratkan, dan menghitungnya menggunakan fungsi daya: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">square</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> power(base, <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br>  Berhasil, tetapi bagaimana jika kita ingin membuat angka?  Atau di tingkat 4?  Haruskah Anda menulis fungsi seperti itu selamanya?  Tentu saja bisa.  Tapi programmer malas.  Jika Anda mengulangi hal yang sama beberapa kali, mungkin ada cara untuk melakukannya lebih cepat dan berhenti melakukan pengulangan.  Aplikasi sebagian dapat digunakan di sini.  Mari kita lihat contoh fungsi daya menggunakan aplikasi parsial: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> partial square = partial(power, exponent=<span class="hljs-number"><span class="hljs-number">2</span></span>) print(square(<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># output is 4 #  4</span></span></code> </pre><br>  Bukankah itu keren?  Kita dapat memanggil fungsi yang membutuhkan 2 argumen, hanya menggunakan 1, dan menentukan apa yang akan menjadi argumen sendiri. <br><br>  Anda juga dapat menggunakan loop untuk mensimulasikan fungsi daya yang akan bekerja dengan kubus hingga kekuatan 1000. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> partial powers = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1001</span></span>): powers.append(partial(power, exponent = x)) print(powers[<span class="hljs-number"><span class="hljs-number">0</span></span>](<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># output is 9 #  9</span></span></code> </pre> <br><h3>  <font color="#9933FF">Pemrograman fungsional tidak cocok dengan kanon pythonic</font> </h3><br>  Anda mungkin telah memperhatikan bahwa banyak hal yang ingin kita lakukan dalam pemrograman fungsional berkisar pada daftar.  Selain mengurangi fungsi dan aplikasi parsial, semua fungsi yang Anda lihat menghasilkan daftar.  Guido (pencipta Python`a) tidak suka hal-hal fungsional dalam Python`e, karena Python memiliki metode sendiri dalam membuat daftar. <br><br>  Jika Anda menulis "impor ini" di konsol, Anda akan mendapatkan: <br> <code>&gt;&gt;&gt; import this <br> <br> The Zen of Python, by Tim Peters <br> <br> Beautiful is better than ugly. <br> Explicit is better than implicit. <br> Simple is better than complex. <br> Complex is better than complicated. <br> Flat is better than nested. <br> Sparse is better than dense. <br> Readability counts. <br> Special cases aren't special enough to break the rules. <br> Although practicality beats purity. <br> Errors should never pass silently. <br> Unless explicitly silenced. <br> In the face of ambiguity, refuse the temptation to guess. <br> There should be one — and preferably only one — obvious way to do it. <br> Although that way may not be obvious at first unless you're Dutch. <br> Now is better than never. <br> Although never is often better than *right* now. <br> If the implementation is hard to explain, it's a bad idea. <br> If the implementation is easy to explain, it may be a good idea. <br> Namespaces are one honking great idea — let's do more of those!</code> <br> <br>  Ini adalah Python Zen.  Ini adalah ayat tentang apa artinya menjadi seorang pythonist.  Bagian yang menarik bagi kami adalah: <br><br><blockquote>  Seharusnya ada satu - dan lebih disukai hanya satu - cara yang jelas untuk melakukannya. </blockquote><br><blockquote>  <i>Seharusnya hanya ada satu - dan lebih disukai hanya satu - cara yang jelas untuk melakukan sesuatu.</i> </blockquote><br>  Dalam Python, peta dan filter dapat melakukan hal yang sama seperti abstraksi daftar ( <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a></i> ).  Ini melanggar salah satu aturan Python-Zen, jadi ini bagian dari pemrograman fungsional bukan "pythonic". <br><br>  Hal-hal selanjutnya untuk dibicarakan adalah fungsi lambda.  Dalam Python, fungsi lambda adalah fungsi normal.  Dan sebenarnya itu adalah gula sintaksis.  Kedua bagian ini melakukan hal yang sama: <br><br><pre> <code class="python hljs">foo = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> a: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Fungsi standar mungkin masih sama dengan fungsi lambda, tetapi tidak sebaliknya.  Fungsi Lambda tidak bisa sama dengan yang biasa. <br><br>  Ini adalah komentar kecil tentang mengapa pemrograman fungsional tidak cukup cocok dengan ideologi pythonic.  Sebelumnya, saya menyebutkan abstraksi daftar ( <i>juga daftar inklusi</i> ), sekarang mari kita bicarakan. <br><br><h3>  <font color="#9933FF">Daftar abstraksi</font> </h3><br>  Saya sudah mengatakan bahwa semua yang dapat dilakukan dengan menggunakan peta dan filter dapat dilakukan dengan menggunakan abstraksi daftar.  Pada bagian ini kita akan membahasnya. <br><br>  Daftar abstraksi adalah cara untuk membuat daftar dengan Python.  Sintaks: <br><br><pre> <code class="python hljs">[function <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> iterable]</code> </pre> <br>  Mari kita kuadratkan setiap item dalam daftar, misalnya: <br><br><pre> <code class="python hljs">print([x * x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]])</code> </pre> <br>  Oke, kita bisa melihat bagaimana menerapkan fungsi ke setiap elemen daftar.  Bagaimana kita menyiasati filter?  Lihatlah kode ini: <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = list(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, x)) print(all_less_than_zero)</code> </pre> <br>  Sekarang gunakan daftar abstraksi: <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = [num <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  Daftar abstraksi mendukung ekspresi kondisional dari jenis ini.  Anda tidak perlu lagi menggunakan sejuta fungsi untuk mendapatkan sesuatu.  Bahkan, jika Anda mencoba melakukan sesuatu dengan daftar, ada kemungkinan lebih bersih dan lebih mudah dicapai dengan abstraksi daftar. <br><br>  Bagaimana jika kita ingin menguadratkan setiap elemen daftar yang di bawah nol.  Dengan fungsi lambda, memetakan dan memfilter, akan terlihat seperti ini: <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num * num, list(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, x))))</code> </pre><br>  Entri ini tidak rasional dan tidak terlalu sederhana.  Menggunakan abstraksi daftar, akan terlihat seperti ini: <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = [num * num <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br>  Daftar abstraksi hanya baik, cukup aneh, untuk daftar.  Peta dan penyaringan bekerja untuk setiap wadah yang dapat diubah, jadi apa yang salah? .. Ya, Anda dapat menggunakan abstraksi untuk setiap wadah yang dapat diubah yang Anda temui. <br><br><h3>  <font color="#9933FF">Abstraksi lainnya</font> </h3><br>  Anda dapat menerapkan abstraksi untuk setiap wadah yang dapat diubah. <br><br>  Setiap wadah yang dapat diubah dapat dibuat menggunakan abstraksi.  Dimulai dengan versi 2.7, Anda bahkan dapat membuat kamus (tabel hash). <br><br>  Jika sesuatu adalah wadah yang dapat diubah, maka sesuatu dapat dihasilkan.  Mari kita lihat contoh terakhir menggunakan set.  Jika Anda tidak tahu apa set, maka lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini yang</a> ditulis oleh saya juga.  Singkatnya: <br><br><ul><li>  Set adalah wadah elemen, elemen di dalamnya tidak diulang </li><li>  Ketertiban tidak penting </li></ul><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># taken from page 87, chapter 3 of Fluent Python by Luciano Ramalho #    Fluent Python, . 87, . 3 &gt;&gt;&gt; from unicodedata import name &gt;&gt;&gt; {chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i), '')} {'×', '¥', '°', '£', '', '#', '¬', '%', 'µ', '&gt;', '¤', '±', '¶', '§', '&lt;', '=', '', '$', '÷', '¢', '+'}</span></span></code> </pre><br>  Seperti yang mungkin Anda perhatikan, set, seperti kamus, menggunakan kurung kurawal.  Python sangat pintar.  Dia akan menebak apakah Anda menggunakan abstraksi kamus atau abstraksi set`a, berdasarkan apakah Anda menentukan parameter tambahan untuk kamus atau tidak.  Jika Anda ingin tahu lebih banyak tentang abstraksi, baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> .  Jika tentang abstraksi dan generasi, maka yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> . <br><br><h3>  <font color="#9933FF">Ringkasan</font> </h3><br>  Pemrograman fungsional sangat bagus.  Kode fungsional dapat berupa bersih atau tidak terlalu.  Beberapa pythonis hardcore tidak menerima paradigma fungsional dalam Python.  Anda harus menggunakan apa yang Anda inginkan dan apa yang cocok untuk Anda. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halaman penulis</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456814/">https://habr.com/ru/post/id456814/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456804/index.html">Ikuti uang: bagaimana grup RTM mulai menyembunyikan alamat server C & C di dompet crypto</a></li>
<li><a href="../id456806/index.html">Satu bot dari semua kekhawatiran</a></li>
<li><a href="../id456808/index.html">Cara Meningkatkan Kinerja Aplikasi Web Front-End: Lima Tips</a></li>
<li><a href="../id456810/index.html">Yang pertama. Kisah Bebas Tesla</a></li>
<li><a href="../id456812/index.html">Apa yang ada di ITMO University - festival IT, hackathons, konferensi, dan seminar terbuka</a></li>
<li><a href="../id456818/index.html">Administrator sistem di perusahaan yang tidak dapat didekati. Beban makhluk yang tak tertahankan?</a></li>
<li><a href="../id456820/index.html">Clay → Brick → Kompor</a></li>
<li><a href="../id456824/index.html">Apa itu probabilitas dan bagaimana cara menghitungnya</a></li>
<li><a href="../id456826/index.html">DIY Autoscaling dengan AWX, Ansible, haproxy, dan CROC Cloud</a></li>
<li><a href="../id456828/index.html">Tuning vias untuk papan sirkuit tercetak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>