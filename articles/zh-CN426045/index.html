<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛥️ 😼 🎅🏻 .NET中的特殊异常以及如何准备它们 🥗 🍭 👃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=".NET中的各种异常都有其自身的特征，了解它们可能非常有用。 如何欺骗CLR？ 如何通过捕获StackOverflowException保持运行时状态？ 似乎无法捕获哪些例外，但是如果您确实愿意，可以吗？ 



 删节后，来自我们的DotNext 2018 Piter会议的Eugene（ epes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET中的特殊异常以及如何准备它们</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/426045/">  .NET中的各种异常都有其自身的特征，了解它们可能非常有用。 如何欺骗CLR？ 如何通过捕获StackOverflowException保持运行时状态？ 似乎无法捕获哪些例外，但是如果您确实愿意，可以吗？ <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f1/314/78d/4f131478de33b4a6acd0ed25a0e53987.png"><br><br> 删节后，来自我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DotNext 2018 Piter</a>会议的Eugene（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">epeshk</a> ）Peshkov的报告抄本，他谈到了异常的这些特征和其他特征。 <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WLSrYgMWif4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br> 你好 我叫尤金。 我为SKB Kontur工作，开发主机系统并为Windows部署应用程序。 最重要的是，我们有许多产品团队来编写自己的服务并与我们托管。 我们为他们提供了轻松，简单的解决方案，以应对各种基础架构任务。 例如，监视系统资源的消耗或完成对服务的复制。 <br><br> 有时，事实证明，托管在我们系统上的应用程序会崩溃。 我们已经看到了应用程序如何在运行时崩溃的多种方式。 其中一种方法是抛出一些意外且令人着迷的异常。 <br><br> 今天，我将讨论.NET中的异常功能。 我们在生产中遇到了其中一些功能，并且在实验过程中遇到了其中一些功能。 <br><br><h2> 计划 </h2><br><ol><li>  .NET异常行为 <br></li><li>  Windows异常处理和黑客 <br></li></ol><br> 对于Windows，以下所有内容均适用。 所有示例都在完整的.NET 4.7.1框架的最新版本上进行了测试。  .NET Core也将有一些引用。 <br><br>
<h2> 访问冲突 </h2><br> 错误的内存操作过程中会发生此异常。 例如，如果应用程序尝试访问它无权访问的内存区域。 例外是低级别，通常，如果发生这种情况，将需要很长时间的调试。 <br><br> 让我们尝试使用C＃获得此异常。 为此，我们将字节42写入地址1000（我们假设1000是一个相当随机的地址，我们的应用程序很可能无法访问它）。 <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Marshal.WriteByte((IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AccessViolationException) { ... }</code> </pre> <br>  WriteByte正是我们所需要的：它将字节写入给定地址。 我们希望此调用引发AccessViolationException。 该代码确实将引发此异常，它将能够处理并且该应用程序将继续运行。 现在让我们稍微更改一下代码： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] {<span class="hljs-number"><span class="hljs-number">42</span></span>}; Marshal.Copy(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, bytes.Length); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AccessViolationException) { ... }</code> </pre><br> 如果使用Copy方法而不是WriteByte并将字节42复制到地址1000，然后使用try-catch，则无法捕获AccessViolation。 同时，控制台上将显示一条消息，指出由于未处理的AccessViolationException而终止了该应用程序。 <br><br><pre> <code class="cs hljs">Marshal.Copy(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, bytes.Length); Marshal.WriteByte((IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre><br> 事实证明，我们有两行代码，而第一行使用AccessViolation使整个应用程序崩溃，而第二行则抛出相同类型的已处理异常。 为了理解为什么会发生这种情况，我们将研究如何从内部安排这些方法。 <br><br> 让我们从Copy方法开始。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Copy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">)</span></span> { Marshal.CopyToNative((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>) source, startIndex, destination, length); } [MethodImpl(MethodImplOptions.InternalCall)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyToNative</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex, IntPtr destination, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Copy方法唯一要做的就是调用在.NET内部实现的CopyToNative方法。 如果我们的应用程序仍然崩溃，并且某处发生异常，则只能在CopyToNative内部发生。 从这里我们可以进行第一个观察：如果.NET代码称为本机代码，并且AccessViolation发生在其中，则由于某种原因，.NET代码无法处理此异常。 <br><br> 现在我们将了解为什么可以使用WriteByte方法处理AccessViolation。 让我们看一下该方法的代码： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteByte</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { *(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*) ptr = val; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NullReferenceException) {     <span class="hljs-comment"><span class="hljs-comment">// this method is documented to throw AccessViolationException on any AV throw new AccessViolationException(); } }</span></span></code> </pre><br> 此方法在托管代码中完全实现。 它使用C＃指针将数据写入所需的地址，并且还捕获NullReferenceException。 如果NRE被拦截，则抛出AccessViolationException。 因此有必要根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">规范</a> 。 在这种情况下，将处理throw结构所引发的所有异常。 因此，如果在WriteByte内部执行代码期间发生NullReferenceException，则可以捕获AccessViolation。 在我们的情况下，访问地址1000而不是地址0时会发生NRE吗？ <br><br> 我们直接使用C＃指针重写代码，然后看到访问非零地址时实际上会抛出NullReferenceException： <br><br><pre> <code class="cs hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*) <span class="hljs-number"><span class="hljs-number">1000</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre><br> 要了解为什么会发生这种情况，我们需要记住该过程的内存是如何工作的。 在过程存储器中，所有地址都是虚拟的。 这意味着该应用程序具有很大的地址空间，并且只有一部分页面显示在实际的物理内存中。 但是有一个特点：前64 KB的地址永远不会映射到物理内存，也不会分配给应用程序。  Rantime .NET知道并使用它。 如果在托管代码中发生AccessViolation，则运行时将检查访问内存中的哪个地址并生成适当的异常。 对于从0到2 ^ 16的地址-NullReference，对于所有其他地址-AccessViolation。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/775/3d4/38f/7753d438fc8a977ac0bb54e431d81c6f.png"><br><br> 让我们看看为什么不仅在访问零地址时抛出NullReference。 假设您正在访问引用类型的对象的字段，并且对该对象的引用为null： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/127/a27/867/127a27867ef7a568a242797758855b44.png"><br><br> 在这种情况下，我们希望得到一个NullReferenceException。 对对象字段的访问发生在相对于该对象地址的偏移处。 事实证明，我们将转向一个足够接近零的地址（请记住，指向我们原始对象的链接为零）。 通过这种运行时行为，无需额外验证对象本身的地址即可获得预期的异常。 <br><br> 但是，如果我们转到对象的字段，并且该对象本身占用的内存超过64 KB，会发生什么情况？ <br><br><img src="https://habrastorage.org/getpro/habr/post_images/356/897/143/356897143b1275403569dc9f9a71471a.png"><br><br> 在这种情况下可以获取AccessViolation吗？ 让我们做一个实验。 让我们创建一个非常大的对象，我们将引用它的字段。 一个字段位于对象的开头，第二个字段位于结尾： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08d/619/95a/08d61995a01630f94f31f759890af4a8.png"><br><br> 这两个方法都将抛出NullReferenceException。 不会发生AccessViolationException。 <br> 让我们看看将为这些方法生成的指令。 在第二种情况下，JIT编译器添加了一个附加的cmp指令，该指令可访问对象本身的地址，从而以零地址调用AccessViolation，运行时将其转换为NullReferenceException。 <br><br> 值得注意的是，对于本实验，将数组用作大对象是不够的。 怎么了 将这个问题留给读者，在评论中写点子:) <br><br> 让我们总结一下AccessViolation的实验。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ffa/86b/0a8/ffa86b0a85f29a16936c92845f5d3e1e.png"><br><br>  AccessViolationException的行为根据异常发生的位置（在托管代码或本机中）而有所不同。 另外，如果托管代码中发生异常，则将检查对象的地址。 <br><br> 问题是：我们可以处理在本机代码或托管代码中发生但未转换为NullReference且未使用throw抛出的AccessViolationException吗？ 有时这是一个有用的功能，尤其是在处理不安全的代码时。 该问题的答案取决于.NET的版本。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/67a/785/318/67a785318bc8b5f084a3b23fa36e766b.png"><br><br> 在.NET 1.0中，根本没有AccessViolationException。 所有链接都被视为有效或为空。 到.NET 2.0时代，很明显，没有直接使用内存的方法-没办法，AccessViolation出现了，而且它是可处理的。 在4.0及更高版本中，它仍然可以工作，但是处理起来却不是那么简单。 要捕获此异常，您现在需要使用HandleProcessCorruptedStateException属性标记catch块所在的方法。 显然，开发人员之所以这样做，是因为他们认为AccessViolationException并不是常规应用程序中应捕获的异常。 <br> 另外，为了向后兼容，可以使用运行时设置： <br><br><ul><li>  legacyNullReferenceExceptionPolicy返回.NET 1.0行为-所有AV都变为NRE <br></li><li>  legacyCorruptedStateExceptionsPolicy返回.NET 2.0行为-拦截了所有AV <br></li></ul><br> 在.NET中，根本不处理Core AccessViolation。 <br><br> 在我们的生产中有这样一种情况： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad7/0f1/6d3/ad70f16d3438d1e8ab80e43ba29d5412.png"><br><br> 在.NET 4.7.1下构建的应用程序使用在.NET 3.5下构建的共享代码库。 该库中有一个助手来执行定期操作： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (isRunning) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { action(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { log.Error(e); } WaitForNextExecution(... ); }</code> </pre><br> 我们将应用程序中的操作传递给了此帮助器。 碰巧他使AccessViolation崩溃了。 结果，我们的应用程序不断记录AccessViolation，而不是因为  3.5以下库中的代码可以捕获它。 应该注意的是，侦听并不取决于运行应用程序的运行时版本，而是取决于构建应用程序的TargetFramework及其依赖项。 <br><br> 总结一下。  AccessVilolation处理取决于其起源（本机或托管代码）以及TargetFramework和运行时设置。 <br><br><h2> 线程中止 </h2><br> 有时在代码中，您需要停止线程之一。 为此，可以使用thread.Abort（）;。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ... Thread.ResetAbort(); } }); ... thread.Abort();</code> </pre><br> 在停止的线程中调用Abort方法时，将引发ThreadAbortException。 让我们分析一下它的功能。 例如，如下代码： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { … } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { … } }); ... thread.Abort();</code> </pre><br> 绝对等于： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }); ... thread.Abort();</code> </pre><br> 如果仍然需要处理ThreadAbort并在已停止的线程中执行其他一些操作，则可以使用Thread.ResetAbort（）方法； 它停止了停止流的过程，并且异常停止将更高的堆栈向上抛出。 重要的是要了解thread.Abort（）方法本身不能保证任何内容-已停止线程中的代码可能会阻止它停止。 <br><br>  thread.Abort（）的另一个功能是，如果它在catch中并最终阻塞，它将无法中断代码。 <br><br> 在框架代码中，您经常可以找到try块为空且所有逻辑最终都在其中的方法。 这样做只是为了防止ThreadAbortException抛出此代码。 <br><br> 另外，对thread.Abort（）方法的调用等待ThreadAbortException的抛出。 结合这两个事实，可以得到thread.Abort（）方法可以阻止调用线程。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { }       <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { } <span class="hljs-comment"><span class="hljs-comment">// &lt;-- No ThreadAbortException in catch       finally { // &lt;-- No ThreadAbortException in finally           Thread.Sleep(- 1); } }); thread.Start(); ... thread.Abort(); // Never returns</span></span></code> </pre><br> 实际上，在使用using时可能会遇到这种情况。 它部署在try / final中，在final内调用Dispose方法。 它可以任意复杂，包含事件处理程序，使用锁。 如果在运行时调用thread.Abort，则Dispose-thread.Abort（）将等待它。 因此，我们几乎从零开始就获得了一把锁。 <br><br> 在.NET Core中，thread.Abort（）方法引发PlatformNotSupportedException。 而且我认为这非常好，因为它不是使用thread.Abort（）而是使用非侵入性方法来停止代码执行，例如使用CancellationToken来激励。 <br><br><h2> 内存不足 </h2><br> 如果机器上的内存少于所需的内存，则可以获取此异常。 或者当我们遇到32位进程的限制时。 但是，即使计算机具有大量可用内存，并且该过程是64位的，您也可以获取它。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr4gb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue/<span class="hljs-number"><span class="hljs-number">2</span></span>];</code> </pre><br> 上面的代码将抛出OutOfMemory。 事实是，默认情况下，不允许使用大于2 GB的对象。 可以通过在App.config中设置gcAllowVeryLargeObjects来解决此问题。 在这种情况下，将创建一个4 GB的阵列。 <br><br> 现在让我们尝试创建更多数组。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> largeArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue];</code> </pre><br> 现在，即使gcAllowVeryLargeObjects也无济于事。 这是因为.NET <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对数组中的最大索引</a>有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">限制</a> 。 此限制小于int.MaxValue。 <br><br> 最大数组索引： <br><br><ul><li> 字节数组-0x7FFFFFC7 <br></li><li> 其他阵列-0X7F <b>E</b> FFFFF <br></li></ul><br> 在这种情况下，将发生OutOfMemoryException，尽管实际上我们遇到了数据类型限制，而不是内存不足。 <br><br> 有时，.NET框架中的托管代码会明确丢弃OutOfMemory： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/efd/c84/d98/efdc84d98a7786e39c9c5931ac523d13.png"><br> 这是string.Concat方法的实现。 如果结果字符串的长度大于int.MaxValue，则会立即引发OutOfMemoryException。 <br><br> 让我们继续讨论当内存实际用完时出现OutOfMemory的情况。 <br><br><pre> <code class="cs hljs">LimitMemory(<span class="hljs-number"><span class="hljs-number">64.</span></span>Mb()); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>)   list.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (OutOfMemoryException e) { Console.WriteLine(e); }</code> </pre><br> 首先，我们将进程的内存限制为64 MB。 接下来，在循环中，选择新的字节数组，将它们保存到某些表中，以使GC不会收集它们，并尝试捕获OutOfMemory。 <br><br> 在这种情况下，任何事情都会发生： <br><br><ul><li> 异常处理 <br></li><li> 进程将下降 <br></li><li> 让我们赶上来，但是异常会再次崩溃 <br></li><li> 让我们进入陷阱，但是StackOverflow将会崩溃 <br></li></ul><br> 在这种情况下，该程序将是完全不确定的。 让我们分析所有选项： <br><br><ol><li> 可以处理异常。 在.NET内部，没有什么可以阻止您处理OutOfMemoryException。 <br></li><li> 该过程可能会失败。 不要忘记我们有一个托管应用程序。 这意味着它不仅在内部执行我们的代码，还在运行时代码中执行。 例如，GC。 因此，当运行时想要为其分配内存但无法执行此操作时，可能会发生这种情况，那么我们将无法捕获异常。 <br></li><li> 让我们进入陷阱，但是异常将再次崩溃。 在catch内，我们还会在需要内存的地方进行工作（我们将异常输出到控制台），这可能会导致新的异常。 <br></li><li> 让我们开始讨论，但是StackOverflow将崩溃。 调用WriteLine方法时会发生StackOverflow本身，但是这里没有堆栈溢出，但是会发生另一种情况。 让我们更详细地分析它。 <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/6e3/d32/752/6e3d32752ba10fd39d1f4a5e2e6648a7.png"><br><br> 在虚拟内存中，页面不仅可以映射到物理内存，还可以保留。 如果该页面被保留，则应用程序会指出它将要使用它。 如果页面已经映射到实际内存或交换，则称为“已提交”（committed）。 堆栈使用此功能将内存拆分为保留和提交。 看起来像这样： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b17/9e4/41f/b179e441f0c00f18e2a5fdf12b3093a9.png"><br><br> 事实证明，我们调用了WriteLine方法，该方法在堆栈上占据了一些位置。 事实证明，所有已提交的内存都已结束，这意味着操作系统此刻应该在堆栈上获取另一个保留页，并将其映射到实际的物理内存，该内存已由字节数组填充。 这导致StackOverflow例外。 <br><br> 下面的代码将允许您在流的开头立即将所有内存提交到堆栈。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; F(), <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>).Start();</code> </pre><br> 或者，您可以使用disableCommitThreadStack <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">运行时设置</a> 。 需要禁用它，以便线程堆栈提前提交。 值得注意的是，文档中描述的和实际观察到的默认行为是不同的。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46e/0e6/dbd/46e0e6dbd47906fb1d0ddf74ac927383.png"><br><br><h2> 堆栈溢出 </h2><br> 让我们仔细看一下StackOverflowException。 让我们看两个代码示例。 在其中一个中，我们运行无限递归，这导致堆栈溢出，在第二个中，我们仅使用throw抛出此异常。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { InfiniteRecursion(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { ... }</code> </pre><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StackOverflowException(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { ... }</code> </pre><br> 由于处理了所有使用throw引发的异常，因此在第二种情况下，我们将捕获该异常。 在第一种情况下，一切都变得更加有趣。 转到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MSDN</a> ： <br><br><blockquote>  “您不能捕获堆栈溢出异常，因为异常处理代码可能需要堆栈。” <br>  MSDN </blockquote><br> 它在这里说，我们将无法捕获StackOverflowException，因为拦截本身可能需要已经结束的额外堆栈空间。 <br><br> 为了以某种方式防止此异常，我们可以执行以下操作。 首先，您可以限制递归的深度。 其次，可以使用RuntimeHelpers类的方法： <br><br><blockquote>  RuntimeHelpers.EnsureSufficientExecutionStack（）; <br><br><ul><li>  “确保剩余的堆栈空间足够大，可以执行平均的.NET Framework函数。”  -MSDN <br></li><li>  InsufficientExecutionStackException <br></li><li>  512 KB-x86，AnyCPU，2 MB-x64（堆栈大小的一半） <br></li><li>  64/128 KB-.NET Core <br></li><li> 仅检查堆栈地址空间 <br></li></ul><br></blockquote><br> 此方法的文档说，它检查堆栈上是否有足够的空间来执行<i>一般的</i> .NET函数。 但是<i>平均</i>函数是多少？ 实际上，在.NET Framework中，此方法验证其大小的至少一半是否在堆栈上可用。 在.NET Core中，它将免费检查64K。 <br><br> 一个类似的东西也出现在.NET Core中：RuntimeHelpers.TryEnsureSufficientExecutionStack（），它返回布尔值，而不是引发异常。 <br><br>  C＃7.2引入了在不使用不安全代码的情况下一起使用Span和stackallock的功能。 也许正因为如此，在代码中将更频繁地使用stackalloc，并且在使用它时有一种保护自己免受StackOverflow影响的方法，这是很有用的，它可以选择在哪里分配内存。 作为这种方法，提出<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了</a>一种方法<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来验证在栈</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">trystackalloc</a>构造<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上分配的可能性</a> 。 <br><br><pre> <code class="cs hljs">Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; span; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CanAllocateOnStack(size)) span = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> span = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size];</code> </pre><br> 返回MSDN上的StackOverflow文档 <br><br><blockquote> 相反，当<b>普通应用程序中</b>发生堆栈溢出时，公共语言运行时（CLR）将终止该进程。” <br>  MSDN <br></blockquote><br> 如果在StackOverflow期间存在“正常”应用程序，那么是否存在不正常的非正常应用程序？ 为了回答这个问题，您将必须从托管应用程序级别下降到CLR级别。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/186/516/64d/18651664dd1c1d1346e5377f0e0b3995.png"><br><br><blockquote>  “ <b>承载CLR</b>的应用程序可以更改默认行为，并指定CLR <b>卸载</b>发生异常<b>的应用程序域</b> ，但可以继续该过程。”  -MSDN <br>  StackOverflowException-&gt; AppDomainUnloadedException <br></blockquote><br> 承载CLR的应用程序可以重新定义堆栈溢出的行为，以便代替完成整个过程，而将应用程序域卸载到发生此溢出的流中。 因此，我们可以将StackOverflowException转换为AppDomainUnloadedException。 <br><br> 启动托管应用程序时，.NET运行时将自动启动。 但是您可以选择其他方式。 例如，编写一个非托管应用程序（使用C ++或其他语言），该应用程序将使用特殊的API来提高CLR并启动我们的应用程序。 内部运行CLR的应用程序称为CLR主机。 通过编写它，我们可以在运行时配置许多东西。 例如，替换内存管理器和线程管理器。 我们在生产中使用CLR主机来避免交换内存页面。 <br><br> 以下代码配置CLR主机，以便在StackOverflow期间卸载AppDomain（C ++）： <br><br><pre> <code class="cpp hljs">ICLRPolicyManager *policyMgr; pCLRControl-&gt;GetCLRManager(IID_ICLRPolicyManager, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**) (&amp;policyMgr)); policyMgr-&gt;SetActionOnFailure(FAIL_StackOverflow, eRudeUnloadAppDomain);</code> </pre><br> 这是逃避StackOverflow的好方法吗？ 大概不是。 首先，我们不得不编写我们不想做的C ++代码。 其次，我们必须更改C＃代码，以便可以引发StackOverflowException的函数在单独的AppDomain和单独的线程中执行。 我们的代码将立即变成这样的面条： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; InfiniteRecursion()); thread.Start(); thread.Join(); }); AppDomain.Unload(appDomain); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AppDomainUnloadedException) { }</code> </pre><br> 为了调用InfiniteRecursion方法，我们编写了很多行。 第三，我们开始使用AppDomain。 这几乎保证了一系列新问题。 包括例外。 考虑一个例子： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain( <span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomException()); System.Runtime.Serialization.SerializationException: Type <span class="hljs-string"><span class="hljs-string">'CustomException'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> not marked <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> serializable. at System.AppDomain.DoCallBack(CrossAppDomainDelegate callBackDelegate)</code> </pre><br> 由于我们的异常未标记为可序列化，因此我们的代码将带有Seri​​alizationException。 为了解决此问题，仅用Serializable属性标记异常是不够的，我们仍然需要实现一个额外的构造函数以进行序列化。 <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext ctx</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">info, context</span></span></span><span class="hljs-function">)</span></span>{} } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomException());</code> </pre><br> 事实证明，它并不是很漂亮，所以我们走得更远-达到操作系统和黑客的水平，这不应在生产中使用。 <br><br><h2>  Seh / veh </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/2c5/7a2/aff/2c57a2aff0542b2a02ad8ab34d097412.png"><br><br> 请注意，虽然托管例外在托管和CLR之间运行，但SEH例外在CLR和Windows之间飞行。 <br><br>  SEH-结构化异常处理 <br><br><ul><li>  Windows异常处理引擎 <br></li><li> 统一的软件和硬件异常处理 <br></li><li> 在SEH之上实现的C＃异常 <br></li></ul><br>  SEH是Windows中的异常处理机制，它使您能够同样统一地处理任何异常，例如，来自处理器级别或与应用程序本身的逻辑相关联的异常。 <br><br>  Rantime .NET知道SEH异常并将其转换为托管异常： <br><br><ul><li>  EXCEPTION_STACK_OVERFLOW-&gt;崩溃 <br></li><li>  EXCEPTION_ACCESS_VIOLATION-&gt; AccessViolationException <br></li><li>  EXCEPTION_ACCESS_VIOLATION-&gt; NullReferenceException <br></li><li>  EXCEPTION_INT_DIVIDE_BY_ZERO-&gt; DivideByZeroException <br></li><li> 未知的SEH例外-&gt; SEHException <br></li></ul><br> 我们可以通过WinApi与SEH进行交互。 <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExceptionCode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExceptionFlags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nNumberOfArguments,IntPtr lpArguments</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// DivideByZeroException RaiseException(0xc0000094, 0, 0, IntPtr.Zero); // Stack overflow RaiseException(0xc00000fd, 0, 0, IntPtr.Zero);</span></span></code> </pre><br>   ,  throw    SEH. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> -&gt; RaiseException(<span class="hljs-number"><span class="hljs-number">0xe0434f4d</span></span>, ...)</code> </pre><br>   ,    CLR-exception     ,        ,    . <br><br> VEH —    ,  SEH,     ,      .  SEH     try-catch,  VEH      .            ,     .   VEH —  ,     SEH-  ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b8/79d/848/7b879d848390b9e3d1b9156b00b8e2bf.png"><br><br>           ,    SEH-     EXCEPTION_STACK_OVERFLOW   ,   .NET   . <br><br>  VEH    WinApi: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">, SetLastError = true)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddVectoredExceptionHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr FirstHandler,  VECTORED_EXCEPTION_HANDLER VectoredHandler</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> VEH : <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> { EXCEPTION_CONTINUE_SEARCH = <span class="hljs-number"><span class="hljs-number">0</span></span>, EXCEPTION_EXECUTE_HANDLER = <span class="hljs-number"><span class="hljs-number">1</span></span>, EXCEPTION_CONTINUE_EXECUTION = <span class="hljs-number"><span class="hljs-number">-1</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EXCEPTION_POINTERS { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EXCEPTION_RECORD* ExceptionRecord; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IntPtr Context; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EXCEPTION_RECORD { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> ExceptionCode; ... }</code> </pre><br>  Context          .     EXCEPTION_RECORD   ExceptionCode  .        ,   CLR    .    : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.ExceptionRecord == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_CONTINUE_SEARCH; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> record = e. ExceptionRecord; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record-&gt;ExceptionCode != ExceptionStackOverflow) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_CONTINUE_SEARCH; record-&gt;ExceptionCode = <span class="hljs-number"><span class="hljs-number">0x01234567</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_EXECUTE_HANDLER; }</code> </pre><br>   ,       HandleSO,     ,      StackOverflowException (        WinApi    ). <br><br><pre> <code class="cs hljs">HandleSO(() =&gt; InfiniteRecursion()) ; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T HandleSO&lt;T&gt;(Func&lt;T&gt; action) { Kernel32. AddVectoredExceptionHandler(IntPtr.Zero, Handler); Kernel32.SetThreadStackGuarantee(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> size); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) when ((<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>) Marshal. GetExceptionCode() == <span class="hljs-number"><span class="hljs-number">0x01234567</span></span>) {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(T); } HandleSO(() =&gt; InfiniteRecursion());</code> </pre><br>      SetThreadStackGuarantee.         StackOverflow. <br><br>          .          ,      . <br><br> ,  ,   HandleSO    ? <br><br><pre> <code class="cs hljs">HandleSO(() =&gt; InfiniteRecursion()); HandleSO(() =&gt; InfiniteRecursion());</code> </pre><br>   AccessViolationException.    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/639/e93/c8d/639e93c8d187dc31fc37a2ac7247f193.png"><br>      .       ,   Guard page.          – STATUS_GUARD_PAGE_VIOLATION,   Guard page   .     ,         –           stack-pointer    ,   .   —  AccessViolationException.        StackOverflow – c     –   _resetstkoflw    C (msvcrt.dll). <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"msvcrt.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _resetstkoflw();</code> </pre><br>     AccessViolationException  .NET Core  Windows,     .               ,   .NET Core   VEH   AccessViolation.         AddVectoredExceptionHandler: <br><br><pre> <code class="cs hljs">Kernel32.AddVectoredExceptionHandler(FirstHandler: (IntPtr) <span class="hljs-number"><span class="hljs-number">1</span></span>, handler);</code> </pre><br>   ,   : <br><br><ul><li>    ,  ; <br></li><li>     ; <br></li><li>       ; <br></li><li>          .NET   ,    . <br></li></ul><br><h2> 参考文献 </h2><br> → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">    </a> <br> → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dotnext 2016 Moscow — Adam Sitnik — Exceptional Exceptions in .NET</a> <br> → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DotNetBook: Exceptions</a> <br> → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">.NET Inside Out Part 8 — Handling Stack Overflow Exception in C# with VEH</a> —    StackOverflow. <br><br><blockquote> 22-23     <b>DotNext 2018 Moscow</b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">« :   »</a> .       ,  ,        .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> ,    — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN426045/">https://habr.com/ru/post/zh-CN426045/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN426029/index.html">您是否放弃并想要退出任务？ 这就是有效的开发人员培训的样子</a></li>
<li><a href="../zh-CN426031/index.html">担心使用人工智能捕获世界可能是基于不科学的假设</a></li>
<li><a href="../zh-CN426033/index.html">数学泰坦在abc假设的史诗证明上发生冲突</a></li>
<li><a href="../zh-CN426039/index.html">紧急发射“联盟MS-10”（船员获救，广播结束）</a></li>
<li><a href="../zh-CN426041/index.html">使用SymPy的Laplace变换方法对线性微分方程和系统的符号解</a></li>
<li><a href="../zh-CN426047/index.html">英语初学者的10本好书</a></li>
<li><a href="../zh-CN426051/index.html">改善软件调试技能-一些技巧</a></li>
<li><a href="../zh-CN426053/index.html">事件处理程序缓存和React应用程序性能改进</a></li>
<li><a href="../zh-CN426055/index.html">TensorFlow.js和clmtrackr.js：在浏览器中跟踪用户凝视的方向</a></li>
<li><a href="../zh-CN426059/index.html">Tutu PHP聚会＃2：演讲视频</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>