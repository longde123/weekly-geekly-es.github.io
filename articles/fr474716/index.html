<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🤝‍👨🏻 👨🏾‍✈️ 💷 Bugs C ++ 20. Résultats de la réunion à Belfast 🏯 👿 🤵🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'autre jour, il y a eu une réunion du comité de normalisation du langage de programmation C ++ à Belfast. Environ 400 commentaires sur le C ++ 20 ont...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bugs C ++ 20. Résultats de la réunion à Belfast</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/474716/">  L'autre jour, il y a eu une réunion du comité de normalisation du langage de programmation C ++ à Belfast.  Environ 400 commentaires sur le C ++ 20 ont été envoyés par les représentants des pays au comité, et la moitié d'entre eux ont réussi à y faire face. <br><br>  Sous la coupe, vous attendez les résultats des discussions des commentaires russes (oui, VOS commentaires sur C ++ 20), quelques commentaires d'autres pays, et bien sûr le nouveau C ++ 23 approprié (Executors!). <br><a name="habracut"></a><br>  Tous ces problèmes avec C ++ que les gens ont mentionnés sur le site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stdcpp.ru</a> , dans le chat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@ProCxx</a> , au travail dans Yandex.Taxi, ou en personne lors de conférences, nous les avons formalisés sous forme de commentaires sur C ++ 20.  Et donc qu'est-ce qui en est arrivé ... <br><br><h3>  std :: atomic &lt;int&gt; a {};  et std :: atomic &lt;int&gt; b; </h3><br>  Cela peut sembler étrange, mais les variables <b>a</b> et <b>b</b> ne <b>sont</b> pas initialisées à 0. Pour initialiser une variable atomique à zéro, il a fallu écrire std :: atomic &lt;int&gt; avec {0}; <br><br>  Ce comportement n'est pas du tout évident et de nombreux développeurs se sont brûlés.  Le comité a accepté notre remarque sur la norme, et en C ++ 20, les constructeurs par défaut pour std :: atomic_flag et std :: atomic initialiseront les variables en <i>clair</i> et T (), respectivement. <br><br><h3>  std :: launder </h3><br>  À partir de C ++ 17, la norme a une fonction effrayante std :: launder.  Les membres du comité pensaient que les développeurs de bibliothèques standard et les utilisateurs ordinaires sauraient comment y faire face. <br><br>  En pratique, il s'est avéré que dans certains cas, cette fonction ne pouvait pas être utilisée.  Il est extrêmement évident qu'il est nécessaire en principe: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;C&gt; v = {C{<span class="hljs-number"><span class="hljs-number">1</span></span>}}; v.pop_back(); v.push_back(C{<span class="hljs-number"><span class="hljs-number">2</span></span>}); assert(v.back().c == <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ]:-&gt;</span></span></code> </pre> <br>  Si vous suivez strictement la lettre de la norme, en fonction de l'implémentation de la bibliothèque standard, des fonctionnalités du compilateur et de la phase de lune, assert peut réussir ou échouer. <br><br>  En discutant du problème, il s'est avéré que l'optimisation, pour le bien de laquelle la norme décrivait un comportement aussi étrange, n'était implémentée que dans l'un des compilateurs et n'apportait pas une amélioration tangible des performances. <br><br>  Donc, à partir de C ++ 20, vous pouvez stocker en toute sécurité des structures avec des liens et des champs constants dans std :: optional, std :: variant, std :: vector, std :: deque, etc. Maintenant, placement new applique automatiquement une partie de la logique std: : blanchiment. <br><br><h3>  * ceci chez les constructeurs </h3><br>  C'est l'un des commentaires où un échec nous attendait: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> C(C&amp;&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : initial_(other.initial_) , secondary_(other.initial_) <span class="hljs-comment"><span class="hljs-comment">// O_O {} int initial_; int secondary_; };</span></span></code> </pre><br>  Selon les règles actuelles, dans la ligne avec <b>O_O, le</b> compilateur a le droit de supposer que &amp; other == this et, en conséquence, une ligne ci-dessus, nous avons réécrit la valeur de other.initial_ et elle doit être relue. <br><br>  En d'autres termes, le compilateur a le droit de supposer qu'une classe qui n'a pas encore été créée est aliasée avec le paramètre à partir duquel l'objet est construit, et à cause de cela, il peut générer du code non optimal. <br><br>  Certains compilateurs (par exemple, GCC), croient que les utilisateurs n'écrivent pas une telle honte et pensent que l'aliasing n'est pas possible. <br><br>  Le comité a rejeté notre remarque «Supposons que le repliement ne soit pas possible».  Il s'est avéré que certaines bases de code ont des hacks effrayants où &amp; autres == cela, et les gens ne sont pas encore prêts à leur dire au revoir. <br><br><h3>  opérateur &lt;=&gt; et programmation intégrée </h3><br>  Pour que l'opérateur du vaisseau spatial fonctionne, vous avez besoin du fichier d'en-tête &lt;compare&gt;.  Cependant, il ne figurait pas dans la liste des fichiers d'en-tête disponibles sur toutes les plates-formes (sur les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">implémentations</a> dites <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autonomes de la</a> bibliothèque standard qui peuvent être utilisées sur n'importe quel fer). <br><br>  Maintenant, c'est sur la liste :) <br><br><h3>  Le reste </h3><br>  Selon nos autres commentaires, le verdict «Pas en C ++ 20» a été rendu: <br>  * Nous voulions que __func__ soit utilisé dans constexpr. <br>  * Nous voulions que le concept n'utilise pas le type incomplet, car sinon vous obtenez plusieurs violations ODR.  Mais la remarque a eu un effet positif inattendu: les compilateurs émettent désormais un avertissement si vous utilisez le type incomplet dans require. <br>  * Nous voulions corriger l'opérateur d'affectation pour std :: string afin qu'un tel désordre ne se produise pas: <br><br><pre> <code class="cpp hljs">basic_string::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(charT c): <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d = <span class="hljs-number"><span class="hljs-number">3.14</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; s = d; <span class="hljs-comment"><span class="hljs-comment">// Compiles</span></span></code> </pre><br>  Le comité a suggéré d'écrire un document séparé et de le corriger après C ++ 20. <br>  * Nous voulions tuer l'affectation des lignes temporaires dans std :: string_view: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view sv; sv = foo(); <span class="hljs-comment"><span class="hljs-comment">// Compiles... dangling reference</span></span></code> </pre><br>  Le résultat est le même que la remarque précédente: le comité a suggéré d'écrire un document séparé et de le corriger après C ++ 20. <br>  * Nous avons demandé que le code suivant soit compilé: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt; template &lt;typename... Xs&gt; auto f (Xs...) -&gt; std::invoke_result_t&lt;Xs...&gt;;</span></span></span></span></code> </pre><br>  On nous a dit que tout est compliqué, il n'y a pratiquement aucune chance de réparer C ++ 20. <br><br><h2>  Commentaires d'autres pays </h2><br>  Des changements importants: ajout de constructeurs pour std :: span à partir de types qui satisfont le concept de plages :: contiguous_range.  Alors maintenant, span peut être implicitement créé à partir de std :: vector et std :: string.  Nous avons également ajouté le constructeur std :: string_view de deux itérateurs qui satisfont le concept de range :: contiguous_iterator. <br><br>  Des modifications amusantes attendaient &lt;compare&gt;.  Au cours des trois dernières années, l'opérateur &lt;=&gt; a beaucoup changé.  Il ne participe plus aux comparaisons d'égalité et, en conséquence, un tiers du contenu de &lt;comparer&gt; n'est plus nécessaire.  Plusieurs pays l'ont remarqué - ils ont abaissé la norme. <br><br>  Un grand changement s'est glissé dans des paramètres de modèle non-type.  En C ++ 20, il sera possible de passer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">presque toutes les classes (voir P1907)</a> avec un destructeur constexpr et des membres publics comme paramètre de modèle, même si la classe contient des types ou des liens à virgule flottante. <br><br>  Nous avons également ajouté le const manquant à différentes parties de la norme, changé les noms et l'ordre des arguments de certaines fonctions nouvelles en C ++ 20.  Il existe également de nombreuses modifications pour les concepts et les plages, les abréviations du texte standard et d'autres petites choses. <br><br><h2>  Numéros TS </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">ZaMaZaN4iK</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">moi avons</a> pu remuer le comité avec le document C ++ Numerics Work In Progress.  Il existe maintenant des plans napoléoniens pour C ++ 23 pour donner aux utilisateurs un ensemble de nouveaux types de nombres (wide_integer, entier, rationnel), ainsi que des méthodes auxiliaires de bas niveau pour travailler avec les débordements et les alias pratiques. <br><br>  On m'a dit de préparer une présentation pour la prochaine réunion avec une introduction aux idées pour l'ensemble du comité. <br><br><h2>  Exécuteurs </h2><br>  Les exécuteurs sont l'une des priorités de C ++ 23.  Ils sont nécessaires à la programmation réactive, à la programmation asynchrone (réseau, disque, processus ...), ils sont à la base du délestage de coroutine et devraient fournir une interface unique pour les bibliothèques tierces. <br><br>  Dans le même temps, les exécuteurs devraient optimiser les algorithmes pour leur implémentation interne.  Par exemple, pour le code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::input_range Range&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MySort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Range&amp; data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> stdr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ranges; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(GetGlobalExecutor(), stdr::begin(data), stdr::end(data), <span class="hljs-number"><span class="hljs-number">42</span></span>); }</code> </pre><br>  la fonction GetGlobalExecutor () peut retourner: <br>  * exécuteur monothread - il devrait exécuter le std :: sort habituel sur son thread; <br>  * exécuteur multithread - il doit effectuer un tri parallèle; <br>  * Exécuteur GPU - il doit déplacer les données vers la mémoire de la carte vidéo, les trier là et renvoyer les données; <br>  * Exécuteur NUMA - ... <br>  * ... <br><br>  Jusqu'à présent, pour implémenter une telle fonctionnalité, vous devez faire des objets de point de personnalisation (CPO) effrayants, transformer chaque algorithme en eux.  Le comité n'a pas aimé ... <br><br>  Mais au moins, ils ont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pré-approuvé le P0443</a> - l'interface de base.  Toutes les phrases suivantes pour les exécuteurs devront être écrites sous forme de correctifs pour P0443. <br><br><h2>  Au lieu de totaux </h2><br>  Maintenant, nous sommes séparés du C ++ 20 par une seule réunion de comité.  Encore un peu ... <br><br>  Eh bien, tous ceux qui veulent discuter avec des représentants du comité en direct - regardez les mitaps et les conférences C ++ <i>(*)</i> : <br>  * <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Corehard à Minsk</a> <br>  * <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++ Sibérie 2020</a> <br>  * <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++ Russie 2020</a> <br>  * <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">St.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Petersburg C ++ User Group</a> <br>  * <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Meetup C ++ 2019 à Moscou</a> <br><br>  <i>(*) Life hack: vous n'êtes pas obligé de payer un ticket de conférence si vous êtes conférencier.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474716/">https://habr.com/ru/post/fr474716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474706/index.html">Algorithme de recherche floue TextRadar - Approches de base</a></li>
<li><a href="../fr474708/index.html">Internet est plus fragmenté que jamais: où plus d'un million de nouveaux utilisateurs «viennent» quotidiennement? Partie 1</a></li>
<li><a href="../fr474710/index.html">c.tech: Frontend Meetup # 2</a></li>
<li><a href="../fr474712/index.html">Udalenka en informatique: expérience personnelle</a></li>
<li><a href="../fr474714/index.html">Caractéristiques du commerce de détail national, ou comment j'ai testé la force de la technologie française</a></li>
<li><a href="../fr474718/index.html">Sécurité dans l'électronique automobile - Hello World sur le contrôleur de tableau de bord</a></li>
<li><a href="../fr474720/index.html">Laboratoire radio de Nizhny Novgorod et «cristadins» de Losev</a></li>
<li><a href="../fr474722/index.html">«Personne ne dit aux autres ce qu'ils doivent faire»: Nicolò Ribaudo sur le développement de Babel et plus</a></li>
<li><a href="../fr474724/index.html">Qu'adviendra-t-il de PHP dans 5 ans: nous avons demandé aux intervenants du mitap de Moscou le plus proche</a></li>
<li><a href="../fr474726/index.html">Même les enfants comprendront: une explication simple de l'async / wait et des promesses en JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>