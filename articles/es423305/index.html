<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç¢ üñ±Ô∏è üèåÔ∏è Rendimiento de la ruina üîí üí™üèª ‚ùì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta nota es una versi√≥n escrita de mi informe "C√≥mo arruinar el rendimiento con c√≥digo ineficiente" de la conferencia JPoint 2018. Puede ver videos y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rendimiento de la ruina</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423305/"><p>  Esta nota es una versi√≥n escrita de mi informe "C√≥mo arruinar el rendimiento con c√≥digo ineficiente" de la conferencia JPoint 2018. Puede ver videos y diapositivas en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la p√°gina de la conferencia</a> .  En el calendario, el informe est√° marcado con un vaso ofensivo de batidos, por lo que no habr√° nada s√∫per complicado, esto es m√°s probable para los principiantes. </p><br><p>  Asunto del informe: </p><br><ul><li>  c√≥mo mirar el c√≥digo para encontrar cuellos de botella </li><li>  antipatrones comunes </li><li>  rastrillo no obvio </li><li>  rastrillo de derivaci√≥n </li></ul><br><p>  Al margen, se√±alaron algunas imprecisiones / omisiones en el informe, se mencionan aqu√≠.  Los comentarios tambi√©n son bienvenidos. </p><a name="habracut"></a><br><h2 id="vliyanie-poryadka-ispolneniya-na-proizvoditelnost">  Impacto en el rendimiento en el rendimiento </h2><br><p>  Hay una clase de usuario: </p><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ String name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; }</code> </pre> <br><p>  Necesitamos comparar los objetos entre s√≠, por lo que declaramos los m√©todos <code>equals</code> y <code>hashCode</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.EqualsAndHashCode; <span class="hljs-meta"><span class="hljs-meta">@EqualsAndHashCode</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ String name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; }</code> </pre> <br><p>  El c√≥digo es viable, la pregunta es diferente: ¬øser√° el mejor rendimiento de este c√≥digo?  Para responderlo, recordemos las caracter√≠sticas del m√©todo <code>Object::equals</code> : devuelve un resultado positivo solo cuando todos los campos que se comparan son iguales; de lo contrario, el resultado ser√° negativo.  En otras palabras, una diferencia ya es suficiente para un resultado negativo. </p><br><p>  Despu√©s de mirar el c√≥digo generado para <code>@EqualsAndHashCode</code> veremos algo como esto: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object that)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... if (name == null &amp;&amp; that.name != null) { return false; } if (name != null &amp;&amp; !name.equals(that.name)) { return false; } return age == that.age; }</span></span></code> </pre> <br><p>  El orden de verificaci√≥n de los campos corresponde al orden de su declaraci√≥n, que en nuestro caso no es la mejor soluci√≥n, porque comparar objetos usando <code>equals</code> "m√°s dif√≠cil" que comparar tipos simples. </p><br><p>  Ok, intentemos crear m√©todos <code>equals/hashCode</code> usando la Idea: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } User that = (User) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> age == that.age &amp;&amp; Objects.equals(name, that.name); }</code> </pre> <br><p>  Una idea crea un c√≥digo m√°s inteligente que conoce la complejidad de comparar diferentes tipos de datos.  Bueno, <code>@EqualsAndHashCode</code> y escribiremos expl√≠citamente <code>equals/hashCode</code> .  Ahora veamos qu√© sucede cuando la clase se extiende: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ List&lt;T&gt; props; String name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; }</code> </pre> <br><p>  Recreando <code>equals/hashCode</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } User that = (User) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> age == that.age &amp;&amp; Objects.equals(props, that.props) <span class="hljs-comment"><span class="hljs-comment">// &lt;---- &amp;&amp; Objects.equals(name, that.name); }</span></span></code> </pre> <br><p>  Las listas se comparan antes de comparar cadenas, lo que no tiene sentido cuando las cadenas son diferentes.  A primera vista, no hay mucha diferencia, porque las cadenas de igual longitud se comparan mediante signos (es decir, el tiempo de comparaci√≥n crece junto con la longitud de la cadena): </p><br><div class="spoiler">  <b class="spoiler_title">Hubo una inexactitud</b> <div class="spoiler_text"><p>  El <a href="">m√©todo</a> <code>java.lang.String::equals</code> <a href="">es intrusivo</a> , por lo que no hay comparaci√≥n de inicio de sesi√≥n en la ejecuci√≥n. </p></div></div><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//java.lang.String public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String) anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { // &lt;---- if (v1[i] != v2[i]) return false; i++; } return true; } } return false; }</span></span></code> </pre> <br><p>  Ahora considere comparar dos <code>ArrayList</code> (como la implementaci√≥n de lista m√°s utilizada).  Examinando <code>ArrayList</code> , nos sorprende descubrir que no tiene su propia implementaci√≥n de <code>equals</code> , sino que usa una implementaci√≥n heredada: </p><br><p><img src="https://habrastorage.org/webt/d4/hn/yg/d4hnyguezlpyxz3pgunk22ha1cm.png"></p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//AbstractList::equals public boolean equals(Object o) { if (o == this) { return true; } if (!(o instanceof List)) { return false; } ListIterator&lt;E&gt; e1 = listIterator(); ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator(); while (e1.hasNext() &amp;&amp; e2.hasNext()) { // &lt;---- E o1 = e1.next(); Object o2 = e2.next(); if (!(o1 == null ? o2 == null : o1.equals(o2))) { return false; } } return !(e1.hasNext() || e2.hasNext()); }</span></span></code> </pre> <br><p>  Importante aqu√≠ es la creaci√≥n de dos iteradores y el paso por pares a trav√©s de ellos.  Supongamos que hay dos <code>ArrayList</code> : </p><br><ul><li>  en un n√∫mero del 1 al 99 </li><li>  en el segundo n√∫mero del 1 al 100 </li></ul><br><p>  Idealmente, ser√≠a suficiente comparar los tama√±os de las dos listas y, si no coinciden, devolver√° inmediatamente un resultado negativo (como lo hace <code>AbstractSet</code> ), en realidad, se realizar√°n 99 comparaciones y solo en la cent√©sima parte quedar√° claro que las listas son diferentes. </p><br><h4 id="chyo-tam-u-kotlinovcev">  ¬øQu√© hay con los kotlinitas? </h4><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>);</code> </pre> <br><p>  Aqu√≠ todo es como un Lombok: el orden de comparaci√≥n corresponde al orden del anuncio: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> User) { User u = (User) o; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Intrinsics.areEqual(name, u.name) &amp;&amp; age == u.age) { <span class="hljs-comment"><span class="hljs-comment">// &lt;---- return true; } } return false; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øC√≥mo mejorar la situaci√≥n?</b>  <b class="spoiler_title">- quejarse!</b> <div class="spoiler_text"><p>  IDEA-170178 La comparaci√≥n de colecciones se debe ejecutar al final de los iguales generados por IDEA () <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-170178</a> </p><br><p>  Reordenaci√≥n de la comparaci√≥n en @EqualsAndHashCode para un mejor rendimiento # 1543 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/rzwitserloot/lombok/issues/1543</a> </p><br><p>  KT-23184 Igual autogenerado () de clase de datos no es √≥ptimo <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://youtrack.jetbrains.com/issue/KT-23184</a> </p></div></div><br><p>  Como soluci√≥n alternativa, puede organizar manualmente las declaraciones de campo. </p><br><h4 id="uslozhnim-zadachu">  Vamos a complicar la tarea. </h4><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dto dto)</span></span></span><span class="hljs-function"> </span></span>{ SomeEntity entity = jpaRepository.findOne(dto.getId()); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> valid = dto.isValid(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valid &amp;&amp; entity.hasGoodRating()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;---- //do smth } }</span></span></code> </pre> <br><p>  El c√≥digo implica acceder a la base de datos incluso cuando el resultado de verificar las condiciones indicadas por la flecha es predecible de antemano.  Si el valor de la variable <code>valid</code> es falso, entonces el c√≥digo en el bloque <code>if</code> nunca se ejecutar√°, lo que significa que puede prescindir de una solicitud: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dto dto)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> valid = dto.isValid(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valid &amp;&amp; hasGoodRating(dto)) { <span class="hljs-comment"><span class="hljs-comment">//do smth } } //       ,    boolean hasGoodRating(Dto dto) { SomeEntity entity = jpaRepository.findOne(dto.getId()); return entity.hasGoodRating(); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Nota desde el margen</b> <div class="spoiler_text"><p>  El hundimiento puede ser insignificante cuando la entidad devuelta desde <code>JpaRepository::findOne</code> ya <code>JpaRepository::findOne</code> en el cach√© del primer nivel, entonces no habr√° ninguna solicitud. </p></div></div><br><p>  Un ejemplo similar sin ramificaci√≥n expl√≠cita: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dto dto)</span></span></span><span class="hljs-function"> </span></span>{ Long id = dto.getId(); Entity entity = jpaRepository.findOne(id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dto.isValid() &amp;&amp; entity.hasChild(); }</code> </pre> <br><p>  Un retorno r√°pido le permite retrasar la solicitud: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dto dto)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dto.isValid()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jpaRepository.findOne(dto.getId()).hasChild(); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Una adici√≥n bastante obvia que no apareci√≥ en el informe</b> <div class="spoiler_text"><p>  Imagine que un cierto cheque usa una entidad similar: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span>(fetch = LAZY) <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CHILD_ID"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ChildEntity child; <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.String) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SomeType type;</code> </pre> <br><p>  Si la verificaci√≥n utiliza la misma entidad, debe asegurarse de que la llamada a las entidades / colecciones secundarias "perezosas" se realice despu√©s de la llamada a los campos que ya est√°n cargados.  A primera vista, una solicitud adicional no tendr√° un impacto significativo en la imagen general, pero todo puede cambiar cuando una acci√≥n se realiza en un bucle. </p></div></div><br><p>  Conclusi√≥n: las cadenas de acciones / verificaciones deben ordenarse en orden de complejidad creciente de las operaciones individuales, quiz√°s algunas de ellas no tendr√°n que realizarse. </p><br><h2 id="cikly-i-massovaya-obrabotka">  Ciclos y procesamiento a granel </h2><br><p>  El siguiente ejemplo no necesita explicaciones especiales: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enrollStudents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;Long&gt; ids)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Long id : ids) { Student student = jpaRepository.findOne(id); <span class="hljs-comment"><span class="hljs-comment">// &lt;---- O(n) enroll(student); } }</span></span></code> </pre> <br><p>  Debido a las m√∫ltiples consultas de la base de datos, el c√≥digo es lento. </p><br><div class="spoiler">  <b class="spoiler_title">Observaci√≥n</b> <div class="spoiler_text"><p>  El rendimiento puede <code>enrollStudents</code> a√∫n m√°s si el m√©todo <code>enrollStudents</code> ejecuta fuera de una transacci√≥n: entonces <strong>cada</strong> llamada a <code>osdjrJpaRepository::findOne</code> se ejecutar√° en una nueva transacci√≥n (ver <a href="">SimpleJpaRepository</a> ), lo que significa recibir y devolver una conexi√≥n a la base de datos, as√≠ como crear y vaciar el cach√© de primer nivel. </p></div></div><br><p>  Arreglo: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enrollStudents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;Long&gt; ids)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ids.isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Student student : jpaRepository.findAll(ids)) { enroll(student); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Midamos el tiempo de ejecuci√≥n (en microsegundos) para una colecci√≥n de claves (10 y 100 piezas)</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/p2/0b/zq/p20bzq2tlnp3-mj8zlx8c96411e.png"></p></div></div><br><p>  <a href="">Punto de referencia</a> </p><br><div class="spoiler">  <b class="spoiler_title">Observaci√≥n</b> <div class="spoiler_text"><p>  Si usa Oracle y pasa m√°s de 1000 claves para <code>findAll</code> , obtendr√° la excepci√≥n <code>ORA-01795: maximum number of expressions in a list is 1000</code> . <br>  Adem√°s, realizar una gran cantidad de consultas (con muchas claves) puede ser peor que n consultas.  Todo depende de la aplicaci√≥n espec√≠fica, por lo que el reemplazo mec√°nico del ciclo para el procesamiento en masa puede degradar el rendimiento. </p></div></div><br><h4 id="bolee-slozhnyy-primer-na-tu-zhe-temu">  Un ejemplo m√°s complejo sobre el mismo tema. </h4><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Long id : ids) { Region region = jpaRepository.findOne(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;----  region = new Region(); region.setId(id); } use(region); }</span></span></code> </pre> <br><p>  En este caso, no podemos reemplazar el bucle con <code>JpaRepository::findAll</code> , <code>JpaRepository::findAll</code> esto romper√° la l√≥gica: todos los valores obtenidos de <code>JpaRepository::findAll</code> no ser√°n <code>null</code> y el bloque <code>if</code> no funcionar√°. </p><br><p>  El hecho de que para cada clave de base de datos nos ayudar√° a resolver esta dificultad <br>  devuelve el valor real o su ausencia.  Es decir, en cierto sentido, una base de datos es un diccionario.  Java desde el cuadro nos da una implementaci√≥n lista para usar del diccionario, <code>HashMap</code> , sobre la cual construiremos la l√≥gica para reemplazar la base de datos: </p><br><pre> <code class="java hljs">Map&lt;Long, Region&gt; regionMap = jpaRepository.findAll(ids) .stream() .collect(Collectors.toMap(Region::getId, Function.identity())); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Long id : ids) { Region region = map.get(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { region = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Region(); region.setId(id); } use(region); }</code> </pre> <br><h4 id="primer-v-obratnuyu-storonu">  Ejemplo inverso </h4><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// class Saver @Transactional(propagation = Propagation.REQUIRES_NEW) public void save(List&lt;AuditEntity&gt; entities) { jpaRepository.save(entities); }</span></span></code> </pre> <br><p>  Este c√≥digo siempre crea una nueva transacci√≥n para guardar una lista de entidades.  La flacidez comienza con m√∫ltiples llamadas a un m√©todo que abre una nueva transacci√≥n: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   @Transactional public void audit(List&lt;AuditDto&gt; inserts) { inserts.map(this::toEntities).forEach(saver::save); // &lt;---- } // class Saver @Transactional(propagation = Propagation.REQUIRES_NEW) // &lt;---- public void save(List&lt;AuditEntity&gt; entities) { jpaRepository.save(entities); }</span></span></code> </pre> <br><p>  Soluci√≥n: aplique el m√©todo <code>Saver::save</code> inmediatamente para todo el conjunto de datos: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">audit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;AuditDto&gt; inserts)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;AuditEntity&gt; bulk = inserts .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::toEntities) .flatMap(List::stream) <span class="hljs-comment"><span class="hljs-comment">// &lt;---- .collect(toList()); saver.save(bulk); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Muchas transacciones se fusionan en una sola, lo que da un aumento tangible (tiempo en microsegundos):</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/f7/3r/n9/f73rn9gtjw7fdgiqrfwkq7tfme4.png"></p></div></div><br><p>  <a href="">Punto de referencia</a> </p><br><p>  Es dif√≠cil formalizar un ejemplo con transacciones m√∫ltiples, lo que no se puede decir acerca de llamar a <code>JpaRepository::findOne</code> en un bucle. </p><br><div class="spoiler">  <b class="spoiler_title">Por lo tanto, tomaremos medidas</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-165730</a> <br>  IDEA-165730 Advierta sobre el uso ineficiente de JpaRepository </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-165942</a> <br><del>  IDEA-165942 </del>  Inspecci√≥n para reemplazar la llamada al m√©todo en un bucle con operaci√≥n masiva <br>  <strong>Fijo en 2017.1</strong> </p></div></div><br><p>  El enfoque es aplicable no solo a la base de datos, por lo que Tagir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">lany</a> Valeev fue m√°s all√°.  Y si antes escribimos as√≠: </p><br><pre> <code class="java hljs">List&lt;Long&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Long id : items) { list.add(id); }</code> </pre> <br><p>  y todo estaba bien, ahora la "Idea" sugiere corregirse a s√≠ misma: </p><br><pre> <code class="java hljs">List&lt;Long&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); list.addAll(items);</code> </pre> <br><p>  Pero incluso esta opci√≥n no siempre lo satisface, porque puede hacerlo a√∫n m√°s corto y m√°s r√°pido: </p><br><pre> <code class="java hljs">List&lt;Long&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(items);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Comparar (tiempo en ns)</b> <div class="spoiler_text"><p>  Para ArrayList, esta mejora proporciona un aumento notable: </p><br><p><img src="https://habrastorage.org/webt/gi/6j/o8/gi6jo8xwigpdckqz6jtuw4cmane.png"></p><br><p>  Para HashSet, no es tan color de rosa: </p><br><p><img src="https://habrastorage.org/webt/u9/lo/fy/u9lofyf2wy2hffk8gd0uwvrmmke.png"></p></div></div><br><p>  <a href="">Punto de referencia</a> </p><br><div class="spoiler">  <b class="spoiler_title">√ötil para el desarrollador:</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-138456</a> <br><del>  IDEA-138456 </del>  Nueva inspecci√≥n: Collection.addAll () reemplazable con constructor parametrizado <br>  <strong>Reparado en 142.1217</strong> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-178761</a> <br><del>  IDEA-178761 </del>  La inspecci√≥n 'Collection.addAll () reemplazable con el constructor parametrizado' debe estar activada por defecto <br>  <strong>Fijo en 2017.3</strong> </p></div></div><br><h4 id="udalenie-iz-arraylist-a">  Eliminar de <code>ArrayList</code> </h4><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = from; i &lt; to; i++) { list.remove(from); }</code> </pre> <br><p>  El problema est√° en implementar el m√©todo <code>List::remove</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> E </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ Objects.checkIndex(index, size); modCount++; E oldValue = elementData(index); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numMoved = size - index - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numMoved &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { System.arraycopy(array, index + <span class="hljs-number"><span class="hljs-number">1</span></span>, array, index, numMoved); <span class="hljs-comment"><span class="hljs-comment">// &lt;---- } array[--size] = null; // clear to let GC do its work return oldValue; }</span></span></code> </pre> <br><p>  Soluci√≥n: </p><br><pre> <code class="java hljs">list.subList(from, to).clear();</code> </pre> <br><p>  Pero, ¬øqu√© pasa si el valor remoto se usa en el c√≥digo fuente? </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = from; i &lt; to; i++) { E removed = list.remove(from); use(removed); }</code> </pre> <br><p>  Ahora primero debe pasar por la lista limpia: </p><br><pre> <code class="java hljs">List&lt;String&gt; removed = list.subList(from, to); removed.forEach(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::use); removed.clear();</code> </pre> <br><p>  Si realmente desea eliminar en el ciclo, un cambio en la direcci√≥n de paso por la lista ayudar√° a aliviar el dolor.  Su significado es cambiar un n√∫mero menor de elementos despu√©s de limpiar la celda: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   , . .       for (int i = from; i &lt; to; i++) { E removed = list.remove(from); use(removed, i); } //  , . .    for (int i = to - 1; i &gt;= from; i--) { E removed = list.remove(i); use(removed, reverseIndex(i)); }</span></span></code> </pre> <br><p>  Compare los tres m√©todos (debajo de las columnas hay% de elementos eliminados de una lista de tama√±o 100): </p><br><div class="spoiler">  <b class="spoiler_title">Java 8</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/4h/ii/tq/4hiitqg5a7d3bk6lxi8od422yky.png"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Java 9</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ow/mo/ty/owmotysgwdqquagklf1yhlrquz0.png"></p></div></div><br><p>  Por cierto, ¬øalguien not√≥ la anomal√≠a? </p><br><div class="spoiler">  <b class="spoiler_title">Para ver</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xm/ni/s9/xmnis9jllk8rozgh8xacdneyhd8.png"></p><br><p>  Si eliminamos la mitad de todos los datos que se mueven desde el final, entonces el √∫ltimo elemento siempre se elimina y no hay desplazamiento: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ArrayList public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) { // &lt;----     System.arraycopy(elementData, index+1, elementData, index, numMoved); } elementData[--size] = null; // clear to let GC do its work return oldValue; }</span></span></code> </pre> </div></div><br><p>  <a href="">Punto de referencia</a> </p><br><div class="spoiler">  <b class="spoiler_title">√ötil para el desarrollador</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-177466</a> <br><del>  IDEA-177466 </del>  Detectar List.remove (index) llamado en un bucle <br>  <strong>Fijo en 2018.2</strong> </p></div></div><br><p>  Conclusi√≥n: las operaciones en masa son a menudo m√°s r√°pidas que las operaciones individuales. </p><br><h2 id="oblast-vidimosti-i-proizvoditelnost">  Alcance y rendimiento </h2><br><p>  Este c√≥digo no necesita ninguna explicaci√≥n especial: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leaveForTheSecondYear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Student&gt; naughty = repository.findNaughty(); List&lt;Student&gt; underAchieving = repository.findUnderAchieving(); <span class="hljs-comment"><span class="hljs-comment">// &lt;---- if (settings.leaveBothCategories()) { leaveForTheSecondYear(naughty, underAchieving); // &lt;---- return; } leaveForTheSecondYear(naughty); }</span></span></code> </pre> <br><p>  Limitamos el alcance, lo que da menos 1 consulta: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leaveForTheSecondYear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Student&gt; naughty = repository.findNaughty(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Settings.leaveBothCategories()) { List&lt;Student&gt; underAchieving = repository.findUnderAchieving(); <span class="hljs-comment"><span class="hljs-comment">// &lt;---- leaveForTheSecondYear(naughty, underAchieving); // &lt;---- return; } leaveForTheSecondYear(naughty); }</span></span></code> </pre> <br><p>  Y aqu√≠ el atento lector deber√≠a preguntarse: ¬øqu√© pasa con el an√°lisis est√°tico?  ¬øPor qu√© Idea no nos cont√≥ sobre la mejora que yace en la superficie? </p><br><p>  El hecho es que las posibilidades de an√°lisis est√°tico son limitadas: si el m√©todo es complejo (especialmente interactuando con la base de datos) y afecta el estado general, la transferencia de su ejecuci√≥n puede interrumpir la aplicaci√≥n.  El analizador est√°tico puede informar ejecuciones muy simples, cuya transferencia, por ejemplo, dentro del bloque no interrumpir√° nada. </p><br><p>  Puede usar el resaltado variable como un error, pero nuevamente, √∫selo con cuidado, ya que los efectos secundarios siempre son posibles.  Puede usar la anotaci√≥n <code>@org.jetbrains.annotations.Contract(pure = true)</code> , disponible en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca de jetbrains-annotations</a> para indicar m√©todos que no cambian de estado: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// com.intellij.util.ArrayUtil @Contract(pure = true) public static int find(@NotNull int[] src, int obj) { return indexOf(src, obj); }</span></span></code> </pre> <br><p>  Conclusi√≥n: la mayor√≠a de las veces, el exceso de trabajo solo empeora el rendimiento. </p><br><h2 id="samyy-neobychnyy-primer">  Ejemplo m√°s inusual </h2><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RemoteService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ContractCounter contractCounter; <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span>(readOnly = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;---- public int countContracts(Dto dto) { if (dto.isInvalid()) { return -1; // &lt;---- } return contractCounter.countContracts(dto); } }</span></span></code> </pre> <br><p>  Esta implementaci√≥n abre una transacci√≥n incluso cuando la transacci√≥n no es necesaria (retorno r√°pido -1 del m√©todo). </p><br><p>  Todo lo que necesita hacer es eliminar la transaccionalidad dentro del <code>ContractCounter::countContracts</code> , donde sea necesario, y eliminarla del m√©todo "externo". </p><br><div class="spoiler">  <b class="spoiler_title">Compare el tiempo de ejecuci√≥n para el caso cuando se devuelve -1 (ns):</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/8k/uu/lp/8kuulppcl4vli1c5ir-txozcemi.png"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Comparar el consumo de memoria (bytes):</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xp/du/ke/xpdukewr4nnooj2vtaktok4ngnm.png"></p></div></div><br><p>  <a href="">Punto de referencia</a> </p><br><p>  Conclusi√≥n: los controladores y los servicios de aspecto "externo" necesitan ser liberados de la transaccionalidad (esto no es su responsabilidad) y la l√≥gica completa de la verificaci√≥n de datos de entrada, que no requiere acceso a la base de datos y componentes transaccionales, debe ser implementada. </p><br><h2 id="preobrazovanie-datyvremeni-v-stroku">  Convertir fecha / hora en cadena </h2><br><p>  Una de las tareas eternas es convertir la fecha / hora en una cadena.  Antes del G8, hicimos esto: </p><br><pre> <code class="java hljs">SimpleDateFormat formatter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleDateFormat(<span class="hljs-string"><span class="hljs-string">"dd.MM.yyyy"</span></span>); String dateAsStr = formatter.format(date);</code> </pre> <br><p>  Con el lanzamiento de JDK 8, obtuvimos <code>LocalDate/LocalDateTime</code> y, en consecuencia, <code>DateTimeFormatter</code> </p><br><pre> <code class="java hljs">DateTimeFormatter formatter = ofPattern(<span class="hljs-string"><span class="hljs-string">"dd.MM.yyyy"</span></span>); String dateAsStr = formatter.format(localDate);</code> </pre> <br><p>  Midamos su rendimiento: </p><br><pre> <code class="java hljs">Date date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(); LocalDate localDate = LocalDate.now(); SimpleDateFormat sdf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleDateFormat(<span class="hljs-string"><span class="hljs-string">"dd.MM.yyyy"</span></span>); DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="hljs-string"><span class="hljs-string">"dd.MM.yyyy"</span></span>); <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simpleDateFormat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sdf.format(date); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dateTimeFormatter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dtf.format(localDate); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Tiempo (ns):</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/zq/jq/sx/zqjqsxjevqpmuckdddvu4gysaoa.png"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Memoria (bytes):</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9j/yq/sw/9jyqswjtyiwq3i8fkutenvyuj7g.png"></p></div></div><br><p>  Pregunta: supongamos que nuestro servicio recibe datos del exterior y no podemos rechazar <code>java.util.Date</code> .  ¬øSer√≠a beneficioso para nosotros convertir <code>Date</code> a <code>LocalDate</code> si este √∫ltimo se convierte m√°s r√°pidamente en una cadena?  Calcular: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureDateConverted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ LocalDate localDate = toLocalDate(data.date); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data.dateTimeFormatter.format(localDate); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> LocalDate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toLocalDate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date date)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate(); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Tiempo (ns):</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/j5/ob/mf/j5obmfec_kvfivo46wat9rmf8e8.png"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Memoria (bytes):</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/hx/hm/on/hxhmon8ss12qyv9s4is6byoy164.png"></p></div></div><br><p>  Por lo tanto, la <code>Date</code> conversi√≥n -&gt; <code>LocalDate</code> beneficiosa cuando se usan los "nueve".  En G8, los costos de conversi√≥n engullir√°n todos los beneficios de <code>DateTimeFormatter</code> -a. </p><br><p>  <a href="">Punto de referencia</a> </p><br><p>  Conclusi√≥n: aproveche las nuevas soluciones. </p><br><h2 id="eschyo-vosmyorka">  Otro "ocho" </h2><br><p>  En este c√≥digo, vemos una redundancia obvia: </p><br><pre> <code class="java hljs">Iterator&lt;Long&gt; iterator = items <span class="hljs-comment"><span class="hljs-comment">// ArrayList&lt;Integer&gt; .stream() .map(Long::valueOf) .collect(toList()) // &lt;----    ? .iterator(); while (iterator.hasNext()) { bh.consume(iterator.next()); }</span></span></code> </pre> <br><p>  Lo quitamos: </p><br><pre> <code class="java hljs">Iterator&lt;Long&gt; iterator = items <span class="hljs-comment"><span class="hljs-comment">// ArrayList&lt;Integer&gt; .stream() .map(Long::valueOf) .iterator(); while (iterator.hasNext()) { bh.consume(iterator.next()); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Veamos cu√°nto ha mejorado el rendimiento:</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/un/mp/pf/unmppfr6sd8ybi3k7r7jrdsdfty.png"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Compare con los nueve:</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/hc/rb/p9/hcrbp98qezjcm5fegv27cywcadu.png"></p></div></div><br><p>  Incre√≠ble verdad?  He argumentado anteriormente que el exceso de trabajo degrada el rendimiento.  Pero aqu√≠ eliminamos el exceso, y (de repente) empeora.  Para comprender lo que est√° sucediendo, tome dos iteradores y m√≠relos bajo una lupa: </p><br><div class="spoiler">  <b class="spoiler_title">Revelar</b> <div class="spoiler_text"><pre> <code class="java hljs">Iterator iterator1 = items.stream().collect(toList()).iterator(); Iterator iterator2 = items.stream().iterator();</code> </pre> <br><p><img src="https://habrastorage.org/webt/rn/ah/kf/rnahkfz2qdyuw0k_cjeorqawqki.png"></p></div></div><br><p>  El primer iterador es el <code>ArrayList$Itr</code> regular <code>ArrayList$Itr</code> . </p><br><div class="spoiler">  <b class="spoiler_title">El paso a trav√©s de √©l es simple:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cursor != size; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> E </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ checkForComodification(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = cursor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt;= size) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NoSuchElementException(); } Object[] elementData = ArrayList.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementData; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt;= elementData.length) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentModificationException(); } cursor = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (E) elementData[lastRet = i]; }</code> </pre> <br><p><img src="https://habrastorage.org/webt/ug/yb/pi/ugybpiiwmjj5-fbcazvmfdjd2tq.png"></p></div></div><br><p>  El segundo es m√°s interesante, es <code>Spliterators$Adapter</code> , que se basa en <code>ArrayList$ArrayListSpliterator</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Pasarlo es m√°s dif√≠cil</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// java.util.Spliterators$Adapter public boolean hasNext() { if (!valueReady) spliterator.tryAdvance(this); return valueReady; } public T next() { if (!valueReady &amp;&amp; !hasNext()) throw new NoSuchElementException(); else { valueReady = false; return nextElement; } }</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/pf/5p/gj/pf5pgjkfhhfw__h8ie7m6oflxqq.png"></p></div></div><br><p>  Veamos la iteraci√≥n del iterador a trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">async-profiler</a> : </p><br><pre> <code class="hljs mel"><span class="hljs-number"><span class="hljs-number">15.64</span></span>% juArrayList$ArrayListSpliterator.tryAdvance <span class="hljs-number"><span class="hljs-number">10.67</span></span>% jusSpinedBuffer.<span class="hljs-keyword"><span class="hljs-keyword">clear</span></span> <span class="hljs-number"><span class="hljs-number">9.86</span></span>% juSpliterators$1Adapter.hasNext <span class="hljs-number"><span class="hljs-number">8.81</span></span>% jusStreamSpliterators$AbstractWrappingSpliterator.fillBuffer <span class="hljs-number"><span class="hljs-number">6.01</span></span>% oojiBlackhole.consume <span class="hljs-number"><span class="hljs-number">5.71</span></span>% jusReferencePipeline$3$1.accept <span class="hljs-number"><span class="hljs-number">5.57</span></span>% jusSpinedBuffer.accept <span class="hljs-number"><span class="hljs-number">5.06</span></span>% cllbir.IteratorFromStreamBenchmark.iteratorFromStream <span class="hljs-number"><span class="hljs-number">4.80</span></span>% jlLong.valueOf <span class="hljs-number"><span class="hljs-number">4.53</span></span>% cllbiIteratorFromStreamBenchmark$$Lambda$8<span class="hljs-number"><span class="hljs-number">.885721577</span></span>.apply</code> </pre> <br><p>  Se puede ver que la mayor parte del tiempo se pasa pasando por el iterador, aunque en general, no lo necesitamos, porque la b√∫squeda se puede hacer as√≠: </p><br><pre> <code class="java hljs">items .stream() .map(Long::valueOf) .forEach(bh::consume);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Compare con el resto:</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/rf/is/i0/rfisi0vsfoezlcvtd43h2lhlvfi.png"></p></div></div><br><p>  <code>Stream::forEach</code> claramente un ganador, pero esto es extra√±o: todav√≠a se basa en <code>ArrayListSpliterator</code> , pero su uso ha mejorado significativamente. </p><br><div class="spoiler">  <b class="spoiler_title">Veamos el perfil:</b> <div class="spoiler_text"><pre> <code class="hljs powershell"><span class="hljs-number"><span class="hljs-number">29.04</span></span>% oojiBlackhole.consume <span class="hljs-number"><span class="hljs-number">22.92</span></span>% juArrayList<span class="hljs-variable"><span class="hljs-variable">$ArrayListSpliterator</span></span>.forEachRemaining <span class="hljs-number"><span class="hljs-number">14.47</span></span>% jusReferencePipeline<span class="hljs-variable"><span class="hljs-variable">$3</span></span><span class="hljs-variable"><span class="hljs-variable">$1</span></span>.accept <span class="hljs-number"><span class="hljs-number">8.79</span></span>% jlLong.valueOf <span class="hljs-number"><span class="hljs-number">5.37</span></span>% cllbiIteratorFromStreamBenchmark<span class="hljs-variable"><span class="hljs-variable">$</span></span><span class="hljs-variable"><span class="hljs-variable">$Lambda</span></span><span class="hljs-variable"><span class="hljs-variable">$9</span></span>.<span class="hljs-number"><span class="hljs-number">617691115</span></span>.accept <span class="hljs-number"><span class="hljs-number">4.84</span></span>% cllbiIteratorFromStreamBenchmark<span class="hljs-variable"><span class="hljs-variable">$</span></span><span class="hljs-variable"><span class="hljs-variable">$Lambda</span></span><span class="hljs-variable"><span class="hljs-variable">$8</span></span>.<span class="hljs-number"><span class="hljs-number">1964917002</span></span>.apply <span class="hljs-number"><span class="hljs-number">4.43</span></span>% jusForEachOps<span class="hljs-variable"><span class="hljs-variable">$ForEachOp</span></span><span class="hljs-variable"><span class="hljs-variable">$OfRef</span></span>.accept <span class="hljs-number"><span class="hljs-number">4.17</span></span>% jusSink<span class="hljs-variable"><span class="hljs-variable">$ChainedReference</span></span>.end <span class="hljs-number"><span class="hljs-number">1.27</span></span>% jlInteger.longValue <span class="hljs-number"><span class="hljs-number">0.53</span></span>% jusReferencePipeline.map</code> </pre> </div></div><br><p>  En este perfil, la mayor parte del tiempo se gasta "tragando" los valores dentro del <code>Blackhole</code> .  En comparaci√≥n con un iterador, una parte significativamente mayor del tiempo se dedica directamente a la ejecuci√≥n de c√≥digo Java.  Se puede suponer que la raz√≥n es el menor peso espec√≠fico de la recolecci√≥n de basura, en comparaci√≥n con la fuerza bruta del iterador.  Comprobar: </p><br><pre> <code class="java hljs">forEach:¬∑gc.alloc.rate.norm <span class="hljs-number"><span class="hljs-number">100</span></span> avgt <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">216</span></span>,<span class="hljs-number"><span class="hljs-number">001</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">002</span></span> B/op iteratorFromStream:¬∑gc.alloc.rate.norm <span class="hljs-number"><span class="hljs-number">100</span></span> avgt <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">416</span></span>,<span class="hljs-number"><span class="hljs-number">004</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">006</span></span> B/op</code> </pre> <br><p>  De hecho, <code>Stream::forEach</code> proporciona la mitad del consumo de memoria. </p><br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© es m√°s r√°pido?</b> <div class="spoiler_text"><p>  La cadena de llamadas desde el principio hasta el agujero negro se ve as√≠: </p><br><p><img src="https://habrastorage.org/webt/2f/5w/1y/2f5w1ydxlo5oomf8bfmhbqtynze.png"></p><br><p>  Como puede ver, la llamada a <code>ArrayListSpliterator::tryAdvance</code> desapareci√≥ de la cadena, y <code>ArrayListSpliterator::forEachRemaining</code> apareci√≥ en su <code>ArrayListSpliterator::forEachRemaining</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ArrayListSpliterator public void forEachRemaining(Consumer&lt;? super E&gt; action) { int i, hi, mc; // hoist accesses and checks from loop ArrayList&lt;E&gt; lst; Object[] a; if (action == null) throw new NullPointerException(); if ((lst = list) != null &amp;&amp; (a = lst.elementData) != null) { if ((hi = fence) &lt; 0) { mc = lst.modCount; hi = lst.size; } else mc = expectedModCount; if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) { for (; i &lt; hi; ++i) { @SuppressWarnings("unchecked") E e = (E) a[i]; // &lt;---- action.accept(e); } if (lst.modCount == mc) return; } } throw new ConcurrentModificationException(); }</span></span></code> </pre> <br><p>  <code>ArrayListSpliterator::forEachRemaining</code> alta velocidad <code>ArrayListSpliterator::forEachRemaining</code> logra mediante el uso de un pase a trav√©s de toda la matriz en 1 llamada al m√©todo.  Cuando se usa un iterador, el pasaje se limita a un elemento, por lo que siempre descansamos en <code>ArrayListSpliterator::tryAdvance</code> . <br>  <code>ArrayListSpliterator::forEachRemaining</code> tiene acceso a toda la matriz e <code>ArrayListSpliterator::forEachRemaining</code> sobre ella con un ciclo de conteo sin llamadas adicionales. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Aviso importante</b> <div class="spoiler_text"><p>  Tenga en cuenta que el reemplazo mec√°nico </p><br><pre> <code class="java hljs">Iterator&lt;Long&gt; iterator = items .stream() .map(Long::valueOf) .collect(toList()) .iterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (iterator.hasNext()) { bh.consume(iterator.next()); }</code> </pre> <br><p>  en </p><br><pre> <code class="java hljs">items .stream() .map(Long::valueOf) .forEach(bh::consume);</code> </pre> <br><p>  No siempre es equivalente, porque en el primer caso usamos una copia de los datos para el pasaje sin afectar la transmisi√≥n en s√≠, y en el segundo caso los datos se toman directamente de la transmisi√≥n. </p></div></div><br><p>  <a href="">Punto de referencia</a> </p><br><p>  Conclusi√≥n: cuando se trata de representaciones complejas de datos, prep√°rese para el hecho de que incluso las reglas de "hierro" (da√±os adicionales al trabajo) dejan de funcionar.  El ejemplo anterior muestra que la lista intermedia aparentemente superflua ofrece la ventaja de una implementaci√≥n m√°s r√°pida de la enumeraci√≥n. </p><br><h4 id="dva-podvoha">  Dos trucos </h4><br><pre> <code class="java hljs">StackTraceElement[] trace = th.getStackTrace(); StackTraceElement[] newTrace = Arrays .asList(trace) .subList(<span class="hljs-number"><span class="hljs-number">0</span></span>, depth) .toArray(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StackTraceElement[newDepth]); <span class="hljs-comment"><span class="hljs-comment">// &lt;----</span></span></code> </pre> <br><p>  Lo primero que llama la atenci√≥n es una "mejora" podrida, es decir, pasar una matriz de longitud distinta de cero al m√©todo <code>Collection::toArray</code> .  Explica con gran detalle por qu√© esto es da√±ino. </p><br><p>  El segundo problema no es tan obvio, y para su comprensi√≥n podemos establecer un paralelismo entre el trabajo del revisor y el del historiador. </p><br><div class="spoiler">  <b class="spoiler_title">Esto es lo que Robin Collingwood escribe sobre esto:</b> <div class="spoiler_text"><p> , ,   []       ‚Äì  . <strong>             </strong> .   , <strong>    ,    </strong> ... </p></div></div><br><p>       <strong></strong>      .      : </p><br><p> 1)     <br> 2)    <br> 3)       </p><br><p>      ,      : </p><br><pre> <code class="java hljs">StackTraceElement[] trace = th.getStackTrace(); StackTraceElement[] newTrace = Arrays.copyOf(trace, depth); <span class="hljs-comment"><span class="hljs-comment">//    0 //  StackTraceElement[] newTrace = Arrays.copyOfRange(trace, 0, depth); //   0</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"> ():</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xg/ia/-8/xgia-8mdesgh-cpqm1cla0n8zz4.png"></p></div></div><br><p> <a href=""></a> </p><br><h4 id="strimoz-golovnogo-mozga">    </h4><br><pre> <code class="java hljs">List&lt;T&gt; list = getList(); Set&lt;T&gt; set = getSet(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.stream().allMatch(set::contains); <span class="hljs-comment"><span class="hljs-comment">//     ?</span></span></code> </pre> <br><p>       ,      ,    : </p><br><pre> <code class="java hljs">List&lt;T&gt; list = getList(); Set&lt;T&gt; set = getSet(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> set.containsAll(list);</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"> ():</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/3c/tc/pr/3ctcprq3scexhaaifc9hiywbj98.png"></p></div></div><br><p> <a href=""></a> </p><br><h4 id="nenuzhnye-obyortki">   </h4><br><p>  : </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileNameLoader</span></span></span><span class="hljs-class"> </span></span>{ String[] loadFileNames(); }</code> </pre> <br><p>     : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FileNameLoader loader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String str : asList(loader.loadFileNames())) { <span class="hljs-comment"><span class="hljs-comment">// &lt;----   use(str); } }</span></span></code> </pre> <br><p>   ,   <code>forEach</code>    ,      : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FileNameLoader loader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String str : loader.loadFileNames()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;----    use(str); } }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"> ():</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/pa/kn/hc/paknhcvrp1cf7g-fw3cn4euxrse.png"></p></div></div><br><p> <a href=""></a> </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-182206</a> <br><del> IDEA-182206 </del> Simplification for Arrays.asList().subList().toArray() <br> <strong>  2018.1</strong> </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-180847</a> <br><del> IDEA-180847 </del> Inspection 'Call to Collection.toArray with zero-length array argument' brings pessimization <br> <strong>  2018.1</strong> </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-181928</a> <br><del> IDEA-181928 </del> Stream.allMatch(Collection::contains) can be simplified to Collection.containsAll() <br> <strong>  2018.1</strong> </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-184240</a> <br><del> IDEA-184240 </del> Unnecessary array-to-collection wrapping should be detected <br> <strong>  2018.1</strong> </p></div></div><br><p> :       : </p><br><ul><li>  </li><li>  </li><li>    </li></ul><br><p>       ,   ,         ,     .  ,   :         "" (        ),       ""     (      ),        . </p><br><p> ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   </a> </p><br><p> ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423305/">https://habr.com/ru/post/es423305/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423293/index.html">C√≥mo no dispararte en la pierna con una m√°quina de estado</a></li>
<li><a href="../es423295/index.html">Conferencia de desarrollo m√≥vil m√°s √∫til</a></li>
<li><a href="../es423297/index.html">Del desarrollador de Android a DevOps</a></li>
<li><a href="../es423299/index.html">Coordinador de aplicaciones en aplicaciones iOS</a></li>
<li><a href="../es423303/index.html">AI, curso pr√°ctico. Transformaci√≥n de m√∫sica basada en la emoci√≥n</a></li>
<li><a href="../es423307/index.html">Solicitudes de extracci√≥n de GitHub en c√≥digo de Visual Studio</a></li>
<li><a href="../es423309/index.html">Transacciones DBMS</a></li>
<li><a href="../es423311/index.html">Asociaci√≥n Naviaddress y ACTUM</a></li>
<li><a href="../es423313/index.html">Toca el I2C. Haz un analizador l√≥gico simple</a></li>
<li><a href="../es423315/index.html">Teor√≠a de los enlaces universales</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>