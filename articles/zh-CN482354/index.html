<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏼 🏮 ❇️ ConfigureAwait：常见问题 ♍️ 🌑 👩🏼‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 我向您介绍Stephen Taub撰写的ConfigureAwait FAQ文章的翻译。 



 Async / await添加到七年前的.NET中。 这一决定不仅对.NET生态系统产生了重大影响-还反映在许多其他语言和框架中。 当前，.NET已在使用异步的其他语言构造方面实现了许多改进...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ConfigureAwait：常见问题</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482354/">哈Ha！ 我向您介绍Stephen Taub撰写<a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/" rel="nofollow">的ConfigureAwait FAQ</a>文章的翻译。 <br><br><img src="https://habrastorage.org/webt/ps/pj/sm/pspjsmmgsimr2lachonj6idmnj8.png" alt="图片"><br><br>  <code>Async</code> / <code>await</code>添加到七年前的.NET中。 这一决定不仅对.NET生态系统产生了重大影响-还反映在许多其他语言和框架中。 当前，.NET已在使用异步的其他语言构造方面实现了许多改进，已实现了具有异步支持的API，对基础架构也进行了根本性的改进，因此<code>async</code> / <code>await</code>工作原理类似于时钟（特别是性能和诊断功能已得到改进）在.NET Core中）。 <br><br>  <code>ConfigureAwait</code>是<code>async</code> / <code>await</code>一个方面，不断引起问题。 我希望我能回答其中的许多问题。 我将尝试使本文从头到尾都具有可读性，同时以对常见问题（FAQ）的回答的方式执行该文章，以便将来可以引用。 <a name="habracut"></a><br><br> 为了实际处理<code>ConfigureAwait</code> ，我们将回顾一下。 <br><br><h3> 什么是SynchronizationContext？ </h3><br> 根据<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext%3Fview%3Dnetframework-4.8" rel="nofollow">System.Threading.SynchronizationContext</a>文档，“提供了用于在各种同步模型中分发同步上下文的基本功能。” 这个定义不是很明显。 <br><br> 在99.9％的情况下， <code>SynchronizationContext</code>仅用作带有虚拟<code>Post</code>方法的类型，该方法接受委托以进行异步执行（ <code>SynchronizationContext</code>还有其他虚拟成员，但它们不那么常见，因此在本文中将不再讨论）。 基本类型的<code>Post</code>方法实际上<a href="" rel="nofollow">只是调用</a> <code>ThreadPool.QueueUserWorkItem</code>以异步执行提供的委托。 派生类型将覆盖<code>Post</code>以便委托可以在正确的时间在正确的位置执行。 <br><br> 例如，Windows窗体具有SynchronizationContext派生的<a href="" rel="nofollow">类型</a> ，该<a href="" rel="nofollow">类型</a>重新定义了<code>Post</code>以使其等效于<code>Control.BeginInvoke</code> 。 这意味着对该<code>Post</code>方法的任何调用都将导致在稍后阶段与对应的Control相关联的线程（即所谓的UI线程）中对委托的调用。  Windows窗体的核心是Win32消息处理。 消息循环在UI线程中执行，该线程仅等待处理新消息。 这些消息是由鼠标移动，单击，键盘输入，可由委托执行的系统事件等触发的。因此，如果您在Windows Forms应用程序中具有UI线程的<code>SynchronizationContext</code>实例，则必须将委托传递给<code>Post</code>方法才能在其中执行操作。 <br><br>  Windows Presentation Foundation（WPF）也具有从<code>SynchronizationContext</code>派生的<a href="" rel="nofollow">类型</a> ，该<a href="" rel="nofollow">类型</a>具有重写的<code>Post</code>方法，该方法类似地使用WPF Dispatcher控件（而不是Windows Forms Control）将委托“定向”到UI流（使用<code>Dispatcher.BeginInvoke</code> ）。 <br><br>  Windows RunTime（WinRT）具有自己的<code>SynchronizationContext</code>派生<a href="" rel="nofollow">类型</a> ，该<a href="" rel="nofollow">类型</a>还使用<code>CoreDispatcher</code>将委托放入UI线程<code>CoreDispatcher</code>中。 <br><br> 这就是短语“ UI线程中的运行委托”的背后。 您还可以使用<code>Post</code>方法和某些实现来实现<code>SynchronizationContext</code> 。 例如，我不必担心委托在哪个线程中运行，但是我想确保<code>SynchronizationContext</code>中的任何<code>Post</code>方法委托都以一定程度的并行度运行。 您可以通过以下方式实现自定义<code>SynchronizationContext</code> ： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MaxConcurrencySynchronizationContext</span></span> : <span class="hljs-title"><span class="hljs-title">SynchronizationContext</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> SemaphoreSlim _semaphore; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MaxConcurrencySynchronizationContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxConcurrencyLevel</span></span></span><span class="hljs-function">)</span></span> =&gt; _semaphore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SemaphoreSlim(maxConcurrencyLevel); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SendOrPostCallback d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> =&gt; _semaphore.WaitAsync().ContinueWith(<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { d(state); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { _semaphore.Release(); } }, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, TaskContinuationOptions.None, TaskScheduler.Default); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Send</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SendOrPostCallback d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> { _semaphore.Wait(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { d(state); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { _semaphore.Release(); } } }</code> </pre> <br>  xUnit框架具有类似<a href="" rel="nofollow">的</a> SynchronizationContext <a href="" rel="nofollow">实现</a> 。 在这里，它用于减少与并行测试关联的代码量。 <br><br> 此处的优势与任何抽象都相同：提供了一个API，该API可用于按照编程人员希望的方式将委托排队以便执行，而无需了解实现细节。 假设我写了一个库，我需要在其中做一些工作，然后将委托排队回到原始上下文。 为此，我需要捕获其<code>SynchronizationContext</code> ，完成所需的操作后，只需调用此上下文的<code>Post</code>方法并将其传递给委托即可执行。 我不需要知道对于Windows窗体，您需要<code>Control</code>并使用其<code>BeginInvoke</code> ；对于WPF，请使用<code>Dispatcher</code> <code>BeginInvoke</code> ，或者以某种方式获取xUnit的上下文及其队列。 我需要做的就是获取当前的<code>SynchronizationContext</code>并在以后使用。 为此， <code>SynchronizationContext</code>具有<code>Current</code>属性。 可以如下实现： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action worker, Action completion</span></span></span><span class="hljs-function">)</span></span> { SynchronizationContext sc = SynchronizationContext.Current; ThreadPool.QueueUserWorkItem(_ =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { worker(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { sc.Post(_ =&gt; completion(), <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } }); }</code> </pre> <br> 您可以使用<code>SynchronizationContext.SetSynchronizationContext</code>方法从<code>Current</code>属性中设置特殊上下文。 <br><br><h3> 什么是任务计划程序？ </h3><br>  <code>SynchronizationContext</code>是“调度程序”的通用抽象。 一些框架为此使用它们自己的抽象，并且<code>System.Threading.Tasks</code>也不例外。 当<code>Task</code>有可以排队和执行的委托时，它们与<code>System.Threading.Tasks.TaskScheduler</code>关联。 还有一个用于排队委托的虚拟<code>Post</code>方法（使用标准机制实现委托调用）， <code>TaskScheduler</code>提供抽象的<code>QueueTask</code>方法（使用<code>ExecuteTask</code>方法实现任务调用）。 <br><br> 返回<code>TaskScheduler.Default</code>的默认调度程序。默认为线程池。 从<code>TaskScheduler</code> ，还可以获取和覆盖用于设置<code>Task</code>调用时间和地点的方法。 例如，核心库包括<code>System.Threading.Tasks.ConcurrentExclusiveSchedulerPair</code>类型。 此类的实例提供两个<code>TaskScheduler</code>属性： <code>ExclusiveScheduler</code>和<code>ConcurrentScheduler</code> 。 可以并行执行在<code>ConcurrentScheduler</code>调度的任务，但要考虑到<code>ConcurrentExclusiveSchedulerPair</code>创建时设置的限制（类似于<code>MaxConcurrencySynchronizationContext</code> ）。 如果在<code>ExclusiveScheduler</code>执行任务并且一次仅允许运行一个独占任务，则不会执行<code>ConcurrentScheduler</code>任务。 此行为与读/写锁非常相似。 <br><br> 与<code>SynchronizationContext</code>一样， <code>TaskScheduler</code>具有<code>Current</code>属性，该属性返回当前<code>TaskScheduler</code> 。 但是，与<code>SynchronizationContext</code>不同，它缺少一种用于设置当前调度程序的方法。 而是，调度程序与当前任务相关联。 因此，例如，该程序将显示<code>True</code> ，因为<code>StartNew</code>使用的lambda在<code>ConcurrentExclusiveSchedulerPair</code>的<code>ExclusiveScheduler</code>实例中执行，而<code>TaskScheduler.Current</code>安装在此调度程序上： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cesp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentExclusiveSchedulerPair(); Task.Factory.StartNew(() =&gt; { Console.WriteLine(TaskScheduler.Current == cesp.ExclusiveScheduler); }, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, TaskCreationOptions.None, cesp.ExclusiveScheduler).Wait(); } }</code> </pre> <br> 有趣的是， <code>TaskScheduler</code>提供了一个静态的<code>FromCurrentSynchronizationContext</code>方法。 该方法创建一个新的<code>TaskScheduler</code>并使用<code>Post</code>方法在返回的<code>SynchronizationContext.Current</code>上下文中将要执行的任务<code>TaskScheduler</code> 。 <br><br><h3>  SynchronizationContext和TaskScheduler与await有什么关系？ </h3><br> 假设您需要编写一个带有按钮的UI应用程序。 按下按钮将启动从网站的文本下载并将其设置为“ <code>Content</code>按钮。 该按钮只能从其所在的流的UI中进行访问，因此，当我们成功加载日期和时间并将其放置在按钮的<code>Content</code> ，我们需要从对其进行控制的流中进行操作。 如果不满足此条件，我们将获得异常： <br><br><pre> <code class="cs hljs">System.InvalidOperationException: <span class="hljs-string"><span class="hljs-string">'        ,     .'</span></span></code> </pre><br> 我们可以手动使用<code>SynchronizationContext</code>在源上下文中设置<code>Content</code> ，例如通过<code>TaskScheduler</code> ： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>).ContinueWith(downloadTask =&gt; { downloadBtn.Content = downloadTask.Result; }, TaskScheduler.FromCurrentSynchronizationContext()); }</code> </pre> <br> 我们可以直接使用<code>SynchronizationContext</code> ： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { SynchronizationContext sc = SynchronizationContext.Current; s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>).ContinueWith(downloadTask =&gt; { sc.Post(<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { downloadBtn.Content = downloadTask.Result; }, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); }); }</code> </pre> <br> 但是，这两个选项都明确使用回调。 相反，我们可以使用<code>async</code> / <code>await</code> ： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>); downloadBtn.Content = text; }</code> </pre> <br> 所有这一切都“起作用”并成功在UI线程中配置<code>Content</code> ，因为在上述手动实现的版本中，默认情况下，等待任务是指<code>SynchronizationContext.Current</code>和<code>TaskScheduler.Current</code> 。 当您“期望” C＃中的某些内容时，编译器将用于轮询（通过调用<code>GetAwaiter</code> ）的“预期”（在本例中为Task）的代码转换为“ waiting”（ <code>TaskAwaiter</code> ）。  “等待”负责附加一个回调（通常称为“继续”），当等待完成时，该回调将返回状态机。 他使用在回调注册期间捕获的上下文/调度程序来实现此目的。 我们将进行一些优化和配置，如下所示： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> scheduler = SynchronizationContext.Current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scheduler <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; TaskScheduler.Current != TaskScheduler.Default) { scheduler = TaskScheduler.Current; }</code> </pre> <br> 在这里，首先检查是否<code>SynchronizationContext</code>了<code>SynchronizationContext</code> ，如果没有<code>SynchronizationContext</code> ，则检查是否<code>TaskScheduler</code>非标准<code>TaskScheduler</code> 。 如果有一个，则当回调准备好进行呼叫时，将使用捕获的调度程序；否则，将使用捕获的调度程序。 如果不是，则回调将作为完成预期任务的操作的一部分执行。 <br><br><h3>  ConfigureAwait的作用（假） </h3><br>  <code>ConfigureAwait</code>方法不是特殊的：编译器或运行时不会以任何特定方式识别它。 这是返回结构的常规方法（ <code>ConfiguredTaskAwaitable</code>包装原始任务）并采用布尔值。 请记住，可以将<code>await</code>与实现正确模式的任何类型一起使用。 如果返回另一种类型，则意味着编译器可以访问实例的<code>GetAwaiter</code>方法（模式的一部分），但使用的是<code>ConfigureAwait</code>返回的类型，而不是直接从任务执行。 这使您可以更改此特殊<code>await</code>行为。 <br><br> 等待而不是等待<code>Task</code>由<code>ConfigureAwait(continueOnCapturedContext: false)</code>返回的类型<code>ConfigureAwait(continueOnCapturedContext: false)</code>会直接影响上述的上下文/调度程序捕获实现。 逻辑变成这样： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> scheduler = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (continueOnCapturedContext) { scheduler = SynchronizationContext.Current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scheduler <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; TaskScheduler.Current != TaskScheduler.Default) { scheduler = TaskScheduler.Current; } }</code> </pre> <br> 换句话说，即使存在回调的当前上下文或调度程序，也将其指定为<code>false</code>意味着它不存在。 <br><br><h3> 为什么需要使用ConfigureAwait（false）？ </h3><br>  <code>ConfigureAwait(continueOnCapturedContext: false)</code>用于防止强制在源上下文或调度程序中调用回调。 这给我们带来了几个优点： <br><br>  <b>性能提升。</b> 与仅调用队列不同，排队回调存在开销，因为这需要额外的工作（通常是额外的分配）。 此外，我们不能在运行时使用优化（当我们确切知道回调将如何调用时，我们可以进行更多优化，但是如果将其传递给抽象的任意实现，则有时会施加限制）。 对于负载较重的部分，甚至检查当前<code>SynchronizationContext</code>和当前<code>TaskScheduler</code>的额外成本（均暗示着要访问静态流）也会显着增加开销。 如果<code>await</code>之后的代码不需要在原始上下文中执行，则可以使用<code>ConfigureAwait(false)</code>避免所有这些开销，因为它不需要不必要地排队，因此可以使用所有可用的优化方法，并且还可以避免不必要地访问流静态变量。 <br><br>  <b>防止死锁。</b> 考虑<code>await</code>用于从网络下载内容的库方法。 您调用此方法并同步阻塞，等待任务完成，例如，使用<code>.GetAwaiter()</code>或<code>.GetAwaiter()</code>或<code>.GetAwaiter()</code> <code>.GetResult()</code> 。 现在考虑如果调用发生在当前<code>SynchronizationContext</code>使用<code>MaxConcurrencySynchronizationContext</code>显式地将其中的操作数限制为1时发生，或者隐式（如果它是具有单个线程（例如，UI线程）使用的上下文）时发生的。 因此，您可以在单个线程中调用该方法，然后将其阻塞，等待操作完成。 下载通过网络开始，并等待其完成。 默认情况下，等待<code>Task</code>捕获当前的<code>SynchronizationContext</code> （在这种情况下），并且从网络下载完成后，它将排队回到<code>SynchronizationContext</code>回调中，该回调将调用其余操作。 但是，在等待操作完成时，当前唯一可以处理队列中回调的线程已被阻塞。 并且，只有在处理完回调之后，该操作才能完成。 死锁！ 即使上下文未将并发限制为1，但是资源以某种方式受到限制，也会发生这种情况。 想象同样的情况， <code>MaxConcurrencySynchronizationContext</code>的值为4。 而不是一次执行该操作，我们将对上下文的4个调用排队。 进行每个呼叫并锁定其完成的预期。 现在，所有资源都被阻塞，等待异步方法完成，并且唯一允许它们完成的事情是如果此回调处理了此上下文。 但是，他已经完全忙碌了。 再次陷入僵局。 如果库方法改为使用<code>ConfigureAwait(false)</code> ，则它将不会将回调排队到原始上下文，这样可以避免死锁脚本。 <br><br><h3> 我是否需要使用ConfigureAwait（true）？ </h3><br> 否，除非您需要明确表明您没有使用<code>ConfigureAwait(false)</code> （例如，隐藏静态分析警告等）。  <code>ConfigureAwait(true)</code>没什么大不了的。 如果比较<code>await task</code>和<code>await task.ConfigureAwait(true)</code> ，则它们在功能上是相同的。 因此，如果代码中存在<code>ConfigureAwait(true)</code> ，则可以删除它而不会产生任何负面影响。 <br><br>  <code>ConfigureAwait</code>方法采用布尔值，因为在某些情况下，它可能需要传递变量来控制配置。 但是在99％的情况下，该值设置为false， <code>ConfigureAwait(false)</code> 。 <br><br><h3> 什么时候使用ConfigureAwait（false）？ </h3><br> 这取决于您是实现应用程序级代码还是通用库代码。 <br><br> 在编写应用程序时，通常需要一些默认行为。 如果应用程序模型/环境（例如Windows窗体，WPF，ASP.NET Core）发布了特殊的<code>SynchronizationContext</code> ，则几乎可以肯定有一个很好的理由：这意味着代码允许您处理同步上下文，以与应用程序模型/环境进行正确的交互。 例如，如果您在Windows Forms应用程序中编写事件处理程序，在xUnit中进行测试，或者在ASP.NET MVC控制器中编写代码，则不管应用程序模型是否已发布<code>SynchronizationContext</code> ，如果都存在，都需要使用<code>SynchronizationContext</code> 。 这意味着，如果同时使用<code>ConfigureAwait(true)</code>和<code>await</code> ，则将回调/继续发送回原始上下文-一切按预期进行。 从这里可以制定一条通用规则： <b>如果编写应用程序级代码， <i>请不要使用</i> <code>ConfigureAwait(false)</code></b> 。 让我们回到点击处理程序： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>); downloadBtn.Content = text; }</code> </pre> <br>  <code>downloadBtn.Content = text</code>应在原始上下文中执行。 如果代码违反了此规则，而是使用了<code>ConfigureAwait (false)</code> ，那么它将不会在原始上下文中使用： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  downloadBtn.Content = text; }</span></span></code> </pre> <br> 这将导致不当行为。 这同样适用于依赖于<code>HttpContext.Current</code>的经典ASP.NET应用程序中的代码。 当使用<code>ConfigureAwait(false)</code>随后尝试使用<code>Context.Current</code>函数可能会导致问题。 <br><br> 这就是通用库的区别。 它们之所以具有通用性，部分原因是它们不关心使用它们的环境。 您可以从Web应用程序，客户端应用程序或测试中使用它们-没关系，因为库代码对于可以使用它的应用程序模型是不可知的。 不可知论还意味着该库将不做任何事情来与应用程序模型进行交互，例如，它将无法访问用户界面控件，因为通用库对此一无所知。 由于不需要在任何特定环境中运行代码，因此我们可以避免将强制执行/回调强制到原始上下文，而我们可以使用<code>ConfigureAwait(false)</code>来执行此操作，这将为我们带来性能优势并提高可靠性。 这将导致以下情况： <b>如果要编写通用库代码，请使用<code>ConfigureAwait(false)</code></b> 。 这就是.NET Core运行时库中每个（或几乎每个）等待都使用ConfigureAwait（false）的原因。 除少数例外（很可能是错误）外，它们将得到修复。 , <a href="https://github.com/dotnet/corefx/pull/38610" rel="nofollow"> PR</a>    <code>ConfigureAwait(false)</code>  <code>HttpClient</code> . <br><br>      . ,     (,   , ,   )      ,     API,     .   ,         ,       ” "  . , ,    Where LINQ: <code>public static async IAsyncEnumerable&lt;T&gt; WhereAsync(this IAsyncEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; predicate)</code> .   <code>predicate</code>    <code>SynchronizationContext</code>  ?     <code>WhereAsync</code> ,   ,        <code>ConfigureAwait(false)</code> . <br><br>       :  <code>ConfigureAwait(false)</code>      /app-model-agnostic . <br><br><h3>   ConfigureAwait (false),         ? </h3><br> ,  ,          .    ,    <code>await</code>      .    ,      ,      . ,    ,      ,   ,   <code>ConfigureAwait(false)</code> ,            ,     . <br><br><h3>    ConfigureAwait (false)       ,    — ? </h3><br>  , .   FAQ.  <code>await task.ConfigureAwait(false)</code>  ,       (      ),   <code>ConfigureAwait(false)</code>  ,           -    ,    . <br><br>     ,   <code>await</code>    ,         ,    <code>SynchronizationContext</code>  <code>TaskScheduler</code> . , <code>CryptoStream</code>     .NET ,                 .      <code><a href="" rel="nofollow">awaiter</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确保第一次等待后的代码在线程池线程中执行。</font><font style="vertical-align: inherit;">但是，即使在这种情况下，您也会注意到下次等待仍在使用</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">从技术上讲，这不是必需的，但是由于不需要了解为什么不使用它，因此可以大大简化代码审查</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 是否可以使用Task.Run避免使用ConfigureAwait（false）？ </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 是的，如果您写： </font></font><br><br><pre> <code class="cs hljs">Task.Run(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> SomethingAsync(); <span class="hljs-comment"><span class="hljs-comment">//     });</span></span></code> </pre> <br>  <code>ConfigureAwait(false)</code>  <code>SomethingAsync()</code>  ,   ,   <code>Task.Run</code>      ,       , <code>SynchronizationContext.Current</code>   <code>null</code> .  , <code>Task.Run</code>   <code>TaskScheduler.Default</code> ,  <code>TaskScheduler.Current</code>      <code>Default</code> .  ,  <code>await</code>        ,    <code>ConfigureAwait(false)</code> .        ,       .     : <br><br><pre> <code class="cs hljs">Task.Run(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { SynchronizationContext.SetSynchronizationContext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeCoolSyncCtx()); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> SomethingAsync(); <span class="hljs-comment"><span class="hljs-comment">//    SomeCoolSyncCtx });</span></span></code> </pre> <br>    <code>SomethingAsync</code>   <code>SynchronizationContext.Current</code>  <code>SomeCoolSyncCtx</code> .   <code>await</code> ,       SomethingAsync     .  ,    ,  ,        ,     ,       . <br><br>        /     .         /      . <br><br>    ,        ,  ,     . ,       ,    <code>ConfigureAwait(false)</code> <a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/ca2007%3Fview%3Dvs-2019" rel="nofollow">CA2007</a> .    ,         <code>ConfigureAwait</code> ,   ,    .        , ,      -  ,            ,       <code>ConfigureAwait(false)</code> . <br><br><h3>    SynchronizationContext.SetSynchronizationContext,    ConfigureAwait (false)? </h3><br> 不行 , .      <br><br>    : <br><br><pre> <code class="cs hljs">Task t; SynchronizationContext old = SynchronizationContext.Current; SynchronizationContext.SetSynchronizationContext(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { t = CallCodeThatUsesAwaitAsync(); <span class="hljs-comment"><span class="hljs-comment">// await'      } finally { SynchronizationContext.SetSynchronizationContext(old); } await t; //  -    </span></span></code> </pre> <br><br>  ,      <code>CallCodeThatUsesAwaitAsync</code>     <code>null</code> .   .       ,  <code>await</code>  <code>TaskScheduler.Current</code> .       <code>TaskScheduler</code> , <code>await</code> '  <code>CallCodeThatUsesAwaitAsync</code>          <code>TaskScheduler</code> . <br><br>    <code>Task.Run</code> FAQ,      :     ,     <code>try</code>     ,    (       ). <br><br>          : <br><br><pre> <code class="cs hljs">SynchronizationContext old = SynchronizationContext.Current; SynchronizationContext.SetSynchronizationContext(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> t; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { SynchronizationContext.SetSynchronizationContext(old); }</code> </pre><br>    ?   ,   .  ,       /   .  ,   <code>SynchronizationContext</code>        ,     ,          .   ,    ,    ,  ,            .        ,    ,          .       ,       . 依此类推。    . <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果我使用GetAwaiter（）.GetResult（），是否需要使用ConfigureAwait（false）？ </font></font></h3><br> 不行 <code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅影响回调。</font><font style="vertical-align: inherit;">特别是，模板</font></font><code>awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要求您</font></font><code>awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供属性</font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，方法</font></font><code>GetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>OnCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（可选地提供UnsafeOnCompleted方法）。</font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅影响行为</font></font><code>{Unsafe}OnCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此，如果您直接调用</font></font><code>GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，无论您是通过</font><font style="vertical-align: inherit;">行为</font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还是</font></font><code>ConfiguredTaskAwaitable.ConfiguredTaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行为方式</font><font style="vertical-align: inherit;">都</font><font style="vertical-align: inherit;">没有区别。</font><font style="vertical-align: inherit;">因此，如果看到</font></font><code>task.ConfigureAwait(false).GetAwaiter().GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以将其替换为</font></font><code>task.GetAwaiter().GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（此外，请考虑是否确实需要这样的实现）。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我知道代码在不会有特殊的SynchronizationContext或特殊的TaskScheduler的环境中运行。</font><font style="vertical-align: inherit;">我可以不使用ConfigureAwait（false）吗？</font></font></h3><br> 可能吧    ,      «».     ,  ,   ,    ,    <code>SynchronizationContext</code>        <code>TaskScheduler</code> ,  ,         .       ,     ,    . <br><br><h3>  ,   .NET Core    ConfigureAwait (false).   ? </h3><br> 不是那样的<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在.NET Core中工作的原因与在.NET Framework中工作的原因相同是必要的。在这方面没有任何改变。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是否某些环境发布自己已经改变了</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。特别是，虽然.NET Framework中的经典ASP.NET具有其自己的</font></font><code><a href="" rel="nofollow">SynchronizationContext</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但ASP.NET Core没有。这意味着默认情况下</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">ASP.NET Core应用程序中运行的代码将看不到特殊代码</font><font style="vertical-align: inherit;">，从而减少了</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对此环境的需求。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，这并不意味着永远不会有习惯</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><code>TaskScheduler</code> .  -   (   ,  )             ,     ,  <code>await</code> '  ASP.NET Core      ,       <code>ConfigureAwait(false)</code> . ,  ,      (       -)             ,      <code>ConfigureAwait(false)</code> . <br><br><h3>     ConfigureAwait,  «  foreach»  IAsyncEnumerable? </h3><br> 是的  .  <a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-iterating-with-async-enumerables-in-csharp-8" rel="nofollow"> MSDN</a> . <br><br> <code>Await foreach</code>   ,  ,      <code>IAsyncEnumerable&lt;T&gt;</code> .       ,     API.    .NET   <a href="" rel="nofollow"></a> <code>ConfigureAwait</code>  <code>IAsyncEnumerable&lt;T&gt;</code> ,    ,   <code>IAsyncEnumerable&lt;T&gt;</code>  <code>Boolean</code>    .      <code>MoveNextAsync</code>  <code>DisposeAsync</code> .         ,    ,    . <br><br><h3>    ConfigureAwait,  'await using' IAsyncDisposable? </h3><br> ,     . <br><br>    <code>IAsyncEnumerable&lt;T&gt;</code> , .NET       <code>ConfigureAwait</code>  <code>IAsyncDisposable</code>  <code>await using</code> ,   ,      ( ,    <code>DisposeAsync</code> ): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAsyncDisposableClass().ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { ... }</code> </pre> <br>     ,   <code>c</code> —   <code>MyAsyncDisposableClass</code> ,   <code>System.Runtime.CompilerServices.ConfiguredAsyncDisposable</code> ,      <code>ConfigureAwait</code>  <code>IAsyncDisposable</code> . <br><br>   ,   : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAsyncDisposableClass(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (c.ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { ... }</code> </pre> <br>   <code>c</code>    <code>MyAsyncDisposableClass</code> .         <code>c</code> ;  ,        . <br><br><h3>   ConfigureAwait (false),   AsyncLocal       .  ? </h3><br> ,   .   <code>AsyncLocal&lt;T&gt;</code>   <code>ExecutionContext</code> ,    <code>SynchronizationContext</code> .       <code>ExecutionContext</code>   <code>ExecutionContext.SuppressFlow()</code> , <code>ExecutionContext</code> (,  ,  <code>AsyncLocal &lt;T&gt;</code> )     <code>awaits</code> ,   ,   <code>ConfigureAwait</code>     <code>SynchronizationContext</code> .      <a href="https://devblogs.microsoft.com/pfxteam/executioncontext-vs-synchronizationcontext/" rel="nofollow"></a> . <br><br><h3>           ConfigureAwait(false)   ? </h3><br>        <code>ConfigureAwait(false)</code>     . <br><br>     ,   ,     // .      ,    , : <a href="https://github.com/dotnet/csharplang/issues/645" rel="nofollow">1</a> , <a href="https://github.com/dotnet/csharplang/issues/2542" rel="nofollow">2</a> , <a href="https://github.com/dotnet/csharplang/issues/2649" rel="nofollow">3</a> , <a href="https://github.com/dotnet/csharplang/issues/2746" rel="nofollow">4</a> . <br><br>     ,        ,  <a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/" rel="nofollow"> </a>    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN482354/">https://habr.com/ru/post/zh-CN482354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN482340/index.html">从初级到中级：解析器</a></li>
<li><a href="../zh-CN482344/index.html">准备在俄罗斯引入社会评级</a></li>
<li><a href="../zh-CN482346/index.html">ASP.NET MVC-通过ADO.NET使用MySQL</a></li>
<li><a href="../zh-CN482348/index.html">毫不怀疑的游戏开发者的拓扑和综合分析：压缩单个3D向量</a></li>
<li><a href="../zh-CN482352/index.html">当我差点将150k投向风或者公寓中强制通风的安装历史时</a></li>
<li><a href="../zh-CN482356/index.html">从常规Windows用户的角度来看，在没有资源管理器的情况下使用Windows Server</a></li>
<li><a href="../zh-CN482358/index.html">惊慌如何在Rust中发挥作用</a></li>
<li><a href="../zh-CN482362/index.html">几乎无政府状态：Fidonet的简要历史，该项目不关心通过互联网获胜</a></li>
<li><a href="../zh-CN482366/index.html">机器人专家对特斯拉自动驾驶仪有何看法</a></li>
<li><a href="../zh-CN482370/index.html">nodejs：流程管理器和ES6模块</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>