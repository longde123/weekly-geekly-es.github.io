<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüé§ üë©üèæ‚Äçü§ù‚Äçüë®üèø üßìüèº Mesures de performances pour la recherche d'applications Web incroyablement rapides üèÇüèø üï¥üèæ üôÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a un dicton: "Ce que vous ne pouvez pas mesurer, vous ne pouvez pas l'am√©liorer." L'auteur de l'article, dont nous publions aujourd'hui la traduc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mesures de performances pour la recherche d'applications Web incroyablement rapides</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/470872/">  Il y a un dicton: "Ce que vous ne pouvez pas mesurer, vous ne pouvez pas l'am√©liorer."  L'auteur de l'article, dont nous publions aujourd'hui la traduction, travaille pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Superhuman</a> .  Il dit que cette entreprise d√©veloppe le client de messagerie le plus rapide au monde.  Nous parlerons ici de ce qui est ¬´rapide¬ª et de la fa√ßon de cr√©er des outils pour mesurer les performances d'applications Web incroyablement rapides. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/q6/af/pp/q6afppxtd4rv6r-iqwvk9-6nyai.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Mesure de vitesse d'application</font> </h2><br>  Afin d'am√©liorer notre d√©veloppement, nous avons pass√© beaucoup de temps √† mesurer sa vitesse.  Et, comme il s'est av√©r√©, les mesures de performance sont des indicateurs qui sont √©tonnamment difficiles √† comprendre et √† appliquer. <br><br>  D'une part, il est difficile de concevoir des m√©triques qui d√©crivent avec pr√©cision les sensations ressenties par l'utilisateur lors de l'utilisation du syst√®me.  D'un autre c√¥t√©, il n'est pas facile de cr√©er des m√©triques si pr√©cises que leur analyse vous permet de prendre des d√©cisions √©clair√©es.  Par cons√©quent, de nombreuses √©quipes de d√©veloppement ne peuvent pas faire confiance aux donn√©es qu'elles collectent sur la performance de leurs projets. <br><br>  M√™me si les d√©veloppeurs disposent de mesures fiables et pr√©cises, leur utilisation n'est pas facile.  Comment d√©finir le terme ¬´rapide¬ª?  Comment trouver un √©quilibre entre vitesse et coh√©rence?  Comment apprendre √† d√©tecter rapidement la d√©gradation des performances ou √† √©valuer l'impact des optimisations sur le syst√®me? <br><br>  Ici, nous voulons partager quelques r√©flexions concernant le d√©veloppement d'outils d'analyse des performances des applications Web. <br><br><h2>  <font color="#3AC1EF">1. Utiliser la bonne ¬´horloge¬ª</font> </h2><br>  JavaScript dispose de deux m√©canismes pour r√©cup√©rer les horodatages: <code>performance.now()</code> et <code>new Date()</code> . <br><br>  En quoi diff√®rent-ils?  Les deux diff√©rences suivantes sont fondamentales pour nous: <br><br><ul><li>  La m√©thode <code>performance.now()</code> est beaucoup plus pr√©cise.  La pr√©cision de la <code>new Date()</code> construction <code>new Date()</code> est de ¬± 1 ms, tandis que la pr√©cision de <code>performance.now()</code> est d√©j√† de ¬± 100 ¬µs (oui, il s'agit de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">microsecondes</a> !). </li><li>  Les valeurs renvoy√©es par la m√©thode <code>performance.now()</code> augmentent toujours √† un taux constant et sont ind√©pendantes de l'heure syst√®me.  Cette m√©thode mesure simplement les intervalles de temps sans se concentrer sur l'heure du syst√®me.  Et √† la <code>new Date()</code> heure <code>new Date()</code> syst√®me affecte.  Si vous r√©organisez l'horloge syst√®me, cela modifiera √©galement le retour de la <code>new Date ()</code> , ce qui ruinera les donn√©es de surveillance des performances. </li></ul><br>  Bien que les ¬´horloges¬ª repr√©sent√©es par la m√©thode <code>performance.now()</code> soient √©videmment beaucoup mieux adapt√©es √† la mesure des intervalles de temps, elles ne sont pas id√©ales non plus.  <code>performance.now()</code> et <code>new Date()</code> souffrent tous deux du m√™me probl√®me, qui se manifeste dans le cas o√π le syst√®me est en veille: les mesures incluent le moment o√π la machine n'√©tait m√™me pas active. <br><br><h2>  <font color="#3AC1EF">2. V√©rification de l'activit√© de l'application</font> </h2><br>  Si vous, en mesurant les performances d'une application Web, passez de son onglet √† un autre, cela perturbera le processus de collecte de donn√©es.  Pourquoi?  Le fait est que le navigateur restreint les applications situ√©es dans les onglets d'arri√®re-plan. <br><br>  Il existe deux situations dans lesquelles les mesures peuvent √™tre d√©form√©es.  En cons√©quence, l'application semblera beaucoup plus lente qu'elle ne l'est r√©ellement. <br><br><ol><li>  L'ordinateur passe en mode veille. </li><li>  L'application s'ex√©cute dans l'onglet d'arri√®re-plan du navigateur. </li></ol><br>  La survenue de ces deux situations n'est pas rare.  Heureusement, nous avons deux options pour les r√©soudre. <br><br>  Premi√®rement, nous pouvons simplement ignorer les m√©triques d√©form√©es, en rejetant les r√©sultats de mesure qui diff√®rent trop de certaines valeurs raisonnables.  Par exemple, le code qui est appel√© lorsqu'un bouton est enfonc√© ne peut tout simplement pas √™tre ex√©cut√© pendant 15 minutes!  C'est peut-√™tre la seule chose dont vous avez besoin pour r√©soudre les deux probl√®mes d√©crits ci-dessus. <br><br>  Deuxi√®mement, vous pouvez utiliser la propri√©t√© <code>document.hidden</code> et l'√©v√©nement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">visibilit√©change</a> .  L'√©v√©nement <code>visibilitychange</code> est d√©clench√© lorsque l'utilisateur passe de l'onglet du navigateur qui vous int√©resse √† un autre onglet ou revient √† l'onglet qui nous int√©resse.  Il est appel√© lorsque la fen√™tre du navigateur minimise ou maximise lorsque l'ordinateur commence √† fonctionner, quitte le mode veille.  En d'autres termes, c'est exactement ce dont nous avons besoin.  De plus, tant que l'onglet est en arri√®re-plan, la propri√©t√© <code>document.hidden</code> est <code>true</code> . <br><br>  Voici un exemple simple illustrant l'utilisation de la propri√©t√© <code>document.hidden</code> et de l'√©v√©nement <code>visibilitychange</code> . <br><br><pre> <code class="plaintext hljs">let lastVisibilityChange = 0 window.addEventListener('visibilitychange', () =&gt; {  lastVisibilityChange = performance.now() }) //    ,      , //  ,   ,     if (metric.start &lt; lastVisibilityChange || document.hidden) return</code> </pre> <br>  Comme vous pouvez le voir, nous supprimons certaines donn√©es, mais c'est bien.  Le fait est que ce sont des donn√©es relatives aux p√©riodes du programme o√π il ne peut pas utiliser pleinement les ressources du syst√®me. <br><br>  Maintenant, nous avons parl√© d'indicateurs qui ne nous int√©ressent pas.  Mais il existe de nombreuses situations, les donn√©es collect√©es dans lesquelles sont tr√®s int√©ressantes pour nous.  Voyons comment collecter ces donn√©es. <br><br><h2>  <font color="#3AC1EF">3. Recherchez l'indicateur qui vous permet de mieux saisir l'heure √† laquelle l'√©v√©nement a commenc√©</font> </h2><br>  L'une des caract√©ristiques les plus controvers√©es de JavaScript est que la boucle d'√©v√©nements de ce langage est monothread.  √Ä un certain moment, un seul morceau de code est capable de s'ex√©cuter, dont l'ex√©cution ne peut pas √™tre interrompue. <br><br>  Si l'utilisateur appuie sur le bouton lors de l'ex√©cution d'un certain code, le programme ne le saura que lorsque l'ex√©cution de ce code sera termin√©e.  Par exemple, si l'application a pass√© 1000 ms dans un cycle continu et que l'utilisateur a appuy√© sur le bouton <code>Escape</code> 100 ms apr√®s le d√©but du cycle, l'√©v√©nement ne sera pas enregistr√© pendant 900 ms suppl√©mentaires. <br><br>  Cela peut gravement d√©former les mesures.  Si nous avons besoin de pr√©cision pour mesurer exactement comment l'utilisateur per√ßoit travailler avec le programme, alors c'est un √©norme probl√®me! <br><br>  Heureusement, r√©soudre ce probl√®me n'est pas si difficile.  Si nous parlons de l'√©v√©nement en cours, nous pouvons, au lieu d'utiliser <code>performance.now()</code> (l'heure √† laquelle nous avons vu l'√©v√©nement), utiliser <code>window.event.timeStamp</code> (l'heure √† laquelle l'√©v√©nement a √©t√© cr√©√©). <br><br>  L'horodatage de l'√©v√©nement est d√©fini par le processus du navigateur principal.  √âtant donn√© que ce processus ne se bloque pas lorsque la boucle d'√©v√©nements JS est verrouill√©e, <code>event.timeStamp</code> nous donne des informations beaucoup plus pr√©cieuses sur le moment o√π l'√©v√©nement a √©t√© r√©ellement d√©clench√©. <br><br>  Il est √† noter que ce m√©canisme n'est pas id√©al.  Ainsi, entre le moment o√π le bouton physique est enfonc√© et le moment o√π l'√©v√©nement correspondant arrive dans Chrome, il s'√©coule 9 √† 15 ms de temps non comptabilis√© ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici un</a> excellent article √† partir duquel vous pouvez savoir pourquoi cela se produit). <br><br>  Cependant, m√™me si nous pouvons mesurer le temps n√©cessaire √† l'√©v√©nement pour atteindre Chrome, nous ne devons pas inclure ce temps dans nos statistiques.  Pourquoi?  Le fait est que nous ne pouvons pas introduire de telles optimisations dans le code qui peuvent affecter de mani√®re significative ces retards.  Nous ne pouvons en aucun cas les am√©liorer. <br><br>  Par cons√©quent, si nous parlons de trouver l'horodatage pour le d√©but de l'√©v√©nement, l'indicateur <code>event.timeStamp</code> semble le plus appropri√© ici. <br><br>  Quelle est la meilleure estimation de la fin de l'√©v√©nement? <br><br><h2>  <font color="#3AC1EF">4. D√©sactivez le minuteur dans requestAnimationFrame ()</font> </h2><br>  Une autre cons√©quence d√©coule des fonctionnalit√©s du p√©riph√©rique de boucle d'√©v√©nements en JavaScript: du code qui n'est pas li√© √† votre code peut √™tre ex√©cut√© apr√®s, mais avant que le navigateur affiche une version mise √† jour de la page √† l'√©cran. <br><br>  Prenons par exemple React.  Apr√®s avoir ex√©cut√© votre code, React met √† jour le DOM.  Si vous ne mesurez que le temps dans votre code, cela signifie que vous ne mesurerez pas le temps n√©cessaire pour ex√©cuter le code React. <br><br>  Afin de mesurer ce temps suppl√©mentaire, nous utilisons <code>requestAnimationFrame()</code> pour d√©sactiver le minuteur.  Cela se fait uniquement lorsque le navigateur est pr√™t √† sortir la trame suivante. <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; { metric.finish(performance.now()) })</code> </pre> <br>  Voici le cycle de vie du cadre (le diagramme est tir√© de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> merveilleux mat√©riau sur <code>requestAnimationFrame</code> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/403/439/0d4/4034390d4dd3060d8653bf03d72d4ca2.png"></div><br>  <i><font color="#999999">Cycle de vie du cadre</font></i> <br><br>  Comme vous pouvez le voir sur cette figure, <code>requestAnimationFrame()</code> est appel√©e une fois le processeur termin√©, juste avant l'affichage du cadre.  Si nous d√©sactivons la minuterie ici, cela signifie que nous pouvons √™tre absolument s√ªrs que tout ce qui a pris le temps de rafra√Æchir l'√©cran est inclus dans les donn√©es collect√©es sur l'intervalle de temps. <br><br>  Jusqu'ici tout va bien, mais maintenant la situation devient plut√¥t compliqu√©e ... <br><br><h2>  <font color="#3AC1EF">5. Ignorer le temps requis pour cr√©er une mise en page et sa visualisation.</font> </h2><br>  Le diagramme pr√©c√©dent, montrant le cycle de vie d'une trame, illustre un autre probl√®me que nous avons rencontr√©.  √Ä la fin du cycle de vie du cadre, il y a des blocs de mise en page (formant une mise en page) et Paint (affichant une page).  Si vous ne tenez pas compte du temps n√©cessaire pour terminer ces op√©rations, le temps mesur√© par nous sera inf√©rieur au temps n√©cessaire pour que certaines donn√©es mises √† jour apparaissent √† l'√©cran. <br><br>  Heureusement, <code>requestAnimationFrame</code> a un autre as dans sa manche.  Lorsque la fonction pass√©e par <code>requestAnimationFrame</code> appel√©e, cette fonction re√ßoit un horodatage indiquant l'heure de d√©but de la formation de la trame actuelle (c'est-√†-dire celle situ√©e dans la partie tout √† gauche de notre diagramme).  Cet horodatage est g√©n√©ralement tr√®s proche de l'heure de fin de l'image pr√©c√©dente. <br><br>  Par cons√©quent, l'inconv√©nient ci-dessus peut √™tre corrig√© en mesurant le temps total √©coul√© entre le moment de <code>event.timeStamp</code> et le moment o√π la formation de la trame suivante commence.  Notez le <code>requestAnimationFrame</code> imbriqu√©: <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; {  requestAnimationFrame((timestamp) =&gt; { metric.finish(timestamp) }) })</code> </pre> <br>  Bien que ce qui est montr√© ci-dessus ressemble √† une excellente solution au probl√®me, nous avons finalement d√©cid√© de ne pas utiliser cette conception.  Le fait est que, bien que cette technique permette d'obtenir des donn√©es plus fiables, la pr√©cision de ces donn√©es est r√©duite.  Les cadres dans Chrome sont form√©s avec une fr√©quence de 16 ms.  Cela signifie que la pr√©cision la plus √©lev√©e √† notre disposition est de ¬± 16 ms.  Et si le navigateur est surcharg√© et saute des images, la pr√©cision sera encore plus faible et cette d√©t√©rioration sera impr√©visible. <br><br>  Si vous impl√©mentez cette solution, une am√©lioration s√©rieuse des performances de votre code, telle que l'acc√©l√©ration d'une t√¢che pr√©c√©demment effectu√©e de 32 ms, jusqu'√† 15 ms, peut ne pas affecter les r√©sultats de la mesure des performances. <br><br>  Sans prendre en compte le temps n√©cessaire pour cr√©er une mise en page et sa sortie, nous obtenons des m√©triques beaucoup plus pr√©cises (¬± 100 Œºs) pour le code qui est sous notre contr√¥le.  Par cons√©quent, nous pouvons obtenir une expression num√©rique de toute am√©lioration apport√©e √† ce code. <br><br>  Nous avons √©galement explor√© une id√©e similaire: <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; {  setTimeout(() =&gt; { metric.finish(performance.now()) } })</code> </pre> <br>  Cela inclura le temps de rendu, mais la pr√©cision de l'indicateur ne sera pas limit√©e √† ¬± 16 ms.  Cependant, nous avons d√©cid√© de ne pas utiliser cette approche non plus.  Si le syst√®me rencontre un long √©v√©nement d'entr√©e, alors l'appel √† quel <code>setTimeout</code> transmis peut √™tre consid√©rablement retard√© et ex√©cut√© apr√®s la mise √† jour de l'interface utilisateur. <br><br><h2>  <font color="#3AC1EF">6. Clarification du ¬´pourcentage d'√©v√©nements inf√©rieurs √† l'objectif¬ª</font> </h2><br>  Nous d√©veloppons un projet et misons sur la haute performance, en essayant de l'optimiser de deux mani√®res: <br><br><ol><li>  La vitesse.  Le temps d'ex√©cution de la t√¢che la plus rapide doit √™tre aussi proche que possible de 0 ms. </li><li>  Uniformit√©.  Le temps d'ex√©cution de la t√¢che la plus lente doit √™tre aussi proche que possible du temps d'ex√©cution de la t√¢che la plus rapide. </li></ol><br>  √âtant donn√© que ces indicateurs changent avec le temps, ils sont difficiles √† visualiser et difficiles √† discuter.  Est-il possible de cr√©er un syst√®me de visualisation de tels indicateurs qui nous inciterait √† optimiser √† la fois la vitesse et l'uniformit√©? <br><br>  Une approche typique consiste √† mesurer le 90e centile de retard.  Cette approche vous permet de dessiner un graphique lin√©aire le long de l'axe Y dont le temps en millisecondes est enregistr√©.  Ce graphique vous permet de voir que 90% des √©v√©nements sont en dessous du graphique lin√©aire, c'est-√†-dire qu'ils s'ex√©cutent plus rapidement que le temps indiqu√© par le graphique lin√©aire. <br><br>  On sait que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">100 ms</a> est la fronti√®re entre ce qui est per√ßu comme "rapide" et "lent". <br><br>  Mais que d√©couvrirons-nous comment les utilisateurs se sentent du travail si nous savons que le 90e centile de retard est de 103 ms?  Pas particuli√®rement.  Quels indicateurs permettront aux utilisateurs d'√™tre utilisables?  Il n'y a aucun moyen de le savoir avec certitude. <br><br>  Mais que faire si nous savons que le 90e centile du retard est de 93 ms?  Le sentiment est que 93 est meilleur que 103, mais nous ne pouvons rien dire de plus sur ces indicateurs, ainsi que sur leur signification en termes de perception des utilisateurs du projet.  Encore une fois, il n'y a pas de r√©ponse exacte √† cette question. <br><br>  Nous avons trouv√© une solution √† ce probl√®me.  Elle consiste √† mesurer le pourcentage d'√©v√©nements dont le temps d'ex√©cution ne d√©passe pas 100 ms.  Cette approche pr√©sente trois grands avantages: <br><br><ul><li>  La m√©trique est orient√©e utilisateur.  Elle peut nous dire quel pourcentage du temps notre application est rapide et quel pourcentage d'utilisateurs la per√ßoivent comme rapide. </li><li>  Cette m√©trique nous permet de ramener les mesures √† la pr√©cision qui a √©t√© perdue du fait que nous n'avons pas mesur√© le temps n√©cessaire pour terminer les t√¢ches √† la toute fin de la trame (nous en avons parl√© dans la section n ¬∞ 5).  √âtant donn√© que nous avons d√©fini un indicateur cible qui s'inscrit dans plusieurs cadres, les r√©sultats de mesure qui sont proches de cet indicateur se r√©v√®lent √™tre inf√©rieurs √† lui ou sup√©rieurs. </li><li>  Cette m√©trique est plus facile √† calculer.  Il suffit de calculer simplement le nombre d'√©v√©nements dont le temps d'ex√©cution est inf√©rieur √† l'indicateur cible, puis de les diviser par le nombre total d'√©v√©nements.  Les centiles sont beaucoup plus difficiles √† compter.  Il existe des approximations efficaces, mais pour tout faire correctement, vous devez prendre en compte chaque dimension. </li></ul><br>  Cette approche n'a qu'un inconv√©nient: si les indicateurs sont pires que l'objectif, il sera difficile de remarquer leur am√©lioration. <br><br><h2>  <font color="#3AC1EF">7. L'utilisation de plusieurs valeurs seuils dans l'analyse des indicateurs</font> </h2><br>  Afin de visualiser le r√©sultat de l'optimisation des performances, nous avons introduit plusieurs valeurs de seuil suppl√©mentaires dans notre syst√®me - sup√©rieures √† 100 ms et inf√©rieures. <br><br>  Nous avons regroup√© les retards comme ceci: <br><br><ul><li>  Moins de 50 ms (rapide). </li><li>  50 √† 100 ms (bon). </li><li>  100 √† 1000 ms (lent). </li><li>  Plus de 1000 ms (terriblement lent). </li></ul><br>  Des r√©sultats ¬´terriblement lents¬ª nous permettent de constater que nous avons beaucoup manqu√© quelque part.  Par cons√©quent, nous les mettons en surbrillance en rouge vif. <br><br>  Ce qui tient en 50 ms est tr√®s sensible aux changements.  Ici, les am√©liorations de performances sont souvent visibles bien avant d'√™tre visibles dans un groupe correspondant √† 100 ms. <br><br>  Par exemple, le graphique suivant illustre les performances de l'affichage des threads dans Superhuman. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb5/773/9e8/eb57739e82476e3b7a2c9212908ff5bf.png"></div><br>  <i><font color="#999999">Afficher le fil</font></i> <br><br>  Il montre la p√©riode de baisse des performances, puis - les r√©sultats des am√©liorations.  Il est difficile d'√©valuer la baisse de performance si vous ne regardez que les indicateurs correspondant √† 100 ms (les parties sup√©rieures des colonnes bleues).  Lorsque l'on regarde les r√©sultats qui correspondent √† 50 ms (les parties sup√©rieures des colonnes vertes), les probl√®mes de performances sont d√©j√† bien plus visibles. <br><br>  Si nous avions utilis√© l'approche traditionnelle pour √©tudier les mesures de performance, nous n'aurions probablement pas remarqu√© un probl√®me dont l'effet sur le syst√®me est illustr√© dans la figure pr√©c√©dente.  Mais gr√¢ce √† la fa√ßon dont nous prenons les mesures et √† la fa√ßon dont nous visualisons nos m√©triques, nous avons pu trouver et r√©soudre tr√®s rapidement un probl√®me. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  Il s'est av√©r√© qu'il √©tait √©tonnamment difficile de trouver la bonne approche pour travailler avec des mesures de performance.  Nous avons r√©ussi √† d√©velopper une m√©thodologie qui nous permet de cr√©er des outils de haute qualit√© pour mesurer la performance des applications web.  √Ä savoir, nous parlons de ce qui suit: <br><br><ol><li>  L'heure de d√©but d'un √©v√©nement est mesur√©e √† l'aide de <code>event.timeStamp</code> . </li><li>  L'heure de fin de l'√©v√©nement est mesur√©e √† l'aide de <code>performance.now()</code> dans le rappel pass√© √† <code>requestAnimationFrame()</code> . </li><li>  Tout ce qui se passe avec l'application lorsqu'elle se trouve dans l'onglet du navigateur inactif est ignor√©. </li><li>  Les donn√©es sont agr√©g√©es √† l'aide d'un indicateur, qui peut √™tre d√©crit comme ¬´le pourcentage d'√©v√©nements inf√©rieurs √† l'objectif¬ª. </li><li>  Les donn√©es sont visualis√©es avec plusieurs niveaux de valeurs de seuil. </li></ol><br>  Cette technique vous donne les outils pour cr√©er des mesures fiables et pr√©cises.  Vous pouvez cr√©er des graphiques qui montrent clairement une baisse des performances, vous pouvez visualiser les r√©sultats des optimisations.  Et le plus important - vous avez la possibilit√© de r√©aliser des projets rapides encore plus rapidement. <br><br>  <b>Chers lecteurs!</b>  Comment analysez-vous les performances de vos applications Web? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr470872/">https://habr.com/ru/post/fr470872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr470856/index.html">Telegram GRAM Wallet: conditions d'utilisation</a></li>
<li><a href="../fr470858/index.html">Antiquit√©s: r√©f√©rence du 386e processeur et des ann√©es 90 fringantes</a></li>
<li><a href="../fr470864/index.html">√Ä propos des plaisirs de passer au panneau et pas seulement</a></li>
<li><a href="../fr470868/index.html">Temps de premier octet: qu'est-ce que c'est et pourquoi est-il important</a></li>
<li><a href="../fr470870/index.html">Pr√©chargement des polices</a></li>
<li><a href="../fr470874/index.html">Optimiser le chargement de JavaScript sur Wikipedia</a></li>
<li><a href="../fr470876/index.html">Cr√©ez des constructions de syntaxe JavaScript personnalis√©es √† l'aide de Babel. Partie 1</a></li>
<li><a href="../fr470878/index.html">Cr√©ez des constructions de syntaxe JavaScript personnalis√©es √† l'aide de Babel. 2e partie</a></li>
<li><a href="../fr470880/index.html">M√©canique du jeu. Aventure, le concept de l'orthophonie z√©ro et convaincante</a></li>
<li><a href="../fr470882/index.html">Pourquoi avez-vous attrap√© ma souris ou un jeu de soci√©t√© comme mod√®le d'interaction sociale</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>