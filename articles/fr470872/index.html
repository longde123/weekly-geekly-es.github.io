<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🎤 👩🏾‍🤝‍👨🏿 🧓🏼 Mesures de performances pour la recherche d'applications Web incroyablement rapides 🏂🏿 🕴🏾 🙄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a un dicton: "Ce que vous ne pouvez pas mesurer, vous ne pouvez pas l'améliorer." L'auteur de l'article, dont nous publions aujourd'hui la traduc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mesures de performances pour la recherche d'applications Web incroyablement rapides</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/470872/">  Il y a un dicton: "Ce que vous ne pouvez pas mesurer, vous ne pouvez pas l'améliorer."  L'auteur de l'article, dont nous publions aujourd'hui la traduction, travaille pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Superhuman</a> .  Il dit que cette entreprise développe le client de messagerie le plus rapide au monde.  Nous parlerons ici de ce qui est «rapide» et de la façon de créer des outils pour mesurer les performances d'applications Web incroyablement rapides. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/q6/af/pp/q6afppxtd4rv6r-iqwvk9-6nyai.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Mesure de vitesse d'application</font> </h2><br>  Afin d'améliorer notre développement, nous avons passé beaucoup de temps à mesurer sa vitesse.  Et, comme il s'est avéré, les mesures de performance sont des indicateurs qui sont étonnamment difficiles à comprendre et à appliquer. <br><br>  D'une part, il est difficile de concevoir des métriques qui décrivent avec précision les sensations ressenties par l'utilisateur lors de l'utilisation du système.  D'un autre côté, il n'est pas facile de créer des métriques si précises que leur analyse vous permet de prendre des décisions éclairées.  Par conséquent, de nombreuses équipes de développement ne peuvent pas faire confiance aux données qu'elles collectent sur la performance de leurs projets. <br><br>  Même si les développeurs disposent de mesures fiables et précises, leur utilisation n'est pas facile.  Comment définir le terme «rapide»?  Comment trouver un équilibre entre vitesse et cohérence?  Comment apprendre à détecter rapidement la dégradation des performances ou à évaluer l'impact des optimisations sur le système? <br><br>  Ici, nous voulons partager quelques réflexions concernant le développement d'outils d'analyse des performances des applications Web. <br><br><h2>  <font color="#3AC1EF">1. Utiliser la bonne «horloge»</font> </h2><br>  JavaScript dispose de deux mécanismes pour récupérer les horodatages: <code>performance.now()</code> et <code>new Date()</code> . <br><br>  En quoi diffèrent-ils?  Les deux différences suivantes sont fondamentales pour nous: <br><br><ul><li>  La méthode <code>performance.now()</code> est beaucoup plus précise.  La précision de la <code>new Date()</code> construction <code>new Date()</code> est de ± 1 ms, tandis que la précision de <code>performance.now()</code> est déjà de ± 100 µs (oui, il s'agit de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">microsecondes</a> !). </li><li>  Les valeurs renvoyées par la méthode <code>performance.now()</code> augmentent toujours à un taux constant et sont indépendantes de l'heure système.  Cette méthode mesure simplement les intervalles de temps sans se concentrer sur l'heure du système.  Et à la <code>new Date()</code> heure <code>new Date()</code> système affecte.  Si vous réorganisez l'horloge système, cela modifiera également le retour de la <code>new Date ()</code> , ce qui ruinera les données de surveillance des performances. </li></ul><br>  Bien que les «horloges» représentées par la méthode <code>performance.now()</code> soient évidemment beaucoup mieux adaptées à la mesure des intervalles de temps, elles ne sont pas idéales non plus.  <code>performance.now()</code> et <code>new Date()</code> souffrent tous deux du même problème, qui se manifeste dans le cas où le système est en veille: les mesures incluent le moment où la machine n'était même pas active. <br><br><h2>  <font color="#3AC1EF">2. Vérification de l'activité de l'application</font> </h2><br>  Si vous, en mesurant les performances d'une application Web, passez de son onglet à un autre, cela perturbera le processus de collecte de données.  Pourquoi?  Le fait est que le navigateur restreint les applications situées dans les onglets d'arrière-plan. <br><br>  Il existe deux situations dans lesquelles les mesures peuvent être déformées.  En conséquence, l'application semblera beaucoup plus lente qu'elle ne l'est réellement. <br><br><ol><li>  L'ordinateur passe en mode veille. </li><li>  L'application s'exécute dans l'onglet d'arrière-plan du navigateur. </li></ol><br>  La survenue de ces deux situations n'est pas rare.  Heureusement, nous avons deux options pour les résoudre. <br><br>  Premièrement, nous pouvons simplement ignorer les métriques déformées, en rejetant les résultats de mesure qui diffèrent trop de certaines valeurs raisonnables.  Par exemple, le code qui est appelé lorsqu'un bouton est enfoncé ne peut tout simplement pas être exécuté pendant 15 minutes!  C'est peut-être la seule chose dont vous avez besoin pour résoudre les deux problèmes décrits ci-dessus. <br><br>  Deuxièmement, vous pouvez utiliser la propriété <code>document.hidden</code> et l'événement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">visibilitéchange</a> .  L'événement <code>visibilitychange</code> est déclenché lorsque l'utilisateur passe de l'onglet du navigateur qui vous intéresse à un autre onglet ou revient à l'onglet qui nous intéresse.  Il est appelé lorsque la fenêtre du navigateur minimise ou maximise lorsque l'ordinateur commence à fonctionner, quitte le mode veille.  En d'autres termes, c'est exactement ce dont nous avons besoin.  De plus, tant que l'onglet est en arrière-plan, la propriété <code>document.hidden</code> est <code>true</code> . <br><br>  Voici un exemple simple illustrant l'utilisation de la propriété <code>document.hidden</code> et de l'événement <code>visibilitychange</code> . <br><br><pre> <code class="plaintext hljs">let lastVisibilityChange = 0 window.addEventListener('visibilitychange', () =&gt; {  lastVisibilityChange = performance.now() }) //    ,      , //  ,   ,     if (metric.start &lt; lastVisibilityChange || document.hidden) return</code> </pre> <br>  Comme vous pouvez le voir, nous supprimons certaines données, mais c'est bien.  Le fait est que ce sont des données relatives aux périodes du programme où il ne peut pas utiliser pleinement les ressources du système. <br><br>  Maintenant, nous avons parlé d'indicateurs qui ne nous intéressent pas.  Mais il existe de nombreuses situations, les données collectées dans lesquelles sont très intéressantes pour nous.  Voyons comment collecter ces données. <br><br><h2>  <font color="#3AC1EF">3. Recherchez l'indicateur qui vous permet de mieux saisir l'heure à laquelle l'événement a commencé</font> </h2><br>  L'une des caractéristiques les plus controversées de JavaScript est que la boucle d'événements de ce langage est monothread.  À un certain moment, un seul morceau de code est capable de s'exécuter, dont l'exécution ne peut pas être interrompue. <br><br>  Si l'utilisateur appuie sur le bouton lors de l'exécution d'un certain code, le programme ne le saura que lorsque l'exécution de ce code sera terminée.  Par exemple, si l'application a passé 1000 ms dans un cycle continu et que l'utilisateur a appuyé sur le bouton <code>Escape</code> 100 ms après le début du cycle, l'événement ne sera pas enregistré pendant 900 ms supplémentaires. <br><br>  Cela peut gravement déformer les mesures.  Si nous avons besoin de précision pour mesurer exactement comment l'utilisateur perçoit travailler avec le programme, alors c'est un énorme problème! <br><br>  Heureusement, résoudre ce problème n'est pas si difficile.  Si nous parlons de l'événement en cours, nous pouvons, au lieu d'utiliser <code>performance.now()</code> (l'heure à laquelle nous avons vu l'événement), utiliser <code>window.event.timeStamp</code> (l'heure à laquelle l'événement a été créé). <br><br>  L'horodatage de l'événement est défini par le processus du navigateur principal.  Étant donné que ce processus ne se bloque pas lorsque la boucle d'événements JS est verrouillée, <code>event.timeStamp</code> nous donne des informations beaucoup plus précieuses sur le moment où l'événement a été réellement déclenché. <br><br>  Il est à noter que ce mécanisme n'est pas idéal.  Ainsi, entre le moment où le bouton physique est enfoncé et le moment où l'événement correspondant arrive dans Chrome, il s'écoule 9 à 15 ms de temps non comptabilisé ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici un</a> excellent article à partir duquel vous pouvez savoir pourquoi cela se produit). <br><br>  Cependant, même si nous pouvons mesurer le temps nécessaire à l'événement pour atteindre Chrome, nous ne devons pas inclure ce temps dans nos statistiques.  Pourquoi?  Le fait est que nous ne pouvons pas introduire de telles optimisations dans le code qui peuvent affecter de manière significative ces retards.  Nous ne pouvons en aucun cas les améliorer. <br><br>  Par conséquent, si nous parlons de trouver l'horodatage pour le début de l'événement, l'indicateur <code>event.timeStamp</code> semble le plus approprié ici. <br><br>  Quelle est la meilleure estimation de la fin de l'événement? <br><br><h2>  <font color="#3AC1EF">4. Désactivez le minuteur dans requestAnimationFrame ()</font> </h2><br>  Une autre conséquence découle des fonctionnalités du périphérique de boucle d'événements en JavaScript: du code qui n'est pas lié à votre code peut être exécuté après, mais avant que le navigateur affiche une version mise à jour de la page à l'écran. <br><br>  Prenons par exemple React.  Après avoir exécuté votre code, React met à jour le DOM.  Si vous ne mesurez que le temps dans votre code, cela signifie que vous ne mesurerez pas le temps nécessaire pour exécuter le code React. <br><br>  Afin de mesurer ce temps supplémentaire, nous utilisons <code>requestAnimationFrame()</code> pour désactiver le minuteur.  Cela se fait uniquement lorsque le navigateur est prêt à sortir la trame suivante. <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; { metric.finish(performance.now()) })</code> </pre> <br>  Voici le cycle de vie du cadre (le diagramme est tiré de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> merveilleux matériau sur <code>requestAnimationFrame</code> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/403/439/0d4/4034390d4dd3060d8653bf03d72d4ca2.png"></div><br>  <i><font color="#999999">Cycle de vie du cadre</font></i> <br><br>  Comme vous pouvez le voir sur cette figure, <code>requestAnimationFrame()</code> est appelée une fois le processeur terminé, juste avant l'affichage du cadre.  Si nous désactivons la minuterie ici, cela signifie que nous pouvons être absolument sûrs que tout ce qui a pris le temps de rafraîchir l'écran est inclus dans les données collectées sur l'intervalle de temps. <br><br>  Jusqu'ici tout va bien, mais maintenant la situation devient plutôt compliquée ... <br><br><h2>  <font color="#3AC1EF">5. Ignorer le temps requis pour créer une mise en page et sa visualisation.</font> </h2><br>  Le diagramme précédent, montrant le cycle de vie d'une trame, illustre un autre problème que nous avons rencontré.  À la fin du cycle de vie du cadre, il y a des blocs de mise en page (formant une mise en page) et Paint (affichant une page).  Si vous ne tenez pas compte du temps nécessaire pour terminer ces opérations, le temps mesuré par nous sera inférieur au temps nécessaire pour que certaines données mises à jour apparaissent à l'écran. <br><br>  Heureusement, <code>requestAnimationFrame</code> a un autre as dans sa manche.  Lorsque la fonction passée par <code>requestAnimationFrame</code> appelée, cette fonction reçoit un horodatage indiquant l'heure de début de la formation de la trame actuelle (c'est-à-dire celle située dans la partie tout à gauche de notre diagramme).  Cet horodatage est généralement très proche de l'heure de fin de l'image précédente. <br><br>  Par conséquent, l'inconvénient ci-dessus peut être corrigé en mesurant le temps total écoulé entre le moment de <code>event.timeStamp</code> et le moment où la formation de la trame suivante commence.  Notez le <code>requestAnimationFrame</code> imbriqué: <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; {  requestAnimationFrame((timestamp) =&gt; { metric.finish(timestamp) }) })</code> </pre> <br>  Bien que ce qui est montré ci-dessus ressemble à une excellente solution au problème, nous avons finalement décidé de ne pas utiliser cette conception.  Le fait est que, bien que cette technique permette d'obtenir des données plus fiables, la précision de ces données est réduite.  Les cadres dans Chrome sont formés avec une fréquence de 16 ms.  Cela signifie que la précision la plus élevée à notre disposition est de ± 16 ms.  Et si le navigateur est surchargé et saute des images, la précision sera encore plus faible et cette détérioration sera imprévisible. <br><br>  Si vous implémentez cette solution, une amélioration sérieuse des performances de votre code, telle que l'accélération d'une tâche précédemment effectuée de 32 ms, jusqu'à 15 ms, peut ne pas affecter les résultats de la mesure des performances. <br><br>  Sans prendre en compte le temps nécessaire pour créer une mise en page et sa sortie, nous obtenons des métriques beaucoup plus précises (± 100 μs) pour le code qui est sous notre contrôle.  Par conséquent, nous pouvons obtenir une expression numérique de toute amélioration apportée à ce code. <br><br>  Nous avons également exploré une idée similaire: <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; {  setTimeout(() =&gt; { metric.finish(performance.now()) } })</code> </pre> <br>  Cela inclura le temps de rendu, mais la précision de l'indicateur ne sera pas limitée à ± 16 ms.  Cependant, nous avons décidé de ne pas utiliser cette approche non plus.  Si le système rencontre un long événement d'entrée, alors l'appel à quel <code>setTimeout</code> transmis peut être considérablement retardé et exécuté après la mise à jour de l'interface utilisateur. <br><br><h2>  <font color="#3AC1EF">6. Clarification du «pourcentage d'événements inférieurs à l'objectif»</font> </h2><br>  Nous développons un projet et misons sur la haute performance, en essayant de l'optimiser de deux manières: <br><br><ol><li>  La vitesse.  Le temps d'exécution de la tâche la plus rapide doit être aussi proche que possible de 0 ms. </li><li>  Uniformité.  Le temps d'exécution de la tâche la plus lente doit être aussi proche que possible du temps d'exécution de la tâche la plus rapide. </li></ol><br>  Étant donné que ces indicateurs changent avec le temps, ils sont difficiles à visualiser et difficiles à discuter.  Est-il possible de créer un système de visualisation de tels indicateurs qui nous inciterait à optimiser à la fois la vitesse et l'uniformité? <br><br>  Une approche typique consiste à mesurer le 90e centile de retard.  Cette approche vous permet de dessiner un graphique linéaire le long de l'axe Y dont le temps en millisecondes est enregistré.  Ce graphique vous permet de voir que 90% des événements sont en dessous du graphique linéaire, c'est-à-dire qu'ils s'exécutent plus rapidement que le temps indiqué par le graphique linéaire. <br><br>  On sait que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">100 ms</a> est la frontière entre ce qui est perçu comme "rapide" et "lent". <br><br>  Mais que découvrirons-nous comment les utilisateurs se sentent du travail si nous savons que le 90e centile de retard est de 103 ms?  Pas particulièrement.  Quels indicateurs permettront aux utilisateurs d'être utilisables?  Il n'y a aucun moyen de le savoir avec certitude. <br><br>  Mais que faire si nous savons que le 90e centile du retard est de 93 ms?  Le sentiment est que 93 est meilleur que 103, mais nous ne pouvons rien dire de plus sur ces indicateurs, ainsi que sur leur signification en termes de perception des utilisateurs du projet.  Encore une fois, il n'y a pas de réponse exacte à cette question. <br><br>  Nous avons trouvé une solution à ce problème.  Elle consiste à mesurer le pourcentage d'événements dont le temps d'exécution ne dépasse pas 100 ms.  Cette approche présente trois grands avantages: <br><br><ul><li>  La métrique est orientée utilisateur.  Elle peut nous dire quel pourcentage du temps notre application est rapide et quel pourcentage d'utilisateurs la perçoivent comme rapide. </li><li>  Cette métrique nous permet de ramener les mesures à la précision qui a été perdue du fait que nous n'avons pas mesuré le temps nécessaire pour terminer les tâches à la toute fin de la trame (nous en avons parlé dans la section n ° 5).  Étant donné que nous avons défini un indicateur cible qui s'inscrit dans plusieurs cadres, les résultats de mesure qui sont proches de cet indicateur se révèlent être inférieurs à lui ou supérieurs. </li><li>  Cette métrique est plus facile à calculer.  Il suffit de calculer simplement le nombre d'événements dont le temps d'exécution est inférieur à l'indicateur cible, puis de les diviser par le nombre total d'événements.  Les centiles sont beaucoup plus difficiles à compter.  Il existe des approximations efficaces, mais pour tout faire correctement, vous devez prendre en compte chaque dimension. </li></ul><br>  Cette approche n'a qu'un inconvénient: si les indicateurs sont pires que l'objectif, il sera difficile de remarquer leur amélioration. <br><br><h2>  <font color="#3AC1EF">7. L'utilisation de plusieurs valeurs seuils dans l'analyse des indicateurs</font> </h2><br>  Afin de visualiser le résultat de l'optimisation des performances, nous avons introduit plusieurs valeurs de seuil supplémentaires dans notre système - supérieures à 100 ms et inférieures. <br><br>  Nous avons regroupé les retards comme ceci: <br><br><ul><li>  Moins de 50 ms (rapide). </li><li>  50 à 100 ms (bon). </li><li>  100 à 1000 ms (lent). </li><li>  Plus de 1000 ms (terriblement lent). </li></ul><br>  Des résultats «terriblement lents» nous permettent de constater que nous avons beaucoup manqué quelque part.  Par conséquent, nous les mettons en surbrillance en rouge vif. <br><br>  Ce qui tient en 50 ms est très sensible aux changements.  Ici, les améliorations de performances sont souvent visibles bien avant d'être visibles dans un groupe correspondant à 100 ms. <br><br>  Par exemple, le graphique suivant illustre les performances de l'affichage des threads dans Superhuman. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb5/773/9e8/eb57739e82476e3b7a2c9212908ff5bf.png"></div><br>  <i><font color="#999999">Afficher le fil</font></i> <br><br>  Il montre la période de baisse des performances, puis - les résultats des améliorations.  Il est difficile d'évaluer la baisse de performance si vous ne regardez que les indicateurs correspondant à 100 ms (les parties supérieures des colonnes bleues).  Lorsque l'on regarde les résultats qui correspondent à 50 ms (les parties supérieures des colonnes vertes), les problèmes de performances sont déjà bien plus visibles. <br><br>  Si nous avions utilisé l'approche traditionnelle pour étudier les mesures de performance, nous n'aurions probablement pas remarqué un problème dont l'effet sur le système est illustré dans la figure précédente.  Mais grâce à la façon dont nous prenons les mesures et à la façon dont nous visualisons nos métriques, nous avons pu trouver et résoudre très rapidement un problème. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Il s'est avéré qu'il était étonnamment difficile de trouver la bonne approche pour travailler avec des mesures de performance.  Nous avons réussi à développer une méthodologie qui nous permet de créer des outils de haute qualité pour mesurer la performance des applications web.  À savoir, nous parlons de ce qui suit: <br><br><ol><li>  L'heure de début d'un événement est mesurée à l'aide de <code>event.timeStamp</code> . </li><li>  L'heure de fin de l'événement est mesurée à l'aide de <code>performance.now()</code> dans le rappel passé à <code>requestAnimationFrame()</code> . </li><li>  Tout ce qui se passe avec l'application lorsqu'elle se trouve dans l'onglet du navigateur inactif est ignoré. </li><li>  Les données sont agrégées à l'aide d'un indicateur, qui peut être décrit comme «le pourcentage d'événements inférieurs à l'objectif». </li><li>  Les données sont visualisées avec plusieurs niveaux de valeurs de seuil. </li></ol><br>  Cette technique vous donne les outils pour créer des mesures fiables et précises.  Vous pouvez créer des graphiques qui montrent clairement une baisse des performances, vous pouvez visualiser les résultats des optimisations.  Et le plus important - vous avez la possibilité de réaliser des projets rapides encore plus rapidement. <br><br>  <b>Chers lecteurs!</b>  Comment analysez-vous les performances de vos applications Web? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr470872/">https://habr.com/ru/post/fr470872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr470856/index.html">Telegram GRAM Wallet: conditions d'utilisation</a></li>
<li><a href="../fr470858/index.html">Antiquités: référence du 386e processeur et des années 90 fringantes</a></li>
<li><a href="../fr470864/index.html">À propos des plaisirs de passer au panneau et pas seulement</a></li>
<li><a href="../fr470868/index.html">Temps de premier octet: qu'est-ce que c'est et pourquoi est-il important</a></li>
<li><a href="../fr470870/index.html">Préchargement des polices</a></li>
<li><a href="../fr470874/index.html">Optimiser le chargement de JavaScript sur Wikipedia</a></li>
<li><a href="../fr470876/index.html">Créez des constructions de syntaxe JavaScript personnalisées à l'aide de Babel. Partie 1</a></li>
<li><a href="../fr470878/index.html">Créez des constructions de syntaxe JavaScript personnalisées à l'aide de Babel. 2e partie</a></li>
<li><a href="../fr470880/index.html">Mécanique du jeu. Aventure, le concept de l'orthophonie zéro et convaincante</a></li>
<li><a href="../fr470882/index.html">Pourquoi avez-vous attrapé ma souris ou un jeu de société comme modèle d'interaction sociale</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>