<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title> 硷  Dart 2. Programaci贸n asincr贸nica: flujos de datos   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Programaci贸n asincr贸nica: flujos de datos 


 Contenido 


- Recepci贸n de eventos de transmisi贸n 
- Eventos de error 
- Trabaja con streams 
- Tipos d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dart 2. Programaci贸n asincr贸nica: flujos de datos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442274/"><h1 id="asinhronnoe-programmirovanie-potoki-dannyh">  Programaci贸n asincr贸nica: flujos de datos </h1><br><p>  <strong>Contenido</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Recepci贸n de eventos de transmisi贸n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Eventos de error</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabaja con streams</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tipos de flujo</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Flujos de suscripci贸n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Transmitir transmisiones</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">M茅todos de procesamiento de flujo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">M茅todos de modificaci贸n de flujo</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funci贸n Transform ()</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Leer y decodificar un archivo</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">M茅todo Listen ()</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">驴Qu茅 m谩s leer?</a> </li></ul><br><p>  <strong>Lo que es importante:</strong> </p><br><ul><li>  Las secuencias proporcionan una secuencia de datos asincr贸nica. </li><li>  Las secuencias de datos contienen eventos de usuario y datos le铆dos de archivos. </li><li> La transmisi贸n se puede procesar usando <strong>waitit</strong> o <code>listen()</code> desde la API <code>Stream</code> . </li><li>  Las transmisiones proporcionan una forma de responder a los errores. </li><li>  Hay dos tipos de transmisiones: transmisiones de <code>single subscription</code> y difusi贸n. <a name="habracut"></a></li></ul><br><p>  La programaci贸n asincr贸nica en Dart se caracteriza por las clases <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Future</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Stream</a> . </p><br><p>  <code>Future</code> es un c谩lculo diferido.  Si una funci贸n normal devuelve un resultado, la funci贸n asincr贸nica devuelve un objeto <code>Future</code> ( <code>future</code> ) que finalmente contendr谩 el resultado.  <code>future</code> devolver谩 el resultado cuando se complete la operaci贸n. </p><br><p>  Una secuencia es una secuencia de eventos asincr贸nicos.  Esto es similar a un objeto asincr贸nico <code>Iterable</code> , donde en lugar de recibir el pr贸ximo evento cuando lo solicita, el hilo informa el evento cuando est谩 listo. </p><br><h2 id="poluchenie-sobytiy-potoka">  Recepci贸n de eventos de transmisi贸n </h2><br><p>  Las secuencias se pueden crear de diferentes maneras, que es el tema de otro art铆culo, pero todas se pueden usar de la misma manera: un bucle for asincr贸nico (generalmente llamado <strong>wait for for</strong> ) itera eventos de secuencia, como un bucle <strong>for</strong> itera a trav茅s de una colecci贸n.  Por ejemplo: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; stream)</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value in stream)</span></span></span><span class="hljs-function"> </span></span>{ sum += value; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br><p>  Este c贸digo simplemente recibe el evento entero de la secuencia, los agrega y devuelve la cantidad ( <code>future</code> ).  Cuando finaliza el cuerpo del bucle, la funci贸n se detiene hasta que finaliza el siguiente evento o subproceso. </p><br><p>  La funci贸n est谩 marcada con la <code>async</code> , que se requiere cuando se utiliza el ciclo de <strong>espera</strong> . </p><br><p>  El siguiente ejemplo (en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DartPad</a> ) verifica el c贸digo anterior creando una secuencia simple de enteros utilizando una funci贸n con <code>async*</code> ( <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">generador de</a> notas</em> ): </p><br><div class="spoiler">  <b class="spoiler_title">C贸digo de ejemplo</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Copyright (c) 2015, the Dart project authors. // Please see the AUTHORS file for details. // All rights reserved. Use of this source code is governed // by a BSD-style license that can be found in the LICENSE file. import 'dart:async'; Future&lt;int&gt; sumStream(Stream&lt;int&gt; stream) async { var sum = 0; await for (var value in stream) { sum += value; } return sum; } Stream&lt;int&gt; countStream(int to) async* { for (int i = 1; i &lt;= to; i++) { yield i; } } main() async { var stream = countStream(10); var sum = await sumStream(stream); print(sum); // 55 }</span></span></code> </pre> </div></div><br><h2 id="sobytiya-s-oshibkoy">  Eventos de error </h2><br><p>  Los subprocesos se ejecutan cuando no hay m谩s eventos en ellos, y el c贸digo que recibe los eventos se notifica al respecto de la misma manera que se notifica la llegada de un nuevo evento.  Al leer eventos con <strong>wait for, el</strong> ciclo finaliza cuando finaliza la transmisi贸n. </p><br><p>  En algunos casos, se produce un error antes de que finalice la secuencia;  quiz谩s una falla de red al recuperar un archivo de un servidor remoto o el c贸digo que gener贸 los eventos contiene un error, alguien deber铆a saberlo. </p><br><p>  Las transmisiones pueden informar un evento de error de la misma manera que los eventos de datos.  La mayor铆a de los hilos se detienen despu茅s del primer error, pero son posibles los hilos que devuelven m谩s de un error y los hilos que informan datos despu茅s de un evento de error.  En este documento, discutimos solo hilos que no devuelven m谩s de un error. </p><br><p>  Al leer una secuencia usando <strong>wait for,</strong> el operador de bucle emite <strong>un</strong> error.  Esto tambi茅n completa el ciclo.  Puede detectar el error con try-catch.  En el siguiente ejemplo (en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DartPad</a> ), se produce un error si el iterador de bucle es 4: </p><br><div class="spoiler">  <b class="spoiler_title">C贸digo de ejemplo</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Copyright (c) 2015, the Dart project authors. // Please see the AUTHORS file for details. // All rights reserved. Use of this source code is governed // by a BSD-style license that can be found in the LICENSE file. import 'dart:async'; Future&lt;int&gt; sumStream(Stream&lt;int&gt; stream) async { var sum = 0; try { await for (var value in stream) { sum += value; } } catch (e) { return -1; } return sum; } Stream&lt;int&gt; countStream(int to) async* { for (int i = 1; i &lt;= to; i++) { if (i == 4) { throw new Exception('Intentional exception'); } else { yield i; } } } main() async { var stream = countStream(10); var sum = await sumStream(stream); print(sum); // -1 }</span></span></code> </pre> </div></div><br><h2 id="rabota-s-potokami">  Trabaja con streams </h2><br><p>  La clase <code>Stream</code> contiene varios m茅todos auxiliares que pueden realizar operaciones generales en un flujo, similar a los m茅todos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Iterable</a> .  Por ejemplo, puede encontrar el entero positivo m谩s peque帽o en una secuencia usando <code>lastWhere()</code> de la API de <code>Stream</code> . </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastPositive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; stream)</span></span></span><span class="hljs-function"> </span></span>=&gt; stream.lastWhere((x) =&gt; x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><h2 id="tipy-potokov">  Tipos de flujo </h2><br><h3 id="potoki-podpiski">  Flujos de suscripci贸n </h3><br><p>  El tipo de secuencia m谩s com煤n contiene una secuencia de eventos que son partes de un todo m谩s grande.  Los eventos deben entregarse en el orden correcto sin perder ninguno de ellos.  Este es el tipo de transmisi贸n que recibe cuando lee un archivo o recibe una solicitud web. </p><br><p>  Dicha transmisi贸n solo se puede escuchar una vez.  Escuchar m谩s tarde puede significar omitir los eventos iniciales, y luego el resto de la transmisi贸n no tiene sentido.  Cuando comience a escuchar, los datos se extraer谩n y se proporcionar谩n en partes. </p><br><h3 id="shirokoveschatelnye-potoki">  Transmitir transmisiones </h3><br><p>  Otro tipo de transmisi贸n es para mensajes individuales que pueden procesarse uno a la vez.  Dicha secuencia se puede utilizar, por ejemplo, para eventos del mouse en un navegador. </p><br><p>  Puede comenzar a escuchar dicha transmisi贸n en cualquier momento, y recibir谩 eventos que ocurrieron durante la escucha.  Stream puede escuchar a varios oyentes.  Puede comenzar a escuchar eventos de transmisi贸n nuevamente despu茅s de cancelar una suscripci贸n anterior. </p><br><h2 id="metody-obrabatyvayuschie-potok">  M茅todos de procesamiento de flujo </h2><br><p>  Los siguientes m茅todos en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">secuencia &lt;T&gt;</a> procesan la secuencia y devuelven el resultado: </p><br><pre> <code class="java hljs">Future&lt;T&gt; get first; Future&lt;bool&gt; get isEmpty; Future&lt;T&gt; get last; Future&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; get length; Future&lt;T&gt; get single; <span class="hljs-function"><span class="hljs-function">Future&lt;bool&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test)</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;bool&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object needle)</span></span></span></span>; Future&lt;E&gt; drain&lt;E&gt;([E futureValue]); <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elementAt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;bool&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">every</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test)</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firstWhere</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test, </span></span>{<span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> orElse})</span></span>; Future&lt;S&gt; fold&lt;S&gt;(S initialValue, <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S previous, T element)</span></span></span><span class="hljs-function"> combine)</span></span>; <span class="hljs-function"><span class="hljs-function">Future </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function(T element)</span></span></span><span class="hljs-function"> action)</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([String separator = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastWhere</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test, </span></span>{<span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> orElse})</span></span>; <span class="hljs-function"><span class="hljs-function">Future </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pipe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StreamConsumer&lt;T&gt; streamConsumer)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T Function(T previous, T element)</span></span></span><span class="hljs-function"> combine)</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">singleWhere</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test, </span></span>{<span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> orElse})</span></span>; Future&lt;List&lt;T&gt;&gt; toList(); Future&lt;Set&lt;T&gt;&gt; toSet();</code> </pre> <br><p>  Todas estas funciones, excepto <code>drain()</code> y <code>pipe()</code> , corresponden a una funci贸n similar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Iterable</a> .  Cada uno de ellos se puede escribir f谩cilmente usando una funci贸n asincr贸nica con un ciclo de <strong>espera</strong> (o simplemente usando uno de los otros m茅todos).  Por ejemplo, algunas implementaciones pueden ser las siguientes: <br>  Todas estas funciones, excepto drenaje () y tuber铆a (), corresponden a una funci贸n similar en Iterable.  Cada uno se puede escribir f谩cilmente usando una funci贸n as铆ncrona con un bucle de espera (o simplemente usando uno de los otros m茅todos).  Por ejemplo, algunas implementaciones podr铆an ser: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;bool&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object needle)</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event in </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event == needle) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-function"><span class="hljs-function">Future </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function(T element)</span></span></span><span class="hljs-function"> action) async </span></span>{ <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event in </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ action(event); } } Future&lt;List&lt;T&gt;&gt; toList() async { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> result = &lt;T&gt;[]; await <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forEach(result.add); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-function">Future&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([String separator = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> async </span></span>=&gt; (await <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toList()).join(separator);</code> </pre> <br><p>  (La implementaci贸n real es un poco m谩s complicada, pero principalmente por razones hist贸ricas). </p><br><h2 id="metody-izmenyayuschie-potok">  M茅todos de modificaci贸n de flujo </h2><br><p>  Los siguientes m茅todos en Stream devuelven una nueva secuencia basada en la secuencia original.  Cada uno de ellos espera a que alguien escuche la nueva transmisi贸n antes de escuchar la original. </p><br><pre> <code class="java hljs">Stream&lt;R&gt; cast&lt;R&gt;(); Stream&lt;S&gt; expand&lt;S&gt;(<span class="hljs-function"><span class="hljs-function">Iterable&lt;S&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T element)</span></span></span><span class="hljs-function"> convert)</span></span>; Stream&lt;S&gt; map&lt;S&gt;(<span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T event)</span></span></span><span class="hljs-function"> convert)</span></span>; Stream&lt;R&gt; retype&lt;R&gt;(); <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skipWhile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test)</span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takeWhile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T element)</span></span></span><span class="hljs-function"> test)</span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">where</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bool Function(T event)</span></span></span><span class="hljs-function"> test)</span></span>;</code> </pre> <br><p>  Los m茅todos anteriores corresponden a m茅todos similares en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Iterable</a> , que convierten el objeto iterable en otro objeto iterable.  Todo esto se puede escribir f谩cilmente utilizando una funci贸n asincr贸nica con un bucle de <strong>espera</strong> . </p><br><pre> <code class="java hljs">Stream&lt;E&gt; asyncExpand&lt;E&gt;(<span class="hljs-function"><span class="hljs-function">Stream&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T event)</span></span></span><span class="hljs-function"> convert)</span></span>; Stream&lt;E&gt; asyncMap&lt;E&gt;(<span class="hljs-function"><span class="hljs-function">FutureOr&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T event)</span></span></span><span class="hljs-function"> convert)</span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distinct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([bool Function(T previous, T next)</span></span></span><span class="hljs-function"> equals])</span></span>;</code> </pre> <br><p>  Las <code>asyncExpand()</code> y <code>asyncMap()</code> son similares a las funciones <code>expand()</code> y <code>map()</code> , pero permiten que el argumento de la funci贸n sea una funci贸n asincr贸nica.  <code>distinct()</code> funciones <code>distinct()</code> no existen en Iterable, pero se pueden implementar. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function onError, {bool test(error)</span></span></span><span class="hljs-function">})</span></span>; <span class="hljs-function"><span class="hljs-function">Stream&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Duration timeLimit, {</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function(EventSink&lt;T&gt; sink)</span></span></span><span class="hljs-function"> onTimeout})</span></span>; Stream&lt;S&gt; transform&lt;S&gt;(StreamTransformer&lt;T, S&gt; streamTransformer);</code> </pre> <br><p>  Las 煤ltimas tres funciones son m谩s espec铆ficas.  Estos incluyen el manejo de errores que el bucle de <strong>espera</strong> no puede realizar, ya que el primer error termina el bucle y se suscribe a la secuencia.  No hay nada que hacer al respecto.  Puede <code>handleError()</code> para eliminar errores de la secuencia antes de usarlo en el ciclo de <strong>espera</strong> . </p><br><h3 id="funkciya-transform">  Funci贸n Transform () </h3><br><p>  La funci贸n transform () no es solo para el manejo de errores;  Es un "mapa" m谩s generalizado para las transmisiones.  Un mapa normal requiere un valor para cada evento entrante.  Sin embargo, especialmente para las secuencias de E / S, se pueden requerir m煤ltiples eventos entrantes para crear un evento de salida.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">StreamTransformer</a> puede ayudar con esto.  Por ejemplo, los decodificadores como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Utf8Decoder</a> son transformadores.  Un transformador requiere solo una funci贸n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bind ()</a> , que puede implementarse f谩cilmente a trav茅s de una funci贸n asincr贸nica. </p><br><pre> <code class="java hljs">Stream&lt;S&gt; mapLogErrors&lt;S, T&gt;( Stream&lt;T&gt; stream, <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T event)</span></span></span><span class="hljs-function"> convert, ) async* </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> streamWithoutErrors = stream.handleError((e) =&gt; log(e)); <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event in streamWithoutErrors)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">yield </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event)</span></span></span></span>; } }</code> </pre> <br><h3 id="chtenie-i-dekodirovanie-fayla">  Leer y decodificar un archivo </h3><br><p>  El siguiente c贸digo lee el archivo y realiza dos conversiones en la secuencia.  Primero, convierte los datos de UTF8 y luego los pasa a trav茅s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LineSplitter</a> .  Todas las l铆neas se imprimen, excepto las que comienzan con un hashtag ( <code>#</code> ). </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'dart:convert'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'dart:io'</span></span>; <span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; args)</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> file = File(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lines = file .openRead() .transform(utf8.decoder) .transform(LineSplitter()); <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> line in lines)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!line.startsWith(<span class="hljs-string"><span class="hljs-string">'#'</span></span>)) print(line); } }</code> </pre> <br><h2 id="metod-listen">  M茅todo Listen () </h2><br><p>  El m茅todo <code>listen()</code> es un m茅todo de "bajo nivel", todas las dem谩s funciones de la funci贸n se definen a trav茅s de <code>listen()</code> . </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">StreamSubscription&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function(T event)</span></span></span><span class="hljs-function"> onData, </span></span>{Function onError, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> onDone, bool cancelOnError})</span></span>;</code> </pre> <br><p>  Para crear un nuevo tipo de transmisi贸n, simplemente puede heredar la clase <code>Stream</code> e implementar el m茅todo <code>listen()</code> , todos los dem谩s m茅todos <code>Stream</code> llaman a <code>listen()</code> para que funcione. </p><br><p>  El m茅todo listen () le permite comenzar a escuchar la transmisi贸n.  Hasta que haga esto, la secuencia es un objeto inerte que describe qu茅 eventos desea escuchar.  Al escuchar, se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">devuelve</a> un objeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">StreamSubscription</a> que representa la secuencia activa que genera eventos.  Esto es similar a c贸mo <code>Iterable</code> es solo una colecci贸n de objetos, y un iterador es el que realiza la iteraci贸n real. </p><br><p>  Puede dejar de suscribirse a una transmisi贸n, reanudarla despu茅s de una pausa y cancelarla por completo.  Puede especificar devoluciones de llamada que se llamar谩n para cada evento de datos o evento de error, as铆 como cuando se cierra la secuencia. </p><br><hr><br><h2 id="chto-esche-pochitat">  驴Qu茅 m谩s leer? </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dart 2. Programaci贸n asincr贸nica: futuros</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442274/">https://habr.com/ru/post/442274/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442264/index.html">Eliminando oportunidades para secuestro de tr谩fico</a></li>
<li><a href="../442266/index.html">Delta Chat: mensajer铆a descentralizada en la parte superior del correo electr贸nico</a></li>
<li><a href="../442268/index.html">AsyncIO Micropython: m茅todos de sincronizaci贸n en programaci贸n asincr贸nica</a></li>
<li><a href="../442270/index.html">5 errores a evitar al crear modelos 3D para impresi贸n 3D</a></li>
<li><a href="../442272/index.html">Ir + = versi贸n de paquete</a></li>
<li><a href="../442278/index.html">Gu铆a del usuario de Kibana. Visualizaci贸n. Parte 6</a></li>
<li><a href="../442280/index.html">Aprendizaje autom谩tico en Dodo. C贸mo lanzar una nueva direcci贸n si eres desarrollador</a></li>
<li><a href="../442282/index.html">Dart 2. Programaci贸n asincr贸nica: futuros</a></li>
<li><a href="../442284/index.html">NoVerify: el linter para PHP del equipo VKontakte ahora est谩 en el dominio p煤blico</a></li>
<li><a href="../442286/index.html">Los oftalm贸logos rusos hablaron sobre la visi贸n bi贸nica. La nueva aplicaci贸n m贸vil demuestra el trabajo del ciber</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>