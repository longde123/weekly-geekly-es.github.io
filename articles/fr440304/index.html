<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ì üìø üçë Interruptions √† partir de p√©riph√©riques externes dans un syst√®me x86. Partie 3. Configuration du routage d'interruption dans le chipset en utilisant l'exemple coreboot üìÜ üë¥üèª üìñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous continuons √† envisager de configurer des interruptions √† partir de p√©riph√©riques externes dans le syst√®me x86. 
 Dans la partie 1 ( Evolution des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interruptions √† partir de p√©riph√©riques externes dans un syst√®me x86. Partie 3. Configuration du routage d'interruption dans le chipset en utilisant l'exemple coreboot</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440304/"> Nous continuons √† envisager de configurer des interruptions √† partir de p√©riph√©riques externes dans le syst√®me x86. <br>  Dans la partie 1 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Evolution des contr√¥leurs d'interruption</a> ), nous avons examin√© les fondements th√©oriques des contr√¥leurs d'interruption et les termes g√©n√©raux, dans la partie 2 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">options de d√©marrage du noyau Linux</a> ), nous avons examin√© comment le syst√®me d'exploitation fait un choix entre les contr√¥leurs dans la pratique.  Dans cette partie, nous verrons comment le BIOS configure le routage IRQ pour les contr√¥leurs d'interruption du chipset. <br><br>  Aucune entreprise de d√©veloppement de BIOS moderne (AwardBIOS / AMIBIOS / Insyde) ne divulgue le code source de leurs programmes.  Mais heureusement, il y a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Coreboot</a> , un projet pour remplacer le BIOS propri√©taire par un logiciel gratuit.  Dans son code, nous verrons comment le routage d'interruption dans le chipset est configur√©. <br><br><img src="https://habrastorage.org/webt/mx/vi/wu/mxviwuisp5rglec_kgsk872hmy8.png"><br><br><a name="habracut"></a><br><h2>  Th√©orie </h2><br>  Tout d'abord, rafra√Æchissez et compl√©tez nos connaissances th√©oriques.  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 1,</a> nous avons identifi√© un chemin d'interruption commun pour le cas de PIC et APIC. <br><br>  <b>Pic:</b> <br><br><img src="https://habrastorage.org/webt/u_/jr/u9/u_jru9pemdeda2xvvbqihvgtp3y.png"><br><br>  <b>APIC:</b> <br><br><img src="https://habrastorage.org/webt/mc/ra/hj/mcrahjn-owk9qrcmyiixcmhomcq.png"><br><br>  Sur ces figures, le mappage p√©riph√©rique PCI ‚Üí PIR est illustr√© de mani√®re abstraite; en fait, c'est un peu plus compliqu√©.  En r√©alit√©, chaque p√©riph√©rique PCI poss√®de 4 lignes d'interruption (INTA #, INTB #, INTC #, INTD #).  Chaque p√©riph√©rique PCI peut avoir jusqu'√† 8 fonctions et chaque fonction a d√©j√† une interruption INTx #.  La ligne de INTx # que chaque fonction du p√©riph√©rique va tirer est soit fix√©e dans le mat√©riel, soit d√©termin√©e par la configuration du p√©riph√©rique. <br><br><img src="https://habrastorage.org/webt/dk/ny/gh/dknyghwfo8gktn5l_lmmqb5awz0.png"><br><br>  En substance, les fonctions sont des blocs logiques s√©par√©s.  Par exemple, dans un p√©riph√©rique PCI, il peut y avoir une fonction de contr√¥leur Smbus, une fonction de contr√¥leur SATA, une fonction de pont LPC.  C√¥t√© OS, chaque fonction est un p√©riph√©rique distinct avec son propre espace de configuration PCI Config. <br><br>  Dans le cas le plus simple (et le plus courant) d'un p√©riph√©rique PCI, il n'y a qu'une seule fonction, dont l'interruption se fait via la ligne INTA #.  Mais en g√©n√©ral, le p√©riph√©rique peut m√™me avoir plus de 4 fonctions (comme nous l'avons dit pr√©c√©demment 8), alors certaines d'entre elles devront √™tre plant√©es sur une ligne INTx # (les interruptions PCI peuvent partager la ligne).  De plus, pour les p√©riph√©riques PCI inclus dans le chipset en √©crivant dans des registres sp√©ciaux, il est souvent possible d'indiquer quelles fonctions utilisent quelles lignes INTx # (et si elles sont utilis√©es du tout). <br><br>  Syst√©matisant nos connaissances, nous d√©signons le chemin (routage) des interruptions de toute fonction PCI via INTx # ‚Üí PIRQy ‚Üí IRQz, o√π: <br><br><ul><li>  INTx # - ligne INT # (INTA #, INTB #, INTC #, INTD #) du p√©riph√©rique PCI que la fonction utilisera </li><li>  PIRQy - la ligne PIRQ (PIRQA, PIRQB, ...) du PIR auquel la ligne INTx # est connect√©e </li><li>  IRQz - Ligne IRQ (0, 1, 2, ...) sur le contr√¥leur d'interruption (APIC / PIC), qui est connect√© √† la ligne PIRQy </li></ul><br><h3>  Pourquoi ne pouvez-vous pas simplement vous connecter partout INTA # ‚Üí PIRQA, INTB # ‚Üí PIRQB, ...? </h3><br>  Pourquoi prendre la peine de configurer le routage?  Supposons que nous d√©cidions de ne pas d√©ranger et d'obtenir toutes les lignes d'interruption de tous les p√©riph√©riques PCI vers les m√™mes lignes PIRQ.  Disons ceci: <br><br><ul><li>  INTA # ‚Üí PIRQA </li><li>  INTB # ‚Üí PIRQB </li><li>  INTC # ‚Üí PIRQC </li><li>  INTD # ‚Üí PIRQD </li></ul><br>  Comme nous l'avons dit ci-dessus, le cas le plus courant est lorsqu'un p√©riph√©rique PCI a une fonction et que son interruption est connect√©e √† la ligne INTA # (car pourquoi le d√©veloppeur du p√©riph√©rique devrait-il la d√©marrer diff√©remment?).  Donc, si nous d√©cidons soudainement de d√©marrer toutes les lignes comme nous l'avons √©crit, alors presque toutes les interruptions des appareils seront divis√©es en lignes PIRQA.  Disons qu'elle s'est retrouv√©e sur IRQ16.  Ensuite, chaque fois que le processeur est inform√© qu'une interruption s'est produite sur la ligne IRQ16, il devra interroger les pilotes de tous les p√©riph√©riques connect√©s √† la ligne IRQ16 (PIRQA) s'ils ont une interruption.  S'il existe de nombreux appareils de ce type, cela n'acc√©l√©rera naturellement pas la r√©ponse du syst√®me √† une interruption.  Et les lignes PIRQB-PIRQD dans ce cas seront pour la plupart inactives.  Pour plus de clart√©, la figure illustrant le probl√®me: <br><br><img src="https://habrastorage.org/webt/cz/dv/bf/czdvbfsnymw5xyyqujavawdcv_m.png"><br><br>  Mais tout pourrait √™tre fait comme ceci: <br><br><img src="https://habrastorage.org/webt/dk/3e/x6/dk3ex67xjmm_9h0q3miq2djqnti.png"><br><br>  L'image est un peu d√©routante, mais le fait est que nous connectons simplement les lignes INTx # avec PIRQy au round robin (PIRQA, PIRQB, PIRQC, PIRQD, PIRQA, PIRQB, PIRQC, PIRQD, PIRQA, PIRQB, PIRQC, PIRQD ,. ..) <br><br>  Il est √† noter qu'ici il faut tenir compte non seulement du fait que le m√™me nombre de fonctions PCI sont charg√©es sur chaque ligne PIRQ.  Apr√®s tout, certaines fonctions peuvent cr√©er des interruptions tr√®s rarement, et certaines de fa√ßon permanente (contr√¥leur Ethernet par exemple).  Dans ce cas, m√™me l'attribution d'une ligne PIRQ distincte pour les interruptions avec une telle fonction peut √™tre tout √† fait justifi√©e. <br><br>  Sur la base de ce qui pr√©c√®de, le d√©veloppeur du BIOS a, entre autres, la t√¢che de s'assurer que les lignes PIRQ sont uniform√©ment charg√©es d'interruptions. <br><br><h3>  Que doit faire le BIOS? </h3><br>  Nous syst√©matisons dans la figure: <br><br><img src="https://habrastorage.org/webt/pm/rq/xg/pmrqxgkdu0nkjz6yb44vdn79a8q.png"><br><br><ul><li>  <b>1) Indiquez quelle ligne de INTx # chaque fonction des p√©riph√©riques PCI tire</b> <br>  Pour les p√©riph√©riques PCI externes, cet √©l√©ment n'est pas effectu√©, mais pour les fonctions des p√©riph√©riques PCI inclus dans le chipset, il peut tr√®s bien l'√™tre. </li><li>  <b>2) Configurer le mappage INTx # ‚Üí PIRQy pour chaque p√©riph√©rique PCI</b> <br>  Il convient de noter qu'il peut y avoir plus de quatre signaux PIRQy standard (PIRQA, PIRQB, PIRQC, PIRQD).  Par exemple 8: PIRQA-PIRQH. </li></ul><br>  Les signaux PIRQy vont sur la ligne IRQz du contr√¥leur d'interruption s√©lectionn√© (APIC / PIC).  Puisque nous voulons prendre en charge toutes les m√©thodes de chargement possibles (voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 2</a> ), nous devons remplir les deux mappages: <br><br><ul><li>  <b>3a) Remplissez le mappage PIRQy ‚Üí IRQz1 pour la communication PIR ‚Üí I / O APIC</b> <br>  Mais ce n'est g√©n√©ralement pas n√©cessaire, car les lignes PIRQy sont fix√©es sur la ligne APIC.  La solution courante est PIRQA ‚Üí IRQ16, PIRQB ‚Üí IRQ17, ... La solution la plus simple, car  En pla√ßant des lignes PIRQy sur des lignes de contr√¥leur ‚â• 16, vous n'avez pas √† vous soucier des conflits avec des interruptions ins√©parables des appareils ISA. </li><li>  <b>3b) Remplissez le mappage PIRQy ‚Üí IRQz2 pour la communication PIR ‚Üí PIC</b> <br>  Cela doit √™tre fourni dans le cas o√π nous utilisons le routage via le contr√¥leur PIC.  Il n'y a pas de solution non ambigu√´ comme dans le cas de l'APIC, car dans le cas du PIC, il faut √™tre conscient de la possibilit√© de conflits avec des interruptions ins√©parables des p√©riph√©riques ISA. </li></ul><br>  Le dernier quatri√®me √©l√©ment est n√©cessaire pour aider le syst√®me d'exploitation √† d√©terminer le routage d'interruption.  Le p√©riph√©rique lui-m√™me n'utilise g√©n√©ralement pas ces registres. <br><br><ul><li>  <b>4) Remplissez les registres Interrupt Line / Interrupt Pin pour chaque fonction PCI</b> <br>  En g√©n√©ral, le registre des broches d'interruption est automatiquement rempli et est g√©n√©ralement en lecture seule, donc le remplissage ne n√©cessitera probablement que le remplissage du registre de la ligne d'interruption.  Cela doit √™tre fourni dans le cas o√π nous utilisons le routage via le contr√¥leur PIC sans fournir au syst√®me d'exploitation une table sur les interruptions de routage (voir √† nouveau la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 2</a> ).  Si des tables sont fournies et que ce mappage est coh√©rent avec les tables de routage ($ PIR / ACPI), le syst√®me d'exploitation le quitte souvent. </li></ul><br>  Il convient de noter que nous ne touchons pas encore aux tables $ PIR / MPtable / ACPI et consid√©rons comment configurer les registres du chipset en termes d'interruptions de routage avant de transf√©rer le contr√¥le au chargeur du syst√®me.  Les tables d'interruption sont un sujet pour un article s√©par√© (√©ventuellement un futur). <br><br>  Alors, les fondements th√©oriques sont √©tudi√©s, enfin on commence √† pratiquer! <br><br><h2>  Pratique </h2><br>  √Ä titre d'exemple pour les articles de cette s√©rie, j'utilise une carte personnalis√©e avec un processeur Intel Haswell i7 et un chipset LynxPoint-LP.  Sur cette carte, j'ai lanc√© coreboot en collaboration avec SeaBIOS.  Coreboot fournit une initialisation sp√©cifique au mat√©riel et la charge utile SeaBIOS fournit une interface BIOS pour les syst√®mes d'exploitation.  Dans cet article, je ne d√©crirai pas le processus de configuration de coreboot, mais j'essaierai simplement de montrer avec un exemple quel type de param√®tres BIOS doivent √™tre d√©finis dans le chipset pour router les interruptions IRQ √† partir de p√©riph√©riques externes. <br><br>  √âtant donn√© que le projet coreboot se d√©veloppe activement afin que l'article soit toujours √† jour, nous consid√©rerons le code en utilisant l'exemple de la derni√®re version fixe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.9</a> (version 2018-12-20). <br><br>  La carte m√®re la plus proche de la mienne est Google Beltino avec la variation Panther.  Le dossier principal de cette carte m√®re est le dossier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"src \ mainboard \ google \ beltino"</a> .  Tous les param√®tres sont concentr√©s ici et le code sp√©cifique √† cette carte. <br><br>  Commen√ßons donc √† trier o√π les √©l√©ments ci-dessus sont configur√©s: <br><br><h4>  1) Indiquez quelle ligne de INTx # chaque fonction des p√©riph√©riques PCI tire </h4><br>  Ces informations sont d√©finies dans le fichier <a href="">¬´src / mainboard / google / beltino / romstage.c¬ª</a> dans la structure rcba_config via les registres DxxIP (Device xx Interrupt Pin Register (IP)).  Ce registre indique quelle broche INTx # (A / B / C / D) chacune des fonctions de l'appareil √©met une interruption. <br><br>  Options possibles (voir le fichier <a href="">"src / southbridge / intel / lynxpoint / pch.h"</a> ): <br><br><pre><code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>h = No interrupt <span class="hljs-number"><span class="hljs-number">1</span></span>h = INTA# <span class="hljs-number"><span class="hljs-number">2</span></span>h = INTB# <span class="hljs-number"><span class="hljs-number">3</span></span>h = INTC# <span class="hljs-number"><span class="hljs-number">4</span></span>h = INTD#</code> </pre> <br>  On suppose que plusieurs fonctions utilisent la m√™me broche. <br><br>  Il est suppos√© que les fonctions ne peuvent pas utiliser la broche pour les interruptions (pas d'interruption). <br>  Tout comme nous l'avons vu dans la figure au d√©but de l'article. <br><br>  Le code complet est responsable de l'article d√©sign√© par nous: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Device interrupt pin register (board specific) */</span></span> RCBA_SET_REG_32(D31IP, (INTC &lt;&lt; D31IP_TTIP) | (NOINT &lt;&lt; D31IP_SIP2) | (INTB &lt;&lt; D31IP_SMIP) | (INTA &lt;&lt; D31IP_SIP)), RCBA_SET_REG_32(D29IP, (INTA &lt;&lt; D29IP_E1P)), RCBA_SET_REG_32(D28IP, (INTA &lt;&lt; D28IP_P1IP) | (INTC &lt;&lt; D28IP_P3IP) | (INTB &lt;&lt; D28IP_P4IP)), RCBA_SET_REG_32(D27IP, (INTA &lt;&lt; D27IP_ZIP)), RCBA_SET_REG_32(D26IP, (INTA &lt;&lt; D26IP_E2P)), RCBA_SET_REG_32(D22IP, (NOINT &lt;&lt; D22IP_MEI1IP)), RCBA_SET_REG_32(D20IP, (INTA &lt;&lt; D20IP_XHCI)),</code> </pre> <br>  Pour une meilleure compr√©hension, consid√©rons quelques exemples: <br><br>  <b>Exemple 1:</b> <br><br>  Le p√©riph√©rique 0x1d (29 en d√©cimal) a une fonction (contr√¥leur EHCI). <br><br>  Dans ce cas, affectez une interruption √† INTA #. <br><br>  00: 1d.0 - INTA # <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D29IP, (INTA &lt;&lt; D29IP_E1P)),</code> </pre> <br>  <b>Exemple 2:</b> <br>  Le p√©riph√©rique 0x1f (31 en d√©cimal) a les fonctions contr√¥leur de capteur thermique (00: 1f.6), contr√¥leur SATA 2 (00: 1f.2), contr√¥leur SMBus (00: 1f.3), contr√¥leur SATA 1 (00: 1f .2).  Nous voulons utiliser uniquement le contr√¥leur SMBus, le contr√¥leur SATA 1 et le contr√¥leur de capteur thermique. <br><br>  00: 1f.2 - INTA # (contr√¥leur SATA 1) <br>  00: 1f.3 - INTB # (contr√¥leur SMBus) <br>  00: 1f.2 - Aucune interruption (le contr√¥leur SATA 2 n'est pas utilis√©) <br>  00: 1f.6 - INTC # (contr√¥leur de capteur thermique) <br><br>  Pour cette configuration, vous devez √©crire: <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D31IP, (INTC &lt;&lt; D31IP_TTIP) | (NOINT &lt;&lt; D31IP_SIP2) | (INTB &lt;&lt; D31IP_SMIP) | (INTA &lt;&lt; D31IP_SIP)),</code> </pre> <br>  <b>Exemple 3:</b> <br><br>  Dans un p√©riph√©rique, le nombre de fonctions dont nous avons besoin est sup√©rieur √† 4. Dans le p√©riph√©rique 0x1c, chaque fonction est responsable du port PCI Express.  Pour que les ports 0-5 fonctionnent et que les interruptions soient r√©parties uniform√©ment entre les lignes, vous pouvez configurer ceci: <br><br>  00: 1c.0 - INTA # (port PCI Express 0) <br>  00.1c.1 - INTB # (port PCI Express 1) <br>  00.1c.2 - INTC # (port PCI Express 2) <br>  00.1c.3 - INTD # (port PCI Express 3) <br>  00.1c.4 - INTA # (port PCI Express 4) <br>  00.1c.5 - INTB # (port PCI Express 5) <br>  00.1c.6 - Aucune interruption (port non utilis√©) <br>  00.1c.7 - Aucune interruption (port non utilis√©) <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D28IP, (INTA &lt;&lt; D28IP_P1IP) | (INTB &lt;&lt; D28IP_P2IP) | (INTC &lt;&lt; D28IP_P3IP) | (INTD &lt;&lt; D28IP_P4IP) | (INTA &lt;&lt; D28IP_P5IP) | (INTB &lt;&lt; D28IP_P6IP) | (NOINT &lt;&lt; D28IP_P7IP) | (NOINT &lt;&lt; D28IP_P8IP)),</code> </pre> <br><h4>  2) Configurer le mappage INTx # ‚Üí PIRQy pour chaque p√©riph√©rique PCI </h4><br>  Ces informations sont √©galement d√©finies dans le fichier <a href="">"src \ mainboard \ google \ beltino \ romstage.c"</a> <br>  dans la structure rcba_config, mais d√©j√† via les registres DxxIR (Device xx Interrupt Route Register). <br><br>  Les informations de ce registre indiquent √† quelle ligne PIRQx (A / B / C / D / E / F / G / H) chaque ligne d'interruption INTx # est connect√©e. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Device interrupt route registers */</span></span> RCBA_SET_REG_32(D31IR, DIR_ROUTE(PIRQG, PIRQC, PIRQB, PIRQA)),<span class="hljs-comment"><span class="hljs-comment">/* LPC */</span></span> RCBA_SET_REG_32(D29IR, DIR_ROUTE(PIRQD, PIRQD, PIRQD, PIRQD)),<span class="hljs-comment"><span class="hljs-comment">/* EHCI */</span></span> RCBA_SET_REG_32(D28IR, DIR_ROUTE(PIRQA, PIRQB, PIRQC, PIRQD)),<span class="hljs-comment"><span class="hljs-comment">/* PCIE */</span></span> RCBA_SET_REG_32(D27IR, DIR_ROUTE(PIRQG, PIRQG, PIRQG, PIRQG)),<span class="hljs-comment"><span class="hljs-comment">/* HDA */</span></span> RCBA_SET_REG_32(D22IR, DIR_ROUTE(PIRQA, PIRQA, PIRQA, PIRQA)),<span class="hljs-comment"><span class="hljs-comment">/* ME */</span></span> RCBA_SET_REG_32(D21IR, DIR_ROUTE(PIRQE, PIRQF, PIRQF, PIRQF)),<span class="hljs-comment"><span class="hljs-comment">/* SIO */</span></span> RCBA_SET_REG_32(D20IR, DIR_ROUTE(PIRQC, PIRQC, PIRQC, PIRQC)),<span class="hljs-comment"><span class="hljs-comment">/* XHCI */</span></span> RCBA_SET_REG_32(D23IR, DIR_ROUTE(PIRQH, PIRQH, PIRQH, PIRQH)),<span class="hljs-comment"><span class="hljs-comment">/* SDIO */</span></span></code> </pre> <br>  <b>Exemple 1:</b> <br><br>  Le p√©riph√©rique 0x1c (28 dans le syst√®me d√©cimal) est le port PCIe comme nous l'avons d√©j√† d√©couvert. <br><br>  Nous √©tablissons une connexion ¬´directe¬ª: <br><br><ul><li>  INTA # ‚Üí PIRQA </li><li>  INTB # ‚Üí PIRQB </li><li>  INTC # ‚Üí PIRQC </li><li>  INTD # ‚Üí PIRQD </li></ul><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D28IR, DIR_ROUTE(PIRQA, PIRQB, PIRQC, PIRQD))</code> </pre> <br>  <b>Exemple 2:</b> <br><br>  P√©riph√©rique 0x1d (29 en d√©cimal) - une fonction (contr√¥leur EHCI) sur INTA #, les autres lignes ne sont pas utilis√©es. <br><br>  Connectez la ligne INTA # √† PIRQD: <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D29IR, DIR_ROUTE(PIRQD, PIRQD, PIRQD, PIRQD))</code> </pre> <br>  Dans ce cas, seul le premier enregistrement PIRQD (pour INTA #) a du sens, le reste n'a pas de sens. <br><br><h4>  3a) Remplissez la cartographie PIRQy ‚Üí IRQz1 (PIR ‚Üí APIC) </h4><br>  Comme nous l'avons d√©j√† dit, la cartographie est souvent fix√©e ici, et ce cas ne fait pas exception. <br><br><ul><li>  PIRQA ‚Üí IRQ16 </li><li>  PIRQB ‚Üí IRQ17 </li><li>  ... </li><li>  PIRQH ‚Üí IRQ23 </li></ul><br><h4>  3b) Remplissez le mapping PIRQy ‚Üí IRQz2 (PIR ‚Üí PIC) </h4><br>  Dans coreboot, le contenu pour remplir ces registres est d√©fini dans le fichier <a href="">devicetree.cb</a> dans le dossier de la carte m√®re "src \ mainboard \ google \ beltino \". <br><br>  devicetree.cb (le nom devicetree pour la communication avec un concept similaire dans le noyau Linux, et ¬´cb¬ª est l'abr√©viation de coreboot) est un fichier sp√©cial qui refl√®te la configuration de cette carte m√®re: quel processeur, chipset sont utilis√©s, quels p√©riph√©riques sont inclus, qui √©teint etc.  De plus, des informations sp√©ciales pour la configuration du chipset peuvent √™tre sp√©cifi√©es dans ce fichier.  C'est juste le cas dont nous avons besoin: <br><br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqf_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqg_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqh_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span></code> </pre> <br>  Ces lignes sp√©cifient le mappage PIRQy ‚Üí IRQz2.  Dans le code, apr√®s avoir analys√© le fichier devicetree.cb, ils sont transform√©s en variables ¬´config-&gt; pirqX_routing¬ª. <br><br>  La variable "config-&gt; pirqa_routing = 0x8b" signifie que le PIRQA est connect√© √† la ligne d'interruption IRIC11 (0x0b = 11) du contr√¥leur PIC, cependant, le bit le plus √©lev√© (qui est 0x80) signifie que le routage d'interruption n'est pas effectu√©.  Honn√™tement, d'apr√®s mon exp√©rience, c'est une erreur, par d√©faut, cela vaut la peine d'activer le routage PIC, le syst√®me d'exploitation lui-m√™me pourra passer √† I / O APIC en d√©finissant ce bit sur 1 si n√©cessaire. <br><br>  Autrement dit, dans ce cas, il serait plus correct d'√©crire: <br><br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> <span class="hljs-comment"><span class="hljs-comment"># not used register "pirqf_routing" = "0x80" # not used register "pirqg_routing" = "0x80" # not used register "pirqh_routing" = "0x80" # not used</span></span></code> </pre><br>  Nous n'avons pas activ√© les 4 derni√®res interruptions, car  L'interruption IRQ0 est toujours utilis√©e sous la minuterie syst√®me et est clairement indisponible (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Informations g√©n√©rales sur les interruptions compatibles IBM-PC</a> ). <br><br>  Mais si nous regardons de plus pr√®s le point 2), nous verrons que certains p√©riph√©riques PCI utilisent les lignes PIRQE-PIRQH, donc les laisser non connect√©s est la bonne voie pour les p√©riph√©riques cass√©s. <br><br>  Il vaut donc mieux √©crire quelque chose comme ceci: <br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x03"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x04"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x05"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x06"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqf_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqg_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0e"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqh_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0f"</span></span></code> </pre> <br><br>  Le remplissage r√©el des registres correspondants se produit dans le fichier <a href="">src \ southbridge \ intel \ lynxpoint \ lpc.c</a> dans la fonction pch_pirq_init. <br><br>  Extrait de code responsable du remplissage du registre: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Get the chip configuration */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">config_t</span></span> *config = dev-&gt;chip_info; pci_write_config8(dev, PIRQA_ROUT, config-&gt;pirqa_routing); pci_write_config8(dev, PIRQB_ROUT, config-&gt;pirqb_routing); pci_write_config8(dev, PIRQC_ROUT, config-&gt;pirqc_routing); pci_write_config8(dev, PIRQD_ROUT, config-&gt;pirqd_routing); pci_write_config8(dev, PIRQE_ROUT, config-&gt;pirqe_routing); pci_write_config8(dev, PIRQF_ROUT, config-&gt;pirqf_routing); pci_write_config8(dev, PIRQG_ROUT, config-&gt;pirqg_routing); pci_write_config8(dev, PIRQH_ROUT, config-&gt;pirqh_routing);</code> </pre> <br>  Les constantes d'adresse de registre sont d√©crites dans le m√™me fichier <a href="">pch.h</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQA_ROUT 0x60 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQB_ROUT 0x61 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQC_ROUT 0x62 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQD_ROUT 0x63 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQE_ROUT 0x68 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQF_ROUT 0x69 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQG_ROUT 0x6A #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQH_ROUT 0x6B</span></span></code> </pre> <br>  Le mappage PIRQy ‚Üí IRQz2 pour ce chipset est √©crit sur le p√©riph√©rique PCI LPC (adresse 00: 1f.0) dans les registres PIRQy_ROUT.  Il convient de noter que souvent, les 15 lignes IRQz2 par PIC ne sont pas autoris√©es √† √™tre utilis√©es, mais seulement une partie (par exemple, 3,4,5,6,7,9,10,11,12,14,15).  La description de ces registres doit contenir des informations sur les IRQ disponibles pour leur affecter des interruptions des lignes PIRQ.  Ainsi, la cartographie que nous proposons ci-dessus n'est possible que si l'affectation de PIRQ sur la ligne IRQ3, IRQ4, IRQ5, IRQ6, IRQ10, IRQ11, IRQ14, IRQ15 est disponible.  Mais si nous regardons attentivement le commentaire avant la fonction pch_pirq_init, nous verrons que c'est: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PIRQ[n]_ROUT[3:0] - PIRQ Routing Control * 0x00 - 0000 = Reserved * 0x01 - 0001 = Reserved * 0x02 - 0010 = Reserved * 0x03 - 0011 = IRQ3 * 0x04 - 0100 = IRQ4 * 0x05 - 0101 = IRQ5 * 0x06 - 0110 = IRQ6 * 0x07 - 0111 = IRQ7 * 0x08 - 1000 = Reserved * 0x09 - 1001 = IRQ9 * 0x0A - 1010 = IRQ10 * 0x0B - 1011 = IRQ11 * 0x0C - 1100 = IRQ12 * 0x0D - 1101 = Reserved * 0x0E - 1110 = IRQ14 * 0x0F - 1111 = IRQ15 * PIRQ[n]_ROUT[7] - PIRQ Routing Control * 0x80 - The PIRQ is not routed. */</span></span></code> </pre> <br><h4>  4) Remplissez les registres Interrupt Line / Interrupt Pin pour chaque fonction PCI </h4><br>  Dans l'espace de configuration PCI (chaque PCI a des fonctions selon la norme) il y a 2 registres qui nous int√©ressent: <br><br><ul><li>  3Ch: Interrupt Line - ici, vous devez √©crire le num√©ro IRQz2 (un nombre de 0 √† 15), le num√©ro d'interruption que la fonction tire finalement lors de l'utilisation du contr√¥leur PIC </li><li>  3Dh: Pin d'interruption - montre quelle ligne INTx # (A / B / C / D) la fonction utilise </li></ul><br>  Commen√ßons par le dernier.  Le registre des broches d'interruption sera rempli automatiquement en fonction des param√®tres du chipset (registres DxxIP) que nous avons d√©finis au paragraphe 1 et sera en lecture seule. <br><br>  Il ne reste donc plus qu'√† remplir le registre Interrupt Line avec une interruption IRQz2 pour chaque fonction PCI. <br><br>  Connaissant le mappage PIRQy ‚Üí IRQz2 (√©l√©ment 3b) et le mappage INTx # ‚Üí PIRQy (√©l√©ment 2), vous pouvez facilement remplir le registre de ligne d'interruption pour chaque fonction, en sachant quelle interruption INTx # elle utilise (√©l√©ment 1). <br><br>  Dans coreboot, les registres de ligne d'interruption sont √©galement remplis dans le <a href="">fichier src \ southbridge \ intel \ lynxpoint \ lpc.c</a> dans la fonction pch_pirq_init: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Eric Biederman once said we should let the OS do this. * I am not so sure anymore he was right. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (irq_dev = all_devices; irq_dev; irq_dev = irq_dev-&gt;next) { u8 int_pin=<span class="hljs-number"><span class="hljs-number">0</span></span>, int_line=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!irq_dev-&gt;enabled || irq_dev-&gt;path.type != DEVICE_PATH_PCI) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; int_pin = pci_read_config8(irq_dev, PCI_INTERRUPT_PIN); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (int_pin) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTA# */</span></span> int_line = config-&gt;pirqa_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTB# */</span></span> int_line = config-&gt;pirqb_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTC# */</span></span> int_line = config-&gt;pirqc_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTD# */</span></span> int_line = config-&gt;pirqd_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!int_line) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; pci_write_config8(irq_dev, PCI_INTERRUPT_LINE, int_line); }</code> </pre> <br>  Pour une raison quelconque, ce code implique que le mappage est dans tous les cas INTA # ‚Üí PIRQA, INTB # ‚Üí PIRQB, INTC # ‚Üí PIRQC, INTD # ‚Üí PIRQD.  Bien qu'en pratique, nous avons vu que cela peut √™tre diff√©rent (voir paragraphe 2). <br><br>  G√©n√©ralement ¬´Eric Biederman a dit une fois¬ª, et nous l'avons copi√© n'importe o√π: <br><br><pre> <code class="bash hljs">$ grep <span class="hljs-string"><span class="hljs-string">"Eric Biederman once said"</span></span> -r src/ src/southbridge/intel/fsp_bd82x6x/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/i82801gx/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/i82801ix/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/lynxpoint/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/sch/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this.</code> </pre> <br>  En g√©n√©ral, coreboot ne se soucie pas vraiment de la prise en charge des interruptions h√©rit√©es.  Tellement d'√™tre surpris de cette erreur n'en vaut pas la peine.  Lorsque vous chargez un syst√®me d'exploitation moderne, cela ne vous d√©range pas, mais si vous devez soudainement charger Linux avec les options ¬´acpi = off nolapic¬ª, cela n'est gu√®re possible. <br><br><h2>  Conclusion </h2><br>  En conclusion, nous r√©p√©terons les informations typiques qui doivent √™tre configur√©es dans le chipset pour le routage des interruptions PCI: <br><br><ol><li>  Indiquez quelle ligne INTx # chaque fonction PCI tire </li><li>  Configurer le mappage INTx # ‚Üí PIRQy pour chaque p√©riph√©rique PCI </li><li>  Remplissage mappage PIRQy ‚Üí IRQz1 (PIR ‚Üí APIC) et mappage PIRQy ‚Üí IRQz2 (PIR ‚Üí PIC) </li><li>  Remplissez les registres Interrupt Line / Interrupt Pin de l'espace de configuration PCI pour chaque fonction PCI. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440304/">https://habr.com/ru/post/fr440304/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440294/index.html">Routeur MIDI sur Raspberry Pi</a></li>
<li><a href="../fr440296/index.html">6 Applications pour l'IoT industriel</a></li>
<li><a href="../fr440298/index.html">Application de la Saint-Valentin sur Libgdx</a></li>
<li><a href="../fr440300/index.html">10 commandes de console pour aider √† d√©battre du code JavaScript comme un PRO</a></li>
<li><a href="../fr440302/index.html">CRM - co√ªt du succ√®s, co√ªt de l'erreur, co√ªt de possession</a></li>
<li><a href="../fr440306/index.html">Mise √† l'√©chelle de la base de donn√©es dans des syst√®mes tr√®s charg√©s</a></li>
<li><a href="../fr440308/index.html">Diviser et conqu√©rir, ou √©crire lentement - lire rapidement</a></li>
<li><a href="../fr440310/index.html">Comment apprendre √† une machine √† comprendre les factures et √† en extraire des donn√©es</a></li>
<li><a href="../fr440312/index.html">Hackquest 2018. R√©sultats et √©critures. Jour 4-7</a></li>
<li><a href="../fr440314/index.html">Candidat √† la sortie de JDK 12: Shenandoah, G1, JMH, Arm64. Les bugs dans Swing ripostent</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>