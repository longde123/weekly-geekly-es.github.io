<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüè≠ üë©üèª‚Äç‚úàÔ∏è üïê √âcrire une interface utilisateur Snapchat sur Swift üë©‚Äçüî¨ üßóüèø ‚å®Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologue 


 Dans l'un de mes projets, j'avais besoin de faire une interface comme √ßa dans Snepchat. Lorsqu'une carte contenant des informations sort ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√âcrire une interface utilisateur Snapchat sur Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415795/"><h2 id="prolog">  Prologue </h2><br><p> Dans l'un de mes projets, j'avais besoin de faire une interface comme √ßa dans Snepchat.  Lorsqu'une carte contenant des informations sort de l'image de l'appareil photo, remplacez-la en douceur par une couleur unie, et tout aussi bien dans la direction oppos√©e.  Personnellement, j'ai √©t√© particuli√®rement fascin√© par le passage de la fen√™tre de la cam√©ra √† la carte lat√©rale et, avec grand plaisir, je suis all√© raconter les moyens de r√©soudre ce probl√®me. </p><br><p>  A gauche, un exemple de Snepchat, √† droite, un exemple d'application que nous allons cr√©er. </p><br><p><img src="https://habrastorage.org/webt/es/cx/sd/escxsdlqbwqu7rfh9l9lcjjcl0a.gif"><img src="https://habrastorage.org/webt/vg/xf/8v/vgxf8vdl1gwnu0vplvu9gikqaho.gif"></p><a name="habracut"></a><br><p> La premi√®re solution qui vient √† l'esprit est probablement d'adapter <code>UIScrollView</code> , de disposer d'une mani√®re ou d'une autre les vues sur celui-ci, d'utiliser la pagination, mais, franchement, le d√©filement est pens√© pour r√©soudre des t√¢ches compl√®tement diff√©rentes, choisir des animations suppl√©mentaires est laborieux et n'a pas la flexibilit√© n√©cessaire param√®tres.  Par cons√©quent, son utilisation pour r√©soudre ce probl√®me est absolument injustifi√©e. </p><br><p>  Le d√©filement entre la fen√™tre de la cam√©ra et l'onglet lat√©ral est trompeur - ce n'est pas du tout un d√©filement, c'est une transition interactive entre les vues appartenant √† diff√©rents contr√¥leurs.  Les boutons dans sa partie inf√©rieure sont des onglets ordinaires, en cliquant sur ce qui nous jette entre les contr√¥leurs. </p><br><p><img src="https://habrastorage.org/webt/s1/xq/o7/s1xqo7xcojshfu3lqvdjiyonluk.jpeg"></p><br><p>  De cette fa√ßon, Snatch utilise sa propre version d'un contr√¥leur de navigation tel que <code>UITabBarController</code> avec des transitions interactives personnalis√©es. </p><br><p>  <code>UIKit</code> comprend deux options pour les contr√¥leurs de navigation qui vous permettent de personnaliser les transitions - ce sont <code>UINavigationController</code> et <code>UITabBarController</code> .  Les deux ont <code>navigationController(_:interactionControllerFor:)</code> m√©thodes <code>navigationController(_:interactionControllerFor:)</code> et <code>tabBarController(_:interactionControllerFor:)</code> dans leurs d√©l√©gu√©s, respectivement, qui nous permettent d'utiliser notre propre animation interactive pour la transition. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tabBarController (_: interactionControllerFor :)</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">navigationController (_: interactionControllerFor :)</a> </p><br><p>  Mais je ne voudrais pas √™tre limit√© par l'impl√©mentation de <code>UITabBarController</code> ou <code>UINavigationController</code> , d'autant plus que nous ne pouvons pas contr√¥ler leur logique interne.  Par cons√©quent, j'ai d√©cid√© d'√©crire mon contr√¥leur similaire, et maintenant je veux dire et montrer ce qui en est arriv√©. </p><br><h2 id="postanovka-zadachi">  √ânonc√© du probl√®me </h2><br><p>  Cr√©ez votre propre contr√¥leur de conteneur, dans lequel vous pouvez basculer entre les contr√¥leurs enfants √† l'aide d'animations interactives pour les transitions, en utilisant le m√©canisme standard dans <code>UITabBarController</code> et <code>UINavigationController</code> .  Nous avons besoin de ce m√©canisme standard pour utiliser des animations de transition pr√™tes √† l'emploi du type <code>UIViewControllerAnimatedTransitioning</code> d√©j√† √©crit. </p><br><h2 id="podgotovka-proekta">  Pr√©paration du projet </h2><br><p>  Habituellement, j'essaie de d√©placer les modules dans des cadres distincts, pour cela, je cr√©e un nouveau projet d'application, et j'y ajoute une cible <code>Cocoa Touch Framework</code> suppl√©mentaire, puis je disperse les sources dans le projet pour les cibles correspondantes.  De cette fa√ßon, j'obtiens un cadre s√©par√© avec une application de test pour le d√©bogage. </p><br><p>  Cr√©ez une <code>Single View App</code> . </p><br><p><img src="https://habrastorage.org/webt/6p/eb/pa/6pebpaksin3ixvmlpse9tj7rnzs.png"></p><br><p>  <code>Product Name</code> sera notre cible. </p><br><p><img src="https://habrastorage.org/webt/aq/qv/fg/aqqvfgoimy4kv85lqjrb34tbkco.png"></p><br><p>  Cliquez sur <code>+</code> pour ajouter la cible. </p><br><p><img src="https://habrastorage.org/webt/_b/2v/vj/_b2vvjuxpzkbvcmxuo8wxsctza0.png"></p><br><p>  Choisissez <code>Cocoa Touch Framework</code> . </p><br><p><img src="https://habrastorage.org/webt/kr/mg/yy/krmgyylj_xfil50cdtejstjdpuc.png"></p><br><p>  Nous appelons notre framework le nom appropri√©, Xcode s√©lectionne automatiquement le projet pour notre cible et propose de lier le binaire directement dans l'application.  Nous sommes d'accord. </p><br><p><img src="https://habrastorage.org/webt/no/xi/cn/noxicnp_oslkyxhn3qkmcaukpom.png"></p><br><p>  Nous <code>Main.storyboard</code> pas besoin du <code>Main.storyboard</code> et du <code>ViewController.swift</code> par d√©faut, nous les <code>ViewController.swift</code> . </p><br><p><img src="https://habrastorage.org/webt/_m/zq/aw/_mzqawkdo2pi9zgulfqlwnhs2vo.png"></p><br><p>  N'oubliez pas non plus de supprimer la valeur de l' <code>Main Interface</code> dans la cible de l'application sous l'onglet <code>General</code> . </p><br><p><img src="https://habrastorage.org/webt/kt/sv/3v/ktsv3vjy_1vqgwdnkh288h4ecpc.png"></p><br><p>  Maintenant, nous allons √† <code>AppDelegate.swift</code> et ne laissons que la m√©thode d' <code>application</code> du contenu suivant: </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">]?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Launch our master view controller let master = MasterViewController() window = UIWindow() window?.rootViewController = master window?.makeKeyAndVisible() return true }</span></span></code> </pre> <br><p>  Ici, nous avons plac√© notre contr√¥leur √† la place principale afin qu'il apparaisse apr√®s le lanceur. </p><br><p>  Cr√©ez maintenant ce m√™me <code>MasterViewController</code> .  Il sera li√© √† l'application, il est donc important de choisir la bonne cible lors de la cr√©ation du fichier. </p><br><p><img src="https://habrastorage.org/webt/7m/0y/r8/7m0yr8cefaenhznoqbjisg7sy1q.png"></p><br><p>  Nous h√©riterons de <code>MasterViewController</code> de <code>SnapchatNavigationController</code> , que nous impl√©menterons plus tard dans le cadre.  N'oubliez pas de sp√©cifier l' <code>import</code> notre framework.  Je ne fournis pas le code complet du contr√¥leur ici, les omissions sont indiqu√©es par des ellipses <code>...</code> , j'ai plac√© l'application sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> , l√† vous pouvez voir tous les d√©tails.  Dans ce contr√¥leur, nous ne sommes int√©ress√©s que par la m√©thode <code>viewDidLoad()</code> , qui initialise le contr√¥leur d'arri√®re-plan avec la cam√©ra + un contr√¥leur transparent (fen√™tre principale) + le contr√¥leur contenant la carte de d√©part. </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">MakingSnapchatNavigation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MasterViewController</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">SnapchatNavigationController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> func viewDidLoad() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() <span class="hljs-comment"><span class="hljs-comment">//   let camera = CameraViewController() setBackground(vc: camera) //     var vcs: [UIViewController] = [] //    var stub = UIViewController() stub.view.backgroundColor = .clear vcs.append(stub) //  ,     stub = UIViewController() stub.view.backgroundColor = .clear //   let scroll = UIScrollView() stub.view.addSubview(scroll) //  ... //  ,      let content = GradientView() //  ... //    scroll.addSubview(content) vcs.append(stub) //     - setViewControllers(vcs: vcs) } }</span></span></code> </pre> <br><p>  Que se passe-t-il ici?  Nous cr√©ons un contr√¥leur avec une cam√©ra et le <code>setBackground</code> √† l'arri√®re-plan en utilisant la m√©thode <code>setBackground</code> de <code>SnapchatNavigationController</code> .  Ce contr√¥leur contient une image √©tir√©e pour la vue enti√®re de la cam√©ra.  Ensuite, nous cr√©ons un contr√¥leur transparent vide et l'ajoutons au tableau, il passe simplement l'image de la cam√©ra √† travers elle, nous pouvons y placer des contr√¥les, cr√©er un autre contr√¥leur transparent, y ajouter un d√©filement, ajouter une vue avec du contenu √† l'int√©rieur du d√©filement, ajouter un deuxi√®me contr√¥leur √† tableau et d√©finissez ce tableau √† l'aide de la m√©thode sp√©ciale <code>setViewControllers</code> du parent <code>SnapchatNavigationController</code> . </p><br><p>  N'oubliez pas d'ajouter une demande d'utilisation de la cam√©ra dans <code>Info.plist</code> </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSCameraUsageDescription<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>Need camera for background<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Sur ce point, nous consid√©rons l'application de test pr√™te, et passons √† la partie la plus int√©ressante - la mise en ≈ìuvre du framework. </p><br><h2 id="struktura-roditelskogo-kontrollera">  Structure du contr√¥leur parent </h2><br><p>  Tout d'abord, cr√©ez un <code>SnapchatNavigationController</code> vide, il est important de choisir la bonne cible pour cela.  Si tout a √©t√© fait correctement, l'application doit √™tre construite.  Ce statut du projet peut √™tre d√©charg√© par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©f√©rence</a> . </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> SnapchatNavigationController: UIViewController { override <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> func viewDidLoad() { super.viewDidLoad() // <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> additional setup <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> loading the <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>. } // MARK: - <span class="hljs-built_in"><span class="hljs-built_in">Public</span></span> interface /// Sets <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controllers. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> func setViewControllers(vcs: [UIViewController]) { } /// Sets background <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> func setBackground(vc: UIViewController) { } }</code> </pre> <br><p>  Ajoutez maintenant les composants internes qui composent le contr√¥leur.  Je n‚Äôapporte pas tout le code ici, je me concentre uniquement sur les points importants. </p><br><p>  Nous d√©finissons les variables pour stocker le tableau des contr√¥leurs enfants.  Maintenant, nous d√©finissons de mani√®re rigide leur quantit√© requise - 2 pi√®ces.  √Ä l'avenir, il sera possible d'√©tendre la logique du contr√¥leur pour l'utiliser avec n'importe quel nombre de contr√¥leurs.  Nous avons √©galement d√©fini une variable pour stocker le contr√¥leur actuel affich√©. </p><br><pre> <code class="hljs pgsql">private let requiredChildrenAmount = <span class="hljs-number"><span class="hljs-number">2</span></span> // MARK: - <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> controllers /// top child <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controller private var topViewController: UIViewController? /// <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> children <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controllers private var children: [UIViewController] = []</code> </pre> <br><p>  Cr√©ez les vues.  Nous avons besoin d'une vue pour l'arri√®re-plan, une vue avec l'effet que nous voulons appliquer √† l'arri√®re-plan lors du changement de contr√¥leur.  Nous avons √©galement un conteneur de vue pour le contr√¥leur enfant actuel et un indicateur de vue qui diront √† l'utilisateur comment travailler avec la navigation. </p><br><pre> <code class="hljs bash">// MARK: - Views private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundViewContainer = UIView() private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffectView: UIVisualEffectView = { <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffect = UIBlurEffect(style: UIBlurEffectStyle.light) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffectView = UIVisualEffectView(effect: backgroundBlurEffect) backgroundBlurEffectView.alpha = 0 <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> backgroundBlurEffectView }() /// content view <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> children private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> contentViewContainer = UIView() private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> swipeIndicatorView = UIView()</code> </pre> <br><p>  Dans le bloc suivant, nous d√©finissons deux variables, <code>swipeAnimator</code> est responsable de l'animation, <code>swipeInteractor</code> est responsable de l'interaction (la capacit√© de contr√¥ler la progression de l'animation), nous devons l'initialiser lors du d√©marrage du contr√¥leur, afin de forcer le d√©ballage. </p><br><pre> <code class="hljs erlang">// MARK: - Animation <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> transition private <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> swipeAnimator = AnimatedTransitioning() private var swipeInteractor: CustomSwipeInteractor!</code> </pre> <br><p>  Nous avons √©galement d√©fini la transformation de l'indicateur.  Nous d√©calons l'indicateur de la largeur du conteneur + double d√©calage √† partir du bord + la largeur de l'indicateur lui-m√™me de sorte que l'indicateur se trouve √† l'extr√©mit√© oppos√©e du conteneur.  La largeur du conteneur sera connue lors de l'application, la variable est donc calcul√©e en d√©placement. </p><br><pre> <code class="hljs pgsql">// MARK: - Animation transforms private var swipeIndicatorViewTransform: CGAffineTransform { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CGAffineTransform(translationX: -contentViewContainer.bounds.size.width + (swipeIndicatorViewXShift * <span class="hljs-number"><span class="hljs-number">2</span></span>) + swipeIndicatorViewWidth, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) } }</code> </pre> <br><p>  Lors du chargement du contr√¥leur, nous nous attribuons √† l'animation (nous impl√©menterons le protocole correspondant ci-dessous), initialisons l'interacteur en fonction de notre animation, dont il contr√¥lera la progression.  Nous le nommons √©galement d√©l√©gu√©.  Le d√©l√©gu√© r√©pondra au d√©but du geste de l'utilisateur et lancera l'animation ou l'annulera en fonction de l'√©tat du contr√¥leur.  Ensuite, nous ajoutons toutes les vues √† la principale et appelons <code>setupViews()</code> , qui d√©finit les contraintes. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() swipeAnimator.animation = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> swipeInteractor = <span class="hljs-type"><span class="hljs-type">CustomSwipeInteractor</span></span>(with: swipeAnimator) swipeInteractor.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> view.addSubview(backgroundViewContainer) view.addSubview(backgroundBlurEffectView) view.addSubview(contentViewContainer) view.addSubview(swipeIndicatorView) setupViews() }</code> </pre> <br><p>  Ensuite, nous passons √† la logique d'installation et de suppression des contr√¥leurs enfants dans un conteneur.  Tout ici est simple comme dans la documentation Apple.  Nous utilisons les m√©thodes prescrites pour ce type d'op√©ration. </p><br><p>  <code>addChildViewController(vc)</code> - ajoutez un contr√¥leur enfant au contr√¥leur actuel. </p><br><p>  <code>contentViewContainer.addSubview(vc.view)</code> - ajoutez la vue du contr√¥leur √† la hi√©rarchie des vues. </p><br><p>  <code>vc.view.frame = contentViewContainer.bounds</code> - √©tire la vue √† l'ensemble du conteneur.  √âtant donn√© que nous utilisons des cadres ici au lieu de la mise en page automatique, nous devons changer leur taille chaque fois que la taille du contr√¥leur change, nous allons omettre cette logique et supposer que le conteneur ne changera pas la taille de l'application pendant que l'application est en cours d'ex√©cution. </p><br><p>  <code>vc.didMove(toParentViewController: self)</code> - met fin √† l'op√©ration d'ajout d'un contr√¥leur enfant. </p><br><p>  <code>swipeInteractor.wireTo</code> - nous <code>swipeInteractor.wireTo</code> le contr√¥leur actuel aux gestes de l'utilisateur.  Plus tard, nous analyserons cette m√©thode. </p><br><pre> <code class="hljs pgsql">// MARK: - Private methods private func addChild(vc: UIViewController) { addChildViewController(vc) contentViewContainer.addSubview(vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>) vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.frame = contentViewContainer.bounds vc.didMove(toParentViewController: self) topViewController = vc let goingRight = children.<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>: topViewController!) == <span class="hljs-number"><span class="hljs-number">0</span></span> swipeInteractor.wireTo(viewController: topViewController!, edge: goingRight ? .right : .left) } private func removeChild(vc: UIViewController) { vc.willMove(toParentViewController: nil) vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.removeFromSuperview() vc.removeFromParentViewController() topViewController = nil }</code> </pre> <br><p>  Il y a deux autres m√©thodes dont je ne donnerai pas le code ici: <code>setViewControllers</code> et <code>setBackground</code> .  Dans la m√©thode <code>setViewControllers</code> nous d√©finissons simplement le tableau des contr√¥leurs enfants dans la variable correspondante de notre contr√¥leur et appelons <code>addChild</code> pour afficher l'un d'entre eux dans la vue.  Dans la m√©thode <code>setBackground</code> nous faisons la m√™me chose que dans <code>addChild</code> , uniquement pour le contr√¥leur d'arri√®re-plan. </p><br><h2 id="logika-animacii-kontrollera-konteynera">  Logique d'animation du contr√¥leur de conteneur </h2><br><p>  Total, la base de notre contr√¥leur parent est: </p><br><ul><li>  UIView divis√© en deux types <br><ul><li>  Conteneurs </li><li>  Ordinaire </li></ul></li><li>  Liste des enfants UIViewController </li><li>  Un objet de contr√¥le d'animation de type <code>swipeAnimator</code> <code>AnimatedTransitioning</code> </li><li>  Un objet qui contr√¥le le cours interactif d'une animation <code>swipeInteractor</code> de type <code>CustomSwipeInteractor</code> </li><li>  D√©l√©guer l'animation interactive </li><li>  Impl√©mentation du protocole d'animation </li></ul><br><p>  Nous allons maintenant analyser les deux derniers points, puis passer √† l'impl√©mentation de <code>AnimatedTransitioning</code> et <code>CustomSwipeInteractor</code> . </p><br><h3 id="delegat-interaktivnogo-hoda-animacii">  D√©l√©guer l'animation interactive </h3><br><p>  Le d√©l√©gu√© se compose d'une seule <code>panGestureDidStart(rightToLeftSwipe: Bool) -&gt; Bool</code> , qui informe le contr√¥leur du d√©but du geste et de sa direction.  En r√©ponse, il attend des informations pour savoir si l'animation peut √™tre consid√©r√©e comme d√©marr√©e. </p><br><p>  En tant que d√©l√©gu√©, nous v√©rifions l'ordre actuel des contr√¥leurs afin de comprendre si nous pouvons d√©marrer l'animation dans la direction donn√©e, et si tout va bien, nous d√©marrons la m√©thode de <code>transition</code> , avec les param√®tres: le contr√¥leur √† partir duquel nous nous d√©pla√ßons, le contr√¥leur vers lequel nous nous d√©pla√ßons, la direction du mouvement, l'indicateur d'interactivit√© (en cas de <code>false</code> , une animation de transition √† dur√©e fixe est d√©clench√©e). </p><br><pre> <code class="hljs julia">func panGestureDidStart(rightToLeftSwipe: <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span> { guard <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> topViewController = topViewController, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fromIndex = children.index(of: topViewController) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newIndex = rightToLeftSwipe ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> //   -    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> newIndex &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; newIndex &lt; children.count &amp;&amp; newIndex != fromIndex { transition(from: children[fromIndex], to: children[newIndex], goingRight: rightToLeftSwipe, interactive: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><p>  Examinons imm√©diatement le corps de la m√©thode de <code>transition</code> .  Tout d'abord, nous cr√©ons le contexte d'animation pour l'animation <code>CustomControllerContext</code> .  Nous analyserons √©galement cette classe un peu plus tard, elle impl√©mente le protocole <code>UIViewControllerContextTransitioning</code> .  Dans le cas de <code>UINavigationController</code> et <code>UITabBarController</code> instance de la mise en ≈ìuvre de ce protocole est automatiquement cr√©√©e par le syst√®me et sa logique nous est cach√©e, nous devons cr√©er la n√¥tre. </p><br><pre> <code class="hljs pgsql">let ctx = CustomControllerContext(fromViewController: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, toViewController: <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, containerView: contentViewContainer, goingRight: goingRight) ctx.isAnimated = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ctx.isInteractive = interactive ctx.completionBlock = { (didComplete: <span class="hljs-type"><span class="hljs-type">Bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> didComplete { self.removeChild(vc: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) self.addChild(vc: <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) } };</code> </pre> <br><p>  Ensuite, nous appelons simplement une animation fixe ou interactive.  Dans le futur, il sera possible d'en accrocher un fixe sur les onglets de navigation entre les contr√¥leurs, dans cet exemple nous ne le ferons pas. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> interactive { // Animate <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> interaction swipeInteractor.startInteractiveTransition(ctx) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // Animate <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> interaction swipeAnimator.animateTransition(<span class="hljs-keyword"><span class="hljs-keyword">using</span></span>: ctx) }</code> </pre> <br><h3 id="protokol-animacii">  Protocole d'animation </h3><br><p>  <code>TransitionAnimation</code> protocole d'animation <code>TransitionAnimation</code> compose de 4 m√©thodes: </p><br><p>  <code>addTo</code> est une m√©thode con√ßue pour cr√©er la structure correcte des vues enfant dans le conteneur, de sorte que la vue pr√©c√©dente chevauche la nouvelle selon l'id√©e de l'animation. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// Setup the views hirearchy for animation. func addTo(containerView: UIView, fromView: UIView, toView: UIView, fromLeft: Bool)</span></span></code> </pre> <br><p>  <code>prepare</code> est la m√©thode appel√©e avant l'animation pour pr√©parer la vue. </p><br><pre> <code class="hljs sql">/// Setup the views position prior to the animation start. func <span class="hljs-keyword"><span class="hljs-keyword">prepare</span></span>(fromView <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: UIView?, toView <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>: UIView?, fromLeft: <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>)</code> </pre> <br><p>  <code>animation</code> - l'animation elle-m√™me. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// The animation. func animation(fromView from: UIView?, toView to: UIView?, fromLeft: Bool)</span></span></code> </pre> <br><p>  <code>finalize</code> - les actions n√©cessaires apr√®s la fin de l'animation. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// Cleanup the views position after the animation ended. func finalize(completed: Bool, fromView from: UIView?, toView to: UIView?, fromLeft: Bool)</span></span></code> </pre> <br><p>  Nous ne consid√©rerons pas l'impl√©mentation utilis√©e, tout y est assez transparent, nous irons directement aux trois classes principales, gr√¢ce auxquelles l'animation se d√©roule. </p><br><h2 id="class-customcontrollercontext-nsobject-uiviewcontrollercontexttransitioning"> <code>class CustomControllerContext: NSObject, UIViewControllerContextTransitioning</code> </h2> <br><p>  Le contexte de l'animation.  Pour d√©crire sa fonction, nous nous r√©f√©rons √† l'aide du protocole <code>UIViewControllerContextTransitioning</code> : </p><br><blockquote>  Un objet de contexte encapsule des informations sur les vues et les contr√¥leurs de vue impliqu√©s dans la transition.  Il contient √©galement des d√©tails sur la fa√ßon d'ex√©cuter la transition. </blockquote><p>  La chose la plus int√©ressante est l'interdiction de l'adaptation de ce protocole: </p><br><blockquote>  N'adoptez pas ce protocole dans vos propres classes et ne devez pas cr√©er directement des objets qui adoptent ce protocole. </blockquote><p>  Mais nous en avons vraiment besoin pour ex√©cuter le moteur d'animation standard, nous l'adaptons donc quand m√™me.  Il n'a presque aucune logique, il ne stocke que l'√©tat.  Par cons√©quent, je ne l'apporterai m√™me pas ici.  Vous pouvez le regarder sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . </p><br><p>  Cela fonctionne tr√®s bien sur les animations √† dur√©e fixe.  Mais lors de son utilisation pour des animations interactives, un probl√®me se pose: <code>UIPercentDrivenInteractiveTransition</code> invoque une m√©thode non document√©e sur le contexte.  La seule bonne solution dans cette situation est d'adapter un autre protocole - <code>UIViewControllerInteractiveTransitioning</code> pour utiliser votre propre contexte. </p><br><h2 id="class-percentdriveninteractivetransition-nsobject-uiviewcontrollerinteractivetransitioning"> <code>class PercentDrivenInteractiveTransition: NSObject, UIViewControllerInteractiveTransitioning</code> </h2> <br><p>  Le voici - le c≈ìur du projet, permettant aux animations interactives d'exister dans des contr√¥leurs de conteneurs personnalis√©s.  Prenons-le dans l'ordre. </p><br><p>  La classe est initialis√©e avec un param√®tre de type <code>UIViewControllerAnimatedTransitioning</code> , c'est le protocole standard pour animer la transition entre les contr√¥leurs.  De cette fa√ßon, nous pouvons utiliser l'une des animations d√©j√† √©crites avec notre classe. </p><br><pre> <code class="hljs objectivec">init(with animator: <span class="hljs-built_in"><span class="hljs-built_in">UIViewControllerAnimatedTransitioning</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.animator = animator }</code> </pre> <br><p>  L'interface publique est assez simple, quatre m√©thodes, dont la fonctionnalit√© devrait √™tre √©vidente. </p><br><p>  Il suffit de noter le moment o√π l'animation d√©marre, nous prenons la vue parent du conteneur et d√©finissons la vitesse du calque sur 0, nous avons donc la possibilit√© de contr√¥ler la progression de l'animation manuellement. </p><br><pre> <code class="hljs pgsql">// MARK: - <span class="hljs-built_in"><span class="hljs-built_in">Public</span></span> func startInteractiveTransition(_ transitionContext: UIViewControllerContextTransitioning) { self.transitionContext = transitionContext transitionContext.containerView.superview?.layer.speed = <span class="hljs-number"><span class="hljs-number">0</span></span> animator.animateTransition(<span class="hljs-keyword"><span class="hljs-keyword">using</span></span>: transitionContext) } func updateInteractiveTransition(percentComplete: CGFloat) { setPercentComplete(percentComplete: (CGFloat(fmaxf(fminf(<span class="hljs-type"><span class="hljs-type">Float</span></span>(percentComplete), <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>)))) } func cancelInteractiveTransition() { transitionContext?.cancelInteractiveTransition() completeTransition() } func finishInteractiveTransition() { transitionContext?.finishInteractiveTransition() completeTransition() }</code> </pre> <br><p>  Nous passons maintenant au bloc logique priv√© de notre classe. </p><br><p>  <code>setPercentComplete</code> d√©finit le d√©calage temporel de la progression de l'animation pour la couche superview, calculant la valeur √† partir du pourcentage d'ach√®vement et de la dur√©e de l'animation. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPercentComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(percentComplete: CGFloat)</span></span></span></span> { setTimeOffset(timeOffset: <span class="hljs-type"><span class="hljs-type">TimeInterval</span></span>(percentComplete) * duration) transitionContext?.updateInteractiveTransition(percentComplete) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setTimeOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset: TimeInterval)</span></span></span></span> { transitionContext?.containerView.superview?.layer.timeOffset = timeOffset }</code> </pre> <br><p>  <code>completeTransition</code> est appel√©e lorsque l'utilisateur a arr√™t√© son geste.  Ici, nous cr√©ons une instance de la classe <code>CADisplayLink</code> , qui nous permettra de terminer automatiquement et magnifiquement l'animation √† partir du moment o√π l'utilisateur ne contr√¥le plus sa progression.  Nous ajoutons notre <code>displayLink</code> √† la <code>run loop</code> afin que le syst√®me appelle notre s√©lecteur chaque fois qu'il a besoin d'afficher un nouveau cadre sur l'√©cran de l'appareil. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">completeTransition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { displayLink = <span class="hljs-type"><span class="hljs-type">CADisplayLink</span></span>(target: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, selector: #selector(tickAnimation)) displayLink!.add(to: .main, forMode: .commonModes) }</code> </pre> <br><p>  Dans notre s√©lecteur, nous calculons et d√©finissons le d√©placement temporaire de la progression de l'animation, comme nous l'avons fait auparavant lors du geste de l'utilisateur, ou nous terminons l'animation lorsqu'elle atteint son point de d√©but ou de fin. </p><br><pre> <code class="hljs coffeescript">@objc private func tickAnimation() { var timeOffset = self.timeOffset() let tick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(displayLink?.duration ?? </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> * TimeInterval</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completionSpeed)</span></span></span><span class="hljs-function"> timeOffset += </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transitionContext?.transitionWasCancelled ?? </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ? -tick : tick; if </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || timeOffset &gt; duration)</span></span></span><span class="hljs-function"> { transitionFinished</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> } else { setTimeOffset</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset: timeOffset)</span></span></span><span class="hljs-function"> } } private func timeOffset</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> TimeInterval { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> transitionContext?.containerView.superview?.layer.timeOffset ?? <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><p>  En terminant l'animation, nous d√©sactivons notre <code>displayLink</code> , retournons la vitesse du calque, et si l'animation n'a pas √©t√© annul√©e, c'est-√†-dire qu'elle a atteint sa derni√®re image, nous calculons le temps √† partir duquel l'animation du calque doit commencer.  Vous pouvez en savoir plus √† ce sujet dans le Core Animation Programming Guide, ou dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette r√©ponse</a> √† stackoverflow. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transitionFinished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { displayLink?.invalidate() <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> layer = transitionContext?.containerView.superview?.layer <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } layer.speed = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wasNotCanceled = !(transitionContext?.transitionWasCancelled ?? <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wasNotCanceled) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pausedTime = layer.timeOffset layer.timeOffset = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timeSincePause = layer.convertTime(<span class="hljs-type"><span class="hljs-type">CACurrentMediaTime</span></span>(), from: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) - pausedTime layer.beginTime = timeSincePause } animator.animationEnded?(wasNotCanceled) }</code> </pre> <br><h2 id="class-animatedtransitioning-nsobject-uiviewcontrolleranimatedtransitioning"> <code>class AnimatedTransitioning: NSObject, UIViewControllerAnimatedTransitioning</code> </h2> <br><p>  La derni√®re classe que nous n'avons pas encore examin√©e est l'impl√©mentation du protocole <code>UIViewControllerAnimatedTransitioning</code> , dans lequel nous contr√¥lons l'ordre d'ex√©cution des m√©thodes de protocole de notre animation <code>addTo</code> , <code>prepare</code> , <code>animation</code> , <code>addTo</code> .  Tout ici est assez prosa√Øque, il convient de noter uniquement l'utilisation de <code>UIViewPropertyAnimator</code> pour effectuer une animation au lieu du <code>UIView.animate(withDuration:animations:)</code> plus typique <code>UIView.animate(withDuration:animations:)</code> .  Ceci est fait de sorte qu'il a √©t√© possible de contr√¥ler davantage la progression de l'animation et, si elle est annul√©e, de la remettre √† sa position d' <code>finishAnimation(at: .start)</code> en appelant <code>finishAnimation(at: .start)</code> , ce qui √©vite un clignotement inutile de l'image finale de l'animation √† l'√©cran. </p><br><h2 id="epilog">  √âpilogue </h2><br><p>  Nous avons cr√©√© une d√©mo fonctionnelle d'une interface similaire √† celle de Snapchat.  Dans ma version, j'ai configur√© les constantes pour qu'il y ait des champs √† droite et √† gauche de la carte, en plus, j'ai laiss√© la cam√©ra en arri√®re plan pour cr√©er un effet derri√®re la carte.  Ceci est fait uniquement pour d√©montrer les capacit√©s de cette approche, comment elle affectera les performances de l'appareil et je n'ai pas v√©rifi√© la charge de sa batterie. </p><br><p>   ‚Äî        ,    -  ,          .      ,    -    . </p><br><p>      GitHub  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . </p><br><p>   ,   ,  ,  ! </p><br><p><img src="https://habrastorage.org/webt/mh/se/2z/mhse2z7hfck6aicbobu-vwyi9bw.gif"></p><br><h2 id="istochniki-informacii">  Sources d'information </h2><br><p>        : </p><br><ol><li><p>  Custom Container View Controller Transitions,  Joachim Bondo. </p><br><p>        Objective C.          Swift. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> </p><br></li><li><p>  Interactive Custom Container View Controller Transitions,  Alek √Östr√∂m </p><br><p>               ,   Objective C,           Swift. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> </p><br></li><li><p> <code>SwipeableTabBarController</code> </p> <br><p> ,            <code>UITabBarController</code> .      . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> </p><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415795/">https://habr.com/ru/post/fr415795/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415783/index.html">Les disques stellaires nous r√©v√®lent les secrets de l'apparition des plan√®tes</a></li>
<li><a href="../fr415785/index.html">SpaceX envoie un robot d'intelligence artificielle √† l'ISS</a></li>
<li><a href="../fr415789/index.html">Algorithmes de brevetage pour les programmes informatiques</a></li>
<li><a href="../fr415791/index.html">Optimisation des contrats intelligents. Comment les types de solidit√© affectent les co√ªts de transaction</a></li>
<li><a href="../fr415793/index.html">Guide complet de r√©approvisionnement de domaine</a></li>
<li><a href="../fr415797/index.html">Expressions r√©guli√®res + programmation logique. Quel est le r√©sultat?</a></li>
<li><a href="../fr415801/index.html">Google: notre IA "t√©l√©phone" n'est pas assez bonne pour √™tre dangereuse</a></li>
<li><a href="../fr415805/index.html">Modification du module barri√®re GSM Doorhan pour le contr√¥le Internet</a></li>
<li><a href="../fr415809/index.html">Comment utiliser le soja, requirejs, backbone js dans les plugins pour Atlassian Jira</a></li>
<li><a href="../fr415811/index.html">AI, cours pratique. Vue d'ensemble des r√©seaux de neurones pour la classification d'images</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>