<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∏üèæ üîñ ü§∞üèæ Pourquoi vous devriez utiliser pathlib üì≠ ü§¶üèø üßúüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Du traducteur: Bonjour, Habr! Je vous pr√©sente la traduction de l'article Pourquoi vous devriez utiliser pathlib et sa suite, Non vraiment, pathlib es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pourquoi vous devriez utiliser pathlib</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453862/"><p>  <em>Du traducteur: Bonjour, Habr!</em>  <em>Je vous pr√©sente la traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pourquoi vous devriez utiliser pathlib</a> et sa suite, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Non vraiment, pathlib est g√©nial</a> .</em>  <em>Une grande attention est d√©sormais accord√©e aux nouvelles fonctionnalit√©s Python telles que asyncio, l'op√©rateur: = et la saisie facultative.</em>  <em>Dans le m√™me temps, un risque non significatif (bien que: appeler une innovation s√©rieuse une langue ne se r√©v√®le pas une innovation s√©rieuse) pour un radar, mais des innovations tr√®s utiles dans une langue.</em>  <em>En particulier, sur une multitude d'articles consacr√©s √† un sujet, je n'ai pas trouv√© (sauf un paragraphe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ), j'ai donc d√©cid√© de corriger la situation.</em> </p><br><p> Quand j'ai d√©couvert le nouveau module <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pathlib</a> il y a quelques ann√©es, j'ai d√©cid√© du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fond de</a> mon esprit que c'√©tait juste une version orient√©e objet l√©g√®rement maladroite du module <code>os.path</code> .  J'avais tort.  <code>pathlib</code> est vraiment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">merveilleux</a> ! </p><br><p>  Dans cet article, je vais essayer de tomber amoureux de <code>pathlib</code> .  J'esp√®re que cet article vous <strong><code>pathlib</code></strong> √† <strong>utiliser <code>pathlib</code> dans toute situation concernant l'utilisation de fichiers en Python</strong> . </p><a name="habracut"></a><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>os.path</code> maladroit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>os</code> surcharg√©</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>   glob</code></a> </li> <li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>pathlib</code> rend les choses simples encore plus faciles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les objets de chemin rendent votre code plus √©vident</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>    pathlib</code> ?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>    pathlib</code> ?</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2. R√©ponses aux questions.</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code> os.path</code> √™tre honn√™te, <code> os.path</code> et <code>pathlib</code></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vous n'avez pas √† vous soucier de normaliser les chemins.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code> ,     ,    pathlib</code> !</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mais ma biblioth√®que pr√©f√©r√©e a Path mieux que la norme!</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>  pathlib.Path</code> et <code>str</code> ne se m√©langent pas, non?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>pathlib</code> trop lent</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Am√©lioration de la lisibilit√©</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>   pathlib.Path</code></a> </li> </ul></li></ul><br><h2 id="chast-1">  Partie 1 </h2><br><h3 id="ospath-neuklyuzh">  <code>os.path</code> maladroit </h3><br><p>  Le module <code>os.path</code> toujours √©t√© ce que nous <code>os.path</code> pour les chemins Python.  En principe, il y a tout ce dont vous avez besoin, mais souvent il n'a pas l'air trop √©l√©gant. </p><br><p>  Dois-je l'importer comme √ßa? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) TEMPLATES_DIR = os.path.join(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Ou alors? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> abspath, dirname, join BASE_DIR = dirname(dirname(abspath(__file__))) TEMPLATES_DIR = join(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Peut-√™tre que la fonction de <code>join</code> a un nom trop g√©n√©ral, et nous devrions faire quelque chose comme ceci: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> abspath, dirname, join <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> joinpath BASE_DIR = dirname(dirname(abspath(__file__))) TEMPLATES_DIR = joinpath(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Pour moi, toutes les options ci-dessus ne semblent pas trop pratiques.  Nous transmettons des cha√Ænes aux fonctions qui renvoient des cha√Ænes que nous transmettons aux fonctions suivantes qui fonctionnent avec des cha√Ænes.  Il se trouve qu'ils contiennent tous des chemins, mais ce ne sont encore que des lignes. </p><br><p>  L'utilisation de cha√Ænes pour l'entr√©e et la sortie dans les fonctions <code>os.path</code> tr√®s g√™nante car vous devez lire le code de l'int√©rieur.  Je voudrais convertir ces appels de imbriqu√©s en s√©quentiels.  C'est ce que <code>pathlib</code> vous permet de faire! </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path BASE_DIR = Path(__file__).resolve().parent.parent TEMPLATES_DIR = BASE_DIR.joinpath(<span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Le module <code>os.path</code> n√©cessite des appels de fonction imbriqu√©s, mais <code>pathlib</code> <strong>nous permet de cr√©er des cha√Ænes d'appels cons√©cutifs aux m√©thodes et attributs de la classe <code>Path</code></strong> avec un r√©sultat √©quivalent. </p><br><p>  Je sais ce que vous en pensez: arr√™tez, ces objets <code>Path</code> ne sont plus les m√™mes qu'avant, nous n'op√©rons plus sur les lignes de trajectoire!  Nous reviendrons sur cette question plus tard (indice: dans presque toutes les situations, ces deux approches sont interchangeables). </p><br><h3 id="os-peregruzhen">  <code>os</code> surcharg√© </h3><br><p>  Le module <code>os.path</code> classique <code>os.path</code> con√ßu pour fonctionner avec des chemins.  Mais apr√®s avoir voulu <em>faire quelque chose</em> avec le chemin (par exemple, cr√©er un r√©pertoire), vous devrez acc√©der √† un autre module, souvent <code>os</code> . </p><br><p>  <code>os</code> contient un tas d'utilitaires pour travailler avec des fichiers et des r√©pertoires: <code>mkdir</code> , <code>getcwd</code> , <code>chmod</code> , <code>stat</code> , <code>remove</code> , <code>rename</code> , <code>rmdir</code> .  Aussi <code>chdir</code> , <code>link</code> , <code>walk</code> , <code>listdir</code> , <code>makedirs</code> , <code>removedirs</code> , <code>removedirs</code> , <code>unlink</code> , <code>symlink</code> .  Et tout un tas de choses qui ne sont pas du tout li√©es aux syst√®mes de fichiers: <code>fork</code> , <code>getenv</code> , <code>putenv</code> , <code>environ</code> , <code>getlogin</code> , <code>system</code> , ... Quelques dizaines d'autres choses que je ne mentionnerai pas ici. </p><br><p>  <strong>Le module <code>os</code> est con√ßu pour un large √©ventail de t√¢ches;</strong>  <strong>c'est une telle bo√Æte avec tout ce qui concerne le syst√®me d'exploitation.</strong>  Il y a beaucoup d'utilit√©s dans <code>os</code> , mais ce n'est pas toujours facile de s'y retrouver: il est souvent n√©cessaire de fouiller un peu dans le module avant de trouver ce dont on a besoin. </p><br><p>  <code>pathlib</code> transf√®re la plupart des fonctions du syst√®me de fichiers vers les objets <code>Path</code> . </p><br><p>  Voici le code qui cr√©e le <code>src/__pypackages__</code> et renomme notre fichier <code>.editorconfig</code> en <code>src/.editorconfig</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path os.makedirs(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'__pypackages__'</span></span>), exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) os.rename(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>, os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>))</code> </pre> <br><p>  Voici un code similaire utilisant <code>Path</code> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>).mkdir(parents=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).rename(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  Notez que le deuxi√®me exemple de code est beaucoup plus facile √† lire, car il est organis√© de gauche √† droite - tout cela gr√¢ce aux cha√Ænes de m√©thodes. </p><br><h3 id="ne-zabyvayte-pro-glob">  N'oubliez pas <code>glob</code> </h3><br><p>  Non seulement <code>os</code> et <code>os.path</code> contiennent des m√©thodes li√©es au syst√®me de fichiers.  Il convient √©galement de mentionner le <code>glob</code> , qui ne peut pas √™tre qualifi√© d'inutile. </p><br><p>  Nous pouvons utiliser la fonction <code>glob.glob</code> pour rechercher des fichiers selon un mod√®le sp√©cifique: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> glob <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> glob top_level_csv_files = glob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>) all_csv_files = glob(<span class="hljs-string"><span class="hljs-string">'**/*.csv'</span></span>, recursive=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><p>  Le module <code>pathlib</code> fournit √©galement des m√©thodes similaires: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path top_level_csv_files = Path.cwd().glob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>) all_csv_files = Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>)</code> </pre> <br><p>  Apr√®s le passage au module <code>pathlib</code> , le <strong>besoin du <code>glob</code> dispara√Æt compl√®tement</strong> : tout ce dont vous avez besoin fait d√©j√† partie int√©grante des objets <code>Path</code> </p><br><h3 id="pathlib-delaet-prostye-veschi-esche-prosche">  <code>pathlib</code> rend les choses simples encore plus faciles </h3><br><p>  <code>pathlib</code> simplifie de nombreuses situations difficiles, mais <strong>rend</strong> √©galement <strong>certains extraits de code simples encore plus faciles</strong> . </p><br><p>  Vous voulez lire tout le texte dans un ou plusieurs fichiers? </p><br><p>  Vous pouvez ouvrir le fichier, lire le contenu et fermer le fichier √† l'aide du bloc <code>with</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> glob <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> glob file_contents = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> glob(<span class="hljs-string"><span class="hljs-string">'**/*.py'</span></span>, recursive=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(filename) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> python_file: file_contents.append(python_file.read())</code> </pre> <br><p>  Ou vous pouvez utiliser la m√©thode <code>read_text</code> sur les objets <code>Path</code> et g√©n√©rer des listes pour obtenir le m√™me r√©sultat en une seule expression: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path file_contents = [ path.read_text() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">'*.py'</span></span>) ]</code> </pre> <br><p>  Mais que faire si vous devez √©crire dans un fichier? </p><br><p>  Voici √† quoi cela ressemble en utilisant <code>open</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  Ou vous pouvez utiliser la m√©thode <code>write_text</code> : </p><br><pre> <code class="python hljs">Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).write_text(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  Si, pour une raison quelconque, vous devez utiliser <code>open</code> , soit comme gestionnaire de contexte, soit pour vos pr√©f√©rences personnelles, <code>Path</code> propose la m√©thode <code>open</code> comme alternative: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path path = Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> path.open(mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  Ou, √† partir de Python 3.6, vous pouvez passer votre <code>Path</code> directement pour <code>open</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path path = Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(path, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><h3 id="obekty-path-delayut-vash-kod-ochevidnee">  Les objets de chemin rendent votre code plus √©vident </h3><br><p>  Qu'indiquent les variables suivantes?  Quelle est la signification de leur signification? </p><br><pre> <code class="python hljs">person = <span class="hljs-string"><span class="hljs-string">'{"name": "Trey Hunner", "location": "San Diego"}'</span></span> pycon_2019 = <span class="hljs-string"><span class="hljs-string">"2019-05-01"</span></span> home_directory = <span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span></code> </pre> <br><p>  Chaque variable pointe vers une ligne.  Mais chacun d'eux a des significations diff√©rentes: le premier est JSON, le second est la date et le troisi√®me est le chemin du fichier. </p><br><p>  Cette repr√©sentation d'objets est l√©g√®rement plus utile: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> date <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path person = {<span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Trey Hunner"</span></span>, <span class="hljs-string"><span class="hljs-string">"location"</span></span>: <span class="hljs-string"><span class="hljs-string">"San Diego"</span></span>} pycon_2019 = date(<span class="hljs-number"><span class="hljs-number">2019</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) home_directory = Path(<span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span>)</code> </pre> <br><p>  Les objets JSON peuvent √™tre d√©s√©rialis√©s dans un dictionnaire, les dates peuvent √™tre repr√©sent√©es en mode natif √† l'aide de <code>datetime.date</code> et <strong>les objets de chemin de fichier peuvent √™tre repr√©sent√©s comme <code>Path</code></strong> </p><br><p>  L'utilisation d'objets <code>Path</code> rend votre code plus explicite.  Si vous souhaitez travailler avec des dates, vous utilisez la <code>date</code> .  Si vous souhaitez travailler avec des chemins de fichier, utilisez <code>Path</code> . </p><br><p>  Je ne suis pas un tr√®s grand partisan de la POO.  Les classes ajoutent une couche suppl√©mentaire d'abstraction, et les abstractions ont parfois tendance √† compliquer le syst√®me plut√¥t qu'√† le simplifier.  En m√™me temps, je pense que <code>pathlib.Path</code> est une <strong>abstraction utile</strong> .  Assez rapidement, cela devient une d√©cision accept√©e. </p><br><p>  Gr√¢ce au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PEP 519</a> , les <code>Path</code> deviennent la norme pour travailler avec les chemins.  Au moment de Python 3.6, la plupart des <code>os.path</code> <code>os</code> , <code>shutil</code> , <code>os.path</code> fonctionnent correctement avec ces objets.  <strong>Vous pouvez passer √† <code>pathlib</code> , transparent pour votre base de code!</strong> </p><br><h3 id="chego-ne-hvataet-v-pathlib">  Qu'est-ce qui manque dans <code>pathlib</code> ? </h3><br><p>  Bien que <code>pathlib</code> cool, il n'est pas complet.  Il y a certainement <strong>plusieurs possibilit√©s que j'aimerais inclure dans le module</strong> . </p><br><p>  La premi√®re chose qui me vient √† l'esprit est le manque de m√©thodes de chemin d'acc√®s √©quivalentes √† <code>shutil</code> .  Bien que vous puissiez passer <code>Path</code> tant <code>shutil</code> param√®tres de <code>shutil</code> pour copier / supprimer / d√©placer des fichiers et des r√©pertoires, vous ne pouvez pas les appeler en tant que m√©thodes sur les objets <code>Path</code> . </p><br><p>  Donc, pour copier des fichiers, vous devez faire quelque chose comme ceci: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> shutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> copyfile source = Path(<span class="hljs-string"><span class="hljs-string">'old_file.txt'</span></span>) destination = Path(<span class="hljs-string"><span class="hljs-string">'new_file.txt'</span></span>) copyfile(source, destination)</code> </pre> <br><p>  Il n'y a pas non plus d'analogue de la m√©thode <code>os.chdir</code> .  Cela signifie que vous devez l'importer si vous devez modifier le r√©pertoire actuel: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chdir parent = Path(<span class="hljs-string"><span class="hljs-string">'..'</span></span>) chdir(parent)</code> </pre> <br><p>  Il n'y a pas non plus d'√©quivalent √† la fonction <code>os.walk</code> .  Bien que vous puissiez √©crire votre propre fonction dans l'esprit d'une <code>walk</code> sans trop de difficult√©. </p><br><p>  J'esp√®re qu'un jour les objets <code>pathlib.Path</code> contiendront des m√©thodes pour certaines des op√©rations mentionn√©es.  Mais m√™me dans ce sc√©nario, <strong>je trouve qu'il est beaucoup plus facile d'utiliser <code>pathlib</code> avec autre chose que d'utiliser <code>os.path</code> et tout le reste</strong> . </p><br><h3 id="vsegda-li-nuzhno-ispolzovat-pathlib">  Est-il toujours n√©cessaire d'utiliser <code>pathlib</code> ? </h3><br><p>  √Ä partir de Python 3.6, les <strong>chemins fonctionnent presque partout o√π vous utilisez des cha√Ænes</strong> .  Je ne vois donc aucune raison de <em>ne pas</em> utiliser <code>pathlib</code> si vous utilisez Python 3.6 et sup√©rieur. </p><br><p>  Si vous utilisez une version ant√©rieure de Python 3, vous pouvez √† tout moment encapsuler l'objet <code>Path</code> dans un appel <code>str</code> pour obtenir une cha√Æne si vous devez revenir au pays des lignes.  Ce n'est pas trop √©l√©gant, mais √ßa marche: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chdir <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path chdir(Path(<span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">#   Python 3.6+ chdir(str(Path('/home/trey'))) #     </span></span></code> </pre> <br><h2 id="chast-2-otvety-na-voprosy">  Partie 2. R√©ponses aux questions. </h2><br><p>  Apr√®s la publication de la premi√®re partie, certaines personnes ont pos√© des questions.  Quelqu'un a dit que j'avais malhonn√™tement <code>pathlib</code> <code>os.path</code> et <code>pathlib</code> .  Certains ont dit que l'utilisation d' <code>os.path</code> tellement ancr√©e dans la communaut√© Python que le passage √† une nouvelle biblioth√®que prendra tr√®s longtemps.  J'ai √©galement vu quelques questions sur les performances. </p><br><p>  Dans cette partie, je voudrais commenter ces questions.  Cela peut √™tre consid√©r√© √† la fois comme <code>pathlib</code> protection <code>pathlib</code> et une sorte de lettre d'amour au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PEP 519</a> . </p><br><h3 id="sravnenie-ospath-i-pathlib-po-chestnomu">  <code>os.path</code> √™tre honn√™te, comparez <code>os.path</code> et <code>pathlib</code> </h3><br><p>  Dans la derni√®re partie, j'ai compar√© les deux fragments de code suivants: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path os.makedirs(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'__pypackages__'</span></span>), exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) os.rename(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>, os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>))</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>).mkdir(parents=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).rename(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  Cela peut sembler une comparaison injuste, car l'utilisation de <code>os.path.join</code> dans le premier exemple garantit que les d√©limiteurs corrects sont utilis√©s sur toutes les plates-formes, ce que je n'ai pas fait dans le deuxi√®me exemple.  En fait, tout est en ordre, car <strong>Path normalise automatiquement les s√©parateurs de chemin</strong> </p><br><p>  Nous pouvons le prouver en regardant la conversion de l'objet <code>Path</code> en une cha√Æne sous Windows: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>str(Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src\\__pypackages__'</span></span></code> </pre> <br><p>  Cela ne fait aucune diff√©rence si nous utilisons la m√©thode <code>joinpath</code> , le <code>'/'</code> dans la ligne de chemin, l'op√©rateur <code>/</code> (une autre fonctionnalit√© int√©ressante de <code>Path</code> ), ou si nous transmettons des arguments individuels au constructeur Path, nous obtenons le m√™me r√©sultat: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>) / <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span> WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>).joinpath(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  Le dernier exemple a provoqu√© une certaine confusion chez les personnes qui ont sugg√©r√© que <code>pathlib</code> pas assez intelligent pour remplacer <code>/</code> par <code>\</code> dans la cha√Æne de chemin.  Heureusement, tout est en ordre! </p><br><p>  Avec les objets <code>Path</code> , vous n'avez plus √† vous soucier de la direction des barres obliques: d√©finissez tous vos chemins √† l'aide de <code>/</code> , et le r√©sultat sera pr√©visible pour n'importe quelle plate-forme. </p><br><h3 id="vy-ne-dolzhny-bespokoitsya-o-normalizacii-putey">  Vous n'avez pas √† vous soucier de normaliser les chemins. </h3><br><p>  Si vous utilisez Linux ou Mac, il est tr√®s facile d'ajouter accidentellement des bogues au code qui affectent uniquement les utilisateurs de Windows.  Si vous ne surveillez pas attentivement l'utilisation de <code>os.path.join</code> et \ ou <code>os.path.normcase</code> pour convertir les barres obliques en celles adapt√©es √† la plate-forme actuelle, <strong>vous pouvez √©crire du code qui ne fonctionnera pas correctement sous Windows</strong> . </p><br><p>  Voici un exemple de bogue sp√©cifique √† Windows: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path directory = <span class="hljs-string"><span class="hljs-string">'.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] new_file = os.path.join(directory, <span class="hljs-string"><span class="hljs-string">'new_package/__init__.py'</span></span>)</code> </pre> <br><p>  De plus, un tel code fonctionnera correctement partout: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path directory = <span class="hljs-string"><span class="hljs-string">'.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] new_file = Path(directory, <span class="hljs-string"><span class="hljs-string">'new_package/__init__.py'</span></span>)</code> </pre> <br><p>  Auparavant, le programmeur √©tait responsable de la concat√©nation et de la normalisation des chemins, tout comme dans Python 2, le programmeur √©tait responsable de d√©cider o√π utiliser unicode au lieu d'octets.  Ce n'est plus votre t√¢che - <code>Path</code> r√©sout tous ces probl√®mes pour vous. </p><br><p>  Je n'utilise pas Windows et je n'ai pas d'ordinateur Windows.  Mais beaucoup de gens qui utiliseront mon code utiliseront tr√®s probablement Windows, et je veux que tout fonctionne correctement pour eux. </p><br><p>  <strong>S'il y a une chance que votre code s'ex√©cute sur Windows, vous devriez s√©rieusement envisager de passer √† <code>pathlib</code> .</strong> </p><br><p>  <strong>Ne vous inqui√©tez pas de la normalisation</strong> : utilisez quand m√™me <code>Path</code> pour les chemins de fichiers. </p><br><h3 id="zvuchit-klassno-no-u-menya-storonnyaya-biblioteka-kotoraya-ne-ispolzuet-pathlib">  √áa a l'air cool, mais j'ai une biblioth√®que tierce qui n'utilise pas <code>pathlib</code> ! </h3><br><p>  Vous disposez d'une grande base de code qui fonctionne avec des cha√Ænes comme chemins.  Pourquoi passer √† <code>pathlib</code> si cela signifie que tout doit √™tre r√©√©crit? </p><br><p>  Imaginons que vous ayez la fonction suivante: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filename."""</span></span> filename = os.path.join(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(filename): os.makedirs(dir_path, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) open(filename, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>).write(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filename</code> </pre> <br><p>  La fonction prend un r√©pertoire et y cr√©e un fichier <code>.editorconfig</code> , quelque chose comme ceci: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path &gt;&gt;&gt; make_editorconfig(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'my_package'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span></code> </pre> <br><p>  Si vous remplacez les lignes par <code>Path</code> , tout fonctionnera aussi: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; make_editorconfig(Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span></code> </pre> <br><p>  Mais ... comment? </p><br><p>  <code>os.path.join</code> accepte les objets <code>Path</code> (depuis Python 3.6).  On peut en dire <code>os.makedirs</code> des <code>os.makedirs</code> . <br>  En fait, la fonction <code>open</code> int√©gr√©e accepte <code>Path</code> , <code>shutil</code> accepte <code>Path</code> et tout dans la biblioth√®que standard utilis√©e pour accepter les cha√Ænes devrait maintenant fonctionner avec <code>Path</code> et les cha√Ænes. </p><br><p>  Nous devons remercier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PEP 519 pour cela</a> , qui a fourni la classe abstraite <code>os.PathLike</code> et a annonc√© que tous les utilitaires int√©gr√©s pour travailler avec les chemins de fichiers devraient maintenant fonctionner avec les cha√Ænes et <code>Path</code> . </p><br><h3 id="no-v-moey-lyubimoy-biblioteke-est-path-luchshe-standartnogo">  Mais ma biblioth√®que pr√©f√©r√©e a Path, meilleure que la norme! </h3><br><p>  Vous utilisez peut-√™tre d√©j√† une biblioth√®que tierce qui fournit son impl√©mentation <code>Path</code> , qui est diff√©rente de celle standard.  Peut-√™tre que vous l'aimez plus. </p><br><p>  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">django-environ</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">path.py</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plumbum</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">visidata</a> contiennent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chacun</a> leurs propres objets <code>Path</code> .  Certaines de ces biblioth√®ques sont plus anciennes que <code>pathlib</code> et ont d√©cid√© d'h√©riter de <code>str</code> afin qu'elles puissent √™tre pass√©es √† des fonctions qui attendent des cha√Ænes comme chemins.  Gr√¢ce au PEP 519, l'int√©gration de biblioth√®ques tierces dans votre code sera plus facile et sans avoir besoin d'h√©riter de <code>str</code> . </p><br><p>  Imaginons que vous ne vouliez pas utiliser <code>pathlib</code> , car <code>Path</code> sont des objets immuables, et vous voulez vraiment vraiment changer leur √©tat.  Avec PEP 519, vous pouvez cr√©er votre meilleure version mutable de <code>Path</code> .  Pour ce faire, impl√©mentez simplement la m√©thode <code>__fspath__</code> </p><br><p>  Toute impl√©mentation auto-√©crite de <code>Path</code> peut d√©sormais fonctionner de mani√®re native avec les fonctions int√©gr√©es Python qui attendent des chemins de fichier.  <strong>M√™me si vous n'aimez pas <code>pathlib</code> , le fait de son existence est un gros plus pour les biblioth√®ques tierces avec leur propre <code>Path</code></strong> </p><br><h3 id="no-ved-pathlibpath-i-str-ne-smeshivayutsya-pravda">  Mais <code>pathlib.Path</code> et <code>str</code> ne se m√©langent pas, non? </h3><br><p>  Vous pensez probablement: tout cela est bien s√ªr g√©nial, mais cette approche avec parfois des lignes et parfois des chemins ajoutera-t-elle de la complexit√© √† mon code? </p><br><p>  La r√©ponse √† cette question est oui, dans une certaine mesure.  Mais ce probl√®me a une solution de contournement assez simple. </p><br><p>  PEP 519 a ajout√© quelques autres choses en plus de <code>PathLike</code> : premi√®rement, c'est un moyen de convertir n'importe quel <code>PathLike</code> en cha√Æne, et deuxi√®mement, c'est un moyen de transformer n'importe quel <code>PathLike</code> en <code>Path</code> . </p><br><p>  Prenons deux objets - une cha√Æne et <code>Path</code> (ou quoi que ce soit avec la m√©thode <strong>fspath</strong> ): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path p1 = os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'my_package'</span></span>) p2 = Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)</code> </pre> <br><p>  La fonction <code>os.fspath</code> normalise les deux objets et les transforme en cha√Ænes: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> fspath &gt;&gt;&gt; fspath(p1), fspath(p2) (<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>, <span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)</code> </pre> <br><p>  Dans ce cas, <code>Path</code> peut prendre ces deux objets dans un constructeur et les convertir en <code>Path</code> : </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Path(p1), Path(p2) (PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>), PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>))</code> </pre> <br><p>  Cela signifie que vous pouvez reconvertir le r√©sultat de <code>make_editorconfig</code> en <code>Path</code> si n√©cessaire: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; Path(make_editorconfig(Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>))) PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span>)</code> </pre> <br><p>  Bien s√ªr, la meilleure solution serait de r√©√©crire <code>make_editorconfig</code> utilisant <code>pathlib</code> . </p><br><h3 id="pathlib-slishkom-medlennyy">  <code>pathlib</code> trop lent </h3><br><p>  J'ai vu √† plusieurs reprises les performances de <code>pathlib</code> .  C'est vrai - <code>pathlib</code> peut √™tre lent.  La cr√©ation de milliers d'objets <code>Path</code> peut affecter consid√©rablement le comportement du programme. </p><br><p>  J'ai d√©cid√© de mesurer les performances de <code>pathlib</code> et <code>os.path</code> sur mon ordinateur √† l'aide de deux programmes diff√©rents qui recherchent tous les fichiers <code>.py</code> dans le r√©pertoire actuel </p><br><p>  Voici la version d' <code>os.walk</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getcwd, walk extension = <span class="hljs-string"><span class="hljs-string">'.py'</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, directories, filenames <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> walk(getcwd()): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filenames: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> filename.endswith(extension): count += <span class="hljs-number"><span class="hljs-number">1</span></span> print(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{count}</span></span></span><span class="hljs-string"> Python files found"</span></span>)</code> </pre> <br><p>  Et voici la version avec <code>Path.rglob</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path extension = <span class="hljs-string"><span class="hljs-string">'.py'</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">f'*</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{extension}</span></span></span><span class="hljs-string">'</span></span>): count += <span class="hljs-number"><span class="hljs-number">1</span></span> print(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{count}</span></span></span><span class="hljs-string"> Python files found"</span></span>)</code> </pre> <br><p>  Tester les performances des programmes qui fonctionnent avec le syst√®me de fichiers est une t√¢che d√©licate, car la dur√©e de fonctionnement peut beaucoup changer.  J'ai d√©cid√© d'ex√©cuter chaque script 10 fois et j'ai compar√© les meilleurs r√©sultats pour chaque programme. </p><br><p>  Les deux programmes ont trouv√© 97507 fichiers dans le r√©pertoire dans lequel je les ai ex√©cut√©s.  Le premier a fonctionn√© en 1,914 secondes, le second a termin√© en 3,430 secondes. </p><br><p>  Lorsque je d√©finis le param√®tre <code>extension=''</code> , ces programmes trouvent environ 600 000 fichiers et la diff√©rence augmente.  Le premier programme a fonctionn√© en 1,888 secondes et le second en 7,485 secondes. </p><br><p>  Ainsi, <code>pathlib</code> est environ <strong>deux fois plus</strong> lent pour les fichiers avec l'extension <code>.py</code> et <strong>quatre fois plus lent</strong> lorsqu'il est lanc√© dans mon r√©pertoire personnel.  L'√©cart de performances relatif entre <code>pathlib</code> et <code>os</code> est large. </p><br><p>  Dans mon cas, cette vitesse ne change pas beaucoup.  J'ai cherch√© tous les fichiers de mon r√©pertoire et j'ai perdu 6 secondes.  Si j'avais la t√¢che de traiter 10 millions de fichiers, je le r√©√©crirais tr√®s probablement.  Mais alors qu'il n'y a pas un tel besoin, vous pouvez attendre. </p><br><p>  Si vous avez un morceau de code chaud et que <code>pathlib</code> affecte √©videmment son fonctionnement, il n'y a rien de mal √† le remplacer par une alternative.  <strong>Vous ne devez pas optimiser le code, qui n'est pas un goulot d'√©tranglement</strong> - c'est une perte de temps suppl√©mentaire, qui conduit √©galement g√©n√©ralement √† un code mal lisible, sans trop √©puiser. </p><br><h3 id="uluchshenie-chitaemosti">  Am√©lioration de la lisibilit√© </h3><br><p>  Je voudrais terminer ce flux de r√©flexions avec quelques exemples de refactoring utilisant <code>pathlib</code> .  J'ai pris quelques petits exemples de code qui fonctionne avec des fichiers et les <code>pathlib</code> fait fonctionner avec <code>pathlib</code> .  Je laisserai la plupart du code sans commentaire sur votre terrain - d√©cidez quelle version vous pr√©f√©rez. </p><br><p>  Voici la fonction <code>make_editorconfig</code> nous avons vue pr√©c√©demment: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filename."""</span></span> filename = os.path.join(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(filename): os.makedirs(dir_path, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) open(filename, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>).write(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filename</code> </pre> <br><p>  Et voici la version r√©√©crite dans <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filepath."""</span></span> path = Path(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> path.exists(): path.parent.mkdir(exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, parent=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) path.touch() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br><p>  Voici un programme de console qui prend une ligne avec un r√©pertoire et imprime le contenu d'un fichier <code>.gitignore</code> s'il existe: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys directory = sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] ignore_filename = os.path.join(directory, <span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.path.isfile(ignore_filename): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(ignore_filename, mode=<span class="hljs-string"><span class="hljs-string">'rt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ignore_file: print(ignore_file.read(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  M√™me chose avec <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys directory = Path(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]) ignore_path = directory / <span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ignore_path.is_file(): print(ignore_path.read_text(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  Voici un programme qui imprime tous les fichiers en double dans le dossier et les sous-dossiers actuels: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> defaultdict <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> md5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getcwd, walk <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_files</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filepath)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, directories, filenames <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> walk(filepath): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filenames: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> os.path.join(root, filename) file_hashes = defaultdict(list) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> find_files(getcwd()): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(path, mode=<span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> my_file: file_hash = md5(my_file.read()).hexdigest() file_hashes[file_hash].append(path) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> paths <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file_hashes.values(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(paths) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Duplicate files found:"</span></span>) print(*paths, sep=<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre> <br><p>  M√™me chose avec c <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> defaultdict <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> md5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_files</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filepath)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path(filepath).rglob(<span class="hljs-string"><span class="hljs-string">'*'</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path.is_file(): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> path file_hashes = defaultdict(list) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> find_files(Path.cwd()): file_hash = md5(path.read_bytes()).hexdigest() file_hashes[file_hash].append(path) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> paths <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file_hashes.values(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(paths) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Duplicate files found:"</span></span>) print(*paths, sep=<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre><br><p>  , , -,     .       <code>pathlib</code> . </p><br><h3 id="nachnite-ispolzovat-obekty-pathlibpath">    <code>pathlib.Path</code> </h3><br><p>  . </p><br><p>  <code>/</code>   <code>pathlib.Path</code>         .   ,    <strong>      </strong> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>path1 = Path(<span class="hljs-string"><span class="hljs-string">'dir'</span></span>, <span class="hljs-string"><span class="hljs-string">'file'</span></span>) &gt;&gt;&gt; path2 = Path(<span class="hljs-string"><span class="hljs-string">'dir'</span></span>) / <span class="hljs-string"><span class="hljs-string">'file'</span></span> &gt;&gt;&gt; path3 = Path(<span class="hljs-string"><span class="hljs-string">'dir/file'</span></span>) &gt;&gt;&gt; path3 WindowsPath(<span class="hljs-string"><span class="hljs-string">'dir/file'</span></span>) &gt;&gt;&gt; path1 == path2 == path3 <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><p>   Python  (. <code>open</code> )   <code>Path</code> ,  ,  <strong>   <code>pathlib</code> ,        !</strong> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> shutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> move <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rename_and_redirect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(old_filename, new_filename)</span></span></span><span class="hljs-function">:</span></span> move(old, new) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(old, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: f.write(<span class="hljs-string"><span class="hljs-string">f'This file has moved to </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{new}</span></span></span><span class="hljs-string">'</span></span>)</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; old, new = Path(<span class="hljs-string"><span class="hljs-string">'old.txt'</span></span>), Path(<span class="hljs-string"><span class="hljs-string">'new.txt'</span></span>) &gt;&gt;&gt; rename_and_redirect(old, new) &gt;&gt;&gt; old.read_text() <span class="hljs-string"><span class="hljs-string">'This file has moved to new.txt'</span></span></code> </pre> <br><p>      <code>pathlib</code> ,     ,    <code>PathLike</code> .  ,   <strong>      ,       ,   PEP 519</strong> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> plumbum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; my_path = Path(<span class="hljs-string"><span class="hljs-string">'old.txt'</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(my_path) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: ... print(f.read()) ... This file has moved to new.txt</code> </pre> <br><p>   <code>pathlib</code>    ,      (  ,    ),    <strong>         ,   </strong> . </p><br><p>  , <code>pathlib</code>     .       Python     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path gitignore = Path(<span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gitignore.is_file(): print(gitignore.read_text(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  <code>pathlib</code> ‚Äî .    ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453862/">https://habr.com/ru/post/fr453862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453846/index.html">Le condens√© des √©v√©nements pour les professionnels des RH dans le domaine des TI pour juin 2019</a></li>
<li><a href="../fr453848/index.html">AlphaFold: utiliser l'IA pour des d√©couvertes scientifiques</a></li>
<li><a href="../fr453850/index.html">Syst√®me de cr√©dit social chinois - le diable est-il si terrible?</a></li>
<li><a href="../fr453852/index.html">Microbiota. Comment prendre soin des bact√©ries intestinales</a></li>
<li><a href="../fr453860/index.html">AMD pr√©sente ses nouveaux processeurs 7 nm personnalis√©s Ryzen de troisi√®me g√©n√©ration</a></li>
<li><a href="../fr453864/index.html">Utiliser une souris et un clavier sur des consoles, c'est tricher?</a></li>
<li><a href="../fr453866/index.html">Demande d'API avec React Hooks, HOC ou Render Prop</a></li>
<li><a href="../fr453868/index.html">Mini interrupteur tactile avec panneau en verre sur nRF52832</a></li>
<li><a href="../fr453870/index.html">Nous √©crivons le proxy Reverse socks5 sur PowerShell. Partie 1</a></li>
<li><a href="../fr453872/index.html">Restauration de photos √† l'aide de r√©seaux de neurones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>