<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏾 🔖 🤰🏾 Pourquoi vous devriez utiliser pathlib 📭 🤦🏿 🧜🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Du traducteur: Bonjour, Habr! Je vous présente la traduction de l'article Pourquoi vous devriez utiliser pathlib et sa suite, Non vraiment, pathlib es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pourquoi vous devriez utiliser pathlib</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453862/"><p>  <em>Du traducteur: Bonjour, Habr!</em>  <em>Je vous présente la traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pourquoi vous devriez utiliser pathlib</a> et sa suite, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Non vraiment, pathlib est génial</a> .</em>  <em>Une grande attention est désormais accordée aux nouvelles fonctionnalités Python telles que asyncio, l'opérateur: = et la saisie facultative.</em>  <em>Dans le même temps, un risque non significatif (bien que: appeler une innovation sérieuse une langue ne se révèle pas une innovation sérieuse) pour un radar, mais des innovations très utiles dans une langue.</em>  <em>En particulier, sur une multitude d'articles consacrés à un sujet, je n'ai pas trouvé (sauf un paragraphe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ), j'ai donc décidé de corriger la situation.</em> </p><br><p> Quand j'ai découvert le nouveau module <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pathlib</a> il y a quelques années, j'ai décidé du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fond de</a> mon esprit que c'était juste une version orientée objet légèrement maladroite du module <code>os.path</code> .  J'avais tort.  <code>pathlib</code> est vraiment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">merveilleux</a> ! </p><br><p>  Dans cet article, je vais essayer de tomber amoureux de <code>pathlib</code> .  J'espère que cet article vous <strong><code>pathlib</code></strong> à <strong>utiliser <code>pathlib</code> dans toute situation concernant l'utilisation de fichiers en Python</strong> . </p><a name="habracut"></a><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>os.path</code> maladroit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>os</code> surchargé</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>   glob</code></a> </li> <li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>pathlib</code> rend les choses simples encore plus faciles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les objets de chemin rendent votre code plus évident</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>    pathlib</code> ?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>    pathlib</code> ?</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2. Réponses aux questions.</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code> os.path</code> être honnête, <code> os.path</code> et <code>pathlib</code></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vous n'avez pas à vous soucier de normaliser les chemins.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code> ,     ,    pathlib</code> !</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mais ma bibliothèque préférée a Path mieux que la norme!</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>  pathlib.Path</code> et <code>str</code> ne se mélangent pas, non?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>pathlib</code> trop lent</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Amélioration de la lisibilité</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>   pathlib.Path</code></a> </li> </ul></li></ul><br><h2 id="chast-1">  Partie 1 </h2><br><h3 id="ospath-neuklyuzh">  <code>os.path</code> maladroit </h3><br><p>  Le module <code>os.path</code> toujours été ce que nous <code>os.path</code> pour les chemins Python.  En principe, il y a tout ce dont vous avez besoin, mais souvent il n'a pas l'air trop élégant. </p><br><p>  Dois-je l'importer comme ça? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) TEMPLATES_DIR = os.path.join(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Ou alors? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> abspath, dirname, join BASE_DIR = dirname(dirname(abspath(__file__))) TEMPLATES_DIR = join(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Peut-être que la fonction de <code>join</code> a un nom trop général, et nous devrions faire quelque chose comme ceci: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> abspath, dirname, join <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> joinpath BASE_DIR = dirname(dirname(abspath(__file__))) TEMPLATES_DIR = joinpath(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Pour moi, toutes les options ci-dessus ne semblent pas trop pratiques.  Nous transmettons des chaînes aux fonctions qui renvoient des chaînes que nous transmettons aux fonctions suivantes qui fonctionnent avec des chaînes.  Il se trouve qu'ils contiennent tous des chemins, mais ce ne sont encore que des lignes. </p><br><p>  L'utilisation de chaînes pour l'entrée et la sortie dans les fonctions <code>os.path</code> très gênante car vous devez lire le code de l'intérieur.  Je voudrais convertir ces appels de imbriqués en séquentiels.  C'est ce que <code>pathlib</code> vous permet de faire! </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path BASE_DIR = Path(__file__).resolve().parent.parent TEMPLATES_DIR = BASE_DIR.joinpath(<span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Le module <code>os.path</code> nécessite des appels de fonction imbriqués, mais <code>pathlib</code> <strong>nous permet de créer des chaînes d'appels consécutifs aux méthodes et attributs de la classe <code>Path</code></strong> avec un résultat équivalent. </p><br><p>  Je sais ce que vous en pensez: arrêtez, ces objets <code>Path</code> ne sont plus les mêmes qu'avant, nous n'opérons plus sur les lignes de trajectoire!  Nous reviendrons sur cette question plus tard (indice: dans presque toutes les situations, ces deux approches sont interchangeables). </p><br><h3 id="os-peregruzhen">  <code>os</code> surchargé </h3><br><p>  Le module <code>os.path</code> classique <code>os.path</code> conçu pour fonctionner avec des chemins.  Mais après avoir voulu <em>faire quelque chose</em> avec le chemin (par exemple, créer un répertoire), vous devrez accéder à un autre module, souvent <code>os</code> . </p><br><p>  <code>os</code> contient un tas d'utilitaires pour travailler avec des fichiers et des répertoires: <code>mkdir</code> , <code>getcwd</code> , <code>chmod</code> , <code>stat</code> , <code>remove</code> , <code>rename</code> , <code>rmdir</code> .  Aussi <code>chdir</code> , <code>link</code> , <code>walk</code> , <code>listdir</code> , <code>makedirs</code> , <code>removedirs</code> , <code>removedirs</code> , <code>unlink</code> , <code>symlink</code> .  Et tout un tas de choses qui ne sont pas du tout liées aux systèmes de fichiers: <code>fork</code> , <code>getenv</code> , <code>putenv</code> , <code>environ</code> , <code>getlogin</code> , <code>system</code> , ... Quelques dizaines d'autres choses que je ne mentionnerai pas ici. </p><br><p>  <strong>Le module <code>os</code> est conçu pour un large éventail de tâches;</strong>  <strong>c'est une telle boîte avec tout ce qui concerne le système d'exploitation.</strong>  Il y a beaucoup d'utilités dans <code>os</code> , mais ce n'est pas toujours facile de s'y retrouver: il est souvent nécessaire de fouiller un peu dans le module avant de trouver ce dont on a besoin. </p><br><p>  <code>pathlib</code> transfère la plupart des fonctions du système de fichiers vers les objets <code>Path</code> . </p><br><p>  Voici le code qui crée le <code>src/__pypackages__</code> et renomme notre fichier <code>.editorconfig</code> en <code>src/.editorconfig</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path os.makedirs(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'__pypackages__'</span></span>), exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) os.rename(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>, os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>))</code> </pre> <br><p>  Voici un code similaire utilisant <code>Path</code> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>).mkdir(parents=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).rename(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  Notez que le deuxième exemple de code est beaucoup plus facile à lire, car il est organisé de gauche à droite - tout cela grâce aux chaînes de méthodes. </p><br><h3 id="ne-zabyvayte-pro-glob">  N'oubliez pas <code>glob</code> </h3><br><p>  Non seulement <code>os</code> et <code>os.path</code> contiennent des méthodes liées au système de fichiers.  Il convient également de mentionner le <code>glob</code> , qui ne peut pas être qualifié d'inutile. </p><br><p>  Nous pouvons utiliser la fonction <code>glob.glob</code> pour rechercher des fichiers selon un modèle spécifique: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> glob <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> glob top_level_csv_files = glob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>) all_csv_files = glob(<span class="hljs-string"><span class="hljs-string">'**/*.csv'</span></span>, recursive=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><p>  Le module <code>pathlib</code> fournit également des méthodes similaires: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path top_level_csv_files = Path.cwd().glob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>) all_csv_files = Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>)</code> </pre> <br><p>  Après le passage au module <code>pathlib</code> , le <strong>besoin du <code>glob</code> disparaît complètement</strong> : tout ce dont vous avez besoin fait déjà partie intégrante des objets <code>Path</code> </p><br><h3 id="pathlib-delaet-prostye-veschi-esche-prosche">  <code>pathlib</code> rend les choses simples encore plus faciles </h3><br><p>  <code>pathlib</code> simplifie de nombreuses situations difficiles, mais <strong>rend</strong> également <strong>certains extraits de code simples encore plus faciles</strong> . </p><br><p>  Vous voulez lire tout le texte dans un ou plusieurs fichiers? </p><br><p>  Vous pouvez ouvrir le fichier, lire le contenu et fermer le fichier à l'aide du bloc <code>with</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> glob <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> glob file_contents = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> glob(<span class="hljs-string"><span class="hljs-string">'**/*.py'</span></span>, recursive=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(filename) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> python_file: file_contents.append(python_file.read())</code> </pre> <br><p>  Ou vous pouvez utiliser la méthode <code>read_text</code> sur les objets <code>Path</code> et générer des listes pour obtenir le même résultat en une seule expression: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path file_contents = [ path.read_text() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">'*.py'</span></span>) ]</code> </pre> <br><p>  Mais que faire si vous devez écrire dans un fichier? </p><br><p>  Voici à quoi cela ressemble en utilisant <code>open</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  Ou vous pouvez utiliser la méthode <code>write_text</code> : </p><br><pre> <code class="python hljs">Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).write_text(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  Si, pour une raison quelconque, vous devez utiliser <code>open</code> , soit comme gestionnaire de contexte, soit pour vos préférences personnelles, <code>Path</code> propose la méthode <code>open</code> comme alternative: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path path = Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> path.open(mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  Ou, à partir de Python 3.6, vous pouvez passer votre <code>Path</code> directement pour <code>open</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path path = Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(path, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><h3 id="obekty-path-delayut-vash-kod-ochevidnee">  Les objets de chemin rendent votre code plus évident </h3><br><p>  Qu'indiquent les variables suivantes?  Quelle est la signification de leur signification? </p><br><pre> <code class="python hljs">person = <span class="hljs-string"><span class="hljs-string">'{"name": "Trey Hunner", "location": "San Diego"}'</span></span> pycon_2019 = <span class="hljs-string"><span class="hljs-string">"2019-05-01"</span></span> home_directory = <span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span></code> </pre> <br><p>  Chaque variable pointe vers une ligne.  Mais chacun d'eux a des significations différentes: le premier est JSON, le second est la date et le troisième est le chemin du fichier. </p><br><p>  Cette représentation d'objets est légèrement plus utile: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> date <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path person = {<span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Trey Hunner"</span></span>, <span class="hljs-string"><span class="hljs-string">"location"</span></span>: <span class="hljs-string"><span class="hljs-string">"San Diego"</span></span>} pycon_2019 = date(<span class="hljs-number"><span class="hljs-number">2019</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) home_directory = Path(<span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span>)</code> </pre> <br><p>  Les objets JSON peuvent être désérialisés dans un dictionnaire, les dates peuvent être représentées en mode natif à l'aide de <code>datetime.date</code> et <strong>les objets de chemin de fichier peuvent être représentés comme <code>Path</code></strong> </p><br><p>  L'utilisation d'objets <code>Path</code> rend votre code plus explicite.  Si vous souhaitez travailler avec des dates, vous utilisez la <code>date</code> .  Si vous souhaitez travailler avec des chemins de fichier, utilisez <code>Path</code> . </p><br><p>  Je ne suis pas un très grand partisan de la POO.  Les classes ajoutent une couche supplémentaire d'abstraction, et les abstractions ont parfois tendance à compliquer le système plutôt qu'à le simplifier.  En même temps, je pense que <code>pathlib.Path</code> est une <strong>abstraction utile</strong> .  Assez rapidement, cela devient une décision acceptée. </p><br><p>  Grâce au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PEP 519</a> , les <code>Path</code> deviennent la norme pour travailler avec les chemins.  Au moment de Python 3.6, la plupart des <code>os.path</code> <code>os</code> , <code>shutil</code> , <code>os.path</code> fonctionnent correctement avec ces objets.  <strong>Vous pouvez passer à <code>pathlib</code> , transparent pour votre base de code!</strong> </p><br><h3 id="chego-ne-hvataet-v-pathlib">  Qu'est-ce qui manque dans <code>pathlib</code> ? </h3><br><p>  Bien que <code>pathlib</code> cool, il n'est pas complet.  Il y a certainement <strong>plusieurs possibilités que j'aimerais inclure dans le module</strong> . </p><br><p>  La première chose qui me vient à l'esprit est le manque de méthodes de chemin d'accès équivalentes à <code>shutil</code> .  Bien que vous puissiez passer <code>Path</code> tant <code>shutil</code> paramètres de <code>shutil</code> pour copier / supprimer / déplacer des fichiers et des répertoires, vous ne pouvez pas les appeler en tant que méthodes sur les objets <code>Path</code> . </p><br><p>  Donc, pour copier des fichiers, vous devez faire quelque chose comme ceci: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> shutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> copyfile source = Path(<span class="hljs-string"><span class="hljs-string">'old_file.txt'</span></span>) destination = Path(<span class="hljs-string"><span class="hljs-string">'new_file.txt'</span></span>) copyfile(source, destination)</code> </pre> <br><p>  Il n'y a pas non plus d'analogue de la méthode <code>os.chdir</code> .  Cela signifie que vous devez l'importer si vous devez modifier le répertoire actuel: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chdir parent = Path(<span class="hljs-string"><span class="hljs-string">'..'</span></span>) chdir(parent)</code> </pre> <br><p>  Il n'y a pas non plus d'équivalent à la fonction <code>os.walk</code> .  Bien que vous puissiez écrire votre propre fonction dans l'esprit d'une <code>walk</code> sans trop de difficulté. </p><br><p>  J'espère qu'un jour les objets <code>pathlib.Path</code> contiendront des méthodes pour certaines des opérations mentionnées.  Mais même dans ce scénario, <strong>je trouve qu'il est beaucoup plus facile d'utiliser <code>pathlib</code> avec autre chose que d'utiliser <code>os.path</code> et tout le reste</strong> . </p><br><h3 id="vsegda-li-nuzhno-ispolzovat-pathlib">  Est-il toujours nécessaire d'utiliser <code>pathlib</code> ? </h3><br><p>  À partir de Python 3.6, les <strong>chemins fonctionnent presque partout où vous utilisez des chaînes</strong> .  Je ne vois donc aucune raison de <em>ne pas</em> utiliser <code>pathlib</code> si vous utilisez Python 3.6 et supérieur. </p><br><p>  Si vous utilisez une version antérieure de Python 3, vous pouvez à tout moment encapsuler l'objet <code>Path</code> dans un appel <code>str</code> pour obtenir une chaîne si vous devez revenir au pays des lignes.  Ce n'est pas trop élégant, mais ça marche: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chdir <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path chdir(Path(<span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">#   Python 3.6+ chdir(str(Path('/home/trey'))) #     </span></span></code> </pre> <br><h2 id="chast-2-otvety-na-voprosy">  Partie 2. Réponses aux questions. </h2><br><p>  Après la publication de la première partie, certaines personnes ont posé des questions.  Quelqu'un a dit que j'avais malhonnêtement <code>pathlib</code> <code>os.path</code> et <code>pathlib</code> .  Certains ont dit que l'utilisation d' <code>os.path</code> tellement ancrée dans la communauté Python que le passage à une nouvelle bibliothèque prendra très longtemps.  J'ai également vu quelques questions sur les performances. </p><br><p>  Dans cette partie, je voudrais commenter ces questions.  Cela peut être considéré à la fois comme <code>pathlib</code> protection <code>pathlib</code> et une sorte de lettre d'amour au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PEP 519</a> . </p><br><h3 id="sravnenie-ospath-i-pathlib-po-chestnomu">  <code>os.path</code> être honnête, comparez <code>os.path</code> et <code>pathlib</code> </h3><br><p>  Dans la dernière partie, j'ai comparé les deux fragments de code suivants: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path os.makedirs(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'__pypackages__'</span></span>), exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) os.rename(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>, os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>))</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>).mkdir(parents=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).rename(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  Cela peut sembler une comparaison injuste, car l'utilisation de <code>os.path.join</code> dans le premier exemple garantit que les délimiteurs corrects sont utilisés sur toutes les plates-formes, ce que je n'ai pas fait dans le deuxième exemple.  En fait, tout est en ordre, car <strong>Path normalise automatiquement les séparateurs de chemin</strong> </p><br><p>  Nous pouvons le prouver en regardant la conversion de l'objet <code>Path</code> en une chaîne sous Windows: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>str(Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src\\__pypackages__'</span></span></code> </pre> <br><p>  Cela ne fait aucune différence si nous utilisons la méthode <code>joinpath</code> , le <code>'/'</code> dans la ligne de chemin, l'opérateur <code>/</code> (une autre fonctionnalité intéressante de <code>Path</code> ), ou si nous transmettons des arguments individuels au constructeur Path, nous obtenons le même résultat: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>) / <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span> WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>).joinpath(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  Le dernier exemple a provoqué une certaine confusion chez les personnes qui ont suggéré que <code>pathlib</code> pas assez intelligent pour remplacer <code>/</code> par <code>\</code> dans la chaîne de chemin.  Heureusement, tout est en ordre! </p><br><p>  Avec les objets <code>Path</code> , vous n'avez plus à vous soucier de la direction des barres obliques: définissez tous vos chemins à l'aide de <code>/</code> , et le résultat sera prévisible pour n'importe quelle plate-forme. </p><br><h3 id="vy-ne-dolzhny-bespokoitsya-o-normalizacii-putey">  Vous n'avez pas à vous soucier de normaliser les chemins. </h3><br><p>  Si vous utilisez Linux ou Mac, il est très facile d'ajouter accidentellement des bogues au code qui affectent uniquement les utilisateurs de Windows.  Si vous ne surveillez pas attentivement l'utilisation de <code>os.path.join</code> et \ ou <code>os.path.normcase</code> pour convertir les barres obliques en celles adaptées à la plate-forme actuelle, <strong>vous pouvez écrire du code qui ne fonctionnera pas correctement sous Windows</strong> . </p><br><p>  Voici un exemple de bogue spécifique à Windows: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path directory = <span class="hljs-string"><span class="hljs-string">'.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] new_file = os.path.join(directory, <span class="hljs-string"><span class="hljs-string">'new_package/__init__.py'</span></span>)</code> </pre> <br><p>  De plus, un tel code fonctionnera correctement partout: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path directory = <span class="hljs-string"><span class="hljs-string">'.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] new_file = Path(directory, <span class="hljs-string"><span class="hljs-string">'new_package/__init__.py'</span></span>)</code> </pre> <br><p>  Auparavant, le programmeur était responsable de la concaténation et de la normalisation des chemins, tout comme dans Python 2, le programmeur était responsable de décider où utiliser unicode au lieu d'octets.  Ce n'est plus votre tâche - <code>Path</code> résout tous ces problèmes pour vous. </p><br><p>  Je n'utilise pas Windows et je n'ai pas d'ordinateur Windows.  Mais beaucoup de gens qui utiliseront mon code utiliseront très probablement Windows, et je veux que tout fonctionne correctement pour eux. </p><br><p>  <strong>S'il y a une chance que votre code s'exécute sur Windows, vous devriez sérieusement envisager de passer à <code>pathlib</code> .</strong> </p><br><p>  <strong>Ne vous inquiétez pas de la normalisation</strong> : utilisez quand même <code>Path</code> pour les chemins de fichiers. </p><br><h3 id="zvuchit-klassno-no-u-menya-storonnyaya-biblioteka-kotoraya-ne-ispolzuet-pathlib">  Ça a l'air cool, mais j'ai une bibliothèque tierce qui n'utilise pas <code>pathlib</code> ! </h3><br><p>  Vous disposez d'une grande base de code qui fonctionne avec des chaînes comme chemins.  Pourquoi passer à <code>pathlib</code> si cela signifie que tout doit être réécrit? </p><br><p>  Imaginons que vous ayez la fonction suivante: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filename."""</span></span> filename = os.path.join(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(filename): os.makedirs(dir_path, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) open(filename, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>).write(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filename</code> </pre> <br><p>  La fonction prend un répertoire et y crée un fichier <code>.editorconfig</code> , quelque chose comme ceci: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path &gt;&gt;&gt; make_editorconfig(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'my_package'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span></code> </pre> <br><p>  Si vous remplacez les lignes par <code>Path</code> , tout fonctionnera aussi: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; make_editorconfig(Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span></code> </pre> <br><p>  Mais ... comment? </p><br><p>  <code>os.path.join</code> accepte les objets <code>Path</code> (depuis Python 3.6).  On peut en dire <code>os.makedirs</code> des <code>os.makedirs</code> . <br>  En fait, la fonction <code>open</code> intégrée accepte <code>Path</code> , <code>shutil</code> accepte <code>Path</code> et tout dans la bibliothèque standard utilisée pour accepter les chaînes devrait maintenant fonctionner avec <code>Path</code> et les chaînes. </p><br><p>  Nous devons remercier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PEP 519 pour cela</a> , qui a fourni la classe abstraite <code>os.PathLike</code> et a annoncé que tous les utilitaires intégrés pour travailler avec les chemins de fichiers devraient maintenant fonctionner avec les chaînes et <code>Path</code> . </p><br><h3 id="no-v-moey-lyubimoy-biblioteke-est-path-luchshe-standartnogo">  Mais ma bibliothèque préférée a Path, meilleure que la norme! </h3><br><p>  Vous utilisez peut-être déjà une bibliothèque tierce qui fournit son implémentation <code>Path</code> , qui est différente de celle standard.  Peut-être que vous l'aimez plus. </p><br><p>  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">django-environ</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">path.py</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plumbum</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">visidata</a> contiennent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chacun</a> leurs propres objets <code>Path</code> .  Certaines de ces bibliothèques sont plus anciennes que <code>pathlib</code> et ont décidé d'hériter de <code>str</code> afin qu'elles puissent être passées à des fonctions qui attendent des chaînes comme chemins.  Grâce au PEP 519, l'intégration de bibliothèques tierces dans votre code sera plus facile et sans avoir besoin d'hériter de <code>str</code> . </p><br><p>  Imaginons que vous ne vouliez pas utiliser <code>pathlib</code> , car <code>Path</code> sont des objets immuables, et vous voulez vraiment vraiment changer leur état.  Avec PEP 519, vous pouvez créer votre meilleure version mutable de <code>Path</code> .  Pour ce faire, implémentez simplement la méthode <code>__fspath__</code> </p><br><p>  Toute implémentation auto-écrite de <code>Path</code> peut désormais fonctionner de manière native avec les fonctions intégrées Python qui attendent des chemins de fichier.  <strong>Même si vous n'aimez pas <code>pathlib</code> , le fait de son existence est un gros plus pour les bibliothèques tierces avec leur propre <code>Path</code></strong> </p><br><h3 id="no-ved-pathlibpath-i-str-ne-smeshivayutsya-pravda">  Mais <code>pathlib.Path</code> et <code>str</code> ne se mélangent pas, non? </h3><br><p>  Vous pensez probablement: tout cela est bien sûr génial, mais cette approche avec parfois des lignes et parfois des chemins ajoutera-t-elle de la complexité à mon code? </p><br><p>  La réponse à cette question est oui, dans une certaine mesure.  Mais ce problème a une solution de contournement assez simple. </p><br><p>  PEP 519 a ajouté quelques autres choses en plus de <code>PathLike</code> : premièrement, c'est un moyen de convertir n'importe quel <code>PathLike</code> en chaîne, et deuxièmement, c'est un moyen de transformer n'importe quel <code>PathLike</code> en <code>Path</code> . </p><br><p>  Prenons deux objets - une chaîne et <code>Path</code> (ou quoi que ce soit avec la méthode <strong>fspath</strong> ): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path p1 = os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'my_package'</span></span>) p2 = Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)</code> </pre> <br><p>  La fonction <code>os.fspath</code> normalise les deux objets et les transforme en chaînes: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> fspath &gt;&gt;&gt; fspath(p1), fspath(p2) (<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>, <span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)</code> </pre> <br><p>  Dans ce cas, <code>Path</code> peut prendre ces deux objets dans un constructeur et les convertir en <code>Path</code> : </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Path(p1), Path(p2) (PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>), PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>))</code> </pre> <br><p>  Cela signifie que vous pouvez reconvertir le résultat de <code>make_editorconfig</code> en <code>Path</code> si nécessaire: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; Path(make_editorconfig(Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>))) PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span>)</code> </pre> <br><p>  Bien sûr, la meilleure solution serait de réécrire <code>make_editorconfig</code> utilisant <code>pathlib</code> . </p><br><h3 id="pathlib-slishkom-medlennyy">  <code>pathlib</code> trop lent </h3><br><p>  J'ai vu à plusieurs reprises les performances de <code>pathlib</code> .  C'est vrai - <code>pathlib</code> peut être lent.  La création de milliers d'objets <code>Path</code> peut affecter considérablement le comportement du programme. </p><br><p>  J'ai décidé de mesurer les performances de <code>pathlib</code> et <code>os.path</code> sur mon ordinateur à l'aide de deux programmes différents qui recherchent tous les fichiers <code>.py</code> dans le répertoire actuel </p><br><p>  Voici la version d' <code>os.walk</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getcwd, walk extension = <span class="hljs-string"><span class="hljs-string">'.py'</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, directories, filenames <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> walk(getcwd()): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filenames: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> filename.endswith(extension): count += <span class="hljs-number"><span class="hljs-number">1</span></span> print(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{count}</span></span></span><span class="hljs-string"> Python files found"</span></span>)</code> </pre> <br><p>  Et voici la version avec <code>Path.rglob</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path extension = <span class="hljs-string"><span class="hljs-string">'.py'</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">f'*</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{extension}</span></span></span><span class="hljs-string">'</span></span>): count += <span class="hljs-number"><span class="hljs-number">1</span></span> print(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{count}</span></span></span><span class="hljs-string"> Python files found"</span></span>)</code> </pre> <br><p>  Tester les performances des programmes qui fonctionnent avec le système de fichiers est une tâche délicate, car la durée de fonctionnement peut beaucoup changer.  J'ai décidé d'exécuter chaque script 10 fois et j'ai comparé les meilleurs résultats pour chaque programme. </p><br><p>  Les deux programmes ont trouvé 97507 fichiers dans le répertoire dans lequel je les ai exécutés.  Le premier a fonctionné en 1,914 secondes, le second a terminé en 3,430 secondes. </p><br><p>  Lorsque je définis le paramètre <code>extension=''</code> , ces programmes trouvent environ 600 000 fichiers et la différence augmente.  Le premier programme a fonctionné en 1,888 secondes et le second en 7,485 secondes. </p><br><p>  Ainsi, <code>pathlib</code> est environ <strong>deux fois plus</strong> lent pour les fichiers avec l'extension <code>.py</code> et <strong>quatre fois plus lent</strong> lorsqu'il est lancé dans mon répertoire personnel.  L'écart de performances relatif entre <code>pathlib</code> et <code>os</code> est large. </p><br><p>  Dans mon cas, cette vitesse ne change pas beaucoup.  J'ai cherché tous les fichiers de mon répertoire et j'ai perdu 6 secondes.  Si j'avais la tâche de traiter 10 millions de fichiers, je le réécrirais très probablement.  Mais alors qu'il n'y a pas un tel besoin, vous pouvez attendre. </p><br><p>  Si vous avez un morceau de code chaud et que <code>pathlib</code> affecte évidemment son fonctionnement, il n'y a rien de mal à le remplacer par une alternative.  <strong>Vous ne devez pas optimiser le code, qui n'est pas un goulot d'étranglement</strong> - c'est une perte de temps supplémentaire, qui conduit également généralement à un code mal lisible, sans trop épuiser. </p><br><h3 id="uluchshenie-chitaemosti">  Amélioration de la lisibilité </h3><br><p>  Je voudrais terminer ce flux de réflexions avec quelques exemples de refactoring utilisant <code>pathlib</code> .  J'ai pris quelques petits exemples de code qui fonctionne avec des fichiers et les <code>pathlib</code> fait fonctionner avec <code>pathlib</code> .  Je laisserai la plupart du code sans commentaire sur votre terrain - décidez quelle version vous préférez. </p><br><p>  Voici la fonction <code>make_editorconfig</code> nous avons vue précédemment: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filename."""</span></span> filename = os.path.join(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(filename): os.makedirs(dir_path, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) open(filename, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>).write(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filename</code> </pre> <br><p>  Et voici la version réécrite dans <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filepath."""</span></span> path = Path(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> path.exists(): path.parent.mkdir(exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, parent=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) path.touch() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br><p>  Voici un programme de console qui prend une ligne avec un répertoire et imprime le contenu d'un fichier <code>.gitignore</code> s'il existe: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys directory = sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] ignore_filename = os.path.join(directory, <span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.path.isfile(ignore_filename): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(ignore_filename, mode=<span class="hljs-string"><span class="hljs-string">'rt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ignore_file: print(ignore_file.read(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  Même chose avec <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys directory = Path(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]) ignore_path = directory / <span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ignore_path.is_file(): print(ignore_path.read_text(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  Voici un programme qui imprime tous les fichiers en double dans le dossier et les sous-dossiers actuels: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> defaultdict <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> md5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getcwd, walk <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_files</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filepath)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, directories, filenames <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> walk(filepath): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filenames: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> os.path.join(root, filename) file_hashes = defaultdict(list) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> find_files(getcwd()): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(path, mode=<span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> my_file: file_hash = md5(my_file.read()).hexdigest() file_hashes[file_hash].append(path) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> paths <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file_hashes.values(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(paths) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Duplicate files found:"</span></span>) print(*paths, sep=<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre> <br><p>  Même chose avec c <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> defaultdict <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> md5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_files</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filepath)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path(filepath).rglob(<span class="hljs-string"><span class="hljs-string">'*'</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path.is_file(): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> path file_hashes = defaultdict(list) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> find_files(Path.cwd()): file_hash = md5(path.read_bytes()).hexdigest() file_hashes[file_hash].append(path) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> paths <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file_hashes.values(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(paths) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Duplicate files found:"</span></span>) print(*paths, sep=<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre><br><p>  , , -,     .       <code>pathlib</code> . </p><br><h3 id="nachnite-ispolzovat-obekty-pathlibpath">    <code>pathlib.Path</code> </h3><br><p>  . </p><br><p>  <code>/</code>   <code>pathlib.Path</code>         .   ,    <strong>      </strong> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>path1 = Path(<span class="hljs-string"><span class="hljs-string">'dir'</span></span>, <span class="hljs-string"><span class="hljs-string">'file'</span></span>) &gt;&gt;&gt; path2 = Path(<span class="hljs-string"><span class="hljs-string">'dir'</span></span>) / <span class="hljs-string"><span class="hljs-string">'file'</span></span> &gt;&gt;&gt; path3 = Path(<span class="hljs-string"><span class="hljs-string">'dir/file'</span></span>) &gt;&gt;&gt; path3 WindowsPath(<span class="hljs-string"><span class="hljs-string">'dir/file'</span></span>) &gt;&gt;&gt; path1 == path2 == path3 <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><p>   Python  (. <code>open</code> )   <code>Path</code> ,  ,  <strong>   <code>pathlib</code> ,        !</strong> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> shutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> move <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rename_and_redirect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(old_filename, new_filename)</span></span></span><span class="hljs-function">:</span></span> move(old, new) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(old, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: f.write(<span class="hljs-string"><span class="hljs-string">f'This file has moved to </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{new}</span></span></span><span class="hljs-string">'</span></span>)</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; old, new = Path(<span class="hljs-string"><span class="hljs-string">'old.txt'</span></span>), Path(<span class="hljs-string"><span class="hljs-string">'new.txt'</span></span>) &gt;&gt;&gt; rename_and_redirect(old, new) &gt;&gt;&gt; old.read_text() <span class="hljs-string"><span class="hljs-string">'This file has moved to new.txt'</span></span></code> </pre> <br><p>      <code>pathlib</code> ,     ,    <code>PathLike</code> .  ,   <strong>      ,       ,   PEP 519</strong> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> plumbum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; my_path = Path(<span class="hljs-string"><span class="hljs-string">'old.txt'</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(my_path) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: ... print(f.read()) ... This file has moved to new.txt</code> </pre> <br><p>   <code>pathlib</code>    ,      (  ,    ),    <strong>         ,   </strong> . </p><br><p>  , <code>pathlib</code>     .       Python     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path gitignore = Path(<span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gitignore.is_file(): print(gitignore.read_text(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  <code>pathlib</code> — .    ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453862/">https://habr.com/ru/post/fr453862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453846/index.html">Le condensé des événements pour les professionnels des RH dans le domaine des TI pour juin 2019</a></li>
<li><a href="../fr453848/index.html">AlphaFold: utiliser l'IA pour des découvertes scientifiques</a></li>
<li><a href="../fr453850/index.html">Système de crédit social chinois - le diable est-il si terrible?</a></li>
<li><a href="../fr453852/index.html">Microbiota. Comment prendre soin des bactéries intestinales</a></li>
<li><a href="../fr453860/index.html">AMD présente ses nouveaux processeurs 7 nm personnalisés Ryzen de troisième génération</a></li>
<li><a href="../fr453864/index.html">Utiliser une souris et un clavier sur des consoles, c'est tricher?</a></li>
<li><a href="../fr453866/index.html">Demande d'API avec React Hooks, HOC ou Render Prop</a></li>
<li><a href="../fr453868/index.html">Mini interrupteur tactile avec panneau en verre sur nRF52832</a></li>
<li><a href="../fr453870/index.html">Nous écrivons le proxy Reverse socks5 sur PowerShell. Partie 1</a></li>
<li><a href="../fr453872/index.html">Restauration de photos à l'aide de réseaux de neurones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>