<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔌 👨‍🚀 🧝 Servidor REST autodocumentado (Node.JS, TypeScript, Koa, Joi, Swagger) 🤴 🦆 👵🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ya se han escrito muchos artículos sobre las ventajas y desventajas de REST (y aún más en los comentarios que se les hacen). Y si resulta que tiene qu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Servidor REST autodocumentado (Node.JS, TypeScript, Koa, Joi, Swagger)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449906/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/tg/hh/en/tghhend0r6amxsxj0mhnr9uy3l4.jpeg"></div><br>  Ya se han escrito muchos artículos sobre las ventajas y desventajas de REST (y aún más en los comentarios que se les hacen).  Y si resulta que tiene que desarrollar un servicio en el que se debe aplicar esta arquitectura, entonces seguramente encontrará su documentación.  Después de todo, al crear cada método, ciertamente entendemos que otros programadores se referirán a estos métodos.  Por lo tanto, la documentación debe ser exhaustiva y, lo más importante, relevante. <br><br>  Bienvenido al gato, donde describiré cómo resolvimos este problema en nuestro equipo. <br><a name="habracut"></a><br>  Un poco de contexto. <br><br>  Nuestro equipo tuvo la tarea de emitir un producto back-end en <b>Node.js de</b> complejidad media en poco tiempo.  Se suponía que los programadores y movilizadores frontend interactuarían con este producto. <br><br>  Después de pensarlo un poco, decidimos intentar usar <b>TypeScript</b> como <b>YaP</b> .  <b>TSLint</b> y <b>Prettier</b> bien ajustados nos ayudaron a lograr el mismo estilo de código y una verificación estricta en la etapa de codificación / ensamblaje (y <b>ronca</b> incluso en la etapa de confirmación).  La escritura fuerte llevó a todos a describir claramente las interfaces y los tipos de todos los objetos.  Se ha vuelto fácil de leer y comprender exactamente qué toma esta función como parámetro de entrada, qué devolverá eventualmente y cuáles de las propiedades del objeto son obligatorias y cuáles no.  El código comenzó a parecerse a Java más o menos).  Y, por supuesto, <b>TypeDoc</b> agregó legibilidad a cada función. <br><br>  Así es como comenzó a verse el código: <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Interface of all responses */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IResponseData</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ nonce: number; code: number; message?: string; data?: T; } <span class="hljs-comment"><span class="hljs-comment">/** * Utils helper */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransferObjectUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Compose all data to result response package * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> responseCode - 200 | 400 | 500 * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> message - any info text message * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> data - response data object * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> ready object for REST response */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> createResponseObject&lt;T = object&gt;(responseCode: number, message: string, data: T): IResponseData&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result: IResponseData&lt;T&gt; = { code: responseCode || <span class="hljs-number"><span class="hljs-number">200</span></span>, nonce: Date.now() }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message) { result.message = message; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data) { result.data = data; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre> <br>  Pensamos en los descendientes, no será difícil mantener nuestro código, es hora de pensar en los usuarios de nuestro servidor REST. <br><br>  Como todo se hizo con bastante rapidez, entendimos que escribir código por separado y documentación por separado sería muy difícil.  Especialmente agregue parámetros adicionales a las respuestas o solicitudes de acuerdo con los requisitos de front-end o mobilchiki y no olvide advertir a otros sobre esto.  Aquí es donde apareció un requisito claro: el <b>código con la documentación siempre debe estar sincronizado</b> .  Esto significaba que el factor humano debería ser excluido y la documentación debería influir en el código, y el código debería afectar la documentación. <br><br>  Aquí profundicé en la búsqueda de herramientas adecuadas para esto.  Afortunadamente, el repositorio de NPM es solo un almacén de todo tipo de ideas y soluciones. <br><br>  Los requisitos para la herramienta fueron los siguientes: <br><br><ul><li>  Documentación de sincronización con el código; </li><li>  Soporte de TypeScript; </li><li>  Validación de paquetes entrantes / salientes; </li><li>  Paquete en vivo y compatible. </li></ul><br>  Tuve que escribir en un servicio REST usando muchos paquetes diferentes, los más populares son: tsoa, ​​swagger-node-express, express-openapi, swagger-codegen. <br><br><img src="https://habrastorage.org/webt/fs/dl/7m/fsdl7mmvvi8c64rgqoks-9loh_i.png"><br><br>  Pero en algunos no había soporte para TypeScript, en algunos de validación de paquetes, y algunos pudieron generar código basado en la documentación, pero no proporcionaron sincronización adicional. <br><br>  Aquí es donde me encontré con joi-to-swagger.  Un gran paquete que puede convertir lo descrito en el esquema Joi en documentación más elegante e incluso con soporte TypeScript.  Todos los elementos se ejecutan, excepto la sincronización.  Apresurándome por algún tiempo, encontré un depósito abandonado de un chino que usaba el <b>joi-to-swagger</b> junto con el marco Koa.  Como no había prejuicios contra Koa en nuestro equipo y no había razones para seguir ciegamente la tendencia Express, decidimos intentar despegar en esta pila. <br><br>  Bifurqué este repositorio, solucioné errores, completé algunas cosas y ahora se lanzó mi primera contribución a OpenSource Koa-Joi-Swagger-TS.  Pasamos con éxito ese proyecto y después ya había varios otros.  Se ha vuelto muy conveniente escribir y mantener servicios REST, y los usuarios de estos servicios no necesitan nada más que un enlace a la documentación en línea de Swagger.  Después de ellos, quedó claro dónde se puede desarrollar este paquete y ha experimentado varias mejoras más. <br><br>  Ahora veamos cómo usar <b>Koa-Joi-Swagger-TS</b> puede escribir un servidor REST autodocumentado.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Publiqué el código terminado aquí</a> . <br><br>  Como este proyecto es una demostración, simplifiqué y fusioné varios archivos en uno.  En general, es bueno si el índice inicializa la aplicación y llama al archivo app.ts, que a su vez leerá recursos, llamadas para conectarse a la base de datos, etc.  El servidor debe comenzar con el último comando (justo lo que se describirá a continuación). <br><br>  Entonces, para empezar, crea <b>index.ts</b> con este contenido: <br><br><div class="spoiler">  <b class="spoiler_title">index.ts</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Koa <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BaseContext } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> bodyParser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-bodyparser"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Router <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-router"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SERVER_PORT = <span class="hljs-number"><span class="hljs-number">3002</span></span>; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Koa(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); app.use(bodyParser()); router.get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, (ctx: BaseContext, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Root loaded!"</span></span>) }); app .use(router.routes()) .use(router.allowedMethods()); app.listen(SERVER_PORT); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Server listening on http://localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${SERVER_PORT}</span></span></span><span class="hljs-string"> ...`</span></span>); })();</code> </pre><br><br></div></div><br>  Cuando inicie este servicio, se generará un servidor REST, que hasta ahora no sabe cómo.  Ahora un poco sobre la arquitectura del proyecto.  Desde que cambié a Node.JS desde Java, intenté construir un servicio con las mismas capas aquí. <br><br><ul><li>  Controladores </li><li>  Servicios </li><li>  Repositorios </li></ul><br>  Comencemos a conectar <b>Koa-Joi-Swagger-TS</b> .  Instalarlo naturalmente. <br><br><pre> <code class="bash hljs">npm install koa-joi-swagger-ts --save</code> </pre> <br>  Cree la carpeta <b>"controladores"</b> y la carpeta <b>"esquemas"</b> en ella.  En la carpeta de controladores, cree nuestro primer controlador <b>base.controller.ts</b> : <br><br><div class="spoiler">  <b class="spoiler_title">base.controller.ts</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BaseContext } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { controller, description, get, response, summary, tag } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-joi-swagger-ts"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ApiInfoResponseSchema } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./schemas/apiInfo.response.schema"</span></span>; @controller(<span class="hljs-string"><span class="hljs-string">"/api/v1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> abstract <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseController</span></span></span><span class="hljs-class"> </span></span>{ @get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: ApiInfoResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Returns text info about version of API"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Show API index page"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> index(ctx: BaseContext, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"GET /api/v1/"</span></span>); ctx.status = <span class="hljs-number"><span class="hljs-number">200</span></span>; ctx.body = { <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">appVersion</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">build</span></span>: <span class="hljs-string"><span class="hljs-string">"1001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">reqHeaders</span></span>: ctx.request.headers, <span class="hljs-attr"><span class="hljs-attr">apiDoc</span></span>: <span class="hljs-string"><span class="hljs-string">"/api/v1/swagger.json"</span></span> } } }; }</code> </pre><br></div></div><br>  Como puede ver en los decoradores (anotaciones en Java), esta clase estará asociada con la ruta "/ api / v1", todos los métodos en el interior serán relativos a esta ruta. <br><br>  Este método tiene una descripción del formato de respuesta, que se describe en el archivo "./schemas/apiInfo.response.schema": <br><br><div class="spoiler">  <b class="spoiler_title">apiInfo.response.schema</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Joi <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"joi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { definition } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-joi-swagger-ts"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BaseAPIResponseSchema } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./baseAPI.response.schema"</span></span>; @definition(<span class="hljs-string"><span class="hljs-string">"ApiInfo"</span></span>, <span class="hljs-string"><span class="hljs-string">"Information data about current application and API version"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiInfoResponseSchema</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseAPIResponseSchema</span></span></span><span class="hljs-class"> </span></span>{ public data = Joi.object({ <span class="hljs-attr"><span class="hljs-attr">appVersion</span></span>: Joi.string() .description(<span class="hljs-string"><span class="hljs-string">"Current version of application"</span></span>) .required(), <span class="hljs-attr"><span class="hljs-attr">build</span></span>: Joi.string().description(<span class="hljs-string"><span class="hljs-string">"Current build version of application"</span></span>), <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: Joi.number() .positive() .description(<span class="hljs-string"><span class="hljs-string">"Version of current REST api"</span></span>) .required(), <span class="hljs-attr"><span class="hljs-attr">reqHeaders</span></span>: Joi.object().description(<span class="hljs-string"><span class="hljs-string">"Request headers"</span></span>), <span class="hljs-attr"><span class="hljs-attr">apiDoc</span></span>: Joi.string() .description(<span class="hljs-string"><span class="hljs-string">"URL path to swagger document"</span></span>) .required() }).required(); }</code> </pre><br></div></div><br>  Las posibilidades de tal descripción del esquema en Joi son muy amplias y se describen con más detalle aquí: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.npmjs.com/package/joi-to-swagger</a> <br><br>  Y aquí está el antepasado de la clase descrita (en realidad esta es la clase base para todas las respuestas de nuestro servicio): <br><br><div class="spoiler">  <b class="spoiler_title">baseAPI.response.schema</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Joi <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"joi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { definition } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-joi-swagger-ts"</span></span>; @definition(<span class="hljs-string"><span class="hljs-string">"BaseAPIResponse"</span></span>, <span class="hljs-string"><span class="hljs-string">"Base response entity with base fields"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseAPIResponseSchema</span></span></span><span class="hljs-class"> </span></span>{ public code = Joi.number() .required() .strict() .only(<span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>) .example(<span class="hljs-number"><span class="hljs-number">200</span></span>) .description(<span class="hljs-string"><span class="hljs-string">"Code of operation result"</span></span>); public message = Joi.string().description(<span class="hljs-string"><span class="hljs-string">"message will be filled in some causes"</span></span>); }</code> </pre><br></div></div><br>  Ahora registre estos circuitos y controladores en el sistema Koa-Joi-Swagger-TS. <br>  Junto a index.ts, cree otro archivo <b>routing.ts</b> : <br><br><div class="spoiler">  <b class="spoiler_title">routing.ts</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { KJSRouter } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-joi-swagger-ts"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BaseController } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./controllers/base.controller"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BaseAPIResponseSchema } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./controllers/schemas/baseAPI.response.schema"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ApiInfoResponseSchema } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./controllers/schemas/apiInfo.response.schema"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SERVER_PORT = <span class="hljs-number"><span class="hljs-number">3002</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loadRoutes = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KJSRouter({ <span class="hljs-attr"><span class="hljs-attr">swagger</span></span>: <span class="hljs-string"><span class="hljs-string">"2.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">info</span></span>: { <span class="hljs-attr"><span class="hljs-attr">version</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">"simple-rest"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">host</span></span>: <span class="hljs-string"><span class="hljs-string">`localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${SERVER_PORT}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">basePath</span></span>: <span class="hljs-string"><span class="hljs-string">"/api/v1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">schemes</span></span>: [<span class="hljs-string"><span class="hljs-string">"http"</span></span>], <span class="hljs-attr"><span class="hljs-attr">paths</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">definitions</span></span>: {} }); router.loadDefinition(ApiInfoResponseSchema); router.loadDefinition(BaseAPIResponseSchema); router.loadController(BaseController); router.setSwaggerFile(<span class="hljs-string"><span class="hljs-string">"swagger.json"</span></span>); router.loadSwaggerUI(<span class="hljs-string"><span class="hljs-string">"/api/docs"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> router.getRouter(); };</code> </pre><br></div></div><br>  Aquí creamos una instancia de la clase KJSRouter, que esencialmente es un enrutador Koa, pero con middlewares y controladores añadidos. <br><br>  Por lo tanto, en el archivo <b>index.ts</b> , simplemente cambiamos <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router();</code> </pre> <br>  en <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = loadRoutes();</code> </pre> <br>  Bueno, elimine el controlador innecesario: <br><br><div class="spoiler">  <b class="spoiler_title">index.ts</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Koa <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> bodyParser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-bodyparser"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { loadRoutes } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./routing"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SERVER_PORT = <span class="hljs-number"><span class="hljs-number">3002</span></span>; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Koa(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = loadRoutes(); app.use(bodyParser()); app .use(router.routes()) .use(router.allowedMethods()); app.listen(SERVER_PORT); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Server listening on http://localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${SERVER_PORT}</span></span></span><span class="hljs-string"> ...`</span></span>); })();</code> </pre><br></div></div><br>  Cuando inicia este servicio, tenemos 3 rutas disponibles: <br>  <b>1. / api / v1</b> - ruta documentada <br>  Que en mi caso se muestra: <br><br><div class="spoiler">  <b class="spoiler_title">http: // localhost: 3002 / api / v1</b> <div class="spoiler_text"><pre> <code class="json hljs">{ code: <span class="hljs-number"><span class="hljs-number">200</span></span>, data: { appVersion: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, build: <span class="hljs-string"><span class="hljs-string">"1001"</span></span>, apiVersion: <span class="hljs-number"><span class="hljs-number">1</span></span>, reqHeaders: { host: <span class="hljs-string"><span class="hljs-string">"localhost:3002"</span></span>, connection: <span class="hljs-string"><span class="hljs-string">"keep-alive"</span></span>, cache-control: <span class="hljs-string"><span class="hljs-string">"max-age=0"</span></span>, upgrade-insecure-requests: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, user-agent: <span class="hljs-string"><span class="hljs-string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36"</span></span>, accept: <span class="hljs-string"><span class="hljs-string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3"</span></span>, accept-encoding: <span class="hljs-string"><span class="hljs-string">"gzip, deflate, br"</span></span>, accept-language: <span class="hljs-string"><span class="hljs-string">"uk-UA,uk;q=0.9,ru;q=0.8,en-US;q=0.7,en;q=0.6"</span></span> }, apiDoc: <span class="hljs-string"><span class="hljs-string">"/api/v1/swagger.json"</span></span> } }</code> </pre><br></div></div><br>  Y dos rutas de servicio: <br><br>  <b>2. /api/v1/swagger.json</b> <br><br><div class="spoiler">  <b class="spoiler_title">swagger.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ swagger: <span class="hljs-string"><span class="hljs-string">"2.0"</span></span>, info: { version: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, title: <span class="hljs-string"><span class="hljs-string">"simple-rest"</span></span> }, host: <span class="hljs-string"><span class="hljs-string">"localhost:3002"</span></span>, basePath: <span class="hljs-string"><span class="hljs-string">"/api/v1"</span></span>, schemes: [ <span class="hljs-string"><span class="hljs-string">"http"</span></span> ], paths: { /: { get: { tags: [ <span class="hljs-string"><span class="hljs-string">"GET"</span></span> ], summary: <span class="hljs-string"><span class="hljs-string">"Show API index page"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Returns text info about version of API"</span></span>, consumes: [ <span class="hljs-string"><span class="hljs-string">"application/json"</span></span> ], produces: [ <span class="hljs-string"><span class="hljs-string">"application/json"</span></span> ], responses: { 200: { description: <span class="hljs-string"><span class="hljs-string">"Information data about current application and API version"</span></span>, schema: { type: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/ApiInfo"</span></span> } } }, security: [ ] } } }, definitions: { BaseAPIResponse: { type: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, required: [ <span class="hljs-string"><span class="hljs-string">"code"</span></span> ], properties: { code: { type: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, format: <span class="hljs-string"><span class="hljs-string">"float"</span></span>, enum: [ <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span> ], description: <span class="hljs-string"><span class="hljs-string">"Code of operation result"</span></span>, example: { value: <span class="hljs-number"><span class="hljs-number">200</span></span> } }, message: { type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"message will be filled in some causes"</span></span> } } }, ApiInfo: { type: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, required: [ <span class="hljs-string"><span class="hljs-string">"code"</span></span>, <span class="hljs-string"><span class="hljs-string">"data"</span></span> ], properties: { code: { type: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, format: <span class="hljs-string"><span class="hljs-string">"float"</span></span>, enum: [ <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span> ], description: <span class="hljs-string"><span class="hljs-string">"Code of operation result"</span></span>, example: { value: <span class="hljs-number"><span class="hljs-number">200</span></span> } }, message: { type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"message will be filled in some causes"</span></span> }, data: { type: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, required: [ <span class="hljs-string"><span class="hljs-string">"appVersion"</span></span>, <span class="hljs-string"><span class="hljs-string">"apiVersion"</span></span>, <span class="hljs-string"><span class="hljs-string">"apiDoc"</span></span> ], properties: { appVersion: { type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Current version of application"</span></span> }, build: { type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Current build version of application"</span></span> }, apiVersion: { type: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, format: <span class="hljs-string"><span class="hljs-string">"float"</span></span>, minimum: <span class="hljs-number"><span class="hljs-number">1</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Version of current REST api"</span></span> }, reqHeaders: { type: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, properties: { }, description: <span class="hljs-string"><span class="hljs-string">"Request headers"</span></span> }, apiDoc: { type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"URL path to swagger document"</span></span> } } } } } } }</code> </pre><br></div></div><br>  <b>3. / api / docs</b> <br><br>  Esta es la página con la interfaz de usuario de Swagger: esta es una representación visual muy conveniente del esquema Swagger, en la que, además de ser conveniente de ver, incluso puede generar solicitudes y obtener respuestas reales del servidor. <br><br><img src="https://habrastorage.org/webt/go/zc/fg/gozcfgxxsvy_qu_us6jbpgutxdo.png"><br><br>  Esta interfaz de usuario requiere acceso al archivo swagger.json, por lo que se incluyó la ruta anterior. <br><br>  Bueno, todo parece estar ahí y todo funciona, pero ... <br><br>  Con el tiempo, encerramos en un círculo que en tal implementación, tenemos mucha duplicación de código.  En el caso en que los controladores necesitan hacer lo mismo.  Fue por esto que más tarde finalicé el paquete y agregué la capacidad de describir el "contenedor" para los controladores. <br><br>  Considere un ejemplo de tal servicio. <br><br>  Supongamos que tenemos un controlador de "Usuarios" con varios métodos. <br><br><div class="spoiler">  <b class="spoiler_title">Consigue todos los usuarios</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> @get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: UsersResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">400</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">500</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Returns list of all users"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Get all users"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getAllUsers(ctx: BaseContext): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"GET /api/v1/users"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = <span class="hljs-string"><span class="hljs-string">"Get all users error"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> code = <span class="hljs-number"><span class="hljs-number">400</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getAllUsers(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult) { data = serviceResult; code = <span class="hljs-number"><span class="hljs-number">200</span></span>; message = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Error while getting users list"</span></span>); code = <span class="hljs-number"><span class="hljs-number">500</span></span>; } ctx.status = code; ctx.body = TransferObjectUtils.createResponseObject(code, message, data); };</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Actualizar usuario</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> @post(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @parameter(<span class="hljs-string"><span class="hljs-string">"body"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: UsersRequestSchema }, ENUM_PARAM_IN.body) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">400</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">500</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Update user data"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Update user data"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> updateUser(ctx: BaseContext): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"POST /api/v1/users"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = <span class="hljs-string"><span class="hljs-string">"Update user data error"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> code = <span class="hljs-number"><span class="hljs-number">400</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> updateUser(ctx.request.body.data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult) { code = <span class="hljs-number"><span class="hljs-number">200</span></span>; message = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Error while updating user"</span></span>); code = <span class="hljs-number"><span class="hljs-number">500</span></span>; } ctx.status = code; ctx.body = TransferObjectUtils.createResponseObject(code, message, data); };</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Insertar usuario</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> @put(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @parameter(<span class="hljs-string"><span class="hljs-string">"body"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: UsersRequestSchema }, ENUM_PARAM_IN.body) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">400</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">500</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Insert new user"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Insert new user"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> insertUser(ctx: BaseContext): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"PUT /api/v1/users"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = <span class="hljs-string"><span class="hljs-string">"Insert new user error"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> code = <span class="hljs-number"><span class="hljs-number">400</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> insertUser(ctx.request.body.data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult) { code = <span class="hljs-number"><span class="hljs-number">200</span></span>; message = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Error while inserting user"</span></span>); code = <span class="hljs-number"><span class="hljs-number">500</span></span>; } ctx.status = code; ctx.body = TransferObjectUtils.createResponseObject(code, message, data); };</code> </pre><br></div></div><br>  Como puede ver, los tres métodos de controlador contienen código duplicado.  Es para tales casos que ahora usamos esta oportunidad. <br><br>  Primero, cree una función de contenedor, por ejemplo, directamente en el archivo <b>routing.ts</b> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> controllerDecorator = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (controller: <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>, <span class="hljs-attr"><span class="hljs-attr">ctx</span></span>: BaseContext, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>, <span class="hljs-attr"><span class="hljs-attr">summary</span></span>: string): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ctx.request.method}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ctx.request.url}</span></span></span><span class="hljs-string">`</span></span>); ctx.body = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; ctx.status = <span class="hljs-number"><span class="hljs-number">400</span></span>; ctx.statusMessage = <span class="hljs-string"><span class="hljs-string">`Error while executing '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${summary}</span></span></span><span class="hljs-string">'`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> controller(ctx); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e, <span class="hljs-string"><span class="hljs-string">`Error while executing '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${summary}</span></span></span><span class="hljs-string">'`</span></span>); ctx.status = <span class="hljs-number"><span class="hljs-number">500</span></span>; } ctx.body = TransferObjectUtils.createResponseObject(ctx.status, ctx.statusMessage, ctx.body); };</code> </pre><br>  Luego conéctelo a nuestro controlador. <br><br>  Reemplazar <br><br><pre> <code class="javascript hljs">router.loadController(UserController);</code> </pre> <br>  en <br><br><pre> <code class="javascript hljs">router.loadController(UserController, controllerDecorator);</code> </pre> <br>  Bueno, simplifiquemos nuestros métodos de controlador <br><br><div class="spoiler">  <b class="spoiler_title">Controlador de usuario</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> @get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: UsersResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">400</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">500</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Returns list of all users"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Get all users"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getAllUsers(ctx: BaseContext): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getAllUsers(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult) { ctx.body = serviceResult; ctx.status = <span class="hljs-number"><span class="hljs-number">200</span></span>; ctx.statusMessage = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }; @post(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @parameter(<span class="hljs-string"><span class="hljs-string">"body"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: UsersRequestSchema }, ENUM_PARAM_IN.body) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">400</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">500</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Update user data"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Update user data"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> updateUser(ctx: BaseContext): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> updateUser(ctx.request.body.data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult) { ctx.status = <span class="hljs-number"><span class="hljs-number">200</span></span>; ctx.statusMessage = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }; @put(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @parameter(<span class="hljs-string"><span class="hljs-string">"body"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: UsersRequestSchema }, ENUM_PARAM_IN.body) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">400</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">500</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Insert new user"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Insert new user"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> insertUser(ctx: BaseContext): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> insertUser(ctx.request.body.data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult) { ctx.status = <span class="hljs-number"><span class="hljs-number">200</span></span>; ctx.statusMessage = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } };</code> </pre><br></div></div><br>  En este <b>controladorDecorator,</b> puede agregar cualquier lógica de comprobaciones o registros detallados de entradas / salidas. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Publiqué el código terminado aquí</a> . <br><br>  Ahora tenemos casi CRUDO listo.  Eliminar se puede escribir por analogía.  De hecho, ahora para escribir un nuevo controlador, debemos: <br><br><ol><li>  Crear archivo controlador </li><li>  Agréguelo a routing.ts </li><li>  Describir los métodos. </li><li>  En cada método, use circuitos de entrada / salida </li><li>  Describa estos esquemas. </li><li>  Conecte estos esquemas en routing.ts </li></ol><br>  Si el paquete entrante no coincide con el esquema, el usuario de nuestro servicio REST recibirá un error 400 con una descripción de lo que está exactamente mal.  Si el paquete saliente no es válido, se generará un error 500. <br><br>  Bueno y quieto como una bagatela agradable.  En Swagger UI, puede usar la funcionalidad " <b>Pruébelo</b> " en cualquier método.  Se generará una solicitud a través de curl a su servicio en ejecución y, por supuesto, puede ver el resultado de inmediato.  Y solo por esto es muy conveniente describir el parámetro " <b>ejemplo</b> " en el circuito.  Porque la solicitud se generará de inmediato con un paquete listo basado en los ejemplos descritos. <br><br><img src="https://habrastorage.org/webt/gk/iq/hi/gkiqhirxja87xqofboi5oo9af1w.png"><br><br><h4>  <b>Conclusiones</b> </h4><br>  Muy conveniente y útil al final, la cosa resultó.  Al principio, no querían validar los paquetes salientes, pero luego, con la ayuda de esta validación, detectaron varios errores importantes de su parte.  Por supuesto, no puede usar todas las funciones de Joi (ya que estamos limitados por joi-to-swagger), pero sí las que son suficientes. <br><br>  Ahora la documentación siempre está en línea y siempre corresponde estrictamente al código, y esto es lo principal. <br>  ¿Qué otras ideas hay? <br><br>  ¿Es posible agregar soporte express? <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Acabo de leerlo</a> . <br><br>  Sería genial describir entidades una vez en un solo lugar.  Porque ahora es necesario editar tanto los circuitos como las interfaces. <br><br>  Quizás tengas algunas ideas interesantes.  Mejor aún Solicitudes de extracción :) <br>  Bienvenido a contribuyentes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/449906/">https://habr.com/ru/post/449906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../449890/index.html">¿Cómo son las secciones algorítmicas en las entrevistas en Yandex?</a></li>
<li><a href="../449896/index.html">Cómo pastar gatos, o consejos para un joven programador</a></li>
<li><a href="../449898/index.html">Noticias de adentro hacia afuera</a></li>
<li><a href="../449902/index.html">Redes de TV por cable para los más pequeños. Parte 2: composición y forma de onda</a></li>
<li><a href="../449904/index.html">Creación de una dll proxy para las verificaciones de operación de secuestro de dll</a></li>
<li><a href="../449908/index.html">DDR3 o DDR4? ¿Por qué ofrecemos el Dell R420 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps por $ 99 en los Países Bajos?</a></li>
<li><a href="../449910/index.html">GitLab Shell Runner. Lanzamiento competitivo de servicios de prueba usando Docker Compose</a></li>
<li><a href="../449916/index.html">5 formas de implementar código PHP en condiciones de alta carga</a></li>
<li><a href="../449918/index.html">Termómetro infrarrojo con sensor MLX90614</a></li>
<li><a href="../449920/index.html">10 formas no estándar de dañar el SEO al cambiar de CMS (bonificación de +1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>