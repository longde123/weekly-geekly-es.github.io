<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏾 🌻 🐽 通过图片学习多线程Go编程 💨 🙆 👐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您很可能已经听说过Go编程语言，其流行程度正在不断提高，这是很合理的。 这种语言简单，快速，并且依赖于强大的社区。 该语言最令人好奇的方面之一是多线程编程模型。 它的基础原语使您可以轻松，简单地创建多线程程序。 本文适用于想要学习这些原语的人：goroutines和channel。 并且，通过插图，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>通过图片学习多线程Go编程</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412715/"><img src="https://habrastorage.org/webt/qk/hi/im/qkhiimd_phctfhx4kka_rhpkepq.png"><br> 您很可能已经听说过Go编程语言，其流行程度正在不断提高，这是很合理的。 这种语言简单，快速，并且依赖于强大的社区。 该语言最令人好奇的方面之一是多线程编程模型。 它的基础原语使您可以轻松，简单地创建多线程程序。 本文适用于想要学习这些原语的人：goroutines和channel。 并且，通过插图，我将展示如何使用它们。 希望这对您的进一步学习有很好的帮助。 <br><a name="habracut"></a><br><h4> 单线程和多线程程序 </h4><br> 您很可能已经编写了单线程程序。 通常看起来像这样：有一组用于执行各种任务的函数，仅当上一个函数准备好数据时才调用每个函数。 因此，程序顺序运行。 <br><br> 那将是我们的第一个例子-矿石开采计划。 我们的职能将寻找，开采和加工矿石。 在我们的示例中，矿山中的矿石由字符串列表表示，函数将其用作参数并返回“已处理”字符串列表。 对于单线程程序，我们的应用程序将设计如下： <br><br><img src="https://habrastorage.org/webt/c5/ua/ja/c5uajayyncivzzj9_orh-u_sw34.png"><br><br> 在此示例中，所有工作均由一个线程（Gary的地鼠）完成。 三个主要功能：搜索，生产和处理依次执行。 <br><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} foundOre := finder(theMine) minedOre := miner(foundOre) smelter(minedOre) }</code> </pre> <br> 如果我们打印每个函数的结果，则会得到以下结果： <br><br><pre> <code class="hljs powershell">From Finder: [<span class="hljs-type"><span class="hljs-type">ore</span></span> <span class="hljs-type"><span class="hljs-type">ore</span></span> <span class="hljs-type"><span class="hljs-type">ore</span></span>] From Miner: [<span class="hljs-type"><span class="hljs-type">minedOre</span></span> <span class="hljs-type"><span class="hljs-type">minedOre</span></span> <span class="hljs-type"><span class="hljs-type">minedOre</span></span>] From Smelter: [<span class="hljs-type"><span class="hljs-type">smeltedOre</span></span> <span class="hljs-type"><span class="hljs-type">smeltedOre</span></span> <span class="hljs-type"><span class="hljs-type">smeltedOre</span></span>]</code> </pre><br> 简单的设计和实现是单线程方法的优点。 但是，如果您想彼此独立地运行和执行功能，该怎么办？ 在这里，多线程编程将为您提供帮助。 <br><br><img src="https://habrastorage.org/webt/om/x1/mq/omx1mqphfsqqs57lab9bngsnggi.png"><br> 这种矿石开采方法效率更高。 现在，几个线程（地鼠）可以独立工作，而Gary只做一部分工作。 一个地鼠搜索矿石，另一个地鼠搜索矿石，第三次熔融，所有这些可能是同时发生的。 为了实现这种方法，我们在代码中需要做两件事：创建彼此独立的地鼠处理器，并在它们之间转移矿石。  Go具有为此的goroutines和渠道。 <br><br><h4> 古鲁丁 </h4><br>  Goroutines可以被认为是“轻量级线程”，要创建goroutines，只需将<b>go</b>关键字放在函数调用代码之前。 为了演示它的简单性，让我们创建两个搜索功能，使用<b>go</b>关键字调用它们，并在他们每次在矿山中发现“矿石”时打印一条消息。 <br><img src="https://habrastorage.org/webt/jz/wx/nb/jzwxnbgxocr-a0rq7kmdoujt_gg.png"><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> finder1(theMine) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> finder2(theMine) &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">//       }</span></span></code> </pre><br> 我们程序的输出如下： <br><br><pre> <code class="hljs pgsql">Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore!</code> </pre><br> 如您所见，函数首先“查找矿石”没有顺序； 搜索功能同时工作。 如果您多次运行该示例，则顺序将有所不同。 现在我们可以运行多线程（多领域）程序，这是一个重要的进步。 但是，当我们需要在独立的goroutine之间建立连接时该怎么办？ 渠道神奇的时刻到了。 <br><br><h4> 频道 </h4><br><img src="https://habrastorage.org/webt/pa/a-/5r/paa-5r_dtecx3fzem9r0dsv42jo.png"><br> 通道允许goroutines交换数据。 这是一种管道，goroutin可以通过该管道从其他goroutine发送和接收信息。 <br><img src="https://habrastorage.org/webt/-d/vp/fz/-dvpfzbpaa65exwi7l4pgerte48.png"><br> 使用箭头运算符（&lt;-）进行通道的读取和写入，该操作符指示数据移动的方向。 <br><img src="https://habrastorage.org/webt/wd/1j/qp/wd1jqp8ipkwvcdgc5xbuoyy6wey.png"><br><pre> <code class="go hljs">myFirstChannel := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) myFirstChannel &lt;- <span class="hljs-string"><span class="hljs-string">"hello"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    myVariable := &lt;- myFirstChannel //   </span></span></code> </pre><br> 现在我们的地鼠侦察兵不需要积累矿石，他可以立即使用渠道将其进一步转移。 <br><img src="https://habrastorage.org/webt/60/yx/_j/60yx_jlczbwcy2tfmsqgvzwp4dg.png"><br> 我更新了示例，现在找矿者和矿工的代码是匿名函数。 如果您以前从未遇到过它们，请不要太在意，只需记住，它们每个都使用关键字<b>go</b>调用，因此，它将在自己的goroutine中执行。 这里最重要的是，goroutines使用<b>oreChan</b>通道在它们之间传输数据。 我们将在最后处理匿名函数。 <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{“ore1”, “ore2”, “ore3”} oreChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   go func(mine [5]string) { for _, item := range mine { oreChan &lt;- item // } }(theMine) //   go func() { for i := 0; i &lt; 3; i++ { foundOre := &lt;-oreChan // fmt.Println(“Miner: Received “ + foundOre + “ from finder”) } }() &lt;-time.After(time.Second * 5) //     }</span></span></code> </pre><br> 以下结论清楚地表明，我们的矿工一次从通道矿石中获得了三份一份。 <br><br><pre> <code class="hljs cs">Miner: Received ore1 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder Miner: Received ore2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder Miner: Received ore3 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder</code> </pre><br> 因此，现在我们可以在不同的goroutines（密码器）之间传输数据，但是在开始编写复杂程序之前，让我们看一下通道的一些重要属性。 <br><br><h4> 锁具 </h4><br> 在某些情况下，使用通道时，goroutin可能会被阻塞。 这是必需的，以便goroutine在开始或继续工作之前可以彼此同步。 <br><br><h4> 写锁 </h4><br><img src="https://habrastorage.org/webt/ir/vv/zi/irvvziqxuk3opysywirescrn40e.png"><br><br> 当goroutine（gopher）将数据发送到通道时，它将被阻塞，直到另一个goroutine从该通道读取数据为止。 <br><br><h4> 读锁 </h4><br><img src="https://habrastorage.org/webt/eq/e5/k8/eqe5k854n39oia6xwaavj5xfk-q.png"><br><br> 类似于在写入通道时锁定，从通道读取时，goroutin可以被锁定，直到没有内容写入为止。 <br> 如果乍一看这些锁对您来说似乎很复杂，您可以将其想象为两个goroutine（密码）之间的“金钱转移”。 当一位地鼠想要转账或收款时，他必须等待交易的第二位参与者。 <br><br> 处理了通道上的goroutine锁之后，让我们讨论两种不同类型的通道：缓冲通道和非缓冲通道。 选择这种或那种类型，我们在很大程度上决定了程序的行为。 <br><br><h4> 无缓冲通道 </h4><br><img src="https://habrastorage.org/webt/hv/k0/ba/hvk0badnrvqhncjqf9uwyrlowq8.png"><br><br> 在前面的所有示例中，我们仅使用了此类通道。 在这样的信道上，一次只能发送一个数据（如上所述，有阻塞）。 <br><br><h4> 缓冲通道 </h4><br><img src="https://habrastorage.org/webt/zs/zg/b1/zszgb15grrrjjiyaqs6gwtfkkye.png"><br><br> 程序中的流不能总是完全同步。 假设在我们的示例中，发生了一名地鼠侦查员发现了三部分矿石，而一名地鼠矿工设法同时提取了一部分已发现储量的情况。 在这里，为了避免地鼠侦查花费大部分时间，等待矿工完成工作，我们将使用缓冲通道。 首先创建一个容量为3的频道。 <br><br><pre> <code class="go hljs">bufferedChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br> 我们可以将一些数据发送到缓冲通道，而无需使用另一个goroutine读取它们。 这是与非缓冲通道的主要区别。 <br><br><img src="https://habrastorage.org/webt/sh/ok/f2/shokf2oswaiw1yk6i-uwplypezi.png"><br><pre> <code class="go hljs">bufferedChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"first"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 1st"</span></span>) bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"second"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 2nd"</span></span>) bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"third"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 3rd"</span></span>) }() &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { firstRead := &lt;- bufferedChan fmt.Println(<span class="hljs-string"><span class="hljs-string">"Receiving.."</span></span>) fmt.Println(firstRead) secondRead := &lt;- bufferedChan fmt.Println(secondRead) thirdRead := &lt;- bufferedChan fmt.Println(thirdRead) }()</code> </pre><br> 这样的程序的输出顺序如下： <br><br><pre> <code class="hljs dos">Sent <span class="hljs-number"><span class="hljs-number">1</span></span>st Sent <span class="hljs-number"><span class="hljs-number">2</span></span>nd Sent <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-built_in"><span class="hljs-built_in">rd</span></span> Receiving.. first second third</code> </pre><br> 为避免不必要的复杂性，我们不会在程序中使用缓冲通道。 但是请务必记住，也可以使用这些类型的渠道。 <br> 同样重要的是要注意，缓冲的通道并不总是使您免于阻塞。 例如，如果一个地鼠侦察器比一个地鼠矿工快十倍，并且它们通过容量为2的缓冲通道连接，那么如果该地鼠侦查器在通道中已经有两个数据，则每次发送时都会被阻塞。 <br><br><h4> 全部放在一起 </h4><br> 因此，有了goroutine和通道，我们可以使用Go中多线程编程的所有优点来编写程序。 <br><br><img src="https://habrastorage.org/webt/cq/xa/h7/cqxah7wnmg1wbcjqwhd13gyejaw.png"><br><pre> <code class="go hljs">theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} oreChannel := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) minedOreChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  go func(mine [5]string) { for _, item := range mine { if item == "ore" { oreChannel &lt;- item //   oreChannel } } }(theMine) //  go func() { for i := 0; i &lt; 3; i++ { foundOre := &lt;-oreChannel //   oreChannel fmt.Println("From Finder: ", foundOre) minedOreChan &lt;- "minedOre" //   minedOreChan } }() //  go func() { for i := 0; i &lt; 3; i++ { minedOre := &lt;-minedOreChan //   minedOreChan fmt.Println("From Miner: ", minedOre) fmt.Println("From Smelter: Ore is smelted") } }() &lt;-time.After(time.Second * 5) //    </span></span></code> </pre><br> 这样的程序将输出以下内容： <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted</code> </pre><br> 与我们的第一个示例相比，这是一个重大改进，现在所有功能都是独立执行的，每个功能都在自己的goroutine中。 另外，我们从通道中获得了一条输送机，矿石在加工后立即通过该输送机进行输送。 为了保持对通道和goroutine的操作的基本了解，我省略了一些要点，这可能会导致启动程序时遇到困难。 最后，我想详细介绍语言的这些功能，因为它们有助于使用goroutine和通道。 <br><br><h4> 匿名猩猩 </h4><br><img src="https://habrastorage.org/webt/ko/t5/y6/kot5y6lv7cf-3h2zbyghvqwf1is.png"><br><br> 正如我们在goroutine中运行常规函数一样，我们可以在<b>go</b>关键字之后立即声明一个匿名函数，并使用以下语法对其进行调用： <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   go func() { fmt.Println("I'm running in my own go routine") }()</span></span></code> </pre><br> 因此，如果只需要在一个地方调用一个函数，就可以在一个单独的goroutine中运行它，而不必担心事先声明它。 <br><br><h4> 主要功能是goroutine。 </h4><br><img src="https://habrastorage.org/webt/c_/bo/y7/c_boy7hpqt3y3krcd1utthdjy3s.png"><br><br> 是的， <b>main</b>函数确实可以在自己的goroutine中工作。 而且，更重要的是，在其完成之后，所有其他goroutine也将结束。 因此，我们在<b>主</b>函数的末尾放置了一个计时器调用。 该调用将创建一个通道，并在5秒钟后向其发送数据。 <br><br><pre> <code class="go hljs">&lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">//      </span></span></code> </pre><br> 还记得在从通道读取消息时，goroutine将被阻止，直到有东西发送给它了吗？ 这就是添加指定代码时发生的情况。 主goroutine将被阻止，使其他goroutias有5秒钟的工作时间。 该方法效果很好，但是通常使用不同的方法来验证所有goroutine已完成其工作。 为了发送有关工作完成的信号，创建了一个特殊通道，阻止了主goroutine对其进行读取，并且一旦子goroutine完成其工作，它将立即写入该通道。 主goroutine被解锁，程序结束。 <br><br><img src="https://habrastorage.org/webt/vi/4e/zv/vi4ezv-tyvzugvamrwi3z9xod8a.png"><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { doneChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//  -  doneChan &lt;- “I'm all done!” }() &lt;-doneChan //        }</span></span></code> </pre><br><h4> 在范围循环中从管道读取 </h4><br> 在我们的示例中，在goffer-getter函数中，我们使用了<b>for</b>循环从通道中选择了三个元素。 但是，如果事先不知道该通道中可以有多少数据，该怎么办？ 在这种情况下，就像集合一样，您可以将channel用作<b>for-range</b>循环的参数。 更新后的函数可能如下所示： <br><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//  go func() { for foundOre := range oreChan { fmt.Println(“Miner: Received “ + foundOre + “ from finder”) } }()</span></span></code> </pre><br> 因此，矿工将读取侦察员发送给他的所有内容；在周期中使用通道将确保这一点。 请注意，处理完通道中的所有数据后，循环将锁定读取； 为了避免阻塞，您需要通过调用<b>close（channel）关闭通道</b> 。 <br><br><h4> 无阻塞频道读取 </h4><br> 使用<b>select-case</b>构造，可以避免阻塞来自管道的读取。 以下是使用此构造的示例：goroutine将从通道中读取数据（如果只有该通道），否则将执行<b>默认</b>块： <br><br><pre> <code class="go hljs">myChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ myChan &lt;- “Message!” }() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg := &lt;- myChan: fmt.Println(msg) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(“No Msg”) } &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg := &lt;- myChan: fmt.Println(msg) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(“No Msg”) }</code> </pre><br> 启动后，此代码将输出以下内容： <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-type"><span class="hljs-type">Msg</span></span> <span class="hljs-type"><span class="hljs-type">Message!</span></span></code> </pre><br><h4> 无阻塞频道录制 </h4><br> 使用相同的<b>select-case</b>结构可以避免在写入通道时发生锁定。 让我们对上一个示例进行一些小的编辑： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> myChan &lt;- “message”: fmt.Println(“sent the message”) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(“no message sent”) }</code> </pre><br><h4> 需要进一步研究 </h4><br><img src="https://habrastorage.org/webt/d6/69/yd/d669ydnx51qv_h0tf-p-lbo8xyu.png"><br><br> 有大量文章和报告更详细地介绍了通道和goroutine的工作。 现在，借助代码，您对如何以及如何使用这些工具有了清晰的了解，您可以从以下材料中获得最大收益： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Google I / O 2012-Go并发模式</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rob Pike-“并发不是并行性”</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GopherCon 2017：爱德华·穆勒（Edward Muller）-反模式</a> </li></ul><br><br> 感谢您抽出宝贵的时间阅读。 希望我能帮助您了解频道，goroutines以及多线程程序为您带来的好处。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN412715/">https://habr.com/ru/post/zh-CN412715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN412703/index.html">在与Veeam的会议上：回顾VeeamON 2018并邀请参加在莫斯科举行的VeeamON论坛</a></li>
<li><a href="../zh-CN412705/index.html">入侵系统：我们如何改变开发人员的选择和适应</a></li>
<li><a href="../zh-CN412709/index.html">哦，我的代码：同学的机器学习和分析</a></li>
<li><a href="../zh-CN412711/index.html">要检查爱因斯坦方程，您需要打一个黑洞</a></li>
<li><a href="../zh-CN412713/index.html">May Power BI更新中最有趣的创新概述</a></li>
<li><a href="../zh-CN412717/index.html">你好外星人； 请不要杀死我们</a></li>
<li><a href="../zh-CN412719/index.html">MDG宣布语音合成竞赛</a></li>
<li><a href="../zh-CN412721/index.html">人类发现外星人的三个希望</a></li>
<li><a href="../zh-CN412723/index.html">寻找一种新的十亿美元颜色</a></li>
<li><a href="../zh-CN412725/index.html">如何使您的IT基础架构变得无聊</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>