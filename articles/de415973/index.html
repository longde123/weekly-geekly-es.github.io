<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòΩ üèÇüèº ü¶ê So brechen Sie den Apache Ignite-Cluster nicht von Anfang an üïö üí≠ üßöüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Unten finden Sie eine Abschrift des Videos der Rede auf der Apache Ignite-Kundgebung in St. Petersburg am 20. Juni. Sie k√∂nnen die Folien hier ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So brechen Sie den Apache Ignite-Cluster nicht von Anfang an</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/gridgain/blog/415973/"><p>  Hallo!  Unten finden Sie eine Abschrift des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Videos der</a> Rede auf der Apache Ignite-Kundgebung in St. Petersburg am 20. Juni.  Sie k√∂nnen die Folien <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> herunterladen. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zrMWgNyvQVI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Es gibt eine ganze Reihe von Problemen, mit denen Anf√§nger konfrontiert sind.  Sie haben gerade Apache Ignite heruntergeladen, die ersten zwei, drei, zehn Mal ausgef√ºhrt und kommen mit Fragen zu uns, die auf √§hnliche Weise gel√∂st werden.  Daher schlage ich vor, eine Checkliste zu erstellen, die Ihnen viel Zeit und Nerven spart, wenn Sie Ihre ersten Apache Ignite-Anwendungen erstellen.  Wir werden √ºber Startvorbereitungen sprechen.  wie man den Cluster zusammenbaut;  wie man einige Berechnungen im Rechenraster startet;  So bereiten Sie ein Datenmodell und einen Code vor, damit Sie Ihre Daten in Ignite schreiben und dann erfolgreich lesen k√∂nnen.  Und vor allem: wie man von Anfang an nichts kaputt macht. </p><a name="habracut"></a><br><h2>  Vorbereitung f√ºr den Start - Konfigurieren Sie die Protokollierung </h2><br><p>  Wir brauchen Protokolle.  Wenn Sie jemals eine Frage in der Apache Ignite-Mailingliste oder in StackOverflow gestellt haben, z. B. "Warum hat alles aufgelegt?", Wurden Sie h√∂chstwahrscheinlich als erstes aufgefordert, alle Protokolle aller Knoten zu senden. </p><br><p> Nat√ºrlich ist die Apache Ignite-Protokollierung standardm√§√üig aktiviert.  Aber es gibt Nuancen.  Erstens schreibt Apache Ignite ein wenig in <code>stdout</code> .  Standardm√§√üig startet es im sogenannten Ruhezustand.  In <code>stdout</code> werden nur die schrecklichsten Fehler angezeigt, und alles andere wird in einer Datei gespeichert, deren Pfad Apache Ignite ganz am Anfang anzeigt (standardm√§√üig - <code>${IGNITE_HOME}/work/log</code> ).  Sie l√∂schen es nicht und bewahren die Protokolle l√§nger auf, es kann sehr n√ºtzlich sein. </p><br><p>  <b><code>stdout</code> beim Standardstart entz√ºnden</b> </p><br><p><img src="https://habrastorage.org/webt/dg/wf/4r/dgwf4rf9on5vckayvxqzcbtr5tk.png"></p><br><p>  Um das Auffinden von Problemen zu vereinfachen, ohne in separate Dateien zu gelangen und eine separate √úberwachung f√ºr Apache Ignite einzurichten, k√∂nnen Sie diese mit dem Befehl im ausf√ºhrlichen Modus ausf√ºhren </p><br><pre> <code class="bash hljs">ignite.sh -v</code> </pre> <br><p>  Anschlie√üend schreibt das System zusammen mit dem Rest der Anwendungsprotokollierung √ºber alle Ereignisse in <code>stdout</code> . </p><br><p>  √úberpr√ºfen Sie die Protokolle!  Sehr oft finden Sie in ihnen L√∂sungen f√ºr Ihre Probleme.  Wenn der Cluster zusammengebrochen ist, sehen Sie sehr oft im Protokoll Meldungen wie ‚ÄûErh√∂hen Sie das Zeitlimit in dieser und jener Konfiguration.  Wir sind wegen ihm abgefallen.  Er ist zu klein.  Das Netzwerk ist nicht gut genug. ‚Äú </p><br><h2>  Cluster-Assembly </h2><br><h3>  Ungebetene G√§ste </h3><br><p>  Das erste Problem, mit dem viele konfrontiert sind, sind die ungebetenen G√§ste in Ihrem Cluster.  Oder Sie selbst erweisen sich als ungebetener Gast: Starten Sie einen neuen Cluster, und pl√∂tzlich sehen Sie, dass Sie im ersten Topologie-Snapshot anstelle eines Knotens von Anfang an zwei Server haben.  Wie so?  Sie haben nur einen gestartet. </p><br><p>  <b>Eine Nachricht, die angibt, dass der Cluster zwei Knoten hat</b> </p><br><p><img src="https://habrastorage.org/webt/l9/fd/kd/l9fdkdt9vvoaryo1fk84agizhvi.png"></p><br><p>  Tatsache ist, dass Apache Ignite standardm√§√üig Multicast verwendet und beim Start nach allen anderen Apache Ignite sucht, die sich im selben Subnetz in derselben Multicast-Gruppe befinden.  In diesem Fall wird versucht, eine Verbindung herzustellen.  Und im Falle einer nicht erfolgreichen Verbindung wird sie √ºberhaupt nicht gestartet.  Daher werden im Cluster auf meinem funktionierenden Laptop regelm√§√üig zus√§tzliche Knoten aus dem Cluster auf dem Laptop des Kollegen angezeigt, was sicherlich nicht sehr praktisch ist. </p><br><p>  Wie k√∂nnen Sie sich davor sch√ºtzen?  Der einfachste Weg, um statische IP zu konfigurieren.  Anstelle von <code>TcpDiscoveryMulticastIpFinder</code> , der standardm√§√üig verwendet wird, gibt es <code>TcpDiscoveryVmIpFinder</code> .  Notieren Sie sich dort alle IP-Adressen und Ports, mit denen Sie eine Verbindung herstellen.  Dies ist viel praktischer und sch√ºtzt Sie vor einer Vielzahl von Problemen, insbesondere in Entwicklungs- und Testumgebungen. </p><br><h3>  Zu viele Adressen </h3><br><p>  Das n√§chste Problem.  Sie haben Multicast deaktiviert, den Cluster gestartet und in einer einzigen Konfiguration eine angemessene Menge an IP aus verschiedenen Umgebungen festgelegt.  Und es kommt vor, dass Sie den ersten Knoten in einem neuen Cluster f√ºr 5-10 Minuten starten, obwohl alle nachfolgenden Knoten in 5-10 Sekunden eine Verbindung zu ihm herstellen. </p><br><p>  Nehmen Sie eine Liste mit drei IP-Adressen.  F√ºr jeden schreiben wir Bereiche von 10 Ports vor.  Insgesamt werden 30 TCP-Adressen erhalten.  Da Apache Ignite versuchen muss, eine Verbindung zu einem vorhandenen Cluster herzustellen, bevor ein neuer Cluster erstellt wird, √ºberpr√ºft es nacheinander jede IP.  Auf Ihrem Laptop kann es nicht schaden, aber in einigen wolkigen Umgebungen ist der Schutz vor Port-Scans h√§ufig enthalten.  Das hei√üt, wenn Sie √ºber eine IP-Adresse auf einen privaten Port zugreifen, erhalten Sie keine Antwort, bis das Zeitlimit abgelaufen ist.  Standardm√§√üig sind es 10 Sekunden.  Und wenn Sie 3 Adressen mit 10 Ports haben, erhalten Sie 3 * 10 * 10 = 300 Sekunden Wartezeit - dieselben 5 Minuten f√ºr die Verbindung. </p><br><p>  Die L√∂sung liegt auf der Hand: Registrieren Sie keine unn√∂tigen Ports.  Wenn Sie drei IPs haben, brauchen Sie kaum einen Standardbereich von 10 Ports.  Dies ist praktisch, wenn Sie etwas auf dem lokalen Computer testen und 10 Knoten ausf√ºhren.  In realen Systemen reicht jedoch normalerweise ein einziger Port aus.  Oder deaktivieren Sie den Schutz gegen Port-Scans im internen Netzwerk, wenn Sie eine solche M√∂glichkeit haben. </p><br><p>  Das dritte h√§ufige Problem ist IPv6.  Sie k√∂nnen seltsame Netzwerkfehlermeldungen sehen: Konnte keine Verbindung herstellen, konnte keine Nachricht senden, Knoten segmentiert.  Dies bedeutet, dass Sie vom Cluster gefallen sind.  Sehr oft werden solche Probleme durch gemischte Umgebungen aus IPv4 und IPv6 verursacht.  Dies bedeutet nicht, dass Apache Ignite IPv6 nicht unterst√ºtzt, aber im Moment gibt es bestimmte Probleme. </p><br><p>  Die einfachste L√∂sung besteht darin, die Option an den Java-Computer zu √ºbergeben </p><br><pre> <code class="hljs objectivec">-Djava.net.preferIPv4Stack=<span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  Dann verwenden Java und Apache Ignite kein IPv6.  Dies l√∂st einen wesentlichen Teil der Probleme mit kollabierenden Clustern. </p><br><h2>  Vorbereitung der Codebasis - wir serialisieren korrekt </h2><br><p>  Der Cluster hat sich versammelt, es ist notwendig, etwas darin zu starten.  Eines der wichtigsten Elemente bei der Interaktion Ihres Codes mit Apache Ignite-Code ist Marshaller oder Serialisierung.  Um etwas in den Speicher zu schreiben, zu persistieren und √ºber das Netzwerk zu senden, serialisiert Apache Ignite zuerst Ihre Objekte.  Sie k√∂nnen Nachrichten sehen, die mit den Worten beginnen: "Kann nicht im Bin√§rformat geschrieben werden" oder "Kann nicht mit BinaryMarshaller serialisiert werden".  Es wird nur eine solche Warnung im Protokoll geben, die jedoch auff√§llt.  Dies bedeutet, dass Sie Ihren Code etwas weiter optimieren m√ºssen, um sich mit Apache Ignite anzufreunden. </p><br><p>  Apache Ignite verwendet drei Mechanismen f√ºr die Serialisierung: </p><br><ul><li>  <code>JdkMarshaller</code> - regul√§re Java-Serialisierung; </li><li>  <code>OptimizedMarshaller</code> - leicht optimierte Java-Serialisierung, aber die Mechanismen sind dieselben; </li><li>  <code>BinaryMarshaller</code> ist eine speziell f√ºr Apache Ignite geschriebene Serialisierung, die √ºberall unter der Haube verwendet wird.  Sie hat eine Reihe von Vorteilen.  Irgendwo k√∂nnen wir zus√§tzliche Serialisierung und Deserialisierung vermeiden, und irgendwo k√∂nnen wir sogar ein nicht deserialisiertes Objekt in der API erhalten, das direkt im Bin√§rformat arbeitet, wie bei etwas wie JSON. </li></ul><br><p>  <code>BinaryMarshaller</code> kann Ihre POJOs serialisieren und de-serialisieren, die nur Felder und einfache Methoden enthalten.  Wenn Sie jedoch eine benutzerdefinierte Serialisierung √ºber <code>readObject()</code> und <code>writeObject()</code> und <code>Externalizable</code> , wird <code>BinaryMarshaller</code> nicht bew√§ltigen.  Er wird feststellen, dass Ihr Objekt durch die √ºbliche Aufzeichnung nicht transienter Felder nicht serialisiert werden kann, und wird aufgeben - es wird auf <code>OptimizedMarshaller</code> . </p><br><p>  Um sich mit Apache Ignite mit solchen Objekten <code>Binarylizable</code> , m√ºssen Sie die <code>Binarylizable</code> Schnittstelle implementieren.  Er ist sehr einfach. </p><br><p>  Zum Beispiel gibt es eine Standard- <code>TreeMap</code> von Java.  Es verf√ºgt √ºber eine benutzerdefinierte Serialisierung und Deserialisierung √ºber Lese- und Schreibobjekte.  Es beschreibt zuerst einige Felder und schreibt dann die L√§nge und die Daten selbst in den <code>OutputStream</code> . </p><br><p>  <b>Implementierung von <code>TreeMap.writeObject()</code></b> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.io.ObjectOutputStream s)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> java.io.IOException </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Write out the Comparator and any hidden stuff s.defaultWriteObject(); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) for (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); i.hasNext(); ) { Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); } }</span></span></code> </pre> <br><p>  <code>writeBinary()</code> und <code>readBinary()</code> von <code>Binarylizable</code> funktionieren genauso: <code>BinaryTreeMap</code> verpackt sich in eine regul√§re <code>TreeMap</code> und schreibt sie in <code>OutputStream</code> .  Diese Methode ist einfach zu schreiben und erh√∂ht die Produktivit√§t erheblich. </p><br><p>  <b>Implementierung von <code>BinaryTreeMap.writeBinary()</code></b> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeBinary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BinaryWriter writer)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> BinaryObjectException </span></span>{ BinaryRawWriter rewriter = writer. rewrite (); rawWriter.writeObject(map.comparator()); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = map.size(); rawWriter.writeInt(size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Map.Entry&lt;Object, Object&gt; entry : ((TreeMap&lt;Object, Object&gt;)map).entrySet()) { rawWriter.writeObject(entry.getKey()); rawWriter.writeObject(entry.getValue()); } }</code> </pre> <br><h2>  Starten Sie in Compute Grid </h2><br><p>  Mit Ignite k√∂nnen Sie nicht nur Daten speichern, sondern auch verteiltes Computing ausf√ºhren.  Wie f√ºhren wir eine Art Lambda aus, damit alle Server gestreut und ausgef√ºhrt werden? <br>  Was ist f√ºr den Anfang das Problem mit diesen Codebeispielen? </p><br><p>  <b>Was ist das Problem?</b> </p><br><pre> <code class="java hljs">Foo foo = ‚Ä¶; Bar bar = ...; ignite.compute().broadcast( () -&gt; doStuffWithFooAndBar(foo, bar) );</code> </pre> <br><p>  <b>Und wenn ja?</b> </p><br><pre> <code class="java hljs">Foo foo = ‚Ä¶; Bar bar = ...; ignite.compute().broadcast(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IgniteRunnable() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ doStuffWithFooAndBar(foo, bar); } });</code> </pre> <br><p>  Wie Sie sich vorstellen k√∂nnen, besteht das Problem bei vielen, die mit den Fallstricken von Lambdas und anonymen Klassen vertraut sind, darin, Variablen von au√üen zu erfassen.  Zum Beispiel versenden wir Lambda.  Es werden einige Variablen verwendet, die au√üerhalb des Lambda deklariert sind.  Dies bedeutet, dass diese Variablen mit ihr reisen und √ºber das Netzwerk zu allen Servern fliegen.  Und dann stellen sich alle die gleichen Fragen: <code>BinaryMarshaller</code> diese Objekte mit <code>BinaryMarshaller</code> befreundet?  Wie gro√ü sind sie?  Wollen wir im Allgemeinen, dass sie irgendwohin √ºbertragen werden, oder sind diese Objekte so gro√ü, dass es besser ist, eine ID zu √ºbergeben und die Objekte im Lambda bereits auf der anderen Seite neu zu erstellen? </p><br><p>  Anonyme Klasse ist noch schlimmer.  Wenn das Lambda dies nicht mitnehmen kann, werfen Sie es weg, wenn es nicht verwendet wird, dann wird die anonyme Klasse es sicher nehmen, und dies f√ºhrt normalerweise zu nichts Gutem. </p><br><p>  Das folgende Beispiel.  Wieder Lambda, der aber ein bisschen die Apache Ignite API verwendet. </p><br><p>  <b>Die Verwendung von Ignite Inside Compute Closure ist <em>falsch</em></b> </p><br><pre> <code class="java hljs">ignite.compute().broadcast(() -&gt; { IgniteCache foo = ignite.cache(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); String sql = <span class="hljs-string"><span class="hljs-string">"where id = 42"</span></span>; SqlQuery qry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlQuery(<span class="hljs-string"><span class="hljs-string">"Foo"</span></span>, sql).setLocal(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo.query(qry); });</code> </pre> <br><p>  In der Originalversion nimmt es den Cache und f√ºhrt lokal eine Art SQL-Abfrage durch.  Dies ist ein solches Muster, wenn Sie eine Aufgabe senden m√ºssen, die nur mit lokalen Daten auf Remote-Knoten funktioniert. </p><br><p>  Was ist das Problem hier?  Das Lambda erfasst erneut die Verkn√ºpfung, aber jetzt nicht zum Objekt, sondern zum lokalen Ignite auf dem Knoten, mit dem wir es senden.  Und es funktioniert sogar, weil das Ignite-Objekt √ºber eine <code>readResolve()</code> -Methode verf√ºgt, mit der die Deserialisierung die √ºber das Netzwerk <code>readResolve()</code> Ignite durch eine lokale auf dem Knoten ersetzen kann, an den wir sie gesendet haben.  Dies f√ºhrt aber manchmal auch zu unerw√ºnschten Folgen. </p><br><p>  Grunds√§tzlich √ºbertragen Sie einfach mehr Daten √ºber das Netzwerk, als Sie m√∂chten.  Wenn Sie von einem Code <code>Ignintion.localIgnite()</code> m√ºssen, den Sie nicht steuern, um Apache Ignite oder einige seiner Schnittstellen zu starten, verwenden Sie am einfachsten die Methode <code>Ignintion.localIgnite()</code> .  Sie k√∂nnen es von jedem von Apache Ignite erstellten Thread aus aufrufen und einen Link zu einem lokalen Objekt erhalten.  Wenn Sie Lambdas, Dienste usw. haben und verstehen, dass Sie hier Ignite ben√∂tigen, empfehle ich diese Methode. </p><br><p>  <strong>Wir verwenden Ignite Inside Compute Closure korrekt - √ºber <code>localIgnite()</code></strong> </p><br><pre> <code class="java hljs">ignite.compute().broadcast(() -&gt; { IgniteCache foo = Ignition.localIgnite().cache(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); String sql = <span class="hljs-string"><span class="hljs-string">"where id = 42"</span></span>; SqlQuery qry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlQuery(<span class="hljs-string"><span class="hljs-string">"Foo"</span></span>, sql).setLocal(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo.query(qry); });</code> </pre><br><p>  Und das letzte Beispiel in diesem Teil.  Apache Ignite verf√ºgt √ºber ein Service Grid, mit dem Microservices direkt in einem Cluster bereitgestellt werden k√∂nnen. Apache Ignite hilft dabei, die richtige Anzahl von Instanzen online zu halten.  Angenommen, wir ben√∂tigen in diesem Dienst auch einen Link zu Apache Ignite.  Wie bekomme ich es?  Wir k√∂nnten <code>localIgnite()</code> , aber dann muss dieser Link manuell im Feld gespeichert werden. </p><br><p>  <strong>Der Dienst speichert Ignite <em>falsch</em> in einem Feld - nimmt es als Argument f√ºr den Konstruktor</strong> </p><br><pre> <code class="java hljs">MyService s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyService(ignite) ignite.services().deployClusterSingleton(<span class="hljs-string"><span class="hljs-string">"svc"</span></span>, s); ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Ignite ignite; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ignite ignite)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ignite = ignite; } ... }</code> </pre> <br><p>  Es gibt einen einfacheren Weg.  Wir haben immer noch vollst√§ndige Klassen und kein Lambda, daher k√∂nnen wir das Feld als <code>@IgniteInstanceResource</code> mit Anmerkungen <code>@IgniteInstanceResource</code> .  Wenn der Dienst erstellt wird, wird Apache Ignite dort abgelegt, und Sie k√∂nnen ihn sicher verwenden.  Ich rate Ihnen dringend, genau das zu tun und nicht zu versuchen, Apache Ignite und seine untergeordneten Elemente an den Konstruktor weiterzugeben. </p><br><p>  <strong>Der Dienst verwendet <code>@IgniteInstanceResource</code></strong> </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IgniteInstanceResource</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Ignite ignite; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } ... }</code> </pre> <br><h2>  Daten schreiben und lesen </h2><br><h3>  Achten Sie auf die Grundlinie </h3><br><p>  Jetzt haben wir einen Apache Ignite-Cluster und vorbereiteten Code. </p><br><p>  Stellen wir uns dieses Szenario vor: </p><br><ul><li>  Ein <code>REPLICATED</code> Cache - Kopien von Daten sind auf allen Knoten verf√ºgbar. </li><li>  Die native Persistenz ist aktiviert - Schreiben auf die Festplatte. </li></ul><br><p>  Wir starten einen Knoten.  Da die native Persistenz aktiviert ist, m√ºssen wir den Cluster aktivieren, bevor wir damit arbeiten k√∂nnen.  Aktivieren.  Dann starten wir einige weitere Knoten. <br>  Alles scheint zu funktionieren: Schreiben und Lesen sind in Ordnung.  Alle Knoten haben Kopien der Daten, Sie k√∂nnen einen Knoten sicher stoppen.  Wenn Sie jedoch den ersten Knoten stoppen, von dem aus Sie den Start gestartet haben, bricht alles zusammen: Die Daten verschwinden und die Vorg√§nge werden nicht mehr ausgef√ºhrt. </p><br><p>  Der Grund daf√ºr ist die Basistopologie - die vielen Knoten, auf denen Persistenzdaten gespeichert sind.  Alle anderen Knoten haben keine persistenten Daten. </p><br><p>  Dieser Satz von Knoten wird zum ersten Mal zum Zeitpunkt der Aktivierung bestimmt.  Und die Knoten, die Sie anschlie√üend hinzugef√ºgt haben, sind nicht mehr in der Anzahl der Basisknoten enthalten.  Das hei√üt, viele Basistopologien bestehen nur aus einem, dem allerersten Knoten. Wenn er stoppt, bricht alles.  Um dies zu verhindern, starten Sie zuerst alle Knoten und aktivieren Sie dann den Cluster.  Wenn Sie mit dem Befehl einen Knoten hinzuf√ºgen oder entfernen m√ºssen </p><br><pre> <code class="bash hljs">control.sh --baseline</code> </pre> <br><p>  Sie k√∂nnen sehen, welche Knoten dort aufgelistet sind.  Das gleiche Skript kann die Baseline auf den aktuellen Status aktualisieren. </p><br><p>  <b><code>control.sh</code> Beispiel</b> </p><br><p><img src="https://habrastorage.org/webt/nw/6d/fy/nw6dfy5onsssvkwsw1vmwaxczm4.png"></p><br><h3>  Datenkolokation </h3><br><p>  Jetzt wissen wir, dass die Daten gespeichert sind. Versuchen Sie, sie zu lesen.  Wir haben SQL-Unterst√ºtzung, Sie k√∂nnen <code>SELECT</code> - fast wie in Oracle.  Gleichzeitig k√∂nnen wir aber beliebig viele Knoten skalieren und ausf√ºhren, die Daten werden verteilt gespeichert.  Schauen wir uns ein solches Modell an: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@QuerySqlField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@QuerySqlField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Long orgId; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Organization</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@QuerySqlField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; }</code> </pre> <br><p>  Anfrage </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Organization</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> o <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.orgId = o.id</code> </pre> <br><p>  gibt nicht alle Daten zur√ºck.  Was ist los? </p><br><p>  Person ( <code>Person</code> ) bezieht sich auf die Organisation ( <code>Organization</code> ) nach ID.  Dies ist ein klassischer Fremdschl√ºssel.  Wenn wir jedoch versuchen, die beiden Tabellen zu kombinieren und eine solche SQL-Abfrage zu senden, erhalten wir bei mehreren Knoten im Cluster nicht alle Daten. </p><br><p>  Tatsache ist, dass SQL <code>JOIN</code> standardm√§√üig nur innerhalb eines einzelnen Knotens funktioniert.  Wenn SQL st√§ndig im gesamten Cluster Daten sammeln und das vollst√§ndige Ergebnis zur√ºckgeben w√ºrde, w√§re dies unglaublich langsam.  Wir w√ºrden alle Vorteile eines verteilten Systems verlieren.  Stattdessen betrachtet Apache Ignite nur lokale Daten. </p><br><p>  Um die richtigen Ergebnisse zu erhalten, m√ºssen wir Daten zusammenstellen (Colocation).  Das hei√üt, f√ºr die richtige Kombination von Person und Organisation m√ºssen die Daten beider Tabellen auf demselben Knoten gespeichert werden. </p><br><p>  Wie kann man das machen?  Die einfachste L√∂sung besteht darin, einen Affinit√§tsschl√ºssel zu deklarieren.  Dies ist ein Wert, der bestimmt, auf welchem ‚Äã‚ÄãKnoten, in welcher Partition, in welcher Gruppe von Datens√§tzen sich dieser oder jener Wert befindet.  Wenn wir die Organisations-ID <code>Person</code> als Affinit√§tsschl√ºssel deklarieren, bedeutet dies, dass sich Personen mit dieser Organisations-ID auf demselben Knoten wie die Organisation mit derselben ID befinden m√ºssen. </p><br><p>  Wenn Sie dies aus irgendeinem Grund nicht tun k√∂nnen, gibt es eine andere, weniger effektive L√∂sung: Aktivieren Sie verteilte Verkn√ºpfungen.  Dies erfolgt √ºber die API, und die Vorgehensweise h√§ngt davon ab, was Sie verwenden - Java, JDBC oder etwas anderes.  Dann werden <code>JOIN</code> langsamer ausgef√ºhrt, aber dann werden die korrekten Ergebnisse zur√ºckgegeben. </p><br><p>  Lassen Sie uns √ºberlegen, wie Sie mit Affinit√§tsschl√ºsseln arbeiten.  Wie verstehen wir, dass eine solche und eine solche ID, ein solches und ein solches Feld zur Bestimmung der Affinit√§t geeignet ist?  Wenn wir sagen, dass alle Personen mit derselben <code>orgId</code> zusammen gespeichert werden, ist <code>orgId</code> eine unteilbare Gruppe.  Wir k√∂nnen es nicht auf mehrere Knoten verteilen.  Wenn die Datenbank 10 Organisationen enth√§lt, gibt es 10 unteilbare Gruppen, die auf 10 Knoten platziert werden k√∂nnen.  Wenn der Cluster mehr Knoten enth√§lt, bleiben alle "zus√§tzlichen" Knoten ohne Gruppen.  Dies ist in der Laufzeit sehr schwer zu definieren. Denken Sie also vorher dar√ºber nach. </p><br><p>  Wenn Sie eine gro√üe und 9 kleine Organisation haben, ist die Gr√∂√üe der Gruppen unterschiedlich.  Apache Ignite ber√ºcksichtigt jedoch nicht die Anzahl der Datens√§tze in Affinit√§tsgruppen, wenn diese auf Knoten verteilt werden.  Daher wird er nicht eine Gruppe auf einen Knoten setzen, sondern 9 andere auf einen anderen, um die Verteilung irgendwie auszugleichen.  Vielmehr wird er sie 5 und 5 setzen (oder 6 und 4 oder sogar 7 und 3). </p><br><p>  Wie k√∂nnen die Daten gleichm√§√üig verteilt werden?  M√∂gen wir haben </p><br><ul><li>  K Tasten; </li><li>  Eine Vielzahl von Affinit√§tsschl√ºsseln; </li><li>  P-Partitionen, dh gro√üe Datengruppen, die Apache Ignite zwischen den Knoten verteilt; </li><li>  N Knoten. </li></ul><br><p>  Dann ist es notwendig, dass die Bedingung </p><br><pre> <code class="hljs ruby">K <span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>A &gt;&gt; P &gt;&gt; N</code> </pre> <br><p>  Dabei ist <code>&gt;&gt;</code> "viel mehr" und die Daten werden relativ gleichm√§√üig verteilt. </p><br><p>  Der Standardwert ist √ºbrigens P = 1024. </p><br><p>  H√∂chstwahrscheinlich wird es Ihnen nicht gelingen, eine gleichm√§√üige Verteilung zu erreichen.  Dies war in Apache Ignite 1.x bis 1.9 der Fall.  Dies wurde als <code>FairAffinityFunction</code> und funktionierte nicht sehr gut - es f√ºhrte zu zu viel Verkehr zwischen Knoten.  Jetzt hei√üt der Algorithmus <code>RendezvousAffinityFunction</code> .  Es gibt keine absolut ehrliche Verteilung, der Fehler zwischen den Knoten betr√§gt plus oder minus 5-10%. </p><br><h2>  Checkliste f√ºr neue Apache Ignite-Benutzer </h2><br><ol><li>  Protokolle einrichten, lesen, speichern </li><li>  Deaktivieren Sie Multicast und notieren Sie nur die Adressen und Ports, die Sie verwenden </li><li>  Deaktivieren Sie IPv6 </li><li>  <code>BinaryMarshaller</code> Sie Ihre Klassen f√ºr <code>BinaryMarshaller</code> </li><li>  Behalten Sie Ihre Grundlinie im Auge </li><li>  Richten Sie die Affinit√§tskollokation ein </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415973/">https://habr.com/ru/post/de415973/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415961/index.html">Russischer verteilter Speicher. Wie es funktioniert</a></li>
<li><a href="../de415963/index.html">Naive Bayes oder wie Sie mit Mathematik Spam filtern k√∂nnen</a></li>
<li><a href="../de415965/index.html">Was im Juli zu lesen ist: 19 neue B√ºcher f√ºr Digitalprofis</a></li>
<li><a href="../de415967/index.html">SolidFire - Speicher f√ºr diejenigen, die Hassspeicher haben</a></li>
<li><a href="../de415969/index.html">HyperX Pulsefire Surge RGB - ein nat√ºrlich geborener Killer</a></li>
<li><a href="../de415975/index.html">Die Chinesen f√ºhrten eine Laserpistole mit einer Reichweite von fast einem Kilometer ein</a></li>
<li><a href="../de415977/index.html">DPI-resistente Tunnel und VPNs</a></li>
<li><a href="../de415979/index.html">Sicherheitswoche 24: Rowhammer unter Android und die Komplexit√§t von Hardware-Schwachstellen</a></li>
<li><a href="../de415981/index.html">Google und HTTP</a></li>
<li><a href="../de415983/index.html">Fr√ºhes Universum 5. Kosmologische Rotverschiebung und Dynamik eines einheitlich expandierenden Universums, Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>