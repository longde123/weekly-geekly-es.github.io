<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🚒 🥘 🕥 GitLab用于InterSystems技术上的持续交付项目：容器 🥂 👼🏼 🔼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文是有关组织持续集成 /持续交付过程的文章的延续，该过程使适用于基于InterSystems平台的解决方案的应用程序的组装，测试和交付自动化。 


 考虑以下主题： 


- 货柜101 
- 处于软件开发周期不同阶段的容器 
- 容器连续交付 
 货柜101 


 关于容器和容器化的文章和书...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GitLab用于InterSystems技术上的持续交付项目：容器</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intersystems/blog/420749/"><p> 本文是有关组织<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">持续集成</a> /持续交付过程的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a>的延续，该过程使适用于基于InterSystems平台的解决方案的应用程序的组装，测试和交付自动化。 </p><br><p> 考虑以下主题： </p><br><ul><li> 货柜101 </li><li> 处于软件开发周期不同阶段的容器 </li><li> 容器连续交付 <a name="habracut"></a></li></ul><br><h1 id="konteynery-101"> 货柜101 </h1><br><p> 关于容器和容器化的文章和书籍很多，因此在这里我将做一个简短的介绍，但是，引言并不是最终的。 因此，让我们开始吧。 </p><br><p> 从技术上讲，容器是一种虚拟化方法，其中操作系统的内核支持几个隔离的用户空间实例（容器），而不是一个。 看起来像这样： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/114/c21/985/114c21985549c134bf91685e2b15d1d3.jpg" alt="Docker与VM"></p><br><p> 重要的是要注意容器不是虚拟机，这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇</a>有关它们之间差异的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">好文章</a> 。 </p><br><h2 id="preimuschestva-konteynerov"> 集装箱的好处 </h2><br><p> 使用容器有几个好处： </p><br><ul><li> 可携性 </li><li> 实效 </li><li> 隔离度 </li><li> 轻便 </li><li> 不变性 </li></ul><br><h3 id="portativnost"> 可携性 </h3><br><p> 容器包含应用程序以及所有依赖项。 这使得在各种环境（例如物理服务器，虚拟机，测试环境和产品环境以及云）中运行应用程序变得容易。 </p><br><p> 此外，可移植性还包括以下事实：在Docker映像组装好并且可以正常工作之后，如果Docker在此工作，即可以在任何地方工作。 在Windows，Linux和MacOS服务器上。 </p><br><h3 id="effektivnost"> 实效 </h3><br><p> 使用虚拟机应用程序时，您是否真的需要OS进程，系统程序等？ 通常，不，只有您的申请过程很有趣。 容器恰恰提供了这一点：只有明显需要的那些过程才在容器中启动，仅此而已。 因为容器不需要单独的操作系统，所以它们使用的资源更少。 虚拟机通常占用数GB，而一个容器可以小到几兆字节，这使您可以在单个服务器上运行比虚拟机更多的容器。 </p><br><p> 由于容器具有更高的服务器利用率，因此需要较少的硬件，从而降低了成本。 </p><br><h3 id="izolyaciya"> 隔离度 </h3><br><p> 容器将应用程序与所有其他进程隔离开来，尽管几个容器可以在同一台服务器上运行，但是它们可以彼此完全独立。 容器之间的任何交互都必须明确声明。 如果一个容器发生故障，则不会影响其他容器，因此可以快速重新启动。 这种隔离也提高了安全性。 例如，利用主机上的Web服务器漏洞可以使攻击者可以访问整个服务器，但是对于容器，攻击者仅可以访问Web服务器容器。 </p><br><h3 id="lyogkost"> 轻便 </h3><br><p> 由于这些容器不需要单独的操作系统，因此可以在几秒钟内启动，停止或重新启动它们，这将加快所有相关过程的速度，包括持续集成过程。 您可以开始更快地开发，而不会浪费时间来设置环境。 </p><br><h3 id="neizmennost-immutability"> 不变性 </h3><br><p> 不可变的基础结构由不可变的组件组成，这些组件会为每个部署替换，并且不会更新。 一致性可以减少不一致性，并允许您轻松，快速地在应用程序的不同状态之间复制和移动。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于不变性的更多信息</a> 。 </p><br><h2 id="novye-vozmozhnosti"> 新功能 </h2><br><p> 所有这些好处使您能够以新方式管理基础架构和应用程序。 </p><br><h3 id="orkestraciya"> 编排 </h3><br><p> 随着时间的流逝，虚拟机和服务器通常会获得“个性”，这会导致将来出现许多普遍不愉快的意外情况。 解决此问题的一种方法是“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基础结构即代码</a> （IoC）”-使用具有版本控制系统的描述性模型进行基础结构管理。 </p><br><p> 使用IoC时，无论环境的初始状态如何，环境部署团队始终将目标环境带入相同的配置。 这可以通过自动设置现有环境或从头开始重新创建环境来实现。 </p><br><p> 开发人员使用IoC可以更改环境描述。 随后，将目标环境修改为新状态。 如果您需要在星期三进行更改，则会对其描述进行编辑。 </p><br><p> 使用容器可以轻松完成所有这些工作。 关闭容器并启动一个新容器需要花费几秒钟，而分配新虚拟机则需要花费几分钟。 </p><br><h3 id="masshtabirovanie"> 缩放比例 </h3><br><p> 编排工具还可以根据当前负载提供水平缩放。 可以运行当前所需数量的容器，并相应地扩展应用程序。 所有这些还降低了应用程序的成本。 </p><br><h1 id="konteynery-na-raznyh-etapah-zhiznennogo-cikla-po"> 处于软件生命周期不同阶段的容器 </h1><br><p> 考虑在软件生命周期的各个阶段中容器的好处。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/639/58e/062/63958e06271594a0c8fbe5a8e8785ca7.png" alt="软件生命周期"></p><br><h2 id="razrabotka"> 发展历程 </h2><br><p>最重要的优点是易于开始开发。  <a href="">安装Docker之后</a> ，运行两个命令就足够了： <code>docker pull</code>加载映像，而<code>docker run</code>启动它。 在应用程序构建阶段，所有依赖关系都已解决。 </p><br><h2 id="otladka"> 侦错 </h2><br><p> 所有环境都是一致的，并且它们的定义存在；此外，易于部署必要的环境。 足以使<code>docker pull</code>所需的容器并运行它。 </p><br><h2 id="testirovanie--qa"> 测试/质量检查 </h2><br><p> 在发生错误的情况下，问题环境和重现错误的条件可以随容器一起转移。 所有基础架构更改均已“记录在案”。 变量的数量在减少-库，框架，操作系统的版本...可以运行多个容器来并行化测试。 </p><br><h2 id="dostavka"> 派送 </h2><br><p> 使用容器可以使您一次构建，除了使用容器之外，还需要高度自动化的组装和部署过程。 由于额外的隔离，应用程序的容器交付可以更安全。 </p><br><h1 id="continuous-delivery"> 持续交付 </h1><br><p> 让我们从理论转向实践。 这是我们的组装和交付自动化解决方案的总体视图： </p><br><p><img src="https://habrastorage.org/webt/yv/dn/qc/yvdnqcgyrlswgft4-zhnm-2mabc.png" alt="光盘"></p><br><p> 可以分为三个主要阶段： </p><br><ul><li> 组装方式 </li><li> 派送 </li><li> 发射 </li></ul><br><h2 id="sborka"> 组装方式 </h2><br><p> 在上一篇文章中，程序集是增量的-我们考虑了当前环境与新代码库之间的差异，并更改了我们的环境，使其与新代码库相对应。 使用容器，每个组装都是完整的。 构建结果是可以在任何地方运行的Docker映像。 </p><br><h2 id="dostavka-1"> 派送 </h2><br><p> 我们的映像经过编译和测试后，将被上传到Docker Registry，这是一个用于托管Docker Image的专用应用程序。 在那里，他可以用相同的名称（标签）替换先前的图像。 例如，由于对master分支的新提交，我们组装了一个新映像（ <code>MyProject/MyApp:master</code> ），如果通过了测试，我们可以在Docker注册表中更新该映像，所有下载<code>MyProject/MyApp:master</code>都将获得一个新版本。 </p><br><h2 id="zapusk"> 发射 </h2><br><p> 最后，必须启动映像。  CD系统（如GitLab）可以直接或在专门的协调器的帮助下进行管理，但是过程通常是相同的-启动某些映像，定期检查性能，如果有新版本可用，则进行更新。 </p><br><p> 请查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网络研讨会，以</a>解释这些步骤。 </p><br><p> 或者，就提交而言： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ced/48d/84c/ced48d84c0a2213b3bd9c2bda109146e.png"></p><br><p> 在我们的持续交付配置中，我们： </p><br><ul><li> 将代码提交到GitLab存储库 </li><li> 我们收集图像 </li><li> 测试它 </li><li> 在我们的Docker Registry中发布新映像 </li><li> 从Docker注册表将旧容器更新为新版本 </li></ul><br><p> 为此，我们需要： </p><br><ul><li> 码头工人 </li><li>  Docker注册表 </li><li> 注册域（可选，但可取） </li><li>  GUI工具（可选） </li></ul><br><h3 id="docker"> 码头工人 </h3><br><p> 首先，我们需要启动Docker。 我建议从具有通用Linux版本（例如Ubuntu，RHEL或Suse）的单个服务器开始。 我不建议从CoreOS，RancherOS等发行版开始-它们不是针对初学者的。  <a href="">切记将存储驱动程序切换到devicemapper</a> 。 </p><br><p> 如果我们谈论大规模部署，那么使用诸如Kubernetes，Rancher或Swarm之类的编排工具，您可以使大多数任务自动化，但我们不会讨论它们（至少在本文的框架中）。 </p><br><h3 id="docker-registry">  Docker注册表 </h3><br><p> 这是我们需要运行的第一个容器，它是一个独立的应用程序，允许我们存储和分发Docker映像。 如果需要，您需要使用Docker Registry： </p><br><ul><li> 控制图像的存储位置 </li><li> 拥有图像分发服务器 </li><li> 将图像存储和分发集成到开发过程中 </li></ul><br><p> 这是有关启动和配置Docker Registry的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a> 。 </p><br><h3 id="podklyuchenie-docker-registry-i-gitlab"> 连接Docker Registry和GitLab </h3><br><p> 要将Docker Registry连接到GitLab，您需要运行具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HTTPS支持</a>的Docker Registry。 我使用“让我们加密”来获取证书，然后按照<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此说明</a>获取证书。 在确认可以通过HTTPS访问Docker Registry（您可以在浏览器中检查它）之后，请按照<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以下说明</a>将Docker Registry连接到GitLab。 这些说明根据您的GitLab安装和所需的配置而有所不同。 就我而言，设置是将Docker注册表证书和密钥添加到<code>/etc/gitlab/ssl</code> ，并将这些行添加到<code>/etc/gitlab/gitlab.rb</code> ： </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">registry_external_url</span></span> <span class="hljs-string"><span class="hljs-string">'https://docker.domain.com'</span></span> gitlab_rails [<span class="hljs-string"><span class="hljs-string">'registry_api_url'</span></span>] = <span class="hljs-string"><span class="hljs-string">"https://docker.domain.com"</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">重新配置GitLab之后</a> ，将出现一个新的注册表选项卡，其中提供了有关如何正确命名所创建图像的信息，以便它们出现在此处。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a54/6b0/f85/a546b0f853ab022249ef03232927461d.png"></p><br><h3 id="domen"> 域 </h3><br><p> 在我们的持续交付配置中，我们将自动为每个分支创建一个映像，如果该映像通过测试，它将在Docker Registry中发布并自动启动，因此我们的应用程序将从所有分支自动部署，例如： </p><br><ul><li>  <code>&lt;featureName&gt;.docker.domain.com</code>多个<code>&lt;featureName&gt;.docker.domain.com</code>分支 </li><li> 在<code>master.docker.domain.com</code>测试版本 </li><li>  <code>preprod.docker.domain.com</code>版本位于<code>preprod.docker.domain.com</code> </li><li> 产品版本位于<code>prod.docker.domain.com</code> </li></ul><br><p> 为此，我们需要一个域名和通配符DNS记录，该记录<code>* .docker.domain.com</code>请求重定向到<code>* .docker.domain.com</code>的IP地址。 另外，您可以使用各种端口。 </p><br><h3 id="nginx">  Nginx的 </h3><br><p> 由于我们有多个环境，因此我们需要自动将对子域的请求重定向到正确的容器。 为此，我们可以将Nginx用作反向代理。 这是一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">指南</a> 。 </p><br><h3 id="gui-instrumenty">  GUI工具 </h3><br><p> 要开始使用容器，可以使用命令行或图形界面之一。 有很多可用的，例如： </p><br><ul><li> 牧场主 </li><li> 微bad </li><li> 烤瓷器 </li><li> 简单的docker ui </li><li>  ... </li></ul><br><p> 它们允许您创建容器并通过GUI而不是CLI来管理它们。 这是Rancher的样子： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/574/485/d9c/574485d9c01d464510f79097f6b823b4.png" alt="牧场主"></p><br><h3 id="gitlab-runner">  Gitlab亚军 </h3><br><p> 和以前一样，要在其他服务器上运行脚本，我们需要安装GitLab运行程序。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章</a>中详细描述了这个问题。 </p><br><p> 请注意，您需要使用执行程序Shell，而不是Docker。 当您需要映像中的某些内容时（例如，在Java容器中创建Android应用程序时，并且仅需要apk），可以使用Executor Docker。 在我们的例子中，工件是整个容器，这需要执行程序外壳程序。 </p><br><h1 id="konfiguraciya-continuous-delivery"> 连续交付配置 </h1><br><p> 现在已经配置了所有必需的组件，您可以开始创建连续交付配置。 </p><br><h2 id="sborka-1"> 组装方式 </h2><br><p> 首先，我们需要组装一个图像。 </p><br><p> 与往常一样，我们的代码存储在<code>gitlab-ci.yml</code>中的CD配置库中，但是除此之外（为了提高安全性），我们还将在构建服务器上存储与映像相关的几个文件。 </p><br><h3 id="gitlabxml">  Gitlab.xml </h3><br><p> 包含CD的回调代码。 它是在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章中</a>开发的，可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">找到</a> 。 这是一个用于下载代码，运行各种回调和测试代码的小型库。 最好使用git子模块来包含此项目或您的存储库中的类似内容。 子模块更好，因为使它们保持最新状态更加容易。 另一种选择是在GitLab上创建一个发行版，并在构建时已经使用ADD命令下载它。 </p><br><h3 id="iriskey"> 虹膜键 </h3><br><p> 许可证密钥。 它可以在容器组装期间加载，而不存储在服务器上。 将密钥存储在存储库中是不安全的。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在WRC上</a>获得试用密钥<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>也可以尝试<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">InterSystems IRIS Experience</a> 。 </p><br><h3 id="pwdtxt">  pwd.txt </h3><br><p> 包含默认密码的文件。 同样，将密码存储在存储库中是相当不安全的。 </p><br><h3 id="load_ciscript">  load_ci.script </h3><br><p> 脚本： </p><br><ul><li> 在InterSystems IRIS中包括<a href="">OS身份验证</a> </li><li> 加载GitLab.xml </li><li> 初始化GitLab回调设置 </li><li> 加载代码 </li></ul><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">set</span></span> sc = ##Class(Security.System).Get(<span class="hljs-string"><span class="hljs-string">"SYSTEM"</span></span>,.Properties) write:(<span class="hljs-string"><span class="hljs-string">'sc) $System.Status.GetErrorText(sc) set AutheEnabled = Properties("AutheEnabled") set AutheEnabled = $ZBOOLEAN(+AutheEnabled,16,7) set Properties("AutheEnabled") = AutheEnabled set sc = ##Class(Security.System).Modify("SYSTEM",.Properties) write:('</span></span>sc) $System.Status.GetErrorText(sc) zn <span class="hljs-string"><span class="hljs-string">"USER"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ##<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>(%SYSTEM.OBJ).Load(##<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>(%File).ManagerDirectory() _ <span class="hljs-string"><span class="hljs-string">"GitLab.xml"</span></span>,<span class="hljs-string"><span class="hljs-string">"cdk"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ##<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>(isc.git.Settings).setSetting(<span class="hljs-string"><span class="hljs-string">"hooks"</span></span>, <span class="hljs-string"><span class="hljs-string">"MyApp/Hooks/"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ##<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>(isc.git.Settings).setSetting(<span class="hljs-string"><span class="hljs-string">"tests"</span></span>, <span class="hljs-string"><span class="hljs-string">"MyApp/Tests/"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ##<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>(isc.git.GitLab).load() halt</code> </pre> <br><p> 请注意，第一行故意留为空白。 如果此初始脚本始终相同，则可以将其保存到存储库中。 </p><br><h2 id="gitlab-ciyml">  gitlab-ci.yml </h2><br><p> 现在，让我们继续进行连续交付配置： </p><br><pre> <code class="hljs bash">build image: stage: build tags: - <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> script: - cp -r /InterSystems/mount ci - <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ci - <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'SuperUser'</span></span> | cat - pwd.txt load_ci.script &gt; temp.txt - mv temp.txt load_ci.script - <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> .. - docker build --build-arg CI_PROJECT_DIR=<span class="hljs-variable"><span class="hljs-variable">$CI_PROJECT_DIR</span></span> -t docker.domain.com/<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/docker:<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_NAME</span></span> .</code> </pre> <br><p> 这是怎么回事 </p><br><p> 首先，由于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">图像组装过程</a>只能访问基本目录的子目录（在本例中为存储库的根目录），因此需要将“ secret”目录（具有<code>GitLab.xml</code> ， <code>iris.key</code> ， <code>pwd.txt</code>和<code>load_ci.skript</code> ） <code>load_ci.skript</code>到克隆的存储库。 </p><br><p> 此外，访问终端需要输入用户名/密码，因此我们将它们添加到<code>load_ci.script</code> （为此，我们需要在<code>load_ci.script</code>的开头留空行）。 </p><br><p> 最后，我们创建一个Docker映像并将其命名为： <code>docker.domain.com/test/docker:$CI_COMMIT_REF_NAME</code> : <code>docker.domain.com/test/docker:$CI_COMMIT_REF_NAME</code> </p><br><p> 其中<code>$CI_COMMIT_REF_NAME</code>是分支的名称。 请注意：图像标签的第一部分必须与GitLab中存储库的名称匹配，以便可以在“注册表”选项卡上看到它（此处提供了正确标记的更多完整说明）。 </p><br><h3 id="dockerfile">  Docker文件 </h3><br><p>  Docker Image是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dockerfile</a>创建的，它是： </p><br><pre> <code class="hljs mel">FROM docker.intersystems.com/intersystems/iris:<span class="hljs-number"><span class="hljs-number">2018.1</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.613</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> ENV SRC_DIR=/tmp/src ENV CI_DIR=$SRC_DIR/ci ENV CI_PROJECT_DIR=$SRC_DIR COPY ./ $SRC_DIR RUN cp $CI_DIR/iris.key $ISC_PACKAGE_INSTALLDIR/mgr/ \ &amp;&amp; cp $CI_DIR/GitLab.xml $ISC_PACKAGE_INSTALLDIR/mgr/ \ &amp;&amp; $ISC_PACKAGE_INSTALLDIR/dev/Cloud/ICM/changePassword.sh $CI_DIR/<span class="hljs-keyword"><span class="hljs-keyword">pwd</span></span>.txt \ &amp;&amp; iris start $ISC_PACKAGE_INSTANCENAME \ &amp;&amp; irissession $ISC_PACKAGE_INSTANCENAME -U%SYS &lt; $CI_DIR/load_ci.script \ &amp;&amp; iris stop $ISC_PACKAGE_INSTANCENAME quietly</code> </pre> <br><p> 执行以下操作： </p><br><ul><li> 我们以InterSystems IRIS的形象为基础。 它应该在您的Docker Registry中。 如果您以前从未使用过Docker，请尝试<a href="">First Look：Docker</a> ，它描述了如何获取InterSystems IRIS映像，将其添加到Docker Registry中并手动启动它。 </li><li> 首先，将我们的存储库（和“秘密”目录）复制到容器内。 </li><li> 将许可证密钥和<code>GitLab.xml</code>复制到<code>mgr</code>目录。 </li><li> 将密码更改为<code>pwd.txt</code>的值。 请注意，在此操作过程中<code>pwd.txt</code>被删除。 </li><li> 启动InterSystems IRIS。 </li><li>  <code>load_ci.script</code>被<code>load_ci.script</code> 。 </li><li>  InterSystems IRIS停止。 </li></ul><br><div class="spoiler">  <b class="spoiler_title">这是部分构建日志</b> <div class="spoiler_text"><pre> <code class="hljs perl">Running with gitlab-runner <span class="hljs-number"><span class="hljs-number">10.6</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> (a3543a27) on docker <span class="hljs-number"><span class="hljs-number">7</span></span>b21e0c4 Using Shell executor... Running on docker... Fetching changes... Removing ci/ Removing temp.txt HEAD is now at <span class="hljs-number"><span class="hljs-number">5</span></span>ef9904 Build load_ci.script From http:<span class="hljs-regexp"><span class="hljs-regexp">//gitlab</span></span>.eduard.win/test/docker <span class="hljs-number"><span class="hljs-number">5</span></span>ef9904..<span class="hljs-number"><span class="hljs-number">9753</span></span>a8d master -&gt; origin/master Checking out <span class="hljs-number"><span class="hljs-number">9753</span></span>a8db as master... Skipping Git submodules setup $ cp -r /InterSystems/mount ci $ cd ci $ echo <span class="hljs-string"><span class="hljs-string">'SuperUser'</span></span> | cat - pwd.txt load_ci.script &gt; temp.txt $ mv temp.txt load_ci.script $ cd .. $ docker build --build-arg CI_PROJECT_DIR=$CI_PROJECT_DIR -t docker.eduard.win/test/docker:$CI_COMMIT_REF_NAME . Sending build context to Docker daemon <span class="hljs-number"><span class="hljs-number">401.4</span></span>kB Step <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> : FROM docker.intersystems.com/intersystems/iris:<span class="hljs-number"><span class="hljs-number">2018.1</span></span>.<span class="hljs-number"><span class="hljs-number">1.613</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> ---&gt; cd2e53e7f85<span class="hljs-number"><span class="hljs-number">0</span></span> Step <span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> : ENV SRC_DIR=<span class="hljs-regexp"><span class="hljs-regexp">/tmp/src</span></span> ---&gt; Using cache ---&gt; <span class="hljs-number"><span class="hljs-number">68</span></span>ba1cb00aff Step <span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> : ENV CI_DIR=$SRC_DIR/ci ---&gt; Using cache ---&gt; <span class="hljs-number"><span class="hljs-number">6784</span></span>c34a9ee6 Step <span class="hljs-number"><span class="hljs-number">4</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> : ENV CI_PROJECT_DIR=$SRC_DIR ---&gt; Using cache ---&gt; <span class="hljs-number"><span class="hljs-number">3757</span></span>fa88a28a Step <span class="hljs-number"><span class="hljs-number">5</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> : COPY ./ $SRC_DIR ---&gt; <span class="hljs-number"><span class="hljs-number">5515</span></span>e13741b<span class="hljs-number"><span class="hljs-number">0</span></span> Step <span class="hljs-number"><span class="hljs-number">6</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> : RUN cp $CI_DIR/iris.key $ISC_PACKAGE_INSTALLDIR/mgr/ &amp;&amp; cp $CI_DIR/GitLab.xml $ISC_PACKAGE_INSTALLDIR/mgr/ &amp;&amp; $ISC_PACKAGE_INSTALLDIR/dev/Cloud/ICM/changePassword.sh $CI_DIR/pwd.txt &amp;&amp; iris start $ISC_PACKAGE_INSTANCENAME &amp;&amp; irissession $ISC_PACKAGE_INSTANCENAME -U%SYS &lt; $CI_DIR/load_ci.script &amp;&amp; iris stop $ISC_PACKAGE_INSTANCENAME quietly ---&gt; Running in <span class="hljs-number"><span class="hljs-number">86526183</span></span>cf7c . Waited <span class="hljs-number"><span class="hljs-number">1</span></span> seconds <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> InterSystems IRIS to start This copy of InterSystems IRIS has been licensed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> exclusively by: ISC Internal Container Sharding Copyright (c) <span class="hljs-number"><span class="hljs-number">1986</span></span>-<span class="hljs-number"><span class="hljs-number">2018</span></span> by InterSystems Corporation Any other <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> is a violation of your license agreement %SYS&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> %SYS&gt; Using <span class="hljs-string"><span class="hljs-string">'iris.cpf'</span></span> configuration file This copy of InterSystems IRIS has been licensed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> exclusively by: ISC Internal Container Sharding Copyright (c) <span class="hljs-number"><span class="hljs-number">1986</span></span>-<span class="hljs-number"><span class="hljs-number">2018</span></span> by InterSystems Corporation Any other <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> is a violation of your license agreement <span class="hljs-number"><span class="hljs-number">1</span></span> alert(<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>) during startup. See messages.log <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> details. Starting IRIS Node: <span class="hljs-number"><span class="hljs-number">39702</span></span>b122ab6, Instance: IRIS Username: Password: Load started on <span class="hljs-number"><span class="hljs-number">04</span></span>/<span class="hljs-number"><span class="hljs-number">06</span></span>/<span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">21</span></span> Loading file /usr/irissys/mgr/GitLab.xml as xml Load finished successfully. USER&gt; USER&gt; [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.017</span></span>] Running init hooks: before [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.017</span></span>] Importing hooks dir /tmp/src/MyApp/Hooks/ [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.374</span></span>] Executing hook class: MyApp.Hooks.Global [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.375</span></span>] Executing hook class: MyApp.Hooks.Local [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.375</span></span>] Importing dir /tmp/src/ Loading file /tmp/src/MyApp/Tests/TestSuite.cls as udl Compilation started on <span class="hljs-number"><span class="hljs-number">04</span></span>/<span class="hljs-number"><span class="hljs-number">06</span></span>/<span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22</span></span> with qualifiers <span class="hljs-string"><span class="hljs-string">'c'</span></span> Compilation finished successfully in <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">194</span></span>s. Load finished successfully. [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.876</span></span>] Running init hooks: after [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.878</span></span>] Executing hook class: MyApp.Hooks.Local [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.921</span></span>] Executing hook class: MyApp.Hooks.Global Removing intermediate container <span class="hljs-number"><span class="hljs-number">39702</span></span>b122ab6 ---&gt; dea6b2123165 [Warning] One <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> more build-args [CI_PROJECT_DIR] were <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> consumed Successfully built dea6b2123165 Successfully tagged docker.domain.com/test/docker:master Job succeeded</code> </pre> </div></div><br><h2 id="zapusk-1"> 发射 </h2><br><p> 我们有一个图像，运行它。 对于要素分支，您可以简单地销毁旧容器并启动一个新容器。 对于产品环境，如果测试成功通过，我们可以先启动临时容器，然后更换中型容器。 </p><br><p> 首先，删除旧容器的脚本。 </p><br><pre> <code class="hljs ruby">destroy <span class="hljs-symbol"><span class="hljs-symbol">old:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">stage:</span></span> destroy <span class="hljs-symbol"><span class="hljs-symbol">tags:</span></span> - test <span class="hljs-symbol"><span class="hljs-symbol">script:</span></span> - docker stop iris-$CI_COMMIT_REF_NAME <span class="hljs-params"><span class="hljs-params">||</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> - docker rm -f iris-$CI_COMMIT_REF_NAME <span class="hljs-params"><span class="hljs-params">||</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p> 该脚本会破坏正在运行的容器并始终成功（默认情况下，Docker尝试停止/删除不存在的容器时会返回错误）。 </p><br><p> 之后，我们启动一个新容器并将其注册为环境。 </p><br><pre> <code class="hljs powershell">run image: stage: run environment: name: <span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_NAME</span></span> url: http://<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_SLUG</span></span>.docker.eduard.win/index.html tags: - test script: - docker run <span class="hljs-literal"><span class="hljs-literal">-d</span></span> -<span class="hljs-literal"><span class="hljs-literal">-expose</span></span> <span class="hljs-number"><span class="hljs-number">52773</span></span> -<span class="hljs-literal"><span class="hljs-literal">-volume</span></span> /InterSystems/durable/<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_SLUG:</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> -<span class="hljs-literal"><span class="hljs-literal">-env</span></span> ISC_DATA_DIRECTORY=/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/sys -<span class="hljs-literal"><span class="hljs-literal">-env</span></span> VIRTUAL_HOST=<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_SLUG</span></span>.docker.eduard.win -<span class="hljs-literal"><span class="hljs-literal">-name</span></span> iris-<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_NAME</span></span> docker.eduard.win/test/docker:<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_NAME</span></span> -<span class="hljs-literal"><span class="hljs-literal">-log</span></span> <span class="hljs-variable"><span class="hljs-variable">$ISC_PACKAGE_INSTALLDIR</span></span>/mgr/messages.log</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nginx容器</a>使用<code>VIRTUAL_HOST</code>环境<code>VIRTUAL_HOST</code>自动将请求重定向到指定的端口-在这种情况下为52773。 </p><br><p> 由于必须在InterSystems IRIS的主机上存储一些数据（密码，％SYS，应用程序数据），因此存在<a href="">Durable％SYS</a>功能，可以将数据存储在主机上，例如： </p><br><ul><li>  <code>iris.cpf</code>是主要配置文件。 </li><li>  <code>/csp</code>包含Web应用程序文件。 </li><li>  <code>/httpd/httpd.conf</code>和私有Apache服务器配置。 </li><li>  <code>/mgr</code>目录存储在其中： <br><ul><li> 数据库<code>IRISSYS</code> ， <code>IRISTEMP</code> ， <code>IRISAUDIT</code> ， <code>IRIS</code> ， <code>USER</code> 。 </li><li>  <code>IRIS.WIJ</code> 。 </li><li> 目录<code>/journal</code>存储杂志。 </li><li>  <code>/temp</code>目录中的临时文件。 </li><li> 记录<code>messages.log</code> ， <code>journal.log</code> ， <code>SystemMonitor.log</code> 。 </li></ul></li></ul><br><p> 要启用Durable％SYS，请指定<code>ISC_DATA_DIRECTORY</code>主机目录的<code>volume</code>参数，并且<code>ISC_DATA_DIRECTORY</code>变量设置用于存储Durable％SYS文件的目录。 该目录不应该存在，它将自动创建。 </p><br><p> 因此，我们的容器化应用程序的体系结构如下： </p><br><p><img src="https://habrastorage.org/webt/61/0q/ze/610qzezlqdilphfkapj5vac9t84.png" alt="容器化应用架构"></p><br><p> 要构建这样的应用程序，我们至少必须创建一个其他数据库（以保存应用程序代码）并在应用程序区域中创建其映射。 我使用<code>USER</code>范围存储应用程序数据，因为默认情况下将此范围添加到Durable％SYS。 应用程序代码存储在容器中，以便可以对其进行更新。 </p><br><p> 基于上述内容， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">％安装程序</a>应： </p><br><ul><li> 创建<code>APP</code>区/数据库 </li><li> 将代码上传到<code>APP</code>区域 </li><li> 在<code>USER</code>区域中创建我们的应用程序的映射类 </li><li> 执行其他配置（我创建了CSP Web应用程序和REST Web应用程序） </li></ul><br><div class="spoiler">  <b class="spoiler_title">代码％安装程序</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> MyApp.Hooks.<span class="hljs-keyword"><span class="hljs-keyword">Local</span></span> { Parameter Namespace = "APP"; /// See <span class="hljs-keyword"><span class="hljs-keyword">generated</span></span> code <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zsetup+<span class="hljs-number"><span class="hljs-number">1</span></span>^MyApp.Hooks.<span class="hljs-keyword"><span class="hljs-keyword">Local</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> XData Install [ XMLNamespace = INSTALLER ] { &lt;Manifest&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Log</span></span> <span class="hljs-type"><span class="hljs-type">Text</span></span>="Creating namespace ${Namespace}" <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span>="0"/&gt; &lt;Namespace <span class="hljs-type"><span class="hljs-type">Name</span></span>="${Namespace}" <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>="yes" Code="${Namespace}" Ensemble="" Data="IRISTEMP"&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Database</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span>="${Namespace}" Dir="/usr/irissys/mgr/${Namespace}" <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>="yes" MountRequired="true" Resource="%DB_${Namespace}" PublicPermissions="RW" MountAtStartup="true"/&gt; &lt;/<span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Import</span></span> File="${Dir}Form" Recurse="1" Flags="cdk" IgnoreErrors="1" /&gt; &lt;/Namespace&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Log</span></span> <span class="hljs-type"><span class="hljs-type">Text</span></span>="End Creating namespace ${Namespace}" <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span>="0"/&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Log</span></span> <span class="hljs-type"><span class="hljs-type">Text</span></span>="Mapping to USER" <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span>="0"/&gt; &lt;Namespace <span class="hljs-type"><span class="hljs-type">Name</span></span>="USER" <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>="no" Code="USER" Data="USER" Ensemble="0"&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Log</span></span> <span class="hljs-type"><span class="hljs-type">Text</span></span>="Mapping Form package to USER namespace" <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span>="0"/&gt; &lt;ClassMapping <span class="hljs-keyword"><span class="hljs-keyword">From</span></span>="${Namespace}" Package="Form"/&gt; &lt;RoutineMapping <span class="hljs-keyword"><span class="hljs-keyword">From</span></span>="${Namespace}" <span class="hljs-keyword"><span class="hljs-keyword">Routines</span></span>="Form" /&gt; &lt;/<span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>&gt; &lt;CSPApplication Url="/" Directory="${Dir}client" AuthenticationMethods="64" IsNamespaceDefault="false" <span class="hljs-keyword"><span class="hljs-keyword">Grant</span></span>="%ALL" Recurse="1" /&gt; &lt;/Namespace&gt; &lt;/Manifest&gt; } /// This <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> generator whose code <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">generated</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> XGL. /// Main setup <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> /// <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> vars("Namespace")="TEMP3" /// <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ##<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(MyApp.Hooks.<span class="hljs-keyword"><span class="hljs-keyword">Global</span></span>).setup(.vars) ClassMethod setup(ByRef pVars, pLogLevel <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> %<span class="hljs-type"><span class="hljs-type">Integer</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, pInstaller <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> %Installer.Installer) <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> %Status [ CodeMode = objectgenerator, <span class="hljs-type"><span class="hljs-type">Internal</span></span> ] { Quit ##<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(%Installer.Manifest).%Generate(%compiledclass, %code, "Install") } /// Entry <span class="hljs-type"><span class="hljs-type">point</span></span> ClassMethod onAfter() <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> %Status { try { <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> "START INSTALLER",! <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> vars("Namespace") = ..#Namespace <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> vars("Dir") = ..getDir() <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> sc = ..setup(.vars) <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> !,$<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Status.GetErrorText(sc),! <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> sc = ..createWebApp() } catch ex { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> sc = ex.AsStatus() <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> !,$<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Status.GetErrorText(sc),! } quit sc } /// Modify web app REST ClassMethod createWebApp(appName <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> %String = "/forms") <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> %Status { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>:$e(appName)<span class="hljs-string"><span class="hljs-string">'="/" appName = "/" _ appName #dim sc As %Status = $$$OK new $namespace set $namespace = "%SYS" if '</span></span>##<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Security</span></span>.Applications).<span class="hljs-keyword"><span class="hljs-keyword">Exists</span></span>(appName) { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> props("AutheEnabled") = $$<span class="bash"><span class="hljs-variable"><span class="bash"><span class="hljs-variable">$AutheUnauthenticated</span></span></span><span class="bash"> </span><span class="hljs-built_in"><span class="bash"><span class="hljs-built_in">set</span></span></span><span class="bash"> props(</span><span class="hljs-string"><span class="bash"><span class="hljs-string">"NameSpace"</span></span></span><span class="bash">) = </span><span class="hljs-string"><span class="bash"><span class="hljs-string">"USER"</span></span></span><span class="bash"> </span><span class="hljs-built_in"><span class="bash"><span class="hljs-built_in">set</span></span></span><span class="bash"> props(</span><span class="hljs-string"><span class="bash"><span class="hljs-string">"IsNameSpaceDefault"</span></span></span><span class="bash">) = $$</span></span>$<span class="hljs-keyword"><span class="hljs-keyword">NO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> props("DispatchClass") = "Form.REST.Main" <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> props("MatchRoles")=":" _ $$<span class="bash"><span class="hljs-variable"><span class="bash"><span class="hljs-variable">$AllRoleName</span></span></span><span class="bash"> </span><span class="hljs-built_in"><span class="bash"><span class="hljs-built_in">set</span></span></span><span class="bash"> sc = </span><span class="hljs-comment"><span class="bash"><span class="hljs-comment">##class(Security.Applications).Create(appName, .props) } quit sc } ClassMethod getDir() [ CodeMode = expression ] { ##class(%File).NormalizeDirectory($system.Util.GetEnviron("CI_PROJECT_DIR")) } }</span></span></span></span></code> </pre> </div></div><br><p> 我注意到要创建不在主机上的数据库，我使用目录<code>/usr/irissys/mgr</code> ，因为调用<code>##class(%File).ManagerDirectory()</code>返回Durable％SYS的目录路径。 </p><br><h2 id="testy"> 测验 </h2><br><p> 现在运行测试。 </p><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">test</span></span> image: stage: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> tags: - <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> script: - docker <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> iris-<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_NAME</span></span> irissession iris -U USER <span class="hljs-string"><span class="hljs-string">"##class(isc.git.GitLab).test()"</span></span></code> </pre> <br><h2 id="dostavka-2"> 派送 </h2><br><p> 测试通过后，我们将在Docker Registry中发布映像。 </p><br><pre> <code class="hljs pgsql">publish image: stage: publish tags: - test script: - docker <span class="hljs-keyword"><span class="hljs-keyword">login</span></span> docker.<span class="hljs-keyword"><span class="hljs-keyword">domain</span></span>.com -u <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> -p pass - docker push docker.<span class="hljs-keyword"><span class="hljs-keyword">domain</span></span>.com/test/docker:$CI_COMMIT_REF_NAME</code> </pre> <br><p> 可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">秘密变量</a>传递登录名/密码。 </p><br><p> 现在，图像显示在GitLab上。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/064/0b3/56f/0640b356f33ea72491c91d55399a4670.png"></p><br><p> 其他开发人员可以从Docker Registry下载它。 在“环境”选项卡上，可以查看我们所有的环境： </p><br><h1 id="vyvody"> 结论 </h1><br><p> 本系列文章讨论了持续集成的常用方法。 在InterSystems平台上自动化应用程序的组装，测试和交付是可能的，并且易于实现。 </p><br><p> 容器化技术的使用将有助于优化应用程序开发和部署过程。 消除环境之间的不一致使测试和调试更加容易。 编排允许您创建可伸缩的应用程序。 </p><br><h1 id="ssylki"> 参考文献 </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">InterSystems社区系列</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代号</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub代码</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN420749/">https://habr.com/ru/post/zh-CN420749/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN420731/index.html">关于类固醇的Zabbix：Sbertech的统一监控平台如何工作</a></li>
<li><a href="../zh-CN420735/index.html">我们邀请您参加Mail.Ru集团办公室的数字马拉松中的结局</a></li>
<li><a href="../zh-CN420737/index.html">迷你ai杯2或几乎是AgarIO-如何赢得比赛</a></li>
<li><a href="../zh-CN420739/index.html">盒子仍然在处理中：为什么在2018年您仍然需要自己学习语言</a></li>
<li><a href="../zh-CN420741/index.html">程序员备忘单或“我们将为您谷歌”</a></li>
<li><a href="../zh-CN420753/index.html">微服务前端-分离前端的现代方法</a></li>
<li><a href="../zh-CN420757/index.html">编程比赛：贸易（结果）</a></li>
<li><a href="../zh-CN420761/index.html">TypeScript 3.0</a></li>
<li><a href="../zh-CN420763/index.html">KDD 2018，第二天，研讨会</a></li>
<li><a href="../zh-CN420765/index.html">双子座PDA的印象。 口袋双靴式收割机还是没用的玩具？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>