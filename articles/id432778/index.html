<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍐 #⃣ 🧙 Pengembangan buck converter pada STM32F334: prinsip operasi, perhitungan, pembuatan prototipe 🗽 👸🏼 🍩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam dua artikel terakhir saya, saya berbicara tentang modul daya dan papan kontrol berdasarkan mikrokontroler STM32F334R8T6, yang dirancang khusus u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan buck converter pada STM32F334: prinsip operasi, perhitungan, pembuatan prototipe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432778/">  Dalam dua artikel terakhir saya, saya berbicara tentang modul daya dan papan kontrol berdasarkan mikrokontroler STM32F334R8T6, yang dirancang khusus untuk penerapan sistem kontrol untuk konverter daya dan drive listrik.  Contoh konverter DC / AC juga dipertimbangkan, yang merupakan demonstrasi, bukan konstruksi yang selesai.  Sekarang saatnya untuk melakukan sesuatu yang sederhana, tetapi bermanfaat, dan yang paling penting selesai. <br><br>  Sebagian besar masalah yang terkait dengan proyek dan elektronik daya terkait dengan topologi spesifik: seseorang tertarik mempelajari algoritma kontrol PFC, seseorang ingin belajar bagaimana membangun LLC setengah jembatan, tetapi topologi yang paling populer tidak diragukan lagi adalah tanggung jawab.  Bagaimanapun, buck converter (alias buck converter) adalah yang utama untuk proyek paling menarik: ini adalah driver untuk lampu LED, dasar dari pengontrol MPPT untuk panel surya, charger dan banyak lagi. <br><br>  Jaringan memiliki banyak informasi tentang buck, termasuk lembar data, tetapi tersebar dan saya pribadi belum menemukan materi yang menjelaskan secara rinci proses membuat konverter buck dengan kontrol digital.  Saatnya memperbaikinya.  Praktis tidak ada matematika, penjelasannya adalah "di jari", sehingga akan menarik bagi semua orang yang entah bagaimana terhubung dengan elektronik. <br><br> <a href=""><img src="https://habrastorage.org/webt/j4/jp/fv/j4jpfvx10zexln6bwiv8gd6dbkc.jpeg"></a> <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Pertama, Anda perlu memahami apa yang ingin kami dapatkan pada akhirnya dan pengantar apa yang kami miliki.  Topologi buck adalah step-down, artinya, Anda dapat membuat konverter tegangan step-down.  Seperti yang akan Anda lihat nanti, tegangan pada output buck converter hampir secara linear tergantung pada tegangan pada input, jadi Anda perlu menambahkan umpan balik.  Hari ini saya akan berbicara tentang umpan balik tegangan sederhana, yang merupakan yang paling intuitif dan akan memungkinkan Anda untuk memahami prinsip operasi, sementara umpan balik ini cukup bagi Anda untuk melaksanakan sebagian besar tugas. <br><br>  Pada akhir artikel kita akan mendapatkan sumber tegangan yang distabilkan sesuai dengan topologi “sinkron uang”, beroperasi pada frekuensi yang cukup tinggi dengan kontrol digital, diimplementasikan pada STM32F334R8T6 menggunakan High Resolution PWM (HRPWM).  Kisaran tegangan input adalah 15 ... 60V, tegangan output 12V, dan arus output maksimum adalah 2A. <br><br><h2>  Bab 1. Prinsip dari topologi buck </h2><br>  Saya akan mulai memberi tahu mulai dari yang paling dasar dan secara bertahap akan meningkatkan konverter kami, sebagai  "Sinkron uang" adalah versi versi yang disempurnakan dengan peningkatan efisiensi dan kompleksitas kontrol.  Versi dasar dari topologi yang mungkin Anda gunakan adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/of/mv/yq/ofmvyqyaxkystxgvsiiauznkfqs.png"><br><br>  Topologi ini digunakan pada konverter tegangan daya rendah, misalnya, untuk menghidupkan sirkuit digital dan perangkat berdaya rendah lainnya.  Menurunkan dc / dc yang Anda gunakan di perangkat Anda mungkin diterapkan pada sirkuit mikro menurut topologi ini.  Contoh dari chip tersebut adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LMR16006</a> . <br><br>  Prinsip operasi rangkaian ini sangat sederhana, sinyal PWM dipasok ke transistor VT1, pekerjaan itu sendiri dibagi menjadi 2 tahap, yang bergantian satu sama lain: <br><br><ul><li>  <b>Tahap penyimpanan energi di sirkuit LC.</b>  Pada tahap ini, transistor VT1 terbuka dan arus mengalir melalui transistor ke beban, secara bersamaan menyimpan energi dalam induktor dan kapasitansi keluaran: <br><br><img src="https://habrastorage.org/webt/xb/x9/fi/xbx9fi3blibz8mc6t-unq7qeaau.png"></li><li>  <b>Tahap pelepasan.</b>  Pada tahap ini, transistor VT1 menutup dan kemudian kesenangan dimulai.  Throttle - ini adalah hal yang mengakumulasi energi jika potensi diterapkan padanya (VT1 terbuka) dan memberikannya jika potensi menghilang (VT1 ditutup).  Pada saat yang sama, ia berusaha tidak hanya untuk memberikan energi, tetapi untuk menghemat nilai arus dan arahnya, oleh karena itu, untuk menggunakan properti ini, Anda perlu menambahkan dioda VD1 untuk menutup rangkaian, karena arus hanya mengalir dalam sirkuit tertutup: <br><br><img src="https://habrastorage.org/webt/fm/qr/z2/fmqrz2uboiwpztct_hjh9stsgws.png"></li></ul><br>  Ketika saya berkenalan dengan topologi ini di kelas 6-7, saya tidak segera mengerti mengapa dioda tidak melakukan arus pada tahap 1, sekarang sepertinya biasa, tapi saya pikir itu layak disebutkan.  Ketika VT1 terbuka, maka potensial + VIN, misalnya, + 20V, diterapkan pada katoda dioda VD1, dan potensial bumi, masing-masing, pada anoda dioda.  Agar arus mengalir melalui dioda, itu harus persis sebaliknya: potensi di anoda harus lebih besar daripada potensi di katoda, oleh karena itu, dalam buck-e, pada tahap penyimpanan energi, dioda "ditutup".  Pada tahap pelepasan, dioda sudah menutup sirkuit, potensial + VIN tidak bekerja pada katoda dan tidak "menguncinya".  Saya harap saya menjelaskan dengan jelas. <br><br>  Maka Anda harus memiliki pertanyaan: "Dan tegangan apa yang akan ada di output, jika kita menerapkan 20V ke input?".  Seperti biasa, semuanya sederhana: <br><br><img src="https://habrastorage.org/webt/hv/oz/g6/hvozg6kwwhf1nekotraxpmdo2gc.png"><br><br>  Seperti dapat dilihat dari rumus, tegangan keluaran secara linear tergantung pada faktor tugas sinyal PWM yang kami suplai ke transistor VT1.  Jika seseorang tidak tahu atau lupa "faktor tugas", ini adalah rasio waktu transistor dalam keadaan terbuka dengan lamanya periode.  Koefisien ini dapat mengambil nilai dari 0 hingga 1 atau dari 0 hingga 100%.  Lebih lanjut, kami akan beroperasi dengan angka khusus ini ketika mengendalikan konverter, tetapi untuk memahami esensi, mari gantikan hubungan ini ke dalam rumus: <br><br><img src="https://habrastorage.org/webt/c5/ij/ax/c5ijaxxjgvlviopshgx_uumfvh4.png"><br><br>  Frekuensi operasi buck converter adalah konstan dan dipilih selama desain, tidak berubah selama operasi, dan karenanya periode (T) konstan.  Ternyata tegangan output secara langsung tergantung pada dua kuantitas fisik: <br><br><ul><li>  dari waktu kita membuka transistor atas (VT1) - semakin lama terbuka, semakin banyak energi yang terakumulasi dalam filter LC dan, karenanya, tegangan output lebih tinggi; </li><li>  dari tegangan input, misalnya, jika kita memperbaiki pengisian sebesar 50% dan mengubah Vin dari 20 ke 40V, maka tegangan output juga akan berubah dari 10 menjadi 20V. </li></ul><br>  Saya pikir gambaran umum dan prinsip kerja sudah mulai menarik Anda, mari kita perbaiki sekarang dan lihat osilograms yang sebenarnya dan periksa perbandingan ini dalam praktik.  Saya telah menyusun tata letak uang yang dimuat dengan LED 10 W.  Saya menggunakan 3 saluran osiloskop, yang termasuk dalam poin-poin berikut: <br><br><img src="https://habrastorage.org/webt/xo/pd/by/xopdbyfozm6wgh3fgz8pdeuojum.png"><br><br>  <b>Pengalaman No. 1 - Tegangan input (Vin) konstan 20V, siklus tugas berubah</b> <br><br><ul><li>  Vin = 20V, D = 25%, Vout = D * Vin = 0.25 * 20V = 5V <br><br><img src="https://habrastorage.org/webt/i3/5k/p5/i35kp5uw2m0tsofihsydvow6xws.png"></li><li>  Vin = 20V, D = 50%, Vout = D * Vin = 0,5 * 20V = 10V <br><br><img src="https://habrastorage.org/webt/lg/zt/bb/lgztbbg8ztwdqwwni9zfgzrdyg4.png"></li></ul><br>  Seperti yang Anda lihat pada bentuk gelombang, hubungan antara tegangan output dan siklus kerja sudah benar.  Tentu saja, ini adalah percobaan "ideal", dalam kenyataannya, tegangan input tidak stabil dan mengapung dalam kisaran yang cukup luas.  Mari kita lihat ketergantungan pada tegangan input pada pengisian yang tetap. <br><br>  <b>Pengalaman No. 2 - Tegangan input (Vin) berubah, siklus tugasnya konstan dan sama dengan 50%</b> <br><br><ul><li>  Vin = 15V, D = 50%, Vout = D * Vin = 0,5 * 15V = 7.5V <br><br><img src="https://habrastorage.org/webt/er/at/_k/erat_kgnli3usl6pf2gnvs4tgky.png"></li><li>  Vin = 20V, D = 50%, Vout = D * Vin = 0,5 * 20V = 10V <br><br><img src="https://habrastorage.org/webt/u7/_1/ek/u7_1ekajdvcyhccqmttgiiiqbzy.png"></li><li>  Vin = 30V, D = 50%, Vout = D * Vin = 0,5 * 30V = 15V <br><br><img src="https://habrastorage.org/webt/ak/1z/na/ak1znaux-gyaj1o6uxx49ewcisu.png"></li></ul><br>  Sekarang kita telah melihat dalam prakteknya bahwa tegangan keluaran juga secara linear tergantung pada tegangan input pada siklus tugas tetap.  Apakah Anda sudah mengerti bagaimana ini akan menstabilkan output?  Prinsip stabilisasi sederhana seperti rumus itu sendiri - Vout adalah 12V dan konstan, kita dapat mengubah siklus tugas dengan bantuan mikrokontroler, jadi jika Vin meningkat, tegangan output juga meningkat dan pada saat ini kita mengurangi faktor tugas hingga menjadi 12V lagi.  Dengan demikian, ketika Vin menurun, kita mulai meningkatkan siklus tugas sampai lagi tegangan Vout menjadi 12V. <br><br>  Apa lagi yang ingin saya perhatikan di bagian teoretis ... Ah, ya!  Tentunya Anda bertanya-tanya bagaimana sebuah PWM dengan amplitudo 20V setelah sebuah transistor akhirnya berubah menjadi tegangan konstan dengan riak minim?  Memang, jika kita meletakkan probe merah osiloskop pada sumber transistor VT1, probe hijau setelah filter LC, kita akan melihat gambar berikut: <br><br><img src="https://habrastorage.org/webt/pe/3o/ox/pe3ooxj5ghth4p2ibxtpubt-rg8.png"><br><br>  Anda dapat melihat bagaimana filter LC “melumasi” tegangan bolak-balik menjadi tegangan konstan, tetapi masalahnya adalah bahwa energi yang disimpan dalam induktansi dan kapasitansi tidak dapat dikonsumsi secara instan, oleh karena itu tegangan tidak dapat berubah secara instan.  Kami mendapatkan bahwa pada saat ketika PWM di depan induktor menjadi 0V, tegangan output disediakan oleh energi yang tersimpan dalam filter, yang tidak menyerap segera dan cukup untuk mempertahankan tegangan pada saat VT1 ditutup.  Semuanya ada di jari, tentu saja, jika menarik untuk menggali lebih dalam, maka seperti biasa saya menyarankan <b>B. Yu.</b>  <b>Semenova "Power Electronics: dari yang sederhana sampai yang kompleks"</b> , ada bab lengkap tentang uang (perajang). <br><br><h3>  Perjuangan untuk efisiensi </h3><br>  Seperti yang saya tulis sebelumnya, ini adalah versi dasar dari topologi.  Kerugian utamanya adalah kerugian tinggi pada dioda penguncian.  Apa arus dalam sistem sederhana yang beroperasi pada MK dan CPLD?  Biasanya dalam 1A, kadang-kadang 2A, jika ada semacam layar TFT.  Dalam hal ini, kerugian bahkan saat menggunakan dioda Schottky adalah 0,4V * 2A = 0,8 watt.  Pada prinsipnya, lumayan untuk menghilang begitu banyak pada paket SMA / SMB tanpa masalah, meskipun dengan tegangan 3,3V dan 2A, kehilangan 0,8V masih merupakan efisiensi 12%! <br><br>  Sekarang bayangkan kasus saat ini yang kita miliki adalah 20A.  Ini bisa menjadi pengontrol MPPT, sistem daya FPGA besar, dan banyak lagi.  Dalam hal ini, kerugiannya adalah 0.4V * 20A = 8 W!  Apa artinya ini?  Misalnya, dalam kasus MPPT, Anda akan memiliki lebih sedikit energi yang tersimpan dalam baterai, dalam kasus daya FPGA itu akan menjadi tambahan 8 watt panas, yang harus dihamburkan di suatu tempat dan dalam kedua kasus ini tidak diragukan lagi adalah kehilangan efisiensi keseluruhan.  Apa yang bisa dilakukan?  Dan mari kita ganti dioda VD1 dengan N-channel Mosfet lain dan dapatkan sirkuit ini: <br><br><img src="https://habrastorage.org/webt/nb/om/7b/nbom7baf8horcmhuevpeeelxkoc.png"><br><br>  Sekarang transistor VT2 bertindak sebagai dioda, yaitu melakukan arus ketika VT1 ditutup.  Dioda, yang berada di versi dasar, tidak memerlukan kontrol, sekarang kami dipaksa untuk membayar saluran kontrol tambahan dengan sinyal PWM untuk meningkatkan kinerja. <br><br>  Pertama, mari kita hitung berapa banyak kerugian yang telah kita kurangi.  Hambatan saluran MOSFET modern adalah beberapa megohms.  Sebagai contoh, mari kita ambil transistor dari modul power saya, yang saya bicarakan di artikel sebelumnya - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IPP083N10N5AKSA1</a> dengan hambatan saluran sebesar 8,3 mOhm.  Kami mendapatkan kerugian statis sama dengan 0,0083 * 20A * 20A = 3,32 watt.  Tentu saja, akan ada kerugian dinamis, yang dengan driver yang dirancang memadai tidak akan lebih dari 20%, yaitu, total kerugian bagi kita adalah 4 watt.  Kami mendapatkan bahwa transisi dari uang konvensional ke yang sinkron dapat mengurangi separuh hilangnya dioda. <br><br>  Sekarang mari kita lihat manajemen yang lebih rumit.  Seperti yang sudah kita pahami, dioda penguncian sedang mengalirkan arus ketika VT1 ditutup.  Dari sini dapat dikatakan bahwa VT2 harus ditutup ketika VT1 terbuka dan, karenanya, VT2 terbuka ketika VT1 ditutup.  Jika lebih sederhana, transistor bekerja secara bergantian: salah satu terbuka atau yang lain, jika kedua transistor terbuka, akan ada arus yang lewat, karena  mereka saling terhubung antara VIN dan GND.  Mari kita lihat apa sinyalnya, di mana "saluran kuning" adalah transistor VT1 dan "saluran hijau" adalah transistor VT2: <br><br><img src="https://habrastorage.org/webt/wu/bc/mo/wubcmogqwk-__w6eroszeyozsv0.png"><br><br>  Seperti yang Anda lihat, jika "1" logis diatur di saluran kuning (di VT1), maka pada saat itu logis "0" harus diatur di saluran hijau (di VT2).  Kami mendapatkan bahwa VT1 memompa energi ke dalam filter LC, dan VT2 menutup sirkuit pada tahap pelepasan. <br><br>  Ada satu hal lagi yang sudah Anda dengar atau baca di atas - <b>sampai saat ini</b> .  Faktanya adalah bahwa nyata, bukan transistor ideal (MOSFET) memiliki kapasitansi tertentu di gerbang, yaitu, pada kenyataannya itu tidak langsung pergi dari log.0 ke log.1, dan energi dalam transistor tidak larut secara instan, menghasilkan transistor untuk waktu yang singkat pada saat peralihan, keduanya mungkin terbuka.  Hal ini dapat mengarah pada peningkatan kerugian, yang berarti pemanasan dan, paling buruk, ke babah, karena  melalui arus adalah hubungan pendek yang umum (hubungan pendek).  Untuk menghindari hal ini, penundaan atau apa yang disebut dead time diperkenalkan antara mematikan satu transistor dan menghidupkan yang lain.  Ini terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/u8/wg/if/u8wgifnybpzrkjg1gfxua-w0gye.png"><br><br>  Saya pikir Anda memperhatikan bahwa ada celah kecil di batas sinyal switching.  Saya menginstalnya dengan sengaja besar (sekitar 3%) sehingga Anda bisa melihatnya, pada kenyataannya jauh lebih kecil.  Secara umum, waktu mati (selanjutnya dt) diatur sesingkat mungkin, tetapi pada saat yang sama cukup untuk memungkinkan transistor untuk menutup.  Itu dapat dihitung, atau dapat dipilih secara empiris, saya pribadi berpikir bahwa opsi ini dan itu adalah normal, tetapi Jedi yang berjanggut mungkin akan memberi tahu Anda: "Ini perlu untuk dipertimbangkan, tetapi lebih baik untuk memodelkannya!"  Ini memang benar, tetapi putuskan sendiri - jika Anda tidak terlalu malas, model dalam LTspice dengan mempertimbangkan induktansi dan kapasitansi konduktor dan komponen yang menyimpang. <br><br>  Untuk stand di artikel ini, saya atur dt ke ~ 100 ns (sebenarnya 104).  Modul saya memungkinkan Anda untuk menginstalnya lebih sedikit, karena  drivernya sangat keras diterapkan, tetapi yang pasti banyak dari Anda akan membangun tata letak Anda tanpa modul saya, yang berarti bahwa kemungkinan besar akan ada ingus.  Agar saya tidak terjebak karena ingus, saya akan meninggalkan dt dengan margin dan jika Anda memiliki kabel normal di papan tulis, maka Anda sendiri dapat menguranginya - maka pada bab tentang kode Anda akan melihat caranya, untuk saat ini, kita melihat apakah memang ada dt: <br><br><img src="https://habrastorage.org/webt/b-/tm/ft/b-tmftfkzmq7xezwdbbd67gaxf4.png"><br><br>  Dapat dilihat bahwa dt berlangsung 2,5 divisi dan setiap divisi adalah 40 ns, yang berarti durasinya ~ 100 ns, seperti yang dimaksudkan.  Saya harap Anda mengerti mengapa dt diperlukan, berapa lama durasinya, dan bagaimana konverter bekerja sesuai dengan topologi buck.  Jika Anda tidak mengerti, maka seperti biasa, pertanyaan dalam komentar, PM dan surat diterima, sementara saya sepertinya menjawab semua orang. <br><br><h2>  Bab 2. Perhitungan komponen utama </h2><br>  Pada bagian artikel ini, saya akan menunjukkan cara cepat dan mudah menghitung komponen daya utama untuk konverter buck sinkron, yaitu: induktor, kapasitor input dan output, transistor. <br><br>  <u>Biarkan saya mengingatkan Anda input data:</u> <br><br><ul><li>  Tegangan input: 15 ... 30V </li><li>  Tegangan output: 12V </li><li>  Nilai arus keluaran: 2A </li><li>  Frekuensi switching: 100 kHz </li></ul><br>  Tegangan output 12V dipilih karena  Saya berencana untuk menggunakan LED 12V 20W sebagai beban, yang ternyata sudah dekat dan merupakan beban yang sangat jelas.  Mengantisipasi pertanyaan "pakar" dalam komentar - ya, saya sadar bahwa LED membutuhkan stabilisasi saat ini, tetapi kami kemudian melakukan stabilisator tegangan dan LED hanya memuat. <br><br>  Tegangan input dipilih dari bulldozer, Anda dapat melakukan 15 ... 60V, jadi jika Anda tertarik pada rentang yang berbeda, maka Anda dapat menghitung nilai komponen untuk itu sendiri.  Arus pengenal 2A dipilih untuk mendapatkan daya output 12V * 2A = 24 W, yaitu, sedikit lebih banyak dari yang dibutuhkan untuk LED.  LED itu sendiri pada 12V mengkonsumsi sekitar 1,82 ... 1,9A. <br><br>  Parameter yang paling menarik tetap - frekuensi operasi konverter.  Apa yang seharusnya?  Anda harus menjawab sendiri di sini, dalam kasus saya 100 kHz.  Pilihannya didasarkan pada dua poin: <br><br><ul><li>  Peningkatan frekuensi menyebabkan penurunan induktansi yang diperlukan dari induktor, input dan output kapasitor.  Sederhananya - dengan peningkatan frekuensi, dimensi perangkat berkurang.  Dengan penurunan frekuensi, dimensi bertambah. </li><li>  Penurunan frekuensi menyebabkan peningkatan efisiensi, karena  kerugian dinamis ketika berpindah transistor dikurangi.  Meningkatkan frekuensi meningkatkan komponen dinamis dari transistor dan karenanya mengurangi efisiensi. </li></ul><br>  Sekarang saya tidak akan membahas pilihan frekuensi, anggap saja 100 kHz.  Setelah saya menunjukkan metodologi perhitungan, kami akan kembali ke pertanyaan ini, karena  menurut formula, ketergantungan peringkat komponen utama pada frekuensi operasi akan lebih jelas terlihat. <br><br>  <b>Langkah 1. Memilih Transistor</b> <br><br>  Kami terutama akan tertarik pada 3 parameter: "sumber-drain" tegangan maksimum, resistansi saluran dalam keadaan terbuka dan kapasitansi gerbang.  Potensi penuh dari sumber tegangan (Vin) diterapkan pada transistor, dan ada juga lonjakan pada saat switching.  Anda memiliki 2 opsi: ambil transistor VT1 dan VT2 dengan margin tegangan atau kisah snubber RC pada VT2.  Dalam kasus saya, modul daya memiliki 100V transistor, dan dengan input 30V ini adalah margin tegangan yang sangat besar, bahkan 60V sudah cukup untuk dilakukan tanpa snubber dan melindungi transistor dari gangguan. <br><br>  Resistansi saluran - semakin kecil semakin baik, tetapi ada satu TAPI.  Dengan penurunan tahanan saluran, kami mengurangi kerugian statis (I <sup>2</sup> * R), tetapi teknologinya sedemikian rupa sehingga kapasitansi gerbang meningkat, dan ini mengarah pada peningkatan kerugian dinamis.  Anda harus menemukan jalan tengah antara "tahanan saluran" dan "kapasitas rana".  Untuk voltase hingga 100V, saya sarankan Anda memperhatikan transistor seri Infineon OptiMOS, sudah lihat sendiri voltase tinggi dengan pencarian parametrik atau bahkan terhadap transistor IGBT.  Yang terakhir ini juga didukung oleh modul daya saya dan tidak memerlukan perubahan apa pun pada driver. <br><br>  <b>Langkah 2. Perhitungan induktansi induktor</b> <br><br>  Penting untuk menghitung nilai minimum induktansi, yang akan memungkinkan konverter dc / dc kami bekerja dalam mode arus kontinu ( <sub>Lmnt</sub> ): <br><br><img src="https://habrastorage.org/webt/mj/np/-j/mjnp-jzmvy7qfodji_da3ryjeya.png"><br><br>  Dalam hal variabel, saya pikir semuanya jelas kecuali - k <sub>ind</sub> .  Ini adalah arus riak yang diizinkan dalam induktor, mereka biasanya memilih nilai 20 ... 50%, tapi saya hampir selalu menetapkan 30%.  Semakin kecil riak arus, semakin jauh kita akan dari batas saturasi inti di mana induktor dilukai, tetapi seperti yang dapat dilihat dari rumus, induktansi besar dari induktor diperlukan. <br><br>  Sekarang kita menghitung nilai minimum induktansi, yang akan diperlukan untuk data input saya, riak saya akan meletakkan 30% seperti yang saya tulis di atas: <br><br><img src="https://habrastorage.org/webt/ri/t9/2h/rit92hfsubagcqaozaebmcl7alw.png"><br><br>  Harus dipahami bahwa ini adalah induktansi minimum yang diperlukan untuk buck converter untuk beroperasi dalam mode arus yang tidak dapat dipisahkan, tetapi sekali lagi ada nuansa.  Dalam proses meningkatkan arus yang bekerja dalam belitan, permeabilitas inti dan induktansi induktor TANPA arus dan Dengan arus yang agak berbeda, ketergantungannya berbeda untuk bahan yang berbeda.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menghindari situasi ketika, dengan peningkatan arus dalam induktor, induktansi berkurang di bawah L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan dc / dc tidak masuk ke mode melanggar arus, perlu untuk meningkatkan induktansi agak, yaitu, tambahkan beberapa putaran tambahan selama belitan. Peningkatan induktansi 10-15% akan cukup untuk bahan Kool Mu, dan choke saya akan di atasnya. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah 3. Perhitungan dan pembuatan induktor</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saya ingin menjelaskan prosedur ini di bagian "prototyping", tetapi kemudian langkah menghitung induktansi akan tetap kurang jelas bagi Anda, dan saya mungkin melewatkan gambar yang menarik, jadi saya akan menjelaskan semuanya di sini. Untuk pembuatan throttle saya akan mengambil throttle R26 / 14/11 (R adalah cincin, dan angka adalah dimensi) dari bahan Kool Mu dengan permeabilitas 60, Anda dapat mengunduh dokumentasi untuk itu dan membelinya di sini -</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lepkos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/webt/kc/mp/e1/kcmpe19wpeprrdiz0qznmnefxyk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang Anda perlu menghitung berapa belokan dan kawat mana yang Anda butuhkan untuk berputar. Mari kita mulai dengan jumlah belokan mungkin. Ada parameter yang mudah digunakan dalam dokumentasi untuk core - A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang sama dengan 75 nH / turn </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Di sini dengan hati-hati - berubah dalam kotak! Untuk menemukan induktansi inti, kalikan </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AL</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan jumlah putaran di kotak. Dari sini rumus untuk menemukan jumlah putaran tampak seperti ini: </font></font><br><br><img src="https://habrastorage.org/webt/ls/dn/zr/lsdnzrojp7ab0aijmv46pxllh0q.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendapatkan induktansi minimum yang diperlukan, perlu memutar 40 putaran, tetapi seperti yang telah kita bahas, perlu sedikit meningkatkan induktansi, mari kita tambahkan 3 putaran. Kami mengambil cincin dan memutar 43, kami mendapatkan throttle seperti:</font></font><br><br><img src="https://habrastorage.org/webt/un/5e/ij/un5eijbi_ksbefygjbn4pkrckli.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, demi kepentingan, kami menghitung induktansi apa yang harus dihasilkan: </font></font><br><br><img src="https://habrastorage.org/webt/rj/yl/mm/rjylmmkynrrleoebfmoilq1oyzm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan untuk keandalan, kami memeriksa induktansi induktor dengan pinset: </font></font><br><br><img src="https://habrastorage.org/webt/tm/ze/qj/tmzeqjuzno3yp3tkpkcmy8jozoa.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">137 μH, bagus! Hasil berkumpul, kesalahan dalam ± 8% ke A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Layak disebutkan bahwa jika Anda tidak memiliki kemampuan untuk mengukur induktansi, jangan membeli core untuk aliexpress, di ChiD, komputer, insinyur elektronik dan "restoran" lainnya - ada peluang untuk mendapatkan inti dari bahan lain atau dengan permeabilitas yang salah, tetapi dengan penandaan yang benar - diverifikasi. Tanpa kemampuan untuk mengukur induktansi, Anda tidak akan dapat memeriksa A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan Anda akan dapat menyiksa diri sendiri dalam mencari penyebab "babakh" konverter Anda.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini menimbulkan pertanyaan yang masuk akal - “akankah kita memiliki inti yang cukup dan dimensinya? Mungkin itu perlu lagi? " Untuk material Kool Mu, batas induksi magnetik adalah 0,5 T, dalam praktiknya, lebih baik tidak merangkak melampaui ambang batas di atas 0,45 T tanpa perlu jelas. Ternyata luka berliku pada inti tidak harus membuat induksi pada setiap titik inti lebih dari 0,45 T, jadi kami memeriksa: </font></font><br><br><img src="https://habrastorage.org/webt/1w/vf/me/1wvfmenl-jqsxqbnhsj-itnzgoe.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat, nilai induksi magnetik 0,06 T jauh lebih rendah daripada batas 0,5 T. Dua kesimpulan dapat ditarik dari ini: pertama, throttle tidak akan masuk ke saturasi, dan kedua, inti sangat besar dan kuat untuk mengambil cincin yang jauh lebih kecil. Saya mengambil cincin R26 hanya karena saya memiliki seluruh kotak mereka, tidak ada makna rahasia lainnya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masih menentukan bagian mana dari kawat yang akan diambil untuk induktor. Pertama, saya sangat menyarankan Anda untuk tidak mengambil kawat dengan diameter lebih dari 1 ... 1,2 mm pada frekuensi tinggi, karena efek kulit sudah memiliki efek signifikan dan mengurangi penampang yang efektif. Kedua, kerapatan arus pada kawat harus dipilih berdasarkan kondisi pendinginan dan daya. Pada daya rendah (hingga 10-20 W), Anda dapat dengan aman meletakkan kerapatan arus 8,10 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bahkan tanpa aliran udara. Pada daya hingga beberapa kilowatt, lebih baik untuk meletakkan kerapatan arus di kisaran 5 ... 6 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan pada daya dari 10 kW dan seterusnya akan masuk akal untuk mengurangi kerapatan arus menjadi 3 ... 4 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di ujung jari saya ada kawat yang dipernis dengan diameter 0,8 mm. Potongan melintangnya masing-masing adalah ~ 0,5 mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pada arus 2A, kami memperoleh kerapatan arus dalam belitan sekitar 4 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Saya bisa menggunakan kawat dengan setengah bagian melintang, tetapi inti saya cukup besar, sehingga kawat yang lebih besar cocok tanpa masalah. Ketika Anda mengoptimalkan perangkat Anda, pertama-tama Anda harus menghitung, dan kemudian membeli kawat dari penampang yang diinginkan, maka Anda bisa mendapatkan dimensi optimal dari induktor. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah 4. Perhitungan kapasitor output</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahap ini, seperti dalam kasus induktansi, kami akan mempertimbangkan nilai minimum kapasitansi yang harus dipasang di filter LC pada output buck converter. Dengan demikian, jika Anda menginstal lebih banyak, itu akan lebih baik dan kemudian lihat alasannya. Mari kita hitung kapasitasnya: </font></font><br><br><img src="https://habrastorage.org/webt/qn/_v/sf/qn_vsfifikijddrrspohgtod9a8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, kapasitasnya juga harus diberi margin, terutama jika Anda hanya menggunakan keramik di outlet, karena kapasitasnya sangat berkurang tergantung pada tegangan yang diberikan padanya. Perlu juga diperhatikan ketergantungan pada denyut nadi - variabel V </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pulsa</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini adalah nilai maksimum dari riak pada output, yaitu, idealnya, dengan kapasitansi 147,8 μF, amplitudo riak akan 0,2V, yaitu, tegangan output akan mengambang di kisaran 11,9 ... 12.1V. Ingin mengurangi riak? Kemudian kurangi dalam rumus dan nilai kapasitas yang dihasilkan akan meningkat sesuai, tentu saja, Anda tidak akan mendapatkan catu daya laboratorium hanya dengan meningkatkan kapasitas output. Penting juga untuk memperhitungkan kebutuhan akan ESR rendah, untuk ini mereka biasanya menempatkan 1-2 elektrolit secara paralel dan menggantung keramik pada beberapa mikrofarad dengan dielektrik X7R, lebih disukai. Jika anggaran memungkinkan, maka mungkin untuk mengganti kapasitor elektrolitik dengan polimer tantalum (seperti pada GPU), dan karena itu keramik tidak diperlukan, mereka memiliki ESR yang kecil. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertimbangan frekuensi</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, seperti yang saya katakan, kita akan kembali ke pertanyaan memilih frekuensi operasi konverter. </font><font style="vertical-align: inherit;">Biarkan saya membagi kesimpulan menjadi beberapa pemikiran:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seperti yang Anda lihat dalam rumus, frekuensi muncul, semakin tinggi frekuensi operasi, semakin rendah induktansi dari induktor akan diperlukan dan semakin sedikit belokan harus terluka - kami menghemat tembaga dan menyederhanakan pembuatan produk berliku </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Induktansi dan jumlah belokan ada dalam rumus untuk menghitung induksi magnetik, meskipun seperti yang Anda ingat, induktansi memiliki ketergantungan kuadrat pada belokan, yang berarti bahwa ketika jumlah putaran berkurang 2 kali, induktansi berkurang 4 kali. </font><font style="vertical-align: inherit;">Dari sini dapat disimpulkan bahwa dengan meningkatnya frekuensi, induktansi dan nilai induksi magnetik berkurang, yang berarti bahwa inti yang lebih kecil dapat digunakan, yaitu, kita mengurangi dimensi</font></font></li><li>      ,     —     ,     ,    .  ! </li><li>   …  ,              .          buck-  mosfet-  200   .    ( )   ?     GaN     </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya pikir dari tesis ini menjadi jelas bagi Anda apa yang mempengaruhi frekuensi switching, sekarang Anda perlu belajar bagaimana menemukan "makna emas" antara kerugian pada transistor dan ukuran perangkat sendiri. </font><font style="vertical-align: inherit;">Dalam salah satu artikel berikut ini saya akan mengajarkan Anda untuk mengoptimalkan frekuensi operasi untuk efisiensi maksimum, hal utama adalah jangan lupa bahwa saya akan melakukannya.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bab 3. Merakit tata letak buck converter </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, bagian yang paling membosankan, tetapi penting, sudah berakhir, sekarang perangkat keras dan kode akan hilang. Mari kita susun tata letak di mana kita akan menerapkan perhitungan teoritis. Untuk melakukan ini, Anda akan memerlukan dua modul yang saya bicarakan di artikel sebelumnya: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modul daya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modul kontrol pada STM32F334</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Anda juga dapat merakit setengah jembatan sendiri dari sampah improvisasi tipe IR2110 pada papan tempat memotong roti, dan menggunakan MK apa pun sebagai kontrol: STM32-Discovery, LaunchPad, Arduino dan hanya mengadaptasi logika kerja dan kode ke MK favorit Anda, tidak ada yang rumit jika Anda mengerti dari dua bab pertama cara kerja konverter uang.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang mari kita buat diagram buck kita lebih "realistis" dengan menambahkan nilai-nilai semua komponen ke dalamnya dan dengan benar mencerminkan jumlah kapasitor, serta perhatikan bagian apa yang dapat disadari oleh modul daya saya:</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/bo/qw/hx/boqwhxzou-myasxcamvspvq_oac.png"></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang dapat Anda lihat dari diagram, modul sudah berisi setengah jembatan (dua transistor) untuk menerapkan buck sinkron dan kapasitor input, omong-omong, modul ini berdiri di modul dengan margin besar - masing-masing ada 3 elektrolit 1000 uF dan 100V, ini cukup untuk dengan mudah mengumpulkan uang seharga 500 -800 watt Tetap bagi kami untuk menambahkan choke, yang telah kami produksi dan output kapasitor, yang terakhir juga dengan cara dengan margin, karena Saya hanya menemukan 4700 uF 25V untuk tegangan rendah, tetapi mereka adalah semacam Cina, jadi saya juga memutuskan untuk memparalelkan pasangan. Faktanya, ada cukup 470 uF di sana, tetapi saya tidak memiliki hal sepele dalam versi output. Ternyata desain ini:</font></font><br><br><img src="https://habrastorage.org/webt/sh/_r/ku/sh_rkup3otnnyiokil-egegoena.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti disebutkan sebelumnya, LED 20 W yang kuat digunakan sebagai beban. </font><font style="vertical-align: inherit;">Saya tidak tahu berapa banyak cahaya bersinar, dan itu tidak terlalu menarik, tetapi hanya mengkonsumsi 21 ... 22 W pada 12 V di mana konverter uang saya dirancang. </font><font style="vertical-align: inherit;">LED itu sendiri melapisi KPT-8 dan memasangnya ke radiator, tentu saja itu tidak cukup, tetapi berlangsung selama 5-7 menit tanpa masalah (memanas hingga +40 ... 50 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C), dan saya tidak perlu lagi. </font><font style="vertical-align: inherit;">Kami menghubungkan 2 HRPWM, sinyal GND dari modul kontrol dan, melalui pembagi, kami menghubungkan output uang ke ADC, sebagai hasilnya, kami memiliki pendirian:</font></font><br><br><img src="https://habrastorage.org/webt/dl/ll/9v/dlll9v0povwnn86na34l1z1nvtc.jpeg"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bab 4. Menulis perangkat lunak dan memulai konverter </font></font></h2><br>  Sekarang kita memiliki semua yang kita butuhkan untuk mulai menulis kode dan merevitalisasi konverter uang kita.  Pertama, mari kita lihat pin-out untuk mikrokontroler STM32F334R8T6, yang terletak di modul kontrol: <br><br><img src="https://habrastorage.org/webt/bw/0i/ao/bw0iaobhw935ug8xttkq_q73uio.png"><br><br>  Sekarang kita mengerti pin mikrokontroler mana yang akan digunakan.  Pada modul itu sendiri, saya hanya perlu 1 dari 5 saluran untuk mengontrol unit daya, kita akan menggunakan saluran "A".  Saluran ini, seperti yang lainnya, memiliki 2 output PWM presisi tinggi (HRPWM), 1 input kesalahan (kami tidak menggunakannya), GND untuk menggabungkan ground board dan 2 saluran ADC (kami hanya akan menggunakan satu untuk voltase). <br><br>  <b>Sedikit tentang HRPWM</b> <br><br>  Dalam perluasan segmen bahasa Rusia di Internet, saya hampir tidak memenuhi materi pelatihan tentang HRPWM dan sama sekali tidak bertemu materi tentang bekerja dengan HRPWM berdasarkan mikrokontroler STM32, dan ini adalah perangkat yang sangat berguna. <br><br>  Saya tidak akan mempelajari teori pinggiran ini dalam kerangka artikel ini, jadi saya akan menjelaskan esensinya.  HRPWM atau High Resolution PWM adalah modul PWM kami yang biasa, yang memiliki resolusi lebih tinggi untuk pengaturan faktor tugas dan juga biasanya memiliki pengaturan yang lebih fleksibel. <br><br> <a href=""><img src="https://habrastorage.org/webt/mx/kb/ct/mxkbctdf9dhgu2ssfv1briuowmm.png"></a> <br><br><ul><li>  Mikrokontroler STM32F334R8T6 memiliki 10 saluran HRPWM, yang digabungkan menjadi 5 grup dengan 2 saluran.  2 saluran dalam kelompok ini dapat bekerja secara mandiri dan membentuk pasangan yang saling melengkapi - kita membutuhkan yang terakhir; </li><li>  Di dalam pasangan komplementer antara 2 sinyal PWM, dimungkinkan untuk menginstal waktu mati perangkat keras untuk perlindungan terhadap arus pass-through; </li><li>  Semua 10 saluran di-clock dari satu pengatur waktu - Pengatur waktu, sehingga semuanya disinkronkan satu sama lain dan Anda tidak harus secara manual mengkonfigurasi rangkaian pengatur waktu.  Cukup menyalakan master dan Timer A ... E timer untuk di-clocked darinya; </li><li>  Frekuensi di HRPWM digandakan, yaitu pada frekuensi inti 72 MHz, di HRPWM adalah 144 MHz setelah pengali tambahan (x2) dengan PLL.  Ini memungkinkan untuk mengontrol konverter pada frekuensi ratusan kHz; </li><li>  Banyak pengaturan untuk kontrol PWM, misalnya, bersama dengan kemampuan untuk mengikat generasi PWM ke awal dan akhir periode, ada 4 peristiwa yang lebih dapat dikonfigurasi (comp) yang memungkinkan Anda untuk menerjemahkan PWM ke 0 atau 1 pada titik mana pun pada periode selain awal / akhir periode; </li><li>  Ada mode untuk topologi tertentu, misalnya, mode push-pull, yang memungkinkan Anda untuk mengimplementasikan banyak topologi push-pull. </li></ul><br>  Dan ini hanya sebagian kecil dari fitur, pada diagram perangkat HRPWM Anda dapat melihat kemampuan sinkronisasi dengan banyak peristiwa, DAC, pembanding yang dibangun ke dalam MK, dan bersama dengan diagram blok ini ada banyak kemungkinan yang lebih banyak didokumentasikan. <br><br>  Masih ada pertanyaan terakhir yang perlu ditangani - "mengapa PWM ini bit-tinggi?".  Untuk melakukan ini, perhatikan contoh sederhana.  Bayangkan kita memutuskan untuk menggunakan MK tanpa HRPWM, katakanlah STM32F103C8T6, yang juga berfungsi pada frekuensi 72 MHz.  Kita perlu mengontrol setengah jembatan pada frekuensi 70 kHz, kami mempertimbangkan langkah regulasi apa yang bisa kami dapatkan: 72 000 000/1025 langkah = 70 243 Hz.  Ya, kami memiliki 1025 langkah dan ketika menyesuaikan kami dapat mengubah tegangan output dengan langkah teoritis 1/1025 = ~ 0,1%.  Sekarang kita ambil STM32F334, dengan frekuensi clock 144 MHz dan lebar shift timer 32 bit, kita mendapatkan frekuensi setara 144 MHz * 32 = 4,608 GHz.  Bagi mereka yang merasa takut dan meragukan sosok itu: <br><br><img src="https://habrastorage.org/webt/7n/ot/o2/7noto2gpr5ht4fnztxskohfhx-m.png"><br><br>  Tidak, ini bukan frekuensi operasi, ini adalah frekuensi yang setara.  Apa yang ini berikan pada kita?  Kami mengambil frekuensi yang setara 4 4608 000 Hz / 70 300 Hz = 65.535 langkah.  Sekarang kita dapat menyesuaikan tegangan (atau arus) pada output dengan peningkatan 1/65 535 = ~ 0,001%, yaitu, 100 kali lebih akurat! <br><br>  Dan sekarang mari kita lakukan - kita memiliki frekuensi 700 kHz, yang normal untuk uang banyak, misalnya.  F103 akan mendapatkan 72.000.000 Hz / 700.000 Hz = 102 langkah, yang memungkinkan Anda untuk mendapatkan 1% regulasi terbaik, tetapi ini adalah 1% untuk tugas, yaitu, pada kenyataannya dengan begitu banyak langkah Anda akan memiliki tegangan mengambang pada output seolah menstabilkan dan tidak juga.  Sedangkan untuk F334 jumlah langkah akan menjadi sekitar 6500, yang masih memungkinkan Anda untuk membangun regulator tegangan atau arus yang sangat akurat.  Kami mendapatkan bahwa resolusi (langkah) dari pengaturan siklus kerja jauh lebih tinggi / lebih sering daripada dengan MK konvensional dengan modul PWM standar di dalamnya. <br><br>  <b>Pengaturan sistem jam</b> <br><br>  Saya menggunakan TrueSTUDIO sebagai lingkungan pengembangan dalam artikel ini, karena gratis, tidak sesedih Keil atau IAR <s>ya ya, ceritakan tentang debugger yang luar biasa</s> , cross-platform dan mungkin solusi terbaik untuk pemula dan tidak hanya.  Pada akhir artikel akan ada arsip dengan proyek khusus untuk IDE ini.  Saya tidak akan memberi tahu Anda cara membuat dan mengkonfigurasi proyek, saya hanya akan meninggalkan tautan ke video di mana semuanya ditampilkan secara detail - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tonton</a> . <br><br>  Setelah Anda membuat proyek dan mengedipkan LED, Anda harus mengonfigurasi sistem jam, yaitu, dari 8 MHz naikkan frekuensi menjadi 72 MHz dan terapkan ke inti, lalu sesuaikan pembagi untuk mengurangi frekuensi yang dipasok ke ADC: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartInitClock</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ RCC-&gt;CR |= RCC_CR_HSEON; <span class="hljs-comment"><span class="hljs-comment">// Enable HSE while (!(RCC-&gt;CR &amp; RCC_CR_HSERDY)); FLASH-&gt;ACR |= FLASH_ACR_LATENCY_1; RCC-&gt;CFGR |= RCC_CFGR_PLLMUL9; // PLL mult x9 RCC-&gt;CFGR |= RCC_CFGR_PLLSRC; // Source HSE RCC-&gt;CFGR2 |= RCC_CFGR2_ADCPRE12_DIV10; // ADC source AHB/10 RCC-&gt;CR |= RCC_CR_PLLON; while((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == 0){} RCC-&gt;CFGR &amp;= ~RCC_CFGR_SW; RCC-&gt;CFGR |= RCC_CFGR_SW_PLL; // Select source SYSCLK = PLL while((RCC-&gt;CFGR &amp; RCC_CFGR_SWS) != RCC_CFGR_SWS_1) {} // Wait PLL }</span></span></code> </pre> <br>  Di sini, saya hanya berpikir, algoritma tuning adalah sebagai berikut: <i>ia beralih ke kuarsa eksternal (HSE) -&gt; kami menunggu ketika transisi selesai dan bendera siap diatur -&gt; kami mengirim sinyal dari kuarsa ke input PLL -&gt; kami mengalikan 8 MHz dengan 9 -&gt; kami membagi frekuensi dengan 72 MHz oleh 10 untuk clock ADC -&gt; nyalakan PLL -&gt; tunggu sampai nyala dan atur flag ready -&gt; kirim sinyal dari PLL ke bus sistem dan core -&gt; tunggu sampai switch selesai -&gt; selesai.</i> <br><br>  <b>Pengaturan HRPWM</b> <br><br>  Di sini semuanya agak lebih rumit, karena  Modul ini memiliki banyak fungsi, banyak pengaturan dan jumlah dokumentasi yang sangat besar, tetapi ini adalah minus dan pada saat yang sama ditambah - Anda harus membayar untuk fleksibilitas. <br><br><pre> <code class="cpp hljs">RCC-&gt;CFGR3 |= RCC_CFGR3_HRTIM1SW_PLL; RCC-&gt;APB2ENR |= RCC_APB2ENR_HRTIM1EN;</code> </pre><br>  Anda perlu menentukan bahwa HRTIM adalah clock dari PLL, pengali x2 sudah diaktifkan secara default.  Kemudian kita cukup menyalakan jam untuk HRTIM, berikut ini adalah fitur pertama - seperti yang kita pahami pengatur waktu jam dari PLL, tapi kita nyalakan untuk APB2.  Ini tidak sepenuhnya logis, tetapi mudah dicari dalam file dengan CMSIS atau dalam dokumentasi. <br><br><pre> <code class="cpp hljs"> RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER8; GPIOA-&gt;MODER |= GPIO_MODER_MODER8_1; <span class="hljs-comment"><span class="hljs-comment">// Alternative PP GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR8; // Very high speed GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER9; GPIOA-&gt;MODER |= GPIO_MODER_MODER9_1; GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR9; GPIOA-&gt;AFR[1] |= 0xDD; // PA8 and PA9 - AF13</span></span></code> </pre><br>  PA8 dan PA9 adalah output dari Timer A, yang pada modul saya masuk ke saluran No. 1, yang dapat Anda lihat pada diagram dan pin-out.  Kaki dikonfigurasikan sebagai push-pull dengan fungsi alternatif, jumlah fungsi itu sendiri untuk kedua kaki adalah yang ke-13.  Penting juga untuk menyetel ke frekuensi GPIO maksimum, jika tidak akan ada penyumbatan depan sinyal yang jatuh, yang sangat penting untuk elektronika daya. <br><br><pre> <code class="cpp hljs">HRTIM1-&gt;sCommonRegs.DLLCR |= HRTIM_DLLCR_CAL | HRTIM_DLLCR_CALEN; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((HRTIM1-&gt;sCommonRegs.ISR &amp; HRTIM_ISR_DLLRDY) == RESET);</code> </pre><br>  Sebelum Anda mulai, Anda perlu mengkalibrasi timer, karena  Ia bekerja dengan penundaan minimal, kemudian hanya menunggu bendera siap. <br><br><pre> <code class="cpp hljs">HRTIM1-&gt;sTimerxRegs[<span class="hljs-number"><span class="hljs-number">0</span></span>].PERxR = PeriodTimerA; <span class="hljs-comment"><span class="hljs-comment">// Period for timer A HRTIM1-&gt;sTimerxRegs[0].CMP1xR = 0; // Duty for timer A</span></span></code> </pre><br>  Itu fleksibilitas.  Pertama, kita dapat mengatur frekuensi kita sendiri untuk setiap timer A ... E, di sini kita cukup mencatat periode PWM kita.  Kedua, secara default kita memiliki penyelarasan PWM di awal periode, yaitu sinyal masuk ke log.1 di awal periode baru, dan sekarang kita harus memilih kapan akan kembali ke log.0, dalam hal ini, oleh pembanding No. 1, yaitu Saya bertanya di dalamnya pada dasarnya faktor tugas. <br><br>  Misalnya, Anda dapat menerjemahkan PWM bukan pada awal periode, tetapi dengan komparator No. 1, dan kembali ke log.0 oleh komparator No. 2 dan dengan demikian fase memindahkan perangkat keras. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Deadtime enable HRTIM1-&gt;sTimerxRegs[0].OUTxR |= HRTIM_OUTR_DTEN; // Tdtg = 6.94 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTPRSC_0 | HRTIM_DTR_DTPRSC_1; // Deadtime rising = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTR_0 | HRTIM_DTR_DTR_1 | HRTIM_DTR_DTR_2 | HRTIM_DTR_DTR_3; // Deadtime falling = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTF_0 | HRTIM_DTR_DTF_1 | HRTIM_DTR_DTF_2 | HRTIM_DTR_DTF_3; HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTFSLK | HRTIM_DTR_DTRSLK;</span></span></code> </pre><br>  Pada tahap ini, kami mengaktifkan waktu mati dan mengkonfigurasinya, pada prinsipnya, komentar berisi semua rumus, mereka juga dapat ditemukan di manual referensi.  DT dengan durasi ~ 100 n yang telah Anda lihat pada bentuk gelombang di bab teoritis artikel ini.  Waktu mati dapat diatur secara terpisah di tepi dan pada penurunan sinyal.  Ngomong-ngomong, [0] adalah Timer A, masing-masing [1] adalah Timer B dan seterusnya. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Samples in middle of ON time HRTIM1-&gt;sTimerxRegs[0].CMP2xR = PeriodTimerA / 10; // ADC trigger 1 update: Timer A HRTIM1-&gt;sCommonRegs.CR1 |= HRTIM_CR1_ADC1USRC_0; // ADC trigger 1 event: Timer A compare 2 HRTIM1-&gt;sCommonRegs.ADC1R |= HRTIM_ADC1R_AD1TAC2;</span></span></code> </pre><br>  Bagi saya, ini bukan momen yang paling jelas.  Intinya adalah - Saya ingin memastikan bahwa selama 10% dari durasi Timer, periode dihasilkan peristiwa yang akan memicu konversi ADC dan mengukur sinyal umpan balik.  Mengapa 10%?  Secara sederhana, idealnya, pengukuran tidak boleh terjadi pada saat transisi PWM dari 0 ke 1 atau sebaliknya, karena  pada saat ini di unit daya ada transien dan gangguan, tetapi kita tidak perlu mengukurnya.  Oleh karena itu, 10% dalam kasus saya optimal, karena  pada output 12V dan 30V, tegangan input dari faktor tugas tidak akan turun hingga 10% dan momen switching transistor tidak akan sama persis dengan pengukuran ADC. <br><br>  Sekarang Anda perlu melihat sistem komunikasi acara antara HRTIM dan ADC: <br><br><img src="https://habrastorage.org/webt/r7/p6/g2/r7p6g2w3zcs-vrrsvzeev7uhwbc.png"><br><br>  Di baris pertama, kami memilih kapan pembanding akan dipicu, dalam kasus saya ini adalah 10% dari periode timer A. Selanjutnya, kami memilih pemicu khusus di ADC yang akan menghubungi MK, kami memiliki akses ke 1 atau 3.  Sekarang ini hanya menunjukkan acara mana yang akan mengirim sinyal ke ADC, dalam kasus saya ini adalah pembanding No. 2. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Enable output PWM for TA1 and TA2 HRTIM1-&gt;sCommonRegs.OENR |= HRTIM_OENR_TA1OEN | HRTIM_OENR_TA2OEN; // Continuous mode HRTIM1-&gt;sTimerxRegs[0].TIMxCR |= HRTIM_TIMCR_CONT; // Period for master timer HRTIM1-&gt;sMasterRegs.MPER = 65000; // Enable counter for Master and timer A HRTIM1-&gt;sMasterRegs.MCR |= HRTIM_MCR_MCEN | HRTIM_MCR_TACEN;</span></span></code> </pre><br>  Dan akord terakhir!  Kami mengizinkan HRTIM untuk mengeluarkan sinyal dari Timer A ke GPIO kami.  Sekarang kita memilih mode, itu terjadi tanpa akhir (saya memilikinya), tetapi itu terjadi bahwa timer dihidupkan selama 1 periode dan setelah itu perlu dimulai lagi.  Selanjutnya, atur periode untuk timer utama dan nyalakan sebagai langkah terakhir, itu mulai untuk clock timer saluran dan sinyal PWM muncul di output. <br><br>  Itu adalah fungsi tuning, masih membuat fungsi yang akan mengatur faktor tugas, dengan itu kita akan bekerja saat membuat controller: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDutyTimerA</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> duty)</span></span></span><span class="hljs-function"> </span></span>{ HRTIM1-&gt;sTimerxRegs[<span class="hljs-number"><span class="hljs-number">0</span></span>].CMP1xR = duty; }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Mendaftarkan pengaturan fungsi dan mengatur siklus tugas</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// f = 102,4 kHz #define PeriodTimerA ((uint16_t)45000) void InitHRPWM (void) { RCC-&gt;CFGR3 |= RCC_CFGR3_HRTIM1SW_PLL; RCC-&gt;APB2ENR |= RCC_APB2ENR_HRTIM1EN; /************************************************ * Setting GPIO ***********************************************/ RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; // Alternative PP GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER8; GPIOA-&gt;MODER |= GPIO_MODER_MODER8_1; // Very high speed GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR8; GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER9; GPIOA-&gt;MODER |= GPIO_MODER_MODER9_1; GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR9; // PA8 and PA9 - AF13 GPIOA-&gt;AFR[1] |= 0xDD; /************************************************ * Setting timer A ***********************************************/ HRTIM1-&gt;sCommonRegs.DLLCR |= HRTIM_DLLCR_CAL | HRTIM_DLLCR_CALEN; while ((HRTIM1-&gt;sCommonRegs.ISR &amp; HRTIM_ISR_DLLRDY) == RESET); // Period for timer A HRTIM1-&gt;sTimerxRegs[0].PERxR = PeriodTimerA; // Duty for timer A HRTIM1-&gt;sTimerxRegs[0].CMP1xR = 0; // Deadtime enable HRTIM1-&gt;sTimerxRegs[0].OUTxR |= HRTIM_OUTR_DTEN; // Tdtg = 6.94 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTPRSC_0 | HRTIM_DTR_DTPRSC_1; // Deadtime rising = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTR_0 | HRTIM_DTR_DTR_1 | HRTIM_DTR_DTR_2 | HRTIM_DTR_DTR_3; // Deadtime falling = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTF_0 | HRTIM_DTR_DTF_1 | HRTIM_DTR_DTF_2 | HRTIM_DTR_DTF_3; HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTFSLK | HRTIM_DTR_DTRSLK; // Event forces the output to active state for TA1 HRTIM1-&gt;sTimerxRegs[0].SETx1R |= HRTIM_SET1R_PER; // Event forces the output to inactive state for TA1 HRTIM1-&gt;sTimerxRegs[0].RSTx1R |= HRTIM_RST1R_CMP1; /************************************************ * ADC trigger intialization (with CMP2 event) ************************************************/ // Samples in middle of ON time HRTIM1-&gt;sTimerxRegs[0].CMP2xR = PeriodTimerA / 10; // ADC trigger 1 update: Timer A HRTIM1-&gt;sCommonRegs.CR1 |= HRTIM_CR1_ADC1USRC_0; // ADC trigger 1 event: Timer A compare 2 HRTIM1-&gt;sCommonRegs.ADC1R |= HRTIM_ADC1R_AD1TAC2; /************************************************ * HRTIM start ***********************************************/ // Enable output PWM for TA1 and TA2 HRTIM1-&gt;sCommonRegs.OENR |= HRTIM_OENR_TA1OEN | HRTIM_OENR_TA2OEN; // Continuous mode HRTIM1-&gt;sTimerxRegs[0].TIMxCR |= HRTIM_TIMCR_CONT; // Period for master timer HRTIM1-&gt;sMasterRegs.MPER = 65000; // Enable counter for Master and timer A HRTIM1-&gt;sMasterRegs.MCR |= HRTIM_MCR_MCEN | HRTIM_MCR_TACEN; } void SetDutyTimerA (uint16_t duty) { HRTIM1-&gt;sTimerxRegs[0].CMP1xR = duty; }</span></span></code> </pre><br></div></div><br>  Sekarang mari kita cari tahu apakah kita bergerak dengan cara yang benar.  Pada fungsi <i>utama</i> , inisialisasi pengaturan HRTIM dan atur siklus kerja, katakan 22500. Dengan tegangan input 20V dan periode 45000, siklus tugas kami akan menjadi 50% dan output akan menjadi sekitar 10V.  Ini tidak cukup untuk memperluas LED menjadi penuh, tetapi harus menyala dan kita akan mengerti jika bagian daya berfungsi, apakah semuanya baik-baik saja dengan dt dan seterusnya.  Saya memulai semuanya pertama kali: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HTLbf9aMAGs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Anda dapat melihat bahwa semua perhitungan teoritis sebelumnya telah dikonfirmasi.  Dengan faktor tugas tetap 50%, tegangan output dibagi dengan 2: 20V -&gt; 10V, 22V -&gt; 11V, 18V -&gt; 9V.  Sekarang mari kita buat tegangan keluaran stabil dan independen dari input, yaitu, tambahkan umpan balik. <br><br>  <b>Penyesuaian ADC dan pengontrol</b> <br><br>  Banyak yang telah ditulis tentang ADC di STM32 sebelum saya, saya hanya memikirkan pengaturan pemicu yang terkait dengan pembanding HRTIM.  Saya akan berbicara singkat tentang pengaturan ADC lainnya.  Kami melihat fungsi inisialisasi: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitBasicADC</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ RCC-&gt;AHBENR |= RCC_AHBENR_ADC12EN; RCC-&gt;AHBENR |= RCC_AHBENR_GPIOCEN; <span class="hljs-comment"><span class="hljs-comment">/************************************************ * Calibration ***********************************************/</span></span> ADC2-&gt;CR &amp;= ~ADC_CR_ADVREGEN; ADC2-&gt;CR |= ADC_CR_ADVREGEN_0; <span class="hljs-comment"><span class="hljs-comment">// Vref enable Delay(10); ADC2-&gt;CR &amp;= ~ADC_CR_ADCALDIF; ADC2-&gt;CR |= ADC_CR_ADCAL; // Start calibration while (ADC2-&gt;CR &amp; ADC_CR_ADCAL); // Wait end calibration /************************************************ * Select event trigger and channel ***********************************************/ // Enable start conversion external trigger ADC2-&gt;CFGR |= ADC_CFGR_EXTEN_0; // Event 7 - HRTIM ADC2-&gt;CFGR |= ADC_CFGR_EXTSEL_0 | ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_2; // Select ADC2 channel IN5 ADC2-&gt;SQR1 |= ADC_SQR1_SQ1_0 | ADC_SQR1_SQ1_2; // Length regular ADC channel = 1 ADC2-&gt;SQR1 &amp;= ~ADC_SQR1_L; ADC2-&gt;IER |= ADC_IER_EOCIE; // Interrupt enable NVIC_EnableIRQ(ADC1_2_IRQn); // enable interrupt ADC1 and ADC2 /************************************************ * Start ADC ***********************************************/ ADC2-&gt;CR |= ADC_CR_ADEN; // Enable ADC2 Delay(10); ADC2-&gt;CR |= ADC_CR_ADSTART; }</span></span></code> </pre><br>  Saya menggunakan mode saluran reguler, saya hanya punya satu saluran dan itu dipilih dalam register <i>SQR1</i> .  ADC nomor 2 yang dilibatkan, yaitu input IN5, cepat dan dapat beroperasi pada frekuensi pengambilan sampel maksimum, tetapi tidak kali ini.  Frekuensi sampling sama dengan frekuensi PWM, karena  1 periode = 1 sampel, pada prinsipnya, ini lebih dari cukup. <br><br>  Juga, dalam register <i>CFGR</i> , <i>kita</i> perlu memilih acara di mana konversi akan dimulai, yaitu, <i>Peristiwa 7</i> , mengapa tepatnya?  Kami melihat RM: <br><br><img src="https://habrastorage.org/webt/mr/f0/wn/mrf0wnno0sft4episcxokfnsduy.png"><br><br>  Pemicu 1 dari modul HRPWM datang ke Acara 7 untuk ADC No. 2 kami, yang dalam hal ini berfungsi sebagai budak, kemudian dikendalikan dari modul HRPWM.  Saya pikir sekarang sudah jelas bagaimana menghubungkan 2 modul, pada prinsipnya, algoritma ini sama untuk setiap perangkat dan timer, hanya nama register yang akan berbeda. <br><br>  Ketika penghitung periode pengatur waktu tercapai, konversi akan dimulai, yang setelah sekitar 15 siklus (untuk seberapa banyak yang terlihat di RM) akan menyebabkan interupsi dan Anda dapat mengambil hasilnya.  Dalam gangguan inilah kami mengatur algoritma kontrol.  Ya, di dalam interupsi, sesuatu yang masif lebih baik untuk tidak melakukannya, lebih baik untuk mengatur bendera dan meneruskan eksekusi, tetapi saya akan membiarkan diri saya menyederhanakan, karena dalam hal ini pengontrol saya tidak dimuat secara khusus dan akan berhasil menghitung dan keluar dari interupsi dengan probabilitas 146% untuk munculnya yang baru. <br><br>  <b>Sedikit tentang manajemen</b> <br><br>  Bayangkan Anda memasuki kamar mandi dan memutuskan untuk mencuci tangan di wastafel.  Anda sedikit membuka air, menyentuhnya dengan tangan Anda, dingin?  Tambahkan lebih banyak air panas, lebih hangat?  Bagus!  Tambahkan lebih banyak air panas?  Hampir apa yang kamu butuhkan?  Bagus!  Tambahkan lebih banyak air panas, coba dengan tangan Anda, bakar diri Anda sendiri?  Mari kita sedikit panaskan sekarang.  Oke  Dan hingga tak terbatas, Anda akan memutar keran hingga suhu air menjadi ideal.  Ini adalah tombol paling mudah! <br><br>  Hanya saja kita tidak mengatur jumlah air panas, tetapi siklus tugas PWM.  Alih-alih tangan, kami memiliki ADC dengan hasil yang diukur.  Tetap hanya menerapkan logika.  Kami akan menghitung apa yang harus dihasilkan ADC pada output 12V, dan kemudian menggunakan kondisi <i>if</i> , kami akan memaksa controller kami untuk mempertahankan nilai ini dengan mengubah faktor tugas. <br><br>  Untuk memulai, mari kita gantung pembagi tegangan untuk mengurangi 12V menjadi 2-2.5V, misalnya, karena  ADC dapat mengukur dari 0 hingga + 3.3V dan jika 12V diberikan, maka mikrokontroler akan terbakar dengan mudah.  Oleh karena itu, saya akan meletakkan pembagi dengan nilai nominal 10 kOhm dan 2 kOhm, yang akan memberikan rasio pembagian 6 dan, dengan demikian, + 12V kami akan berubah menjadi + 2V.  ADC kami akan menghasilkan hasilnya: adcResult = (V <sub>out</sub> / k) / V <sub>ref</sub> * 2 <sup>12</sup> = (12V / 6) / 3.3 * 4095 = 2481. Sekarang kita menulis kode untuk interrupt handler: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ADC1_2_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ADC2-&gt;ISR |= ADC_ISR_EOC; adcResult = ADC2-&gt;DR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (adcResult &gt; <span class="hljs-number"><span class="hljs-number">2480</span></span>) { dutyControl = dutyControl - <span class="hljs-number"><span class="hljs-number">10</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dutyControl = dutyControl + <span class="hljs-number"><span class="hljs-number">10</span></span>; } SetDutyTimerA(dutyControl); }</code> </pre><br>  Pertama-tama, setelah masuk ke interrupt handler, Anda perlu menghapus bendera interupsi ini, jika tidak kedua kalinya Anda tidak akan masuk ke dalamnya.  Kemudian kami membaca hasilnya dan menyimpannya sebagai variabel <i>adcResult</i> .  Sekarang, mengetahui tegangan pada output, Anda perlu menyesuaikan siklus tugas untuk PWM, saya menerapkan ini hanya melalui kondisi <i>if</i> .  Dalam setiap periode PWM, kami melakukan pengukuran, menambah atau mengurangi siklus tugas dan mengatur hasilnya untuk periode berikutnya.  Semuanya sederhana, cepat dan esensi terlihat.  Kami melihat hasil kerja: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JxpeGDzYd3A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Seperti yang Anda lihat, semuanya berfungsi dan ketika voltase input berubah, outputnya sendiri tetap stabil pada 12V.  Sangat penuh perhatian dapat melihat jarum kecil menyelinap, maka Anda hanya perlu menggantung keramik X7R pada output 1-10 mikrofarad dan mereka akan pergi, saya terlalu malas untuk mencarinya dan menyoldernya.  Sekarang osilogram itu sendiri, agar tidak merusak mata: <br><br><img src="https://habrastorage.org/webt/ff/xf/be/ffxfbeq791q3wqwwfmohhheyg10.png"><br><br>  Di sini Anda dapat melihat bagaimana tegangan output naik.  Faktanya adalah bahwa karena algoritma kontrol, agar pengisian mencapai nilai dari 0 hingga 10.000, misalnya, seribu periode atau sekitar 10 ms diperlukan.  Ini cocok untuk saya karena permulaan yang lembut, jika Anda ingin mengurangi waktu naik, mempersulit algoritma sedikit dan menambahkan +1000, bukan +10, dan semakin dekat Anda ke 12V yang ditentukan, semakin sedikit regulasi yang Anda lakukan hingga Anda mencapai +10 .  Secara umum, banyak hal dapat dilakukan dalam hal manajemen, sehingga Anda memiliki bidang untuk eksperimen. <br><br>  Poin menarik lainnya adalah osilasi pada saat shutdown, seperti "harmonika".  Faktanya adalah bahwa setelah mematikan daya, bagian digital saya terus bekerja dari PSU lain dan mencoba untuk menjaga nilai yang diinginkan pada output.  Dari mana energi itu berasal?  Ya, dari kapasitor input, ini adalah 1000 mikrofarad yang sudah 3 buah, ini adalah fenomena yang menarik. <br><br><h2>  Kesimpulan </h2><br>  Artikel itu tidak kecil, tetapi Anda menginginkan segalanya dan segera mereka mengatakan mari kita siapkan besi - dapatkan.  Saya harap Anda menikmati artikel ini, saya mencoba membuatnya tidak ilmiah, tetapi sains populer, sehingga materi dapat diakses oleh orang-orang dengan berbagai tingkat pengetahuan dan pengalaman.  Mungkin di masa depan saya akan menganalisis topologi serupa lainnya seperti boost, full bridge dan lainnya. <br><br>  By the way, artikel dan kode ini akan berfungsi untuk pengontrol MPPT baru pada 20A, yang saya rancang.  Sekarang saya sedang menunggu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">papan PCBway</a> , yang sebenarnya menawarkan diri untuk mensponsori proyek open source saya dengan papan sirkuit cetak, sumber MPPT juga akan terbuka untuk semua modul saya. <br><br>  Saya lupa hal yang paling penting!  Simpan proyek dengan kode untuk TrueSTDIO - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RAR</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432778/">https://habr.com/ru/post/id432778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432768/index.html">Headphone nirkabel untuk "serial maraton": di Dolby mereka akan ditawarkan seharga $ 599</a></li>
<li><a href="../id432770/index.html">Botnet dan tipenya: apa yang diketahui pada 2018</a></li>
<li><a href="../id432772/index.html">Bagaimana kami membuat layanan kampanye iklan yang sesuai dengan GDPR</a></li>
<li><a href="../id432774/index.html">Frontend DevDay. Rekaman Laporan</a></li>
<li><a href="../id432776/index.html">Buku "React in action"</a></li>
<li><a href="../id432780/index.html">Mengapa empati dibutuhkan di dunia teknologi</a></li>
<li><a href="../id432782/index.html">Instalasi multi-server Zimbra Collaboration Suite</a></li>
<li><a href="../id432784/index.html">Castlevania Bot</a></li>
<li><a href="../id432786/index.html">.NET - lokalisasi tanpa rasa sakit. (N) gettext + poedit</a></li>
<li><a href="../id432788/index.html">Prototipe: cara membuat produk yang sukses dan menyimpan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>