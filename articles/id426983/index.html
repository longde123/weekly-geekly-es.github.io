<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍⚕️ 👨‍👩‍👧‍👧 🐢 Baru di SObjectizer-5.5.23: keinginan terpenuhi atau kotak Pandora? ⏲️ ⚒️ 📿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini merupakan kelanjutan dari artikel refleksi yang diterbitkan sebulan yang lalu, " Apakah mudah untuk menambahkan fitur baru ke kerangka lam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Baru di SObjectizer-5.5.23: keinginan terpenuhi atau kotak Pandora?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426983/"><img src="https://habrastorage.org/webt/kt/xf/7o/ktxf7oduhnd0zuhd_tpaju7p_em.jpeg"><br><br>  Artikel ini merupakan kelanjutan dari artikel refleksi yang diterbitkan sebulan yang lalu, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apakah mudah untuk menambahkan fitur baru ke kerangka lama? Penderitaan pilihan berdasarkan contoh pengembangan SObjectizer</a> ".  Artikel itu menjelaskan tugas yang ingin kami selesaikan dalam versi SObjectizer berikutnya, memeriksa dua pendekatan untuk solusinya dan mendaftarkan kelebihan dan kekurangan masing-masing pendekatan. <br><br>  Seiring berjalannya waktu, salah satu pendekatan diimplementasikan dan versi baru dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SObjectizer</a> , serta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek yang</a> menyertainya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">so_5_extra</a> , sudah disebut " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bernapas dalam-dalam</a> ".  Anda dapat benar-benar mengambil dan mencoba. <br><br>  Hari ini kita akan berbicara tentang apa yang dilakukan, mengapa itu dilakukan, apa yang menyebabkannya.  Jika seseorang tertarik mengikuti bagaimana salah satu dari sedikit kerangka kerja aktor hidup, lintas platform, dan terbuka untuk C ++ berkembang, Anda dipersilakan untuk melakukannya. <br><a name="habracut"></a><br><h1>  Bagaimana semuanya dimulai? </h1><br>  Semuanya dimulai dengan upaya untuk memecahkan masalah pembatalan pengatur waktu yang dijamin.  Inti dari masalah adalah bahwa ketika pesan tertunda atau berkala dikirim, programmer dapat membatalkan pengiriman pesan.  Sebagai contoh: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> timer_id = so_5::send_periodic&lt;my_message&gt;(my_agent, <span class="hljs-number"><span class="hljs-number">10</span></span>s, <span class="hljs-number"><span class="hljs-number">10</span></span>s, ...); ... <span class="hljs-comment"><span class="hljs-comment">// - . // ,    my_message    . timer_id.release(); //      my_message.</span></span></code> </pre> <br>  Setelah memanggil <i>timer_id.release (),</i> timer tidak akan lagi mengirim instance baru dari pesan my_message.  Tetapi salinan yang sudah dikirim dan berada dalam antrian penerima tidak akan pergi ke mana pun.  Seiring waktu, mereka akan diekstraksi dari antrian yang sama dan akan ditransfer ke agen penerima untuk diproses. <br><br>  Masalah ini merupakan konsekuensi dari prinsip dasar pengoperasian SObjectizer-5 dan tidak memiliki solusi sederhana karena fakta bahwa SObjectizer tidak dapat mengekstraksi pesan dari antrian.  Itu tidak bisa karena antrian dalam SObjectizer milik dispatcher, dispatcher berbeda, antrian mereka juga diatur secara berbeda.  Termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada dispatcher yang bukan bagian dari SObjectizer,</a> dan SObjectizer, pada prinsipnya, tidak dapat mengetahui cara kerja dispatcher ini. <br><br>  Secara umum, ada fitur seperti itu di timer SObjectizer asli.  Bukan berarti itu terlalu banyak merusak pengembang.  Tetapi perhatian ekstra harus diambil.  Terutama untuk pemula yang baru saja berkenalan dengan framework. <br><br>  Dan akhirnya, tangan-tangan itu pergi ke titik mengusulkan solusi untuk masalah ini. <br><br><h1>  Jalur solusi mana yang dipilih? </h1><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> , dua opsi yang mungkin dipertimbangkan.  Opsi pertama tidak memerlukan modifikasi pada mekanisme pengiriman pesan di SObjectizer, tetapi mengharuskan programmer untuk secara eksplisit mengubah jenis pesan yang dikirim / diterima. <br><br>  Opsi kedua membutuhkan modifikasi dari mekanisme pengiriman pesan SObjectizer.  Jalur inilah yang dipilih, karena memungkinkan bersembunyi dari penerima pesan fakta bahwa pesan dikirim dengan cara tertentu. <br><br><h2>  Apa yang telah berubah di SObjectizer? </h2><br><h3>  Konsep baru: amplop dengan pesan di dalamnya </h3><br>  Komponen pertama dari solusi yang diimplementasikan adalah penambahan konsep seperti amplop ke SObjectizer.  Amplop adalah pesan khusus, di dalamnya terdapat pesan saat ini (payload).  SObjectizer mengirimkan amplop beserta pesannya ke penerima dengan cara yang hampir biasa.  Perbedaan mendasar dalam pemrosesan amplop hanya terdeteksi pada tahap pengiriman terakhir: <br><br><ul><li>  setelah pengiriman pesan reguler, agen penerima hanya mencari penangan untuk jenis pesan ini dan, jika penangan seperti itu ditemukan, penangan yang ditemukan dipanggil dan pesan yang dikirim dikembalikan sebagai parameter; </li><li>  dan setelah pengiriman amplop dengan pesan setelah pawang ditemukan, upaya pertama-tama dilakukan untuk mengeluarkan pesan dari amplop.  Dan hanya jika amplop memberikan pesan yang tersimpan di dalamnya, hanya pawang yang dipanggil. </li></ul><br>  Ada dua poin utama di sini yang memiliki dampak besar pada mengapa dan bagaimana amplop pesan dapat digunakan. <br><br>  Titik kunci pertama adalah bahwa pesan diminta dari amplop hanya ketika penangan pesan ditemukan di penerima.  Yaitu  hanya ketika pesan telah benar-benar dikirim ke penerima dan penerima akan ada di sini dan sekarang akan memproses pesan ini. <br><br>  Poin kunci kedua di sini adalah bahwa amplop mungkin tidak memberikan pesan di dalamnya.  Misalnya, sebuah amplop dapat memeriksa waktu saat ini dan memutuskan bahwa semua tanggal pengiriman telah terjawab dan, oleh karena itu, pesan tidak lagi relevan dan tidak dapat diproses.  Karena itu, amplop tidak akan memberikan pesan.  Karenanya, SObjectizer akan mengabaikan amplop ini dan tidak akan mengambil tindakan tambahan. <br><br><h4>  Seperti apa amplop itu? </h4><br>  Amplop adalah implementasi dari antarmuka envelope_t, yang didefinisikan sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SO_5_TYPE</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envelope_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-comment"><span class="hljs-comment">// -. //   ,       //    . virtual void handler_found_hook( handler_invoker_t &amp; invoker ) noexcept = 0; //   ,      //     . virtual void transformation_hook( handler_invoker_t &amp; invoker ) noexcept = 0; private : kind_t so5_message_kind() const noexcept override { return kind_t::enveloped_msg; } };</span></span></code> </pre> <br>  Yaitu  Amplop pada dasarnya adalah pesan yang sama dengan yang lainnya.  Tetapi dengan atribut khusus, yang dikembalikan oleh metode so5_message_kind (). <br><br>  Programmer dapat mengembangkan amplop yang diwarisi dari envelope_t (atau, lebih mudahnya, dari <a href="">so_5 :: extra :: enveloped_msg :: just_envelope_t</a> ) dan mengganti metode hook handler_found_hook () dan transformation_hook (). <br><br>  Di dalam metode kait, pengembang amplop memutuskan apakah ia ingin memberikan pesan di dalam amplop untuk diproses / diubah atau tidak.  Jika dia mau, maka pengembang harus memanggil metode invoke () dan objek invoker.  Jika dia tidak mau, dia tidak menelepon, dalam hal ini amplop dan isinya akan diabaikan. <br><br><h4>  Bagaimana cara amplop mengatasi masalah pembatalan pengatur waktu? </h4><br>  Solusinya, yang sekarang diimplementasikan dalam so_5_extra dalam bentuk namespace so_5 :: extra :: revocable_timer, sangat sederhana: pengiriman khusus pesan tertunda atau berkala menciptakan amplop khusus, di dalamnya terletak tidak hanya pesan itu sendiri, tetapi juga bendera atom dicabut.  Jika bendera ini dihapus, maka pesan tersebut dianggap relevan.  Jika diatur, maka pesan tersebut dianggap ditarik. <br><br>  Ketika metode kait dipanggil pada amplop, amplop memeriksa nilai bendera yang dicabut.  Jika bendera disetel, amplop tidak memberikan pesan.  Dengan demikian, pesan tidak diproses bahkan jika timer sudah berhasil memasukkan pesan ke dalam antrian penerima. <br><br><h3>  Ekstensi antarmuka abstract_message_box_t </h3><br>  Menambahkan antarmuka envelope_t hanyalah salah satu bagian dari implementasi amplop di SObjectizer.  Bagian kedua mempertimbangkan fakta adanya amplop dalam mekanisme pengiriman pesan di dalam SObjectizer. <br><br>  Di sini, sayangnya, tidak bisa melakukan tanpa membuat perubahan terlihat oleh pengguna.  Secara khusus, di kelas abstract_message_box_t, yang mendefinisikan antarmuka semua kotak surat di SObjectizer, perlu menambahkan metode virtual lain: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_deliver_enveloped_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::type_index &amp; msg_type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_ref_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> overlimit_reaction_deep )</span></span></span></span>;</code> </pre> <br>  Metode ini bertanggung jawab untuk mengirimkan amplop pesan dengan pesan tipe msg_type ke penerima.  Pengiriman tersebut mungkin berbeda dalam detail implementasi tergantung pada jenis mbox itu. <br><br>  Saat menambahkan do_deliver_enveloped_msg () ke abstract_message_box_t, kami punya pilihan: menjadikannya metode virtual murni atau menawarkan semacam implementasi standar. <br><br>  Jika kami membuat do_deliver_enveloped_msg () metode virtual murni, maka kami akan memutus kompatibilitas antara versi SObjectizer di cabang 5.5.  Setelah semua, maka para pengguna yang menulis implementasi mbox mereka sendiri harus memodifikasi mbox mereka sendiri ketika beralih ke SObjectizer-5.5.23, jika tidak mereka tidak akan dapat mengkompilasi dengan versi baru dari SObjectizer. <br><br>  Kami tidak menginginkan ini, jadi kami tidak membuat do_deliver_enveloped_msg () metode virtual murni di v.5.5.23.  Ini memiliki implementasi standar yang hanya melempar pengecualian.  Dengan demikian, pengguna khusus mbox-s akan dapat terus bekerja secara normal dengan pesan biasa, tetapi secara otomatis akan menolak untuk menerima amplop.  Kami menemukan perilaku ini lebih dapat diterima.  Selain itu, pada tahap awal tidak mungkin bahwa amplop dengan pesan akan digunakan secara luas, dan tidak mungkin bahwa dalam implementasi kustom "liar" mbox SObjectizer sering ditemukan;) <br><br>  Selain itu, ada jauh dari peluang nol bahwa dalam versi utama SObjectizer berikutnya, di mana kita tidak akan melihat kompatibilitas dengan cabang 5.5, antarmuka abstract_message_box_t akan mengalami perubahan besar.  Tapi kita sudah maju dari diri kita sendiri ... <br><br><h2>  Cara mengirim amplop dengan pesan </h2><br>  SObjectizer-5.5.23 sendiri tidak menyediakan cara sederhana untuk mengirim amplop.  Diasumsikan bahwa jenis spesifik amplop dan alat-alat yang sesuai sedang dikembangkan untuk tugas tertentu agar dapat dengan mudah mengirim amplop dari jenis tertentu.  Contohnya dapat dilihat di <a href="">so_5 :: extra :: revocable_timer</a> , di mana Anda tidak hanya perlu mengirim amplop, tetapi juga memberi pengguna timer_id khusus. <br><br>  Untuk situasi yang lebih sederhana, Anda dapat menggunakan alat dari <a href="">so_5 :: extra :: enveloped_msg</a> .  Sebagai contoh, ini adalah bagaimana pesan dikirim dengan batasan yang diberikan pada waktu pengiriman: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// make     . so_5::extra::enveloped_msg::make&lt;my_message&gt;(... /*    */) // envelope         . //  5s        . .envelope&lt;so_5::extra::enveloped_msg::time_limited_delivery_t&gt;(5s) //        . .send_to(destination);</span></span></code> </pre> <br><h2>  Untuk membuat semuanya menyenangkan: amplop dalam amplop </h2><br>  Amplop dirancang untuk membawa beberapa pesan di dalamnya.  Tapi yang mana? <br><br>  Apa saja. <br><br>  Dan ini membawa kita pada pertanyaan yang menarik: apakah mungkin memasukkan amplop ke dalam amplop lain? <br><br>  Ya kamu bisa.  Sebanyak yang kamu suka.  Kedalaman bersarang dibatasi hanya oleh akal sehat pengembang dan kedalaman tumpukan untuk panggilan handler_found_hook / transformation_hook panggilan rekursif. <br><br>  Pada saat yang sama, SObjectizer pergi ke pengembang amplop sendiri: amplop tidak boleh berpikir tentang apa yang ada di dalamnya - pesan tertentu atau amplop lain.  Ketika metode kait dipanggil pada amplop dan amplop memutuskan bahwa ia dapat memberikan isinya, amplop tersebut hanya memanggil invoke () pada handler_invoker_t dan meneruskan tautan ke isinya dalam invoke ().  Dan sudah memanggil () di dalam akan mencari tahu apa yang berhadapan dengannya.  Dan jika ini adalah amplop lain, maka aktifkan () akan memanggil metode kait yang diperlukan pada amplop ini. <br><br>  Menggunakan toolkit yang ditunjukkan di atas dari so_5 :: extra :: enveloped_msg pengguna dapat membuat beberapa amplop bersarang seperti ini: <br><br><pre> <code class="cpp hljs">so_5::extra::enveloped_msg::make&lt;my_message&gt;(...) <span class="hljs-comment"><span class="hljs-comment">// ,        my_message. .envelope&lt;inner_envelope_type&gt;(...) // ,      inner_envelope_type. .envelope&lt;outer_envelope_type&gt;(...) .send_to(destination);</span></span></code> </pre> <br><h1>  Beberapa contoh menggunakan amplop </h1><br>  Sekarang, setelah kita menjelajahi internal SObjectizer-5.5.23, sekarang saatnya untuk beralih ke bagian aplikasi yang lebih berguna bagi pengguna.  Berikut adalah beberapa contoh yang didasarkan pada apa yang sudah diterapkan di so_5_extra, atau menggunakan alat dari so_5_extra. <br><br><h2>  Timer yang dapat dibatalkan </h2><br>  Karena seluruh dapur dengan amplop ini disusun untuk menyelesaikan masalah penarikan kembali pengingat waktu, mari kita lihat apa yang terjadi pada akhirnya.  Kami akan menggunakan contoh dari so_5_extra-1.2.0, yang menggunakan alat dari so_5 :: extra :: revocable_timer namespace baru: <br><br><div class="spoiler">  <b class="spoiler_title">Contoh kode dengan penghitung waktu yang dapat dibatalkan</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5_extra/revocable_timer/pub.hpp&gt; #include &lt;so_5/all.hpp&gt; namespace timer_ns = so_5::extra::revocable_timer; class example_t final : public so_5::agent_t { //  ,       //    . struct first_delayed final : public so_5::signal_t {}; struct second_delayed final : public so_5::signal_t {}; struct last_delayed final : public so_5::signal_t {}; struct periodic final : public so_5::signal_t {}; //    . timer_ns::timer_id_t m_first; timer_ns::timer_id_t m_second; timer_ns::timer_id_t m_last; timer_ns::timer_id_t m_periodic; public : example_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self() .event( &amp;example_t::on_first_delayed ) .event( &amp;example_t::on_second_delayed ) .event( &amp;example_t::on_last_delayed ) .event( &amp;example_t::on_periodic ); } void so_evt_start() override { using namespace std::chrono_literals; //      ... m_first = timer_ns::send_delayed&lt; first_delayed &gt;( *this, 100ms ); m_second = timer_ns::send_delayed&lt; second_delayed &gt;( *this, 200ms ); m_last = timer_ns::send_delayed&lt; last_delayed &gt;( *this, 300ms ); // ...    . m_periodic = timer_ns::send_periodic&lt; periodic &gt;( *this, 75ms, 75ms ); //    220ms.       //    first_delaye, second_delayed  //    periodic. std::cout &lt;&lt; "hang the agent..." &lt;&lt; std::flush; std::this_thread::sleep_for( 220ms ); std::cout &lt;&lt; "done" &lt;&lt; std::endl; } private : void on_first_delayed( mhood_t&lt;first_delayed&gt; ) { std::cout &lt;&lt; "first_delayed received" &lt;&lt; std::endl; //   second_delayed  periodic. //          ,  //       . m_second.revoke(); m_periodic.revoke(); } void on_second_delayed( mhood_t&lt;second_delayed&gt; ) { std::cout &lt;&lt; "second_delayed received" &lt;&lt; std::endl; } void on_last_delayed( mhood_t&lt;last_delayed&gt; ) { std::cout &lt;&lt; "last_delayed received" &lt;&lt; std::endl; so_deregister_agent_coop_normally(); } void on_periodic( mhood_t&lt;periodic&gt; ) { std::cout &lt;&lt; "periodic received" &lt;&lt; std::endl; } }; int main() { so_5::launch( [](so_5::environment_t &amp; env) { env.register_agent_as_coop( "example", env.make_agent&lt;example_t&gt;() ); } ); return 0; }</span></span></span></span></code> </pre> <br></div></div><br>  Apa yang kita punya di sini? <br><br>  Kami memiliki agen yang pertama kali memulai beberapa pesan penghitung waktu, dan kemudian memblokir utas kerjanya untuk sementara waktu.  Selama waktu ini, timer berhasil mengantri agen beberapa permintaan sebagai akibat dari timer yang dipicu: beberapa instance periodik, satu first_delayed dan second_delayed masing-masing. <br><br>  Dengan demikian, ketika agen membuka utangnya, ia harus menerima periodik pertama dan first_delayed.  Saat memproses first_delayed, agen membatalkan pengiriman periodik dan second_delayed.  Oleh karena itu, sinyal-sinyal ini seharusnya tidak mencapai agen, terlepas dari apakah mereka sudah dalam antrian agen atau tidak (dan mereka). <br><br>  Kami melihat hasil dari contoh: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">hang</span></span> the agent...done periodic received first_delayed received last_delayed received</code> </pre> <br>  Ya, benar.  Mendapat periodik pertama dan first_delayed.  Maka tidak ada periodik atau second_delayed. <br><br>  Tetapi jika dalam contoh kita mengganti "timer" dari so_5 :: extra :: revocable_timer dengan timer standar dari SObjectizer, hasilnya akan berbeda: semua instance sinyal periodik dan second_delayed yang sudah memasuki antrian agen akan mencapai agen. <br><br><h2>  Pesan Terbatas Waktu Pengiriman </h2><br>  Hal lain yang berguna, kadang-kadang, yang akan tersedia di so_5_extra-1.2.0 adalah pengiriman pesan dengan batas waktu.  Misalnya, agen request_handler mengirim pesan verifikasi_signature ke agen crypto_master.  Pada saat yang sama, request_handler ingin verifikasi_syarat dikirimkan dalam waktu 5 detik.  Jika ini tidak terjadi, maka tidak akan ada artinya dalam pemrosesan verity_signature, agen request_handler akan berhenti bekerja. <br><br>  Dan agen crypto_master adalah kawan yang suka berubah menjadi “bottleneck”: kadang-kadang ia mulai melambat.  Pada saat seperti itu, pesan diakumulasikan dalam antrian, seperti tanda verifikasi_ di atas, yang dapat menunggu hingga crypto_master dihapus. <br><br>  Misalkan request_handler mengirim pesan verifikasi_signature ke agen crypto_master, tetapi kemudian crypto_master macet dan macet selama 10 detik.  Agen request_handler sudah "jatuh", mis.  sudah mengirim semua orang penolakan layanan dan menyelesaikan pekerjaannya.  Tapi pesan verifikasi_masih tetap dalam antrian crypto_master!  Jadi, ketika crypto_master "batalkan", ia akan menerima pesan ini dan akan memproses pesan ini.  Meskipun ini tidak lagi diperlukan. <br><br>  Dengan menggunakan amplop baru so_5 :: extra :: enveloped_msg :: time_limited_delivery_t, kami dapat menyelesaikan masalah ini: agen request_handler akan mengirim verifikasi_signature time_limited_delivery_t terlampir dalam amplop dengan batas waktu pengiriman: <br><br><pre> <code class="cpp hljs">so_5::extra::enveloped_msg::make&lt;verify_signature&gt;(...) .envelope&lt;so_5::extra::enveloped_msg::<span class="hljs-keyword"><span class="hljs-keyword">time_limited_delivery_t</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">5</span></span>s) .send_to(crypto_master_mbox);</code> </pre> <br>  Sekarang jika crypto_master “tetap” dan tidak berhasil memverifikasi_signature dalam 5 detik, amplop tidak akan mengirim pesan ini untuk diproses.  Dan crypto_master tidak akan melakukan pekerjaan yang tidak dibutuhkan orang lain. <br><br><h2>  Laporan pengiriman penerima </h2><br>  Dan akhirnya, contoh hal yang aneh yang tidak diimplementasikan secara teratur baik dalam SObjectizer atau so_5_extra, tetapi yang dapat dilakukan secara mandiri. <br><br>  Terkadang Anda ingin menerima sesuatu dari SObjectizer seperti pesan "laporan pengiriman" kepada penerima.  Bagaimanapun, itu adalah satu hal ketika pesan mencapai penerima, tetapi penerima karena suatu alasan tidak menanggapinya.  Hal lain adalah ketika pesan tidak sampai ke penerima sama sekali.  Misalnya, itu diblokir oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mekanisme perlindungan agen yang berlebihan</a> .  Dalam kasus pertama, pesan yang kami tidak menunggu jawabannya dapat dihilangkan.  Tetapi dalam kasus kedua, mungkin masuk akal untuk mengirim ulang pesan setelah beberapa waktu. <br><br>  Sekarang kita akan mempertimbangkan bagaimana mekanisme paling sederhana dari "laporan pengiriman" dapat diimplementasikan menggunakan amplop. <br><br>  Jadi, pertama-tama kita lakukan langkah persiapan yang diperlukan: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5_extra/enveloped_msg/just_envelope.hpp&gt; #include &lt;so_5_extra/enveloped_msg/send_functions.hpp&gt; #include &lt;so_5/all.hpp&gt; using namespace std::chrono_literals; namespace envelope_ns = so_5::extra::enveloped_msg; using request_id_t = int;</span></span></span></span></code> </pre><br>  Sekarang kita dapat mendefinisikan pesan yang akan digunakan dalam contoh.  Pesan pertama adalah permintaan untuk melakukan beberapa tindakan yang kita butuhkan.  Dan pesan kedua adalah konfirmasi bahwa pesan pertama mencapai penerima: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_id_t</span></span> m_id; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_data; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delivery_receipt_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//   request_t::m_id   request_t. request_id_t m_id; };</span></span></code> </pre> <br>  Selanjutnya, kita dapat mendefinisikan agent_tiga agen yang akan memproses pesan bertipe request_t.  Tetapi pemrosesan akan dengan meniru "menempel".  Yaitu  ia memproses request_t, setelah itu ia mengubah statusnya dari st_normal menjadi st_busy.  Dalam keadaan st_busy, ia tidak melakukan apa-apa dan mengabaikan semua pesan yang sampai padanya. <br><br>  Ini berarti bahwa jika agen processor_t mengirim tiga pesan request_t berturut-turut, itu akan memproses yang pertama dan dua lainnya akan dilemparkan, karena  saat memproses pesan pertama, agen akan pergi ke st_busy dan mengabaikan apa yang akan datang ketika sedang dalam st_busy. <br><br>  Dalam st_busy, agen processor_t akan menghabiskan 2 detik, setelah itu ia akan kembali ke st_normal dan akan siap untuk memproses pesan baru. <br><br>  Inilah yang terlihat seperti agen prosesor: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">processor_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   .     //   . state_t st_normal{this, "normal"}; //  " ".   . state_t st_busy{this, "busy"}; public: processor_t(context_t ctx) : so_5::agent_t{std::move(ctx)} { this &gt;&gt;= st_normal; st_normal.event(&amp;processor_t::on_request); //     ,    . //  2   ,    st_normal. st_busy.time_limit(2s, st_normal); } private: void on_request(mhood_t&lt;request_t&gt; cmd) { std::cout &lt;&lt; "processor: on_request(" &lt;&lt; cmd-&gt;m_id &lt;&lt; ", " &lt;&lt; cmd-&gt;m_data &lt;&lt; ")" &lt;&lt; std::endl; this &gt;&gt;= st_busy; } };</span></span></code> </pre> <br>  Sekarang kita dapat mendefinisikan agen request_generator_t, yang memiliki banyak permintaan yang perlu dikirim ke processor_t.  Agen request_generator_t mengirim seluruh paket setiap 3 detik, dan kemudian menunggu konfirmasi pengiriman dalam bentuk delivery_receipt_t. <br><br>  Ketika delivery_recept_t tiba, agen request_generator_t membuang permintaan yang dikirim keluar dari bundel.  Jika paket benar-benar kosong, maka contoh selesai.  Jika ada yang lain, maka paket yang tersisa akan dikirim lagi ketika pengiriman berikutnya tiba. <br><br>  Jadi di sini adalah kode agen request_generator_t.  Ini cukup banyak, tetapi primitif.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda hanya dapat memperhatikan internal metode send_requests (), di mana pesan request_t dikirim, dilampirkan dalam amplop khusus. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode agen requests_generator_t</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">requests_generator_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    . const so_5::mbox_t m_processor; //  ,       . std::map&lt;request_id_t, std::string&gt; m_requests; struct resend_requests final : public so_5::signal_t {}; public: requests_generator_t(context_t ctx, so_5::mbox_t processor) : so_5::agent_t{std::move(ctx)} , m_processor{std::move(processor)} { so_subscribe_self() .event(&amp;requests_generator_t::on_delivery_receipt) .event(&amp;requests_generator_t::on_resend); } void so_evt_start() override { //    . m_requests.emplace(0, "First"); m_requests.emplace(1, "Second"); m_requests.emplace(2, "Third"); m_requests.emplace(3, "Four"); //  . send_requests(); } private: void on_delivery_receipt(mhood_t&lt;delivery_receipt_t&gt; cmd) { std::cout &lt;&lt; "request delivered: " &lt;&lt; cmd-&gt;m_id &lt;&lt; std::endl; m_requests.erase(cmd-&gt;m_id); if(m_requests.empty()) //    .  . so_deregister_agent_coop_normally(); } void on_resend(mhood_t&lt;resend_requests&gt;) { std::cout &lt;&lt; "time to resend requests, pending requests: " &lt;&lt; m_requests.size() &lt;&lt; std::endl; send_requests(); } void send_requests() { for(const auto &amp; item : m_requests) { std::cout &lt;&lt; "sending request: (" &lt;&lt; item.first &lt;&lt; ", " &lt;&lt; item.second &lt;&lt; ")" &lt;&lt; std::endl; envelope_ns::make&lt;request_t&gt;(item.first, item.second) .envelope&lt;custom_envelope_t&gt;(so_direct_mbox(), item.first) .send_to(m_processor); } //       3 . so_5::send_delayed&lt;resend_requests&gt;(*this, 3s); } };</span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kami memiliki pesan dan agen yang harus menggunakan pesan ini untuk berkomunikasi. </font><font style="vertical-align: inherit;">Hanya ada satu hal kecil yang tersisa - entah bagaimana membuat pesan delivery_receipt_t tiba ketika mengirimkan request_t ke processor_t. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini dilakukan dengan menggunakan amplop ini:</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> custom_envelope_t final : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> envelope_ns::just_envelope_t { //     . const so_5::mbox_t m_to; // ID  . const request_id_t m_id; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: custom_envelope_t(so_5::message_ref_t payload, so_5::mbox_t <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, request_id_t id) : envelope_ns::just_envelope_t{std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(payload)} , m_to{std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>)} , m_id{id} {} <span class="hljs-type"><span class="hljs-type">void</span></span> handler_found_hook(handler_invoker_t &amp; <span class="hljs-keyword"><span class="hljs-keyword">invoker</span></span>) noexcept override { //    ,     . //     . so_5::send&lt;delivery_receipt_t&gt;(m_to, m_id); //      . envelope_ns::just_envelope_t::handler_found_hook(<span class="hljs-keyword"><span class="hljs-keyword">invoker</span></span>); } };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, tidak ada yang rumit. </font><font style="vertical-align: inherit;">Kami mewarisi dari so_5 :: extra :: enveloped_msg :: just_envelope_t. </font><font style="vertical-align: inherit;">Ini adalah jenis tambahan amplop yang menyimpan pesan yang terlampir di dalamnya dan menyediakan implementasi dasar dari hooks </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">handler_found_hook () dan transformation_hook (). </font><font style="vertical-align: inherit;">Oleh karena itu, kita hanya dapat menyimpan atribut yang kita butuhkan di dalam custom_envelope_t dan mengirim delivery_receipt_t di dalam kait handler_found_hook ().</font></font><br><br>  Faktanya, itu saja.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika kita menjalankan contoh ini, kita mendapatkan yang berikut: </font></font><br><br><pre> <code class="hljs vbscript">sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">0</span></span>, First) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">0</span></span>, First) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">3</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">2</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">1</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, saya harus mengatakan bahwa dalam praktiknya, custom_envelope_t sederhana untuk menghasilkan laporan pengiriman hampir tidak cocok. </font><font style="vertical-align: inherit;">Tetapi jika seseorang tertarik dengan topik ini, maka dapat dibahas dalam komentar, dan tidak menambah volume artikel.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa lagi yang bisa dilakukan dengan amplop? </font></font></h1><br>  Pertanyaan bagus!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami sendiri tidak memiliki jawaban yang komprehensif. </font><font style="vertical-align: inherit;">Mungkin, kemungkinan hanya dibatasi oleh imajinasi pengguna. </font><font style="vertical-align: inherit;">Nah, jika untuk realisasi fantasi di SObjectizer ada yang hilang, maka ini bisa diceritakan kepada kita. </font><font style="vertical-align: inherit;">Kami selalu mendengarkan. </font><font style="vertical-align: inherit;">Dan, yang penting, kadang-kadang kita lakukan :)</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Integrasi agen dengan mchain </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berbicara sedikit lebih serius, itu adalah fitur lain yang ingin saya miliki dari waktu ke waktu dan yang bahkan direncanakan untuk so_5_extra-1.2.0. Tetapi yang, kemungkinan besar, tidak akan jatuh ke rilis 1.2.0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini tentang menyederhanakan integrasi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kereta</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan agen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faktanya adalah bahwa awalnya rantai ditambahkan ke SObjectizer untuk menyederhanakan komunikasi agen dengan bagian lain dari aplikasi yang ditulis tanpa agen. Misalnya, ada utas utama aplikasi, di mana pengguna berinteraksi menggunakan GUI. Dan ada beberapa agen-pekerja yang melakukan pekerjaan "keras" latar belakang. Mengirim pesan ke agen dari utas utama tidak menjadi masalah: panggil saja pengiriman biasa. Tetapi bagaimana cara mentransfer informasi kembali?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk ini, mchain-s ditambahkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun seiring berjalannya waktu, ternyata kereta bisa memainkan peran yang jauh lebih besar. Mungkin, pada prinsipnya, untuk membuat aplikasi multithreaded pada SObjectizer tanpa agen sama sekali, hanya pada mchain-ahs (lebih detail di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Dan Anda dapat menggunakan mchain-s sebagai sarana untuk menyeimbangkan beban pada agen. Sebagai mekanisme untuk memecahkan masalah produsen-konsumen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah dengan produsen-konsumen adalah jika produsen menghasilkan pesan lebih cepat daripada yang dapat ditangani konsumen, maka kita dalam masalah. Antrian pesan akan bertambah, kinerja dapat menurun seiring waktu, atau aplikasi akan macet sama sekali karena kehabisan memori. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi biasa yang kami usulkan untuk digunakan dalam kasus ini adalah menggunakan</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sepasang agen penagih kolektor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Anda juga dapat menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">batas pesan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (baik sebagai mekanisme perlindungan utama, atau sebagai tambahan untuk pengumpul-pemain). Tetapi menulis kolektor-pemain membutuhkan pekerjaan tambahan dari programmer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi rantai dapat digunakan untuk tujuan ini dengan upaya minimal dari pengembang. Jadi, produser akan memasukkan pesan berikutnya di mchain, dan konsumen akan mengambil pesan dari mchain ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi masalahnya adalah bahwa ketika konsumen adalah agen, itu tidak terlalu nyaman bagi agen untuk bekerja dengan mchain melalui fungsi accept () dan select () yang tersedia. Dan ketidaknyamanan ini dapat dicoba untuk dihilangkan dengan bantuan beberapa alat untuk mengintegrasikan agen dan mchain-s.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat mengembangkan alat semacam itu, beberapa masalah perlu dipecahkan. Misalnya, ketika sebuah pesan tiba di mchain, pada titik apa pesan itu harus diekstraksi dari mchain? Jika konsumen bebas dan tidak memproses apa pun, maka Anda dapat mengambil pesan dari mchain segera dan memberikannya kepada agen konsumen. Jika pesan sudah dikirim ke konsumen dari mchain, dia belum berhasil memproses pesan ini, tetapi pesan baru telah tiba di mchain ... Apa yang harus dilakukan dalam kasus ini? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada spekulasi bahwa amplop dapat membantu dalam kasus ini. Jadi, ketika kami mengambil pesan pertama dari mchain dan mengirimkannya ke konsumen, kami membungkus pesan ini dalam amplop khusus. Ketika amplop melihat bahwa pesan telah dikirim dan diproses, ia meminta pesan berikutnya dari mchain (jika ada).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, semuanya tidak begitu sederhana di sini. </font><font style="vertical-align: inherit;">Namun sejauh ini tampilannya cukup solvable. </font><font style="vertical-align: inherit;">Dan, saya harap, mekanisme serupa akan muncul di salah satu versi so_5_extra berikutnya.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apakah kita akan membuka kotak Pandora? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlu dicatat bahwa dengan kita kemampuan tambahan itu sendiri menyebabkan perasaan ganda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di satu sisi, amplop sudah memungkinkan / memungkinkan untuk melakukan hal-hal yang sebelumnya disebutkan (tetapi hanya bermimpi tentang sesuatu). </font><font style="vertical-align: inherit;">Misalnya, ini adalah pembatalan dijamin timer dan pembatasan waktu pengiriman, laporan pengiriman, kemampuan untuk mengingat pesan yang sebelumnya dikirim. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sisi lain, tidak jelas apa yang akan terjadi selanjutnya. </font><font style="vertical-align: inherit;">Lagipula, Anda dapat membuat masalah dari peluang apa pun jika Anda mulai menggunakan peluang ini di tempat yang Anda butuhkan dan di mana Anda tidak. </font><font style="vertical-align: inherit;">Jadi mungkin kita membuka kotak Pandora dan kita masih tidak membayangkan apa yang menanti kita? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetap bersabar dan melihat ke mana semua ini akan menuntun kita.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tentang rencana pengembangan langsung SObjectizer alih-alih menyimpulkan </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih kesimpulan, saya ingin berbicara tentang bagaimana kita melihat masa depan SObjectizer yang sangat dekat (dan tidak hanya). Jika seseorang tidak senang dengan sesuatu dalam rencana kami, maka Anda dapat berbicara dan memengaruhi bagaimana SObjectizer-5 akan berkembang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versi beta pertama dari SObjectizer-5.5.23 dan so_5_extra-1.2.0 sudah diperbaiki dan tersedia untuk diunduh dan percobaan. Masih ada banyak pekerjaan yang harus dilakukan di bidang dokumentasi dan kasus penggunaan. Karena itu, rilis resmi direncanakan pada dekade pertama bulan November. Jika berhasil lebih awal, kami akan melakukannya lebih awal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelepasan SObjectizer-5.5.23 tampaknya berarti bahwa evolusi cabang 5.5 akan segera berakhir. Ini adalah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rilis pertama dari cabang ini diadakan empat tahun lalu, bulan Oktober 2014</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sejak itu, SObjectizer-5 telah berevolusi dalam cabang 5.5 tanpa ada perubahan besar antar versi. Itu tidak mudah. Terutama mengingat fakta bahwa selama ini kami harus melihat kembali pada kompiler yang jauh dari dukungan ideal untuk C ++ 11. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kami tidak melihat alasan untuk melihat kembali kompatibilitas di dalam cabang 5.5, dan terutama pada kompiler C ++ yang lebih lama. Apa yang bisa dibenarkan pada tahun 2014, ketika C ++ 14 baru saja siap untuk secara resmi diadopsi, dan C ++ 17 belum ada di cakrawala, sekarang terlihat sangat berbeda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus, dalam SObjectizer-5.5 sendiri sudah ada akumulasi cukup banyak rake dan backup, yang muncul karena kompatibilitas yang sama dan yang mempersulit pengembangan SObjectizer lebih lanjut.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleh karena itu, dalam beberapa bulan mendatang kita akan bertindak sesuai dengan skenario berikut: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Pengembangan versi selanjutnya dari so_5_extra, di mana saya ingin menambahkan alat untuk menyederhanakan penulisan tes untuk agen. Apakah itu akan so_5_extra-1.3.0 (mis. Dengan memecah perubahan relatif ke 1.2.0) atau apakah itu akan so_5_extra-1.2.1 (mis. Tanpa memecah perubahan) belum jelas. Mari kita lihat bagaimana kelanjutannya. Jelas bahwa versi so_5_extra berikutnya akan didasarkan pada SObjectizer-5.5.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1a. Jika untuk versi so_5_extra selanjutnya Anda perlu melakukan sesuatu tambahan di SObjectizer-5.5, maka versi berikutnya 5.5.24 akan dirilis. Jika untuk so_5_extra tidak perlu melakukan perbaikan pada kernel SObjectizer, maka versi 5.5.23 akan berubah menjadi versi signifikan terakhir dalam kerangka cabang 5.5. Rilis minor perbaikan bug akan keluar. Tetapi pengembangan cabang 5.5 itu sendiri berhenti pada versi 5.5.23 atau 5.5.24.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Kemudian versi SObjectizer-5.6.0 akan dirilis, yang akan membuka cabang baru. Di cabang 5.6, kami akan membersihkan kode SObjectizer dari semua kruk dan cadangan yang terakumulasi, serta dari sampah lama yang telah lama ditandai sebagai usang. Kemungkinan beberapa hal akan mengalami refactoring (misalnya, abstract_message_box_t dapat diubah), tetapi hampir tidak kardinal. Prinsip dasar kerja dan fitur karakteristik SObjectizer-5.5 di SObjectizer-5.6 akan tetap dalam bentuk yang sama. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5.6 sudah membutuhkan C ++ 14 (setidaknya pada level GCC-5.5). Kompiler Visual C ++ di bawah VC ++ 15 (yang berasal dari Visual Studio 2017) tidak akan didukung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menganggap cabang 5.6 sebagai cabang stabil dari SObjectizer, yang akan relevan sampai versi pertama SObjectizer-5.7 muncul.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya ingin merilis versi 5.6.0 pada awal 2019, tentatif pada bulan Februari. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Setelah menstabilkan cabang 5.6, kami ingin mulai bekerja pada cabang 5.7, di mana kami dapat merevisi beberapa prinsip dasar pekerjaan SObjectizer. Misalnya, sepenuhnya meninggalkan operator publik, hanya menyisakan yang pribadi. Mengulangi mekanisme koperasi dan hubungan orangtua-anak mereka, sehingga menghilangkan hambatan selama pendaftaran / deregistrasi koperasi. Hapus pembagian dengan pesan / sinyal. Hanya izinkan send / send_delayed / send_ periodic untuk mengirim pesan, dan sembunyikan metode deliver_message dan schedule_timer “di bawah tenda”. Ubah mekanisme untuk mengirim pesan sehingga menghapus dynamic_casts sepenuhnya dari proses ini, atau kurangi seminimal mungkin.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, ada tempat untuk berbalik. Pada saat yang sama, SObjectizer-5.7 sudah membutuhkan C ++ 17, tanpa memperhatikan C ++ 14. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda melihat hal-hal tanpa kacamata merah muda, ada baiknya jika rilis 5.7.0 terjadi pada akhir musim gugur 2019. Itu. versi kerja utama dari SObjectizer untuk 2019 akan menjadi cabang 5.6. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Sejalan dengan semua ini, so_5_extra akan berkembang. Mungkin, versi so_5_extra-2 akan dirilis bersama dengan SObjectizer-5.6, yang akan menggabungkan fungsionalitas baru selama 2019, tetapi berdasarkan pada SObjectizer-5.6.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, kita sendiri melihat evolusi progresif untuk SObjectizer-5 dengan revisi bertahap dari beberapa prinsip dasar SObjectizer-5. Pada saat yang sama, kami akan mencoba melakukan ini semulus mungkin sehingga memungkinkan untuk beralih dari satu versi ke versi lain dengan sedikit rasa sakit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, jika seseorang ingin perubahan yang lebih dramatis dan signifikan dari SObjectizer, maka </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami memiliki beberapa pemikiran tentang ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Singkatnya: Anda dapat membuat ulang SObjectizer sesuka Anda, segera untuk mengimplementasikan SObjectizer-6 untuk bahasa pemrograman lain. Tetapi kami tidak akan melakukan ini sepenuhnya dengan biaya kami sendiri, karena ini terjadi dengan evolusi SObjectizer-5.</font></font><br><br>  Itu mungkin saja.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komentar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk artikel sebelumnya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ternyata merupakan diskusi yang baik dan konstruktif. </font><font style="vertical-align: inherit;">Akan bermanfaat bagi kita jika diskusi serupa terjadi kali ini. </font><font style="vertical-align: inherit;">Seperti biasa, kami siap menjawab pertanyaan apa pun, tetapi untuk pertanyaan yang masuk akal, dan dengan senang hati. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan kepada pembaca yang paling sabar yang telah mencapai garis ini, banyak terima kasih atas waktu yang dihabiskan untuk membaca artikel.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426983/">https://habr.com/ru/post/id426983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426973/index.html">Sandwich perusahaan</a></li>
<li><a href="../id426975/index.html">Joker 2018: yang mustahil itu mungkin</a></li>
<li><a href="../id426977/index.html">LibreOffice: mimpi buruk akuntan</a></li>
<li><a href="../id426979/index.html">Cara belajar bahasa Inggris secara gratis: 3 alat umum dan instruksi terperinci untuk masing-masingnya</a></li>
<li><a href="../id426981/index.html">10 trik untuk dasbor tingkat lanjut di Splunk. Bagian 1</a></li>
<li><a href="../id426985/index.html">kubebox dan cangkang konsol lainnya untuk Kubernetes</a></li>
<li><a href="../id426987/index.html">Pelajari OpenGL. Pelajaran 6.3 - Pencahayaan Berbasis Gambar. Iradiasi difus</a></li>
<li><a href="../id426991/index.html">Startup Digest: 10 acara IT mendatang di Moskow</a></li>
<li><a href="../id426993/index.html">Apakah saya perlu belajar C untuk memahami cara kerja komputer?</a></li>
<li><a href="../id426995/index.html">Daur ulang membahayakan produk dan karyawan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>