<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèáüèª üàÇÔ∏è ‚ÜòÔ∏è (Statique) S√©lection de conteneurs optimaux dans les programmes C ++ üâë üå∫ üë∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour Aujourd'hui, je voudrais reparler de l'analyse statique. Et encore une fois √† propos de C ++. Seulement, contrairement √† PVS-Studio, nous ne r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>(Statique) S√©lection de conteneurs optimaux dans les programmes C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455379/">  Bonjour  Aujourd'hui, je voudrais reparler de l'analyse statique.  Et encore une fois √† propos de C ++.  Seulement, contrairement √† PVS-Studio, nous ne rechercherons aucune erreur dans nos programmes (bien qu'ils ne recherchent pas seulement des erreurs), mais des endroits qui ne sont pas √©crits de mani√®re optimale.  Et l'un de ces endroits est de choisir un conteneur pour les donn√©es du programme.  Si je vous int√©resse, alors bienvenue au chat! <br><a name="habracut"></a><br><h3>  Le probl√®me </h3><br>  Au CoreHard 2018 Autumn (une tr√®s bonne conf√©rence, venez), j'ai parl√© de la fa√ßon dont les compilateurs C ++ n'optimisent pas bien pour le moment.  Et l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une</a> de mes plaintes √©tait que les compilateurs ne peuvent pas optimiser l'utilisation des conteneurs dans nos programmes.  Regardons quelques exemples de code. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v(<span class="hljs-number"><span class="hljs-number">42</span></span>); }</code> </pre> <br>  Il semblerait que dans un cas aussi simple, le compilateur devrait √™tre en mesure d'optimiser cette fonction et de simplement jeter une d√©claration de variable de type std :: vector, car √† partir de C ++ 14, le compilateur est autoris√© √† supprimer les allocations de m√©moire dynamique, mais pas le compilateur.  La raison en est qu'√† l'heure actuelle, un seul compilateur C ++ impl√©mente l'optimisation pour supprimer les allocations dynamiques - Clang.  Jusqu'√† pr√©sent, tous les autres compilateurs ne savent pas comment proc√©der.  Mais m√™me Clang peut le faire dans un nombre limit√© de cas. <br><br>  Dans ce cas, nous pourrions remplacer std :: vector par std :: array, √† condition que la taille du vecteur s√©lectionn√© ne soit pas trop grande, car nous pourrions ne pas avoir assez de pile pour un tel remplacement.  Un tel remplacement supprimera une allocation de m√©moire assez ch√®re au tas, et le plus est que lors de l'utilisation de std :: array, le compilateur peut d√©j√† lancer std :: array de la fonction! <br><br>  Si nous parlons d'optimisation des performances, nous proposons de consid√©rer l'exemple suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">42</span></span>; ++i) { v.insert(v.begin(), <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> val : v) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br>  Dans ce cas, nous voyons l'utilisation d'une op√©ration extr√™mement inefficace dans le cas de std :: vector - insertion au d√©but du conteneur.  Tous les programmeurs C ++ savent que c'est extr√™mement mauvais √† faire, car cela fait que tous les √©l√©ments se d√©placent √† chaque fois, ce qui entra√Æne des co√ªts importants pour la copie / le d√©placement.  Il serait beaucoup plus agr√©able dans ce cas de le remplacer par std :: list, qui ne se soucie pas de l'endroit o√π l'insertion a lieu, ou std :: deque (bien que dans ce cas, vous puissiez clairement voir que vous n'avez pas seulement besoin d'utiliser insert. Mais ce n'est qu'un exemple, pas plus :) <br><br>  Regardons un autre exemple de code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { v.push_front(i); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> val : v) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br>  Dans ce cas, nous pouvons remarquer que nous pouvons remplacer sans douleur std :: list (oui, je sais que peu de gens l'utilisent) par std :: forward_list.  Dans ce cas, dans ce cas, nous ne perdrons absolument rien, mais nous obtiendrons des √©conomies de m√©moire.  Naturellement, le compilateur ne fait pas une telle optimisation maintenant. <br><br>  Une astuce similaire peut √™tre effectu√©e dans l'exemple suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">deque</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { v.push_back(i); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; v.back() &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; v.pop_back(); } }</code> </pre> <br>  Ici, nous pouvons voir que ce dont nous avons vraiment besoin n'est pas std :: deque, mais std :: stack.  Cela ne peut pas √™tre appel√© optimisation, car std :: stack est un adaptateur et, par d√©faut, il utilise std :: deque inside (sauf si l'utilisateur sp√©cifie le contraire).  Ici, nous pouvons parler davantage de l'optimisation s√©mantique, c'est-√†-dire  simplifier le code pour comprendre.  De mon point de vue, c'est √©galement important.  Si vous demandez: ¬´Peut-√™tre qu'un tel remplacement donne √©galement un gain de performances?¬ª, Je r√©pondrai ¬´Peut-√™tre.  Consultez les d√©tails de l'impl√©mentation dans votre version de la biblioth√®que standard. ¬ª <br><br>  Eh bien, je pense qu'il y a suffisamment d'exemples.  Chacun d'entre vous peut √©galement en proposer plusieurs. <br><br><h3>  Moyens utilis√©s </h3><br>  Pour impl√©menter l'analyseur statique, j'ai utilis√© Clang Static Analzyer (CSA) et Clang Tidy, qui font partie du package LLVM.  J'ai choisi ces outils, car je les consid√®re comme les plus prometteurs parmi les outils ouverts pour l'analyse statique.  De plus, Clang fournit l'un des analyseurs C ++ de la plus haute qualit√© que les autres analyseurs statiques ne peuvent pas se vanter (√† moins bien s√ªr qu'ils utilisent libclang). <br><br>  CSA et Clang Tidy sont des analyseurs statiques, qui font tous deux partie de LLVM.  Quelle est la diff√©rence?  La diff√©rence est que Clang Tidy est con√ßu pour √©crire des v√©rifications simples, qui consistent essentiellement √† trouver une sorte de mod√®le sur l'arbre de syntaxe abstraite, √† afficher une sorte d'avertissement, et √©ventuellement √† le remplacer automatiquement par une autre.  Vous pouvez en savoir plus sur Clang Tidy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  CSA est con√ßu pour √©crire des v√©rifications plus ¬´s√©rieuses¬ª et gourmandes en ressources (tant du point de vue de l'impl√©mentation que du temps d'ex√©cution / m√©moire d√©pens√©e).  L√†, par exemple, un m√©canisme d'ex√©cution symbolique est disponible. <br><br>  J'ai d√©cid√© de mettre en place le ch√®que en CSA, car cela ne me semble pas banal, d'ailleurs, √† l'avenir √ßa va devenir de plus en plus dur.  Et il a √©t√© d√©cid√© de passer par Clang Tidy, car cet analyseur statique a de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nombreuses</a> int√©grations avec divers IDE. <br><br><h3>  Comment nous allons (essayer) de r√©soudre les probl√®mes </h3><br>  Pour commencer, cela vaut la peine d'introduire quelques restrictions assez fortes, qui sont principalement li√©es au fait qu'il ne s'agit pour l'instant que d'un prototype: <br><br><ul><li>  Analyse uniquement au niveau des fonctions;  Cette limitation signifie qu'il n'y aura pas d'analyse entre les fonctions, ainsi qu'entre les unit√©s de traduction.  La restriction de l'analyse entre les fonctions a √©t√© impos√©e pour simplifier la mise en ≈ìuvre de cette analyse et, √† l'avenir, elle peut √™tre relativement facilement corrig√©e en ex√©cutant une analyse statique pour l'ensemble de l'unit√© de traduction, et pas seulement pour chaque fonction.  La restriction √† l'analyse entre les unit√©s de traduction est impos√©e par les restrictions existantes dans le CSA, qui seront bient√¥t fix√©es (les commits se d√©versent d√©j√† en amont); </li><li>  Prise en charge d'un nombre limit√© de conteneurs uniquement.  Ceci est relativement facilement r√©solu √† l'avenir en ajoutant de nouvelles r√®gles pour les nouveaux conteneurs. </li><li>  Utilisez pour l'analyse uniquement un arbre de syntaxe abstraite.  √âtant donn√© que pour le prototypage, il s'agit du type d'analyse le plus simple.  Pour des r√©sultats plus pr√©cis, bien s√ªr, vous pouvez essayer d'utiliser au moins une ex√©cution symbolique, mais cette m√©thode a ses inconv√©nients.  Vous pouvez en savoir plus sur les m√©thodes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </li></ul><br>  Maintenant, le prototype impl√©mente l'algorithme simple suivant: <br><br><ul><li>  Tout d'abord, sur l'arbre de syntaxe abstraite, nous trouvons les sommets qui sont responsables de la d√©claration des variables de type conteneur que nous prenons en charge. </li><li>  Ensuite, nous trouvons les op√©rations li√©es √† ces conteneurs, les classons et enregistrons ces informations dans un cache temporaire. </li><li>  Apr√®s avoir atteint la fin de la fonction, nous analysons les statistiques collect√©es et, sur la base de r√®gles pr√©d√©finies, √©mettons une recommandation sur l'utilisation d'un conteneur. </li></ul><br>  La classification des op√©rations de conteneurs pour le moment est la suivante (sera √©largie √† l'avenir): <br><br><ul><li>  Ajoutez un √©l√©ment en haut du conteneur. </li><li>  Ajout d'un √©l√©ment au milieu du conteneur. </li><li>  Ajout d'un √©l√©ment √† la fin du conteneur. </li><li>  Suppression d'un √©l√©ment au d√©but du conteneur. </li><li>  Retrait d'un √©l√©ment du milieu du conteneur. </li><li>  Retrait d'un √©l√©ment de la fin du conteneur. </li></ul><br>  Le classement pour le moment est incomplet et m√™me sur cette liste ne fonctionne pas correctement.  Par exemple, l'op√©ration d'insertion, m√™me si elle est effectu√©e au d√©but, l'analyseur se classe comme une insertion au milieu, bien qu'en fait elle ne l'est pas du tout. <br><br><h3>  Lutter contre les faux positifs </h3><br>  Dans toute analyse statique, les faux positifs sont le principal casse-t√™te.  S'il y en a trop, les messages utiles sont perdus √† la poubelle.  Par cons√©quent, dans ce cas, vous devez agir de mani√®re tr√®s conservatrice et √©mettre des avertissements uniquement dans les cas o√π nous sommes vraiment confiants dans nos diagnostics et pouvons tout √† fait dire que quelque chose ne va vraiment pas √† un endroit du code. <br><br>  Si nous parlons des optimisations du compilateur, c'est encore plus triste l√†-bas - les optimisations appropri√©es ne peuvent pas changer le comportement d'un programme selon la norme C ++ (sinon, un tel optimiseur ne vaut rien).  Et l'optimisation ne doit pas non plus introduire de pessimisation :) Donc, ici, vous devez √™tre beaucoup plus prudent dans vos d√©cisions. <br><br>  Dans cet analyseur, cette lutte a entra√Æn√© le fait que si l'analyseur constate qu'une op√©ration non prise en charge est en cours, l'analyse de ce conteneur est d√©sactiv√©e. <br><br><h3>  Inconv√©nients et solutions possibles </h3><br>  Il y a plusieurs probl√®mes avec cette m√©thode. <br><br>  Le premier probl√®me est que pour l'analyseur pour le moment, toutes les branches du code sont √©galement probables.  Plus pr√©cis√©ment, il ne conna√Æt m√™me pas les diff√©rentes branches de l'ex√©cution du code. <br>  Cela se traduit par des probl√®mes d'analyse pour quelque chose comme ce code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* ptr, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ptr == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { v.insert(v.begin(), <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { v.push_back(<span class="hljs-number"><span class="hljs-number">84</span></span>); } }</code> </pre> <br>  Tr√®s probablement, dans notre application, ces branches de code n'ont pas des probabilit√©s √©gales d'ex√©cution, car dans le monde r√©el, un pointeur indique g√©n√©ralement quelque chose de normal, et non nullptr.  Dans le m√™me LLVM, il existe des heuristiques statiques sur ce score.  Par exemple, il prend en compte le cas ci-dessus en comparant les pointeurs avec nullptr, et en comparant entre eux l'√©galit√© des valeurs de deux variables avec une virgule flottante, et quelques autres cas int√©ressants.  Mais cela ressemble de plus en plus √† des b√©quilles, et de mon point de vue, la vraie solution √† ce probl√®me est d'ajouter une analyse dynamique ou une instrumentation. <br><br>  Le deuxi√®me probl√®me est le manque de prise en charge des conteneurs personnalis√©s.  Nous vivons dans le monde du C ++, ils aiment rouler ici (laissons les discussions sur les raisons de ce ph√©nom√®ne pas toujours mauvais en dehors du cadre de cet article) tout, y compris nos conteneurs.  Les exemples incluent le m√™me LLVM, LibreOffice et bien d'autres.  √Ä cet √©gard, la question se pose - comment analyser les conteneurs ne provenant pas de la biblioth√®que STL?  Apr√®s tout, je voudrais inclure une analyse pour autant de conteneurs que possible. <br><br>  Il existe diff√©rentes mani√®res de r√©soudre le probl√®me. <br><br>  La premi√®re est que l'utilisateur annote ses conteneurs d'une mani√®re ou d'une autre (un type sp√©cial de commentaire, des attributs C ++, autre chose).  Le probl√®me avec cette m√©thode est que nous devons comprendre comment annoter en g√©n√©ral, quelles informations nous avons besoin pour une analyse qualitative.  Un autre probl√®me peut √™tre la modification du code des conteneurs eux-m√™mes, ce qui n'est pas toujours possible. <br><br>  La deuxi√®me m√©thode offre √† l'utilisateur un m√©canisme pour √©crire ses propres r√®gles.  Pour le moment, les r√®gles de l'analyseur sont cousues dans le code source de l'analyseur lui-m√™me, et si l'utilisateur veut ajouter ses propres r√®gles, il devra alors t√©l√©charger le code source de l'analyseur, l'assembler, comprendre comment √©crire des ch√®ques, √©crire, reconstruire, etc.  Vous pouvez fournir √† l'utilisateur un moyen de d√©finir ses contr√¥les sur certains DSL, o√π l'utilisateur √©crit uniquement des contr√¥les pour ses conteneurs, et l'analyseur est engag√© dans l'ensemble de la routine.  Je consid√®re cette m√©thode comme plus prometteuse que la pr√©c√©dente. <br><br>  De plus, le remplacement automatique de conteneur n'est pas pris en charge, car cette fonctionnalit√© n'est pas dans CSA (mais elle est dans Clang Tidy).  Mais dans les cas difficiles, l'ex√©cution de la correction automatique n'est pas toujours une t√¢che triviale et l'analyseur fonctionne plus probablement en mode semi-manuel. <br><br><h3>  Applications possibles </h3><br>  Je vois plusieurs applications pour ce type d'analyse: <br><br><ol><li>  Comme un analyseur statique.  Tout est simple ici - un autre test d'analyse statique, que vous ex√©cutez √† votre guise (avec vos mains, dans l'EDI automatiquement pendant le d√©veloppement, sur CI, etc.), o√π vous recevrez probablement un indice que quelque part vous pourriez ramasser un conteneur et mieux. </li><li>  Comme l'optimisation dans le compilateur.  Dans certains cas, nous pouvons garantir que le remplacement du conteneur n'affectera certainement pas les performances.  Par exemple, remplacer std :: vector pour les petites tailles connues au moment de la compilation par std :: array ou remplacer std :: list par std :: forward_list lorsque nous n'avons pas besoin de connexion binaire et que nous ne prenons pas la taille de la liste.  Le compilateur pourrait remplacer les conteneurs par des conteneurs plus optimaux √† notre insu, comme il le fait d√©j√† pour un tr√®s grand nombre de choses. </li><li>  Comme un analyseur dynamique.  C'est la direction qui me semble la plus prometteuse pour ce type d'analyse.  En effet, √† l'aide de connaissances sur le profil d'ex√©cution du programme, nous pouvons, par exemple, obtenir pour nous des informations aussi importantes que les probabilit√©s d'ex√©cution de chaque branche de code.  Et cela est n√©cessaire pour une √©valuation plus pr√©cise.  Et avec une telle analyse, vous pouvez d√©j√† penser dans le sens de l'int√©gration avec PGO ... </li></ol><br>  Il convient √©galement de noter que cette m√©thode est bien s√ªr applicable non seulement aux programmes C ++.  J'aimerais vraiment voir ce genre d'analyse / optimisation statique dans le compilateur et pour d'autres langages de programmation.  Par exemple, l'analyseur statique SAP pour ABAP sait d√©j√† comment effectuer une analyse d'optimalit√© statique √† un niveau de base, ce qui est une bonne nouvelle.  Si vous connaissez des projets similaires pour d'autres langages de programmation - √©crivez dans les commentaires et j'ajouterai √† l'article! <br><br><h3>  Travailler dans des directions similaires </h3><br>  Pour le monde C ++, je n'ai trouv√© de tels analyseurs nulle part.  Pour le monde ABAP, j'ai mentionn√© l'analyseur ci-dessus, qui peut trouver des op√©rations inefficaces pour une partie des conteneurs standard, mais √† ma connaissance, une analyse statique tr√®s simple y est impl√©ment√©e. <br><br>  Un travail beaucoup plus int√©ressant est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chameleon</a> - un analyseur dynamique pour Java, qui est tr√®s intelligemment fait.  Ils ont l√©g√®rement modifi√© la machine virtuelle Java et, pendant le fonctionnement, ils collectent diverses statistiques sur l'utilisation des conteneurs et, en fonction du profil de charge actuel, ils s√©lectionnent certains conteneurs et les remplacent automatiquement pendant le fonctionnement.  Malheureusement, les sources sont ferm√©es et il n'y a aucune chance de les obtenir (j'ai essay√©). <br><br>  Je recommande √©galement de regarder diff√©rents travaux (il y en a beaucoup) sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SETL</a> .  Dans ces documents, les auteurs ont √©galement souvent pos√© des questions sur la s√©lection automatique du conteneur. <br><br><h3>  Les r√©f√©rences </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Impl√©mentation</a> actuelle sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++ Russia 2017: Yuri Efimochev, clang-tidy: a journey inside C ++ Abstract Syntax Tree</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cam√©l√©on: s√©lection adaptative des collections</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide de l'analyseur statique Clang</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Discussion en russe</a> sur le d√©veloppement de compilateurs dans Telegram.  Si vous √™tes int√©ress√©, entrez, c'est tr√®s int√©ressant l√†-bas.  Faites juste attention au d√©luge - ils le puniront imm√©diatement :) </li></ol><br>  Au lieu d'une conclusion, je voudrais me concentrer sur le fait qu'il ne s'agit pour l'instant que d'un prototype et qu'il a trop de ¬´trous¬ª dans la mise en ≈ìuvre.  Dans cet article, je veux juste partager avec vous l'id√©e d'une telle analyse et sa vulgarisation.  Eh bien, peut-√™tre que quelqu'un sera int√©ress√© par ce sujet et qu'il y aura un d√©sir de se connecter au projet - je ne serai que heureux!  De plus, vous pouvez toujours r√©cup√©rer cet analyseur √† votre place pour l'essayer sur vos exemples de test. <br><br>  Si vous avez quelque chose √† compl√©ter le mat√©riel, avez rencontr√© une t√¢che similaire, ou avez simplement des informations qui peuvent √™tre utiles sur ce sujet - n'h√©sitez pas √† partager ces informations dans les commentaires. <br><br>  Merci de votre attention! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455379/">https://habr.com/ru/post/fr455379/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455369/index.html">Certification des administrateurs de bases de donn√©es et bien plus encore lors de l'anniversaire DevConfX (21-22 juin √† Moscou)</a></li>
<li><a href="../fr455371/index.html">Source de courant stable de 5 ŒºA √† 20 mA</a></li>
<li><a href="../fr455373/index.html">Comment ajuster la loi du printemps pour qu'elle devienne porteuse pour les petits prestataires? L'annuler</a></li>
<li><a href="../fr455375/index.html">Ecrire UDR en Pascal</a></li>
<li><a href="../fr455377/index.html">Architecture IoT</a></li>
<li><a href="../fr455381/index.html">Le support technique de 3CX r√©pond: capturez le trafic SIP sur le serveur PBX</a></li>
<li><a href="../fr455387/index.html">Comprendre l'apprentissage automatique dans Elastic Stack (aka Elasticsearch, aka ELK)</a></li>
<li><a href="../fr455389/index.html">Haxe 4: Quoi de neuf?</a></li>
<li><a href="../fr455391/index.html">Partie 1: RISC-V / RocketChip dans un habitat non naturel</a></li>
<li><a href="../fr455393/index.html">Sur l'utilisation des m√©thodes param√©triques d'estimation spectrale en radar - la m√©thode MUSIC. Ajout √† l'article</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>