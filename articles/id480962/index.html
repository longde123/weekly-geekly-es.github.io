<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💞 📙 🤡 Pengembangan kompiler C untuk neuroprosesor multiclet baru 👩‍👧‍👧 🥃 ♠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada konferensi pengembang perangkat lunak sistem dan alat - OS DAY 2016, yang diadakan di Innopolis pada 9-10 Juni 2016 (Kazan) ketika membahas lapor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan kompiler C untuk neuroprosesor multiclet baru</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480962/"><img src="https://habrastorage.org/webt/nm/q_/3x/nmq_3x1b_eccqomclbciqkb5go8.jpeg"><br><br>  Pada konferensi pengembang perangkat lunak sistem dan alat - OS DAY 2016, yang diadakan di Innopolis pada 9-10 Juni 2016 (Kazan) ketika membahas laporan arsitektur multiseluler, gagasan itu menyatakan bahwa itu akan paling efektif dalam menyelesaikan masalah kecerdasan buatan.  Kondisi untuk pengembangan prosesor tujuan umum baru yang berfokus pada tugas AI telah dikembangkan tahun ini. <br><br>  Neuroprocessor S2 Multiclet, proyek yang pertama kali dipresentasikan di Huawei Innovation Forum 2019, adalah pengembangan lebih lanjut dari arsitektur multicell.  Ini berbeda dari multisel yang dibuat sebelumnya dengan sistem perintah, yaitu, pengenalan tipe baru data berukuran kecil (dengan titik tetap dan mengambang) dan operasi dengannya.  Jumlah sel meningkat - 256 dan frekuensi - 2,5 GHz, yang seharusnya memberikan kinerja puncak 81,9 TFlops pada 16F dan, karenanya, membuatnya sebanding, dalam hal perhitungan saraf, dengan kemampuan TPU ASIC khusus modern (TPU-3: 90 TFlops di 16F). <br><br>  Karena efisiensi menggunakan prosesor sangat tergantung pada optimalitas kompiler, skema optimisasi kode yang dikembangkan telah dikembangkan. <br>  Mari kita pertimbangkan lebih terinci. <br><a name="habracut"></a><br>  <a href="https://habr.com/ru/post/434982/">Artikel sebelumnya</a> menyebutkan optimisasi kompiler yang layak diterapkan.  Di sana Anda dapat menemukan materi tentang arsitektur multiseluler jika Anda belum terbiasa dengannya. <br><br><h4>  Menghasilkan Perintah Dua-Argumen dengan Dua Konstanta </h4><br>  Format instruksi baru telah diperkenalkan dengan prosesor S1, yang memungkinkan kedua argumen ditetapkan sebagai nilai konstan.  Ini memungkinkan Anda untuk mengurangi jumlah perintah dalam kode, menyingkirkan perintah yang tidak perlu seperti memuat untuk memuat konstanta di sakelar. <br><br>  Sebagai contoh: <br><br><pre><code class="plaintext hljs">load_l func wr_l @1, #SP</code> </pre> <br>  dapat diganti dengan: <br><br><pre> <code class="plaintext hljs">wr_l func, #SP</code> </pre> <br>  Atau bahkan dua tim sekaligus: <br><br><pre> <code class="plaintext hljs">load_l [foo] load_l [bar] add_l @1, @2</code> </pre> <br>  Ada dua alamat konstan, dan membaca dari mereka juga dapat diganti secara langsung ke argumen perintah: <br><br><pre> <code class="plaintext hljs">add_l [foo], [bar]</code> </pre><br>  Optimasi ini diterapkan untuk semua orang yang mendukung format ini.  Sayangnya, itu ternyata sangat tidak efektif, karena dua alasan: <br><br><ul><li>  Jumlah situasi di mana optimasi tersebut dapat dilakukan sangat kecil.  Dalam kode arbitrase, situasi jarang muncul ketika Anda perlu memproses dua nilai yang diketahui sebelumnya.  Paling sering, hal-hal seperti itu diputuskan pada tahap kompilasi, dan hanya sedikit yang harus dilakukan dalam runtime.  Biasanya ini adalah beberapa operasi pada alamat, sekali lagi, konstan. </li><li>  Menghapus perintah beban tidak membebaskan prosesor dari proses menghasilkan konstanta, tetapi hanya dari mengambil perintah beban terpisah, yang hanya memberikan akselerasi yang lemah, dan itupun tidak selalu. </li></ul><br><h4>  Optimalisasi transfer register virtual antara unit dasar </h4><br>  Dalam LLVM, blok dasar adalah bagian linier di mana kode dieksekusi tanpa bercabang.  Paragraf dalam arsitektur multiseluler melakukan fungsi yang persis sama, oleh karena itu, paling sering ketika menghasilkan kode, satu paragraf mencerminkan satu blok dasar.  Dalam prosesor R1, setiap transfer register virtual antara paragraf dilakukan melalui memori dengan menulis nilai register yang diinginkan ke stack dan membacanya kembali ke paragraf yang membutuhkan register ini.  Mekanisme ini dibagi menjadi 2 bagian: transfer register virtual ke paragraf lain untuk penggunaan langsung dan transfer register virtual sebagai parameter untuk simpul phi. <br><br>  Phi node adalah konsekuensi dari bentuk <a href="https://ru.wikipedia.org/wiki/SSA" rel="nofollow">SSA (Static Single Assignment)</a> di mana bahasa presentasi LLVM diwakili.  Dalam bentuk ini, variabel (atau, seperti dalam kasus LLVM IR - register virtual) dapat ditulis hanya sekali.  Misalnya, kode semu ini: <br><br><pre> <code class="cpp hljs">a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span>; b = a;</code> </pre> <br>  tidak disajikan dalam bentuk SSA, karena nilai variabel <b>a</b> dapat ditimpa.  Kode dapat ditulis ulang dalam bentuk ini, jika Anda menggunakan phi node: <br><br><pre> <code class="cpp hljs">a1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) a2 = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> a3 = <span class="hljs-number"><span class="hljs-number">3</span></span>; b = phi(a2, a3);</code> </pre> <br>  Node phi memilih a2 atau a3, tergantung dari mana aliran kontrol berasal: <br><img src="https://habrastorage.org/webt/ug/rw/-b/ugrw-brljdidipmpwg-iobfvjkm.png"><br>  Dalam phi IR LLVM, node diimplementasikan sebagai instruksi terpisah, yang memilih register virtual yang berbeda tergantung pada unit dasar mana kontrol berasal.  Implementasi pada prosesor instruksi ini melalui memori cukup sederhana: blok dasar yang berbeda menulis data yang berbeda ke sel memori yang sama, dan sebagai pengganti node phi, sel memori ini dibaca, dan data akan berbeda tergantung pada blok dasar sebelumnya. <br><br>  Formulir SSA menyiratkan bahwa ketika register diinisialisasi, nilai akan selalu sama.  Ketika transfer langsung register virtual dilakukan, ketika nilai setiap register virtual ditulis ke sel memori terpisahnya sendiri, kondisi SSA terpenuhi tanpa masalah: data ada di memori sampai ditimpa.  Namun, jika kita ingin mentransfer register melalui switch, kita harus ingat: ukurannya hanya 63 sel, dan nilai apa pun menghilang ketika 63 perintah dieksekusi.  Oleh karena itu, jika register virtual ditulis dalam beberapa paragraf pertama, dan digunakan setelah ratusan lainnya selesai, maka tidak mungkin untuk mentransfernya melalui sakelar;  hanya memori yang tersisa. <br>  Implementasi optimasi ini dimulai tepat dengan optimalisasi node phi, karena, tidak seperti transfer langsung register virtual, nilai parameter untuk node phi selalu diinisialisasi langsung dalam paragraf sebelumnya (blok dasar), yang memungkinkan Anda untuk tidak terlalu memikirkan apakah switch cukup besar. jika kita ingin melewatkan parameter ini melaluinya. <br><br>  Assembler multiseluler memungkinkan Anda untuk menetapkan nama ke hasil perintah, dan menggunakan hasilnya dengan nama ini.  Alih-alih setiap programmer harus menghitung berapa banyak perintah hasil ini diperoleh kembali, assembler menghitung ini sendiri: <br><br><pre> <code class="plaintext hljs">result := add_l [A], [B] ; ;    ; wr_l @result, C</code> </pre> <br>  Mekanisme ini berfungsi sempurna dalam paragraf saat ini, karena ini adalah bagian linier dan urutan perintahnya diketahui di sana.  Ini digunakan secara aktif ketika kompiler menghasilkan kode: semua perintah diberikan nama dan kompiler tidak perlu khawatir tentang penomoran perintah.  Lebih tepatnya, itu tidak perlu, karena jika kita ingin mendapatkan hasil dari perintah yang dieksekusi dalam paragraf lain, maka mekanismenya tidak berfungsi: pada tahap perakitan tidak mungkin untuk mengetahui paragraf mana yang sebenarnya dieksekusi oleh paragraf sebelumnya jika ada beberapa input pada perintah saat ini.  Oleh karena itu, satu-satunya pilihan adalah mengakses hasil tim melalui nomor.  Untuk alasan ini, Anda tidak bisa hanya membuang catatan / bacaan tambahan dari memori di paragraf yang berdekatan dan mengganti referensi register dari perintah read dengan perintah di paragraf sebelumnya. <br><br>  Di sini perlu diperhatikan konsekuensi yang sangat penting: jika sebuah paragraf memiliki beberapa input, maka <b>@ 1</b> pada perintah pertama bagian ini dapat merujuk ke hasil yang sama sekali berbeda, tergantung pada paragraf mana yang sebelumnya.  Simpul Phi hanya situasi seperti itu.  Sebelumnya, di semua blok dasar menginisialisasi node phi, data ditulis ke sel memori yang sama, dan di tempat node phi ada pembacaan dari sel ini.  Dengan demikian, sama sekali tidak penting tempat di mana ada catatan dalam sel ini di paragraf sebelumnya, sama seperti tempat di mana sel ini dibaca.  Jika Anda menyingkirkan penggunaan memori - itu berubah. <br><br>  Untuk mengizinkan host phi menggunakan sakelar alih-alih memori, berikut ini dilakukan: <br><br><ol><li>  Semua node phi dalam unit dasar saat ini dihitung (dan mungkin ada beberapa), ditandai dengan nomor seri dan diatur dalam urutan ini </li><li>  Untuk setiap simpul phi, blok dasar yang menginisialisasinya dilewati; perintah untuk memuat nilai ke sakelar ( <b>loadu_q</b> ), ditandai dengan nomor seri dari simpul phi yang sesuai, ditambahkan ke dalamnya </li><li>  Instruksi phi dari simpul itu sendiri juga digantikan oleh <b>loadu_q</b> dengan nomor seri </li><li>  Semua perintah yang ditambahkan disusun kembali dalam urutan yang diberikan </li></ol><br>  Poin keempat diperlukan karena alasan yang telah ditunjukkan: jika kita ingin perintah <b>loadu_q @ 3</b> mengakses hasil khusus untuk simpul phi-nya, maka semua paragraf inisialisasi dari perintah yang memuat data ke sakelar harus dalam urutan yang persis sama.  Mari kita beri contoh hasil nyata dari kompilasi kode di mana ada dua node phi dalam satu unit dasar. <br><br>  Paragraf dengan inisialisasi node ph: <br><br><pre> <code class="plaintext hljs">LBB1_27: LBB1_30: SR4 := loadu_q @1 setjf_l @0, LBB1_31 setjf_l @0, LBB1_31 SR4 := loadu_q [#SP + 8] SR5 := loadu_q [#SP + 16] SR5 := loadu_q [#SP] SR6 := loadu_l 0x1 SR6 := add_l @SR4, 0xffffffff SR7 := add_l @SR6, [@SR4] loadu_q @SR5 wr_l @SR7, @SR4 loadu_q @SR6 loadu_q @SR6 complete loadu_q @SR5 complete</code> </pre><br>  Paragraf dengan dua node phi: <br><br><pre> <code class="plaintext hljs">LBB1_31: SR4 := loadu_q @2 SR5 := loadu_q @2 SR6 := loadu_l [#SP + 124] SR7 := loadu_l [#SP + 120] setjf_l @0, @SR7 setrg_q #RETV, @SR4 wr_l @SR5, @SR6 setrg_q #SP, #SP + 120 complete</code> </pre> <br>  Sebelumnya, alih- <b>alih</b> perintah <b>loadu_q,</b> akan ada tulisan ke memori dan dibaca dari itu. <br>  Dalam proses penerapan optimasi ini, ada juga beberapa masalah yang tidak diperkirakan sebelumnya: <br><br><ul><li>  Beberapa optimasi kode yang ada mengatur ulang perintah di tempat, misalnya, menempatkan alamat paragraf berikutnya ke bagian paling awal dari yang sekarang, atau lokasi memori membaca / menulis perintah di awal / akhir paragraf, masing-masing.  Optimalisasi ini terjadi setelah operasi dengan phi nodes (yang disebut menurunkan instruksi LLVM sebelum instruksi prosesor), sehingga sering mengganggu urutan dibangun perintah <b>loadu_q</b> .  Agar tidak mengganggu pekerjaan optimasi ini, saya harus membuat pass LLVM terpisah, yang mengatur perintah untuk node phi dalam urutan yang benar setelah semua manipulasi lainnya dengan perintah. </li><li>  Ternyata suatu situasi dapat muncul di mana satu unit dasar menginisialisasi node phi untuk dua unit dasar yang berbeda.  Artinya, mengikuti algoritma yang ditunjukkan, blok-blok dasar ini akan ditambahkan ke perintah inisialisasi <b>loadu_q</b> untuk setiap node phi.  Dalam hal ini, bahkan jika mereka hanya memiliki satu simpul phi, di bagian inisialisasi akan ada 2 <b>perintah loadu_q</b> , yang, secara logis, keduanya harus berada di tempat terakhir, yang, tentu saja, tidak mungkin.  Untungnya, situasi seperti itu cukup langka, jadi jika ada unit dasar di mana node phi diinisialisasi untuk lebih dari satu unit dasar lainnya, maka hanya yang pertama menggunakan saklar sesuai dengan algoritma, untuk sisanya - seperti sebelumnya, melalui memori. </li></ul><br>  Semua optimasi phi node ini dapat ditambah sedikit lagi.  Misalnya, jika Anda melihat paragraf <b>LBB1_30 di</b> atas, Anda dapat melihat bahwa <b>loadu_q memerintahkan</b> nilai-nilai yang tidak digunakan di tempat lain.  Yaitu, jika Anda menghapus <b>loadu_q</b> dan mengatur perintah yang membuat nilai-nilai ini dalam urutan yang sama, maka perintah <b>loadu_q @ 2</b> di bagian selanjutnya juga akan memuat nilai yang benar. <br><br><h4>  Tingkatan yang dicapai </h4><br>  Hasil optimasi saat ini diuji pada benchmark CoreMark dan WhetStone, deskripsi yang dapat ditemukan di <a href="https://habr.com/ru/post/434982/">artikel sebelumnya</a> .  Mari kita mulai dengan hasil CoreMark pada inti S2 dibandingkan dengan hasil lama (versi sebelumnya dari kompiler pada inti S1). <br><div class="scrollable-table"><table><tbody><tr><th>  CPU </th><th>  <b>Multiclet s2</b> </th><th>  Multiclet s1 </th><th>  Elbrus-4C (E2S) </th><th>  Texas Inst.  AM5728 ARM Cortex-A15 </th><th>  Baikal-t1 </th><th>  Intel Core i7 7700K </th></tr><tr><td>  Frekuensi jam, MHz </td><td>  <b>2500</b> </td><td>  1600 </td><td>  800 </td><td>  1500 </td><td>  1200 </td><td>  4500 </td></tr><tr><td>  Skor keseluruhan CoreMark </td><td>  <b>122425</b> </td><td>  18356 </td><td>  8850 </td><td>  15789 </td><td>  13142 </td><td>  182128 </td></tr></tbody></table></div><br>  Nilai-nilai CoreMark / MHz relatif ditampilkan dalam histogram: <br><br><img src="https://habrastorage.org/webt/nw/c6/kw/nwc6kwtqwiejo48poskzc0zrzky.png"><br><br>  Untuk mendapatkan perkiraan akselerasi hanya karena optimalisasi node phi, Anda dapat menghitung ulang indikator CoreMark pada satu multisel pada inti S1 dan S2 untuk frekuensi 1600 MHz: masing-masing adalah 1147 dan 1224, yang berarti peningkatan sebesar 6,7%. <br><br>  Dengan WhetStone, situasinya agak berbeda.  Perubahan dalam kernel di sini mempengaruhi hasil, di samping itu, benchmark ini berjalan pada satu inti (multicell) dan dihitung dalam hal megahertz, sehingga frekuensi prosesor tidak memainkan peran apa pun. <br><br>  Kartu Skor Whetstone: <br><div class="scrollable-table"><table><tbody><tr><th>  CPU </th><th>  <b>MultiClet S2</b> </th><th>  MultiClet S1 </th><th>  Core i7 4820K </th><th>  ARM v8-A53 </th></tr><tr><td>  MWIPS / MHz </td><td>  <b>0,326</b> </td><td>  0,342 </td><td>  0,887 </td><td>  0,642 </td></tr><tr><td>  MFLOPS1 / MHz </td><td>  <b>0,141</b> </td><td>  0,156 </td><td>  0,341 </td><td>  0,268 </td></tr><tr><td>  MFLOPS2 / MHz </td><td>  <b>0,094</b> </td><td>  0,111 </td><td>  0,308 </td><td>  0,241 </td></tr><tr><td>  MFLOPS3 / MHz </td><td>  <b>0,108</b> </td><td>  0,124 </td><td>  0,167 </td><td>  0,239 </td></tr><tr><td>  COS MOPS / MHz </td><td>  <b>0,007</b> </td><td>  0,008 </td><td>  0,023 </td><td>  0,028 </td></tr><tr><td>  EXP MOPS / MHz </td><td>  <b>0,005</b> </td><td>  0,005 </td><td>  0,014 </td><td>  0,004 </td></tr><tr><td>  FIXPT MOPS / MHz </td><td>  <b>0,115</b> </td><td>  0,116 </td><td>  0,998 </td><td>  1.197 </td></tr><tr><td>  JIKA MOPS / MHz </td><td>  <b>0,196</b> </td><td>  0,196 </td><td>  1,504 </td><td>  1.436 </td></tr><tr><td>  EQUAL MOPS / MHz </td><td>  <b>0,156</b> </td><td>  0,149 </td><td>  0,251 </td><td>  0,439 </td></tr></tbody></table></div><br>  Sekarang jelas bahwa bahkan ketika menggunakan versi kompiler sebelumnya pada kernel S1, indeks keseluruhan lebih tinggi, terutama karena tes titik mengambang MFLOPS1-3.  Kelemahan ini diperhatikan selama pengujian dan disebabkan oleh fakta bahwa conveyor internal blok floating point di S2, dibandingkan dengan S1, adalah satu langkah lebih jauh.  Akibatnya, rantai berurutan dari perintah terkait data kehilangan satu ukuran pada setiap perintah.  Perlunya langkah ini disebabkan oleh pengurangan durasi clock cycle (peningkatan frekuensi prosesor dari 1,6 GHz menjadi 2,5 GHz dan peningkatan nomenklatur perintah, misalnya, tampilan perintah perkalian dengan akumulasi MAC).  Keputusan ini bersifat sementara.  Upaya untuk mengurangi panjang pipa sedang berlangsung, dan di masa depan ini akan diperbaiki, tetapi tes dilakukan pada versi S2 saat ini. <br><br>  Untuk mengevaluasi percepatan optimasi kompiler, WhetStone juga dikompilasi pada versi sebelumnya dan diluncurkan pada versi S2 saat ini.  Indikator total adalah 0,3068 MWIPS / MHz versus 0,3267 MWIPS / MHz pada kompiler baru, yaitu  yang menunjukkan akselerasi 6,5% karena optimasi di atas. <br><br>  Sistem optimisasi yang dikembangkan dan diuji memungkinkan Anda untuk mengimplementasikan skema optimasi selanjutnya, yaitu transfer langsung register virtual melalui sakelar.  Seperti yang telah disebutkan, tidak setiap salinan register virtual dapat dilakukan melalui sakelar.  Karena ukuran saklar yang terbatas dan ketidakmampuan untuk mengakses dengan benar hasil paragraf sebelumnya jika ada beberapa titik masuk ke yang sekarang (ini sebagian diselesaikan oleh node phi), satu-satunya pilihan yang mungkin adalah menyalin register virtual dari satu paragraf langsung ke paragraf berikutnya, tetapi hanya ada satu sebelumnya .  Kasus-kasus seperti itu, pada kenyataannya, tidak sedikit, cukup sering perlu untuk mentransfer data secara langsung, meskipun berapa banyak akselerasi kode yang akan diberikan untuk mengatakan di muka, tentu saja, sulit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480962/">https://habr.com/ru/post/id480962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480950/index.html">Analisis kuis Android dari stand hh.ru di Mobius 2019 Moscow</a></li>
<li><a href="../id480954/index.html">Tugas nomor 1. Cari tahu jenis kelamin dan tingkat hubungan</a></li>
<li><a href="../id480956/index.html">Bagaimana saya menemukan cara untuk melacak semua driver Citimobil</a></li>
<li><a href="../id480958/index.html">Koneksi satelit. Tinjauan perusahaan operator dan sedikit tentang peringkat</a></li>
<li><a href="../id480960/index.html">Temukan file yang hilang di beberapa target Xcode</a></li>
<li><a href="../id480964/index.html">Apakah zona Fresnel dan CCQ (Kualitas Koneksi Klien) atau faktor mendasar dari jembatan nirkabel berkualitas tinggi</a></li>
<li><a href="../id480970/index.html">10 praktik terbaik untuk mengamankan gambar Docker. Bagian 1</a></li>
<li><a href="../id480974/index.html">Pengembangan aplikasi dalam aplikasi mini VK</a></li>
<li><a href="../id480976/index.html">Perpustakaan Pengujian API JSON-RPC</a></li>
<li><a href="../id480978/index.html">Apakah ada kehidupan setelah Signora?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>