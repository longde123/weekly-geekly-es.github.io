<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌨️ ⛹🏼 🐈 Linux Kernel 5.0-在blk-mq下编写简单块设备 💿 ☝🏻 👲🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好消息！ 

 Linux内核5.0已经在这里并出现在实验发行版中，例如Arch，openSUSE Tumbleweed，Fedora。 



 而且，如果您查看Ubuntu Disko Dingo和Red Hat 8的RC发行版，则很清楚：很快内核5.0也将从风扇台式机转移到重要的服务器上。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux Kernel 5.0-在blk-mq下编写简单块设备</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/446148/"> 大家好消息！ <br><br>  Linux内核5.0已经在这里并出现在实验发行版中，例如Arch，openSUSE Tumbleweed，Fedora。 <br><br><img src="https://habrastorage.org/webt/me/zn/aq/meznaq4kak63su90hds63zvj1tq.png"><br><br> 而且，如果您查看Ubuntu Disko Dingo和Red Hat 8的RC发行版，则很清楚：很快内核5.0也将从风扇台式机转移到重要的服务器上。 <br> 有人会说-那么。 下一个版本，没什么特别的。 所以莱纳斯·托瓦尔兹本人说： <blockquote> 我想再次指出，我们不进行基于功能的发行，“ 5.0”的含义不外乎是4.x数字开始变得足够大，以至于我筋疲力尽和脚趾。 <br><br>  （ <i>我再说一遍-我们的发行版不与任何特定功能绑定，因此新版本5.0的编号仅意味着对4.x版本编号，我已经没有足够的手指和脚趾了</i> ） <br></blockquote><br> 但是，用于软盘的模块（不知道-这些是大小为前胸口袋衬衫的磁盘，容量为1.44 MB）-已更正... <br> 这就是为什么： <br><a name="habracut"></a><br> 这都是关于多队列块层（blk-mq）的。 互联网上有很多关于他的介绍性文章，所以让我们直接讲一下。 向blk-mq的过渡很久以前就开始了，并正在缓慢地向前发展。 多队列scsi（内核参数scsi_mod.use_blk_mq）出现了，新的调度程序mq-deadline，bfq等出现了…… <br><br><pre><code class="dos hljs">[root@fedora-<span class="hljs-number"><span class="hljs-number">29</span></span> sblkdev]# cat /sys/block/sda/queue/scheduler [mq-deadline] none</code> </pre> <br> 顺便问一下，你是什么人？ <br><br> 减少了使用旧版本的块设备驱动程序的数量。 在5.0中，blk_init_queue（）函数被不必要地删除了。 现在，2003年的旧光荣代码<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">lwn.net/Articles/58720</a>不仅不可用，而且失去了相关性。 此外，准备在今年发布的新发行版在默认配置中使用了多队列块层。 例如，在第18个Manjaro上，内核（尽管版本为4.19）默认为blk-mq。 <br><br> 因此，我们可以假设内核5.0中向blk-mq的过渡已经完成。 对我来说，这是一个重要事件，需要重写代码和进行其他测试。 它本身承诺会出现大小不一的错误以及几个崩溃的服务器（这是必要的，Fedya，这是必须的！（C））。 <br><br> 顺便说一句，如果有人认为对于rhel8来说，这个临界点没有到来，因为那里的内核是由4.18版“刷新”的，那么您就错了。 在rhel8上的最新RC中，已经移植了5.0以后的新产品，并且blk_init_queue（）函数也已被删除（可能是在将另一个签入从github.com/torvalds/linux拖到其源时）。 <br> 通常，长期以来，Linux发行商（如SUSE和Red Hat）的内核的“冻结”版本。 例如，系统报告版本为4.4，实际上该功能来自新的4.8 vanilla。 同时，在官方网站上标有一个题词，例如：“在新发行版中，我们为您保留了稳定的4.4内核。” <br><br> 但是我们分心了... <br><br> 所以在这里。 我们需要一个新的简单块设备驱动程序，以使其更清楚地工作。 <br> 因此，源代码在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/CodeImp/sblkdev上</a> 。 我建议讨论，提出拉动请求，开始发行-我将解决它。 质量检查尚未测试。 <br><br> 在本文的后面，我将尝试描述原因。 因此，有很多代码。 <br> 我很抱歉没有完全尊重Linux内核编码风格，是的-我不喜欢goto。 <br><br> 因此，让我们从入口点开始。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">init </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; _sblkdev_major = register_blkdev(_sblkdev_major, _sblkdev_name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_sblkdev_major &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: unable to get major number\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EBUSY; } ret = sblkdev_add_device(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) unregister_blkdev(_sblkdev_major, _sblkdev_name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">exit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ sblkdev_remove_device(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_sblkdev_major &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) unregister_blkdev(_sblkdev_major, _sblkdev_name); } module_init(sblkdev_init); module_exit(sblkdev_exit);</code> </pre><br> 显然，在加载模块时，将在卸载sblkdev_exit（）时启动sblkdev_init（）函数。 <br>  register_blkdev（）函数注册一个块设备。 他被分配了一个主要号码。  unregister_blkdev（）-释放此数字。 <br><br> 我们模块的关键结构是sblkdev_device_t。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// The internal representation of our device typedef struct sblkdev_device_s { sector_t capacity; // Device size in bytes u8* data; // The data aray. u8 - 8 bytes atomic_t open_counter; // How many openers struct blk_mq_tag_set tag_set; struct request_queue *queue; // For mutual exclusion struct gendisk *disk; // The gendisk structure } sblkdev_device_t;</span></span></code> </pre><br> 它包含有关内核模块必需的设备的所有信息，尤其是：块设备的容量，数据本身（这很简单），指向磁盘的指针和队列。 <br><br> 所有块设备初始化都在sblkdev_add_device（）函数中执行。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_add_device</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>* dev = kzalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>), GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: unable to allocate %ld bytes\n"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; } _sblkdev_device = dev; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>{ ret = sblkdev_allocate_buffer(dev); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ret) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//simply variant with helper function blk_mq_init_sq_queue. It`s available from kernel 4.20 (vanilla). {//configure tag_set struct request_queue *queue; dev-&gt;tag_set.cmd_size = sizeof(sblkdev_cmd_t); dev-&gt;tag_set.driver_data = dev; queue = blk_mq_init_sq_queue(&amp;dev-&gt;tag_set, &amp;_mq_ops, 128, BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE); if (IS_ERR(queue)) { ret = PTR_ERR(queue); printk(KERN_WARNING "sblkdev: unable to allocate and initialize tag set\n"); break; } dev-&gt;queue = queue; } #else // more flexible variant {//configure tag_set dev-&gt;tag_set.ops = &amp;_mq_ops; dev-&gt;tag_set.nr_hw_queues = 1; dev-&gt;tag_set.queue_depth = 128; dev-&gt;tag_set.numa_node = NUMA_NO_NODE; dev-&gt;tag_set.cmd_size = sizeof(sblkdev_cmd_t); dev-&gt;tag_set.flags = BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE; dev-&gt;tag_set.driver_data = dev; ret = blk_mq_alloc_tag_set(&amp;dev-&gt;tag_set); if (ret) { printk(KERN_WARNING "sblkdev: unable to allocate tag set\n"); break; } } {//configure queue struct request_queue *queue = blk_mq_init_queue(&amp;dev-&gt;tag_set); if (IS_ERR(queue)) { ret = PTR_ERR(queue); printk(KERN_WARNING "sblkdev: Failed to allocate queue\n"); break; } dev-&gt;queue = queue; } #endif dev-&gt;queue-&gt;queuedata = dev; {// configure disk struct gendisk *disk = alloc_disk(1); //only one partition if (disk == NULL) { printk(KERN_WARNING "sblkdev: Failed to allocate disk\n"); ret = -ENOMEM; break; } disk-&gt;flags |= GENHD_FL_NO_PART_SCAN; //only one partition //disk-&gt;flags |= GENHD_FL_EXT_DEVT; disk-&gt;flags |= GENHD_FL_REMOVABLE; disk-&gt;major = _sblkdev_major; disk-&gt;first_minor = 0; disk-&gt;fops = &amp;_fops; disk-&gt;private_data = dev; disk-&gt;queue = dev-&gt;queue; sprintf(disk-&gt;disk_name, "sblkdev%d", 0); set_capacity(disk, dev-&gt;capacity); dev-&gt;disk = disk; add_disk(disk); } printk(KERN_WARNING "sblkdev: simple block device was created\n"); }while(false); if (ret){ sblkdev_remove_device(); printk(KERN_WARNING "sblkdev: Failed add block device\n"); } return ret; }</span></span></span></span></code> </pre><br> 我们为结构分配内存，为存储数据分配缓冲区。 这里没什么特别的。 <br> 接下来，我们使用一个blk_mq_init_sq_queue（）函数或一次两个blk_mq_alloc_tag_set（）+ blk_mq_init_queue（）函数来初始化请求处理队列。 <br><br> 顺便说一句，如果查看blk_mq_init_sq_queue（）函数的源代码，您会发现这只是对4.20内核中出现的blk_mq_alloc_tag_set（）和blk_mq_init_queue（）函数的包装。 另外，它为我们隐藏了队列的许多参数，但看起来却简单得多。 您必须选择更好的选择，但是我更喜欢一个更明确的选择。 <br><br> 此代码中的关键是全局变量_mq_ops。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blk_mq_ops</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mq_ops</span></span></span><span class="hljs-class"> = {</span></span> .queue_rq = queue_rq, };</code> </pre><br> 这是提供请求处理的功能所在的位置，但稍后会对此进行更多介绍。 最主要的是，我们已将入口点指定给请求处理程序。 <br><br> 现在我们已经创建了队列，我们​​可以创建磁盘的实例。 <br><br> 没有重大变化。 分配磁盘，设置参数并将磁盘添加到系统中。 我想解释一下参数disk-&gt;标志。 它使您可以告诉系统该磁盘是可移动的，或者例如，它不包含分区，并且您无需在那里寻找它们。 <br><br> 有一个用于磁盘管理的_fops结构。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">block_device_operations</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fops</span></span></span><span class="hljs-class"> = {</span></span> .owner = THIS_MODULE, .open = _open, .release = _release, .ioctl = _ioctl, #ifdef CONFIG_COMPAT .compat_ioctl = _compat_ioctl, #endif };</code> </pre><br> 对于我们来说，用于简单块设备模块的入口_open和_release还不是很有趣。 除了原子递增和递减计数器外，没有任何其他内容。 我也没有执行compat_ioctl，因为对我来说，具有64位内核和32位用户空间环境的系统版本似乎并不理想。 <br><br> 但是_ioctl允许您处理该驱动器的系统请求。 出现磁盘时，系统将尝试了解更多信息。 您可以自行决定回答一些查询（例如，假装是一张新CD），但是一般规则是：如果您不想回答您不感兴趣的查询，只需返回错误代码-ENOTTY。 顺便说一下，如有必要，您可以在此处添加有关此特定驱动器的请求处理程序。 <br><br> 因此，我们添加了设备-我们需要注意资源的释放。  Rust不在<s>这里</s> 。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_remove_device</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>* dev = _sblkdev_device; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;disk) del_gendisk(dev-&gt;disk); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { blk_cleanup_queue(dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>); dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span> = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;tag_set.tags) blk_mq_free_tag_set(&amp;dev-&gt;tag_set); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;disk) { put_disk(dev-&gt;disk); dev-&gt;disk = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } sblkdev_free_buffer(dev); kfree(dev); _sblkdev_device = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: simple block device was removed\n"</span></span>); } }</code> </pre><br> 原则上，所有事情都是显而易见的：我们从系统中删除磁盘对象并释放队列，然后释放缓冲区（数据区域）。 <br><br> 现在，最重要的是queue_rq（）函数中的查询处理。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> blk_status_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queue_rq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct blk_mq_hw_ctx *hctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct blk_mq_queue_data* bd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">blk_status_t</span></span> status = BLK_STS_OK; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bd</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class">;</span></span> blk_mq_start_request(rq); <span class="hljs-comment"><span class="hljs-comment">//we cannot use any locks that make the thread sleep { unsigned int nr_bytes = 0; if (do_simple_request(rq, &amp;nr_bytes) != SUCCESS) status = BLK_STS_IOERR; printk(KERN_WARNING "sblkdev: request process %d bytes\n", nr_bytes); #if 0 //simply and can be called from proprietary module blk_mq_end_request(rq, status); #else //can set real processed bytes count if (blk_update_request(rq, status, nr_bytes)) //GPL-only symbol BUG(); __blk_mq_end_request(rq, status); #endif } return BLK_STS_OK;//always return ok }</span></span></code> </pre><br> 首先，考虑参数。 第一个是struct blk_mq_hw_ctx * hctx-硬件队列的状态。 在我们的情况下，我们没有硬件队列，因此没有使用。 <br><br> 第二个参数是const struct blk_mq_queue_data * bd-具有非常简洁的结构的参数，我不怕将其完整地介绍给您： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blk_mq_queue_data</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> last; };</code> </pre><br> 事实证明，从本质上讲，这与编年史家<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">elixir.bootlin.com</a>不再记得的时代所提出的要求相同。 因此，我们接受了请求并开始处理它，然后我们通过调用blk_mq_start_request（）通知内核。 完成请求处理后，我们将通过调用blk_mq_end_request（）函数来通知内核。 <br><br> 这里有个小提示：blk_mq_end_request（）函数本质上是对blk_update_request（）+ __blk_mq_end_request（）的调用的包装。 使用blk_mq_end_request（）函数时，您无法指定实际处理的字节数。 相信一切都已处理。 <br><br> 替代选项具有另一个功能：仅针对仅GPL模块导出blk_update_request函数。 也就是说，如果要创建专有的内核模块（让PM从这个棘手的路径中解救出来），则不能使用blk_update_request（）。 所以选择是您的。 <br><br> 将字节直接从请求移到缓冲区，反之亦然，我将其放入do_simple_request（）函数中。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_simple_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct request *rq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *nr_bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bio_vec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bvec</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">req_iterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iter</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span> *dev = rq-&gt;q-&gt;queuedata; <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> pos = blk_rq_pos(rq) &lt;&lt; SECTOR_SHIFT; <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> dev_size = (<span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span>)(dev-&gt;capacity &lt;&lt; SECTOR_SHIFT); printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: request start from sector %ld \n"</span></span>, blk_rq_pos(rq)); rq_for_each_segment(bvec, rq, iter) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b_len = bvec.bv_len; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* b_buf = page_address(bvec.bv_page) + bvec.bv_offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((pos + b_len) &gt; dev_size) b_len = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)(dev_size - pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rq_data_dir(rq))<span class="hljs-comment"><span class="hljs-comment">//WRITE memcpy(dev-&gt;data + pos, b_buf, b_len); else//READ memcpy(b_buf, dev-&gt;data + pos, b_len); pos += b_len; *nr_bytes += b_len; } return ret; }</span></span></code> </pre><br> 没有什么新内容：rq_for_each_segment遍历所有bio，它们都具有bio_vec结构，使我们能够访问带有请求数据的页面。 <br><br> 您的印象如何？ 一切看起来都很简单？ 通常，请求处理只是在请求的页面和内部缓冲区之间复制数据。 非常值得一个简单的块设备驱动程序，对吗？ <br><br> 但是有一个问题： <b>这不是真正的用途！</b> <br><br> 问题的实质是在处理列表中请求的循环中调用了queue_rq（）请求处理函数。 我不知道该列表使用了哪个锁，Spin或RCU（我不想说谎-谁知道，请纠正我），但是例如，当您尝试在请求处理功能中使用互斥锁时，调试内核会发誓并警告：打ze睡在这里是不可能的。 也就是说，由于进程无法进入待机状态，因此无法使用常规的同步工具或虚拟连续内存（使用vmalloc分配的虚拟内存，并且可以与其所暗示的所有内容进行交换）。 <br><br> 因此，如.. \ linux \ drivers \ block \ brd.c中实现的那样，只有Spin或RCU锁以及页面，列表或树形式的缓冲区（如在.. \ linux \ drivers \ block \ brd.c中实现），或在另一个线程中的延迟处理（如在.. \ linux中实现）。 \ linux \驱动程序\块\ loop.c. <br><br> 我认为无需描述如何组装模块，如何将其加载到系统中以及如何卸载。 这方面没有新产品，谢谢您：)因此，如果有人想尝试一下，我一定会弄清楚的。  <b>只是不要立即在您喜欢的笔记本电脑上做！</b> 举起virtualochka或至少在球上做个备份。 <br><br> 顺便说一句，适用于Linux的Veeam Backup 3.0.1.1046已经可用。 只是不要尝试在内核5.0或更高版本上运行VAL 3.0.1.1046。  veeamsnap无法组装。 而且一些多队列创新仍处于测试阶段。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446148/">https://habr.com/ru/post/zh-CN446148/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN446134/index.html">Flutter中的依赖注入</a></li>
<li><a href="../zh-CN446136/index.html">我的大理石机3D打印</a></li>
<li><a href="../zh-CN446138/index.html">以简单的合伙关系形式合法地组织您的创业公司有多容易</a></li>
<li><a href="../zh-CN446142/index.html">平坦的地球：实验和证据</a></li>
<li><a href="../zh-CN446144/index.html">面向292号移动开发人员的有趣材料的摘要（3月25日至3月31日）</a></li>
<li><a href="../zh-CN446150/index.html">无需Python，Anaconda和其他爬行动物的机器学习</a></li>
<li><a href="../zh-CN446152/index.html">Commando VM-Windows的Kali Linux替代品</a></li>
<li><a href="../zh-CN446162/index.html">如何成为“智能大三”。 个人经历</a></li>
<li><a href="../zh-CN446172/index.html">限制消息API VK-怎么办</a></li>
<li><a href="../zh-CN446174/index.html">PHP中的Yandex.Alice和Telegram机器人具有单一功能</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>