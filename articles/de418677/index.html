<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶Å ü•â üßñüèø Die ganze Wahrheit √ºber RTOS. Artikel 6. Andere RTOS-Dienste ü§ë ü§û üîΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In fr√ºheren Artikeln haben wir die Funktionalit√§t des Kernels im Hinblick auf die ausgef√ºhrten Aufgaben und die Interaktion zwischen ihnen er√∂rtert. I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber RTOS. Artikel 6. Andere RTOS-Dienste</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418677/"><img src="https://habrastorage.org/webt/zw/8-/qc/zw8-qcoua4iac13tid0bo2ivkrw.jpeg"><br><br>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikeln haben</a> wir die Funktionalit√§t des Kernels im Hinblick auf die ausgef√ºhrten Aufgaben und die Interaktion zwischen ihnen er√∂rtert.  In diesem Artikel sehen wir uns an, was der Kernel sonst noch tun kann, was sich gr√∂√ütenteils in einer Reihe anderer verf√ºgbarer API-Aufrufe manifestiert.  Wir werden auch die Frage beantworten, was den Kernel in ein Betriebssystem verwandelt. <br><a name="habracut"></a><br>  Fr√ºhere Artikel in der Reihe: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einf√ºhrung.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br><h2>  Aufgabenverwaltung </h2><br>  Zus√§tzlich zur Aufgabenplanung und Interaktion zwischen ihnen enth√§lt das RTOS Funktionen (API-Aufrufe) zum Verwalten von Aufgaben auf verschiedene Arten.  Betrachten wir einige M√∂glichkeiten. <br><br>  <b>Aufgaben erstellen und l√∂schen</b> <br><br>  Im "dynamischen" RTOS gibt es Funktionsaufrufe, mit denen Sie Aufgaben (und andere RTOS-Objekte) erstellen k√∂nnen, wenn sie ben√∂tigt werden.  Solche Aufrufe umfassen eine Vielzahl von Parametern, die die Aufgabe definieren, z. B. Einstiegspunkt, Stapelgr√∂√üe und Priorit√§t.  Mit dem entsprechenden API-Aufruf zum Entfernen von Aufgaben k√∂nnen Sie Ressourcen freigeben, nachdem die Aufgabe abgeschlossen wurde. <br><br>  Im "statischen" RTOS werden die definierenden Parameter der Aufgabe w√§hrend der Montage in einer Art Konfigurationsdatei konfiguriert. <br><br>  <b>Halten Sie an und setzen Sie eine Aufgabe fort</b> <br><br>  Wie wir gesehen haben, haben die meisten RTOS das Konzept eines ‚Äûsuspendierten‚Äú Aufgabenzustands.  Dies kann auf verschiedene Arten erreicht werden.  Eine davon ist ein expliziter Aufruf der Suspend Task API-Funktion.  Es kann durch sich selbst oder eine andere Aufgabe verursacht werden.  Mit dem entsprechenden Aufruf "Aufgabe fortsetzen" kann die Aufgabe erneut f√ºr die Planung in die Warteschlange gestellt werden. <br><br>  <b>Task-Ruhezustand</b> <br><br>  F√ºr ein Echtzeitsystem ist die Zeitsteuerung eine wichtige Anforderung und kann verschiedene Formen annehmen.  Eine einfache Ansicht ist die F√§higkeit der Aufgabe, "einzuschlafen", dh die Aufgabe wird f√ºr einen bestimmten Zeitraum angehalten.  Wenn die Zeit abgelaufen ist, wird die Aufgabe ‚Äûaufgeweckt‚Äú und erneut f√ºr die Planung in die Warteschlange gestellt.  Zu diesem Zweck steht normalerweise ein API-Aufruf zur Verf√ºgung.  Diese Funktionalit√§t h√§ngt nat√ºrlich von der Verf√ºgbarkeit des Timers ab. <br><br>  <b>Befreiung</b> <br><br>  Bei Verwendung des Round Robin-Schedulers ("Karussell") kann eine Aufgabe die Steuerung des Prozessors f√ºr die n√§chste Aufgabe in der Kette verweigern.  Zu diesem Zweck steht die API-Funktion ‚ÄûRelease Task‚Äú zur Verf√ºgung.  Die Aufgabe wird nicht angehalten, sie steht f√ºr die Planung zur Verf√ºgung, wenn sie an die Reihe kommt.  Bei Verwendung des Zeitscheiben-Schedulers kann eine Aufgabe einen Teil ihres Zeitintervalls freigeben, wenn sie nicht sofort wichtige Aufgaben zu erledigen hat.  Das Freigeben einer Aufgabe hat keine logische Bedeutung, wenn der Planer "Ausf√ºhren bis zum Abschluss" oder "Priorit√§t" ausgef√ºhrt wird. <br><br>  <b>Aufgabenerf√ºllung</b> <br><br>  In einem fr√ºheren Artikel haben wir festgestellt, dass das RTOS zus√§tzlich zu den Zust√§nden "Bereit" oder "Angehalten" andere Aufgabenzust√§nde unterst√ºtzen kann.  Die Aufgabe kann "Abgeschlossen" sein, was bedeutet, dass ihre Hauptfunktion gerade noch √ºbrig ist: Es ist kein spezieller API-Aufruf erforderlich.  Eine Aufgabe kann "Beendet" werden. Dies bedeutet, dass sie nicht f√ºr die Planung verf√ºgbar ist und zur√ºckgesetzt werden muss, um wieder zum Starten verf√ºgbar zu sein. Siehe "Zur√ºcksetzen einer Aufgabe" weiter unten.  Dies erfordert einen speziellen API-Aufruf.  Die Verf√ºgbarkeit dieser zus√§tzlichen Taskzust√§nde, die verwendete Terminologie und ihre genauen Definitionen unterscheiden sich je nach RTOS. <br><br>  <b>Task zur√ºckgesetzt</b> <br><br>  Viele RTOS bieten einen Aufruf der API-Funktion "Task zur√ºcksetzen" an, mit der Sie die Task in ihren urspr√ºnglichen Zustand zur√ºckversetzen k√∂nnen.  Sie befindet sich m√∂glicherweise in einem angehaltenen Zustand und muss die Funktion ‚ÄûAufgabe fortsetzen‚Äú ausf√ºhren, um sich f√ºr die Planung in die Warteschlange zu stellen. <br><br>  <b>Priorit√§tsaufgaben usw.</b> <br><br>  In einem ‚Äûdynamischen‚Äú RTOS stehen m√∂glicherweise API-Aufrufe zur Verf√ºgung, um mehrere Taskparameter zur Laufzeit zu konfigurieren.  Beispiele sind Priorit√§t und Zeitintervalldauer. <br><br><h2>  Systeminformationen </h2><br>  In RTOS wird es eine Reihe von API-Aufrufen geben, um dem System Informationen √ºber die Aufgabe bereitzustellen, darunter: <br>  <b>Informationen zu den Aufgaben</b> .  Wie viele Aufgaben befinden sich im System, ihre Konfiguration und der aktuelle Status. <br>  <b>Informationen zu anderen Kernelobjekten.</b>  Wie viele Objekte jedes Typs befinden sich im System, ihre Konfiguration und Informationen zum aktuellen Status.  Zum Beispiel: <br><br><ul><li>  Was ist die aktuelle Kapazit√§t der Warteschlange? Kann ich weitere Nachrichten hinzuf√ºgen? </li><li>  Wie viele Aufgaben werden an einem bestimmten Postfach angehalten? </li></ul>  <b>Informationen zur RTOS-Version</b> .  Ein API-Aufruf kann √§hnliche Daten bereitstellen. <br><br><h2>  Speicherzuordnung </h2><br>  In vielen Anwendungen ist es wichtig, dass das Programm bei Bedarf dynamisch Speicher erfassen und freigeben kann, wenn er nicht mehr ben√∂tigt wird.  Das gleiche passiert in der Firmware.  Herk√∂mmliche Ans√§tze sind jedoch anf√§llig f√ºr Probleme, die in Desktopanwendungen unwahrscheinlich oder unpraktisch sind, f√ºr ein eingebettetes System jedoch katastrophal sein k√∂nnen.  Trotzdem gibt es M√∂glichkeiten, solche Dienste auch in einem statischen RTOS zu implementieren. <br><br><h2>  Probleme mit den Funktionen malloc () und free () </h2><br>  In einem Desktop-C-Programm kann eine Funktion <b>malloc ()</b> aufrufen, um <b>anzuzeigen</b> , wie viel Speicher ben√∂tigt wird, und einen Zeiger auf den Speicherbereich zur√ºckerhalten.  Mit Speicher kann es durch Aufrufen von <b>free ()</b> freigegeben werden.  Der Speicher wird aus einem Bereich namens Heap zugewiesen.  Das Problem bei diesem Ansatz besteht darin, dass bei einer unkoordinierten Folge von Aufrufen dieser Funktionen der Heap-Bereich leicht fragmentiert werden kann und die Speicherzuweisung auch dann fehlschl√§gt, wenn gen√ºgend Speicher verf√ºgbar ist, weil  angrenzende Bereiche sind nicht gro√ü genug.  Einige Systeme (wie Java und Visual Basic) verwenden zur Defragmentierung ausgefeilte "Garbage Collection" -Schemata.  Das Problem ist, dass diese Schemata zu erheblichen unvorhersehbaren Verz√∂gerungen bei der Laufzeit f√ºhren k√∂nnen und dass indirekte Zeiger verwendet werden m√ºssen (was in C nicht funktioniert). <br><br>  Wenn <b>malloc ()</b> und <b>free ()</b> reentrant implementiert wurden (normalerweise nicht) und von den RTOS-Tasks verwendet wurden, tritt eine Fragmentierung sehr schnell auf und ein Systemausfall ist fast unvermeidlich.  In C ++ gibt es <b>neue</b> und <b>gel√∂schte</b> Operatoren, die im Allgemeinen dieselben Funktionen wie malloc () und free () ausf√ºhren.  Sie unterliegen denselben Einschr√§nkungen und Problemen. <br><br><h2>  Abschnitte des Ged√§chtnisses </h2><br>  Um ein Echtzeitsystem mit dynamisch zug√§nglichem Speicher bereitzustellen, kann ein Blockansatz f√ºr die Speicherverwaltung verwendet werden.  Solche Bl√∂cke werden √ºblicherweise "Partitionen" genannt;  Partitionen k√∂nnen aus dem "Partitionspool" zugeordnet werden. <br><br>  Der Partitionspool enth√§lt eine bestimmte Anzahl von Bl√∂cken, von denen jeder dieselbe Gr√∂√üe hat.  Die Anzahl und Gr√∂√üe der Bl√∂cke in einer Partition wird beim Erstellen des Partitionspools festgelegt.  Dies kann dynamisch sein, wenn das System dies zul√§sst, oder statisch w√§hrend der Montage.  In der Regel kann eine Anwendung mehrere Partitionspools enthalten, die Bl√∂cke unterschiedlicher Gr√∂√üe anbieten. <br><br>  Wenn eine Aufgabe Speicher ben√∂tigt, ruft sie eine API auf, die einen Block aus einem bestimmten Pool anfordert.  Wenn dieser Aufruf erfolgreich ist, erh√§lt die Task einen Zeiger auf den ausgew√§hlten Block.  Wenn der Anruf fehlschl√§gt, weil  Im angegebenen Pool sind keine Partitionen verf√ºgbar. Die Aufgabe erh√§lt m√∂glicherweise eine Fehlerantwort.  Alternativ kann die Aufgabe blockiert (angehalten) werden, bis eine andere Aufgabe den Block im Abschnitt freigibt. <br><br>  In der Regel √ºbergibt eine Task einfach einen Zeiger auf einen Speicherblock in einem Code, der den Block verwendet.  Dies f√ºhrt zu einem Problem, wenn der Block nicht mehr ben√∂tigt wird.  Wenn der Code nur einen Zeiger auf einen Block hat, wie kann er dem RTOS √ºber einen API-Aufruf mitteilen, aus welchem ‚Äã‚ÄãPartitionspool Speicher freigegeben werden soll?  Die Antwort ist, dass die meisten RTOS zus√§tzliche Daten in einem dedizierten Block unterst√ºtzen (normalerweise ein negativer Versatz vom Zeiger), die die erforderlichen Informationen liefern.  Um die API aufzurufen, um einen Block freizugeben, ist daher nur seine Adresse erforderlich. <br><br>  Der folgende Artikel enth√§lt weitere Informationen zu Speicherpartitionen. <br><br><h2>  Zeit </h2><br>  Die mit der Verwendung und Steuerung der Zeit verbundene Funktionalit√§t ist wahrscheinlich im Echtzeitbetriebssystem verf√ºgbar.  Die M√∂glichkeiten variieren je nach RTOS, wir werden jedoch √∂ffentlich zug√§ngliche ber√ºcksichtigen.  In jedem Fall ist der Echtzeit-Timer ein unverzichtbares Element f√ºr das Funktionieren eines dieser Dienste. <br><br>  <b>Systemzeit</b> <br><br>  Eine einfache Systemzeit oder "Clock Timer" ist fast immer verf√ºgbar.  Dies ist nur ein Z√§hler (normalerweise 32 Bit), der mithilfe der Echtzeit-Interrupt-Serviceroutine inkrementiert wird und √ºber API-Aufrufe gesetzt und gelesen werden kann. <br><br>  <b>Service Call Timeouts</b> <br><br>  In der Regel erm√∂glicht ein RTOS das Blockieren von API-Aufrufen, dh die aufrufende Task wird angehalten (blockiert), bis der angeforderte Dienst bereitgestellt wird.  Normalerweise ist diese Sperre vage, aber einige RTOS bieten eine Zeit√ºberschreitung an, w√§hrend der der Anruf zur√ºckgegeben wird, wenn die Zeit√ºberschreitung abl√§uft, wenn der Dienst weiterhin nicht verf√ºgbar ist.  API-Aufrufzeitlimits werden nicht von allen RTOS unterst√ºtzt. <br><br>  <b>Task-Ruhezustand</b> <br><br>  In der Regel k√∂nnen sich Aufgaben f√ºr einen festgelegten Zeitraum pausieren.  Dies wurde weiter oben im Abschnitt Aufgabenverwaltung erl√§utert. <br><br>  <b>Software-Timer</b> <br><br>  Damit Programmaufgaben Zeitz√§hlfunktionen ausf√ºhren k√∂nnen, bieten die meisten RTOS Timer-Objekte an.  Dies sind unabh√§ngige Timer, die vom Echtzeit-Timer-Interrupt-Handler aktualisiert werden und durch API-Aufrufe gesteuert werden k√∂nnen.  Solche Aufrufe konfigurieren, √ºberwachen und √ºberwachen den Betrieb des Timers.  In der Regel k√∂nnen sie f√ºr eine einzelne Bet√§tigung oder einen automatischen Neustart eingestellt werden.  In der Regel wird auch eine Ablaufroutine unterst√ºtzt, eine Funktion, die jedes Mal ausgef√ºhrt wird, wenn ein Timer einen Zyklus abschlie√üt.  Der n√§chste Artikel enth√§lt weitere Informationen zu Software-Timern und eine Beschreibung ihrer Implementierung. <br><br><h2>  Interrupts, Treiber und E / A. </h2><br>  Das Ausma√ü, in dem RTOSs mit Interrupts und E / A verbunden sind, ist sehr unterschiedlich.  Ebenso haben einige RTOSs eine sehr klare Struktur f√ºr Ger√§tetreiber, was zu Problemen bei der Auswahl eines bestimmten Produkts f√ºhren kann. <br><br>  <b>Unterbrechungen</b> <br><br>  Interrupts stellen aus zwei Gr√ºnden ein Problem f√ºr RTOS dar. <br><br><ul><li>  Ohne Vorsichtsma√ünahmen ‚Äûstiehlt‚Äú der Interrupt-Handler (ISR) die Prozessorzeit und st√∂rt dadurch das Echtzeit-RTOS-Verhalten. </li><li>  Wenn der ISR API-Aufrufe ausf√ºhrt, die sich auf die Aufgabenplanung auswirken, sollte dies √ºberwacht werden, und das RTOS sollte in der Lage sein, seinen Planungsalgorithmus auszuf√ºhren. </li></ul>  Ein Beispiel f√ºr einen solchen API-Aufruf ist das Verfahren zum Aufwecken einer Aufgabe mit einer h√∂heren Priorit√§t als derjenigen, die zum Zeitpunkt des Interrupts gestartet wurde. <br><br>  Einige RTOS steuern alle Interrupts vollst√§ndig.  Eine Reihe von API-Aufrufen steht zur Verf√ºgung, um ISR-Programme zu "registrieren".  Dieser Ansatz erm√∂glicht es dem Scheduler, genau zu bestimmen, wann Interrupts aktiviert sind, und erleichtert die Verwendung der meisten API-Aufrufe vom ISR. <br><br>  Zum Beispiel implementiert Nucleus RTOS das Konzept der Interrupt-Handler mit niedriger und hoher Priorit√§t, die ein zuverl√§ssiges Interrupt-Management ohne unn√∂tigen Overhead (dh eine Erh√∂hung der Interrupt-Verz√∂gerung) bieten. <br><br>  Andere RTOS k√∂nnen den automatischen Hands-Off-Modus f√ºr Interrupts verwenden, der Entwicklern mehr Optionen bietet, um sicherzustellen, dass Interrupt-Handler ordnungsgem√§√ü funktionieren.  In der Regel werden zus√§tzliche ISR-Pr√§fixe (Prolog) und Suffixe (Epilog) bereitgestellt, um darin ausgef√ºhrte API-Aufrufe zu sch√ºtzen. <br>  Nucleus SE verwendet eine einfache Interrupt-Routine, die in einem zuk√ºnftigen Artikel beschrieben wird. <br><br>  <b>Treiber</b> <br><br>  Die meisten RTOS bestimmen die Struktur des Ger√§tetreibers.  Details k√∂nnen je nach RTOS variieren, aber der Treiber besteht normalerweise aus zwei interagierenden Komponenten: eingebettetem Code (API-Aufrufe) und ISR.  In der Regel stehen andere API-Aufrufe zum Verwalten und Registrieren von Treibern zur Verf√ºgung. <br><br>  <b>Eingabe / Ausgabe</b> <br><br>  Gegenw√§rtig interessieren sich die meisten RTOS auf dem Markt nicht f√ºr √ºbergeordnete Ein- / Ausgabe, aber einige von ihnen definieren einen Eingabe- / Ausgabestream, der im Wesentlichen eine Verbindung zwischen den entsprechenden Ger√§tetreibern und Standardfunktionen der C-Sprache wie printf () herstellt. <br>  In der Vergangenheit unterst√ºtzte das RTOS h√§ufig die ‚ÄûKonsole‚Äú, die Benutzeroberfl√§che zum RTOS √ºber einen seriellen Kanal.  Dies wurde haupts√§chlich f√ºr die Diagnose und das Debuggen verwendet.  Durch die Verwendung moderner Debugger, die Debugging-Anwendungen mit RTOS unterst√ºtzen, sind solche Objekte nicht mehr erforderlich. <br><br><h2>  Diagnose </h2><br>  In der Regel erfordert RTOS maximale Leistung bei minimalem Speicherbedarf.  Daher hat die Integrit√§tspr√ºfung keine hohe Priorit√§t.  Mit Hilfe moderner Debugging-Technologien, die die Funktionen des RTOS ber√ºcksichtigen, k√∂nnen die meisten √úberpr√ºfungen au√üerhalb des RTOS selbst durchgef√ºhrt werden. <br><br><h2>  √úberpr√ºfen der API-Aufrufparameter </h2><br>  API-Aufrufe k√∂nnen viele komplexe Parameter haben.  Dies kann zu Fehlern f√ºhren.  Viele RTOS bieten eine √úberpr√ºfung der Laufzeitparameter mit der R√ºckgabe eines Fehlercodes im Falle eines falschen Parameters.  Da dies zus√§tzlichen Code erfordert und die √úberpr√ºfungen selbst die Leistung beeintr√§chtigen, ist es besser, die Parameter w√§hrend der Montage oder Konfiguration zu √ºberpr√ºfen. <br><br><h2>  Stapelpr√ºfung </h2><br>  F√ºr die meisten Arten von Schedulern (au√üer Run to Completion) verf√ºgt jede Aufgabe √ºber einen eigenen Stapel, dessen Gr√∂√üe individuell festgelegt wird.  In einigen RTOSs verf√ºgt der Kernel √ºber einen separaten Stapel, in anderen wird der Taskstapel w√§hrend eines API-Aufrufs ‚Äûausgeliehen‚Äú.  Offensichtlich ist die Stapelintegrit√§t f√ºr die Zuverl√§ssigkeit des Gesamtsystems wichtig.  Daher bieten RTOS h√§ufig Tools zur √úberpr√ºfung der Stapelintegrit√§t zur Laufzeit.  Es gibt mehrere M√∂glichkeiten: <br><br><ul><li>  Ein API-Aufruf, der den Stapelspeicherplatz f√ºr die aktuelle oder angegebene Aufgabe zur√ºckgibt. </li><li>  Die Begrenzungsparameter des Stapels.  Ihnen wird ein eindeutiger Wert (normalerweise ungerade und ungleich Null) zugewiesen, der regelm√§√üig auf Umschreiben √ºberpr√ºft wird. </li></ul><br><br><h2>  Anwendungsdiagnose </h2><br>  Trotz der Tatsache, dass diese Funktion im RTOS nicht direkt unterst√ºtzt wird, kann eine Anwendungsaufgabe zur √úberpr√ºfung der Integrit√§t des gesamten Systems zugewiesen werden.  Eine solche Aufgabe kann f√ºr das Zur√ºcksetzen des Watchdog-Timers verantwortlich sein.  Eine Aufgabe kann periodische Eingabedaten (z. B. Signalparameter) von jeder kritischen Aufgabe empfangen.  Das Zur√ºcksetzen des Watchdog-Timers (wodurch ein Neustart des Systems verhindert wird) wird erst durchgef√ºhrt, nachdem Daten von allen Aufgaben eingegangen sind. <br><br><h2>  Nicht-Kernel-Dienste </h2><br>  Das RTOS ist mehr als nur der Kern, auf den wir uns bisher konzentriert haben.  Dieses Desktop-Betriebssystem unterscheidet sich erheblich vom eingebetteten RTOS.  In der Regel werden in einem Desktop-Betriebssystem alle zus√§tzlichen Komponenten geb√ºndelt oder k√∂nnen installiert werden (alle Desktop-PCs verf√ºgen √ºber eine grafische Benutzeroberfl√§che, und nur wenige von ihnen haben keinen Netzwerkzugriff).  Der Desktop-PC hat keine wirklichen Ressourcenbeschr√§nkungen: Es gibt immer freien Speicher, Festplattenspeicher und nicht verwendete CPU-Ressourcen.  In einer Welt eingebetteter Systeme mit begrenzten Ressourcen sind m√∂glicherweise zus√§tzliche Komponenten wie Grafikkarten, Netzwerkkomponenten und Dateisysteme erforderlich, die jedoch trennbar und skalierbar sein m√ºssen, um den Speicherbedarf zu minimieren. <br><br>  <b>Netzwerkfunktionen</b> <br><br>  Die meisten eingebetteten Systeme sind irgendwie mit Netzwerken verbunden.  Es wird daher erwartet, dass ein erhebliches Interesse an Netzwerkl√∂sungen f√ºr eingebettete Systeme besteht, aufgrund derer eine gro√üe Anzahl von Produkten auf dem Markt ist. <br><br>  <b>TCP / IP</b> ist ein weit verbreitetes Standardprotokoll, das f√ºr viele Anwendungen die offensichtliche Wahl ist.  In der Regel wird TCP / IP f√ºr das Ethernet-Protokoll (IEEE802.3) verwendet, das eine durchschnittliche Geschwindigkeit von 10 Mbit / s bietet.  Heutzutage sind 100 Mbit / s weit verbreitet und beim Ansatz 1 Gbit / s.  Dar√ºber hinaus kann TCP / IP f√ºr andere Protokolle verwendet werden.  Beispielsweise ist PPP (Point-to-Point-Protokoll) eine TCP / IP-Implementierung f√ºr die serielle Daten√ºbertragung, die f√ºr Breitband-Internetverbindungen angepasst wurde. <br><br>  Bis vor kurzem wurde Version v4 des IP-Protokolls (IPv4) verwendet.  Es wird jedoch veraltet, wenn freie Adressen ausgehen.  Die L√∂sung ist IPv6, wodurch die Anzahl der m√∂glichen Adressen erheblich erh√∂ht und effizientere Tools f√ºr Wartung und Sicherheit bereitgestellt werden.  IPv6 ist weit verbreitet und wird in Ger√§ten vieler L√§nder sowie in milit√§rischen Systemen auf der ganzen Welt verwendet. <br>  Eine Alternative ist das User Datagram Protocol (UDP).  Dieses Protokoll wird f√ºr maximale Leistung verwendet.  UDP bietet nicht die gleiche Zuverl√§ssigkeit und Konsistenz wie TCP, ist jedoch leicht und hocheffizient. <br><br>  <b>USB</b> ist der Universal Serial Bus, der h√§ufig in Ger√§ten zum Anschlie√üen an Desktop-Computer verwendet wird.  Es bietet eine sehr einfach zu bedienende Plug-and-Play-Oberfl√§che, die ziemlich ausgefeilte Software verbirgt.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein eingebettetes Ger√§t, das an einen PC angeschlossen werden muss, muss als USB-Funktion implementiert werden, f√ºr die ein bestimmter Satz von Softwarekomponenten erforderlich ist. Wenn das Ger√§t andere √ºber USB angeschlossene Ger√§te (wie einen normalen PC) verwalten muss, ben√∂tigt es eine Reihe von Host-Software. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IEEE1394</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein weiterer Standard f√ºr serielle Schnittstellen, mit dem gro√üe Datenmengen schnell zwischen Ger√§ten √ºbertragen werden k√∂nnen (z. B. zum √úbertragen von Videodaten), auch bekannt als FireWire und i.Link.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drahtlose Protokolle - Die Bequemlichkeit und Verbreitung verschiedener drahtloser Technologien bei Verbrauchern hat zu einer hohen Nachfrage nach drahtlosen Funktionen in eingebetteten Ger√§ten gef√ºhrt. Wi-Fi (IEEE802.11-Standardsatz) bietet einen vollst√§ndigen Satz von Netzwerkfunktionen, mit denen Sie Peer- und Infrastruktur-Topologien in ausreichender Entfernung implementieren k√∂nnen. Das Interesse an Datensicherheit in solchen Netzwerken w√§chst, was bedeutet, dass dies Auswirkungen auf die Software haben sollte. Andere Funktechnologien, insbesondere Bluetooth und ZigBee, bieten Punkt-zu-Punkt-Funkkommunikation mit kurzer Reichweite. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protokoll√ºberpr√ºfung</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da Networking-M√∂glichkeiten sehr gefragt sind, bieten viele Anbieter ihre L√∂sungen an. Kunden stehen vor der Herausforderung, die Qualit√§t der verf√ºgbaren Produkte zu √ºberpr√ºfen. Im Gegensatz zum RTOS-Kernel ist eine vollst√§ndige √úberpr√ºfung der Funktionalit√§t und Leistung des Protokollstapels keine leichte Aufgabe. Gl√ºcklicherweise stehen Toolkits zur √úberpr√ºfung von Protokollen zur Verf√ºgung (wenn auch zu einem erheblichen Preis), und ein potenzieller K√§ufer kann beim Lieferanten herausfinden, welches Set er zur √úberpr√ºfung verwendet hat.</font></font><br><br>  <b>Grafik</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine grafische Oberfl√§che wird bei eingebetteten Ger√§ten immer h√§ufiger. Es kann sich um ein sehr einfaches, kleines monochromatisches LCD handeln (wie bei alten Telefonen, MP3-Playern, Alarmen usw.). Andererseits kann ein digitaler Fernsehempf√§nger einen eigenen hochaufl√∂senden HDTV-Bildschirm haben. Ein solcher Bildschirm erfordert Softwareunterst√ºtzung, die vollst√§ndig in den RTOS-Kernel integriert ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da der Bildschirm normalerweise √ºber eine Art Eingabeger√§t verf√ºgt, ist die Unterst√ºtzung f√ºr solche Ger√§te h√§ufig im Grafikpaket enthalten. Ein solches Paket kann Zeigeger√§te (z. B. eine Maus), Touchscreens, Tastaturen und vollst√§ndige Tastaturen unterst√ºtzen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grafiken k√∂nnen auf verschiedene Arten verwendet werden. Es kann einfach eine Informationsausgabe bereitstellen (z. B. wie eine elektronische Anzeigetafel). Oder die Anzeige kann zusammen mit Men√ºs, Fenstern, Symbolen und √§hnlichen Elementen Teil einer grafischen Benutzeroberfl√§che sein. In jedem Fall ist ein ziemlich spezifischer Satz von Software erforderlich, und das mit dem RTOS gelieferte Grafikpaket sollte die erforderliche Flexibilit√§t bieten, ohne die Menge des verwendeten Speichers wesentlich zu erh√∂hen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dateisysteme</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn eine eingebettete Anwendung erhebliche Datenmengen speichern und verarbeiten muss, ist es offensichtlich sinnvoll, diese Daten in einer Art Dateisystem zu organisieren. </font><font style="vertical-align: inherit;">Daten k√∂nnen sich im RAM, im eingebauten Flash-Speicher, auf einem USB-Flash-Laufwerk, auf einer normalen Festplatte oder auf einer optischen Festplatte (CD-ROM oder DVD-ROM) befinden. </font><font style="vertical-align: inherit;">Auch bei dieser Gelegenheit sollte die Softwareunterst√ºtzung vollst√§ndig in das RTOS integriert sein. </font><font style="vertical-align: inherit;">Das Dateisystem muss sorgf√§ltig entworfen werden, um die Wiedereintrittsanforderungen eines Multitasking-Systems zu erf√ºllen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compliance ist besonders wichtig f√ºr Dateisysteme. </font><font style="vertical-align: inherit;">Die Verwendung des MS-DOS-kompatiblen Festplattenformats erm√∂glicht Entwicklern beispielsweise die Verwendung der etablierten Architektur und bietet einen umfassenden Datenaustausch mit Desktop-Systemen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418677/">https://habr.com/ru/post/de418677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418665/index.html">Anpassung des MR-Projekts f√ºr HoloLens</a></li>
<li><a href="../de418667/index.html">Benchmarking von HDFS 3 mit HDFS 2</a></li>
<li><a href="../de418669/index.html">Sicherheitswoche 28: NetSpectre, Angriff auf Kan√§le von Drittanbietern √ºber das Netzwerk</a></li>
<li><a href="../de418673/index.html">Warum w√§chst der ERP-Markt: Statistiken und Trends</a></li>
<li><a href="../de418675/index.html">Wie ich zur Droidcon Berlin gegangen bin</a></li>
<li><a href="../de418679/index.html">Wir schreiben eine Komponente mit "Material" -Schaltfl√§chen f√ºr Svelte</a></li>
<li><a href="../de418681/index.html">Tag der Freundschaft - 50% Rabatt auf alle JetBrains-IDEs f√ºr unsere Freunde</a></li>
<li><a href="../de418683/index.html">Erstellen eines Emulator-Arcade-Automaten. Teil 2</a></li>
<li><a href="../de418685/index.html">Prozedurale Level-Generierung</a></li>
<li><a href="../de418687/index.html">3,5 "Umdrehung: Details eines kleinen Auslegers von Disketten mit D√§mpfen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>