<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐙 👩‍👧‍👧 😝 Testez ceci: comment nous déterminons les tests à exécuter lors des vérifications de demandes de tirage 👩🏿‍🎤 🚸 🏏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je m'appelle Egor Danilenko. Je développe une plate-forme numérique pour les services bancaires par Internet aux entreprises de Sberban...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testez ceci: comment nous déterminons les tests à exécuter lors des vérifications de demandes de tirage</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/430270/">  Bonjour, Habr!  Je m'appelle Egor Danilenko.  Je développe une plate-forme numérique pour les services bancaires par Internet aux entreprises de Sberbank Business Online, et aujourd'hui, je veux vous parler de la procédure de développement de CI que nous avons adoptée. <br><a name="habracut"></a><br>  Comment les modifications apportées aux développeurs sont-elles introduites dans la branche de publication?  Le développeur apporte des modifications localement et pousse dans notre système de contrôle de version.  Nous utilisons Bitbucket avec le plugin d'un auteur (nous avons écrit à propos de ce plugin plus tôt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ).  Sur ces changements, l'assemblage est lancé et les tests sont poursuivis (unit, intégration, fonctionnel).  Si l'assemblage n'a pas échoué et que tous les tests ont réussi, ainsi qu'après un examen réussi, la demande d'extraction est versée dans la branche principale. <br><br>  Mais au fil du temps, le nombre d'équipes a augmenté.  Le nombre de tests a augmenté proportionnellement.  Nous avons compris qu'un tel nombre d'équipes accélérerait l'apparition du problème de la «lente traction-demande-vérification» et qu'il deviendrait impossible de développer un produit.  Actuellement, nous avons environ 40 équipes.  Avec de nouvelles fonctionnalités, ils apportent de nouveaux tests, qui doivent également être exécutés sur les demandes d'extraction. <br><br>  Nous pensions que ce serait cool si nous savions quels tests exécuter pour changer un morceau de code particulier. <br><br>  Et c'est ainsi que nous avons résolu ce problème. <br><br><h4>  Énoncé du problème </h4><br>  Il existe un projet avec des tests, et nous voulons déterminer quels tests doivent être exécutés lorsqu'un certain fichier est «touché». <br><br>  Nous connaissons tous la bibliothèque de couverture de code EclEmma JaCoCo.  Nous l'avons pris comme base. <br><br><h4>  Un peu sur JaCoCo </h4><br>  JaCoCo est une bibliothèque pour mesurer la couverture de code avec des tests.  Le travail est basé sur l'analyse d'octets de code.  L'agent collecte les informations d'exécution et les télécharge à la demande ou à l'arrêt de la machine virtuelle Java. <br><br>  Il existe trois modes de collecte de données: <br><br><ol><li>  Système de fichiers: après l'arrêt de la JVM, les données seront écrites dans un fichier. </li><li>  TCP Socket Server: vous pouvez connecter des outils externes à la JVM et recevoir des données via le socket. </li><li>  TCP Socket Client: Lorsqu'il est lancé, l'agent JaCoCo se connecte à un point de terminaison TCP spécifique. </li></ol><br>  Nous avons choisi la deuxième option. <br><br><h4>  Solution </h4><br>  Il est nécessaire de réaliser la capacité d'exécuter des applications et les tests eux-mêmes avec l'agent JaCoCo. <br><br>  Tout d'abord, nous ajoutons à gradle la possibilité d'exécuter des tests avec l'agent JaCoCo. <br><br>  L'agent Java peut être démarré: <br><br><pre><code class="java hljs">-javaagent:[yourpath/]jacocoagent.jar=[option1]=[value1],[option2]=[value2]</code> </pre> <br>  Ajoutez une dépendance à notre projet: <br><br><pre> <code class="java hljs">dependencies { compile <span class="hljs-string"><span class="hljs-string">'org.jacoco:org.jacoco.agent:0.8.0'</span></span> }</code> </pre><br>  Nous devons seulement commencer par l'agent pour collecter des statistiques, nous ajoutons donc l'indicateur withJacoco avec la valeur par défaut false à gradle.properties.  Nous spécifions également le répertoire où seront collectées les statistiques, l'adresse et le port. <br><br>  Ajoutez l'argument jvm avec l'agent à la tâche de lancement du test: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withJacoco.toBoolean()) { … jvmArgs <span class="hljs-string"><span class="hljs-string">"-javaagent:${tempPath}=${jacocoArgs.join(',')}"</span></span>.toString() }</code> </pre> <br>  Maintenant, après chaque réussite du test, nous devons collecter des statistiques avec JaCoCo.  Pour ce faire, écrivez l'écouteur TestNG. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JacocoCoverageTestNGListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ITestListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> IntegrationTestsCoverageReporter reporter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntegrationTestsCoverageReporter(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String TEST_NAME_PATTERN = <span class="hljs-string"><span class="hljs-string">"%s.%s"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTestStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ITestResult result)</span></span></span><span class="hljs-function"> </span></span>{ reporter.resetCoverageDumpers(String.format(TEST_NAME_PATTERN, result.getInstanceName(), result.getMethod().getMethodName())); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTestSuccess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ITestResult result)</span></span></span><span class="hljs-function"> </span></span>{ reporter.report(String.format(TEST_NAME_PATTERN, result.getInstanceName(), result.getMethod().getMethodName())); } }</code> </pre><br>  Ajoutez un écouteur à testng.xml et commentez-le, car nous n'en avons pas besoin lors d'un test normal. <br><br>  Nous avons maintenant la possibilité d'exécuter des tests avec l'agent JaCoCo, avec chaque statistique de test réussie sera collectée. <br><br>  Un peu plus sur la façon dont reporter est implémenté pour collecter des statistiques. <br>  Pendant l'initialisation du reporter, une connexion est établie avec les agents, un répertoire est créé où les statistiques seront stockées et les statistiques seront collectées. <br><br>  Ajoutez la méthode de rapport: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String test)</span></span></span><span class="hljs-function"> </span></span>{ reportClassFiles(test); reportResources(test); }</code> </pre> <br>  La méthode reportClassFile crée le dossier jvm dans le répertoire des statistiques, dans lequel les statistiques collectées par les fichiers de classe sont stockées. <br><br>  La méthode reportResources crée le dossier des ressources, qui stocke les statistiques collectées sur les ressources (pour tous les fichiers non-classe). <br><br>  Le rapport contient toute la logique de connexion à un agent, de lecture de données à partir d'un socket et d'écriture dans un fichier.  Implémenté par des outils fournis par JaCoCo, tels que org.jacoco.core.runtime.RemoteControlReader / RemoteControlWriter. <br><br>  Les fonctions reportClassFiles et reportResources utilisent la fonction générique dumpToFile. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dumpToFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Writer fileWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedWriter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileWriter(file))) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (RemoteControlReader remoteControlReader : remoteControlReaders) { remoteControleReader.setExecutionDataVisitor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IExecutionDataVisitor() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitClassExecution</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExecutionData data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.hasHits()) { String name = data.getName(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fileWriter.write(name); fileWriter.write(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(e); } } } }); } } }</code> </pre> <br>  Le résultat de la fonction sera un fichier avec un ensemble de classes / ressources affectées par ce test. <br><br>  Et donc, après avoir exécuté tous les tests, nous avons un répertoire avec des statistiques sur les fichiers de classe et les ressources. <br><br>  Il reste à écrire un pipeline pour la collecte de statistiques quotidiennes et à ajouter au lancement du pipeline des vérifications des demandes d'extraction. <br><br>  Nous ne sommes pas intéressés par les étapes de l'assemblage du projet, mais nous examinerons plus en détail l'étape de publication des statistiques. <br><br><pre> <code class="java hljs">stage(<span class="hljs-string"><span class="hljs-string">'Agregate and parse result'</span></span>) { def inverterInJenkins = downloadMavenDependency( url: NEXUS_RELEASE_REPOSITORY, group: <span class="hljs-string"><span class="hljs-string">''</span></span>, name: <span class="hljs-string"><span class="hljs-string">'coverage-inverter'</span></span>, version: <span class="hljs-string"><span class="hljs-string">'0'</span></span>, type: <span class="hljs-string"><span class="hljs-string">'jar'</span></span>, mavenHome: wsp ) dir(<span class="hljs-string"><span class="hljs-string">'coverage-mapping'</span></span>) { gitFullCheckoutRef <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'coverage-mapping'</span></span>, <span class="hljs-string"><span class="hljs-string">"refs/heads/${params.targetBranch}-integration-tests"</span></span> sh <span class="hljs-string"><span class="hljs-string">'rm -rf *'</span></span> } sh <span class="hljs-string"><span class="hljs-string">"ls -lRa ..//out/coverage/"</span></span> def inverter = wsp + inverterInJenkins.substring(wsp.length()) sh <span class="hljs-string"><span class="hljs-string">"java -jar ${inverter} "</span></span> + <span class="hljs-string"><span class="hljs-string">"-d ..//out/coverage/jvm "</span></span> + <span class="hljs-string"><span class="hljs-string">"-o coverage-mapping//jvm "</span></span> + <span class="hljs-string"><span class="hljs-string">"-i coverage-config/jvm-include "</span></span> + <span class="hljs-string"><span class="hljs-string">"-e coverage-config/jvm-exclude"</span></span> sh <span class="hljs-string"><span class="hljs-string">"java -jar ${inverter} "</span></span> + <span class="hljs-string"><span class="hljs-string">"-d ..//out/coverage/resources "</span></span> + <span class="hljs-string"><span class="hljs-string">"-o coverage-mapping//resources "</span></span> + <span class="hljs-string"><span class="hljs-string">"-i coverage-config/resources-include "</span></span> + <span class="hljs-string"><span class="hljs-string">"-e coverage-config/resources-exclude"</span></span> gitPush <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'coverage-mapping'</span></span>, <span class="hljs-string"><span class="hljs-string">"${params.targetBranch}-integration-tests"</span></span> }</code> </pre><br>  Dans la cartographie de couverture, nous devons stocker le nom du fichier et à l'intérieur une liste de tests qui doivent être exécutés.  Étant donné que le résultat de la collecte de statistiques est le nom du test qui stocke l'ensemble des classes et des ressources, nous devons inverser le tout et exclure les données supplémentaires (classes des bibliothèques tierces). <br><br>  Nous inversons nos statistiques et poussons vers notre référentiel. <br><br>  Des statistiques sont collectées tous les soirs.  Il est stocké dans un référentiel distinct pour chaque branche de version. <br><br>  Bingo! <br><br>  Maintenant, lors de l'exécution des tests, il nous suffit de trouver le fichier modifié et de déterminer les tests à exécuter. <br><br>  Les problèmes rencontrés: <br><br><ul><li>  Étant donné que JaCoCo ne fonctionne qu'avec le bytecode, il est impossible de collecter des statistiques sur des fichiers tels que .xml, .gradle, .sql à partir de la boîte.  Par conséquent, nous avons dû «accélérer» nos décisions. </li><li>  Contrôle constant de la pertinence des statistiques et de la fréquence de l'assemblage, si l'assemblage nocturne échouait pour une raison quelconque, les statistiques «d'hier» seront utilisées pour vérification dans les demandes de tirage. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430270/">https://habr.com/ru/post/fr430270/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430258/index.html">Non aux décharges de MSW - mettez une ferme de vermicinifères sous la fenêtre</a></li>
<li><a href="../fr430260/index.html">Rapport du Club de Rome 2018, chapitre 1.10, «Agenda 2030: le diable se cache dans la mise en œuvre»</a></li>
<li><a href="../fr430264/index.html">Comment Yandex a changé la recherche au cours de la dernière année. Mise à jour Andromeda</a></li>
<li><a href="../fr430266/index.html">Paysage des services de traduction automatique dans le cloud. Conférence à Yandex</a></li>
<li><a href="../fr430268/index.html">Sans serveur va tuer DevOps?</a></li>
<li><a href="../fr430272/index.html">"Les monstres en jeux ou 15 cm suffisent pour attaquer"</a></li>
<li><a href="../fr430274/index.html">7 jeux PC plus cool pour apprendre l'anglais</a></li>
<li><a href="../fr430276/index.html">L'erreur dévastatrice des débutants dans Gamedev</a></li>
<li><a href="../fr430278/index.html">Conférence de Budapest (29-31 octobre) Data Crunch</a></li>
<li><a href="../fr430280/index.html">VotingClassifier dans sсikit-learn: construction et optimisation d'un ensemble de modèles de classification</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>