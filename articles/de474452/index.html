<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ•Ô∏è ‚ôêÔ∏è üï∫üèø Haxe Herbst Statusbericht üòí ‚å®Ô∏è üßëüèº‚Äçü§ù‚Äçüßëüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Am 26. Oktober fand in Linz am Rhein (Deutschland) die Minikonferenz HaxeUp Sessions 2019 statt , die Haxe und verwandten Technologien gewidmet war. D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Haxe Herbst Statusbericht</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474452/"><p>  Am 26. Oktober fand in Linz am Rhein (Deutschland) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Minikonferenz HaxeUp Sessions 2019 statt</a> , die Haxe und verwandten Technologien gewidmet war.  Das wichtigste Ereignis war nat√ºrlich die endg√ºltige Ver√∂ffentlichung von Haxe 4.0.0 (zum Zeitpunkt der Ver√∂ffentlichung, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dh</a> nach etwa einer Woche, wurde das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Update 4.0.1 ver√∂ffentlicht</a> ).  In diesem Artikel m√∂chte ich Ihnen eine √úbersetzung des ersten Berichts der Konferenz vorstellen - einen Bericht √ºber die Arbeit des Haxe-Teams f√ºr 2019. </p><br><p><img src="https://habrastorage.org/webt/hk/ik/sp/hkiksp6o31il9tcdxjjlm6xnmve.png" alt="Bild"></p><a name="habracut"></a><br><p>  Ein wenig √ºber den Autor des Berichts: </p><br><p>  Simon arbeitet seit 2010 mit Haxe zusammen, als er noch Student war und eine Arbeit √ºber Fl√ºssigkeitssimulationen in Flash schrieb.  Die Implementierung einer solchen Simulation erforderte einen st√§ndigen Zugriff auf Daten, die den Zustand von Partikeln beschreiben (in jedem Schritt wurden mehr als 100 Abfragen zu Datenfeldern √ºber den Zustand jeder Zelle in der Simulation durchgef√ºhrt), w√§hrend die Arbeit mit Arrays in ActionScript 3 nicht so schnell war.  Daher war die anf√§ngliche Implementierung einfach nicht funktionsf√§hig und musste gefunden werden, um eine L√∂sung f√ºr dieses Problem zu finden.  Bei seiner Suche stie√ü Simon auf einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel von Nicolas Kannass</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erfinder</a> von Haxe) √ºber die damals nicht dokumentierten Alchemie-Opcodes, die mit ActionScript nicht verf√ºgbar waren, aber Haxe erlaubte, sie zu verwenden.  Simon schrieb die Simulation auf Haxe mit Opcodes um und bekam eine funktionierende Simulation!  Dank langsamer Arrays in ActionScript lernte Simon Haxe kennen. </p><br><p>  Seit 2011 ist Simon Teil der Entwicklung von Haxe. Er begann, OCaml (auf dem der Compiler geschrieben ist) zu studieren und verschiedene Korrekturen am Compiler vorzunehmen. </p><br><p>  Und seit 2012 wurde er der Haupt-Compiler-Entwickler.  Im selben Jahr wurde die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haxe Foundation</a> gegr√ºndet (eine Organisation, deren Hauptziel die Entwicklung und Pflege des Haxe-√ñkosystems ist und die die Gemeinde bei der Organisation von Konferenzen und Beratungsdiensten unterst√ºtzt), und Simon wurde einer ihrer Mitbegr√ºnder. </p><br><p><img src="https://habrastorage.org/webt/ic/n2/-z/icn2-zvorldkegboovusqzxfdbo.png" alt="Bild"></p><br><p>  In den Jahren 2014-2015 lud Simon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Josephine Pertosa</a> zur Haxe Foundation ein, die im Laufe der Zeit f√ºr die Organisation von Konferenzen und Community Relations verantwortlich war. </p><br><p>  2016 hielt Simon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seine</a> erste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pr√§sentation zu Haxe</a> und organisierte 2018 die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten HaxeUp-Sitzungen</a> . </p><br><p><img src="https://habrastorage.org/webt/ii/3p/vq/ii3pvqd1f88pj3toyvcaxjcmjr8.png" alt="Bild"></p><br><p>  Also, was ist in der Haxe-Welt in den letzten 2019 passiert? </p><br><p>  Im Februar und M√§rz kamen 2 Release-Kandidaten heraus (4.0.0-rc1 und 4.0.0-rc2) <br>  Im April traten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aurel Bili</a> (als Praktikant) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexander Kuzmenko</a> (als Compiler-Entwickler) dem Team der Haxe Foundation bei. </p><br><p>  Im Mai fand der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haxe US Summit 2019 statt</a> . <br>  Im Juni wurde Haxe 4.0.0-rc3 ver√∂ffentlicht.  Und im September - Haxe 4.0.0-rc4 und Haxe 4.0.0-rc5. </p><br><p><img src="https://habrastorage.org/webt/bg/cz/di/bgczdidj4imp0y_rteusgqy-dwq.png" alt="Bild"></p><br><p>  Haxe ist nicht nur ein Compiler, sondern auch eine ganze Reihe verschiedener Tools, und w√§hrend des ganzen Jahres wurde auch st√§ndig daran gearbeitet: <br>  Dank der Bem√ºhungen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andy Lee verwendet</a> Haxe jetzt Azure Pipelines anstelle von Travis CI und AppVeyor.  Dies bedeutet, dass Montage und automatisierte Tests jetzt viel schneller sind. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hugh Sanderson arbeitet</a> weiterhin an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hxcpp</a> (einer Bibliothek zur Unterst√ºtzung von C ++ in Haxe). <br>  Pl√∂tzlich schlossen sich Benutzer von Github <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">terurou</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">takashiski</a> der Arbeit an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">externen Ger√§ten f√ºr</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js an.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rudy Ges</a> arbeitete an Korrekturen und Verbesserungen, um das C # -Ziel zu unterst√ºtzen. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">George Corney unterst√ºtzt</a> weiterhin den externen HTML-Generator. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jens Fisher</a> arbeitet an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vshaxe</a> (eine Erweiterung f√ºr VS Code f√ºr die Arbeit mit Haxe) und an vielen anderen Haxe-Projekten. </p><br><p><img src="https://habrastorage.org/webt/4c/n-/vr/4cn-vrhfusi6b6adnvyldgpyd7y.png" alt="Bild"></p><br><p>  Und das Hauptereignis des Jahres war nat√ºrlich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lang erwartete Ver√∂ffentlichung von Haxe 4.0.0</a> (sowie Neko 2.3.0), die versehentlich mit dem HaxeUp 2019 Linz zusammenfiel :) </p><br><p><img src="https://habrastorage.org/webt/z6/n5/w0/z6n5w0pvjr4oecito4cd4w0ge_i.png" alt="Bild"></p><br><p>  Simon widmete den Gro√üteil des Berichts neuen Funktionen in Haxe 4.0.0 (Sie k√∂nnen sie auch aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht von Alexander Kuzmenko</a> vom letzten Haxe US-Gipfel 2019 erfahren). </p><br><p><img src="https://habrastorage.org/webt/mn/-z/u2/mn-zu2pk84sti-8ztm8hvhmvizm.png" alt="Bild"></p><br><p>  Der neue Eval-Makro-Interpreter ist um ein Vielfaches schneller als der alte.  Simon hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in seiner Rede auf dem Haxe Summit EU 2017</a> ausf√ºhrlich √ºber ihn gesprochen.  Aber seitdem hat es die Debugging-Funktionen des Codes verbessert, viele Fehler behoben und die Implementierung von Strings neu gestaltet. </p><br><p><img src="https://habrastorage.org/webt/d_/j3/uq/d_j3uqwvxpukog8q9pgp9prafrw.png" alt="Bild"></p><br><p> Mit Haxe 4 wird die Unicode-Unterst√ºtzung f√ºr alle Plattformen (au√üer Neko) eingef√ºhrt.  Simon hat dies in seiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letztj√§hrigen Rede</a> ausf√ºhrlich beschrieben.  F√ºr den Endbenutzer des Compilers bedeutet dies, dass der Ausdruck <code>"Haxe„ÅØÊúÄÈ´ò„Å†„ÅûÔºÅ".length</code> f√ºr alle Plattformen gibt immer <code>10</code> (wieder mit Ausnahme von Neko). </p><br><p>  Die UCS-2-Codierung wird nur minimal unterst√ºtzt (f√ºr jede Plattform / Sprache wird eine nativ unterst√ºtzte Codierung verwendet; der Versuch, √ºberall dieselbe Codierung zu unterst√ºtzen, w√§re unpraktisch): </p><br><ul><li>  JavaScript, Flash, HashLink und C ++ verwenden die UCS-2-Codierung </li><li>  f√ºr eval, PHP, lua - UTF-8 </li><li>  f√ºr Java und C # - UTF-16 </li><li>  f√ºr Python - UTF-32 </li></ul><br><p>  Alle Zeichen, die sich au√üerhalb der mehrsprachigen Hauptebene befinden (einschlie√ülich Emoji), werden als "Ersatzpaare" dargestellt. Diese Zeichen werden durch zwei Bytes dargestellt.  Wenn Sie beispielsweise in Java / C # / JavaScript (dh f√ºr Zeichenfolgen in UTF-16- und UCS-2-Codierungen) die L√§nge einer Zeichenfolge anfordern, die aus einem Emoji besteht, lautet das Ergebnis "2".  Diese Tatsache muss bei der Arbeit mit solchen Zeichenfolgen auf diesen Plattformen ber√ºcksichtigt werden. </p><br><p>  Haxe 4 f√ºhrt eine neue Art von Iterator ein - Schl√ºsselwert: </p><br><p><img src="https://habrastorage.org/webt/h5/8l/1f/h58l1f46pistrquuipoopbqybeq.png" alt="Bild"></p><br><p>  Es funktioniert mit Containern vom Typ <code>Map</code> (W√∂rterb√ºcher) und Strings (unter Verwendung der StringTools-Klasse). Die Unterst√ºtzung f√ºr Arrays wurde noch nicht implementiert.  Es ist auch m√∂glich, einen solchen Iterator f√ºr benutzerdefinierte Klassen zu implementieren. <code>keyValueIterator():KeyValueIterator&lt;K, V&gt;</code> reicht es aus, die <code>keyValueIterator():KeyValueIterator&lt;K, V&gt;</code> -Methode f√ºr diese zu implementieren <code>keyValueIterator():KeyValueIterator&lt;K, V&gt;</code> . </p><br><p>  Mit dem neuen Meta-Tag <code>@:using</code> k√∂nnen Sie statische Erweiterungen mit Typen an der Stelle ihrer Deklaration verkn√ºpfen. </p><br><p>  In dem auf der Folie unten gezeigten Beispiel ist die <code>MyOption</code> Aufz√§hlung mit <code>MyOptionTools</code> verkn√ºpft. <code>MyOptionTools</code> erweitern wir diese Aufz√§hlung statisch (was in der √ºblichen Situation nicht m√∂glich ist) und erhalten die M√∂glichkeit, die <code>get()</code> -Methode aufzurufen und sie als Objektmethode zu bezeichnen. </p><br><p><img src="https://habrastorage.org/webt/ol/i7/in/oli7inyhluzdfnval9ohazjh-lg.png" alt="Bild"></p><br><p>  In diesem Beispiel ist die <code>get()</code> -Methode inline, wodurch der Compiler auch den Code weiter optimieren kann: Anstatt die <code>MyOptionTools.get(myOption)</code> -Methode <code>MyOptionTools.get(myOption)</code> , ersetzt der Compiler den gespeicherten Wert, d. H. <code>12</code> . </p><br><p>  Wenn die Methode nicht als einbettbar deklariert ist, besteht ein weiteres Optimierungswerkzeug, das dem Programmierer zur Verf√ºgung steht, darin, die Funktionen am Ort ihres Aufrufs einzubetten (Call-Site-Inlining).  Dazu m√ºssen Sie beim Aufrufen der Funktion zus√§tzlich das <code>inline</code> : </p><br><p><img src="https://habrastorage.org/webt/4p/bb/xp/4pbbxpcwmgfbabo5dih7lpqdmm0.png" alt="Bild"></p><br><p>  Dank der Arbeit von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Daniil Korostelev</a> hat Haxe nun die M√∂glichkeit, ES6-Klassen f√ºr JavaScript zu generieren.  Sie m√ºssen lediglich das Kompilierungsflag <code>-D js-es=6</code> hinzuf√ºgen. </p><br><p>  Derzeit generiert der Compiler eine js-Datei f√ºr das gesamte Projekt (es ist m√∂glicherweise m√∂glich, in Zukunft separate js-Dateien f√ºr jede der Klassen zu generieren, dies kann jedoch bisher nur mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zus√§tzlichen Tools durchgef√ºhrt werden</a> ). </p><br><p><img src="https://habrastorage.org/webt/md/mk/no/mdmknohyzhrkyftm1frzusodoi4.png" alt="Bild"></p><br><p>  Bei abstrakten Aufz√§hlungen werden jetzt automatisch Werte generiert. </p><br><p>  In Haxe 3 mussten die Werte f√ºr jeden Konstruktor manuell festgelegt werden.  In Haxe 4 verhalten sich abstrakte Aufz√§hlungen, die auf <code>Int</code> nach denselben Regeln wie in C. Abstrakte Aufz√§hlungen, die auf Strings erstellt wurden, verhalten sich √§hnlich - f√ºr sie stimmen die generierten Werte mit den Namen der Konstruktoren √ºberein. </p><br><p><img src="https://habrastorage.org/webt/mu/gr/uj/mugrujzah5vmzrw-vcgyjzw42ju.png" alt="Bild"></p><br><p>  Erw√§hnenswert sind auch einige Syntaxverbesserungen: </p><br><ul><li>  abstrakte Aufz√§hlungen und externe Funktionen sind zu vollwertigen Mitgliedern von Haxe geworden, und jetzt m√ºssen Sie nicht mehr die Meta-Tags <code>@:enum</code> und <code>@:extern</code> , um sie zu deklarieren </li><li>  4th Haxe verwendet eine neue Schnittpunktsyntax, die die Essenz expandierender Strukturen besser widerspiegelt.  Solche Konstruktionen sind am n√ºtzlichsten, wenn Datenstrukturen deklariert werden: Der Ausdruck <code>typedef T = A &amp; B</code> bedeutet, dass die Struktur <code>T</code> alle Felder der Typen <code>A</code> und <code>B</code> </li><li>  In √§hnlicher Weise deklarieren die vier Typparametereinschr√§nkungen: Der Eintrag <code>&lt;T:A &amp; B&gt;</code> gibt an, dass der Typ des Parameters <code>T</code> sowohl <code>A</code> als auch <code>B</code> </li><li>  Die alte Syntax funktioniert (mit Ausnahme der Syntax f√ºr Typeinschr√§nkungen, da sie mit der neuen Syntax zur Beschreibung von Funktionstypen in Konflikt steht). </li></ul><br><p><img src="https://habrastorage.org/webt/ju/gt/yu/jugtyumi4hrt7fvt7ridshgzt5a.png" alt="Bild"></p><br><p>  Die neue Syntax zur Beschreibung von Funktionstypen (Funktionstypsyntax) ist logischer: Die Verwendung von Klammern um die Typen von Funktionsargumenten ist visuell einfacher zu lesen.  Dar√ºber hinaus k√∂nnen Sie mit der neuen Syntax Argumentnamen definieren, die als Teil der Dokumentation f√ºr den Code verwendet werden k√∂nnen (dies hat jedoch keine Auswirkungen auf die Eingabe selbst). </p><br><p><img src="https://habrastorage.org/webt/1v/yu/y5/1vyuy5q4ayqlbteqmq3ugx9lzba.png" alt="Bild"></p><br><p>  In diesem Fall wird die alte Syntax weiterhin unterst√ºtzt und wird nicht als veraltet angesehen  Andernfalls w√§ren zu viele √Ñnderungen am vorhandenen Code erforderlich (Simon selbst ist st√§ndig aus Gewohnheit und verwendet weiterhin die alte Syntax). </p><br><p>  Haxe 4 hat endlich Pfeilfunktionen (oder Lambda-Ausdr√ºcke)! </p><br><p><img src="https://habrastorage.org/webt/vh/49/oo/vh49oomjlu8y1o1t5cs-jmzv7nm.png" alt="Bild"></p><br><p>  Merkmale der Pfeilfunktionen in Haxe sind: </p><br><ul><li>  implizite <code>return</code> .  Wenn der Funktionsk√∂rper aus einem Ausdruck besteht, gibt diese Funktion implizit den Wert dieses Ausdrucks zur√ºck </li><li>  Es ist m√∂glich, die Arten von Funktionsargumenten festzulegen, weil  Der Compiler kann den erforderlichen Typ nicht immer bestimmen (z. B. <code>Float</code> oder <code>Int</code> ). </li><li>  Wenn der Hauptteil der Funktion aus mehreren Ausdr√ºcken besteht, m√ºssen Sie ihn mit geschweiften Klammern umgeben </li><li>  Es gibt jedoch keine M√∂glichkeit, den R√ºckgabetyp der Funktion explizit festzulegen </li></ul><br><p>  Im Allgemeinen ist die Syntax von Pfeilfunktionen der in Java 8 verwendeten sehr √§hnlich (obwohl sie etwas anders funktioniert). </p><br><p>  Und da wir Java erw√§hnt haben, sollte gesagt werden, dass es in Haxe 4 m√∂glich wurde, JVM-Bytecode direkt zu generieren.  <code>-D jvm</code> Sie dazu beim Kompilieren eines Projekts unter Java einfach das Flag <code>-D jvm</code> . </p><br><p>  Das Generieren eines JVM-Bytecodes bedeutet, dass kein Java-Compiler verwendet werden muss und der Kompilierungsprozess viel schneller ist. </p><br><p><img src="https://habrastorage.org/webt/ut/bc/mw/utbcmwnuwk1ade_vqrztz5rzhjk.png" alt="Bild"></p><br><p>  Bisher hat das JVM-Ziel aus folgenden Gr√ºnden einen experimentellen Status: </p><br><ul><li>  In einigen F√§llen ist der Bytecode etwas langsamer als das Ergebnis der √úbersetzung von Haxe in Java und der anschlie√üenden Kompilierung mit Javac.  Das Compiler-Team ist sich des Problems bewusst und wei√ü, wie es behoben werden kann. Es erfordert lediglich zus√§tzliche Arbeit. </li><li>  Es gibt Probleme mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MethodHandle</a> unter Android, die auch zus√§tzliche Arbeit erfordern (Simon wird sich freuen, wenn ihm bei der L√∂sung dieser Probleme geholfen wird). </li></ul><br><p><img src="https://habrastorage.org/webt/yo/ho/r5/yohor5rg8cydts1horbcezmqqf0.png" alt="Bild"></p><br><p>  Ein allgemeiner Vergleich des direkten Erzeugens von Bytecode (genjvm) und des Kompilierens von Haxe in Java-Code, der dann in Bytecode (genjava) kompiliert wird: </p><br><ul><li>  Wie bereits erw√§hnt, ist genjvm in Bezug auf die Kompilierungsgeschwindigkeit schneller als genjava <br>  In Bezug auf die Ausf√ºhrungsgeschwindigkeit ist der Bytecode genjvm genjava immer noch unterlegen </li><li>  Es gibt einige Probleme bei der Verwendung von Typparametern und Genjava </li><li>  genJvm verwendet MethodHandle, um auf Funktionen zu verweisen, und genjava verwendet die sogenannten "Waneck-Funktionen" (zu Ehren von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kaui Vanek</a> , dank dessen Java- und C # -Unterst√ºtzung in Haxe erschienen ist).  Obwohl der mit Waneck-Funktionen erhaltene Code nicht sch√∂n aussieht, funktioniert er schnell genug. </li></ul><br><p>  Allgemeine Tipps f√ºr die Arbeit mit Java in Haxe: </p><br><ul><li>  Aufgrund der Tatsache, dass der Garbage Collector in Java schnell ist, sind damit verbundene Probleme selten.  Das st√§ndige Erstellen neuer Objekte ist nat√ºrlich keine gute Idee, aber Java kommt mit der Speicherverwaltung gut zurecht und die Notwendigkeit, sich st√§ndig um die Zuweisungen zu k√ºmmern, ist nicht so akut wie auf einigen anderen von Haxe unterst√ºtzten Plattformen (z. B. in HashLink). </li><li>  Der Zugriff auf die Felder einer Klasse in einem JVM-Ziel kann sehr langsam funktionieren, wenn dies √ºber eine Struktur ( <code>typedef</code> ) erfolgt - w√§hrend der Compiler diesen Code nicht optimieren kann </li><li>  √úberm√§√üige Verwendung des <code>inline</code> Schl√ºsselworts sollte vermieden werden - der JIT-Compiler leistet ziemlich gute Arbeit </li><li>  Vermeiden Sie die Verwendung von <code>Null&lt;T&gt;</code> , insbesondere bei komplexen mathematischen Berechnungen.  Andernfalls werden im generierten Code viele bedingte Anweisungen angezeigt, die sich negativ auf die Geschwindigkeit Ihres Codes auswirken. </li></ul><br><p>  Die neue Haxe 4-Funktion Null-Sicherheit kann dazu beitragen, die Verwendung von <code>Null&lt;T&gt;</code> vermeiden.  Alexander Kuzmenko sprach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letztes Jahr auf der HaxeUp</a> ausf√ºhrlich √ºber sie. </p><br><p><img src="https://habrastorage.org/webt/wx/hk/vk/wxhkvkjk-aq9pjo4mlp6l9hxrzi.png" alt="Bild"></p><br><p>  In dem obigen Beispiel hat die static <code>safe()</code> -Methode den Strict-Modus f√ºr die √úberpr√ºfung auf Null-Sicherheit aktiviert, und diese Methode hat einen optionalen <code>arg</code> Parameter, der einen Null-Wert haben kann.  Damit diese Funktion erfolgreich kompiliert werden kann, muss der Programmierer eine √úberpr√ºfung des <code>arg</code> Argumentwerts hinzuf√ºgen (andernfalls zeigt der Compiler eine Meldung an, dass es unm√∂glich ist, die <code>charAt()</code> -Methode f√ºr ein potenziell null-Objekt <code>charAt()</code> ). </p><br><p><img src="https://habrastorage.org/webt/sd/mq/md/sdmqmdmuv3lauh3wopzzblnxm8k.png" alt="Bild"></p><br><p>  Die Nullsicherheit kann sowohl auf <code>@:nullSafety</code> (mithilfe eines Makros) als auch auf Typen und einzelnen <code>@:nullSafety</code> (mithilfe des Meta-Tags <code>@:nullSafety</code> ) <code>@:nullSafety</code> . </p><br><p>  Die Modi, in denen Null-Sicherheits√ºberpr√ºfungen funktionieren, sind: Strict, Loose und Off.  Global sind diese √úberpr√ºfungen deaktiviert (Aus-Modus).  Wenn sie aktiviert sind, wird standardm√§√üig der Loose-Modus verwendet (es sei denn, Sie geben den Modus explizit an).  Der Hauptunterschied zwischen dem Loose- und dem Strict-Modus besteht darin, dass im Loose-Modus die M√∂glichkeit ignoriert wird, Werte zwischen Operationen f√ºr den Zugriff auf diese Werte zu √§ndern.  In dem Beispiel auf der Folie unten sehen wir, dass eine <code>null</code> f√ºr die Variable <code>x</code> hinzugef√ºgt wurde.  Im strengen Modus wird dieser Code jedoch nicht kompiliert, da  Bevor Sie direkt mit der Variablen <code>x</code> , wird die <code>sideEffect()</code> -Methode <code>sideEffect()</code> , die m√∂glicherweise den Wert dieser Variablen aufheben kann. Sie m√ºssen daher eine weitere Pr√ºfung hinzuf√ºgen oder den Wert der Variablen in eine lokale Variable kopieren, mit der wir weiterhin arbeiten werden. </p><br><p><img src="https://habrastorage.org/webt/m6/sq/6w/m6sq6w1wgue4r9fiylnchvfaxk4.png" alt="Bild"></p><br><p>  Haxe 4 f√ºhrt ein neues <code>final</code> Schl√ºsselwort ein, das je nach Kontext eine unterschiedliche Bedeutung hat: </p><br><ul><li>  Wenn Sie es anstelle des Schl√ºsselworts <code>var</code> , kann dem auf diese Weise deklarierten Feld kein neuer Wert zugewiesen werden.  Sie k√∂nnen es nur direkt beim Deklarieren (f√ºr statische Felder) oder im Konstruktor (f√ºr nicht statische Felder) festlegen. </li><li>  Wenn Sie es beim Deklarieren einer Klasse verwenden, wird die Vererbung von ihr verboten </li><li>  Wenn Sie es als Modifikator f√ºr den Zugriff auf die Eigenschaft eines Objekts verwenden, verhindert dies die Neudefinition von Getter / Setter in den Erbenklassen. </li></ul><br><p><img src="https://habrastorage.org/webt/fo/je/_6/foje_6ftilhqwsyhnb-zbskf-l8.png" alt="Bild"></p><br><p>  Theoretisch kann der Compiler, nachdem er das <code>final</code> Schl√ºsselwort erf√ºllt hat, versuchen, den Code zu optimieren, vorausgesetzt, der Wert dieses Felds √§ndert sich nicht.  Diese M√∂glichkeit wird derzeit jedoch nur in Betracht gezogen und nicht im Compiler implementiert. </p><br><p><img src="https://habrastorage.org/webt/aa/z_/th/aaz_thozjk6apzimnpf15tsfsja.png" alt="Bild"></p><br><p>  Und ein wenig √ºber die Zukunft von Haxe: </p><br><ul><li>  Derzeit wird an einer asynchronen E / A-API gearbeitet <br>  Die Unterst√ºtzung von Coroutine ist geplant, aber die Arbeiten an ihnen sind in der Planungsphase noch nicht abgeschlossen.  Vielleicht erscheinen sie in Haxe 4.1 und vielleicht sp√§ter. </li><li>  Die Tail-Call-Optimierung wird im Compiler angezeigt </li><li>  und m√∂glicherweise die <a href="">auf Modulebene verf√ºgbaren Funktionen</a> .  Obwohl sich die Priorit√§t dieser Funktion st√§ndig √§ndert </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474452/">https://habr.com/ru/post/de474452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474440/index.html">Schwierigkeiten bei der Berechnung der Einnahmen aus Abonnements mit automatischer Verl√§ngerung in iOS-Anwendungen</a></li>
<li><a href="../de474442/index.html">Irish Life Extension Story</a></li>
<li><a href="../de474444/index.html">5 weitere gewagte Trainingsprojekte f√ºr den Entwickler (Layer, Squoosh, Rechner, Website Crawler, Music Player)</a></li>
<li><a href="../de474448/index.html">Was das Gehirn eines Studenten in der Computerwelt kann</a></li>
<li><a href="../de474450/index.html">Verwenden Sie keine l√§cherlich kleinen TTL mehr f√ºr DNS</a></li>
<li><a href="../de474458/index.html">Kumulative Summe in SQL</a></li>
<li><a href="../de474460/index.html">Beschreibung der Prozessorarchitekturen in LLVM mit TableGen</a></li>
<li><a href="../de474462/index.html">Riesiger offener Datensatz der russischen Sprachversion 1.0</a></li>
<li><a href="../de474466/index.html">Geschichte des ersten Diablo</a></li>
<li><a href="../de474470/index.html">DDoS-Angriff auf RDP-Dienste: Erkennen und √úberwinden. Erfolgreiche Erfahrung aus Tucha</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>