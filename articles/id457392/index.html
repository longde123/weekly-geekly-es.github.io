<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤Ÿ ğŸ” ğŸ‘¨ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ» Penghematan pada Pengembangan Lintas-Platform Seluler: Studi Kasus Skyeng ğŸ§‘ğŸ» ğŸ‚ğŸ¿ ğŸ‘ˆğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, saya Andrey Kucherenko, pemimpin tim pengembangan ponsel Skyeng. Kami membuat aplikasi seluler untuk iOS dan Android. Mereka memiliki fungsi yang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penghematan pada Pengembangan Lintas-Platform Seluler: Studi Kasus Skyeng</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/457392/"><p><img src="https://habrastorage.org/webt/di/aq/ep/diaqephrv2-agtf7evehgjbvok8.png"></p><br><p>  Hai, saya Andrey Kucherenko, pemimpin tim pengembangan ponsel Skyeng.  Kami membuat aplikasi seluler untuk iOS dan Android.  Mereka memiliki fungsi yang sama dan antarmuka yang sama akurat dengan gaya.  Tetapi karena platform yang berbeda, pengembangan aplikasi yang tampaknya cukup mahal.  Dalam mencari peluang untuk menghemat pengembangan lintas platform seluler, kami mencoba empat solusi: </p><br><ul><li>  Menggabungkan pengembang iOS dan Android dalam satu tim </li><li>  Pembentukan kelompok kerja untuk memecahkan masalah yang kompleks </li><li>  Menyimpan pada dokumentasi </li><li>  Menulis kode umum </li></ul><br><p>  Saya memiliki kesempatan untuk membuat beberapa laporan tentang apa yang terjadi;  Dalam artikel ini, saya telah mengumpulkan pengamatan dan hasil utama. </p><a name="habracut"></a><br><h2 id="obedinenie-razrabotchikov-ios-i-android-v-odnu-komandu">  Menggabungkan pengembang iOS dan Android dalam satu tim </h2><br><p>  Dua tahun lalu, kami memiliki dua aplikasi seluler yang terpisah dan dua tim pengembangan, yang hanya terhubung oleh manajer produk umum.  Banyak masalah muncul dari ini: aplikasi satu sama lain secara lahiriah hanya menyerupai jarak jauh, mereka bekerja dalam banyak cara, para pengembang tidak tahu bagaimana aplikasi tetangga diatur, mereka secara teratur mengeluarkan segala macam bug dan kesalahan dalam logika.  Pada titik tertentu, menjadi jelas bahwa ini tidak dapat dilanjutkan, dan hal pertama yang kami lakukan dalam hal ini adalah menyatukan pengembang iOS dan Android menjadi satu tim produk, membuat sejumlah proses menjadi umum. </p><br><p>  Salah satu dari proses ini telah menjadi tinjauan teknis. </p><br><p> Sebelum sampai ke pengembang, tugas berjalan dengan cara tertentu.  Untuk mulai dengan, itu dirumuskan dalam format Kisah Pengguna, sketsa atau tata letak digambar di atasnya, setelah itu sebuah epik dimulai di mana masalah pengguna dan solusinya dijelaskan.  Dalam bentuk ini, cerita jatuh ke dalam memimpin tim jika itu adalah epik lintas tim, atau ke satu pemimpin tim jika berada di tim yang sama.  Di sana semuanya terurai ke tingkat tugas individu.  Dalam setiap tugas tersebut, jika sesuai, solusi yang mungkin dijelaskan, tugas di dalam tautan Epic satu sama lain, berbagai pemblokir ditempelkan, yang menghilangkan banyak komunikasi yang tidak perlu.  Setelah itu, tinjauan teknis dilakukan secara langsung, di mana keputusan akhir akan diperbaiki dan estimasi akan dimasukkan.  Juga pada tahap ini, tugas dapat didekomposisi lebih lanjut jika estimasi diperoleh lebih dari dua hari. </p><br><p>  Bagaimana kami menghemat ulasan teknis bersama: </p><br><ul><li>  dalam kebanyakan kasus, ternyata solusi teknis yang sama untuk iOS dan Android.  Solusi yang berbeda juga mungkin, ini mungkin disebabkan oleh arsitektur platform yang berbeda, tetapi dalam konteks tugas perbedaannya paling sering minimal; </li><li>  menyinkronkan arsitektur dan struktur kedua aplikasi.  Ini menghilangkan situasi ketika produk dilengkapi dengan fitur lain, dan kami mengevaluasi tugas iOS dua jam, dan Android pada minggu itu, karena semuanya harus ditulis ulang di sana; </li><li>  lebih sering daripada tidak, kita mendapat nilai bagus.  Jika penilaian kami untuk platform sangat berbeda, ini mungkin mengindikasikan bahwa pengembang tidak memahami tugas, atau beberapa masalah platform yang perlu ditangani; </li><li>  Dengan ulasan ini, pertukaran pengalaman terjadi antara pengembang iOS dan Android, dan saya percaya mereka harus memiliki gagasan tentang bagaimana platform tetangga bekerja.  Sering kali ternyata solusi dari satu platform berhasil untuk yang lain; </li><li>  penyederhanaan pengujian manual.  Fitur diimplementasikan berdasarkan satu solusi teknis, jika QA menemukan bug, maka ini adalah kesempatan untuk mengulangi langkah yang sama di platform lain.  Seringkali bug yang sama juga ada; </li><li>  tentara universal, yang mampu menulis untuk kedua platform: jika ya, maka Anda dapat mengalihkannya di antara proyek, yang meningkatkan faktor bus dan membuatnya mudah untuk mentransfer liburan dan ketidakhadiran.  Tidak ada situasi ketika satu platform berjalan jauh di depan selama liburan. </li></ul><br><p>  <em>Faktor bus: jumlah orang dalam tim yang harus diturunkan oleh bus sehingga proyek tidak dapat dilanjutkan.</em> </p><br><h2 id="rabochie-gruppy-dlya-resheniya-slozhnyh-zadach">  Kelompok kerja untuk memecahkan masalah yang kompleks </h2><br><p>  Untuk menyelesaikan masalah, sangat sering, selain menulis kode secara langsung, kita perlu melakukan beberapa penelitian, melaksanakan desain, dan jika tugas tersebut melibatkan interaksi antar tim, menghabiskan banyak waktu untuk berkomunikasi.  Dalam konteks pengembangan ponsel, tugas apa pun yang tidak memerlukan semua ini adalah sesuatu yang sepele, tidak melibatkan pekerjaan dari backend.  Saya menyebutnya "sederhana", dan yang lainnya - "kompleks". </p><br><p>  Saya menganalisis worklog mengenai distribusi waktu yang dihabiskan untuk penulisan kode, komunikasi, desain, dan penelitian.  Inilah yang terjadi untuk tugas-tugas sederhana: </p><br><p><img src="https://habrastorage.org/webt/6r/4p/pg/6r4ppgle1kafwq8zpq71jbfomze.png"></p><br><p>  Semuanya jelas di sini, pada dasarnya kita menulis kode, biayanya hingga 80% dari waktu. </p><br><p>  Sangat sering, tugas memerlukan semacam penyempurnaan dari backend, ini secara otomatis membuatnya antar-perintah.  Di sini, lebih banyak waktu dihabiskan untuk desain dan komunikasi.  Pangsa penulisan kode berkurang: </p><br><p><img src="https://habrastorage.org/webt/o-/8i/am/o-8iamfvmdnxntwtwy87phf8bpu.png"></p><br><p>  Seringkali produk datang dengan tugas-tugas yang tidak sesuai dengan arsitektur aplikasi saat ini, dan kita perlu menghabiskan waktu untuk menemukan solusi yang baik: mungkin merencanakan beberapa refactoring, segera melaksanakannya sebagai bagian dari tugas, dll.  Dalam hal ini, banyak waktu dihabiskan untuk mendesain: </p><br><p><img src="https://habrastorage.org/webt/6p/3-/2h/6p3-2hiiaivex2z5snunhutiggw.png"></p><br><p>  Akhirnya, tugas-tugas yang umumnya tidak jelas cara pendekatannya, di mana Anda harus terlebih dahulu meneliti dan merancang: </p><br><p><img src="https://habrastorage.org/webt/_u/nw/yg/_unwygwwt1kkfwr2-gmdgaxqgpk.png"></p><br><p>  Jika pekerjaan pada tugas kompleks tidak dapat dikoordinasikan dengan cara apa pun, maka semua pekerjaan yang tidak terkait langsung dengan penulisan kode akan dilakukan dua kali.  Dan dalam tugas yang kompleks, ini adalah 50% dari waktu penyelesaian, seringkali bahkan lebih. </p><br><p>  Saya menemukan jalan keluar: Saya hanya mengambil dan mengunci semua tugas ini pada diri saya sendiri.  Saya berhasil menghemat waktu, tetapi saya terus kelebihan beban, saya tidak punya cukup waktu untuk memperhatikan tugas-tugas prioritas rendah, para pengembang harus menunggu saya, semuanya buruk.  Masalah muncul lagi, dan kami sudah menyelesaikannya dengan membuat kelompok kerja. </p><br><p>  Kelompok kerja adalah beberapa pengembang iOS dan Android yang akan terlibat langsung dalam penerapan fitur ini.  Seseorang ditunjuk sebagai pemimpin, dialah yang akan bertanggung jawab untuk desain, penelitian, interaksi dengan tim lain.  Hasil karyanya akan menjadi dokumentasi, di mana semuanya sudah diperbaiki;  dermaga ini kemudian ditinjau oleh kelompok kerja dan ketua tim, dan tim melanjutkan implementasi. </p><br><p>  Sebagai hasilnya, kami menerima: </p><br><ul><li>  Beban pada Timlid telah menurun, sementara dia tidak kehilangan kendali atas kemajuan tugas.  Saya berpartisipasi dalam semua pertemuan utama, meninjau solusi teknis, benar-benar mengontrol tugas sebelum langsung masuk ke dalam pengembangan; </li><li>  para pengembang sangat termotivasi.  Ketika kami menguji latihan ini, semua orang datang dan berkata "keren, mari kita coba lagi."  Tidak ada orang yang tidak mau melakukan ini dan lebih suka "hanya coding".  Orang-orang memiliki lebih banyak peluang untuk pengembangan; </li><li>  faktor bus meningkat, tim menjadi lebih mandiri, ditambah mereka yang dapat dikembangkan lebih lanjut menjadi pemimpin tim terlihat jelas pada tugas-tugas tersebut.  Masalah meninggalkan Timlida untuk berlibur sedang diselesaikan. </li></ul><br><h2 id="ekonomiya-na-dokumentacii">  Simpan pada dokumentasi </h2><br><p>  Kami memutuskan untuk menyimpan dokumentasi di marketdown dan menyimpannya di repositori github.  Dokumentasi direvisi bersama dengan kode dan permintaan tarik, jadi kami mengecualikan situasi ketika sesuatu ditulis, tetapi ketika tidak ada yang membacanya, dan ketika diminta, tidak ada yang mengerti apa pun.  Dokumentasi dengan kode memungkinkan Anda untuk masuk ke dalam konteks, untuk memahami apa itu pull-rikvest. </p><br><p>  Kami mengedit dokumentasi langsung dari IDE, kebanyakan dari mereka dapat membuat penurunan harga, itu tidak mengganggu kode penulisan, Anda tidak perlu pergi ke suatu tempat dalam pertemuan, risikonya berkurang bahwa pengembang hanya akan lupa untuk memperbaruinya.  Bagi mereka yang mengunduh repositori secara lokal, kami melemparkan tautan ke Github, mereka juga dapat membaca semuanya. </p><br><p>  Akhirnya, gaya docking ini membantu dalam pengembangan pengembang baru: bersama dengan kode, ia menerima semua gaya kode yang mungkin, konvensi, instruksi perakitan aplikasi, dan memasuki tim jauh lebih mudah. </p><br><h2 id="obschiy-kod">  Kode umum </h2><br><p>  Gagasan menulis kode umum bukan yang terbaru, ada banyak alat untuk melakukan ini.  Kami mencoba C ++ untuk menulis perpustakaan kosa kata, dan kami memiliki aplikasi kecil yang seluruhnya ditulis dalam Multipliner Kotlin.  Secara teoritis, ketika menggunakan alat pengembangan lintas-platform, biaya penulisan kode kami harus dikurangi setengahnya.  Tetapi yang tambahan muncul: </p><br><ul><li><p>  biaya awal.  Banyak waktu harus dihabiskan untuk mengumpulkan, meluncurkan, menguji, menguji hipotesis, dan melatih tim.  Dalam beberapa kasus, biaya ini sangat besar sehingga keuntungannya tidak terlihat sama sekali; </p><br></li><li><p>  menulis kode platform.  Dari pengalaman saya sendiri dan berdasarkan sejumlah sumber, saya dapat mengatakan bahwa apa pun alat yang Anda pilih, jika Anda memiliki aplikasi yang agak rumit, cepat atau lambat Anda harus menulis kode platform.  Waktu untuk menulisnya sangat bervariasi tergantung pada alat yang dipilih; </p><br></li><li><p>  penghapusan cacat.  Sebagian besar alat masih sangat mentah, mereka memiliki bug, Anda harus berurusan dengan beberapa rilis yang melanggar kompatibilitas, dan akan butuh waktu untuk memperbaiki semua ini juga; </p><br></li><li><p>  menghindari pembatasan.  Alat lintas platform mungkin memiliki batasan arsitektural atau lainnya yang dapat Anda temui dan habiskan waktu untuk menghindarinya.  Kadang-kadang pembatasan seperti itu ternyata sangat parah sehingga orang harus sepenuhnya meninggalkan alat.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Airbnb mengabaikan React Native</a> dan kembali ke pengembangan asli; </p><br></li><li><p>  Kompleksitas pengembangan.  Anda harus menulis kode untuk dua platform sekaligus, yang tidak semua orang tahu, ditambah komunikasi tambahan akan muncul.  Kurangnya IDE asli juga tidak menyederhanakan pengembangan ini. </p><br></li></ul><br><p>  Untuk membandingkan biaya metode pengembangan lintas platform yang kami coba, saya mengidentifikasi empat kelompok utama: </p><br><ul><li>  biaya awal </li><li>  biaya penulisan kode umum </li><li>  biaya penulisan kode platform </li><li>  biaya infrastruktur (yang tidak berlaku untuk tiga poin pertama) </li></ul><br><p>  Dia mengambil acak-acakan dan membandingkan waktu yang sebenarnya dihabiskan untuk pengembangan lintas-platform dan waktu yang seharusnya kita habiskan untuk pengembangan asli. </p><br><p><img src="https://habrastorage.org/webt/hz/ap/wc/hzapwc2--mfzcwcqsskfjjf2ncw.png"></p><br><p>  Setiap kolom adalah tugas.  Dalam kasus C ++, itu ternyata menjadi awal yang cukup mudah, tetapi biaya infrastruktur ternyata signifikan, total penghematan - hanya 29%.  C ++ juga ditinggalkan karena bahasa ini menurunkan faktor bus: pengembang seluler kami tidak tahu C ++, mereka dapat mendukung kode, tetapi tidak ada seorang pun di tim yang memiliki pengalaman serius. </p><br><p><img src="https://habrastorage.org/webt/uj/pe/yy/ujpeyy7ezjyoka6ew2cxhokqi84.png"></p><br><p>  Start-up sangat tinggi, tetapi sementara biaya kode platform dan infrastruktur rendah.  Kami tidak memiliki cukup untuk analisis yang baik dari jumlah tugas, pada posisi saat ini menghemat 19%.  Dengan asumsi bahwa kita akan melakukan banyak tugas dan membuang biaya awal, kita akan mendapatkan penghematan sekitar 40%, kecuali, tentu saja, masalah serius akan muncul di masa depan.  Kelebihan lainnya adalah sebagian besar pengembang akrab dengan Kotlin. </p><br><p>  Yang minus jelas - kerumitan prosesnya.  Kami baik menulis untuk kedua platform sekaligus, tetapi tidak semuanya dapat, atau menunggu sampai seseorang menulis bagian umum, maka kami akan merevisinya, kemudian ternyata tidak cocok, dll.  dll.  Kita harus mengeluarkan biaya tambahan untuk fase desain, sehingga semuanya mungkin segera berakhir. </p><br><p>  Total: </p><br><ul><li>  Anda dapat dan harus menghemat proses pengembangan seluler dan penulisan kode.  Proses yang dibangun dengan benar membantu tidak hanya menyimpan, tetapi juga menyelesaikan sejumlah tugas tambahan. </li><li>  Saat memilih alat untuk pengembangan ponsel lintas platform, Anda perlu menilai risiko dan biaya tenaga kerja secara cermat. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457392/">https://habr.com/ru/post/id457392/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457378/index.html">Bagaimana id Software menciptakan Wolfenstein 3D berdasarkan teknologi dari Commander Keen</a></li>
<li><a href="../id457380/index.html">OpenGL Ultramodern. Bagian 2</a></li>
<li><a href="../id457382/index.html">7 kebiasaan programmer berkinerja tinggi</a></li>
<li><a href="../id457386/index.html">Memperkenalkan Linux Virtual Interfaces: Tunnels</a></li>
<li><a href="../id457390/index.html">Madagaskar - pulau kontras</a></li>
<li><a href="../id457396/index.html">Membuka kunci wadah LUKS root secara otomatis setelah boot panas</a></li>
<li><a href="../id457398/index.html">Tetapi apakah saya melakukan omong kosong? Mengapa pengembang pergi ke gemba</a></li>
<li><a href="../id457400/index.html">Jumlah korban dalam bencana nuklir seperti Chernobyl sangat dibesar-besarkan untuk drama</a></li>
<li><a href="../id457402/index.html">Bagaimana mengatur pengembangan dan dukungan sebuah blog di WordPress pada 2Q19 dan tidak memperbaikinya</a></li>
<li><a href="../id457404/index.html">Berita dari dunia OpenStreetMap No. 465 (06/11/2019 - 06/16/2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>