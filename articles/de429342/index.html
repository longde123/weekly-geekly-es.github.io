<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🔧 👨🏽‍🔧 🎒 Angular 6+ ist eine vollständige Anleitung zur Abhängigkeitsinjektion. zur Verfügung gestellt gegen Anbieter: [] 🧑🏽‍🤝‍🧑🏽 🙇 🚂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Angular 6 führte eine neue verbesserte Syntax zum Einbetten von Dienstabhängigkeiten in eine Anwendung ein ( requireIn ). Trotz der Tatsache, dass Ang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angular 6+ ist eine vollständige Anleitung zur Abhängigkeitsinjektion. zur Verfügung gestellt gegen Anbieter: []</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429342/"><img src="https://habrastorage.org/getpro/habr/post_images/878/6df/25a/8786df25a4fd4d9b0699cabbfc8dcaec.jpg" alt="Bild"><br><br>  Angular 6 führte eine neue verbesserte Syntax zum Einbetten von Dienstabhängigkeiten in eine Anwendung ein ( <b>requireIn</b> ).  Trotz der Tatsache, dass Angular 7 bereits veröffentlicht wurde, ist dieses Thema immer noch relevant.  <b>Die Kommentare von GitHub, Slack und Stack Overflow sind sehr verwirrend. Schauen wir uns dieses Thema also genauer an.</b> <b><br></b> <br><h3>  In diesem Artikel werden wir Folgendes berücksichtigen: </h3><br><ol><li>  <b>Abhängigkeitsinjektion</b> </li><li>  Alte Methode, um Abhängigkeiten in Angular einzufügen ( <b>Anbieter: []</b> ); </li><li>  Eine neue Methode zum Einfügen von Abhängigkeiten in Angular ( <b>vorausgesetzt: 'root' | SomeModule</b> ); </li><li>  <b>UseIn-</b> Szenarien <b>bietenIn</b> ; </li><li>  Empfehlungen zur Verwendung der neuen Syntax in Anwendungen; </li><li>  Zusammenfassend. </li></ol><a name="habracut"></a><br><h3>  Abhängigkeitsinjektion </h3><br>  Sie können diesen Abschnitt überspringen, wenn Sie bereits eine Vorstellung von <b>DI haben</b> . <br><blockquote>  Mit Dependency <b>Injection</b> ( <b>DI</b> ) können Objekte erstellt werden, die von anderen Objekten abhängen.  Das Abhängigkeitsinjektionssystem stellt abhängige Objekte bereit, wenn es eine Klasse instanziiert. <br><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Winkeldokumentation</a> </blockquote><br>  Formale Erklärungen sind gut, aber schauen wir uns genauer an, was Abhängigkeitsinjektion ist. <br><br>  Alle Komponenten und Dienste sind Klassen.  Jede Klasse verfügt über eine spezielle <b>Konstruktormethode</b> , die beim Aufruf ein Instanzobjekt dieser Klasse erstellt, das in der Anwendung verwendet wird. <br><br>  Angenommen, in einem unserer Dienste gibt es den folgenden Code: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private http: HttpClient)</code> </pre> <br>  Wenn Sie es ohne Verwendung des Abhängigkeitsinjektionsmechanismus erstellen, müssen Sie <b>HttpClient</b> manuell hinzufügen.  Dann sieht der Code folgendermaßen aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyService(httpClient)</code> </pre> <br>  Aber wo in diesem Fall <b>httpClient</b> bekommen?  Es muss auch erstellt werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(httpHandler)</code> </pre> <br>  Aber wo bekommt <b>man</b> jetzt <b>httpHandler</b> ?  Und so weiter, bis alle notwendigen Klassen instanziiert sind.  Wie wir sehen können, kann die manuelle Erstellung kompliziert sein und dabei können Fehler auftreten. <br><br>  <b>Der Winkelabhängigkeitsinjektionsmechanismus erledigt dies alles automatisch.</b>  <b>Wir müssen lediglich die Abhängigkeiten im Komponentenkonstruktor angeben und sie werden ohne unser Zutun hinzugefügt.</b> <br><br><h3>  Alte Methode zum Einfügen von Abhängigkeiten in Angular (Anbieter: []) </h3><br>  Um die Anwendung ausführen zu können, muss Angular jedes einzelne Objekt kennen, das in Komponenten und Services implementiert werden soll.  Vor der Veröffentlichung von Angular 6 bestand die einzige Möglichkeit darin, die Dienste in der <b>Provider-</b> Eigenschaft anzugeben <b>: []</b> decorators <b>@NgModule</b> , <b>@Component</b> und <b>@Directive</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f6c/3a7/433/f6c3a7433a1f72dc45b9e9cd2b5edc18.png" alt="Bild"><br><br>  Hier sind drei Hauptverwendungen von <b>Anbietern: []</b> : <br><br><ol><li>  Im <b>@ NgModule-</b> Dekorator des sofort geladenen Moduls ( <b>eifrig</b> ); </li><li>  Im <b>@ NgModule-</b> Dekorator des Moduls für verzögertes Laden ( <b>faul</b> ); </li><li>  In Dekorateuren <b>@Component</b> und <b>@Directive</b> . </li></ol><br><h4>  Mit der Anwendung heruntergeladene Module (Eager) </h4><br>  In diesem Fall wird der Dienst im globalen Bereich als Singleton registriert.  Es wird ein Singleton sein, selbst wenn es in <b>Anbietern []</b> mehrerer Module enthalten ist.  Es wird eine einzelne Instanz der Serviceklasse erstellt, die auf der Stammebene der Anwendung registriert wird. <br><br><h4>  Verzögerte Lademodule (Lazy) </h4><br>  Während der Initialisierung wird eine Instanz des mit dem <b>Lazy-</b> Modul verbundenen Dienstes erstellt.  Das Hinzufügen eines solchen Dienstes zur <b>eifrigen</b> Komponente des Moduls führt zu einem Fehler: <b>Kein Anbieter für MyService!</b>  <b>Fehler</b> . <br><br><h4>  Implementierung in @ Component und @ Directive </h4><br>  Bei der Implementierung in einer Komponente oder Direktive wird eine separate Instanz des Dienstes erstellt, die in dieser Komponente und allen untergeordneten Komponenten verfügbar ist.  <b>In dieser Situation ist der Dienst kein Singleton, seine Instanz wird jedes Mal erstellt, wenn die Komponente verwendet und gelöscht wird, zusammen mit dem Entfernen der Komponente aus dem DOM.</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b0/4fc/6a9/6b04fc6a974ad8278ba910524a3e062e.png" alt="Bild"><br><br>  In diesem Fall ist <b>RandomService</b> nicht auf Modulebene implementiert und kein Singleton. <br>  aber bei <b>Anbietern</b> registriert <b>: []</b> der <b>RandomComponent-</b> Komponente.  Infolgedessen erhalten wir jedes Mal eine neue Zufallszahl, wenn Sie <b>&lt;randm&gt; &lt;/ randm&gt; verwenden</b> . <br><br><h3>  Neue Methode zum Einfügen von Abhängigkeiten in Angular (vorausgesetzt: 'root' | SomeModule) </h3><br>  In Angular 6 haben wir ein neues Tool <b>"Tree-Shakable Providers"</b> zum <b>Einfügen von</b> Abhängigkeiten in eine Anwendung erhalten, das mit der Eigenschaft <b>"ardsIn "</b> des <b>@ Injectable-</b> Dekorators verwendet werden kann. <br><br>  <b>Sie können sich <b>vorausgesetzt</b> als die Implementierung von Abhängigkeiten in die entgegengesetzte Richtung vorstellen: Bevor das Modul die Dienste beschrieb, mit denen es verbunden werden soll, definiert der Dienst nun das Modul, mit dem es verbunden wird.</b> <br><br>  Der Dienst kann in das Stammverzeichnis der Anwendung ( <b>bereitgestellt in: 'root'</b> ) oder in ein beliebiges Modul ( <b>bereitgestellt in: SomeModule</b> ) <b>eingebettet werden</b> .  <b>bereitgestelltIn: 'root'</b> ist eine Abkürzung für die Bereitstellung im <b>AppModule</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c41/57a/fa6/c4157afa6304838f407ab76f4665aaa8.png" alt="Bild"><br><br>  Lassen Sie uns die wichtigsten Szenarien für die Verwendung der neuen Syntax analysieren: <br><br><ol><li>  Implementierung im Root-Modul der Anwendung ( <b>vorausgesetzt: 'root'</b> ); </li><li>  Implementierung im sofort geladenen Modul ( <b>eifrig</b> ); </li><li>  Implementierung im Modul mit verzögertem Laden ( <b>faul</b> ). </li></ol><br><h4>  Implementierung im Root-Modul der Anwendung (vorausgesetztIn: 'root') </h4><br>  Dies ist die häufigste Option zur Abhängigkeitsinjektion.  In diesem Fall wird der Dienst nur dann zur Bundle-Anwendung hinzugefügt, wenn er tatsächlich verwendet wird, d. H.  eingebettet in eine Komponente oder einen anderen Dienst. <br><br>  Bei Verwendung des neuen Ansatzes gibt es keinen großen Unterschied in einer monolithischen SPA-Anwendung, in der alle schriftlichen Dienste verwendet werden, jedoch <b>bereitgestellt. In: 'root'</b> ist beim Schreiben von Bibliotheken hilfreich. <br><br>  Bisher mussten alle Bibliotheksdienste den <b>Anbietern</b> hinzugefügt <b>werden: []</b> ihres Moduls.  Nach dem Importieren der Bibliothek in die Anwendung wurden alle Dienste zum Bundle hinzugefügt, auch wenn nur einer verwendet wurde.  Im Fall von <b>Bereitgestellt in: 'root'</b> muss das Bibliotheksmodul nicht angeschlossen werden.  Betten Sie den Service einfach in die gewünschte Komponente ein. <br><br><h4>  Modul zum verzögerten Laden (faul) und bereitgestelltIn: 'root' </h4><br>  Was passiert, wenn Sie den Dienst mit <b>deployIn: 'root'</b> im <b>Lazy-</b> Modul implementieren? <br><br>  Technisch gesehen steht <b>'root'</b> für <b>AppModule</b> , aber Angular ist intelligent genug, um dem <b>Lazy</b> Bundle eines Moduls einen Service hinzuzufügen, wenn er nur in seinen Komponenten und Services implementiert ist.  Es gibt jedoch ein Problem (obwohl einige Leute behaupten, dass dies eine Funktion ist).  Wenn Sie später den Dienst, der nur im <b>Lazy-</b> Modul verwendet wird, in das Hauptmodul einführen, wird der Dienst in das <b>Hauptpaket</b> übertragen.  In großen Anwendungen mit vielen Modulen und Diensten kann dies zu Problemen bei der Abhängigkeitsverfolgung und zu unvorhersehbarem Verhalten führen. <br><br>  <b>Seien Sie aufmerksam!</b>  <b>Die Implementierung eines Dienstes in mehreren Modulen kann zu versteckten Abhängigkeiten führen, die schwer zu verstehen und nicht zu entschlüsseln sind.</b> <br><br>  Glücklicherweise gibt es Möglichkeiten, dies zu verhindern, und wir werden sie im Folgenden betrachten. <br><br><h3>  Abhängigkeitsinjektion in sofort geladenem Modul (eifrig) </h3><br>  In der Regel ist dieser Fall nicht sinnvoll und stattdessen können wir <b>vorausgesetzt: 'root' verwenden</b> .  Das Verbinden eines Dienstes in <b>EagerModule</b> kann zur Kapselung verwendet werden und verhindert die Implementierung ohne Anschließen eines Moduls. In den meisten Fällen ist dies jedoch nicht erforderlich. <br><br>  Wenn Sie den Umfang des Dienstes wirklich einschränken müssen, ist es einfacher, die alte <b>Provider-</b> Methode zu verwenden <b>: []</b> , da dies sicherlich nicht zu zyklischen Abhängigkeiten führt. <br><br>  <b>Wenn möglich, versuchen Sie in allen eifrigen Modulen die Verwendung von availableIn: 'root'.</b> <br><br><h4>  Hinweis  Der Vorteil von verzögerten Lademodulen (faul) </h4><br>  Eines der Hauptmerkmale von Angular ist die Möglichkeit, die Anwendung einfach in Fragmente aufzuteilen, was die folgenden Vorteile bietet: <br><br><ol><li>  Die geringe Größe des Hauptbündels der Anwendung, aufgrund derer die Anwendung schneller geladen und gestartet wird. </li><li>  Das Modul für verzögertes Laden ist gut isoliert und wird in der Anwendung einmal in der Eigenschaft <b>loadChildren</b> der entsprechenden Route verbunden. </li></ol><br>  <b>Dank des verzögerten Ladens kann ein ganzes Modul mit Hunderten von Diensten und Komponenten ohne großen Aufwand entfernt oder in eine separate Anwendung oder Bibliothek verschoben werden.</b> <br><br>  Ein weiterer Vorteil der Isolierung des <b>Lazy-</b> Moduls besteht darin, dass ein darin gemachter Fehler den Rest der Anwendung nicht beeinträchtigt.  Jetzt können Sie auch am Veröffentlichungstag ruhig schlafen. <br><br><h3>  Implementierung in einem Modul mit verzögertem Laden (vorausgesetzt: LazyModule) </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/6ce/a76/ebd/6cea76ebda5a5fe9190c79554065f399.png" alt="Bild"><br><br>  Die Abhängigkeitsinjektion in ein bestimmtes Modul verhindert die Verwendung des Dienstes in anderen Teilen der Anwendung.  Dadurch bleibt die Abhängigkeitsstruktur erhalten, was besonders für große Anwendungen nützlich ist, bei denen eine unordentliche Abhängigkeitsinjektion zu Verwirrung führen kann. <br><br>  <b>Interessante Tatsache: Wenn Sie den Lazy Service im Hauptteil der Anwendung implementieren, schlägt die Assembly (auch AOT) fehlerfrei fehl, die Anwendung stürzt jedoch mit dem Fehler "Kein Anbieter für LazyService" ab.</b> <br><br><h4>  Das Problem mit der zyklischen Abhängigkeit </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/789/f3d/551/789f3d551cca5651454027e49a1513c3.png" alt="Bild"><br><br>  Sie können den Fehler wie folgt reproduzieren: <br><br><ol><li>  Erstellen Sie das <b>LazyModule-</b> Modul. </li><li>  Wir erstellen den <b>LazyService-</b> Dienst und stellen eine Verbindung mit <b>bereitgestellten Informationen her: LazyModule</b> ; </li><li>  Wir erstellen die <b>LazyComponent-</b> Komponente und verbinden sie mit dem <b>LazyModule</b> . </li><li>  Fügen Sie <b>LazyService</b> zum Konstruktor der <b>LazyComponent-</b> Komponente hinzu. </li><li>  Wir erhalten einen Fehler mit einer zyklischen Abhängigkeit. </li></ol><br>  Schematisch sieht es so aus: <b>Service -&gt; Modul -&gt; Komponente -&gt; Service</b> . <br><br>  Sie können dieses Problem lösen, indem Sie ein Submodul <b>LazyServiceModule erstellen</b> , das mit <b>LazyModule verbunden wird</b> .  Verbinden Sie Dienste mit dem Submodul. <br><img src="https://habrastorage.org/getpro/habr/post_images/c9c/da3/bae/c9cda3bae241d0c3e748ca16007ed816.jpg" alt="Bild"><br><br>  In diesem Fall müssen Sie ein zusätzliches Modul erstellen, dies erfordert jedoch keinen großen Aufwand und bietet die folgenden Vorteile: <br><br><ol><li>  Dadurch wird die Einführung des Dienstes in anderen Anwendungsmodulen verhindert. </li><li>  Ein Dienst wird dem Bundle nur hinzugefügt, wenn er in eine Komponente oder einen anderen im Modul verwendeten Dienst eingebettet ist. </li></ol><br><h4>  Einbetten eines Dienstes in eine Komponente (bereitgestellt in: SomeComponent) </h4><br>  Ist es möglich, einen Dienst mit der neuen Syntax in <b>@Component</b> oder <b>@Directive</b> einzubetten? <br><br>  <b>Im Moment nicht!</b> <br><br>  Um eine Instanz des Dienstes für jede Komponente zu erstellen, müssen Sie weiterhin <b>Anbieter verwenden: []</b> in den <b>Dekoratoren</b> <b>@</b> <b>omponent</b> oder <b>@Directive</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46b/56b/6af/46b56b6af20ae67ffe30cff15fc0eb47.png" alt="Bild"><br><br><h3>  Best Practices für die Verwendung neuer Syntax in Anwendungen </h3><br><h4>  Bibliotheken </h4><br>  <b>vorausgesetzt: 'root'</b> eignet sich zum Erstellen von Bibliotheken.  Dies ist eine sehr bequeme Möglichkeit, nur den direkt verwendeten Teil der Funktionalität mit der Hauptanwendung zu verbinden und die Größe der Endmontage zu reduzieren. <br><br>  <b>Ein praktisches Beispiel ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ngx-Modellbibliothek</a> , die mit der neuen Syntax neu geschrieben wurde und jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ angle-extensions / model heißt</a> .</b>  <b>In der neuen Implementierung muss NgxModelModule nicht mit der Anwendung verbunden werden. Es reicht aus, ModelFactory nur in die erforderliche Komponente einzubetten.</b>  <b>Details zur Implementierung finden Sie <a href="">hier</a> .</b> <br><br><h4>  Aufgeschobene Download-Module (faul) </h4><br>  Verwenden Sie das separate Modul <b>ProvidedIn: LazyServicesModule</b> für Dienste und schließen Sie es an <b>LazyModule an</b> .  Dieser Ansatz kapselt Dienste und verhindert, dass sie in andere Module eingesteckt werden.  Dadurch werden Grenzen gesetzt und eine skalierbare Architektur erstellt. <br><br>  <b>Nach meiner Erfahrung kann eine versehentliche Einführung in das Haupt- oder Zusatzmodul (unter Verwendung von Bereitgestelltem: 'root') zu Verwirrung führen und ist nicht die beste Lösung!</b> <br><br>  <b>Bereitgestellt in: 'root'</b> funktioniert auch korrekt, aber bei Verwendung von <b>Bereitgestellt: LazyServideModule</b> wird bei der Implementierung in anderen Modulen ein Fehler <b>"Fehlender Anbieter"</b> <b>angezeigt</b> , und wir können die Architektur beheben.  <b>Verschieben Sie den Dienst an einen geeigneteren Ort im Hauptteil der Anwendung.</b> <br><br><h4>  Wann sollten Anbieter eingesetzt werden: []? </h4><br>  In Fällen, in denen das Modul konfiguriert werden muss.  Verbinden Sie den Dienst beispielsweise nur mit <b>SomeModule.forRoot (someConfig)</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fe3/244/6e1/fe32446e118077fc5fb5839bb32c7501.png" alt="Bild"><br><br>  <b>Andererseits können Sie in dieser Situation vorausgesetzt: 'root' verwenden.</b>  <b>Dadurch wird garantiert, dass der Dienst nur einmal zur Anwendung hinzugefügt wird.</b> <br><br><h3>  Schlussfolgerungen </h3><br><ol><li>  Verwenden Sie availableIn <b>: 'root'</b> , um den Dienst als Singleton zu registrieren, der in der gesamten Anwendung verfügbar ist. </li><li>  Verwenden Sie <b>für</b> <b>das im Hauptpaket</b> enthaltene Modul <b>Bereitgestellt in: 'root'</b> , nicht <b>Bereitgestellt in: EagerlyImportedModule</b> .  Verwenden Sie in Ausnahmefällen <b>Anbieter: []</b> zur Kapselung. </li><li>  Erstellen Sie ein Submodul mit Diensten, um deren Umfang <b>einzuschränken. In: LazyServiceModule</b> bei Verwendung des <b>verzögerten</b> Ladens. </li><li>  <b>Stecken Sie</b> das <b>LazyServiceModule-</b> Modul in das <b>LazyModule</b> , um eine zirkuläre Abhängigkeit zu vermeiden. </li><li>  Verwenden Sie <b>Anbieter: []</b> in den <b>Dekoratoren</b> <b>@</b> <b>omponent</b> und <b>@Directive</b> , um für jede neue Komponenteninstanz eine neue <b>Dienstinstanz</b> zu erstellen.  Eine Dienstinstanz ist auch in allen untergeordneten Komponenten verfügbar. </li><li>  Begrenzen Sie immer den Umfang der Abhängigkeiten, um die Architektur zu verbessern und verwirrende Abhängigkeiten zu vermeiden. </li></ol><br><h3>  Referenzen </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originalartikel.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Angular ist eine russischsprachige Gemeinschaft.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Angular Meetups in Russland</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429342/">https://habr.com/ru/post/de429342/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429330/index.html">Mythen und Legenden von Agile - von den Pharaonen bis heute</a></li>
<li><a href="../de429332/index.html">Selbstgemachtes Laserlichtschwert - wie es war, Teil 1</a></li>
<li><a href="../de429336/index.html">Kommunikation zwischen Treiber und Gerät über die _HID ACPI-Methode am Beispiel des GPIO des Lynxpoint-Controllers</a></li>
<li><a href="../de429338/index.html">Android-Speicher: intern, extern, entfernbar. Teil 1/3</a></li>
<li><a href="../de429340/index.html">Überlegen Sie zweimal, bevor Sie Helm verwenden.</a></li>
<li><a href="../de429344/index.html">Wochenendlesung: Ressourcen für Audio-Tuning und Lautsprecherdesign</a></li>
<li><a href="../de429346/index.html">Zum Masterstudiengang ohne Prüfungen: eine neue Richtung "Big Data" bei den Olympischen Spielen "Ich bin ein Profi"</a></li>
<li><a href="../de429348/index.html">Warum wird Agile in Zukunft nicht mehr benötigt?</a></li>
<li><a href="../de429350/index.html">Der Markt für Verkabelung und Verkabelung von Offshore-Windenergie erreicht 14 Mrd. GBP</a></li>
<li><a href="../de429352/index.html">Eine Liste gesunder IT'shnik oder wie Sie Ihr Leben nicht ruinieren können</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>