<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎾 🎐 🤞 Linux内核启动。 第一部分 🚷 👸🏿 👩🏻‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="从引导程序到内核 

 如果您阅读了以前的文章 ，您将了解我对底层编程的新兴趣。 我写了几篇关于x86_64 Linux的汇编程序编程的文章，同时开始深入研究Linux内核的源代码。 

 我非常想了解低级事物的工作原理：程序如何在计算机上运行，​​它们如何位于内存中，内核如何管理进程和内存，网络堆...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux内核启动。 第一部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428664/"> <b>从引导程序到内核</b> <br><br> 如果您阅读了以前的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> ，您将了解我对底层编程的新兴趣。 我写了几篇关于<code>x86_64</code> Linux的汇编程序编程的文章，同时开始深入研究Linux内核的源代码。 <br><br> 我非常想了解低级事物的工作原理：程序如何在计算机上运行，​​它们如何位于内存中，内核如何管理进程和内存，网络堆栈在低级如何工作等等。 因此，我决定写另一系列有关<b>x86_64体系结构</b> Linux内核的文章。 <br><br> 请注意，我不是专业的内核开发人员，也不在工作时编写内核代码。 这只是一个爱好。 我只喜欢低级的东西，深入研究它们很有趣。 因此，如果您发现任何混乱或疑问/评论出现，请<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过Twitter</a>通过<a href="">邮件</a>与我联系，或者只是创建<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">票证</a> 。 我将不胜感激。 <br><a name="habracut"></a><br> 所有文章都发布在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub存储库中</a> ，如果我的英语或文章内容有问题，请立即发送拉取请求。 <br><br>  <i>请注意，这不是官方文档，而只是培训和知识共享。</i> <br><br>  <b>必修知识</b> <br><br><ul><li> 了解C代码 </li><li> 了解汇编代码（AT＆T语法） </li></ul><br> 无论如何，如果您刚刚开始学习此类工具，我将尝试在本文章及其后续文章中进行解释。 好的，随着介绍的完成，是时候深入探讨Linux内核和底层知识了。 <br><br> 我从Linux 3.18内核时代开始写这本书，此后发生了很多变化。 如果有更改，我将相应地更新文章。 <br><br><h1> 魔术电源按钮，下一步是什么？ </h1><br> 尽管这些是有关Linux内核的文章，但至少在本节中，我们还没有涉及到它。 按下膝上型计算机或台式计算机上的魔术电源按钮后，它将立即开始工作。 主板将信号发送到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">电源</a> 。 收到信号后，它将为计算机提供必要的电量。 主板收到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“电源正常”信号后</a> ，便立即尝试启动CPU。 他将所有剩余的数据转储到寄存器中，并为每个寄存器设置预定义的值。 <br><br> 重新启动后，处理器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">80386</a>和更高版本的CPU寄存器中应具有以下值： <br><br><pre>  IP 0xfff0
 CS选择器0xf000
 CS基数0xffff0000 </pre><br> 处理器开始在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实模式下</a>工作。 让我们回到过去，尝试了解此模式下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的内存分段</a> 。 所有与x86兼容的处理器都支持实模式：从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8086</a>到现代的64位Intel处理器。  8086处理器使用20位地址总线，也就是说，它可以使用<code>0-0xFFFFF</code>或<code>1 </code>的地址空间工作。 但是它只有16位寄存器，最大地址为<code>2^16-1</code>或<code>0xffff</code> （64 KB）。 <br><br> 需要使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内存分段</a>来使用整个可用地址空间。 所有内存均分为固定大小为<code>65536</code>字节（64 KB）的小段。 由于使用16位寄存器，我们无法访问64 KB以上的内存，因此开发了另一种方法。 <br><br> 地址由两部分组成：1）具有基地址的段选择器；  2）从基址偏移。 在实模式下，段<code>  * 16</code>的基地址为<code>  * 16</code> 。 因此，要获取内存中的物理地址，您需要将段选择器的一部分乘以16并向其添加偏移量： <br><br><pre> <code class="hljs">  =   * 16 + </code> </pre> <br> 例如，如果<code>CS:IP</code>寄存器的值为<code>0x2000:0x0010</code> ，则相应的物理地址将如下所示： <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0x2000</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0x0010</span></span>) <span class="hljs-string"><span class="hljs-string">'0x20010'</span></span></code> </pre> <br> 但是，如果使用最大段的选择器和偏移量<code>0xffff:0xffff</code> ，则会得到地址： <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0xffff</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) <span class="hljs-string"><span class="hljs-string">'0x10ffef'</span></span></code> </pre> <br> 即第一个兆字节后的<code>65520</code>个字节。 由于在实模式下只有1兆字节可用， <code>0x10ffef</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在</a>禁用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">A20线路的情况</a>下<code>0x10ffef</code>变为<code>0x00ffef</code> 。 <br><br> 好了，现在我们对实模式和此模式下的内存寻址有所了解。 让我们回到复位后寄存器值的讨论。 <br><br>  <code>CS</code>寄存器由两部分组成：可见的段选择器和隐藏的基地址。 尽管基地址通常是通过在硬件复位期间将段选择器的值乘以16形成的，但CS寄存器中的段选择器为<code>0xf000</code> ，基地址为<code>0xffff0000</code> 。 处理器使用此特殊基地址，直到CS更改为止。 <br><br> 通过将基地址添加到EIP寄存器中的值来形成起始地址： <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; <span class="hljs-number"><span class="hljs-number">0xffff0000</span></span> + <span class="hljs-number"><span class="hljs-number">0xfff0</span></span> <span class="hljs-string"><span class="hljs-string">'0xfffffff0'</span></span></code> </pre> <br> 我们得到<code>0xfffffff0</code> ，这是4 GB以下的16个字节。 这一点称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">复位向量</a> 。 这是内存中CPU复位后等待第一条指令执行的位置：跳转操作（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">jmp</a> ），通常指示BIOS入口点。 例如，如果您查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">coreboot</a>的源代码（ <code>src/cpu/x86/16bit/reset16.inc</code> ），我们将看到： <br><br><pre> <code class="hljs css"> <span class="hljs-selector-class"><span class="hljs-selector-class">.section</span></span> "<span class="hljs-selector-class"><span class="hljs-selector-class">.reset</span></span>", "<span class="hljs-selector-tag"><span class="hljs-selector-tag">ax</span></span>", %<span class="hljs-selector-tag"><span class="hljs-selector-tag">progbits</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.code16</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.globl</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xe9</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.int</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start16bit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> ( . + 2 ) ...</code> </pre> <br> 在这里，我们看到操作码（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">opcode</a> ） <code>jmp</code> ，即<code>0xe9</code> ，目的地址<code>_start16bit - ( . + 2)</code> 。 <br><br> 我们还看到<code>reset</code>部分是16个字节，它编译后从地址<code>0xfffff0</code> （ <code>src/cpu/x86/16bit/reset16.ld</code> ）运行： <br><br><pre> <code class="hljs pgsql">SECTIONS { <span class="hljs-comment"><span class="hljs-comment">/* Trigger an error if I have an unuseable start address */</span></span> _bogus = <span class="hljs-keyword"><span class="hljs-keyword">ASSERT</span></span>(_start16bit &gt;= <span class="hljs-number"><span class="hljs-number">0xffff0000</span></span>, "_start16bit too low. Please report."); _ROMTOP = <span class="hljs-number"><span class="hljs-number">0xfffffff0</span></span>; . = _ROMTOP; .<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span> . : { *(.<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>); . = <span class="hljs-number"><span class="hljs-number">15</span></span>; BYTE(<span class="hljs-number"><span class="hljs-number">0x00</span></span>); } }</code> </pre> <br>  BIOS现在启动； 初始化并检查BIOS硬件后，您需要找到引导设备。 引导顺序保存在BIOS配置中。 尝试从硬盘驱动器引导时，BIOS尝试查找引导扇区。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MBR分区</a>磁盘上，引导扇区存储在第一个扇区的前446个字节中，其中每个扇区为512个字节。 第一个扇区的最后两个字节是<code>0x55</code>和<code>0xaa</code> 。 它们显示BIOS它是引导设备。 <br><br> 例如： <br><br><pre> <code class="hljs powershell">; ; :       Intel x86 ; [<span class="hljs-type"><span class="hljs-type">BITS</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>] boot: mov al, <span class="hljs-string"><span class="hljs-string">'!'</span></span> mov ah, <span class="hljs-number"><span class="hljs-number">0</span></span>x0e mov bh, <span class="hljs-number"><span class="hljs-number">0</span></span>x00 mov bl, <span class="hljs-number"><span class="hljs-number">0</span></span>x07 int <span class="hljs-number"><span class="hljs-number">0</span></span>x10 jmp <span class="hljs-variable"><span class="hljs-variable">$</span></span> times <span class="hljs-number"><span class="hljs-number">510</span></span>-(<span class="hljs-variable"><span class="hljs-variable">$</span></span>-<span class="hljs-variable"><span class="hljs-variable">$</span></span><span class="hljs-variable"><span class="hljs-variable">$</span></span>) db <span class="hljs-number"><span class="hljs-number">0</span></span> db <span class="hljs-number"><span class="hljs-number">0</span></span>x55 db <span class="hljs-number"><span class="hljs-number">0</span></span>xaa</code> </pre> <br> 我们收集并运行： <br><br> <code>nasm -f bin boot.nasm &amp;&amp; qemu-system-x86_64 boot</code> <br> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">QEMU</a>收到一条命令，以使用我们刚刚创建的<code>boot</code>二进制文件作为磁盘映像。 由于上面生成的二进制文件满足引导扇区的要求（从<code>0x7c00</code>开始并以魔术序列结束），因此QEMU将二进制文件视为磁盘映像的主引导记录（MBR）。 <br><br> 您将看到： <br><br><img src="https://habrastorage.org/webt/e1/rk/nw/e1rknwgwcuouazuhzrmco1b8szg.png"><br><br> 在此示例中，我们看到代码以16位实模式运行，并从内存中的地址<code>0x7c00</code>开始。 启动后，它会导致一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">0x10</a>中断，该中断只会打印一个字符<code>!</code>  ; 用零填充剩余的510字节，并以两个魔术字节<code>0xaa</code>和<code>0x55</code> <code>0xaa</code> 。 <br><br> 您可以使用<code>objdump</code>实用程序查看二进制转储： <br><br> <code>nasm -f bin boot.nasm <br> objdump -D -b binary -mi386 -Maddr16,data16,intel boot</code> <br> <br> 当然，在实际的引导扇区中，有代码可以继续引导过程和分区表，而不是一堆零和一个感叹号:)。 从这一刻起，BIOS将控制权转移到引导加载程序。 <br><br>  <i>注意</i> ：如上所述，CPU处于实模式。 内存中物理地址的计算如下： <br><br><pre> <code class="hljs">  =   * 16 + </code> </pre> <br> 我们只有16位通用寄存器，而16位寄存器的最大值是<code>0xffff</code> ，因此，最大值将是： <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0xffff</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>) + <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) <span class="hljs-string"><span class="hljs-string">'0x10ffef'</span></span></code> </pre> <br> 其中<code>0x10ffef</code>是<code>1  + 64  - 16 </code> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8086处理器</a> （第一个具有实模式的处理器）具有20位地址线。 由于<code>2^20 = 1048576</code> ，因此实际可用内存为1 MB。 <br><br> 通常，实模式存储器寻址如下： <br><br><pre>  0x00000000-0x000003FF-实模式的中断向量表
 0x00000400-0x000004FF-BIOS数据区域
 0x00000500-0x00007BFF-未使用
 0x00007C00-0x00007DFF-我们的引导程序
 0x00007E00-0x0009FFFF-未使用
 0x000A0000-0x000BFFFF-视频RAM（VRAM） 
 0x000B0000-0x000B7777-单色视频存储器
 0x000B8000-0x000BFFFF-彩色模式视频存储器
 0x000C0000-0x000C7FFF-视频ROM BIOS
 0x000C8000-0x000EFFFF-阴影区域（BIOS阴影）
 0x000F0000-0x000FFFFF-系统BIOS </pre><br> 在本文开头写道，处理器的第一条指令位于<code>0xFFFFFFF0</code> ，这比<code>0xFFFFF</code> （1 MB）大得多。  CPU如何在实模式下访问该地址？ 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">coreboot</a>文档中回答： <br><br> <code>0xFFFE_0000 - 0xFFFF_FFFF: 128  ROM    </code> <br> <br> 在执行开始时，BIOS不在RAM中，而在ROM中。 <br><br><h1> 引导程序 </h1><br>  Linux内核可以使用不同的引导加载程序进行加载，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GRUB 2</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">syslinux</a> 。 内核具有一个引导协议，该协议定义了用于实现Linux支持的引导程序要求。 在此示例中，我们正在使用GRUB 2。 <br><br> 继续引导过程，BIOS选择了引导设备并将控制权转移到引导扇区，执行从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">boot.img</a>开始。 由于大小有限，这是一个非常简单的代码。 它包含一个指向主GRUB 2映像的指针，它以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">diskboot.img</a>开头，通常存储在第一个扇区之后，第一个分区之前的未使用空间中。 上面的代码将包含GRUB 2内核和用于处理文件系统的驱动程序的其余映像加载到内存中。 之后， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">执行grub_main</a>函数。 <br><br>  <code>grub_main</code>函数初始化控制台，返回模块的基址，设置根设备，加载/解析grub配置文件，加载模块，等等。 在执行结束时，它将使grub进入普通模式。  <code>grub_normal_execute</code>函数（来自<code>grub-core/normal/main.c</code>源文件）完成了最后的准备工作并显示了用于选择操作系统的菜单。 当我们选择grub菜单项之一时，将<code>grub_menu_execute_entry</code>函数，该函数执行grub <code>boot</code>命令并加载所选的OS。 <br><br> 如内核引导协议中所示，引导加载程序必须读取并填写内核安装标头的某些字段，该字段从内核安装代码的偏移量<code>0x01f1</code>开始。 此偏移量在<a href="">链接脚本中</a>指示。 内核头文件<a href="">arch / x86 / boot / header.S的</a>开头是： <br><br><pre> <code class="hljs css"> <span class="hljs-selector-class"><span class="hljs-selector-class">.globl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hdr</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hdr</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">setup_sects</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">root_flags</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ROOT_RDONLY</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">syssize</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.long</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">ram_size</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">vid_mode</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SVGA_MODE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">root_dev</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">boot_flag</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xAA55</span></span></code> </pre> <br> 引导加载程序应使用从命令行接收或在引导时计算的值来填充此标头和其他标头（在本示例中，在Linux引导协议中仅标记为类型<code>write</code> ）。 现在，我们将不讨论所有标题字段的描述和解释。 稍后我们将讨论内核如何使用它们。 有关所有字段的说明，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下载协议</a> 。 <br><br> 如您在内核启动协议中所看到的，内存将显示如下： <br><br><pre>  | 受保护的内核模式
 100000 + ------------------------ +
          |  I / O映射|
 0A0000 + ------------------------ +
          | 储备金 对于BIOS | 尽可能地自由
          ~~
          | 命令行|  （也可能低于X + 10000）
 X + 10000 + ------------------------ +
          | 堆/堆| 使用真实的内核模式代码
 X + 08000 + ------------------------ +
          | 内核安装| 内核实模式代码
          | 内核引导扇区| 旧版内核启动扇区
        X + ------------------------ +
          | 装载机  &lt;-入口点0x7C00引导扇区
 001000 + ------------------------ +
          | 储备金 适用于MBR / BIOS |
 000800 + ------------------------ +
          | 通常使用  MBR |
 000600 + ------------------------ +
          | 二手的 仅BIOS |
 000000 + ------------------------ +
</pre><br> 因此，当加载程序将控制权转移到内核时，它以地址开头： <br><br><pre> <code class="hljs lisp">X + sizeof (<span class="hljs-name"><span class="hljs-name">KernelBootSector</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br> 其中<code>X</code>是内核引导扇区的地址。 在我们的例子中， <code>X</code>是<code>0x10000</code> ，如内存转储所示： <br><br><img src="https://habrastorage.org/webt/ot/1u/ep/ot1uepwbgvghzktwcbwwskwwjbs.png"><br><br> 引导程序将Linux内核移至内存中，填充标头字段，然后移至相应的内存地址。 现在我们可以直接进入内核安装代码。 <br><br><h1> 内核安装阶段开始 </h1><br> 最后，我们是核心！ 尽管从技术上讲它尚未运行。 首先，内核安装部分需要配置一些东西，包括一个解压缩器和一些带有内存管理的东西。 完成所有这些步骤后，她将解压缩真正的核心并继续进行。 安装以带有<a href="">_start</a>字符的<a href="">arch / x86 / boot / header.S</a>开始。 <br><br> 乍一看，这似乎有些奇怪，因为在他面前有几条指令。 但是很久以前，Linux内核拥有自己的引导程序。 现在，例如，如果您运行 <br><br> <code>qemu-system-x86_64 vmlinuz-3.18-generic</code> <br> <br> 您将看到： <br><br><img src="https://habrastorage.org/webt/4r/5f/xg/4r5fxgpwl4l2vwlw9muscl3ygie.png"><br><br> 实际上， <code>header.S</code>文件以魔术数字<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MZ</a> （请参见上面的转储的屏幕截图），错误消息的文本和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PE</a>标头开头： <br><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#ifdef</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">CONFIG_EFI_STUB</span></span> # "<span class="hljs-selector-tag"><span class="hljs-selector-tag">MZ</span></span>", <span class="hljs-selector-tag"><span class="hljs-selector-tag">MS-DOS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">header</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x4d</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x5a</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#endif</span></span> ... ... ... <span class="hljs-selector-tag"><span class="hljs-selector-tag">pe_header</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.ascii</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">PE</span></span>" <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0</code> </pre> <br> 需要加载带有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UEFI</a>支持的操作系统。 我们将在以下各章中考虑其设备。 <br><br> 安装内核的实际入口点： <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// header.S line 292 .globl _start _start:</span></span></code> </pre> <br> 引导程序（grub2等）知道这一点（从<code>MZ</code>偏移<code>0x200</code> ）并直接转到该点，尽管<code>header.S</code>从<code>.bstext</code>部分开始，错误消息的文本位于该部分： <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ arch/x</span></span>86/boot/setup.ld /<span class="hljs-regexp"><span class="hljs-regexp">/ . = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ current position .bstext : { *(.bstext) } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ put .bstext section to position 0 .bsdata : { *(.bsdata) }</span></span></code> </pre> <br> 内核安装入口点： <br><br><pre> <code class="hljs go"> .globl _start _start: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-number"><span class="hljs-number">0xeb</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> start_of_setup<span class="hljs-number"><span class="hljs-number">-1f</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">// // rest of the header //</span></span></code> </pre> <br> 在这里，我们看到操作代码<code>jmp</code> （ <code>0xeb</code> ），该代码转到<code>start_of_setup-1f</code>点。 例如，在<code>Nf</code>表示法中， <code>2f</code>表示本地标签<code>2:</code> 在我们的示例中，这是标签<code>1</code> ，它在转换后立即出现，并且包含其余的设置标头。 在安装标题之后，我们立即看到<code>.entrytext</code>部分，该部分以<code>start_of_setup</code>标签开头。 <br><br> 这是实际执行的第一个代码（当然，不是前面的跳转指令）。 在部分内核安装收到来自加载程序的控制后，第一条<code>jmp</code>指令位于从实际内核模式开始的偏移量<code>0x200</code>处，即在前512个字节之后。 在Linux内核启动协议和grub2源代码中都可以看到： <br><br><pre> <code class="hljs ruby">segment = grub_linux_real_target <span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span><span class="hljs-number"><span class="hljs-number">4</span></span>; state.gs = state.fs = state.es = state.ds = state.ss = segment; state.cs = segment + <span class="hljs-number"><span class="hljs-number">0x20</span></span>;</code> </pre> <br> 在我们的例子中，内核在地址<code>0x10000</code>引导。 这意味着开始内核安装后，段寄存器将具有以下值： <br><br> <code>gs = fs = es = ds = ss = 0x10000 <br> cs = 0x10200</code> <br> <br> 转到<code>start_of_setup</code>内核应执行以下操作： <br><br><ul><li> 确保所有段寄存器值都相同 </li><li> 如有必要，配置正确的堆栈 </li><li> 配置<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bss</a> </li><li> 在<a href="">arch / x86 / boot / main.c中</a>转到C代码 </li></ul><br> 让我们看看这是如何实现的。 <br><br><h1> 段案例对齐 </h1><br> 首先，内核检查<code>ds</code>和<code>es</code>段寄存器是否指向相同的地址。 然后使用<code>cld</code>清除方向标志： <br><br><pre> <code class="hljs perl"> movw %ds, %ax movw %ax, %es cld</code> </pre> <br> 如我先前所写，默认情况下，grub2加载内核安装代码为<code>0x10000</code> ， <code>cs</code>加载为<code>0x10200</code> ，因为执行不是从文件开头开始，而是从此处的过渡开始： <br><br><pre> <code class="hljs go">_start: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-number"><span class="hljs-number">0xeb</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> start_of_setup<span class="hljs-number"><span class="hljs-number">-1f</span></span></code> </pre> <br> 这是<a href="">4d 5a</a>的<code>512</code>字节偏移量。 像所有其他段寄存器一样，还必须将<code>cs</code>从<code>0x10200</code>对齐到<code>0x10000</code> 。 之后，安装堆栈： <br><br><pre> <code class="hljs perl"> pushw %ds pushw $6f lretw</code> </pre> <br> 该指令将<code>ds</code>值压入堆栈，然后是标签<a href="">6</a>的地址和<code>lretw</code>指令，后者将标签<code>6</code>的地址加载到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">命令计数器</a>的寄存器中，并向<code>cs</code>加载值<code>ds</code> 。 之后， <code>ds</code>和<code>cs</code>将具有相同的值。 <br><br><h1> 堆叠设定 </h1><br> 几乎所有这些代码都是在实模式下准备C环境的过程的一部分。 下一步是检查<code>ss</code>寄存器值，如果<code>ss</code>值不正确，则创建正确的堆栈： <br><br><pre> <code class="hljs perl"> movw %ss, %dx cmpw %ax, %dx movw %sp, %dx je <span class="hljs-number"><span class="hljs-number">2</span></span>f</code> </pre> <br> 这可以触发三种不同的情况： <br><br><ul><li>  <code>ss</code>有效值为<code>0x1000</code> （与<code>cs</code>以外的所有其他寄存器一样） </li><li>  <code>ss</code>值无效，并且设置了<code>CAN_USE_HEAP</code>标志（请参见下文） </li><li>  <code>ss</code>值无效，并且未设置<code>CAN_USE_HEAP</code>标志（请参见下文） </li></ul><br> 按顺序考虑所有方案： <br><br><ul><li>  <code>ss</code>有效值（ <code>0x1000</code> ）。 在这种情况下，我们转到标签2： </li></ul><br><pre> <code class="hljs mel"><span class="hljs-number"><span class="hljs-number">2</span></span>: andw $~<span class="hljs-number"><span class="hljs-number">3</span></span>, %dx jnz <span class="hljs-number"><span class="hljs-number">3</span></span>f movw $0xfffc, %dx <span class="hljs-number"><span class="hljs-number">3</span></span>: movw %ax, %ss movzwl %dx, %esp sti</code> </pre> <br> 在这里，我们将<code>dx</code>寄存器（其中包含引导加载程序指示的<code>sp</code>值）的对齐方式设置为<code>4</code>个字节，并检查是否为零。 如果为零，则我们将值<code>0xfffc</code> <code>dx</code> （最大段大小为64 KB之前的<code>4</code>字节对齐地址）放入。 如果不等于零，那么我们将继续使用引导加载程序指定的<code>sp</code>值（在本例中为<code>0xf7f4</code> ）。 然后将<code>ax</code>值放入<code>ss</code> ，这将保存正确的段地址<code>0x1000</code>并设置正确的<code>sp</code> 。 现在我们有了正确的堆栈： <br><br><img src="https://habrastorage.org/webt/wf/dp/bl/wfdpblqpiltzdrprytvnoj3kygo.png"><br><br><ul><li> 在第二种情况下， <code>ss != ds</code> 。 首先，我们将值<a href="">_end</a> （安装代码末尾的地址）放在<code>dx</code>并使用<code>testb</code>指令检查报头字段<code>loadflags</code> ，以检查是否可以使用堆。  <a href="">loadflags</a>是一个位掩码标头，定义如下： </li></ul><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LOADED_HIGH (1&lt;&lt;0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QUIET_FLAG (1&lt;&lt;5) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KEEP_SEGMENTS (1&lt;&lt;6) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CAN_USE_HEAP (1&lt;&lt;7)</span></span></code> </pre> <br> 并按照启动协议中的指示： <br><br> <code> : loadflags <br> <br>     . <br> <br>  7 (): CAN_USE_HEAP <br>     1,  ,   <br> heap_end_ptr .    ,   <br>   .</code> <br> <br> 如果将<code>CAN_USE_HEAP</code>位置1，则在<code>dx</code>我们设置值<code>heap_end_ptr</code> （指向<code>_end</code> ）并向其添加<code>STACK_SIZE</code> （最小堆栈大小为<code>1024</code>字节）。 之后，转到标签<code>2</code> （与前面的情况一样）并进行正确的堆叠。 <br><br><img src="https://habrastorage.org/webt/1n/be/nw/1nbenww3ncnipvbi1g-jqdvsmok.png"><br><br><ul><li> 如果未设置<code>CAN_USE_HEAP</code>使用从<code>_end</code>到<code>_end + STACK_SIZE</code>的最小堆栈： </li></ul><br><img src="https://habrastorage.org/webt/5x/xg/fi/5xxgfikk1iskr_6pgjzvmcwhpjy.png"><br><br><h1>  BSS设置 </h1><br> 在继续使用主要的C代码之前，还需要执行两个步骤：这是设置<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BSS区域</a>并验证“魔术”签名。 首先进行签名验证： <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">cmpl</span></span> <span class="hljs-variable"><span class="hljs-variable">$0</span></span>x5a5aaa55, setup_sig jne setup_bad</code> </pre> <br> 该指令只是将<a href="">setup_sig</a>与幻数0x5a5aaa55进行比较。 如果它们不相等，则会报告致命错误。 <br><br> 如果幻数匹配，并且我们有一组正确的段寄存器和堆栈，那么剩下的就是在进行C代码之前配置BSS部分。 <br><br>  BSS部分用于存储静态分配的未初始化数据。  Linux仔细检查此存储区是否已重置： <br><br><pre> <code class="hljs perl"> movw $__bss_start, %di movw $_end+<span class="hljs-number"><span class="hljs-number">3</span></span>, %cx xorl %eax, %eax subw %di, %cx shrw $2, %cx rep; stosl</code> </pre> <br> 首先， <a href="">__ bss_start</a>的起始地址移至<code>di</code> 。 然后，地址<code>_end + 3</code> （用于对齐4字节的+3）被移至<code>cx</code> 。 清除<code>eax</code>寄存器（使用<code>xor</code>指令），计算bss分区的大小（ <code>cx-di</code> ），并将其放置在<code>cx</code> 。 然后，将<code>cx</code>分为四部分（“字”的大小），并<code>stosl</code>使用<code>stosl</code>指令，将值<code></code> （零）存储在指向<code>di</code>的地址中，自动将<code>di</code>增加4，并重复此操作直到<code></code>达到零为止。 这段代码的最终结果是，从<code>__bss_start</code>到<code>_end</code>将零写入内存中的所有单词： <br><br><img src="https://habrastorage.org/webt/2s/bw/ym/2sbwymhai1qislpkru0btkrolcy.png"><br><br><h1> 前往主要 </h1><br> 就是这样：我们有一个堆栈和BSS，因此您可以转到<code>main()</code> C函数： <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">calll</span></span> main</code> </pre> <br>  <code>main()</code>函数位于<a href="">arch / x86 / boot / main.c中。</a> 下一部分我们将讨论她。 <br><br><h1> 结论 </h1><br> 这是有关Linux内核设备的第一部分的结尾。       ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> ,  <a href=""></a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> .         C,      Linux,   ,   <code>memset</code> , <code>memcpy</code> , <code>earlyprintk</code> ,        . <br><br><h1> 参考文献 </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Intel 80386,  , 1986 .</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">    Intel</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8086</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">80386</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   Linux</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Coreboot,  </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> «  »</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN428664/">https://habr.com/ru/post/zh-CN428664/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN428654/index.html">麻省理工学院的课程“计算机系统安全”。 第15课：医疗软件，第2部分</a></li>
<li><a href="../zh-CN428656/index.html">麻省理工学院的课程“计算机系统安全”。 第15课：医疗软件，第3部分</a></li>
<li><a href="../zh-CN428658/index.html">Mail.Ru集团办公室的免费教育研讨会</a></li>
<li><a href="../zh-CN428660/index.html">在VSTS中启用可扩展的请求请求策略以支持开发过程</a></li>
<li><a href="../zh-CN428662/index.html">零售编程任务</a></li>
<li><a href="../zh-CN428666/index.html">我如何使用CSS蒙版创建改变心情的动画</a></li>
<li><a href="../zh-CN428668/index.html">暴雪宣布将于2019年发布《魔兽争霸III》的重新发行。 公开预订</a></li>
<li><a href="../zh-CN428672/index.html">QuietOn主动静噪概述</a></li>
<li><a href="../zh-CN428674/index.html">在Profi.ru上构建客户端路由/语义搜索</a></li>
<li><a href="../zh-CN428676/index.html">打破C＃的基础：在堆栈上为引用类型分配内存</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>