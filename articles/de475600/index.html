<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîî üêí üë´ Wie wir Prometheus verbunden haben üìî üòÑ üßìüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Irgendwie musste ich mich wie immer mit den Metriken f√ºr unsere API auseinandersetzen (keine Zeit?!), Um sie sp√§ter hinzuzuf√ºgen - es ist sehr schwier...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir Prometheus verbunden haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475600/"><p> Irgendwie musste ich mich wie immer mit den Metriken f√ºr unsere API auseinandersetzen (keine Zeit?!), Um sie sp√§ter hinzuzuf√ºgen - es ist sehr schwierig und noch nicht implementiert - es bedeutet, dass es Zeit ist, sie zu implementieren.  Nach einigen Streifz√ºgen im Netz schien mir Prometheus das beliebteste √úberwachungssystem zu sein. </p><br><p>  Mit Prometheus k√∂nnen wir verschiedene Computerressourcen √ºberwachen, z. B. Speicher, Prozessor, Festplatte und Netzwerklast.  Es kann f√ºr uns auch wichtig sein, die Anzahl der Aufrufe der Methoden unserer API zu berechnen oder die Ausf√ºhrungszeit zu messen, da die Ausfallzeit umso teurer ist, je h√∂her die Systemlast ist.  Und hier kommt uns Prometheus zu Hilfe.  Dieser Artikel enth√§lt meines Erachtens die wichtigsten Punkte f√ºr das Verst√§ndnis der Arbeit von Prometheus und f√ºr das Hinzuf√ºgen einer Sammlung von Metriken zur API.  Daher beginnen wir mit der banalsten, mit einer kleinen Beschreibung. </p><a name="habracut"></a><br><p>  Prometheus ist ein Open-Source-System und ein in Go geschriebenes und von SoundCloud entwickeltes Zeitreihen-DBMS.  Es hat offizielle Dokumentation und Unterst√ºtzung f√ºr Sprachen wie: Go, Java oder Scala, Python, Ruby.  Es gibt inoffizielle Unterst√ºtzung f√ºr andere Sprachen wie C #, C ++, C, Bash, Lua f√ºr Nginx, Lua f√ºr Tarantool und andere. Die gesamte Liste befindet sich auf der offiziellen Prometheus-Website. </p><br><p>  Alle Prometheus-Dienste sind als Docker-Images auf dem Docker Hub oder Quay.io verf√ºgbar. </p><br><p> Prometheus wird mit dem <code>docker run -p 9090:9090 prom/prometheus</code> gestartet, der es mit der Standardkonfiguration startet und den Port <code>localhost:9090</code> daf√ºr festlegt. Danach ist die Prometheus-Benutzeroberfl√§che unter <code>localhost:9090</code> verf√ºgbar. </p><br><p>  Prometheus ist ein √úberwachungssystem, das verschiedene Tools zur Konfiguration der √úberwachung von Anwendungen (Endpunkten) mithilfe des HTTP-Protokolls enth√§lt.  Beim Herstellen einer Verbindung zu Prometheus unterst√ºtzt die HTTP-API die "Basisauthentifizierung" nicht.  Wenn Sie die Basisauthentifizierung f√ºr die Verbindung mit Prometheus verwenden m√∂chten, wird empfohlen, Prometheus in Verbindung mit einem Reverse-Proxy-Server zu verwenden und die Authentifizierung auf Proxy-Ebene zu verwenden.  Sie k√∂nnen mit Prometheus jeden Reverse-Proxy verwenden. </p><br><p>  <strong><em>Die Hauptkomponenten von Prometheus:</em></strong> </p><br><ul><li>  ein Server, der Metriken sammelt, in der Datenbank speichert und bereinigt; </li><li>  Pakete zum Sammeln von Metriken in der API; </li><li>  Pushgateway - Komponente zum Empfangen von Metriken aus Anwendungen, f√ºr die eine Pull-Anforderung nicht verwendet werden kann. </li><li>  Exporter - Tools zum Exportieren von Metriken aus Anwendungen und Diensten von Drittanbietern, die auf Zielcomputern installiert sind. </li><li>  AlertManager - Benachrichtigungsmanager (Warnungen). Warnungen werden in der Konfigurationsdatei definiert und durch eine Reihe von Regeln f√ºr Metriken festgelegt. <br>  Wenn w√§hrend des Betriebs die Regel eingehalten wird, wird ein Alarm ausgel√∂st und per E-Mail, Slack oder anderen an die angegebenen Empf√§nger gesendet. </li></ul><br><p>  Die Objekte, mit denen Prometheus arbeitet, werden Metriken genannt, die von Zielen entweder √ºber Pushgateway oder √ºber Exporteure empfangen werden. </p><br><p>  <strong><em>Beim Sammeln von Metriken werden verschiedene Methoden zum √úbertragen von Metriken verwendet:</em></strong> </p><br><ul><li>  Prometheus fordert Metriken vom Ziel √ºber eine Pull-Anforderung an, deren Einstellungen in der Konfigurationsdatei im Abschnitt scrape_config f√ºr jeden Job angegeben sind. <br>  Wenn das System Daten erfasst, k√∂nnen Sie die H√§ufigkeit der Erfassung steuern und verschiedene Konfigurationen der Datenerfassung erstellen, um eine unterschiedliche H√§ufigkeit f√ºr verschiedene Objekte auszuw√§hlen. </li><li>  Mit Exportern k√∂nnen Sie Metriken von verschiedenen Objekten sammeln, z. B. von Datenbanken (MongoDB, SQL usw.), Nachrichtenbrokern (RabbitMQ, EMQ, NSQ usw.), HTTP - Load - Balancern usw .; </li><li>  Pushgateway.  Es kann bei Bedarf verwendet werden, wenn die Anwendung Prometheus keine direkten Metriken zur Verf√ºgung stellen kann.  oder wenn Sie Stapeljobs verwenden, die die Prometheus-Pull-Anforderung nicht verwenden k√∂nnen. </li></ul><br><p>  Somit werden alle empfangenen Metriken von Prometheus in einer Datenbank mit Zeitstempeln gespeichert. </p><br><p>  <strong><strong>Konfiguration</strong></strong> </p><br><p>  Prometheus wird mithilfe der Befehlszeilenflags und Konfigurationsdateien im YAML-Format konfiguriert.  Mit Befehlszeilen-Flags k√∂nnen Sie unver√§nderliche Parameter konfigurieren, z. B. Pfade, auf der Festplatte und im Speicher gespeicherte Datenmengen usw.  In der Konfigurationsdatei k√∂nnen Sie alles konfigurieren, was mit Jobs zu tun hat, und geladene Regel-Yaml-Dateien einrichten.  Alles ist in der globalen Konfigurationsdatei geschrieben. Sie k√∂nnen allgemeine Einstellungen f√ºr alle Benutzer vornehmen und Einstellungen f√ºr verschiedene Konfigurationsabschnitte separat markieren.  Die Einstellungen, die Prometheus abruft, werden in der Konfigurationsdatei im Abschnitt scrape_configs konfiguriert. </p><br><p>  Prometheus kann Konfigurationsdateien w√§hrend des Betriebs neu laden. Wenn die neue Konfiguration ung√ºltig ist, wird sie nicht angewendet.  Der Neustart der Konfigurationsdatei wird durch Senden des Befehls SIGHUP Prometheus oder Senden der HTTP-POST-Anforderung an <code>/-/reload</code> <code>--web.enable-lifecycle</code> , sofern das <code>--web.enable-lifecycle</code> .  Es werden auch alle konfigurierten Regeldateien neu geladen. </p><br><p>  <strong><strong>Welche Arten von Daten werden verwendet?</strong></strong> </p><br><p>  Prometheus speichert ein benutzerdefiniertes mehrdimensionales Datenmodell und verwendet eine Abfragesprache f√ºr mehrdimensionale Daten namens PromQL.  Prometheus speichert Daten in Form von Zeitreihen und unterst√ºtzt verschiedene Speicherm√∂glichkeiten: </p><br><ul><li>  lokaler festplattenspeicher: Alle 2 Stunden werden Daten, die im Speicher zwischengespeichert wurden, komprimiert und auf der Festplatte gespeichert.  Standardm√§√üig wird das Verzeichnis ./data im Arbeitsverzeichnis zum Speichern komprimierter Dateien verwendet. </li><li>  Remote-Repository: Prometheus unterst√ºtzt die Integration in Repositorys von Drittanbietern (z. B. Kafka, PostgreSQL, Amazon S3 usw.) √ºber den Protocol Buffer-Adapter. </li></ul><br><p>  Die gespeicherte Zeitreihe wird durch die Metrik und die Metadaten in Form von Schl√ºssel-Wert-Paaren bestimmt, obwohl der Name der Metrik gegebenenfalls nicht verwendet werden kann und die Metrik selbst nur aus Metadaten besteht.  Eine Zeitreihe kann formal als &lt;Metrikname&gt; {&lt;Metadaten&gt;} definiert werden.  <strong><em>Der Schl√ºssel</em></strong> ist &lt;metrischer Name&gt; {&lt;Metadaten&gt;} - das, was wir messen, und der <strong><em>Wert</em></strong> ist der tats√§chliche Wert als Zahl mit dem Typ float64 (Prometheus unterst√ºtzt nur diesen Typ).  Die Schl√ºsselbeschreibung enth√§lt Metadaten (Labels), die auch durch Schl√ºssel-Wert-Paare beschrieben werden: &lt;Label-Name&gt; = "&lt;Label-Wert&gt;", &lt;Label-Name&gt; = "&lt;Label-Wert&gt;", ... </p><br><p>  <strong>Beim Speichern von Metriken werden die folgenden Datentypen verwendet:</strong> </p><br><ul><li>  <strong><em>Z√§hler</em></strong> - Z√§hlt den Betrag √ºber einen bestimmten Zeitraum.  Diese Art von Metriken kann nur erh√∂ht werden (Sie k√∂nnen keine negativen Werte verwenden) oder den Wert zur√ºcksetzen. <br>  Es kann zum Beispiel zum Z√§hlen der Anzahl von Anfragen pro Minute oder der Anzahl von Fehlern pro Tag, der Anzahl von gesendeten / empfangenen Netzwerkpaketen usw. geeignet sein. </li><li>  <strong><em>Messger√§t</em></strong> - speichert Werte, die mit der Zeit abnehmen oder zunehmen k√∂nnen. <br>  Das Messger√§t zeigt nicht die Entwicklung von Metriken √ºber einen bestimmten Zeitraum an.  Mit Gauge k√∂nnen Sie mit der Zeit unregelm√§√üige metrische √Ñnderungen verlieren. </li><li>  <strong><em>Histogramm</em></strong> - speichert mehrere Zeitreihen: die Gesamtsumme aller beobachteten Werte;  die Anzahl der beobachteten Ereignisse; <br>  Akkumulationsz√§hler (Eimer) - werden auf dem Etikett als <code>le="&lt;upper inclusive bound&gt;"</code> . <br>  Werte werden in Bereichen mit benutzerdefinierten Obergrenzen (Buckets) erfasst. </li><li>  <strong><em>Zusammenfassung</em></strong> - speichert mehrere Zeitreihen: die Gesamtsumme aller beobachteten Werte;  die Anzahl der beobachteten Ereignisse; <br>  Fluss œÜ-Quantile (0 ‚â§ œÜ ‚â§ 1) von beobachteten Ereignissen - werden auf dem Etikett als <code>quantile="&lt;œÜ&gt;"</code> . </li></ul><br><p>  <strong><strong>Wie werden Daten gespeichert?</strong></strong> </p><br><p>  Prometheus empfiehlt, einer laufenden Anwendung 2/3 des Arbeitsspeichers zuzuweisen. <br>  Prometheus verwendet zum Speichern von Daten Chunk-Dateien, wobei jede Metrik eine eigene Datei hat.  Alle Chunk-Dateien sind unver√§nderlich, mit Ausnahme der letzten, in die Daten geschrieben werden.  Neue Daten werden im Chunk gespeichert und alle 2 Stunden werden die Daten vom Hintergrundstream kombiniert und auf die Festplatte geschrieben.  Jeder zweist√ºndige Block besteht aus einem Verzeichnis mit einer oder mehreren Chunk-Dateien, die alle Zeitreihenbeispiele f√ºr diesen Zeitraum enthalten, sowie einer Metadatendatei und einer Indexdatei (die die Namen der Metriken und Bezeichnungen f√ºr Zeitreihen in den Chunk-Dateien indiziert).  Wenn Prometheus innerhalb einer Stunde keine Daten in Chunck schreibt, werden diese auf der Festplatte gespeichert und es wird ein neuer Chunck zum Schreiben von Daten erstellt.  Die maximale Datenaufbewahrungsdauer in Prometheus betr√§gt ~ 21 Tage. </p><br><p>  Weil  Wenn die Gr√∂√üe des Speichers festgelegt ist, wird die Schreib- und Leseleistung des Systems durch diese Speicherkapazit√§t begrenzt.  Die Gr√∂√üe des PTSDB-Speichers wird durch den Mindestzeitraum, den Erfassungszeitraum und die Anzahl der Zeitmetriken bestimmt. </p><br><p>  Prometheus hat auch einen WAL-Mechanismus, um Datenverlust zu verhindern. </p><br><p>  <strong><em>Write Ahead Log (WAL)</em></strong> serialisiert gespeicherte Vorg√§nge auf einem permanenten Medium in Form von Protokolldateien.  Im Falle eines Fehlers k√∂nnen WAL-Dateien verwendet werden, um die Datenbank durch Wiederherstellen aus Protokollen in ihren konsistenten Zustand zur√ºckzusetzen. </p><br><p>  Protokolldateien werden in einem Verzeichnis mit 128 MB gespeichert.  Diese Dateien enthalten Rohdaten, die noch nicht komprimiert wurden. Sie sind daher erheblich gr√∂√üer als normale Fragmentdateien. </p><br><p>  Prometheus speichert mindestens 3 Protokolldateien, Server mit hohem Datenverkehr k√∂nnen jedoch mehr als drei WAL-Dateien anzeigen, da mindestens zwei Stunden Rohdaten gespeichert werden m√ºssen. </p><br><p>  Das Ergebnis der Verwendung von WAL ist eine signifikante Reduzierung der Anzahl der Schreibanforderungen auf die Festplatte  Es muss nur eine Protokolldatei auf die Festplatte geschrieben werden, und nicht alle Daten, die infolge des Vorgangs ge√§ndert wurden.  Die Protokolldatei wird sequentiell geschrieben, und daher sind die Kosten f√ºr die Synchronisierung des Protokolls viel geringer als die Kosten f√ºr das Schreiben von Fragmenten mit Daten. </p><br><p>  Prometheus speichert regelm√§√üige Haltepunkte, die standardm√§√üig alle 2 Stunden hinzugef√ºgt werden, indem Protokolle f√ºr den letzten Zeitraum komprimiert und auf der Festplatte gespeichert werden. </p><br><p>  Alle Haltepunkte werden im selben Verzeichnis wie checkpoint.ddd gespeichert, wobei ddd eine monoton ansteigende Zahl ist.  Bei der Wiederherstellung nach einem Fehler k√∂nnen daher Haltepunkte aus dem Haltepunktkatalog mit Angabe der Reihenfolge (.ddd) wiederhergestellt werden. <br>  Durch das Schreiben von WAL-Protokollen k√∂nnen Sie zu jedem Pr√ºfpunkt zur√ºckkehren, f√ºr den das Datenprotokoll verf√ºgbar ist. </p><br><p>  <strong><strong>Was ist in der Praxis passiert?</strong></strong> </p><br><p>  Beim Hinzuf√ºgen zum Projekt (.Net Framework) haben wir das Prometheus.Client.3.0.2-Paket zum Sammeln von Metriken verwendet.  Um Metriken zu sammeln, wurden die erforderlichen Methoden und Klassen zum Projekt hinzugef√ºgt, um Metriken zu speichern, bis sie von Prometheus empfangen werden. </p><br><p>  Urspr√ºnglich wurde eine IMetricsService-Schnittstelle definiert, die Timer-Methoden zum Messen der Funktionsdauer von Methoden enthielt: </p><br><pre> <code class="plaintext hljs">public interface IMetricsService { Stopwatch StartTimer(); void StopTimer(Stopwatch timer, string controllerName, string actionName, string methodName = "POST"); }</code> </pre> <br><p>  Wir f√ºgen die MetricsService-Klasse hinzu, die die IMetricsService-Schnittstelle implementiert und Metriken tempor√§r speichert. </p><br><pre> <code class="plaintext hljs">public class MetricsService : IMetricsService { private static Histogram _histogram; static MetricsService() { _histogram = CreateHistogram(); } public Stopwatch StartTimer() { try { var timer = new Stopwatch(); timer.Start(); return timer; } catch (Exception exception) { Logger.Error(exception); } return null; } public void StopTimer(Stopwatch timer, string controllerName, string actionName, string methodName = "POST") { try { if (timer == null) { throw new ArgumentException($"{nameof(timer)} can't be null."); } timer.Stop(); _histogram .WithLabels(controllerName, actionName, methodName) .Observe(timer.ElapsedMilliseconds, DateTimeOffset.UtcNow); } catch (Exception exception) { Logger.Error(exception); } } public static List&lt;string&gt; GetAllLabels() { var metricsList = new List&lt;string&gt;(); try { foreach (var keyValuePair in _histogram.Labelled) { var controllerName = keyValuePair.Key.Labels[0].Value; var actionName = keyValuePair.Key.Labels[1].Value; var methodName = keyValuePair.Key.Labels[2].Value; var requestDurationSum = keyValuePair.Value.Value.Sum; var requestCount = keyValuePair.Value.Value.Count; metricsList.Add($"http_request_duration_widget_sum{{controller={controllerName},action={actionName},method={methodName}}} {requestDurationSum}"); metricsList.Add($"http_request_duration_widget_count{{controller={controllerName},action={actionName},method={methodName}}} {requestCount}"); } _histogram = CreateHistogram(); } catch (Exception exception) { Logger.Error(exception); } return metricsList; } private static Histogram CreateHistogram() { var newMetrics = Metrics .WithCustomRegistry(new CollectorRegistry()) .CreateHistogram(name: "http_request_duration_web_api", help: "Histogram metrics of Web.Api", includeTimestamp: true, labelNames: new[] { "controller", "action", "method" }); var oldValue = _histogram; for (var i = 0; i &lt; 10; i++) { var oldValue = Interlocked.Exchange&lt;Histogram&gt;(ref oldValue, newMetrics); if (oldValue != null) { return oldValue; } } return null; } }</code> </pre> <br><p>  Jetzt k√∂nnen wir unsere Klasse verwenden, um die zu sammelnden Metriken in den Methoden Application_BeginRequest, Application_Error, Application_EndRequest zu speichern.  In der Global.cs-Klasse f√ºgen wir den obigen Methoden eine Sammlung von Metriken hinzu. </p><br><pre> <code class="plaintext hljs">private IMetricsService _metricsService; protected virtual void Application_BeginRequest(object sender, EventArgs e) { var context = new HttpContextWrapper(HttpContext.Current); var metricServiceTimer = _metricsService.StartTimer(); context.Items.Add("metricsService", _metricsService); context.Items.Add("metricServiceTimer", metricServiceTimer); } protected virtual void Application_EndRequest(object sender, EventArgs e) { WriteMetrics(new HttpContextWrapper(HttpContext.Current)); } protected void Application_Error(object sender, EventArgs e) { WriteMetrics(new HttpContextWrapper(HttpContext.Current)); } private void WriteMetrics(HttpContextBase context) { try { _metricsService = context.Items["metricsService"] as IMetricsService; if (_metricsService != null) { var timer = context.Items["metricServiceTimer"] as Stopwatch; string controllerName = null; string actionName = null; var rd = RouteTable.Routes.GetRouteData(context); if (rd != null) { controllerName = rd.GetRequiredString("controller"); actionName = rd.GetRequiredString("action"); } _metricsService.StopTimer(timer, controllerName, actionName, context.Request.HttpMethod); } } catch (Exception exception) { Logger.Error("Can't write metrics.", exception); } }</code> </pre><br><p>  F√ºgen Sie einen neuen Controller hinzu, der als Referenzpunkt f√ºr das Senden der Messdaten unserer API an Prometheus dient: </p><br><pre> <code class="plaintext hljs">public class MetricsController : Controller { [HttpGet] public string[] GetAllMetrics() { try { var metrics = MetricsService.GetAllLabels(); return metrics.ToArray(); } catch (Exception exception) { Logger.Error(exception); } return new string[] { }; } }</code> </pre> <br><p>  Der letzte Schritt besteht darin, die Prometheus-Konfiguration so zu konfigurieren, dass Metriken im Abschnitt scrape_configs erfasst werden. Danach k√∂nnen wir die erfassten Metriken bereits in der Prometheus- oder Grafana-Benutzeroberfl√§che anzeigen. </p><br><p>  <strong><strong>Wichtige Features, an denen wir bei Prometheus interessiert waren:</strong></strong> </p><br><p>  Mehrdimensionales Datenmodell: Metriken und Beschriftungen. <br>  Flexible PromQL-Abfragesprache.  In demselben Abfrageoperator k√∂nnen Operationen wie Multiplikation, Addition, Verkettung usw. Verwendet werden.  kann mit mehreren Metriken durchgef√ºhrt werden. <br>  Sammelt HTTP-basierte Daten mithilfe der Pull-Methode. <br>  Kompatibel mit der Push-Methode √ºber Pushgateway. <br>  Es ist m√∂glich, Metriken aus anderen Anwendungen √ºber Exporteure zu erfassen. <br>  Bietet einen Mechanismus zum Verhindern von Datenverlust. <br>  Unterst√ºtzt verschiedene grafische Darstellungen von Daten. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475600/">https://habr.com/ru/post/de475600/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475588/index.html">Drei Paradigmen</a></li>
<li><a href="../de475590/index.html">Kompilieren von Programmen mit Notepad ++</a></li>
<li><a href="../de475594/index.html">Unterhaltsames JavaScript: Eine fast lineare Gleichung</a></li>
<li><a href="../de475596/index.html">Hypothesen f√ºr gro√üe Primzahlen haben sich f√ºr kleine Zahlensysteme bew√§hrt</a></li>
<li><a href="../de475598/index.html">Organisation einer einfachen Architektur in einer Android-Anwendung mit einer Reihe von ViewModel + LiveData, Retrofit + Coroutines</a></li>
<li><a href="../de475604/index.html">Konfigurieren der offiziellen PostgreSQL-Vorlage unter Zabbix 4.4</a></li>
<li><a href="../de475608/index.html">Google Tag Manager: Unscheinbare und n√ºtzliche Trigger-Einstellungen</a></li>
<li><a href="../de475610/index.html">Sichere LED-Tischleuchten, die die Sicht behalten</a></li>
<li><a href="../de475612/index.html">Vorausgesetzt, wann, Behauptungen und Vertrauen in die Umsetzung</a></li>
<li><a href="../de475614/index.html">Automatisierung f√ºr die Kleinsten. Zweiter Teil. Netzwerkdesign</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>