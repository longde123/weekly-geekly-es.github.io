<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘‡ ğŸ§“ğŸ½ ğŸ‘©ğŸ¾â€âš–ï¸ Optimasi penanganan acara di Angular ğŸ‘ª ğŸš­ â¹ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Angular menyediakan cara deklaratif yang mudah untuk berlangganan acara dalam templat menggunakan sintaks (eventName)="onEventName($ev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimasi penanganan acara di Angular</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/429692/"><h1 id="vvedenie">  Pendahuluan </h1><br><p> Angular menyediakan cara deklaratif yang mudah untuk berlangganan acara dalam templat menggunakan sintaks <code>(eventName)="onEventName($event)"</code> .  Bersama dengan kebijakan pemeriksaan perubahan <code>ChangeDetectionStrategy.OnPush</code> , pendekatan ini secara otomatis memulai siklus pemeriksaan perubahan hanya untuk input pengguna yang menarik minat kami.  Dengan kata lain, jika kita mendengarkan acara <code>(input)</code> pada elemen <code>&lt;input&gt;</code> , maka pemeriksaan perubahan tidak akan dipicu jika pengguna cukup mengklik bidang input.  Ini sangat meningkat <br>  kinerja dibandingkan dengan kebijakan default ( <code>ChangeDetectionStrategy.Default</code> ).  Dalam arahan, kami juga dapat berlangganan acara pada elemen host melalui <code>@HostListener('eventName')</code> . </p><br><p>  Dalam praktik saya, sering ada kasus di mana pemrosesan peristiwa tertentu diperlukan hanya jika suatu kondisi terpenuhi.  yaitu  pawang terlihat seperti ini: </p><a name="habracut"></a><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentWithEventHandler</span></span></span><span class="hljs-class"> { // ... onEvent(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">) { if (!</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">condition</span></span></span><span class="hljs-class">) { return; } // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Handling</span></span></span><span class="hljs-class"> event ... } }</span></span></code> </pre> <br><p>  Bahkan jika kondisi tidak terpenuhi dan tidak ada tindakan yang sebenarnya terjadi, siklus verifikasi perubahan masih akan dimulai.  Dalam hal acara sering, seperti <code>scroll</code> atau <code>mousemove</code> , ini dapat mempengaruhi kinerja aplikasi. </p><br><p>  Di pustaka UI komponen yang sedang saya kerjakan, berlangganan <code>mousemove</code> di dalam menu drop-down memicu penghitungan ulang seluruh komponen pohon untuk setiap gerakan mouse.  Itu perlu untuk memantau mouse untuk menerapkan perilaku menu yang benar, tetapi jelas layak dioptimalkan.  Lebih lanjut tentang ini di bawah ini. </p><br><p>  Momen seperti itu sangat penting untuk elemen UI universal.  Mungkin ada banyak dari mereka di halaman, dan aplikasi bisa sangat kompleks dan menuntut kinerja. </p><br><p>  Anda dapat memperbaiki situasi dengan berlangganan acara yang melewati <code>ngZone</code> , misalnya, menggunakan <code>Observable.fromEvent</code> dan mulai memeriksa perubahan secara manual dengan memanggil <code>changeDetectorRef.markForCheck()</code> .  Namun, ini menambah satu ton pekerjaan tambahan dan membuatnya tidak mungkin untuk menggunakan alat Angular bawaan yang nyaman. </p><br><p>  Bukan rahasia lagi bahwa Angular memungkinkan Anda untuk berlangganan apa yang disebut pseudo-events, menentukan dengan tepat peristiwa yang kami minati.  Kita dapat menulis <code>(keydown.enter)="onEnter($event)"</code> dan handler (dan dengan itu siklus pemeriksaan perubahan) akan dipanggil hanya ketika tombol <code>Enter</code> ditekan. Penekanan yang tersisa akan diabaikan.  Pada artikel ini, kita akan melihat bagaimana Anda dapat menggunakan pendekatan yang sama seperti Angular untuk mengoptimalkan penanganan acara.  Dan sebagai bonus, tambahkan <code>.prevent</code> dan <code>.stop</code> , yang akan membatalkan perilaku default dan menghentikan acara agar tidak <code>.stop</code> secara otomatis. </p><br><h1 id="eventmanagerplugin">  EventManagerPlugin </h1><br><div style="text-align:center;"><img width="600" height="600" src="https://habrastorage.org/webt/ss/vr/ls/ssvrlsnebhii2-bcfct4kcmvllu.jpeg"></div><br><p>  Angular menggunakan kelas <code>EventManager</code> untuk menangani acara.  Ini memiliki satu set yang disebut plugins yang memperpanjang <code>EventManagerPlugin</code> abstrak dan mendelegasikan pemrosesan berlangganan acara ke plugin yang mendukung acara ini (dengan nama).  Ada beberapa plugin di dalam Angular, termasuk penanganan event HammerJS dan sebuah plugin yang bertanggung jawab untuk acara komposit seperti <code>keydown.enter</code> .  Ini adalah implementasi internal Angular, dan pendekatan ini dapat berubah.  Namun, 3 tahun telah berlalu sejak penciptaan masalah pada pemrosesan solusi ini, dan tidak ada kemajuan yang telah dibuat dalam arah ini: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/angular/angular/issues/3929</a> </p><br><p>  Apa yang menarik dalam hal ini bagi kita?  Terlepas dari kenyataan bahwa kelas-kelas ini bersifat internal dan tidak dapat diwarisi dari mereka, token yang bertanggung jawab untuk menerapkan dependensi untuk plugin bersifat publik.  Ini artinya kita dapat menulis plugin sendiri dan memperluas mekanisme penanganan kejadian bawaan. </p><br><p>  Jika Anda melihat kode sumber <code>EventManagerPlugin</code> , Anda akan melihat bahwa kami tidak akan dapat mewarisinya, sebagian besar bersifat abstrak dan mudah untuk mengimplementasikan kelas kami sendiri yang memenuhi persyaratan: </p><br><p>  <a href="">https://github.com/angular/angular/blob/master/packages/platform-browser/src/dom/events/event_manager.ts#L92</a> </p><br><p>  Secara kasar, plugin harus dapat menentukan apakah itu berfungsi dengan acara ini dan harus dapat menambahkan pengendali acara dan penangan global (pada <code>body</code> , <code>window</code> dan <code>document</code> ).  Kami akan tertarik pada pengubah <code>.prevent</code> , <code>.prevent</code> dan <code>.stop</code> .  Untuk mengikat mereka ke plugin kami, kami menerapkan metode yang diperlukan <code>supports</code> : </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FILTER = <span class="hljs-string"><span class="hljs-string">'.filter'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PREVENT = <span class="hljs-string"><span class="hljs-string">'.prevent'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> STOP = <span class="hljs-string"><span class="hljs-string">'.stop'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FilteredEventPlugin</span></span> { supports(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>): boolean { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.includes(FILTER) || <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.includes(PREVENT) || <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.includes(STOP) ); } }</code> </pre> <br><p>  Jadi <code>EventManager</code> akan memahami bahwa peristiwa atas nama yang ada pengubah tertentu harus diteruskan ke plugin kami untuk diproses.  Maka kita perlu menerapkan penambahan event handler.  Kami tidak tertarik dengan penangan global, dalam hal mereka kebutuhan akan alat semacam itu jauh lebih jarang, dan implementasinya akan lebih rumit.  Oleh karena itu, kami cukup menghapus pengubah kami dari nama acara dan mengembalikannya ke <code>EventManager</code> sehingga <code>EventManager</code> yang benar untuk diproses: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FilteredEventPlugin</span></span></span><span class="hljs-class"> { supports(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">): boolean { // ... } addGlobalEventListener( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eventName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Function</span></span></span><span class="hljs-class">, ): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Function</span></span></span><span class="hljs-class"> { const event = eventName .replace(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FILTER</span></span></span><span class="hljs-class">, '') .replace(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PREVENT</span></span></span><span class="hljs-class">, '') .replace(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STOP</span></span></span><span class="hljs-class">, ''); return this.manager.addGlobalEventListener(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class">); } }</span></span></code> </pre> <br><p>  Dalam hal suatu peristiwa pada elemen reguler, kita perlu menulis logika kita sendiri.  Untuk melakukan ini, kami membungkus pawang dalam penutupan dan meneruskan acara tanpa pengubah kami kembali ke <code>EventManager</code> , menyebutnya di luar <code>ngZone</code> , untuk menghindari memulai siklus pemeriksaan perubahan: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FilteredEventPlugin</span></span></span><span class="hljs-class"> { supports(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">): boolean { // ... } addEventListener( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HTMLElement</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eventName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Function</span></span></span><span class="hljs-class">, ): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Function</span></span></span><span class="hljs-class"> { const event = eventName .replace(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FILTER</span></span></span><span class="hljs-class">, '') .replace(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PREVENT</span></span></span><span class="hljs-class">, '') .replace(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STOP</span></span></span><span class="hljs-class">, ''); //     const filtered = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">) =&gt; { // ... }; const wrapper = () =&gt; this.manager.addEventListener(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filtered</span></span></span><span class="hljs-class">); return this.manager.getZone().runOutsideAngular(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wrapper</span></span></span><span class="hljs-class">); } /* addGlobalEventListener(...): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Function</span></span></span><span class="hljs-class"> { ... } */ }</span></span></code> </pre> <br><p>  Pada tahap ini, kita memiliki: nama acara, acara itu sendiri, dan elemen yang didengarkan.  Pawang yang sampai di sini bukanlah pawang yang ditugaskan untuk acara ini, tetapi akhir dari rantai penutupan yang dibuat oleh Angular untuk tujuannya sendiri. </p><br><p>  Salah satu solusinya adalah dengan menambahkan atribut ke elemen, yang bertanggung jawab untuk memanggil pawang atau tidak.  Terkadang, untuk membuat keputusan, perlu untuk menganalisis peristiwa itu sendiri: apakah tindakan default dibatalkan, elemen mana yang menjadi sumber acara, dll.  Atribut tidak cukup untuk ini, kita perlu menemukan cara untuk mengatur fungsi filter yang menerima acara dan mengembalikan <code>true</code> atau <code>false</code> .  Kemudian kita bisa menggambarkan pawang kita sebagai berikut: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filtered = (<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>: Event) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filter = getOurHandler(some_arguments); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !eventName.includes(FILTER) || !filter || filter(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (eventName.includes(PREVENT)) { <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.preventDefault(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (eventName.includes(STOP)) { <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.stopPropagation(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.manager.getZone().run(() =&gt; handler(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>)); } };</code> </pre> <br><h1 id="reshenie">  Solusi </h1><br><p>  Solusinya mungkin layanan tunggal yang menyimpan korespondensi elemen untuk pasangan peristiwa / filter dan entitas tambahan untuk mengatur korespondensi ini.  Tentu saja, pada satu elemen dapat ada beberapa penangan untuk acara yang sama, tetapi, sebagai aturan, dapat berupa <code>@HostListener</code> dan penangan yang diinstal pada komponen ini di templat satu tingkat lebih tinggi.  Kami akan meramalkan situasi ini, sementara kasus-kasus lain kurang menarik bagi kami karena kekhususannya. </p><br><p>  Layanan utama cukup sederhana dan terdiri dari peta dan beberapa metode untuk mengatur, menerima dan membersihkan filter: </p><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Filter</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">) =&gt; boolean; export </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Filters</span></span></span><span class="hljs-class"> = {[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">]: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Filter</span></span></span><span class="hljs-class">}; class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FilteredEventMainService</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">elements</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Element</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Filters</span></span></span><span class="hljs-class">&gt; = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Map</span></span></span><span class="hljs-class">(); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">register</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Element</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filters</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Filters</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">elements</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">set</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filters</span></span></span><span class="hljs-class">); } unregister(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Element</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">elements</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delete</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">); } getFilter(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Element</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Filter</span></span></span><span class="hljs-class"> | null { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">map</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">elements</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">map</span></span></span><span class="hljs-class"> ? </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">map</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">] || </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class">; } }</span></span></code> </pre> <br><p>  Dengan demikian, kami dapat mengimplementasikan layanan ini dalam plugin dan menerima filter dengan meneruskan elemen dan nama acara.  Untuk digunakan bersama dengan <code>@HostListener</code> kami menambahkan layanan kecil lain yang akan hidup dengan komponen dan menghapus filter yang sesuai ketika dihapus: </p><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventFiltersService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( <span class="hljs-meta"><span class="hljs-meta">@Inject(ElementRef)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly elementRef: ElementRef, <span class="hljs-meta"><span class="hljs-meta">@Inject(FilteredEventMainService)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly mainService: FilteredEventMainService, ) {} ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mainService.unregister(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement); } register(filters: Filters) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mainService.register(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement, filters); } }</code> </pre> <br><p>  Untuk menambahkan filter ke elemen, Anda dapat membuat arahan yang serupa: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventFiltersDirective</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> eventFilters(filters: Filters) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mainService.register(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement, filters); } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( <span class="hljs-meta"><span class="hljs-meta">@Inject(ElementRef)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly elementRef: ElementRef, <span class="hljs-meta"><span class="hljs-meta">@Inject(FilteredEventMainService)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly mainService: FilteredEventMainService, ) {} ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mainService.unregister(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement); } }</code> </pre> <br><p>  Jika ada layanan untuk memfilter peristiwa di dalam komponen, kami tidak akan membiarkan filter digantung melalui arahan.  Pada akhirnya, ini hampir selalu dapat dilakukan dengan hanya membungkus komponen dengan elemen yang akan mengarahkan arahan kita.  Untuk memahami bahwa suatu layanan sudah ada pada elemen ini, kami secara opsional akan mengimplementasikannya dalam arahan: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EventFiltersDirective</span></span></span><span class="hljs-class"> { // ... constructor( @</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Optional</span></span></span><span class="hljs-class">() @</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Self</span></span></span><span class="hljs-class">() @</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Inject</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FiltersService</span></span></span><span class="hljs-class">) private readonly filtersService: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FiltersService</span></span></span><span class="hljs-class"> | null, ) {} // ... }</span></span></code> </pre> <br><p>  Jika layanan ini hadir, kami akan menampilkan pesan yang menyatakan bahwa arahan tidak berlaku untuk itu: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventFiltersDirective</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> eventFilters(filters: Filters) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.eventFiltersService === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { console.warn(ALREADY_APPLIED_MESSAGE); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mainService.register(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement, filters); } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><div style="text-align:center;"><img width="324" height="500" src="https://habrastorage.org/webt/k5/qi/rd/k5qirdkshv3m4cwjfzama7topjm.jpeg"></div><br><h1 id="primenenie-na-praktike">  Aplikasi praktis </h1><br><p>  Semua kode yang dijelaskan dapat ditemukan di Stackblitz: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://stackblitz.com/edit/angular-event-filter</a> </p><br><p>  Sebagai contoh penggunaan, <code>select</code> imajiner ditampilkan di sana - komponen di dalam jendela modal - dan menu konteks dalam peran dropdown-nya.  Dalam kasus menu konteks, jika Anda memeriksa implementasi apa pun, Anda akan melihat bahwa perilaku selalu sebagai berikut: ketika Anda mengarahkan kursor ke item, fokus, ketika Anda menekan panah pada keyboard, fokus bergerak melalui item, tetapi jika Anda menggerakkan mouse, fokus kembali ke elemen. terletak di bawah penunjuk tetikus.  Tampaknya perilaku ini mudah diterapkan, namun, reaksi yang tidak perlu terhadap acara <code>mousemove</code> bisa memicu lusinan siklus pemeriksaan perubahan yang tidak berguna.  Dengan menetapkan sebagai filter centang untuk fokus elemen <code>target</code> acara, kami dapat memotong pemicu yang tidak perlu ini, hanya menyisakan yang benar-benar membawa fokus. </p><br><div style="text-align:center;"><img width="600" height="325" src="https://habrastorage.org/webt/ha/4m/1r/ha4m1rwr3suhds0xl1cdgbc1lso.gif"></div><br><p>  Juga, komponen <code>select</code> ini memiliki pemfilteran pada langganan <code>@HostListener</code> .  Ketika Anda menekan tombol <code>Esc</code> di dalam popup, itu akan menutup.  Ini harus terjadi hanya jika klik ini tidak diperlukan di beberapa komponen bersarang dan tidak diproses di dalamnya.  Dalam <code>select</code> menekan <code>Esc</code> menutup dropdown dan mengembalikan fokus ke bidang itu sendiri, tetapi jika sudah ditutup, itu seharusnya tidak mencegah acara muncul dan jendela modal menjadi ditutup nanti.  Dengan demikian, pemrosesan dapat dijelaskan oleh dekorator: </p><br><p>  <code>@HostListener('keydown.esc.filtered.stop')</code> , saat <code>@HostListener('keydown.esc.filtered.stop')</code> : <code>() =&gt; this.opened</code> . </p><br><p>  Karena <code>select</code> adalah komponen dengan beberapa elemen yang dapat fokus, pelacakan fokus umumnya dimungkinkan melalui peristiwa sembulan <code>focusout</code> .  Mereka akan terjadi dengan semua perubahan dalam fokus, termasuk yang tidak meninggalkan batas-batas komponen.  Acara ini memiliki bidang <code>relatedTarget</code> yang <code>relatedTarget</code> mana fokus bergerak.  Setelah menganalisanya, kita dapat memahami apakah akan memanggil analog acara <code>blur</code> untuk komponen kami: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SelectComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... @HostListener('focusout.filtered') onBlur() { this.opened = false; } // ... }</span></span></code> </pre> <br><p>  Filter, pada saat yang sama, terlihat seperti ini: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> focusOutFilter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{relatedTarget}: FocusEvent</span></span></span><span class="hljs-function">) =&gt;</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement.contains(relatedTarget);</code> </pre> <br><h1 id="vyvod">  Kesimpulan </h1><br><p>  Sayangnya, pemrosesan penekanan tombol majemuk di Angular masih akan dimulai di <code>NgZone</code> , yang berarti akan memeriksa perubahan.  Jika kami mau, kami tidak mungkin terpaksa menggunakan pemrosesan bawaan, tetapi perolehan kinerja akan kecil, dan ceruk di â€œdapurâ€ internal Angular dapat rusak selama peningkatan.  Oleh karena itu, kita harus meninggalkan acara komposit, atau menggunakan filter yang mirip dengan operator batas dan tidak memanggil pawang yang tidak relevan. </p><br><p>  Menarik ke dalam pemrosesan acara internal Angular adalah pekerjaan yang penuh petualangan, karena implementasi internal dapat berubah di masa depan.  Ini mengharuskan kami untuk mengikuti pembaruan, khususnya, tugas di GitHub, yang diberikan di bagian kedua artikel.  Tetapi sekarang kita dapat dengan mudah memfilter pelaksanaan penangan dan mulai memeriksa perubahan, kita sekarang memiliki kesempatan untuk menerapkan dengan <code>stopPropagation</code> metode <code>preventDefault</code> dan <code>stopPropagation</code> yang khas dari pemrosesan acara tepat saat menyatakan berlangganan.  Dari masa depan, akan lebih mudah untuk mendeklarasikan filter untuk <code>@HostListener</code> tepat di sebelahnya menggunakan dekorator.  Pada artikel berikutnya, saya berencana untuk berbicara tentang beberapa dekorator yang kami buat di rumah, dan mencoba menerapkan solusi ini. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429692/">https://habr.com/ru/post/id429692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429682/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 17: Otentikasi Pengguna, Bagian 2</a></li>
<li><a href="../id429684/index.html">Firebase Summit 2018: secara singkat tentang hal utama</a></li>
<li><a href="../id429686/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 17: "Otentikasi Pengguna", bagian 3</a></li>
<li><a href="../id429688/index.html">Cara membuat pahlawan yang akan dipercaya</a></li>
<li><a href="../id429690/index.html">Errorx - pustaka untuk bekerja dengan kesalahan di Go</a></li>
<li><a href="../id429694/index.html">Mail.Ru menyebut peringkat Yandex "tidak masuk akal" dan menuntut untuk menghapus mereknya dari sana</a></li>
<li><a href="../id429696/index.html">Laporan video dengan MOSDROID # 13 Aluminium</a></li>
<li><a href="../id429698/index.html">Cara bekerja dengan Lebedev Studio: pengalaman Tutu.ru</a></li>
<li><a href="../id429700/index.html">Definisi angka menurut telinga</a></li>
<li><a href="../id429702/index.html">Google Analytics Sinkronisasi Pixel Facebook, VK, Yandex, MyTarget</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>