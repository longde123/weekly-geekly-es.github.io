<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñüèΩ üíè üë®‚Äçüë©‚Äçüëß‚Äçüë¶ De onde v√™m os Mojibakes? Fundamentos de codifica√ß√µes üë¥üèø ü§πüèø üê≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo explora os conceitos b√°sicos por tr√°s da codifica√ß√£o de caracteres e, em seguida, mergulha nos detalhes t√©cnicos dos sistemas de codifica√ß...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>De onde v√™m os Mojibakes? Fundamentos de codifica√ß√µes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alconost/blog/480688/"><p> <a href="https://habrahabr.ru/company/alconost/blog/480688/"><img src="https://habrastorage.org/webt/6b/fx/u8/6bfxu80gx8ygam-qemhdptmtsvc.jpeg"></a> </p><br><p>  Este artigo explora os conceitos b√°sicos por tr√°s da codifica√ß√£o de caracteres e, em seguida, mergulha nos detalhes t√©cnicos dos sistemas de codifica√ß√£o. </p><br><p>  Se voc√™ possui apenas um conhecimento b√°sico de codifica√ß√£o de caracteres e deseja entender melhor o essencial, as diferen√ßas entre os sistemas de codifica√ß√£o, por que √†s vezes acabamos com texto sem sentido e os princ√≠pios por tr√°s de uma arquitetura de sistema de codifica√ß√£o diferente, continue lendo. </p><br><p>  Conhecer a codifica√ß√£o de caracteres em detalhes requer uma leitura extensa e uma boa parte do tempo.  Tentei poupar um pouco desse esfor√ßo reunindo tudo em um s√≥ lugar, fornecendo o que acredito ser um background bastante completo do t√≥pico. </p><br><p>  Vou examinar como as codifica√ß√µes de byte √∫nico (ASCII, Windows-1251 etc.) funcionam, a hist√≥ria de como o Unicode surgiu, as codifica√ß√µes baseadas em Unicode UTF-8, UTF-16 e como elas diferem, o recursos espec√≠ficos, compatibilidade e falta dela entre v√°rias codifica√ß√µes, princ√≠pios de codifica√ß√£o de caracteres e um guia pr√°tico de como os caracteres s√£o codificados e decodificados. </p><a name="habracut"></a><br><p>  Embora a codifica√ß√£o de caracteres possa n√£o ser um t√≥pico de vanguarda, √© √∫til entender como funciona agora e como funcionou no passado sem gastar muito tempo. </p><br><h3 id="history-of-unicode">  Hist√≥ria do unicode </h3><br><p>  Eu acho que √© melhor come√ßar nossa hist√≥ria a partir do momento em que os computadores n√£o eram nem de longe t√£o avan√ßados nem t√£o comuns em nossas vidas como agora.  Os desenvolvedores e engenheiros que tentavam criar padr√µes na √©poca n√£o tinham id√©ia de que os computadores e a Internet seriam t√£o populares e difundidos quanto eles.  Quando isso aconteceu, o mundo precisava de codifica√ß√µes de caracteres. </p><br><p>  Mas como voc√™ pode ter um computador armazenando caracteres ou letras quando ele apenas entende caracteres e zeros?  Fora dessa necessidade, surgiu a primeira codifica√ß√£o ASCII de 1 byte, que embora n√£o necessariamente a primeira codifica√ß√£o, foi a mais utilizada e estabeleceu a refer√™ncia.  Portanto, √© um bom padr√£o para usar. </p><br><p>  Mas o que √© ASCII?  O c√≥digo ASCII consiste em 8 bits.  Alguma aritm√©tica f√°cil mostra que esse conjunto de caracteres cont√©m 256 s√≠mbolos (oito bits, zeros e uns 2‚Å∏ = 256). </p><br><p>  Os primeiros 7 bits - 128 s√≠mbolos (2‚Å∑ = 128) do conjunto foram usados ‚Äã‚Äãpara letras latinas, caracteres de controle (como quebras de linha r√≠gida, tabula√ß√µes etc.) e s√≠mbolos gramaticais.  Os outros bits eram para idiomas nacionais.  Dessa forma, os primeiros 128 caracteres s√£o sempre os mesmos e, se voc√™ quiser codificar seu idioma nativo, sirva-se dos s√≠mbolos restantes. </p><br><p>  Isso deu origem a uma pan√≥plia de codifica√ß√µes nacionais.  Voc√™ acaba com uma situa√ß√£o como esta: digamos que voc√™ est√° na R√∫ssia criando um arquivo de texto que, por padr√£o, usa o Windows-1251 (a codifica√ß√£o russa usada no Windows).  E voc√™ envia seu documento para algu√©m fora da R√∫ssia, digamos nos EUA.  Mesmo se o destinat√°rio souber russo, eles ficar√£o sem sorte quando abrirem o documento em seu computador (com software de processamento de texto usando ASCII como c√≥digo padr√£o) porque ver√£o caracteres bizarros e ileg√≠veis (mojibake) em vez de letras russas .  Mais precisamente, as letras em ingl√™s aparecer√£o muito bem, porque os primeiros 128 s√≠mbolos no Windows-1251 e ASCII s√£o id√™nticos, mas onde houver texto em russo, o software de processamento de texto do destinat√°rio usar√° a codifica√ß√£o errada, a menos que o usu√°rio tenha definido manualmente o caractere correto codifica√ß√£o. </p><br><p>  O problema com os padr√µes nacionais de c√≥digos de caracteres √© √≥bvio.  E, finalmente, esses c√≥digos nacionais come√ßaram a se multiplicar, a Internet come√ßou a explodir e todos queriam escrever em seu idioma nacional sem produzir esses mojibakes indecifr√°veis. </p><br><p>  Nesse momento, havia duas op√ß√µes: usar uma codifica√ß√£o para cada pa√≠s ou criar um mapa universal de caracteres para representar todos os caracteres do planeta. </p><br><h3 id="a-short-primer-on-ascii">  Uma breve cartilha sobre ASCII </h3><br><p>  Pode parecer excessivamente elementar, mas se formos detalhados, precisamos cobrir todas as bases. </p><br><p> <a href="https://habrahabr.ru/company/alconost/blog/480688/"><img src="https://habrastorage.org/webt/az/bt/mw/azbtmwjfkdtsfbvqd_ju-fibbwe.png"></a> </p><br><p>  Existem 3 grupos de colunas na tabela ASCII: </p><br><ul><li>  o valor decimal do caractere </li><li>  o valor hexadecimal do caractere </li><li>  o glifo para o pr√≥prio personagem </li></ul><br><p> Digamos que queremos codificar a palavra "ok" em ASCII.  A letra "o" tem um valor decimal de 111 e 6F em hexadecimal.  Em bin√°rio, seria - 01101111. A letra "k" √© a posi√ß√£o 107 em decimal e 6B em hexadecimal ou - 01101011 em bin√°rio.  Portanto, a palavra "OK" em ASCII se pareceria com 01101111 01101011. O processo de decodifica√ß√£o seria o oposto.  Come√ßamos com 8 bits, os convertemos em codifica√ß√£o decimal, terminamos com o n√∫mero do caractere e pesquisamos na tabela o s√≠mbolo correspondente. </p><br><h3 id="unicode">  Unicode </h3><br><p>  Pelo exposto, deve ser bastante √≥bvio o motivo de um √∫nico mapa de caracteres comum ser necess√°rio.  Mas como seria?  A resposta √© Unicode, que na verdade n√£o √© uma codifica√ß√£o, mas um conjunto de caracteres.  Consiste em 1.114.112 posi√ß√µes, ou pontos de c√≥digo, a maioria ainda vazia, portanto, n√£o √© prov√°vel que o conjunto precise ser expandido. </p><br><p>  O padr√£o Unicode consiste em 17 planos com 65.536 pontos de c√≥digo cada.  Cada plano cont√©m um grupo de s√≠mbolos.  O plano zero √© o plano multil√≠ngue b√°sico, onde encontramos os caracteres mais usados ‚Äã‚Äãem todos os alfabetos modernos.  O segundo plano cont√©m caracteres de idiomas mortos.  Existem at√© dois avi√µes reservados para uso privado.  A maioria dos avi√µes ainda est√° vazia. </p><br><p>  Unicode possui pontos de c√≥digo de 0 a 10FFFF (em hexadecimal). </p><br><p>  Os caracteres s√£o codificados no formato hexadecimal precedido por um "U +".  Assim, por exemplo, o primeiro plano b√°sico inclui os caracteres U + 0000 a U + FFFF (0 a 65.535), e o bloco 17 cont√©m U + 100000 a U + 10FFFF (1.048.576 a 1.114.111). </p><br><p>  Portanto, agora, em vez de uma variedade de in√∫meras codifica√ß√µes, temos uma tabela abrangente que codifica todos os s√≠mbolos e caracteres dos quais podemos precisar.  Mas n√£o √© sem suas falhas.  Embora cada caractere tenha sido codificado anteriormente por um byte, agora ele pode ser codificado usando diferentes n√∫meros de bytes.  Por exemplo, voc√™ costumava precisar apenas de um byte para codificar todas as letras do alfabeto ingl√™s.  Por exemplo, a letra latina ‚Äúo‚Äù em Unicode √© U + 006F.  Em outras palavras, o mesmo n√∫mero do ASCII-6F em hexadecimal e 111 em bin√°rio.  Mas para codificar o s√≠mbolo "U + 103D5" (o n√∫mero persa "100"), precisamos de 103D5 em hexadecimal e 66.517 em decimal, e agora precisamos de tr√™s bytes. </p><br><p>  Essa complexidade deve ser tratada por codifica√ß√µes Unicode como UTF-8 e UTF-16.  E mais adiante, vamos dar uma olhada neles. </p><br><h3 id="utf-8">  Utf-8 </h3><br><p>  UTF-8 √© uma codifica√ß√£o Unicode do sistema de codifica√ß√£o de largura vari√°vel que pode ser usada para exibir qualquer s√≠mbolo Unicode. </p><br><p>  O que queremos dizer quando falamos em largura vari√°vel?  Primeiro de tudo, precisamos entender que a unidade estrutural (at√¥mica) na codifica√ß√£o √© um byte.  Codifica√ß√£o de largura vari√°vel significa que um caractere pode ser codificado usando diferentes n√∫meros de unidades ou bytes.  Por exemplo, letras latinas s√£o codificadas com um byte e letras cir√≠licas com dois. </p><br><p>  Antes de prosseguirmos, um pequeno aparte em rela√ß√£o √† compatibilidade entre ASCII e UTF. </p><br><p>  O fato de letras latinas e caracteres de controle de teclas, como quebras de linha, tabula√ß√£o, etc.  conter um byte torna a codifica√ß√£o UTF compat√≠vel com ASCII.  Em outras palavras, caracteres de script e controle em latim s√£o encontrados exatamente nos mesmos pontos de c√≥digo em ASCII e UTF e s√£o codificados usando um byte em ambos e, portanto, s√£o compat√≠veis com vers√µes anteriores. </p><br><p>  Vamos usar a letra "o" do nosso exemplo ASCII anterior.  Lembre-se de que sua posi√ß√£o na tabela ASCII √© 111 ou 01101111 em bin√°rio.  Na tabela Unicode, √© U + 006F ou 01101111. E agora que o UTF √© um sistema de codifica√ß√£o de largura vari√°vel, ‚Äúo‚Äù seria de um byte.  Em outras palavras, "o" seria representado da mesma maneira em ambos.  E o mesmo para os caracteres de 0 a 128. Portanto, se o documento contiver letras em ingl√™s, voc√™ n√£o notar√° diferen√ßa se o abrisse usando UTF-8, UTF-16 ou ASCII e s√≥ notaria a diferen√ßa se come√ßar a trabalhar com codifica√ß√µes nacionais. </p><br><p>  Vejamos como a frase mista em ingl√™s / russo "Hello World" apareceria em tr√™s sistemas de codifica√ß√£o diferentes: Windows-1251 (codifica√ß√£o em russo), ISO-8859-1 (sistema de codifica√ß√£o para idiomas da Europa Ocidental), UTF-8 (Unicode) .  Este exemplo √© revelador, porque temos uma frase em dois idiomas diferentes. </p><br><p> <a href="https://habrahabr.ru/company/alconost/blog/480688/"><img src="https://habrastorage.org/webt/3c/xa/rk/3cxarky4ifw35kpwa2fhcoslen8.jpeg"></a> </p><br><p>  Agora, vamos considerar como esses sistemas de codifica√ß√£o funcionam e como podemos traduzir uma linha de texto de uma codifica√ß√£o para outra, e o que acontece se os caracteres s√£o exibidos incorretamente ou se simplesmente n√£o podemos fazer isso devido √†s diferen√ßas nos sistemas. </p><br><p>  Vamos supor que nossa frase original tenha sido escrita com a codifica√ß√£o Windows-1251.  Quando olhamos para a tabela acima, podemos ver traduzindo de decimal ou hexadecimal para decimal que obtemos a codifica√ß√£o abaixo em bin√°rio usando o Windows-1251. </p><br><p>  01001000 01100101 01101100 01101100 01101111 00100000 11101100 11101000 11110000 </p><br><p>  Ent√£o agora temos a frase "Hello World" na codifica√ß√£o Windows-1251. </p><br><p>  Agora imagine que temos um arquivo de texto, mas n√£o sabemos em que sistema de codifica√ß√£o o texto foi salvo.  N√≥s assumimos que ele est√° codificado na ISO-8859-1 e a abrimos em nosso processador de texto usando este sistema de codifica√ß√£o.  Como vimos anteriormente, alguns dos caracteres parecem bem, pois existem nesse sistema de codifica√ß√£o e est√£o nos mesmos pontos de c√≥digo, mas os caracteres da palavra russa "mundo" n√£o funcionam t√£o bem.  Esses caracteres n√£o existem no sistema de codifica√ß√£o e, em seus locais ou pontos de c√≥digo, na ISO-8859-1, encontramos caracteres completamente diferentes.  Portanto, "m" √© o ponto de c√≥digo 236, "e" √© 232 e "p" √© 240. Mas na ISO-8859-1 esses pontos de c√≥digo correspondem a "√¨" (236), "√®" (232) e " (‚Äù(240). </p><br><p>  Portanto, nossa frase em idioma misto ‚ÄúHello World‚Äù codificada no Windows-1251 e lida na ISO-8859-1 ser√° semelhante a ‚ÄúHello √¨√®√∞‚Äù.  Temos compatibilidade parcial e n√£o podemos exibir uma frase codificada em um sistema adequadamente no outro, porque os s√≠mbolos de que precisamos simplesmente n√£o existem na segunda codifica√ß√£o. </p><br><p>  Precisamos de uma codifica√ß√£o Unicode - no nosso caso, usaremos o UTF-8 como exemplo.  J√° discutimos que os caracteres podem ter entre 1 e 4 bytes em UTF-8, mas outra vantagem √© que o UTF, diferentemente dos dois sistemas de codifica√ß√£o anteriores, n√£o est√° restrito a 256 s√≠mbolos, mas cont√©m todos os s√≠mbolos no conjunto de caracteres Unicode . </p><br><p>  Funciona da seguinte forma: o primeiro bit de cada caractere codificado corresponde n√£o ao glifo ou s√≠mbolo em si, mas a um byte espec√≠fico.  Portanto, se o primeiro bit for zero, sabemos que o s√≠mbolo codificado usa apenas um byte - o que torna o conjunto compat√≠vel com o ASCII.  Se olharmos atentamente para a tabela de s√≠mbolos ASCII, veremos que os primeiros 128 s√≠mbolos (alfabeto ingl√™s, caracteres de controle e sinais de pontua√ß√£o) s√£o expressos em bin√°rio, todos come√ßam com um valor de bit 0 (observe que, se voc√™ traduzir caracteres para bin√°rio usando um conversor on-line ou algo semelhante, o primeiro bit zero de alta ordem pode ser descartado, o que pode ser um pouco confuso). </p><br><p>  01001000 - o valor do primeiro bit √© 0, ent√£o 1 byte codifica 1 caractere -&gt; "H". </p><br><p>  01100101 - o valor do primeiro bit √© 0, ent√£o 1 byte codifica 1 caractere -&gt; ‚Äúe‚Äù. </p><br><p>  Se o valor do primeiro bit n√£o for zero, o s√≠mbolo ser√° codificado em v√°rios bytes. </p><br><p>  Uma codifica√ß√£o de dois bytes ter√° 110 para os primeiros valores de tr√™s bits. </p><br><p>  11010000 10111100 - os bits do marcador s√£o 110 e 10, portanto, usamos 2 bytes para codificar 1 caractere.  O segundo byte, neste caso, sempre come√ßa com "10." Portanto, omitimos os bits de controle (os bits iniciais destacados em vermelho e verde) e observamos o restante do c√≥digo (10000111100) e convertemos para hex (043). -&gt; U + 043C, que nos d√° o "m" russo em Unicode. </p><br><p>  Os bits iniciais para um caractere de tr√™s bytes s√£o 1110. </p><br><p>  11101000 10000111 101010101 - somamos todos os bits, exceto os de controle, e descobrimos que em hexadecimal temos 103B5, U + 103D5 - o antigo n√∫mero persa cem (10000001111010101). </p><br><p>  As codifica√ß√µes de caracteres de quatro bytes come√ßam com os bits iniciais 11110. </p><br><p>  11110100 10001111 10111111 10111111 - U + 10FFFF, que √© o √∫ltimo caractere dispon√≠vel no conjunto Unicode (1000011111111111111111111). </p><br><p>  Agora, podemos escrever facilmente nossa frase em v√°rios idiomas na codifica√ß√£o UTF-8. </p><br><h3 id="utf-16">  Utf-16 </h3><br><p>  UTF-16 √© outra codifica√ß√£o de largura vari√°vel.  A principal diferen√ßa entre UTF-16 e UTF-8 √© que o UTF-16 usa 2 bytes (16 bits) por unidade de c√≥digo em vez de 1 bye (8 bits).  Em outras palavras, qualquer caractere Unicode codificado em UTF-16 pode ter dois ou quatro bytes.  Para simplificar, vou me referir a esses dois bytes como uma unidade de c√≥digo.  Portanto, em UTF-16, qualquer caractere pode ser representado usando uma ou duas unidades de c√≥digo. </p><br><p>  Vamos come√ßar com s√≠mbolos codificados usando uma unidade de c√≥digo.  Podemos calcular facilmente que existem 65.535 (216) caracteres com uma unidade de c√≥digo, alinhada completamente com o plano multil√≠ngue b√°sico do Unicode.  Todos os caracteres neste plano ser√£o representados por uma unidade de c√≥digo (dois bytes) em UTF-16. </p><br><p>  Letra latina ‚Äúo‚Äù - 00000000 01101111. </p><br><p>  Letra cir√≠lica "M" - 00000100 00011100. </p><br><p>  Agora, vamos considerar caracteres fora do plano multil√≠ngue b√°sico.  Eles requerem duas unidades de c√≥digo (4 bytes) e s√£o codificados de uma maneira um pouco mais complicada. </p><br><p>  Primeiro, precisamos definir o conceito de um par substituto.  Um par substituto √© duas unidades de c√≥digo usadas para codificar um √∫nico caractere (totalizando 4 bytes).  O conjunto de caracteres Unicode reserva um intervalo especial D800 a DFFF para pares substitutos.  Isso significa que, ao converter um par substituto em bytes em hexadecimal, acabamos com um ponto de c√≥digo nesse intervalo que √© um par substituto em vez de um caractere separado. </p><br><p>  Para codificar um s√≠mbolo no intervalo de 10000 a 10FFFF (ou seja, caracteres que requerem mais de uma unidade de c√≥digo), procedemos da seguinte maneira: </p><br><ol><li><p>  Subtraia 10000 (hex) do ponto de c√≥digo (este √© o ponto de c√≥digo mais baixo no intervalo de 10000 a 10FFFF). </p><br></li><li><p>  Acabamos com um n√∫mero de at√© 20 bits n√£o superior a FFFF. </p><br></li><li><p>  Os 10 bits de alta ordem com os quais terminamos s√£o adicionados ao D800 (o ponto de c√≥digo mais baixo no intervalo de pares substitutos em Unicode). </p><br></li><li><p>  Os pr√≥ximos 10 bits s√£o adicionados ao DC00 (tamb√©m da faixa de pares substitutos). </p><br></li><li><p>  Em seguida, terminamos com 2 unidades de c√≥digo substitutas de 16 bits, cujos primeiros 6 bits definem a unidade como parte de um par substituto. </p><br></li><li><p>  O d√©cimo bit em cada substituto define a ordem do par.  Se temos um "1", √© o substituto principal ou alto, e se temos um "0", √© o substituto final ou baixo. </p><br></li></ol><br><p>  Isso far√° um pouco mais de sentido quando ilustrado com o exemplo abaixo. </p><br><p>  Vamos codificar e decodificar o n√∫mero persa cem (U + 103D5): </p><br><ol><li><p>  103D5 - 10000 = 3D5. </p><br></li><li><p>  3D5 = 0000000000 1111010101 (os 10 bits mais altos s√£o zero e, quando convertidos em hexadecimal, terminamos com "0" (os dez primeiros) e 3D5 (os segundos dez)). </p><br></li><li><p>  0 + D800 = D800 (1101100000000000), os 6 primeiros bits nos dizem que esse ponto de c√≥digo cai no intervalo dos pares substitutos, o d√©cimo bit (√† direita) tem um valor "0", ent√£o esse √© o substituto alto. </p><br></li><li><p>  3D5 + DC00 = DFD5 (1101111111010101), os primeiros 6 bits nos dizem que esse ponto de c√≥digo cai no intervalo dos pares substitutos, o d√©cimo bit (da direita) √© um "1", ent√£o sabemos que esse √© o substituto baixo. </p><br></li><li><p>  O caractere resultante codificado em UTF-16 √© semelhante a - 1101100000000000 1101111111010101. </p><br></li></ol><br><p>  Agora vamos decodificar o personagem.  Digamos que temos o seguinte ponto de c√≥digo - 1101100000100010 1101111010001000: </p><br><ol><li><p>  N√≥s convertemos para hexadecimal = D822 DE88 (os dois pontos de c√≥digo caem no intervalo do par substituto, portanto, sabemos que estamos lidando com um par substituto). </p><br></li><li><p>  1101100000100010 - o d√©cimo bit (da direita) √© um "0", ent√£o esse √© o substituto alto. </p><br></li><li><p>  1101111010001000 - o d√©cimo bit (da direita) √© um "1", portanto esse √© o substituto baixo. </p><br></li><li><p>  Ignoramos os 6 bits que identificam isso como substituto e ficamos com 0000100010 1010001000 (8A88). </p><br></li><li><p>  Adicionamos 10000 (o ponto de c√≥digo mais baixo no intervalo substituto) 8A88 + 10000 = 18A88. </p><br></li><li><p>  Observamos a tabela Unicode para U + 18A88 = Tangut Component-649. </p><br></li></ol><br><p>  Parab√©ns a todos que leram at√© aqui! </p><br><p>  Espero que isso tenha sido informativo sem deixar voc√™ muito entediado. </p><br><p>  <strong>Voc√™ tamb√©m pode achar √∫til:</strong> <strong><br></strong> <br>  <a href="https://unicode-table.com/en/">O conjunto de caracteres unicode</a> </p><br><p>  <a href="https://habr.com/ru/company/alconost/blog/473960/">Estrat√©gias para localiza√ß√£o de conte√∫do: com base em IP ou navegador</a> <a href="https://habr.com/ru/company/alconost/blog/473960/"><br></a> </p><br><h3 id="about-the-translator">  Sobre o tradutor </h3><br><p>  <a href="https://alconost.com/en%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">A Alconost</a> √© um fornecedor global de servi√ßos de <a href="https://alconost.com/en/services/software-localization%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">localiza√ß√£o para aplicativos</a> , <a href="https://alconost.com/en/services/game-localization%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">jogos</a> , v√≠deos e <a href="https://alconost.com/en/services/website-translation%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">sites</a> em mais de 70 idiomas.  Oferecemos tradu√ß√µes de ling√ºistas nativos, testes ling√º√≠sticos, fluxo de trabalho baseado em nuvem, localiza√ß√£o cont√≠nua, gerenciamento de projetos 24 horas por dia, 7 dias por semana e trabalhamos com qualquer formato de recursos de string.  Tamb√©m criamos <a href="https://alconost.com/en/services/video-production%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">v√≠deos</a> e imagens publicit√°rios e educacionais, teasers, explicadores e trailers para o Google Play e a App Store. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt480688/">https://habr.com/ru/post/pt480688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt480674/index.html">Testando servidores virtuais da DigitalOcean, Vultr, Linode e Hetzner. Baixas humanas: 0.0</a></li>
<li><a href="../pt480680/index.html">Estrat√©gia de defesa NGINX e pedido a Igor Sysoev</a></li>
<li><a href="../pt480682/index.html">Intel RealSense LiDAR L515 - Outro novo RealSense</a></li>
<li><a href="../pt480684/index.html">DIY StarWars Snowflakes (atualize 2019)</a></li>
<li><a href="../pt480686/index.html">Por que recusei solu√ß√µes de plataforma cruzada no desenvolvimento m√≥vel</a></li>
<li><a href="../pt480690/index.html">Gerenciamos cortinas de polegada mais baratas</a></li>
<li><a href="../pt480692/index.html">MobX ou Redux: Qual √© melhor para o gerenciamento de estado de rea√ß√£o?</a></li>
<li><a href="../pt480694/index.html">Podemos parar de chamar a acessibilidade e usabilidade do UX?</a></li>
<li><a href="../pt480700/index.html">Usamos console.log () no Chrome ao m√°ximo</a></li>
<li><a href="../pt480702/index.html">RH e talentos, especialistas e criativos: como foi o oitavo Habraseminar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>