<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèæ üë©üèø‚Äçü§ù‚Äçüë®üèæ ‚úåüèø Mikrofronts: Wor√ºber reden wir? üç≠ üè• üö£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In all den Jahren haben Sie als Frontend-Entwickler Monolithen geschrieben, obwohl Sie verstanden haben, dass dies eine schlechte Angewohnheit war. Si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mikrofronts: Wor√ºber reden wir?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/459540/"> In all den Jahren haben Sie als Frontend-Entwickler Monolithen geschrieben, obwohl Sie verstanden haben, dass dies eine schlechte Angewohnheit war.  Sie haben Ihren Code in Komponenten aufgeteilt, <code>require</code> oder <code>import</code> und npm-Pakete in package.json definiert oder Git-Repositorys in Ihrem Projekt generiert, aber Sie haben trotzdem einen Monolithen geschrieben. <br>  Es ist Zeit, die Position zu √§ndern. <br><a name="habracut"></a><br><h3>  <b>Warum kann Ihr Code als Monolith betrachtet werden?</b> </h3><br>  Von Natur aus sind alle Frontend-Anwendungen monolithisch - mit Ausnahme von Anwendungen, die Micro-Frontends implementieren.  Der Grund daf√ºr ist, dass Sie mithilfe der React-Bibliothek entwickeln und zwei Teams die Arbeit erledigen.  Beide sollten dieselbe Version von React verwenden und sich gegenseitig √ºber Aktualisierungen auf dem Laufenden halten. Dies bedeutet, dass sie Konflikte mit der Zusammenf√ºhrung des Codes ausnahmslos l√∂sen.  Sie sind in der Codebasis nicht v√∂llig unabh√§ngig voneinander.  Sie verwenden wahrscheinlich alle dasselbe Repository und ein Build-System.  Microservices k√∂nnen vor monolithischen Anwendungen sparen!  Aber wie so?  Immerhin sind sie f√ºr das Backend!  * unglaubliche √úberraschung * <br><br><h3>  <b>Was sind Microservices?</b> </h3><br>  In einfachen Worten, Microservices sind eine Entwicklungstechnik, die es Entwicklern erm√∂glicht, unabh√§ngige Funktionen (Releases) f√ºr verschiedene Teile der Plattform bereitzustellen, und gleichzeitig brechen sich Releases nicht gegenseitig.  Unabh√§ngige Lieferungen erm√∂glichen es ihnen, isolierte oder lose gekoppelte Dienste zu sammeln.  Es gibt mehrere Regeln, die diese Architektur robuster machen.  Kurz gesagt, sie k√∂nnen wie folgt definiert werden: Jeder Dienst sollte klein sein und nur eine Aufgabe ausf√ºhren.  Daher sollte das Team, das daran arbeitet, auch klein sein.  Wie gro√ü ein Projekt und ein Team sein k√∂nnen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erkl√§ren</a> James Lewis und Martin Fowler: <br><br><blockquote>  Entwickler, die mit Microservices interagieren, nennen unterschiedliche Gr√∂√üen.  Die gr√∂√üten von ihnen erf√ºllen die <i>Zwei-Pizza-Team-</i> Strategie von Amazon - nicht mehr als 10-12 Personen.  Die umgekehrte Pole - Teams von 5-6 Personen, von denen jede einen Dienst unterst√ºtzt. </blockquote><br>  Hier ist ein Diagramm, das den Unterschied zwischen einem Monolithen und Mikrodiensten erkl√§rt: <br><br><img src="https://habrastorage.org/webt/jb/wa/hd/jbwahdgqhcgufovvsbd9yc_8wj0.jpeg"><br><br>  Aus dem Diagramm ist ersichtlich, dass jeder Dienst im Microservice-System eine separate Anwendung ist, mit Ausnahme der Benutzeroberfl√§che - es bleibt ein einziges Ganzes!  Wenn alle Services von einem Team unterst√ºtzt werden, besteht das Risiko, dass das Frontend-Team mit dem Wachstum des Unternehmens nicht mehr mit der Benutzeroberfl√§che Schritt h√§lt.  Dies ist die Schwachstelle dieser Architektur. <br><br><img src="https://habrastorage.org/webt/sz/zs/to/szzsto67t102i-tdnrukvfcdx5w.jpeg"><br><br>  Architektur kann organisatorische Probleme mit sich bringen.  Angenommen, das Unternehmen ist gewachsen und hat eine flexible Entwicklungsmethode eingef√ºhrt (ich spreche von Agile).  Sie erfordern kleine funktions√ºbergreifende Teams.  In unserem abstrakten Beispiel werden Manager nat√ºrlich beginnen, die Aufgaben des Frontends und des Backends zu trennen, und die funktions√ºbergreifenden Teams werden nicht wirklich funktions√ºbergreifend sein.  Und alle Bem√ºhungen werden vergebens sein: Das Team mag flexibel aussehen, aber tats√§chlich wird es stark gespalten sein.  Das Management eines solchen Teams ist nichts f√ºr schwache Nerven.  Bei jedem Meeting wird eine Frage gestellt: Gibt es genug Frontend-Aufgaben, gibt es genug Backend-Aufgaben im Sprint?  Um diese und viele andere Probleme zu l√∂sen, tauchte vor einigen Jahren die Idee der Mikrofront auf, die schnell an Popularit√§t gewann. <br><br><h3>  <b>L√∂sung des Problems: Mikrofronts</b> </h3><br>  Die L√∂sung sieht ziemlich offensichtlich aus, da √§hnliche Prinzipien bei der Arbeit an Backend-Diensten seit langem erfolgreich angewendet werden: Aufteilen eines monolithischen Frontends in kleine UI-Fragmente.  Die Benutzeroberfl√§che ist den Diensten jedoch nicht ganz √§hnlich - sie ist eine Schnittstelle zwischen dem Endbenutzer und dem Produkt. Sie muss durchdacht und systematisch sein.  Dar√ºber hinaus werden im Zeitalter von Anwendungen mit nur einer Seite ganze Anwendungen √ºber einen Browser auf der Clientseite gestartet.  Dies sind keine einfachen HTML-Dateien mehr, sondern komplexe Komponenten, die verschiedene Benutzeroberfl√§chen und Gesch√§ftslogik enthalten k√∂nnen.  Vielleicht ist es jetzt notwendig, Mikrofronts zu definieren. <br><br><blockquote>  Das Prinzip der Mikrofronts: Die Pr√§sentation einer Website oder Webanwendung als eine <b>Reihe von Funktionen,</b> f√ºr die unabh√§ngige Teams verantwortlich sind.  Jedes Team hat seine eigene Mission, sein eigenes Arbeitsfeld, auf das es sich spezialisiert hat.  Das Team ist funktions√ºbergreifend und entwickelt sich weiter <br>  <b>den gesamten Zyklus</b> - von der Datenbank bis zur Benutzeroberfl√§che ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">micro-fontend.org</a> ). </blockquote><br>  Meine aktuelle Erfahrung zeigt, dass es f√ºr viele Unternehmen schwierig sein kann, die oben vorgeschlagene Architektur zu akzeptieren.  F√ºr andere erlaubt die Belastung durch den alten Code nicht den √úbergang zu einer neuen Architektur.  Daher ist eine reibungslosere, einfachere und zuverl√§ssigere Art der Migration erforderlich.  Nachdem ich die Architektur genauer untersucht habe, werde ich versuchen, meine Vision zur L√∂sung des Problems anzubieten.  Machen Sie sich mit der Terminologie vertraut, bevor Sie sich mit den Details befassen. <br><br>  <b>Allgemeine Struktur und etwas mehr Terminologie</b> <br><br>  Stellen Sie sich vor, wir teilen die Struktur einer monolithischen Anwendung vertikal durch Gesch√§ftsfunktionen.  Wir werden mehrere kleinere Anwendungen mit der gleichen Struktur wie die monolithische Anwendung erhalten.  Wenn wir jedoch zus√§tzlich zu diesen kleinen monolithischen Anwendungen eine spezielle Anwendung hinzuf√ºgen, werden die Benutzer damit interagieren.  Es wird wiederum die Benutzeroberfl√§che dieser kleinen Anwendungen integrieren.  Wir nennen diese Ebene den Link, da die UI-Elemente jedes Microservices in einer einzigen Schnittstelle zusammengefasst werden - dies ist die direkteste Implementierung des Mikrofronts.  * aufrichtige Bewunderung * <br><br><img src="https://habrastorage.org/webt/_z/uj/un/_zujun_sxd6nv5clohckbo5pgny.jpeg"><br><br>  Um es klarer zu machen, werde ich im Folgenden jede kleine monolithische Anwendung als <b>Mikroanwendung bezeichnen</b> , da es sich nicht nur um Mikrodienste handelt, sondern um eigenst√§ndige Anwendungen - jede von ihnen verf√ºgt √ºber UI-Elemente und jede von ihnen repr√§sentiert eine vollwertige Gesch√§ftsfunktion.  Wie Sie wissen, ist das heutige Front-End-√ñkosystem sehr vielf√§ltig und kann sehr komplex sein.  Und solche einfachen, offensichtlichen L√∂sungen sind im Produktimplementierungsprozess m√∂glicherweise nicht angemessen. <br><br><h3>  <b>Zu l√∂sende Probleme</b> </h3><br>  Als die Idee zu diesem Artikel geboren wurde, habe ich ein Thema auf Reddit gestartet, um dar√ºber zu diskutieren.  Dank der Community-Mitglieder und ihres Feedbacks kann ich die Probleme auflisten, die behoben werden m√ºssen. <br><br>  <b>Problem Nummer 1:</b> Erzielen Sie ein konsistentes und konsistentes Verhalten √ºber die Benutzeroberfl√§che, wenn wir mehrere vollst√§ndig autonome Mikroanwendungen haben <br><br>  Es gibt kein Allheilmittel, aber es gibt die Idee, eine gemeinsame UI-Bibliothek zu erstellen, die auch eine unabh√§ngige Mikroanwendung w√§re.  In diesem Fall m√ºssen alle anderen Mikroanwendungen von dieser UI-Bibliothek abh√§ngen.  Und das t√∂tet ihre Unabh√§ngigkeit. <br><br>  Eine weitere Option besteht darin, allgemeine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSS-Variablen</a> auf Stammebene zu erstellen.  Der Vorteil dieser L√∂sung ist, dass wir ein globales benutzerdefiniertes Thema f√ºr alle Anwendungen erhalten. <br><br>  Oder wir k√∂nnen SASS-Variablen und Verunreinigungen allen Teams gemeinsam machen.  Zu den Nachteilen dieses Ansatzes geh√∂ren die wiederholte Implementierung von UI-Elementen und die Notwendigkeit einer st√§ndigen √úberpr√ºfung des Designs √§hnlicher Elemente in allen Mikroanwendungen. <br><br>  <b>Problem Nummer 2:</b> Stellen Sie sicher, dass ein Team das CSS eines anderen Teams nicht neu schreibt <br><br>  Erstens k√∂nnen Sie den Umfang von CSS mithilfe von Selektoren einschr√§nken, die aus dem Namen der Mikroanwendung bestehen.  Indem Sie diese Einschr√§nkung auf die mittlere Ebene setzen, k√∂nnen Sie die Gesamtentwicklungszeit reduzieren, gleichzeitig erh√∂ht sich jedoch die Verantwortung f√ºr die mittlere Ebene. <br><br>  Zweitens k√∂nnen Sie jede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mikroanwendung</a> zu einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierten Webkomponente machen</a> .  Der Vorteil dieses Ansatzes besteht darin, dass sich der Browser mit der Einschr√§nkung befasst.  Alles hat jedoch seinen Preis: Mit dem Shadow DOM ist es fast unm√∂glich, auf der Serverseite zu rendern.  Dar√ºber hinaus werden benutzerdefinierte Elemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von Browsern nicht zu</a> 100% <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unterst√ºtzt</a> - insbesondere, wenn Sie IE-Unterst√ºtzung ben√∂tigen. <br><br>  <b>Problem Nummer 3:</b> Machen Sie globale Informationen f√ºr verschiedene Mikroanwendungen gleich <br><br>  Dieses Problem ist eines der h√§ufigsten, aber es ist recht einfach zu l√∂sen.  HTML5 verf√ºgt √ºber leistungsstarke Funktionen, die von den meisten Front-End-Entwicklern kaum erforscht werden. <br>  Eine dieser Funktionen sind benutzerdefinierte Ereignisse, mit denen Sie Informationen f√ºr Mikroanwendungen festlegen k√∂nnen. <br><br>  Eine Pub-Sub- oder T39-Implementierung kann ebenfalls hilfreich sein.  Wenn Sie einen subtileren globalen Status-Handler ben√∂tigen, k√∂nnen Sie einen kleinen allgemeinen Redux implementieren - dies ergibt eine reaktionsschnellere Architektur. <br><br>  <b>Problem Nummer 4:</b> Wenn alle Mikroanwendungen autonom sind, wie wird das Routing auf der Clientseite durchgef√ºhrt? <br><br>  Die L√∂sung des Problems h√§ngt von der Implementierung ab.  Alle wichtigen modernen Frameworks verf√ºgen √ºber leistungsstarke clientseitige Routing-Mechanismen, die den Status des Browserverlaufs verwenden.  Das Problem ist, welche Anwendung f√ºr die aktuelle Route verantwortlich ist und wann genau. <br><br>  Mein pragmatischer Ansatz besteht darin, einen gemeinsamen Client-Router zu erstellen, der nur f√ºr Routen der obersten Ebene verantwortlich ist, und der Rest ist den entsprechenden Mikroanwendungen ausgeliefert.  Angenommen, wir haben eine Routendefinition <code>/content/:id.</code>  Der gemeinsame Router l√∂st den c <code>/content</code> und die aufgel√∂ste Route wird an ContentMicroApp √ºbergeben.  ContentMicroApp ist ein eigenst√§ndiger Server, der nur mit <code>/:id</code> aufgerufen wird. <br><br>  <b>Problem Nummer 5:</b> Brauchen wir wirklich SSR (serverseitiges Rendering)? Ist dies bei Verwendung von Mikrofronts m√∂glich? <br><br>  Das serverseitige Rendern ist nicht einfach.  Wenn Sie Mikroanwendungen mithilfe von Iframes b√ºndeln m√∂chten, vergessen Sie das serverseitige Rendern.  Ebenso sind Webkomponenten zum Binden nicht st√§rker als Iframes.  Wenn jedoch jede der Mikroanwendungen in der Lage ist, serverseitigen Inhalt zu rendern, ist die Verbindungsschicht nur f√ºr das Kombinieren von HTML-Fragmenten auf der Serverseite verantwortlich. <br><br>  <b>Problem 6:</b> ‚ÄûDie Integration in die vorhandene Umgebung ist wie Luft erforderlich!  Wie macht man das? " <br><br>  F√ºr die Integration in bestehende Systeme m√∂chte ich meine Vision beschreiben, die ich als ‚Äû <i>schrittweise Implementierung</i> ‚Äú bezeichne. <br><br>  Zun√§chst m√ºssen wir die Middleware-Schicht so implementieren, dass sie die Funktionalit√§t eines transparenten Proxyservers aufweist.  Danach k√∂nnen wir das vorhandene System als <i>Mikroanwendung</i> ( <i>LegacyMicroApp</i> ) definieren, indem wir eine spezielle Route dazu deklarieren.  Der gesamte Datenverkehr, der die Verbindungsebene erreicht, wird transparent an das vorhandene System weitergeleitet, da wir noch keine anderen Mikroanwendungen haben. <br><br>  Der n√§chste Schritt ist die schrittweise Implementierung.  Wir werden ein kleines St√ºck <i>LegacyMicroApp nehmen</i> , die <i>Hauptnavigation</i> entfernen und durch eine Abh√§ngigkeit ersetzen.  Diese Abh√§ngigkeit ist eine Mikroanwendung, die mit der brandneuen brillanten Technologie NavigationMicroApp implementiert wurde. <br><br>  Jetzt f√§ngt <i>LegacyMicroApp</i> alle Routen durch die NavigationMicroApp-Abh√§ngigkeit ab und verarbeitet sie intern. <br><br>  In √§hnlicher Weise werden wir dann die Fu√üzeile neu erstellen. <br><br>  Also werden wir weiterhin ein St√ºck <i>LegacyMicroApp</i> abbei√üen, bis nichts mehr davon √ºbrig ist. <br><br>  <b>Problem Nummer 7:</b> Orchestrieren Sie die Clientseite, damit Sie die Seite nicht jedes Mal neu laden m√ºssen <br><br>  Die Middleware-Schicht l√∂st Probleme auf der Clientseite, jedoch nicht auf der Serverseite.  Auf der Clientseite k√∂nnen wir durch Herunterladen eines einzelnen HTML-Codes beim √Ñndern von URLs keine einzelnen Teile laden.  Daher ben√∂tigen wir einen Mechanismus, der Fragmente asynchron l√§dt.  Das Problem ist, dass diese Fragmente Abh√§ngigkeiten aufweisen k√∂nnen und diese Abh√§ngigkeiten auf der Clientseite aufgel√∂st werden m√ºssen.  Dies bedeutet, dass die Mikrofrontend-L√∂sung einen Mechanismus zum Laden von Mikroanwendungen und zum Implementieren der Abh√§ngigkeitsinjektion bieten sollte. <br><br>  Die oben aufgef√ºhrten Probleme k√∂nnen zu folgenden Themen zusammengefasst werden: <br><br>  <b>Client-Seite</b> <br><br><ul><li>  Orchestrierung </li><li>  Routing </li><li>  Mikroisolation </li><li>  Anwendungsinteraktion </li><li>  Unity UI-Mikroanwendungen </li></ul><br>  <b>Serverseite</b> <br><br><ul><li>  Server-Rendering </li><li>  Routing </li><li>  Abh√§ngigkeitsmanagement </li></ul><br><h3>  <b>Flexible und leistungsstarke, aber einfache Architektur</b> </h3><br>  Aus diesem Grund hat es sich gelohnt, den Anfang des Artikels zu ertragen!  Die Hauptelemente und Anforderungen der Mikrofrontend-Architektur haben sich endlich herausgebildet;) <br><br>  Anhand der Anforderungen und Bedenken begann ich, eine L√∂sung namens <b>microfe zu entwickeln</b> .  * Vorfreude auf Feedback * <br>  Hier werde ich die Architektur des Projekts skizzieren und kurz seine Hauptkomponenten beschreiben. <br><br>  Der einfachste Weg ist der Start auf der Clientseite, die drei separate Hauptstrukturen aufweist: <i>AppsManager, Loader, Router</i> sowie einen weiteren, <i>MicroAppStore</i> . <br><br><img src="https://habrastorage.org/webt/av/xb/wm/avxbwmyjvlrs8zqwgf5jpbfpido.jpeg"><br><br>  <b>AppsManager</b> <br>  AppsManager ist der Kern der clientseitigen Orchestrierung von Mikroanwendungen.  Das Hauptziel von AppsManager ist das Erstellen eines Abh√§ngigkeitsbaums.  Sobald alle Abh√§ngigkeiten aufgel√∂st sind, startet AppsManager die Mikroanwendung. <br><br>  <b>Lader</b> <br>  Ein weiterer wichtiger Bestandteil der clientseitigen Orchestrierung ist Loader.  Er ist verantwortlich f√ºr das Herunterladen von Anwendungen f√ºr die Client-Seite. <br><br>  <b>Router</b> <br>  Um clientseitiges Routing durchzuf√ºhren, habe ich Router in Microfe implementiert.  Im Gegensatz zu herk√∂mmlichen clientseitigen Routern verf√ºgt der Mikrofe-Router √ºber eine eingeschr√§nkte Funktionalit√§t.  Es werden keine Seiten verarbeitet, sondern Mikroanwendungen.  Angenommen, wir haben URL <code>/content/detail/13</code> und ContentMicroApp.  In diesem Fall verarbeitet der Mikrofe-Router die URL zu <code>/content/*</code> und ruft den Teil ContentMicroApp <code>/detail/13</code> . <br><br>  <b>Microapppore</b> <br>  Um die Client-Interaktion zwischen Mikroanwendungen zu l√∂sen, habe ich MicroAppStore in microfe implementiert.  Es hat die gleiche Funktionalit√§t wie die Redux-Bibliothek, jedoch mit einer Einschr√§nkung: Es ist flexibler in Bezug auf asynchrone Datenmodifikation und Reducer'a-Deklaration. <br><br><h3>  <b>***.</b> </h3><br>  Die Server-Seite ist vielleicht etwas komplizierter zu implementieren, hat aber eine einfachere Struktur.  Es besteht aus zwei Hauptteilen - StitchingServer und MicroAppServer. <br><br><h3>  <b>Mikroappserver</b> </h3><br><img src="https://habrastorage.org/webt/ux/nl/wn/uxnlwnbgtmo0xr4-uryt6-tq2sq.jpeg"><br><br>  Die kleinstm√∂gliche MicroAppServer-Funktionalit√§t kann ausgedr√ºckt werden als: init und serve. <br>  Wenn MicroAppServer gestartet wird, sollte zun√§chst SticthingServer aufgerufen und ein Endpunkt bei der angek√ºndigten Mikroanwendung registriert werden.  Es definiert die Abh√§ngigkeiten, Typen und URLs des MicroAppServer-Schemas. Ich denke, dass es unn√∂tig ist, √ºber Serve zu sprechen - hier gibt es nichts Interessantes. <br><br><h3>  <b>Stitching Server</b> </h3><br><img src="https://habrastorage.org/webt/i1/o6/n0/i1o6n0ititazoneaj1lcebo_syw.jpeg"><br><br>  Mit StitchingServer k√∂nnen Sie einen Endpunkt bei MicroAppServers registrieren.  Wenn sich MicroAppServer bei StichingServer registriert, zeichnet StichingServer die MicroAppServer-Deklaration auf. <br><br>  Sp√§ter verwendet StitchingServer die Anzeige, um MicroAppServices von der angeforderten URL aufzul√∂sen. <br><br>  Nachdem MicroAppServer und alle seine Abh√§ngigkeiten zugelassen wurden, wird die entsprechende √∂ffentliche URL in den Namen aller entsprechenden Pfade in CSS, JS und HTML angezeigt.  Ein weiterer Schritt besteht darin, CSS-Selektoren ein eindeutiges MicroAppServer-Pr√§fix hinzuzuf√ºgen, um Konflikte zwischen Mikroanwendungen auf der Clientseite zu vermeiden. <br><br>  Dann tritt die Hauptaufgabe von StitchingServer in die Szene ein: Zusammenstellen aller empfangenen Teile und Zur√ºckgeben der gesamten HTML-Seite. <br><br><h3>  <b>Ein paar Worte zu anderen Implementierungen</b> </h3><br>  Noch bevor der Begriff Mikrofrontend im Jahr 2016 auftauchte, versuchten viele gro√üe Unternehmen, √§hnliche Probleme zu l√∂sen - zum Beispiel Facebook mit seiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BigPipe</a> . <br>  Jetzt gewinnt die Idee an Fahrt.  Unternehmen jeder Gr√∂√üe interessieren sich f√ºr dieses Thema und investieren Zeit und Geld in es.  Beispielsweise stellte Zalando den Open Source-Code f√ºr seine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Project Mosaic-</a> L√∂sung bereit.  Ich kann sagen, dass Mikrofe und Projektmosaik √§hnliche Ans√§tze verfolgen, jedoch mit einigen wesentlichen Unterschieden.  Wenn Microfe auf vollst√§ndig dezentrales Routing zur√ºckgreift, um jede Mikroanwendung unabh√§ngiger zu machen, bevorzugt Project Mosaic das zentralisierte Routing und die Musterdefinition f√ºr jede Route.  √úbrigens macht es Project Mosaic einfach, AB-Tests und dynamische Vorlagengenerierung im laufenden Betrieb durchzuf√ºhren. <br><br>  Es gibt insbesondere andere Ans√§tze, bei denen iframs als Verbindungsschicht verwendet wird - offensichtlich nicht auf der Serverseite, sondern auf der Clientseite.  Dies ist eine sehr einfache L√∂sung, die keine spezielle Serverstruktur und die Einbeziehung von DevOps erfordert.  Es kann vom Front-End-Team unabh√§ngig implementiert werden, was bedeutet, dass es weniger organisatorische Probleme f√ºr das Unternehmen verursacht und weniger kostet. <br><br>  Es gibt immer noch ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Single-Spa-</a> Framework.  Das Projekt st√ºtzt sich auf Namenskonventionen f√ºr jede Anwendung, um Mikroanwendungen zuzulassen und herunterzuladen.  Einfach die Idee zu erfassen und Mustern zu folgen.  Das Framework kann daher hilfreich sein, um das System in Ihrer lokalen Umgebung kennenzulernen und damit zu experimentieren.  Das Minus des Projekts ist, dass Sie jede Mikroanwendung streng definiert erstellen m√ºssen - andernfalls akzeptiert das Framework sie m√∂glicherweise nicht. <br><br><h3>  <b>Fazit (und Links)</b> </h3><br>  Ich denke, dass das Thema Mikrofronts im Laufe der Zeit genauer betrachtet wird.  Wenn es die Aufmerksamkeit von immer mehr Unternehmen auf sich zieht, wird dieses Konzept in gro√üen Teams zur Standardentwicklungsmethode.  Es wird f√ºr jeden Front-End-Entwickler n√ºtzlich sein, sich in naher Zukunft mit dieser Architektur vertraut zu machen und wertvolle Erfahrungen damit zu sammeln. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Micro Fe App Registrierungsserver</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Micro-Front-End-Infrastruktur</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459540/">https://habr.com/ru/post/de459540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459528/index.html">Wie unterrichten wir die franz√∂sische √ñkologie und sammeln Flaschen?</a></li>
<li><a href="../de459530/index.html">Microbiota. Geschichte der Studien- und Forschungsmethoden</a></li>
<li><a href="../de459532/index.html">So w√§hlen Sie eine Zufallszahl von 1 bis 10</a></li>
<li><a href="../de459536/index.html">Entwickeln Sie Plugins f√ºr JetBrains-Produkte und verkaufen Sie sie auf dem JetBrains-Marktplatz</a></li>
<li><a href="../de459538/index.html"># 18 Mosdroid Argon in Lamoda - Ank√ºndigung</a></li>
<li><a href="../de459542/index.html">Gamification Mechanics: F√§higkeitsbaum</a></li>
<li><a href="../de459544/index.html">Warum die Tschernobyl-Reihe die Kernenergie so schlecht beschrieb</a></li>
<li><a href="../de459550/index.html">Backup, Teil 5: Testen von Bacula und Veeam Backup f√ºr Linux</a></li>
<li><a href="../de459552/index.html">So verlieren Sie den Zugriff auf das Live-System, indem Sie einfach den Quellcode fummeln</a></li>
<li><a href="../de459554/index.html">Verfolgen Sie Datei√§nderungen mithilfe von Alerting OpenDistro for Elasticsearch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>