<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§“ğŸ¼ ğŸ„ ğŸ‘©â€ğŸ­ Optimalisasi rendering adegan dari kartun Disney "Moana". Bagian 4 dan 5 ğŸ‘¨ğŸ¾â€ğŸ”§ ğŸ‘¨ğŸ½â€ğŸ­ ğŸ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya memiliki cabang pbrt, yang saya gunakan untuk menguji ide-ide baru, mengimplementasikan ide-ide menarik dari artikel ilmiah, dan secara umum untu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimalisasi rendering adegan dari kartun Disney "Moana". Bagian 4 dan 5</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417939/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/8a1/30a/6fe8a130ad8c4f43d16d964991b3852f.jpg" alt="gambar"></div><br>  Saya memiliki cabang pbrt, yang saya gunakan untuk menguji ide-ide baru, mengimplementasikan ide-ide menarik dari artikel ilmiah, dan secara umum untuk mempelajari semua yang biasanya menghasilkan edisi baru dari buku <em>Rendering Berbasis Fisik</em> .  Tidak seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pbrt-v3</a> , yang kami berusaha sedekat mungkin dengan sistem yang dijelaskan dalam buku ini, di utas ini kami dapat mengubah apa pun.  Hari ini kita akan melihat bagaimana perubahan yang lebih radikal dalam sistem akan secara signifikan mengurangi penggunaan memori dalam adegan dengan pulau dari kartun Disney <em>"Moana"</em> . <br><br>  Catatan tentang metodologi: dalam tiga posting sebelumnya, semua statistik diukur untuk versi WIP (Work In Progress) dari adegan yang saya gunakan sebelum rilis.  Pada artikel ini, kita akan beralih ke versi final, yang sedikit lebih rumit. <br><br>  Saat merender adegan pulau terakhir dari <em>Moana</em> , 81 GB RAM digunakan untuk menyimpan deskripsi adegan untuk pbrt-v3.  Saat ini, pbrt-berikutnya menggunakan 41 GB - sekitar setengahnya.  Untuk mendapatkan hasil ini, cukup membuat perubahan kecil yang meluas ke beberapa ratus baris kode. <br><a name="habracut"></a><br><h2>  Mengurangi Primitif </h2><br>  Mari kita ingat bahwa dalam pbrt, <code>Primitive</code> adalah kombinasi dari geometri, materialnya, fungsi radiasi (jika itu adalah sumber cahaya) dan catatan tentang lingkungan di dalam dan di luar permukaan.  Di pbrt-v3, <code>GeometricPrimitive</code> menyimpan yang berikut: <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Shape&gt; shape; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Material&gt; material; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AreaLight&gt; areaLight; MediumInterface mediumInterface;</code> </pre> <br>  Seperti yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dinyatakan sebelumnya</a> , sebagian besar <code>areaLight</code> waktu adalah <code>nullptr</code> , dan <code>MediumInterface</code> berisi sepasang <code>nullptr</code> .  Jadi di pbrt-next saya menambahkan opsi <code>Primitive</code> bernama <code>SimplePrimitive</code> , yang hanya menyimpan pointer ke geometri dan material.  Jika memungkinkan, ini digunakan <code>GeometricPrimitive</code> mungkin alih-alih <code>GeometricPrimitive</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimplePrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;Shape&gt; shape; std::shared_ptr&lt;Material&gt; material; };</span></span></code> </pre> <br>  Untuk instance objek non-animasi, kami sekarang memiliki <code>TransformedPrimitive</code> , yang menyimpan hanya pointer ke primitif dan transformasi, yang menyelamatkan kami sekitar 500 byte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ruang</a> yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terbuang</a> yang ditambahkan oleh instance <code>AnimatedTransform</code> ke dalam renderer <code>TransformedPrimitive</code> pbrt-v3. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransformedPrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;Primitive&gt; primitive; std::shared_ptr&lt;Transform&gt; PrimitiveToWorld; };</span></span></code> </pre> <br>  (Ada <code>AnimatedPrimitive</code> jika Anda memerlukan konversi animasi ke pbrt-next.) <br><br>  Setelah semua perubahan ini, statistik melaporkan bahwa hanya 7,8 GB yang digunakan di bawah <code>Primitive</code> , bukannya 28,9 GB yang digunakan di pbrt-v3.  Meskipun hebat bahwa kami menghemat 21 GB, itu tidak sebanyak penurunan yang bisa kami harapkan dari perkiraan sebelumnya;  kami akan kembali ke perbedaan ini di akhir bagian ini. <br><br><h2>  Mengurangi geometri </h2><br>  Selain itu, pbrt-next secara signifikan mengurangi jumlah memori yang ditempati oleh geometri: ruang yang digunakan untuk segitiga mesh menurun dari 19,4 GB menjadi 9,9 GB, dan ruang penyimpanan untuk kurva dari 1,4 menjadi 1,1 GB.  Lebih dari setengah penghematan ini berasal dari penyederhanaan kelas <code>Shape</code> dasar. <br><br>  Di pbrt-v3, <code>Shape</code> membawa serta beberapa anggota yang membawa ke semua implementasi <code>Shape</code> - ini adalah beberapa aspek yang nyaman untuk diakses dalam implementasi <code>Shape</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// .... const Transform *ObjectToWorld, *WorldToObject; const bool reverseOrientation; const bool transformSwapsHandedness; };</span></span></code> </pre> <br>  Untuk memahami mengapa variabel anggota ini menyebabkan masalah, akan sangat membantu untuk memahami bagaimana jerat segitiga direpresentasikan dalam pbrt.  Pertama, ada kelas <code>TriangleMesh</code> , yang menyimpan simpul dan buffer indeks untuk seluruh jala: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TriangleMesh</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nTriangles, nVertices; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vertexIndices; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Point3f[]&gt; p; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Normal3f[]&gt; n; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br>  Setiap segitiga di jala diwakili oleh kelas <code>Triangle</code> , yang mewarisi dari <code>Shape</code> .  Idenya adalah untuk menjaga <code>Triangle</code> sekecil mungkin: mereka hanya menyimpan pointer ke jala di mana mereka menjadi bagian, dan pointer ke offset di buffer indeks di mana indeks dari simpulnya dimulai: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Triangle</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Shape { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;TriangleMesh&gt; mesh; const int *v; };</span></span></code> </pre> <br>  Ketika implementasi <code>Triangle</code> perlu menemukan posisi verteks mereka, ia melakukan pengindeksan yang sesuai untuk mendapatkannya dari <code>TriangleMesh</code> . <br><br>  Masalah dengan <code>Shape</code> pbrt-v3 adalah bahwa nilai yang disimpan di dalamnya sama untuk semua segitiga mesh, jadi lebih baik untuk menyimpannya dari setiap seluruh mesh di <code>TriangleMesh</code> , dan kemudian memberikan akses <code>Triangle</code> ke satu salinan dari nilai-nilai umum. <br><br>  Masalah ini diperbaiki di pbrt-next: kelas <code>Shape</code> dasar di pbrt-next tidak mengandung anggota tersebut, dan oleh karena itu setiap <code>Triangle</code> kurang dari 24 byte.  <code>Curve</code> Geometri menggunakan strategi yang sama dan juga manfaat dari <code>Shape</code> lebih kompak. <br><br><h2>  Buffer Segitiga Bersama </h2><br>  Terlepas dari kenyataan bahwa pemandangan pulau <em>Moana membuat</em> penggunaan instantiasi objek secara luas untuk pengulangan geometri, saya ingin tahu seberapa sering menggunakan kembali buffer indeks, buffer koordinat tekstur, dan sebagainya digunakan untuk berbagai jerat segitiga. <br><br>  Saya menulis sebuah kelas kecil yang mem-hash buffer ini setelah diterima dan menyimpannya di cache, dan memodifikasi <code>TriangleMesh</code> sehingga memeriksa cache dan menggunakan versi yang sudah disimpan dari buffer redundan yang dibutuhkannya.  Keuntungannya sangat baik: saya berhasil menyingkirkan 4,7 GB volume berlebih, yang jauh lebih dari yang saya harapkan. <br><br><h2>  Hancurkan dengan std :: shared_ptr </h2><br>  Setelah semua perubahan ini, statistik melaporkan sekitar 36 GB dari memori yang dialokasikan diketahui, dan pada awal rendering, <code>top</code> menunjukkan penggunaan 53 GB.  Urusan. <br><br>  Saya takut akan rangkaian <code>massif</code> lambat lainnya untuk mengetahui memori yang dialokasikan tidak ada dalam statistik, tetapi kemudian surat dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arseny Kapulkin</a> muncul di kotak masuk saya.  Arseny menjelaskan kepada saya bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perkiraan saya sebelumnya</a> tentang penggunaan memori <code>GeometricPrimitive</code> sangat salah.  Saya harus mencari tahu untuk waktu yang lama, tetapi kemudian saya menyadari;  banyak terima kasih kepada Arseny karena menunjukkan kesalahan dan penjelasan rinci. <br><br>  Sebelum menulis ke Arseny, saya membayangkan implementasi <code>std::shared_ptr</code> sebagai berikut: di baris ini ada deskriptor umum yang menyimpan jumlah referensi dan pointer ke objek yang ditempatkan itu sendiri: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_ptr_info</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; refCount; T *ptr; };</code> </pre> <br>  Lalu saya menyarankan bahwa instance <code>shared_ptr</code> hanya menunjuk ke sana dan menggunakannya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... T *operator-&gt;() { return info-&gt;ptr; } shared_ptr_info&lt;T&gt; *info; };</span></span></code> </pre> <br>  Singkatnya, saya berasumsi bahwa <code>sizeof(shared_ptr&lt;&gt;)</code> sama dengan ukuran pointer, dan bahwa 16 byte ruang ekstra terbuang untuk setiap pointer yang dibagikan. <br><br>  Tapi ini tidak benar. <br><br>  Dalam implementasi sistem saya, deskriptor yang umum adalah 32 byte dalam ukuran dan 16 byte dalam <code>sizeof(shared_ptr&lt;&gt;)</code> .  Oleh karena itu, <code>GeometricPrimitive</code> , yang terutama terdiri dari <code>std::shared_ptr</code> , sekitar dua kali lebih besar dari perkiraan saya.  Jika Anda bertanya-tanya mengapa ini terjadi, maka kedua pos Stack Overflow ini menjelaskan alasannya dengan sangat terperinci: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> . <br><br>  Di hampir semua kasus menggunakan <code>std::shared_ptr</code> di pbrt-next, mereka tidak harus dibagi pointer.  Saat melakukan peretasan gila, saya mengganti semua yang saya bisa dengan <code>std::unique_ptr</code> , yang sebenarnya memiliki ukuran yang sama dengan pointer biasa.  Sebagai contoh, inilah <code>SimplePrimitive</code> sekarang: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimplePrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::unique_ptr&lt;Shape&gt; shape; const Material *material; };</span></span></code> </pre> <br>  Hadiahnya ternyata lebih besar dari yang saya perkirakan: penggunaan memori pada awal rendering menurun dari 53 GB menjadi 41 GB - penghematan 12 GB, benar-benar tidak terduga beberapa hari yang lalu, dan total volume hampir setengah dari yang digunakan oleh pbrt-v3.  Hebat! <br><br>  Pada bagian selanjutnya, kita akhirnya akan menyelesaikan seri artikel ini - memeriksa kecepatan rendering di pbrt-next dan mendiskusikan ide untuk cara lain untuk mengurangi jumlah memori yang diperlukan untuk adegan ini. <br><br><h2>  Bagian 5 </h2><br>  Untuk meringkas seri artikel ini, kita akan mulai dengan mengeksplorasi kecepatan rendering adegan pulau dari kartun Disney <em>"Moana"</em> di pbrt-next - cabang pbrt yang saya gunakan untuk menguji ide-ide baru.  Kami akan membuat lebih banyak perubahan radikal daripada yang dimungkinkan dalam pbrt-v3, yang harus mematuhi sistem yang dijelaskan dalam buku kami.  Kami menyimpulkan dengan diskusi tentang area untuk perbaikan lebih lanjut, dari yang paling sederhana hingga yang sedikit ekstrim. <br><br><h2>  Waktu render </h2><br>  Pbrt-next membuat banyak perubahan pada algoritma transfer cahaya, termasuk perubahan pada pengambilan sampel BSDF dan peningkatan pada algoritma roulette Rusia.  Akibatnya, ia melacak lebih banyak sinar daripada pbrt-v3 untuk membuat adegan ini, jadi tidak mungkin untuk secara langsung membandingkan waktu eksekusi kedua renderer ini.  Kecepatan umumnya dekat, dengan satu pengecualian penting: ketika merender adegan pulau dari <em>Moana</em> , ditunjukkan di bawah, pbrt-v3 menghabiskan 14,5% dari waktu eksekusi untuk mencari tekstur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ptex</a> .  Ini dulunya tampak cukup normal bagi saya, tetapi pbrt-next hanya menghabiskan 2,2% dari waktu eksekusi.  Semua ini sangat menarik. <br><br>  Setelah mempelajari statistik, kita mendapatkan <sup>1</sup> : <br><br> <code>pbrt-v3: <br>   Ptex 20828624 <br>  Ptex 712324767 <br> <br> pbrt-next: <br>   Ptex 3378524 <br>  Ptex 825826507</code> <br> <br>  Seperti yang kita lihat di pbrt-v3, tekstur ptex dibaca dari disk rata-rata setiap 34 pencarian tekstur.  Dalam pbrt-next, ia dibacakan hanya setelah setiap 244 pencarian - yaitu, disk I / O telah menurun sekitar 7 kali.  Saya menyarankan ini terjadi karena pbrt-selanjutnya menghitung perbedaan ray untuk sinar tidak langsung, dan ini mengarah ke akses ke tingkat tekstur MIP yang lebih tinggi, yang pada gilirannya menciptakan serangkaian akses yang lebih terintegrasi ke cache tekstur ptex, mengurangi jumlah kesalahan cache, dan karenanya jumlah operasi I / O <sup>2</sup> .  Pemeriksaan singkat mengkonfirmasi dugaan saya: ketika perbedaan balok dimatikan, kecepatan ptex menjadi jauh lebih buruk. <br><br>  Peningkatan kecepatan ptex tidak hanya memengaruhi biaya komputasi dan I / O.  Dalam sistem 32-CPU, pbrt-v3 hanya dipercepat 14,9 kali setelah menguraikan deskripsi adegan.  pbrt biasanya menunjukkan skala linear paralel, sehingga cukup mengecewakan saya.  Karena jumlah konflik yang jauh lebih kecil selama penguncian dalam ptex, versi pbrt-next adalah 29,2 kali lebih cepat dalam sistem dengan 32 CPU dan 94,9 kali lebih cepat dalam sistem dengan 96 CPU - kita kembali ke indikator yang sesuai dengan kita. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/8a1/30a/6fe8a130ad8c4f43d16d964991b3852f.jpg"></div><br>  <i>Akar dari adegan pulau Moana dibuat oleh pbrt dengan resolusi 2048x858 pada 256 sampel per piksel.</i>  <i>Total waktu rendering pada mesin Google Compute Engine dengan 96 CPU virtual dengan frekuensi 2 GHz di pbrt-next adalah 41 menit 22 detik.</i>  <i>Akselerasi karena mulithreading selama rendering adalah 94,9 kali.</i>  <i>(Saya tidak mengerti apa yang terjadi dengan pemetaan benjolan.)</i> <br><br><h2>  Bekerja untuk masa depan </h2><br>  Mengurangi jumlah memori yang digunakan dalam adegan yang rumit adalah pengalaman yang menyenangkan: menyimpan beberapa gigabyte dengan perubahan kecil jauh lebih menyenangkan daripada puluhan megabita yang disimpan dalam adegan yang lebih sederhana.  Saya memiliki daftar yang baik tentang apa yang saya harap dapat pelajari di masa depan, jika waktu mengizinkan.  Berikut ini adalah ikhtisar singkat. <br><br><h3>  Lebih lanjut mengurangi memori buffer segitiga </h3><br>  Bahkan dengan penggunaan berulang buffer yang menyimpan nilai yang sama untuk beberapa jerat segitiga, banyak memori masih digunakan di bawah buffer segitiga.  Berikut ini adalah rincian penggunaan memori untuk berbagai jenis buffer segitiga di tempat kejadian: <br><br><table><thead><tr><th>  Jenis </th><th>  Memori </th></tr></thead><tbody><tr><td>  Item baris </td><td>  2,5 GB </td></tr><tr><td>  Normal </td><td>  2,5 GB </td></tr><tr><td>  UV </td><td>  98 MB </td></tr><tr><td>  Indeks </td><td>  252 MB </td></tr></tbody></table><br>  Saya mengerti bahwa tidak ada yang bisa dilakukan dengan posisi vertex yang ditransmisikan, tetapi untuk data lain ada penghematan.  Ada banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jenis representasi vektor normal dalam bentuk</a> yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">efisien-memori</a> yang menyediakan berbagai pertukaran antara ukuran memori / jumlah perhitungan.  Menggunakan salah satu dari representasi 24-bit atau 32-bit akan mengurangi ruang yang ditempati oleh normals menjadi 663 MB dan 864 MB, yang akan menghemat kita lebih dari 1,5 GB RAM. <br><br>  Dalam adegan ini, jumlah memori yang digunakan untuk menyimpan koordinat tekstur dan buffer indeks sangat kecil.  Saya kira ini terjadi karena keberadaan banyak tanaman yang dihasilkan secara prosedural di tempat kejadian dan karena semua variasi dari jenis tanaman yang sama memiliki topologi yang sama (dan karenanya penyangga indeks) dengan parameterisasi (dan karenanya koordinat UV).  Pada gilirannya, menggunakan kembali buffer yang cocok cukup efisien. <br><br>  Untuk adegan lain, pengambilan sampel koordinat UV 16-bit tekstur atau menggunakan nilai float setengah presisi, tergantung pada kisaran nilainya, mungkin sangat cocok.  Tampaknya dalam adegan ini, semua nilai koordinat tekstur adalah nol atau satu, yang berarti bahwa mereka dapat diwakili oleh satu <em>bit</em> - yaitu, adalah mungkin untuk mengurangi memori yang ditempati hingga 32 kali.  Keadaan ini mungkin muncul karena penggunaan format ptex untuk texturing, yang menghilangkan kebutuhan untuk atlas UV.  Mengingat jumlah kecil yang saat ini ditempati oleh koordinat tekstur, implementasi optimasi ini tidak terlalu diperlukan. <br><br>  pbrt selalu menggunakan bilangan bulat 32-bit untuk buffer indeks.  Untuk jerat kecil kurang dari 256 simpul, hanya 8 bit per indeks yang memadai, dan untuk jerat kurang dari 65.536 simpul, 16 bit dapat digunakan.  Mengubah pbrt untuk menyesuaikannya dengan format ini tidak akan terlalu sulit.  Jika kami ingin mengoptimalkan secara maksimal, kami dapat memilih bit yang tepat sebanyak yang diperlukan untuk mewakili kisaran yang diperlukan dalam indeks, sementara harga akan meningkatkan kompleksitas menemukan nilai-nilai mereka.  Terlepas dari kenyataan bahwa sekarang hanya seperempat gigabyte memori digunakan untuk indeks titik, tugas ini tidak terlihat sangat menarik dibandingkan dengan yang lain. <br><br><h3>  Puncak BVH membangun penggunaan memori </h3><br>  Sebelumnya, kami tidak membahas detail lain dari penggunaan memori: segera sebelum rendering, puncak jangka pendek 10 GB memori tambahan yang digunakan terjadi.  Ini terjadi ketika BVH (besar) dari seluruh adegan dibangun.  Kode untuk membangun BVH dari renderer pbrt ditulis untuk dieksekusi dalam dua fase: pertama, itu membuat BVH dengan <a href="">representasi tradisional</a> : dua pointer anak ke setiap node.  Setelah membangun pohon, itu dikonversi menjadi <a href="">skema memori efisien</a> di mana anak pertama dari node terletak tepat di belakangnya di memori, dan offset ke anak kedua disimpan sebagai integer. <br><br>  Pemisahan seperti itu diperlukan dari sudut pandang mengajar siswa - itu jauh lebih mudah untuk memahami algoritma untuk membangun BVH tanpa kekacauan yang terkait dengan kebutuhan untuk mengubah pohon menjadi bentuk yang kompak selama proses konstruksi.  Namun, hasilnya adalah puncak ini dalam penggunaan memori;  dengan mempertimbangkan pengaruhnya di tempat kejadian, penghapusan masalah ini tampaknya menarik. <br><br><h3>  Konversikan pointer ke integer </h3><br>  Dalam berbagai struktur data, ada banyak pointer 64-bit yang dapat direpresentasikan sebagai integer 32-bit.  Sebagai contoh, setiap <code>SimplePrimitive</code> berisi pointer ke <code>Material</code> .  Sebagian besar contoh <code>Material</code> adalah umum bagi banyak primitif di tempat kejadian dan tidak pernah ada lebih dari beberapa ribu;  oleh karena itu, kita dapat menyimpan satu vektor <code>vector</code> global <code>vector</code> semua bahan: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Material *&gt; allMaterials;</code> </pre> <br>  dan hanya menyimpan offset integer 32-bit untuk vektor ini di <code>SimplePrimitive</code> , yang menghemat 4 byte.  Trik yang sama dapat digunakan dengan pointer ke <code>TriangleMesh</code> di setiap <code>Triangle</code> , serta di banyak tempat lainnya. <br><br>  Setelah perubahan seperti itu, akan ada sedikit redundansi dalam mengakses tanda-tanda itu sendiri, dan sistem akan menjadi sedikit kurang dimengerti bagi siswa yang mencoba memahami pekerjaannya;  selain itu, ini mungkin terjadi ketika, dalam konteks pbrt, lebih baik untuk menjaga implementasi sedikit lebih dimengerti, meskipun dengan biaya optimalisasi penggunaan memori yang tidak lengkap. <br><br><h3>  Akomodasi berdasarkan arena (area) </h3><br>  Untuk setiap <code>Triangle</code> individu dan primitif, panggilan terpisah dibuat untuk yang <code>new</code> (sebenarnya <code>make_unique</code> , tetapi ini sama).  Alokasi memori tersebut mengarah pada penggunaan akuntansi sumber daya tambahan, menempati sekitar lima gigabytes memori, tidak terhitung dalam statistik.  Karena umur semua penempatan seperti itu adalah sama - hingga perenderan selesai - kita dapat menyingkirkan penghitungan tambahan ini dengan memilihnya dari <a href="">arena memori</a> . <br><br><h3>  Khaki vtable </h3><br>  Gagasan terakhir saya mengerikan, dan saya minta maaf untuk itu, tetapi dia menggugah saya. <br><br>  Setiap segitiga dalam adegan memiliki beban tambahan setidaknya dua pointer vtable: satu untuk <code>Triangle</code> , dan satu lagi untuk <code>SimplePrimitive</code> .  Ini adalah 16 byte.  Adegan pulau <em>Moana</em> memiliki total 146 162 124 segitiga unik, yang menambahkan hampir 2,2 GB pointer tabel berlebihan. <br><br>  Bagaimana jika kita tidak memiliki kelas dasar abstrak untuk <code>Shape</code> dan setiap implementasi geometri tidak mewarisi dari apa pun?  Ini akan menghemat ruang kita pada pointer vtable, tetapi, tentu saja, ketika melewati pointer ke geometri, kita tidak akan tahu seperti apa geometri itu, yaitu, itu akan sia-sia. <br><br>  Ternyata pada CPU x86 modern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">, hanya 48 bit pointer 64-bit</a> yang benar-benar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">digunakan</a> .  Oleh karena itu, ada 16 bit tambahan yang dapat kita pinjam untuk menyimpan beberapa informasi ... misalnya, seperti geometri yang kita tunjuk.  Pada gilirannya, dengan menambahkan sedikit pekerjaan, kita dapat membuat jalan kembali ke kemungkinan membuat analog panggilan ke fungsi virtual. <br><br>  Begini caranya: pertama kita mendefinisikan struktur <code>ShapeMethods</code> yang berisi pointer ke fungsi, seperti <sup>3</sup> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShapeMethods</span></span></span><span class="hljs-class"> {</span></span> Bounds3f (*WorldBound)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); <span class="hljs-comment"><span class="hljs-comment">// Intersect, etc. ... };</span></span></code> </pre> <br>  Setiap implementasi geometri akan mengimplementasikan fungsi kendala, fungsi persimpangan, dan seterusnya, menerima analog dari pointer <code>this</code> sebagai argumen pertama: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Bounds3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangleWorldBound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       Triangle. Triangle *tri = (Triangle *)t; // ...</span></span></code> </pre> <br>  Kita akan memiliki tabel global struktur <code>ShapeMethods</code> di mana elemen <em>ke</em> - <em>n</em> adalah untuk tipe geometri dengan indeks <em>n</em> : <br><br><pre> <code class="cpp hljs">ShapeMethods shapeMethods[] = { { TriangleWorldBound, <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> }, { CurveWorldBound, <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br>  Saat membuat geometri, kami menyandikan tipenya ke beberapa bit yang tidak digunakan dari pointer kembali.  Kemudian, dengan mempertimbangkan penunjuk ke geometri yang panggilan spesifiknya ingin kita lakukan, kita akan mengekstrak indeks tipe ini dari penunjuk dan menggunakannya sebagai indeks dalam <code>shapeMethods</code> untuk menemukan penunjuk fungsi yang sesuai.  Pada dasarnya, kami akan mengimplementasikan vtable secara manual, memproses pengiriman sendiri.  Jika kita melakukan ini baik untuk geometri dan untuk primitif, maka kita akan menghemat 16 byte per <code>Triangle</code> , tetapi pada saat yang sama kami membuat cara yang agak sulit. <br><br>  Saya kira peretasan seperti itu untuk mengimplementasikan manajemen fungsi virtual bukanlah hal baru, tetapi saya tidak dapat menemukan tautan ke sana di Internet.  Berikut adalah halaman Wikipedia tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pointer yang ditandai</a> , tetapi ia memang melihat hal-hal seperti jumlah tautan.  Jika Anda tahu tautan yang lebih baik, kirimkan saya surat. <br><br>  Dengan berbagi hack yang canggung ini, saya dapat menyelesaikan serangkaian posting.  Sekali lagi, banyak terima kasih kepada Disney untuk menerbitkan adegan ini.  Sangat menyenangkan untuk bekerja dengan;  roda gigi di kepalaku terus berputar. <br><br><h2>  Catatan </h2><br><ol><li>  Pada akhirnya, pbrt-next melacak lebih banyak sinar dalam adegan ini daripada pbrt-v3, yang mungkin menjelaskan peningkatan jumlah operasi pencarian. </li><li>  Perbedaan ray untuk sinar tidak langsung pada pbrt-next dihitung menggunakan retasan yang sama dengan yang digunakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekstensi cache tekstur</a> untuk pbrt-v3. ,     ,        . </li><li>   <a href="">Rayshade   </a> .   ,   C    .  Rayshade          . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417939/">https://habr.com/ru/post/id417939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417929/index.html">Kutipan dari buku â€œOne Day in the Life of the Brain. Neurobiologi kesadaran dari fajar hingga senja â€</a></li>
<li><a href="../id417931/index.html">Teknik Retensi Pemain: Contoh dari Game dari Berbagai Genre</a></li>
<li><a href="../id417933/index.html">Minggu Keamanan 27: iPhone Palsu dan Harga Keamanan</a></li>
<li><a href="../id417935/index.html">Memo tentang Kecerdasan Buatan, Pembelajaran Mesin, Pembelajaran Dalam, dan Big Data</a></li>
<li><a href="../id417937/index.html">Apakah "besi" orang membuat perangkat lunak?</a></li>
<li><a href="../id417941/index.html">Di mana air dalam ketel menghilang?</a></li>
<li><a href="../id417943/index.html">Serverless and React 2: Sleight of Hand dan No Fraud</a></li>
<li><a href="../id417945/index.html">Alat apa yang dimiliki probe surya Parker</a></li>
<li><a href="../id417947/index.html">Visualisasi data untuk proyek web Anda</a></li>
<li><a href="../id417949/index.html">Bagaimana saya menulis library C ++ 11 standar atau mengapa boost sangat menakutkan. Bab 4.2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>