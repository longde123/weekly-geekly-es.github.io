<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™…ğŸ» ğŸš£ğŸ» ğŸ´ Docker + Laravel = â¤ ğŸ•¦ ğŸ‚ğŸ¿ âš±ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini, saya akan berbicara tentang pengalaman saya "membungkus" aplikasi Laravel dalam wadah Docker sehingga pengembang frontend dan backe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker + Laravel = â¤</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425101/"><p><img src="https://habrastorage.org/getpro/habr/post_images/89c/b0e/91f/89cb0e91fd1efafb24b66b7ee44dc1b0.png" alt="laravel-in-docker"></p><br><p> Dalam artikel ini, saya akan berbicara tentang pengalaman saya "membungkus" aplikasi Laravel dalam wadah Docker sehingga pengembang frontend dan backend dapat bekerja secara lokal dengannya, dan meluncurkannya pada produksi sesederhana mungkin.  Selain itu, CI akan secara otomatis menjalankan analisis kode statis, tes <code>phpunit</code> , dan membuat gambar. </p><br><p>  "Dan apa, sebenarnya, kerumitan itu?"  - Anda bisa mengatakan, dan Anda akan sebagian benar.  Faktanya adalah bahwa cukup banyak diskusi dalam komunitas berbahasa Rusia dan berbahasa Inggris dikhususkan untuk topik ini, dan saya akan membagi secara kondisional hampir semua utas yang dipelajari ke dalam kategori berikut: </p><br><ul><li>  "Aku menggunakan buruh pelabuhan untuk pengembangan lokal. Aku meletakkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laradock</a> dan aku tidak tahu masalahnya."  Keren, tapi bagaimana dengan peluncuran otomatisasi dan produksi? </li><li>  "Saya mengumpulkan satu kontainer <em>(monolit)</em> berdasarkan <code>fedora:latest</code> (~ 230 Mb), memasukkan semua layanan (nginx, db, cache, dll) ke dalamnya, jalankan semua yang ada di dalam supervisor."  Juga luar biasa, mudah untuk memulai, tetapi bagaimana dengan ideologi "satu wadah - satu proses"?  Bagaimana dengan penyeimbangan dan manajemen proses?  Berapa ukuran gambar? </li><li>  "Ini potongan-potongan konfigurasi, bumbui dengan kutipan dari skrip-sh, tambahkan nilai sihir env, gunakan."  Terima kasih, tetapi bagaimana dengan setidaknya satu contoh hidup yang dapat saya mainkan dan mainkan sepenuhnya? </li></ul><br><p>  Semua yang Anda baca di bawah ini adalah pengalaman subjektif yang tidak berpura-pura sebagai kebenaran tertinggi.  Jika Anda memiliki tambahan atau indikasi ketidakakuratan - selamat datang di komentar. </p><br><blockquote>  Untuk yang tidak sabar - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ke repositori</a> , tiruan yang Anda dapat memulai aplikasi Laravel dengan satu perintah.  Juga tidak sulit untuk menjalankannya pada pemilik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peternakan yang</a> sama, dengan benar "menghubungkan" wadah-wadah, atau menggunakan versi belanjaan <code>docker-compose.yml</code> sebagai titik awal. </blockquote><a name="habracut"></a><br><h2 id="chast-teoreticheskaya">  Bagian teoretis </h2><br><p>  Alat apa yang akan kita gunakan dalam pekerjaan kita, dan apa yang akan kita fokuskan?  Pertama-tama, kita perlu menginstal host: </p><br><ul><li>  <code>docker</code> - pada saat penulisan, saya menggunakan versi <code>18.06.1-ce</code> </li><li>  <code>docker-compose</code> - ini mengatasi dengan menghubungkan kontainer dan menyimpan nilai-nilai lingkungan yang diperlukan;  versi <code>1.22.0</code> </li><li>  <code>make</code> - Anda mungkin akan terkejut, tetapi sangat cocok dengan konteks bekerja dengan buruh pelabuhan </li></ul><br><blockquote>  Anda dapat <code>curl -fsSL get.docker.com | sudo sh</code> <code>docker</code> pada sistem mirip- <code>debian</code> dengan perintah <code>curl -fsSL get.docker.com | sudo sh</code>  <code>curl -fsSL get.docker.com | sudo sh</code> , tetapi <code>docker-compose</code> lebih baik untuk menginstal menggunakan <code>pip</code> , karena versi terbaru tinggal di repositori-nya ( <code>apt</code> jauh di belakang, sebagai aturan). </blockquote><p>  Ini melengkapi daftar dependensi.  Apa yang akan Anda gunakan untuk bekerja dengan kode sumber - <code>phpstorm</code> , <code>netbeans</code> atau dead <code>vim</code> - terserah Anda. </p><br><p>  Selanjutnya adalah QA dadakan dalam konteks desain gambar <em>(saya tidak takut pada kata ini)</em> : </p><br><ul><li><p>  <strong>T: Gambar dasar - mana yang lebih baik untuk dipilih?</strong> </p><br></li><li><p>  <strong>A:</strong> Yang "lebih tipis", tanpa embel-embel.  Atas dasar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>alpine</code></a> <em>(~ 5 Mb),</em> Anda dapat mengumpulkan apa pun yang diinginkan hati Anda, tetapi kemungkinan besar Anda harus bermain dengan perakitan layanan dari sumbernya.  Sebagai alternatif - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>jessie-slim</code></a> <em>(~ 30 Mb)</em> .  Atau gunakan yang paling sering digunakan pada proyek Anda. </p><br></li><li><p>  <strong>T: Mengapa bobot gambar penting?</strong> </p><br></li><li><p>  <strong>A:</strong> Penurunan volume lalu lintas, penurunan probabilitas kesalahan saat mengunduh (lebih sedikit data - kurang probabilitas), penurunan tempat yang dikonsumsi.  Aturan "Gravity is reliable" (Â© "Snatch") tidak berfungsi dengan baik di sini. </p><br></li><li><p>  <strong>T: Tapi teman saya <code>%friend_name%</code> mengatakan bahwa gambar "monolitik" dengan semua-semua dependensi adalah cara terbaik.</strong> </p><br></li><li><p>  <strong>A:</strong> Mari kita hitung saja.  Aplikasi ini memiliki 3 dependensi - PG, Redis, PHP.  Dan Anda ingin menguji bagaimana perilakunya dalam bundel versi berbeda dari dependensi ini.  PG - versi 9.6 dan 10, Redis - 3.2 dan 4.0, PHP - 7.0 dan 7.2.  Seandainya setiap kecanduan adalah gambar yang terpisah - Anda memerlukan 6 di antaranya, yang bahkan tidak perlu Anda kumpulkan - semuanya sudah siap dan terletak di <code>hub.docker.com</code> .  Jika, karena alasan ideologis, semua dependensi "dikemas" dalam satu wadah, Anda harus merakitnya dengan pena ... 8 kali?  Sekarang tambahkan kondisi yang Anda masih ingin bermain dengan <code>opcache</code> .  Dalam kasus dekomposisi, ini hanyalah perubahan pada tag gambar yang digunakan.  Monolith lebih mudah dijalankan dan dipelihara, tetapi itu adalah jalan ke mana-mana. </p><br></li><li><p>  <strong>T: Mengapa penyelia dalam wadah itu jahat?</strong> </p><br></li><li><p>  <strong>A:</strong> Karena <code>PID 1</code> .  Jika Anda tidak ingin banyak masalah dengan proses zombie dan memiliki kemampuan untuk "menambah kapasitas" secara fleksibel jika perlu - cobalah menjalankan satu proses per wadah.  Pengecualian khusus adalah <code>nginx</code> dengan pekerjanya dan <code>php-fpm</code> , yang memiliki kemampuan untuk menghasilkan proses, tetapi harus tahan dengan ini (apalagi, mereka tidak buruk bereaksi terhadap <code>SIGTERM</code> , cukup benar "membunuh" pekerjanya).  Dengan meluncurkan semua iblis sebagai pengawas, Anda hampir pasti akan menemui kesulitan.  Meskipun, dalam beberapa kasus, sulit untuk melakukannya tanpanya, tetapi ini sudah merupakan pengecualian. </p><br></li></ul><br><p>  Setelah memutuskan pendekatan utama, mari beralih ke aplikasi kita.  Itu harus dapat: </p><br><ul><li>  <code>web|api</code> - berikan static dengan <code>nginx</code> , dan hasilkan konten dinamis dengan <code>fpm</code> </li><li>  <code>scheduler</code> - menjalankan penjadwal tugas asli </li><li>  <code>queue</code> - memproses pekerjaan dari antrian </li></ul><br><p>  Satu set dasar yang dapat diperluas jika perlu.  Sekarang mari kita beralih ke gambar yang harus kita kumpulkan agar aplikasi kita "lepas landas" (nama kode mereka diberikan dalam tanda kurung): </p><br><ul><li>  <code>PHP + PHP-FPM</code> ( <strong>app</strong> ) - lingkungan di mana kode kita akan dieksekusi.  Karena versi PHP dan FPM akan sama untuk kami - kami mengumpulkannya dalam satu gambar.  Jadi lebih mudah dikelola dengan konfigurasi, dan komposisi paket akan sama.  Tentu saja - FPM dan proses aplikasi akan berjalan dalam wadah yang berbeda </li><li>  <code>nginx</code> ( <strong>nginx</strong> ) - yang tidak akan mengganggu pengiriman konfigurasi dan modul opsional untuk <code>nginx</code> - kami akan mengumpulkan gambar terpisah dengannya.  Karena ini adalah layanan terpisah, ia memiliki file buruh pelabuhan dan konteksnya sendiri </li><li>  Sumber aplikasi ( <strong>sumber</strong> ) - sumber akan dikirim menggunakan gambar yang terpisah, dengan memasukkan <code>volume</code> dalam wadah dengan aplikasi.  Gambar dasar adalah <code>alpine</code> , di dalam hanya ada sumber dengan dependensi yang diinstal dan dikumpulkan menggunakan aset webpack (membangun artefak) </li></ul><br><p>  Layanan pengembangan lainnya diluncurkan dalam wadah, menariknya dari <code>hub.docker.com</code> ;  pada produksi, di sisi lain - mereka berjalan di server yang terpisah, berkerumun.  Yang tersisa bagi kita adalah memberi tahu aplikasi <em>(melalui lingkungan)</em> di mana alamat / port dan dengan rincian mana perlu mengetuk mereka.  Bahkan yang lebih keren adalah menggunakan penemuan-layanan untuk tujuan ini, tetapi tidak untuk saat ini. </p><br><p>  Setelah memutuskan pada bagian teoretis, saya mengusulkan pindah ke bagian selanjutnya. </p><br><h2 id="chast-prakticheskaya">  Bagian praktis </h2><br><p>  Saya sarankan mengatur file dalam repositori sebagai berikut: </p><br><pre> <code class="hljs css">. â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">docker</span></span> #    <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>   â”‚  â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">app</span></span> â”‚  â”‚  â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">Dockerfile</span></span> â”‚  â”‚  â””â”€â”€ ... â”‚  â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">nginx</span></span> â”‚  â”‚  â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">Dockerfile</span></span> â”‚  â”‚  â””â”€â”€ ... â”‚  â””â”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">sources</span></span> â”‚    â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">Dockerfile</span></span> â”‚    â””â”€â”€ ... â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">src</span></span> #   â”‚ â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">app</span></span> â”‚ â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">bootstrap</span></span> â”‚ â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">config</span></span> â”‚ â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">artisan</span></span> â”‚ â””â”€â”€ ... â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">docker-compose</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.yml</span></span> # <span class="hljs-selector-tag"><span class="hljs-selector-tag">Compose-</span></span>    â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">Makefile</span></span> â”œâ”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">CHANGELOG</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.md</span></span> â””â”€â”€ <span class="hljs-selector-tag"><span class="hljs-selector-tag">README</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.md</span></span></code> </pre> <br><blockquote>  Anda dapat membiasakan diri dengan struktur dan file dengan mengklik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ini</a> . </blockquote><p>  Untuk membangun layanan, Anda dapat menggunakan perintah: </p><br><pre> <code class="bash hljs">$ docker build \ --tag %local_image_name% \ -f ./docker/%service_directory%/Dockerfile ./docker/%service_directory%</code> </pre> <br><p>  Satu-satunya perbedaan adalah perakitan gambar dengan sumber - untuk itu, konteks perakitan (argumen ekstrem) <code>./src</code> diatur ke <code>./src</code> . </p><br><p>  Aturan untuk menamai gambar di registri lokal merekomendasikan menggunakan yang digunakan pembuat <code>docker-compose</code> <code>%root_directory_name%_%service_name%</code> secara default, yaitu: <code>%root_directory_name%_%service_name%</code> .  Jika direktori proyek bernama <code>my-awesome-project</code> , dan layanan ini bernama <code>redis</code> , maka nama gambar (lokal) masing-masing lebih baik untuk memilih <code>my-awesome-project_redis</code> . </p><br><blockquote>  Untuk mempercepat proses pembuatan, Anda dapat memberi tahu buruh pelabuhan untuk menggunakan cache dari gambar yang dirakit sebelumnya, dan untuk ini, <code>--cache-from %full_registry_name%</code> peluncuran <code>--cache-from %full_registry_name%</code> .  Dengan demikian, daemon buruh pelabuhan akan terlihat sebelum memulai instruksi tertentu di Dockerfile - apakah sudah berubah?  Dan jika tidak (hash menyatu) - ia akan melewati instruksi, menggunakan layer yang sudah disiapkan dari gambar, yang akan Anda kirim untuk digunakan sebagai cache.  Hal ini tidak buruk sehingga akan membangun kembali prosesnya, terutama jika tidak ada yang berubah :) <br><br>  Perhatikan skrip <code>ENTRYPOINT</code> untuk meluncurkan wadah aplikasi. </blockquote><p>  Gambar lingkungan untuk meluncurkan aplikasi (aplikasi) dikumpulkan dengan mempertimbangkan fakta bahwa itu akan bekerja tidak hanya pada produksi, tetapi juga secara lokal, pengembang perlu berinteraksi secara efektif dengannya.  Memasang dan menghapus dependensi <code>composer</code> , menjalankan <code>unit</code> test, log <code>tail</code> dan menggunakan alias yang sudah dikenal ( <code>php /app/artisan</code> â†’ <code>art</code> , <code>composer</code> â†’ <code>c</code> ) harus tanpa rasa tidak nyaman.  Selain itu - ini juga akan digunakan untuk menjalankan <code>unit</code> test dan analisa kode statis ( <code>phpstan</code> dalam kasus kami) di CI.  Itulah sebabnya Dockerfile-nya, misalnya, berisi jalur instalasi <code>xdebug</code> , tetapi modul itu sendiri tidak diaktifkan (hanya diaktifkan menggunakan CI). </p><br><blockquote>  Juga untuk <code>composer</code> paket <code>hirak/prestissimo</code> , yang sangat meningkatkan pemasangan semua dependensi. </blockquote><p>  Saat produksi, kami memasang konten direktori <code>/src</code> dari gambar dengan sumber (sumber) di dalamnya ke direktori <code>/app</code> .  Untuk pengembangan, kami â€œroll overâ€ direktori lokal dengan sumber aplikasi ( <code>-v "$(pwd)/src:/app:rw"</code> ). </p><br><p>  Dan di sini terletak satu kompleksitas - ini adalah <strong>hak akses ke file</strong> yang dibuat dari wadah.  Faktanya adalah bahwa secara default proses yang berjalan di dalam wadah mulai dari root ( <code>root:root</code> ), file yang dibuat oleh proses ini (cache, log, sesi, dll) - juga, dan sebagai hasilnya - Anda tidak memiliki sesuatu yang "lokal" dengan mereka Anda dapat melakukannya tanpa menjalankan <code>sudo chown -R $(id -u):$(id -g) /path/to/sources</code> . </p><br><p>  Sebagai satu solusi, gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fixuid</a> , tetapi solusi ini mudah.  Menurut saya cara terbaik untuk <code>USER_ID</code> lokal dan <code>GROUP_ID</code> - <code>GROUP_ID</code> di dalam wadah, dan <a href="">memulai proses dengan nilai-nilai ini</a> .  Secara default, mengganti nilai <code>1000:1000</code> (nilai default untuk pengguna lokal pertama) menyingkirkan panggilan <code>$(id -u):$(id -g)</code> , dan jika perlu, Anda selalu dapat menimpanya ( <code>$ USER_ID=666 docker-compose up -d</code> ) atau letakkan file docker-compose di file <code>.env</code> . </p><br><p>  Juga, ketika <code>php-fpm</code> diluncurkan secara lokal <code>php-fpm</code> lupa untuk menonaktifkan <code>opcache</code> darinya - jika tidak ada banyak "ya, apa-apaan!  Anda akan diberikan. </p><br><p>  Untuk koneksi "langsung" ke redis dan postgres, saya melemparkan port tambahan "keluar" (masing-masing <code>15432</code> dan <code>15432</code> ), sehingga tidak ada masalah dengan "menghubungkan dan melihat apa dan bagaimana sebenarnya" pada prinsipnya. </p><br><p>  Saya menjaga wadah dengan <code>app</code> nama kode berjalan (- <code>--command keep-alive.sh</code> ) untuk tujuan akses mudah ke aplikasi. </p><br><p>  Berikut adalah beberapa contoh pemecahan masalah sehari-hari dengan <code>docker-compose</code> : </p><br><table><thead><tr><th>  Operasi </th><th>  Menjalankan perintah </th></tr></thead><tbody><tr><td>  Instal paket <code>composer</code> </td><td> <code>$ docker-compose exec app composer require package/name</code> </td> </tr><tr><td>  Menjalankan phpunit </td><td> <code>$ docker-compose exec app php ./vendor/bin/phpunit --no-coverage</code> </td> </tr><tr><td>  Instal semua dependensi simpul </td><td> <code>$ docker-compose run --rm node npm install</code> </td> </tr><tr><td>  Instal paket simpul </td><td> <code>$ docker-compose run --rm node npm i package_name</code> </td> </tr><tr><td>  Meluncurkan pembangunan kembali aset secara langsung </td><td> <code>$ docker-compose run --rm node npm run watch</code> </td> </tr></tbody></table><br><p>  Anda dapat menemukan semua detail peluncuran di file <strong><a href="">docker-compose.yml</a></strong> . </p><br><h4 id="coy-make-zhiv"><del>  Choi </del>  <code>make</code> hidup! </h4><br><p>  Mengetik perintah yang sama setiap kali menjadi membosankan setelah yang kedua kalinya, dan karena programmer pada dasarnya adalah makhluk yang malas, mari masuk ke "otomatisasi" mereka.  Menyimpan seperangkat naskah adalah sebuah pilihan, tetapi tidak semenarik <code>Makefile</code> tunggal, terutama karena penerapannya dalam pengembangan modern sangat diremehkan. </p><br><blockquote>  Manual lengkap dalam bahasa Rusia dapat Anda temukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ini</a> . </blockquote><p>  Mari kita lihat bagaimana tampilan <code>make</code> di root repositori: </p><br><pre> <code class="bash hljs">[user@host ~/projects/app] $ make <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> Show this <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> app-pull Application - pull latest Docker image (from remote registry) app Application - build Docker image locally app-push Application - tag and push Docker image into remote registry sources-pull Sources - pull latest Docker image (from remote registry) sources Sources - build Docker image locally sources-push Sources - tag and push Docker image into remote registry nginx-pull Nginx - pull latest Docker image (from remote registry) nginx Nginx - build Docker image locally nginx-push Nginx - tag and push Docker image into remote registry pull Pull all Docker images (from remote registry) build Build all Docker images push Tag and push all Docker images into remote registry login Log <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> to a remote Docker registry clean Remove images from <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> registry --------------- --------------- up Start all containers (<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> background) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> development down Stop all started <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> development containers restart Restart all started <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> development containers shell Start shell into application container install Install application dependencies into application container watch Start watching assets <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> changes (node) init Make full application initialization (install, seed, build assets) <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Execute application tests Allowed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> overriding next properties: PULL_TAG - Tag <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pulling images before building own (<span class="hljs-string"><span class="hljs-string">'latest'</span></span> by default) PUBLISH_TAGS - Tags list <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> building and pushing into remote registry (delimiter - single space, <span class="hljs-string"><span class="hljs-string">'latest'</span></span> by default) Usage example: make PULL_TAG=<span class="hljs-string"><span class="hljs-string">'v1.2.3'</span></span> PUBLISH_TAGS=<span class="hljs-string"><span class="hljs-string">'latest v1.2.3 test-tag'</span></span> app-push</code> </pre> <br><p>  Dia sangat pandai dalam tujuan adiktif.  Misalnya, untuk mulai <code>watch</code> ( <code>docker-compose run --rm node npm run watch</code> ), Anda perlu aplikasi "dinaikkan" - Anda hanya perlu menentukan target <code>up</code> sebagai tergantung - dan Anda tidak perlu khawatir lupa melakukan hal ini sebelum menelepon <code>watch</code> - <code>make</code> dirinya akan melakukan segalanya untukmu.  Hal yang sama berlaku untuk menjalankan tes dan analisis statis, misalnya, sebelum melakukan perubahan - jalankan <code>make test</code> dan semua keajaiban akan terjadi untuk Anda! </p><br><p>  Tidak perlu dikatakan, Anda tidak perlu khawatir tentang mengumpulkan gambar, mengunduhnya, menentukan <code>--cache-from</code> dan hampir semuanya? </p><br><p>  Anda dapat melihat konten <code>Makefile</code> di <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ini</a></strong> . </p><br><h2 id="chast-avtomaticheskaya">  Bagian otomatis </h2><br><p>  Mari kita lanjutkan ke bagian akhir artikel ini - ini adalah otomatisasi proses memperbarui gambar di Docker Registry.  Meskipun dalam contoh saya GitLab CI digunakan - untuk mentransfer ide ke layanan integrasi lain, saya pikir itu akan sangat mungkin. </p><br><p>  Pertama-tama, kami akan menentukan penamaan tag gambar yang digunakan: </p><br><table><thead><tr><th>  Nama tag </th><th>  Tujuan </th></tr></thead><tbody><tr><td> <code>latest</code> </td> <td>  Gambar dikumpulkan dari cabang <code>master</code> . <br>  Keadaan kode adalah yang terbaru, tetapi belum siap untuk masuk ke rilis </td></tr><tr><td> <code>some-branch-name</code> </td> <td>  Gambar dikumpulkan pada brunch <code>some-branch-name</code> . <br>  Dengan demikian, kita dapat "meluncurkan" perubahan dalam lingkungan apa pun yang hanya diterapkan dalam kerangka kerja brunch tertentu sebelum menggabungkannya dengan <code>master</code> -light - cukup untuk "meregangkan" gambar dengan tag ini. <br>  Dan - ya, perubahan mungkin menyangkut kode dan gambar semua layanan secara umum! </td></tr><tr><td> <code>vX.XX</code> </td> <td>  Sebenarnya, rilis aplikasi (gunakan untuk menyebarkan versi tertentu) </td></tr><tr><td> <code>stable</code> </td> <td>  Alias, untuk tag dengan rilis terbaru (gunakan untuk menggunakan versi stabil terbaru) </td></tr></tbody></table><br><p>  Rilis ini dilakukan dengan menerbitkan tag dalam format <code>vX.XX</code> </p><br><p>  Untuk mempercepat pembangunan, caching direktori <code>./src/vendor</code> dan <code>./src/node_modules</code> + <code>--cache-from</code> untuk <code>docker build</code> , dan terdiri dari tahapan berikut: </p><br><table><thead><tr><th>  Nama panggung </th><th>  Tujuan </th></tr></thead><tbody><tr><td> <code>prepare</code> </td> <td>  Fase persiapan - perakitan gambar semua layanan <strong>kecuali</strong> gambar dengan sumbernya </td></tr><tr><td> <code>test</code> </td> <td>  Menguji aplikasi (menjalankan <code>phpunit</code> , penganalisa kode statis) menggunakan gambar yang <strong>dikumpulkan pada tahap persiapan</strong> </td></tr><tr><td> <code>build</code> </td> <td>  Menginstal semua dependensi <code>composer</code> ( <code>--no-dev</code> ), merakit <code>assets</code> <code>webpack</code> , dan merakit gambar dengan kode sumber <strong>termasuk artefak yang diterima</strong> ( <code>vendor/*</code> , <code>app.js</code> , <code>app.css</code> ) </td></tr></tbody></table><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8c2/873/625/8c2873625893ec1a0605e24bf85ef541.png" alt="tangkapan layar pipelines"></p><br><blockquote>  Perakitan pada cabang <code>master</code> menghasilkan <code>push</code> dengan tag <code>master</code> dan <code>latest</code> </blockquote><p>  Rata-rata, semua tahap perakitan memakan waktu <strong>4 menit</strong> , yang merupakan hasil yang cukup bagus (pelaksanaan tugas paralel adalah segalanya bagi kami). </p><br><p>  Anda dapat membiasakan diri dengan konten konfigurasi ( <strong><code>.gitlab-ci.yml</code></strong> ) dari kolektor di <strong><a href="">tautan ini</a></strong> . </p><br><h2 id="vmesto-zaklyucheniya">  Alih-alih sebuah kesimpulan </h2><br><p>  Seperti yang Anda lihat, mengorganisasikan pekerjaan dengan aplikasi php (menggunakan <code>Laravel</code> sebagai contoh) menggunakan Docker tidak begitu sulit.  Sebagai ujian, Anda dapat melakukan fork <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> , dan mengganti semua kemunculan <code>tarampampam/laravel-in-docker</code> dengan milik Anda - coba semuanya "hidup" sendiri. </p><br><p>  Untuk peluncuran lokal - jalankan hanya 2 perintah: </p><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://gitlab.com/tarampampam/laravel-in-docker.git ./laravel-in-docker &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> <span class="hljs-variable"><span class="hljs-variable">$_</span></span> $ make init</code> </pre> <br><p>  Kemudian buka <code>http://127.0.0.1:9999</code> di browser favorit Anda. </p><br><p>  <strong><em>... merebut peluang</em></strong> </p><br><p>  <em>Saat ini saya sedang mengerjakan proyek TL "autocode", dan kami sedang mencari pengembang dan administrator sistem php yang berbakat (kantor pengembangan berlokasi di Yekaterinburg).</em>  <em>Jika Anda menganggap diri Anda sebagai yang pertama atau kedua - tulis surat SDM kami dengan teks "Saya ingin menjadi tim pengembangan, lanjutkan:% link_on_summary%" ke email <code>hr@avtocod.ru</code> , kami membantu dengan relokasi.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425101/">https://habr.com/ru/post/id425101/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425089/index.html">TI di Dunia Satwa: Pencarian Makanan Semut dan TCP / IP</a></li>
<li><a href="../id425091/index.html">Apa yang terjadi dengan peringkat popularitas bahasa pemrograman?</a></li>
<li><a href="../id425093/index.html">Solusi IoT untuk layanan perumahan dan komunal: apa yang akan menjadi smart meter dan siapa yang harus melayani mereka?</a></li>
<li><a href="../id425095/index.html">Buka webinar "Game" 2048 "</a></li>
<li><a href="../id425099/index.html">Apa yang saya pahami dan masalah apa yang saya temui saat membuat klon Peretas Berita</a></li>
<li><a href="../id425103/index.html">Hentikan Google Predators Mengejar Anak-Anak Anda</a></li>
<li><a href="../id425105/index.html">Intel ME Manufacturing Mode - ancaman tersembunyi, atau apa yang ada di balik kerentanan CVE-2018-4251 di MacBook</a></li>
<li><a href="../id425107/index.html">Fintech digest: masalah biometrik pada ponsel, penyewaan ponsel Samsung, sekuritas pada blockchain</a></li>
<li><a href="../id425109/index.html">Buku â€œJava in the cloud. Spring Boot, Spring Cloud, Cloud Foundry Â»</a></li>
<li><a href="../id425111/index.html">Trik beriklan yang dapat membuat Anda kehilangan uang dan reputasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>