<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâüèΩ üèùÔ∏è üñï A mem√≥ria do computador fica a cada 7,8 Œºs üë©üèø‚Äçü§ù‚Äçüë®üèº ü¶ë üç¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SDRAM DDR3 moderno. Fonte: BY-SA / 4.0 by Kjerish 

 Durante uma recente visita ao Museu da Hist√≥ria do Computador em Mountain View, uma amostra antig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>A mem√≥ria do computador fica a cada 7,8 Œºs</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431010/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc7/f53/c6e/dc7f53c6eb17bfa58db7c138915bce84.jpg"></div><br>  <i><font color="gray">SDRAM DDR3 moderno.</font></i>  <i><font color="gray">Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BY-SA / 4.0 by Kjerish</a></font></i> <br><br>  Durante uma recente visita ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Museu da Hist√≥ria do Computador</a> em Mountain View, uma amostra antiga de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mem√≥ria</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ferrite</a> chamou minha aten√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b2/d31/5c6/2b2d315c67b80adcd5f0b5bf4dd23e7a.jpg"></div><br>  <i><font color="gray">Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BY-SA / 3.0 de Konstantin Lanzet</a></font></i> <br><a name="habracut"></a><br>  Cheguei rapidamente √† conclus√£o de que n√£o tenho ideia de como essas coisas funcionam.  Os an√©is giram (n√£o) e por que tr√™s fios passam por cada anel (ainda n√£o entendo como eles funcionam).  Mais importante, percebi que tenho muito pouca ideia de como funciona a moderna RAM din√¢mica! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fc/cb6/f41/7fccb6f418a426c7829b7e9bb1b5d3c3.png"></div><br>  <i><font color="gray">Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ciclo de Mem√≥ria de Ulrich Drapper</a></font></i> <br><br>  Eu estava particularmente interessado em uma das consequ√™ncias de como a RAM din√¢mica funciona.  Acontece que cada bit de dados √© armazenado por uma carga (ou sua aus√™ncia) em um pequeno capacitor no chip de RAM.  Mas esses capacitores perdem gradualmente sua carga ao longo do tempo.  Para evitar a perda de dados armazenados, eles devem ser atualizados regularmente para restaurar a cobran√ßa (se houver) ao seu n√≠vel original.  Esse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">processo de atualiza√ß√£o</a> envolve a leitura de cada bit e a grava√ß√£o novamente.  Durante esta "atualiza√ß√£o", a mem√≥ria est√° ocupada e n√£o pode executar opera√ß√µes normais, como gravar ou armazenar bits. <br><br>  Isso me incomodou por um longo tempo, e eu me perguntava ... √© poss√≠vel notar um atraso na atualiza√ß√£o no n√≠vel do programa? <br><br><h1>  Base de treinamento de atualiza√ß√£o din√¢mica de RAM </h1><br>  Cada DIMM consiste em "c√©lulas" e "linhas", "colunas", "lados" e / ou "fileiras".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Esta apresenta√ß√£o</a> da Universidade de Utah explica a nomenclatura.  A configura√ß√£o da mem√≥ria do computador pode ser verificada com o <code>decode-dimms</code> .  Aqui est√° um exemplo: <br><br><pre>  $ decode-dimms
 Tamanho 4096 MB
 Bancos x Linhas x Colunas x Bits 8 x 15 x 10 x 64
 Fileiras 2 </pre><br>  N√£o precisamos entender todo o esquema DDR DIMM, queremos entender a opera√ß√£o de apenas uma c√©lula que armazena um pouco de informa√ß√£o.  Mais precisamente, estamos interessados ‚Äã‚Äãapenas no processo de atualiza√ß√£o. <br><br>  Considere duas fontes: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tutorial de atualiza√ß√£o de DRAM</a> da Universidade de Utah </li><li>  E a excelente documenta√ß√£o de chips gigabit da Micron: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúProjetando o TN-46-09 para SDRAM DDR de 1Gb‚Äù</a> </li></ul><br>  Cada bit na mem√≥ria din√¢mica deve ser atualizado: isso geralmente acontece a cada 64 ms (a chamada atualiza√ß√£o est√°tica).  Esta √© uma opera√ß√£o bastante cara.  Para evitar uma grande parada a cada 64 ms, o processo √© dividido em 8192 opera√ß√µes de atualiza√ß√£o menores.  Em cada um deles, o controlador de mem√≥ria do computador envia comandos de atualiza√ß√£o para os chips DRAM.  Ap√≥s receber as instru√ß√µes, o chip atualizar√° 1/8192 c√©lulas.  Se voc√™ contar, ent√£o 64 ms / 8192 = 7812,5 ns ou 7,81 Œºs.  Isso significa o seguinte: <br><br><ul><li>  Um comando de atualiza√ß√£o √© executado a cada 7812,5 ns.  √â chamado tREFI. </li><li>  O processo de atualiza√ß√£o e recupera√ß√£o leva algum tempo, para que o chip possa executar novamente opera√ß√µes normais de leitura e grava√ß√£o.  O chamado tRFC √© igual a 75 ns ou 120 ns (como na documenta√ß√£o da Micron mencionada). </li></ul><br>  Se a mem√≥ria estiver quente (acima de 85 ¬∞ C), o tempo de armazenamento de dados na mem√≥ria diminuir√° e o tempo de atualiza√ß√£o est√°tica ser√° reduzido pela metade para 32 ms.  Consequentemente, o tREFI cai para 3906,25 ns. <br><br>  Um chip de mem√≥ria t√≠pico est√° ocupado atualizando por uma parte significativa de sua vida: de 0,4% a 5%.  Al√©m disso, os chips de mem√≥ria s√£o respons√°veis ‚Äã‚Äãpelo compartilhamento n√£o trivial do consumo de energia de um computador t√≠pico, e a maior parte desse poder √© gasta em atualiza√ß√µes. <br><br>  O chip de mem√≥ria inteiro est√° bloqueado durante a atualiza√ß√£o.  Ou seja, cada bit na mem√≥ria √© bloqueado por mais de 75 ns a cada 7812 ns.  Vamos medir. <br><br><h1>  Prepara√ß√£o da experi√™ncia </h1><br>  Para medir opera√ß√µes com precis√£o de nanossegundos, voc√™ precisa de um ciclo muito apertado, talvez em C. Parece o seguinte: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ...; i++) { <span class="hljs-comment"><span class="hljs-comment">//   . *(volatile int *) one_global_var; //   CPU.    _mm_clflush(one_global_var); //   ,     //    (25    160). // , - . asm volatile("mfence"); //     clock_gettime(CLOCK_MONOTONIC, &amp;ts); }</span></span></code> </pre> <br>  <a href="">O c√≥digo completo est√° dispon√≠vel no GitHub.</a> <br><br>  O c√≥digo √© muito simples.  Execute a leitura da mem√≥ria.  Despejamos dados do cache da CPU.  N√≥s medimos o tempo. <br><br>  (Nota: no <a href="">segundo experimento,</a> tentei usar o MOVNTDQA para carregar dados, mas isso requer uma p√°gina de mem√≥ria especial n√£o armazen√°vel em cache e direitos de root). <br><br>  No meu computador, o programa exibe os seguintes dados: <br><br><pre>  # timestamp, tempo de ciclo
 3101895733, 134
 3101895865, 132
 3101896002, 137
 3101896134, 132
 3101896268, 134
 3101896403, 135
 3101896762, 359
 3101896901, 139
 3101897038, 137 </pre><br>  Geralmente, √© obtido um ciclo com uma dura√ß√£o de cerca de 140 ns, periodicamente o tempo salta para cerca de 360 ‚Äã‚Äãns.  √Äs vezes, resultados estranhos aparecem acima de 3200 ns. <br><br>  Infelizmente, os dados s√£o muito barulhentos.  √â muito dif√≠cil verificar se h√° um atraso percept√≠vel associado aos ciclos de atualiza√ß√£o. <br><br><h1>  Transforma√ß√£o r√°pida de Fourier </h1><br>  Em algum momento, ocorreu-me.  Como queremos encontrar um evento com um intervalo fixo, podemos enviar dados para o algoritmo FFT (transforma√ß√£o r√°pida de Fourier), que descriptografa as principais frequ√™ncias. <br><br>  N√£o sou o primeiro a pensar sobre isso: Mark Seaborn com a famosa vulnerabilidade que <a href="">Rowhammer</a> implementou essa mesma t√©cnica em 2015.  Mesmo depois de analisar o c√≥digo de Mark, fazer a FFT funcionar foi mais dif√≠cil do que eu esperava.  Mas no final, juntei todas as pe√ßas. <br><br>  Primeiro voc√™ precisa preparar os dados.  A FFT requer entrada com um intervalo de amostragem constante.  Tamb√©m queremos cortar os dados para reduzir o ru√≠do.  Por tentativa e erro, descobri que o melhor resultado √© alcan√ßado ap√≥s o processamento preliminar dos dados: <br><br><ul><li>  Pequenos valores (abaixo da m√©dia de 1,8) das itera√ß√µes do loop s√£o cortados, ignorados e substitu√≠dos por zeros.  Realmente n√£o queremos fazer barulho. </li><li>  Todas as outras leituras s√£o substitu√≠das por unidades, uma vez que a amplitude do atraso causado por algum ru√≠do n√£o √© realmente importante para n√≥s. </li><li>  Eu estabeleci um intervalo de amostragem de 100 ns, mas qualquer n√∫mero at√© a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">frequ√™ncia Nyquist (dupla frequ√™ncia esperada) servir√°</a> . </li><li>  Os dados devem ser coletados em um hor√°rio fixo antes de serem enviados √† FFT.  Todos os m√©todos razo√°veis ‚Äã‚Äãde amostragem funcionam bem, decidi pela interpola√ß√£o linear b√°sica. </li></ul><br>  O algoritmo √© algo como isto: <br><br><pre> <code class="cpp hljs">UNIT=<span class="hljs-number"><span class="hljs-number">100</span></span>ns A = [(timestamp, loop_duration),...] p = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> curr_ts in frange(fist_ts, last_ts, UNIT): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>(A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].timestamp &lt;= curr_ts &lt; A[p].timestamp): p += <span class="hljs-number"><span class="hljs-number">1</span></span> v1 = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> avg*<span class="hljs-number"><span class="hljs-number">1.8</span></span> &lt;= A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].duration &lt;= avg*<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> v2 = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> avg*<span class="hljs-number"><span class="hljs-number">1.8</span></span> &lt;= A[p].duration &lt;= avg*<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> v = estimate_linear(v1, v2, A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].timestamp, curr_ts, A[p].timestamp) B.append( v )</code> </pre> <br>  Que em meus dados produz um vetor bastante chato como este: <br><br><pre>  [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...] </pre><br>  No entanto, o vetor √© bastante grande, geralmente cerca de 200 mil pontos de dados.  Com esses dados, voc√™ pode usar o FFT! <br><br><pre> <code class="cpp hljs">C = numpy.fft.fft(B) C = numpy.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(C) F = numpy.fft.fftfreq(len(B)) * (<span class="hljs-number"><span class="hljs-number">1000000000</span></span>/UNIT)</code> </pre> <br>  Muito simples, certo?  Isso produz dois vetores: <br><br><ul><li>  C cont√©m n√∫meros complexos de componentes de frequ√™ncia.  N√£o estamos interessados ‚Äã‚Äãem n√∫meros complexos, e voc√™ pode suaviz√°-los com o comando <code>abs()</code> . </li><li>  F cont√©m r√≥tulos, cujo intervalo de frequ√™ncia est√° em qual local do vetor C. N√≥s normalizamos o expoente em hertz multiplicando pela frequ√™ncia de amostragem do vetor de entrada. </li></ul><br>  O resultado pode ser plotado em um gr√°fico: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/580/d99/6ad/580d996adeb168c27821b2efb11bac2c.png"><br><br>  Eixo Y sem unidades, pois normalizamos o tempo de atraso.  Apesar disso, as rajadas s√£o claramente vis√≠veis em algumas faixas de frequ√™ncia fixas.  Vamos consider√°-los mais perto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf2/d37/2ed/bf2d372ed5483d677e1d775b863c6b76.png"><br><br>  Vemos claramente os tr√™s primeiros picos.  Ap√≥s um pouco de aritm√©tica inexpressiva, incluindo a leitura de filtragem pelo menos dez vezes a m√©dia, voc√™ pode extrair as frequ√™ncias b√°sicas: <br><br><pre>  127850.0
 127900.0
 127950.0
 255700.0
 255750.0
 255800.0
 255850.0
 255900.0
 255950.0
 383600.0
 383650.0 </pre><br>  Consideramos: 1000000000 (ns / s) / 127900 (Hz) = 7818,6 ns <br><br>  Viva!  O primeiro salto na frequ√™ncia √© realmente o que est√°vamos procurando e realmente se correlaciona com o tempo de atualiza√ß√£o. <br><br>  Os picos restantes em 256 kHz, 384 kHz, 512 kHz s√£o os chamados harm√¥nicos que s√£o m√∫ltiplos da nossa frequ√™ncia base de 128 kHz.  Esse √© o efeito colateral totalmente esperado da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aplica√ß√£o da FFT em algo como uma onda quadrada</a> . <br><br>  Para facilitar os experimentos, fizemos uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vers√£o para a linha de comando</a> .  Voc√™ pode executar o c√≥digo voc√™ mesmo.  Aqui est√° um exemplo de inicializa√ß√£o no meu servidor: <br><br><pre>  ~ / 2018-11-refresh-memory $ make
 gcc -msse4.1 -ggdb -O3 -Wall -Wextra measure-dram.c -o measure-dram
 ./measure-dram |  python3 ./analyze-dram.py
 [*] Verificando ASLR: main = 0x555555554890 pilha = 0x7fffffefe2ec
 [] Curiosidade.  Eu fiz 40663553 clock_gettime () por segundo
 [*] Medindo o tempo MOVQ + CLFLUSH.  Executando 131072 itera√ß√µes.
 [*] Gravando dados
 [*] Dados de entrada: min = 117 avg = 176 med = 167 max = 8172 itens = 131072
 [*] Intervalo de corte 212-inf
 [] 127849 itens abaixo do limite, 0 itens acima do limite, 3223 itens diferentes de zero
 [*] Executando FFT
 [*] A frequ√™ncia m√°xima acima de 2kHz abaixo de 250kHz tem magnitude de 7716
 [+] Os picos de frequ√™ncia superior a 2kHZ est√£o em:
 127906Hz 7716
 255813Hz 7947
 383720Hz 7460
 511626Hz 7141 </pre><br>  Devo admitir que o c√≥digo n√£o √© completamente est√°vel.  Em caso de problemas, √© recomend√°vel desativar o Turbo Boost, a escala de frequ√™ncia da CPU e a otimiza√ß√£o para desempenho. <br><br><h1>  Conclus√£o </h1><br>  Existem duas conclus√µes principais deste trabalho. <br><br>  Vimos que os dados de baixo n√≠vel s√£o bastante dif√≠ceis de analisar e parecem bastante barulhentos.  Em vez de avaliar a olho nu, voc√™ sempre pode usar a boa e velha FFT.  Na prepara√ß√£o dos dados, √© necess√°rio, em certo sentido, uma ilus√£o. <br><br>  Mais importante, mostramos que muitas vezes √© poss√≠vel medir o comportamento sutil do hardware a partir de um processo simples no espa√ßo do usu√°rio.  Esse tipo de pensamento levou √† descoberta da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vulnerabilidade original do Rowhammer</a> , que foi implementada nos ataques Meltdown / Spectre e novamente mostrada na recente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reencarna√ß√£o do Rowhammer para a mem√≥ria ECC</a> . <br><br>  Muito resta al√©m do escopo deste artigo.  Mal tocamos na opera√ß√£o interna do subsistema de mem√≥ria.  Para uma leitura mais aprofundada, recomendo: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapeando o cache L3 nos processadores Sandy Bridge</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como um endere√ßo f√≠sico √© mapeado para linhas e bancos na DRAM</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hannu Hartikainen invadiu a DDR3 SO-DIMM e a fez funcionar ... mais lentamente</a> </li></ul><br>  Finalmente, aqui est√° uma boa descri√ß√£o da antiga mem√≥ria de ferrite: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Explica√ß√£o da Mem√≥ria de Ferrite PDP-11 da Universidade de Sydney</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt431010/">https://habr.com/ru/post/pt431010/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430996/index.html">O bug indescrit√≠vel LittleBigPlanet</a></li>
<li><a href="../pt430998/index.html">Libera√ß√£o XMPP (Jabber) do servidor Prosody 0.11.0</a></li>
<li><a href="../pt431000/index.html">S√≠ndrome do encanamento: regras de c√≥digo legado para testes</a></li>
<li><a href="../pt431004/index.html">O sistema de reconhecimento facial chin√™s considerou a imagem de uma pessoa em um √¥nibus um infrator de tr√¢nsito</a></li>
<li><a href="../pt431006/index.html">O InSight est√° se preparando para pousar em Marte</a></li>
<li><a href="../pt431012/index.html">Crie um leitor de e-book usando o PDFKit no Swift</a></li>
<li><a href="../pt431014/index.html">Flexbox Infografia de tecnologia</a></li>
<li><a href="../pt431016/index.html">Os Estados Unidos pedem aos parceiros que abandonem o uso de equipamentos da Huawei</a></li>
<li><a href="../pt431018/index.html">Implementar um sistema de CRM? Tire os √≥culos cor de rosa</a></li>
<li><a href="../pt431020/index.html">Relat√≥rio do Club of Rome 2018, Cap√≠tulo 1.7 ‚ÄúCrescimento e urbaniza√ß√£o insustent√°veis ‚Äã‚Äãda popula√ß√£o‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>