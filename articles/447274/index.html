<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÖ üê∫ „Ä∞Ô∏è Lo que sucede detr√°s de escena C #: lo b√°sico para trabajar con la pila ‚ô£Ô∏è üôè üßõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Propongo mirar las partes internas que est√°n detr√°s de las l√≠neas simples de inicializaci√≥n de los objetos, los m√©todos de llamada y los par√°metros de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lo que sucede detr√°s de escena C #: lo b√°sico para trabajar con la pila</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447274/">  Propongo mirar las partes internas que est√°n detr√°s de las l√≠neas simples de inicializaci√≥n de los objetos, los m√©todos de llamada y los par√°metros de paso.  Y, por supuesto, utilizaremos esta informaci√≥n en la pr√°ctica: restaremos la pila del m√©todo de llamada. <br><br><h3>  Descargo de responsabilidad </h3><br>  Antes de continuar con la historia, le recomiendo que lea la primera publicaci√≥n sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">StructLayout</a> , hay un ejemplo que se utilizar√° en este art√≠culo. <br><br>  Todo el c√≥digo detr√°s del de alto nivel se presenta para el modo de <b>depuraci√≥n</b> , ya que muestra la base conceptual.  La optimizaci√≥n JIT es un gran tema separado que no se tratar√° aqu√≠. <br><br>  Tambi√©n me gustar√≠a advertir que este art√≠culo no contiene material que deba usarse en proyectos reales. <br><br><h3>  Primero - teor√≠a </h3><br>  Cualquier c√≥digo eventualmente se convierte en un conjunto de comandos de m√°quina.  Lo m√°s comprensible es su representaci√≥n en forma de instrucciones en lenguaje ensamblador que corresponden directamente a una (o varias) instrucciones de m√°quina. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ya/yv/k7/yayvk7f2o3tfr5flwaybim4u1m8.jpeg"></div><a name="habracut"></a><br>  Antes de pasar a un ejemplo simple, propongo familiarizarse con la pila.  <b>La pila</b> es principalmente una porci√≥n de memoria que se usa, por regla general, para almacenar varios tipos de datos (generalmente se les puede llamar <i>datos temporales</i> ).  Tambi√©n vale la pena recordar que la pila crece hacia direcciones m√°s peque√±as.  Es decir, cuanto m√°s tarde se coloque un objeto en la pila, menos direcci√≥n tendr√°. <br><br>  Ahora echemos un vistazo al siguiente fragmento de c√≥digo en lenguaje ensamblador (he omitido algunas de las llamadas que son inherentes al modo de depuraci√≥n). <br><br>  C #: <br><br><pre><code class="plaintext hljs">public class StubClass { public static int StubMethod(int fromEcx, int fromEdx, int fromStack) { int local = 5; return local + fromEcx + fromEdx + fromStack; } public static void CallingMethod() { int local1 = 7, local2 = 8, local3 = 9; int result = StubMethod(local1, local2, local3); } }</code> </pre> <br>  Asm: <br><br><pre> <code class="plaintext hljs">StubClass.StubMethod(Int32, Int32, Int32) 1: push ebp 2: mov ebp, esp 3: sub esp, 0x10 4: mov [ebp-0x4], ecx 5: mov [ebp-0x8], edx 6: xor edx, edx 7: mov [ebp-0xc], edx 8: xor edx, edx 9: mov [ebp-0x10], edx 10: nop 11: mov dword [ebp-0xc], 0x5 12: mov eax, [ebp-0xc] 13: add eax, [ebp-0x4] 14: add eax, [ebp-0x8] 15: add eax, [ebp+0x8] 16: mov [ebp-0x10], eax 17: mov eax, [ebp-0x10] 18: mov esp, ebp 19: pop ebp 20: ret 0x4 StubClass.CallingMethod() 1: push ebp 2: mov ebp, esp 3: sub esp, 0x14 4: xor eax, eax 5: mov [ebp-0x14], eax 6: xor edx, edx 7: mov [ebp-0xc], edx 8: xor edx, edx 9: mov [ebp-0x8], edx 10: xor edx, edx 11: mov [ebp-0x4], edx 12: xor edx, edx 13: mov [ebp-0x10], edx 14: nop 15: mov dword [ebp-0x4], 0x7 16: mov dword [ebp-0x8], 0x8 17: mov dword [ebp-0xc], 0x9 18: push dword [ebp-0xc] 19: mov ecx, [ebp-0x4] 20: mov edx, [ebp-0x8] 21: call StubClass.StubMethod(Int32, Int32, Int32) 22: mov [ebp-0x14], eax 23: mov eax, [ebp-0x14] 24: mov [ebp-0x10], eax 25: nop 26: mov esp, ebp 27: pop ebp 28: ret</code> </pre><br>  Lo primero que debe notar es el <b>EBP</b> y los registros <b>ESP</b> y las operaciones con ellos. <br><br>  Una idea err√≥nea de que el registro <b>EBP</b> est√° relacionado de alguna manera con el puntero a la parte superior de la pila es com√∫n entre mis amigos.  Debo decir que no lo es. <br><br>  El registro <b>ESP</b> es responsable de apuntar a la parte superior de la pila.  De manera correspondiente, con cada instrucci√≥n <b>PUSH</b> (poniendo un valor en la parte superior de la pila) se disminuye el valor del registro <b>ESP</b> (la pila crece hacia direcciones m√°s peque√±as), y con cada instrucci√≥n <b>POP</b> se incrementa.  Adem√°s, el comando <b>CALL</b> empuja la direcci√≥n de retorno en la pila, lo que disminuye el valor del registro <b>ESP</b> .  De hecho, el cambio del registro <b>ESP</b> se realiza no solo cuando se ejecutan estas instrucciones (por ejemplo, cuando se realizan llamadas de interrupci√≥n, lo mismo sucede con las instrucciones <b>CALL</b> ). <br><br>  Considerar√° <i>StubMethod ()</i> . <br><br>  En la primera l√≠nea, se guarda el contenido del registro <b>EBP</b> (se coloca en una pila).  Antes de regresar de una funci√≥n, este valor ser√° restaurado. <br><br>  La segunda l√≠nea almacena el valor actual de la direcci√≥n de la parte superior de la pila (el valor del registro <b>ESP</b> se mueve a <b>EBP</b> ).  A continuaci√≥n, movemos la parte superior de la pila a tantas posiciones como sea necesario para almacenar variables y par√°metros locales (tercera fila).  Algo as√≠ como la asignaci√≥n de memoria para todas las necesidades locales: <b>marco de pila</b> .  Al mismo tiempo, el registro <b>EBP</b> es un punto de partida en el contexto de la llamada actual.  El direccionamiento se basa en este valor. <br><br>  Todo lo anterior se llama <b>el pr√≥logo de la funci√≥n</b> . <br><br>  Despu√©s de eso, se accede a las variables en la pila a trav√©s del registro <b>EBP</b> almacenado, que apunta en el lugar donde comienzan las variables de este m√©todo.  Luego viene la inicializaci√≥n de variables locales. <br><br>  Recordatorio de <i>llamada r√°pida</i> : en .net, se utiliza la convenci√≥n de llamada de llamada <i>r√°pida</i> . <br>  La convenci√≥n de llamada gobierna la ubicaci√≥n y el orden de los par√°metros pasados ‚Äã‚Äãa la funci√≥n. <br>  Los par√°metros primero y segundo se pasan a trav√©s de los registros <b>ECX</b> y <b>EDX</b> , respectivamente, los par√°metros posteriores se transmiten a trav√©s de la pila.  (Esto es para sistemas de 32 bits, como siempre. En sistemas de 64 bits, cuatro par√°metros pasaron a trav√©s de registros ( <b>RCX</b> , <b>RDX</b> , <b>R8</b> , <b>R9</b> )) <br><br>  Para los m√©todos no est√°ticos, el primer par√°metro es impl√≠cito y contiene la direcci√≥n de la instancia en la que se llama el m√©todo (esta direcci√≥n). <br><br>  En las l√≠neas 4 y 5, los par√°metros que se pasaron a trav√©s de los registros (los primeros 2) se almacenan en la pila. <br><br>  Lo siguiente es limpiar el espacio en la pila para las variables locales ( <i>marco de la pila</i> ) e inicializar las variables locales. <br><br>  Cabe mencionar que el resultado de la funci√≥n est√° en el registro <b>EAX</b> . <br><br>  En las l√≠neas 12-16, se produce la adici√≥n de las variables deseadas.  Llamo su atenci√≥n a la l√≠nea 15. Hay un valor de acceso por la direcci√≥n que es mayor que el comienzo de la pila, es decir, a la pila del m√©todo anterior.  Antes de llamar, la persona que llama empuja un par√°metro a la parte superior de la pila.  Aqu√≠ lo leemos.  El resultado de la adici√≥n se obtiene del registro <b>EAX</b> y se coloca en la pila.  Como este es el valor de retorno de <i>StubMethod ()</i> , se vuelve a colocar en <b>EAX</b> .  Por supuesto, estos conjuntos de instrucciones absurdas son inherentes solo en el modo de depuraci√≥n, pero muestran exactamente c√≥mo se ve nuestro c√≥digo sin un optimizador inteligente que hace la mayor parte del trabajo. <br><br>  En las l√≠neas 18 y 19, se restauran tanto el <b>EBP</b> anterior (m√©todo de llamada) como el puntero a la parte superior de la pila (en el momento en que se llama al m√©todo).  La √∫ltima l√≠nea es el retorno de la funci√≥n.  Sobre el valor 0x4 lo contar√© un poco m√°s tarde. <br><br>  Tal secuencia de comandos se llama ep√≠logo de funci√≥n. <br><br>  Ahora echemos un vistazo a <i>CallingMethod ()</i> .  Vayamos directamente a la l√≠nea 18. Aqu√≠ colocamos el tercer par√°metro en la parte superior de la pila.  Tenga en cuenta que hacemos esto utilizando la instrucci√≥n <b>PUSH</b> , es decir, el valor <b>ESP</b> se reduce.  Los otros 2 par√°metros se colocan en registros ( <i>llamada r√°pida</i> ).  Luego viene la llamada al m√©todo <i>StubMethod ()</i> .  Ahora recordemos la instrucci√≥n <b>RET 0x4</b> .  Aqu√≠ es posible la siguiente pregunta: ¬øqu√© es 0x4?  Como mencion√© anteriormente, hemos introducido los par√°metros de la funci√≥n llamada en la pila.  Pero ahora no los necesitamos.  0x4 indica cu√°ntos bytes deben borrarse de la pila despu√©s de la llamada a la funci√≥n.  Como el par√°metro era uno, debe borrar 4 bytes. <br><br>  Aqu√≠ hay una imagen aproximada de la pila: <br><br><img src="https://habrastorage.org/webt/vz/eo/vz/vzeovzr2rvkuetuzi4xyp4iuxye.png"><br><br>  Por lo tanto, si nos damos la vuelta y vemos qu√© hay en la pila justo despu√©s de la llamada al m√©todo, lo primero que veremos es <b>EBP</b> , que se introdujo en la pila (de hecho, esto sucedi√≥ en la primera l√≠nea del m√©todo actual).  Lo siguiente ser√° la direcci√≥n del remitente.  Determina el lugar, all√≠ para reanudar la ejecuci√≥n despu√©s de que nuestra funci√≥n haya finalizado (utilizada por <b>RET</b> ).  Y justo despu√©s de estos campos veremos los par√°metros de la funci√≥n actual (a partir del 3er, los dos primeros par√°metros se pasan a trav√©s de los registros).  ¬°Y detr√°s de ellos se esconde la pila del m√©todo de llamada! <br><br>  Los campos primero y segundo mencionados anteriormente ( <b>EBP</b> y direcci√≥n de retorno) explican el desplazamiento en + 0x8 cuando accedemos a los par√°metros. <br><br>  En consecuencia, los par√°metros deben estar en la parte superior de la pila en un orden estrictamente definido antes de la llamada a la funci√≥n.  Por lo tanto, antes de llamar al m√©todo, cada par√°metro se inserta en la pila. <br>  Pero, ¬øqu√© pasa si no empujan y la funci√≥n a√∫n los tomar√°? <br><br><h3>  Peque√±o ejemplo </h3><br>  Por lo tanto, todos los hechos anteriores me han provocado un deseo abrumador de leer la pila del m√©todo que llamar√° mi m√©todo.  La idea de que solo estoy en una posici√≥n desde el tercer argumento (ser√° la m√°s cercana a la pila del m√©todo de llamada) son los datos apreciados que quiero recibir tanto, no me dejaron dormir. <br><br>  Por lo tanto, para leer la pila del m√©todo de llamada, necesito subir un poco m√°s all√° de los par√°metros. <br><br>  Cuando se hace referencia a par√°metros, el c√°lculo de la direcci√≥n de un par√°metro particular se basa solo en el hecho de que la persona que llama los ha empujado a todos a la pila. <br><br>  Pero el paso impl√≠cito a trav√©s del par√°metro <b>EDX</b> (qui√©n est√° interesado - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior</a> ) me hace pensar que podemos ser m√°s astutos que el compilador en algunos casos. <br><br>  La herramienta que sol√≠a hacer esto se llama StructLayoutAttribute (todas las caracter√≠sticas est√°n en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el primer art√≠culo</a> ).  // Alg√∫n d√≠a aprender√© un poco m√°s que solo este atributo, lo prometo <br><br>  Utilizamos el mismo m√©todo favorito con tipos de referencia superpuestos. <br><br>  Al mismo tiempo, si los m√©todos superpuestos tienen un n√∫mero diferente de par√°metros, el compilador no inserta los necesarios en la pila (al menos porque no sabe cu√°les). <br>  Sin embargo, el m√©todo que realmente se llama (con el mismo desplazamiento de un tipo diferente), se convierte en direcciones positivas en relaci√≥n con su pila, es decir, aquellas en las que planea encontrar los par√°metros. <br><br>  Pero nadie pasa par√°metros y el m√©todo comienza a leer la pila del m√©todo de llamada.  Y la direcci√≥n del objeto (con la propiedad Id, que se usa en <i>WriteLine ()</i> ) est√° en el lugar, donde se espera el tercer par√°metro. <br><br><div class="spoiler">  <b class="spoiler_title">El c√≥digo est√° en el spoiler.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">using System; using System.Runtime.InteropServices; namespace Magic { public class StubClass { public StubClass(int id) { Id = id; } public int Id; } [StructLayout(LayoutKind.Explicit)] public class CustomStructWithLayout { [FieldOffset(0)] public Test1 Test1; [FieldOffset(0)] public Test2 Test2; } public class Test1 { public virtual void Useless(int skipFastcall1, int skipFastcall2, StubClass adressOnStack) { adressOnStack.Id = 189; } } public class Test2 { public virtual int Useless() { return 888; } } class Program { static void Main() { Test2 objectWithLayout = new CustomStructWithLayout { Test2 = new Test2(), Test1 = new Test1() }.Test2; StubClass adressOnStack = new StubClass(3); objectWithLayout.Useless(); Console.WriteLine($"MAGIC - {adressOnStack.Id}"); // MAGIC - 189 } } }</code> </pre><br></div></div><br>  No dar√© el c√≥digo del lenguaje ensamblador, todo est√° bastante claro all√≠, pero si hay alguna pregunta, intentar√© responderla en los comentarios <br><br>  Entiendo perfectamente que este ejemplo no se puede usar en la pr√°ctica, pero en mi opini√≥n, puede ser muy √∫til para comprender el esquema general de trabajo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/447274/">https://habr.com/ru/post/447274/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447262/index.html">Acelerando el sitio con JivoSite. Descarga diferida de consultor en l√≠nea</a></li>
<li><a href="../447264/index.html">Encender la cuadr√≠cula de servicio: reiniciar</a></li>
<li><a href="../447266/index.html">Lenguaje y √≥rganos sensoriales</a></li>
<li><a href="../447268/index.html">Microsoft Azure Security Center anuncia nuevas caracter√≠sticas</a></li>
<li><a href="../447270/index.html">BGP herida perforante</a></li>
<li><a href="../447276/index.html">¬øQu√© es la biblioteca ITIL y por qu√© su empresa la necesita?</a></li>
<li><a href="../447278/index.html">Estonia est√° tratando de usar la IA en la justicia</a></li>
<li><a href="../447280/index.html">Nivelar cuentas de juegos en China: un negocio serio y un dolor de cabeza para los desarrolladores</a></li>
<li><a href="../447282/index.html">Errores de programadores de sistemas y aplicaciones atrapados en la interfaz (art√≠culo eliminado)</a></li>
<li><a href="../447284/index.html">Actualice las herramientas web y Azure en Visual Studio 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>