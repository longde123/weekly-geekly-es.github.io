<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿 🤟🏿 📳 Ein praktisches Beispiel für die Erstellung einer eigenen View-Komponente 👨‍🚒 🍅 🙆🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich mag Dribbble . Es gibt viele coole und inspirierende Designprojekte. Aber wenn Sie ein Entwickler sind, wird das Gefühl der Schönheit oft schnell ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein praktisches Beispiel für die Erstellung einer eigenen View-Komponente</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433782/"><p><img src="https://habrastorage.org/getpro/habr/post_images/5c6/ece/f09/5c6ecef09bce1d621d5127f0e49338d1.jpg" alt="Ein praktisches Beispiel für die Erstellung einer eigenen View-Komponente"></p><br><p> Ich mag <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dribbble</a> .  Es gibt viele coole und inspirierende Designprojekte.  Aber wenn Sie ein Entwickler sind, wird das Gefühl der Schönheit oft schnell durch Verzweiflung ersetzt, wenn Sie darüber nachdenken, wie Sie dieses coole Design implementieren können. </p><br><p>  In diesem Artikel werde ich Ihnen ein Beispiel für ein solches Design und seine Implementierung zeigen, aber lassen Sie uns vorher über die Lösung des Problems als Ganzes sprechen. </p><a name="habracut"></a><br><p>  Am einfachsten ist es, eine Bibliothek zu verwenden, die unsere Anforderungen erfüllt.  Versteh mich jetzt nicht falsch, ich bin ein großer Befürworter des Ansatzes "Das Rad nicht neu erfinden".  Es gibt großartige Open-Source-Bibliotheken, und wenn ich Bilder hochladen oder die REST-API implementieren muss, helfen mir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Glide</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Picasso</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Retrofit</a> sehr. </p><br><p>  Wenn Sie jedoch ein ungewöhnliches Design implementieren müssen, ist dies nicht immer die beste Wahl.  Sie müssen Zeit damit verbringen, nach einer guten, unterstützten Bibliothek zu suchen, die etwas Ähnliches tut.  Dann müssen Sie in den Code schauen, um sicherzustellen, dass dort etwas Angemessenes geschrieben ist.  Sie müssen mehr Zeit darauf verwenden, die Einstellungen und Konfigurationen zu verstehen, mit denen Sie die Bibliothek für Ihre Aufgaben verwenden können.  Und seien wir ehrlich, höchstwahrscheinlich wird die Bibliothek Ihre Anforderungen nicht zu 100% decken, und Sie müssen einige Kompromisse mit Designern eingehen. </p><br><p> Daher sage ich, dass es oft einfacher und besser ist, eine eigene <code>View</code> Komponente zu erstellen.  Wenn ich "native <code>onDraw()</code> " sage, meine ich die Erweiterung der <code>View</code> Klasse, die die <code>onDraw()</code> -Methode überschreibt und <code>Paint</code> und <code>Canvas</code> zum Zeichnen der <code>View</code> Komponente verwendet.  Dies mag beängstigend erscheinen, wenn Sie es noch nicht getan haben, da diese Klassen viele Methoden und Eigenschaften haben, aber Sie können sich auf die wichtigsten konzentrieren: </p><br><ul><li><p>  <code>canvas.drawRect()</code> - <code>canvas.drawRect()</code> die Koordinaten der Ecken an und zeichnen Sie ein Rechteck. </p><br></li><li><p>  <code>canvas.drawRoundRect()</code> - <code>canvas.drawRoundRect()</code> optional den Radius an, und die Ecken des Rechtecks ​​werden gerundet. </p><br></li><li><p>  <code>canvas.drawPath()</code> ist eine komplexere, aber auch leistungsstärkere Methode, um mithilfe von Linien und Kurven eine eigene Form zu erstellen. </p><br></li><li><p>  <code>canvas.drawText()</code> - zum Zeichnen von Text auf Leinwand (mit <code>Paint</code> Sie die Größe, Farbe und andere Eigenschaften steuern); </p><br></li><li><p>  <code>canvas.drawCircle()</code> - <code>canvas.drawCircle()</code> den Mittelpunkt und den Radius an und erhalten Sie einen Kreis. </p><br></li><li><p>  <code>canvas.drawArc()</code> - <code>canvas.drawArc()</code> das Begrenzungsrechteck sowie die Start- und <code>canvas.drawArc()</code> zum Zeichnen des Bogens an. </p><br></li><li><p>  <code>paint.style</code> - <code>paint.style</code> an, ob die gezeichnete Form gefüllt, eingekreist oder beides sein wird. </p><br></li><li><p>  <code>paint.color</code> - gibt die Farbe an (einschließlich Transparenz); </p><br></li><li><p>  <code>paint.strokeWidth</code> - steuert die Breite für Strichformen; </p><br></li><li><p>  <code>paint.pathEffect</code> - Mit dieser <code>paint.pathEffect</code> können Sie die Geometrie der gezeichneten Figur beeinflussen. </p><br></li><li><p>  <code>paint.shader</code> - Ermöglicht das Zeichnen von Verläufen. </p><br></li></ul><br><p>  Denken Sie daran, dass Sie manchmal andere APIs verwenden müssen, aber selbst wenn Sie diese Methoden beherrschen, können Sie sehr komplexe Formen zeichnen. </p><br><h2 id="prakticheskiy-primer">  Praktisches Beispiel </h2><br><p>  Hier ist ein Design, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pepper</a> uns anbietet: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f9a/033/e21/f9a033e211e7dae32ea25a6449017765.png" alt="Design"></p><br><p>  Hier gibt es viele interessante Dinge, aber lassen Sie uns alles in kleine Stücke zerlegen. </p><br><h3 id="shag-1-rasschitat-pozicii-markerov">  Schritt 1. Berechnen Sie die Markerpositionen </h3><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcPositions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(markers: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Marker</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> max = markers.maxBy { it.value } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> min = markers.minBy { it.value } pxPerUnit = chartHeight / (max - min) zeroY = max * pxPerUnit + paddingTop <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> step = (width - <span class="hljs-number"><span class="hljs-number">2</span></span> * padding - scalesWidth) / (markers.size - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((i, marker) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> markers.withIndex()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = step * i + paddingLeft <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y = zeroY - entry.value * pxPerUnit marker.currentPos.x = x marker.currentPos.y = y } }</code> </pre> <br><p>  Wir finden die Minimal- und Maximalwerte, berechnen das Verhältnis der Pixel pro Einheit, die horizontale Schrittgröße zwischen den Markierungen und den X- und Y-Positionen. </p><br><h3 id="shag-2-narisovat-gradient">  Schritt 2. Zeichnen Sie einen Farbverlauf </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/526/055/4f9/5260554f9e4702b526931cf68dac8bef.png" alt="Farbverlauf"></p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// prepare the gradient paint val colors = intArrayOf(colorStart, colorEnd)) val gradient = LinearGradient( 0f, paddingTop, 0f, zeroY, colors, null, CLAMP ) gradientPaint.style = FILL gradientPaint.shader = gradient private fun drawGradient(canvas: Canvas) { path.reset() path.moveTo(paddingLeft, zeroY) for (marker in markers) { path.lineTo(marker.targetPos.x, entry.targetPos.y) } // close the path path.lineTo(markers.last().targetPos.x, zeroY) path.lineTo(paddingLeft, zeroY) canvas.drawPath(path, gradientPaint) }</span></span></code> </pre> <br><p>  Wir erstellen eine Form beginnend am linken Rand, zeichnen eine Linie zwischen den einzelnen Markierungen und beenden die Form am Startpunkt.  Zeichnen Sie diese Form dann mit Farbe mit einem Farbverlaufs-Shader. </p><br><h3 id="shag-3-narisovat-setku">  Schritt 3. Zeichnen Sie ein Raster </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bbc/a14/ded/bbca14ded078fcf450e80f3451eb8988.png" alt="Mesh"></p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// prepare the guideline paint dottedPaint.style = STROKE dottedPaint.strokeWidth = DOTTED_STROKE_WIDTH_DP dottedPaint.pathEffect = DashPathEffect(floatArrayOf(INTERVAL, INTERVAL), 0f) private fun drawGuidelines(canvas: Canvas) { val first = findFirstDayOfWeekInMonth(markers) for (i in first..markers.lastIndex step 7) { val marker = markers[i] guidelinePath.reset() guidelinePath.moveTo(entry.currentPos.x, paddingTop) guidelinePath.lineTo(entry.currentPos.x, zeroY) canvas.drawPath(guidelinePath, dottedPaint) } }</span></span></code> </pre> <br><p>  Wir setzen die Farbe so, dass sie mit einer gepunkteten Linie gezeichnet wird.  Dann verwenden wir den speziellen Kotlin-Sprachzyklus, mit dem wir die Markierungen in Schritten von 7 (der Anzahl der Tage in einer Woche) durchlaufen können.  Für jeden Marker nehmen wir die X-Koordinate und zeichnen eine vertikale gepunktete Linie vom oberen <code>zeroY</code> des Diagramms bis <code>zeroY</code> . </p><br><h3 id="shag-4-narisovat-grafik-i-markery">  Schritt 4. Zeichnen Sie ein Diagramm und Markierungen </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4f1/a4d/e8c/4f1a4de8cc3e5b40fff2dd71a77d4e0a.png" alt="Diagramm und Marker"></p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawLineAndMarkers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(canvas: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Canvas</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> previousMarker: Marker? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (marker <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> markers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousMarker != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// draw the line val p1 = previousMarker.currentPos val p2 = marker.currentPos canvas.drawLine(p1.x, p1.y, p2.x, p2.y, strokePaint) } previousMarker = marker // draw the marker canvas.drawCircle( marker.currentPos.x, marker.currentPos.y, pointRadius, pointPaint ) } }</span></span></code> </pre> <br><p>  Wir gehen durch die Markierungen, zeichnen für jede einen gefüllten Kreis und eine einfache Linie von der vorherigen Markierung zur aktuellen. </p><br><h3 id="shag-5-narisovat-knopki-nedel">  Schritt 5. Zeichnen Sie die Wochenschaltflächen </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e4a/113/85b/e4a11385be04e7b7094597339a291f88.png" alt="Wochen-Schaltflächen"></p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawWeeks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(canvas: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Canvas</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((i, week) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> weeks.withIndex()) { textPaint.getTextBounds(week, <span class="hljs-number"><span class="hljs-number">0</span></span>, week.length, rect) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = middle(i) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y = zeroY + rect.height() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> halfWidth = rect.width() / <span class="hljs-number"><span class="hljs-number">2f</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> halfHeight = rect.height() / <span class="hljs-number"><span class="hljs-number">2f</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> left = x - halfWidth - padding <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> top = y - halfHeight - padding <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> right = x + halfWidth + padding <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bottom = y + halfHeight + padding rect.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(left, top, right, bottom) paint.color = bgColor paint.style = FILL canvas.drawRoundRect(rect, radius, radius, paint) paint.color = strokeColor paint.style = STROKE canvas.drawRoundRect(rect, radius, radius, paint) canvas.drawText(week, x, keyY, textPaint) } }</code> </pre> <br><p>  Wir gehen die Wochenmarkierungen durch, finden die X-Koordinate der Wochenmitte und zeichnen die Schaltfläche in Ebenen: Zuerst zeichnen wir einen Hintergrund mit abgerundeten Ecken, dann einen Rand und schließlich Text.  Wir passen die Farbe an, bevor wir jede Ebene zeichnen. </p><br><h3 id="shag-6-narisovat-chislovye-markery-sprava">  Schritt 6. Zeichnen Sie die numerischen Markierungen rechts </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5e2/fca/38c/5e2fca38cd0c3160c240cee8458d839f.png" alt="Numerische Markierungen"></p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawGraduations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(canvas: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Canvas</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = markers.last().currentPos.x + padding <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graduations) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y = zeroY - scale * pxPerUnit <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> formatted = NumberFormat.getIntegerInstance().format(value) canvas.drawText(formatted, x, y, textPaint) } }</code> </pre> <br><p>  Die X-Koordinate ist die Position des letzten Markers plus einer Einrückung.  Die Y-Koordinate wird anhand des Pixelverhältnisses pro Einheit berechnet.  Wir formatieren die Zahl in eine Zeichenfolge (fügen Sie bei Bedarf ein Tausendertrennzeichen hinzu) und zeichnen den Text. </p><br><p>  Das ist alles, jetzt <code>onDraw()</code> unser <code>onDraw()</code> so aus: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDraw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(canvas: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Canvas</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { drawGradient(canvas) drawGuidelines(canvas) drawLineAndMarkers(canvas) drawWeeks(canvas) drawGraduations(canvas) }</code> </pre> <br><p>  Durch das Kombinieren der Ebenen erhalten wir das gewünschte Ergebnis: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/051/51e/d11/05151ed1197c4ae9f95d4dab4c3f54c2.png" alt="Ergebnis"></p><br><h2 id="itog">  Zusammenfassung </h2><br><ol><li>  Haben Sie keine Angst, eigene <code>View</code> Komponenten zu erstellen (falls erforderlich). </li><li>  Lernen Sie die grundlegenden <code>Canvas</code> und <code>Paint</code> APIs kennen. </li><li>  Teilen Sie Ihr Design in kleine Ebenen auf und zeichnen Sie jede einzeln. </li></ol><br><p>  Was den letzten Punkt betrifft, so ist dies für mich eine der besten Programmierlektionen im Allgemeinen: Wenn Sie mit einer großen und komplexen Aufgabe konfrontiert werden, teilen Sie sie in kleinere, einfachere Aufgaben auf. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433782/">https://habr.com/ru/post/de433782/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433770/index.html">Die Wissenschaft der Arbeitssuche, Teil VII: Nur 50% der „Anforderungen“ einer offenen Stelle müssen erfüllt werden</a></li>
<li><a href="../de433772/index.html">Computer Vision Annotation Tool: Datenmarkierung aus einer Hand</a></li>
<li><a href="../de433774/index.html">Wer macht TeamLead Conf und warum?</a></li>
<li><a href="../de433776/index.html">MongoDB Go Treiber Tutorial</a></li>
<li><a href="../de433780/index.html">Übergang vom UI-Kit zum Design-System in QIWI</a></li>
<li><a href="../de433786/index.html">Fintech Digest: Kryptowährung ist Eigentum, eine Rekordzahl von Kreditkarten wurde in der Russischen Föderation ausgestellt</a></li>
<li><a href="../de433788/index.html">Secure Deal und neue freiberufliche Bewertungen</a></li>
<li><a href="../de433790/index.html">Erweiterte mehrstufige Build-Vorlagen</a></li>
<li><a href="../de433792/index.html">Shell-Skripte in Ansible</a></li>
<li><a href="../de433796/index.html">Wie Homo Sapiens die Welt eroberte. Kommunikations- und Verhandlungsfähigkeiten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>