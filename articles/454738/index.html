<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞üèæ üë®üèΩ‚Äçüè≠ üíÖüèæ Soporte de Visual Studio 2019 en PVS-Studio ‚ûø üë®üèø‚Äçüîß üëÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El soporte para Visual Studio 2019 en PVS-Studio afect√≥ inmediatamente a varios componentes diferentes: el complemento IDE en s√≠, la aplicaci√≥n de an√°...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Soporte de Visual Studio 2019 en PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/454738/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de3/aea/16e/de3aea16e3b6472a4d5034fd035d8827.png"></div><br>  El soporte para Visual Studio 2019 en PVS-Studio afect√≥ inmediatamente a varios componentes diferentes: el complemento IDE en s√≠, la aplicaci√≥n de an√°lisis de l√≠nea de comandos, los analizadores C ++ y C #, as√≠ como varias utilidades.  Hablar√© brevemente sobre los problemas que encontramos al admitir la nueva versi√≥n del IDE y c√≥mo resolverlos. <br><a name="habracut"></a><br>  Antes de comenzar, quiero mirar un poco hacia atr√°s para rastrear el historial de soporte para versiones anteriores de Visual Studio, lo que dar√° una mejor comprensi√≥n de nuestra visi√≥n de la tarea y las decisiones tomadas en ciertas situaciones. <br><br>  Comenzando con la primera versi√≥n del analizador PVS-Studio, en el que apareci√≥ el complemento para el entorno de Visual Studio (entonces era la versi√≥n de Visual Studio 2005), admitir nuevas versiones de Visual Studio fue una tarea bastante simple para nosotros: b√°sicamente se redujo a actualizar el archivo de proyecto del complemento y dependencias de varias API de extensi√≥n de Visual Studio.  A veces era necesario admitir adicionalmente nuevas caracter√≠sticas del lenguaje C ++, que el compilador de Visual C ++ estaba aprendiendo gradualmente, pero esto tampoco sol√≠a causar problemas inmediatamente antes del lanzamiento de la pr√≥xima edici√≥n de Visual Studio.  Y solo hab√≠a un analizador en PVS-Studio para los lenguajes C y C ++. <br><br>  Todo cambi√≥ para el lanzamiento de Visual Studio 2017. Adem√°s del hecho de que muchas de las API de extensi√≥n para este IDE cambiaron muy significativamente en esta versi√≥n, despu√©s de la actualizaci√≥n tuvimos problemas para garantizar la compatibilidad con el trabajo del nuevo analizador C # que hab√≠a aparecido en ese momento (as√≠ como nuestra nueva capa C ++). analizador para proyectos de MSBuild) con versiones anteriores de MSBuild \ Visual Studio. <br><br>  Por lo tanto, antes de leer este art√≠culo, le recomiendo que lea el art√≠culo relacionado sobre el soporte de Visual Studio 2017: "Soporte de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Visual Studio 2017 y Roslyn 2.0 en PVS-Studio: a veces, usar soluciones preparadas no es tan f√°cil como parece a primera vista</a> ".  El art√≠culo mencionado anteriormente describe los problemas que encontramos la √∫ltima vez, as√≠ como los esquemas de interacci√≥n de varios componentes (por ejemplo, PVS-Studio, MSBuild, Roslyn).  Entender esta interacci√≥n ser√° √∫til al leer este art√≠culo. <br><br>  En √∫ltima instancia, la soluci√≥n a estos problemas trajo cambios significativos a nuestro analizador y, como esper√°bamos, los nuevos enfoques que aplicamos permitir√°n que las versiones actualizadas de Visual Studio \ MSBuild sean mucho m√°s f√°ciles y r√°pidas en el futuro.  En parte, esta suposici√≥n ya ha sido confirmada por el lanzamiento de numerosas actualizaciones de Visual Studio 2017. ¬øEste nuevo enfoque ayud√≥ con el soporte de Visual Studio 2019?  Sobre esto a continuaci√≥n. <br><br><h2>  PVS-Studio Plugin para Visual Studio 2019 </h2><br>  Todo comenz√≥, al parecer, no est√° mal.  Fue bastante f√°cil portar el complemento a Visual Studio 2019, donde comenz√≥ y funcion√≥ bien.  A pesar de esto, se revelaron 2 problemas de inmediato, que promet√≠an problemas futuros. <br><br>  La primera es la interfaz <i>IVsSolutionWorkspaceService</i> , que se utiliza para admitir el modo de carga de soluci√≥n ligera, que, por cierto, se deshabilit√≥ en una de las actualizaciones anteriores en Visual Studio 2017, se decor√≥ con el atributo <i>Desaprobado</i> , que era solo una advertencia durante el ensamblaje, pero promet√≠a m√°s en el futuro problemas  Microsoft introdujo r√°pidamente este modo y lo abandon√≥ ... Nos ocupamos de este problema de manera bastante simple: nos negamos a usar la interfaz adecuada. <br><br>  El segundo: al cargar Visual Studio con el complemento, apareci√≥ el siguiente mensaje: <i>Visual Studio ha detectado una o m√°s extensiones que est√°n en riesgo o que no funcionan en una actualizaci√≥n VS de funci√≥n.</i> <br><br>  Ver los registros de inicio de Visual Studio (archivo ActivityLog) finalmente salpic√≥ la 'i': <br><br>  <i>Advertencia: La extensi√≥n 'PVS-Studio' usa la caracter√≠stica 'carga autom√°tica s√≠ncrona' de Visual Studio.</i>  <i>Esta caracter√≠stica ya no ser√° compatible en una futura actualizaci√≥n de Visual Studio 2019, momento en el que esta extensi√≥n no funcionar√°.</i>  <i>P√≥ngase en contacto con el proveedor de la extensi√≥n para obtener una actualizaci√≥n.</i> <br><br>  Para nosotros, esto significaba una cosa: cambiar la forma en que el complemento se carga en modo as√≠ncrono.  Espero que no est√© molesto si no lo sobrecargo con detalles sobre c√≥mo interactuar con las interfaces COM de Visual Studio, y repasar√© los cambios brevemente. <br><br>  Microsoft tiene un art√≠culo sobre la creaci√≥n de complementos cargados asincr√≥nicamente: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo: Usar AsyncPackage para cargar VSPackages en segundo plano</a> ".  Al mismo tiempo, era obvio para todos que el asunto no se limitar√≠a a estos cambios. <br><br>  Uno de los principales cambios es el m√©todo de carga, o m√°s bien, la inicializaci√≥n.  Anteriormente, la inicializaci√≥n necesaria se realizaba en dos m√©todos: el m√©todo <i>Inicializado</i> anulado de nuestra clase de <i>herencia de</i> <i>Paquete</i> y el m√©todo <i>OnShellPropertyChange</i> .  La necesidad de transferir parte de la l√≥gica al m√©todo <i>OnShellPropertyChange</i> se debe al hecho de que cuando el complemento se carga sincr√≥nicamente, Visual Studio a√∫n no se puede cargar e inicializar completamente, y como resultado de esto, no todas las acciones necesarias podr√≠an realizarse en la etapa de inicializaci√≥n del complemento.  Una opci√≥n para resolver este problema es esperar a que Visual Studio salga del estado 'zombie' y retrase estas acciones.  Esta es la l√≥gica y se ha procesado en <i>OnShellPropertyChange</i> con una comprobaci√≥n del estado 'zombie'. <br><br>  En la clase abstracta <i>AsyncPackage</i> , de la que se heredan los complementos cargados asincr√≥nicamente, el m√©todo <i>Initialize</i> tiene un modificador <i>sellado</i> , por lo que la inicializaci√≥n se debe realizar en el m√©todo <i>Inicializado Inicializado</i> , que se realiz√≥.  Tambi√©n tuvimos que cambiar la l√≥gica con el seguimiento del estado 'zombie' de Visual Studio, porque dejamos de recibir esta informaci√≥n en el complemento.  Sin embargo, una serie de acciones que deb√≠an realizarse despu√©s de que se inicializ√≥ el complemento no desaparecieron.  La <i>soluci√≥n</i> fue utilizar el m√©todo <i>OnPackageLoaded</i> de la interfaz <i>IVsPackageLoadEvents</i> , donde se realizaron acciones que requer√≠an una ejecuci√≥n diferida. <br><br>  Otro problema que surge l√≥gicamente del hecho de la carga as√≠ncrona del complemento es la ausencia de comandos del complemento PVS-Studio al momento de iniciar Visual Studio.  Cuando abre el registro del analizador haciendo doble clic desde el administrador de archivos (si necesita abrirlo a trav√©s de Visual Studio), se lanz√≥ la versi√≥n necesaria de devenv.exe con el comando para abrir el informe del analizador.  El comando de lanzamiento se parec√≠a a esto: <br><br><pre><code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\Common7\IDE\devenv.exe"</span></span> /command <span class="hljs-string"><span class="hljs-string">"PVSStudio.OpenAnalysisReport C:\Users\vasiliev\source\repos\ConsoleApp\ConsoleApp.plog"</span></span></code> </pre> <br>  El indicador "/ command" aqu√≠ se usa para invocar un comando registrado en Visual Studio.  Ahora este enfoque no funcion√≥, ya que los comandos no estuvieron disponibles hasta que se descarg√≥ el complemento.  Como resultado, tuve que parar en la "muleta" al analizar la l√≠nea de lanzamiento de devenv.exe despu√©s de cargar el complemento, y si hay una representaci√≥n de cadena del comando para abrir el registro, de hecho, cargar el registro.  Por lo tanto, en este caso, al negarse a utilizar la interfaz "correcta" para trabajar con comandos, fue posible mantener la funcionalidad necesaria al retrasar la carga del registro hasta que el complemento se haya cargado por completo. <br><br>  Fuh, parece estar resuelto y todo funciona, todo se carga y se abre correctamente, no hay advertencias, finalmente. <br><br>  Y luego sucede lo inesperado: Pavel (¬°hola!) Instala un complemento, despu√©s de lo cual pregunta por qu√© no hicimos una carga asincr√≥nica. <br><br>  Decir que nos sorprendi√≥, por no decir nada, ¬øc√≥mo?  No, de verdad, aqu√≠ est√° la nueva versi√≥n del complemento instalado, aqu√≠ est√° el mensaje de que el paquete se puede descargar de forma s√≠ncrona.  Instalamos con Alexander (y hola a usted tambi√©n) la misma versi√≥n del complemento en nuestras m√°quinas: todo est√° bien.  Nada est√° claro: decidimos ver qu√© versiones de las bibliotecas PVS-Studio se cargaron en Visual Studio.  Y de repente resulta que se usan las versiones de las bibliotecas PVS-Studio para Visual Studio 2017, a pesar del hecho de que la versi√≥n correcta de las bibliotecas est√° en el paquete VSIX, para Visual Studio 2019. <br><br>  Despu√©s de jugar con VSIXInstaller, logr√© encontrar la causa del problema: la cach√© del paquete.  La teor√≠a tambi√©n fue confirmada por el hecho de que al restringir los derechos de acceso al paquete en el cach√© (C: \ ProgramData \ Microsoft \ VisualStudio \ Packages) VSIXInstaller escribi√≥ informaci√≥n de error en el registro.  Sorprendentemente, si no hay ning√∫n error, no se escribe en el registro ninguna informaci√≥n sobre el hecho de que el paquete est√° instalado desde el cach√©. <br><br>  <b>Nota</b>  Al estudiar el comportamiento de VSIXInstaller y las bibliotecas relacionadas, se se√±al√≥ a s√≠ mismo que es genial que Roslyn y MSBuild tengan c√≥digo fuente abierto, lo que hace que sea conveniente leer, depurar y rastrear la l√≥gica del trabajo. <br><br>  Como resultado, sucedi√≥ lo siguiente: al instalar el complemento, VSIXInstaller vio que el paquete correspondiente ya estaba en la cach√© (hab√≠a un paquete .vsix para Visual Studio 2017), y lo us√≥ en lugar del paquete instalado real durante la instalaci√≥n.  Por qu√© esto no tiene en cuenta las restricciones / requisitos descritos en .vsixmanifest (por ejemplo, la versi√≥n de Visual Studio para la que puede instalar la extensi√≥n) es una pregunta abierta.  Debido a esto, result√≥ que, aunque .vsixmanifest conten√≠a las restricciones necesarias, el complemento dise√±ado para Visual Studio 2017 se instal√≥ en Visual Studio 2019. <br><br>  Lo peor es que una instalaci√≥n de este tipo rompi√≥ el gr√°fico de dependencia de Visual Studio, y aunque externamente podr√≠a parecer que el entorno de desarrollo funcionaba bien, de hecho, todo estaba muy mal.  Era imposible instalar y desinstalar extensiones, realizar actualizaciones, etc.  El proceso de 'recuperaci√≥n' tambi√©n fue bastante desagradable, porque  fue necesario eliminar la extensi√≥n (los archivos correspondientes), as√≠ como editar manualmente los archivos de configuraci√≥n que almacenan informaci√≥n sobre el paquete instalado.  En general, no es lo suficientemente agradable. <br><br>  Para resolver este problema y evitar situaciones similares en el futuro, se decidi√≥ crear un GUID para el nuevo paquete para separar exactamente los paquetes de Visual Studio 2017 y Visual Studio 2019 (no existe tal problema con los paquetes m√°s antiguos, y siempre usaron un GUID com√∫n). <br><br>  Y como est√°bamos hablando de sorpresas desagradables, mencionar√© una cosa m√°s: despu√©s de actualizar a la Vista previa 2, el elemento del men√∫ 'se movi√≥' en la pesta√±a 'Extensiones'.  Parece que est√° bien, pero el acceso a las funciones del complemento se ha vuelto menos conveniente.  En versiones posteriores de Visual Studio 2019, incluida la versi√≥n de lanzamiento, este comportamiento se ha conservado.  No encontr√© ninguna menci√≥n de esta 'caracter√≠stica' en el momento de su lanzamiento en la documentaci√≥n o el blog. <br><br>  Ahora, parece que todo funciona, y con el soporte de plug-in para Visual Studio 2019 est√° terminado.  El d√≠a despu√©s del lanzamiento de PVS-Studio 7.02 con soporte para Visual Studio 2019, result√≥ que esto no era as√≠: se encontr√≥ otro problema con el complemento as√≠ncrono.  Para el usuario, esto podr√≠a verse as√≠: al abrir una ventana con los resultados del an√°lisis (o comenzar el an√°lisis), nuestra ventana a veces se mostraba "vac√≠a": no conten√≠a contenido: botones, una tabla con advertencias del analizador, etc. <br><br>  De hecho, este problema a veces se repiti√≥ en el curso del trabajo.  Sin embargo, se repiti√≥ solo en una m√°quina y comenz√≥ a aparecer solo despu√©s de actualizar Visual Studio en una de las primeras versiones de 'Vista previa'; hubo sospechas de que algo se hab√≠a roto durante la instalaci√≥n / actualizaci√≥n.  Con el tiempo, sin embargo, el problema dej√≥ de repetirse incluso en esta m√°quina, y decidimos que "se repar√≥ por s√≠ mismo".  Result√≥ que no, tan afortunado.  M√°s precisamente, sin suerte. <br><br>  El asunto result√≥ estar en el orden de inicializaci√≥n de la ventana del entorno en s√≠ (el descendiente de la clase <i>ToolWindowPane</i> ) y su contenido (de hecho, nuestro control con la cuadr√≠cula y los botones).  Bajo ciertas condiciones, la inicializaci√≥n del control ocurri√≥ antes de la inicializaci√≥n del panel, y a pesar de que todo funcion√≥ sin errores, el m√©todo <i>FindToolWindowAsync</i> (crear una ventana en la primera llamada) funcion√≥ correctamente, pero el control permaneci√≥ invisible.  Lo arreglamos agregando una inicializaci√≥n diferida para nuestro control al c√≥digo de relleno del panel. <br><br><h2>  Soporte C # 8.0 </h2><br>  Usar Roslyn como base para el analizador tiene una ventaja significativa: no es necesario mantener manualmente nuevas construcciones de lenguaje.  Todo esto es compatible e implementado en el marco de las bibliotecas Microsoft.CodeAnalysis: utilizamos resultados listos para usar.  Por lo tanto, el soporte para la nueva sintaxis se implementa actualizando las bibliotecas. <br><br>  Por supuesto, en lo que respecta al an√°lisis est√°tico, aqu√≠ ya tiene que hacer todo usted mismo, en particular, para procesar nuevas construcciones de lenguaje.  S√≠, obtenemos el nuevo √°rbol de sintaxis autom√°ticamente al usar la versi√≥n m√°s reciente de Roslyn, pero debemos ense√±arle al analizador c√≥mo percibir y procesar los nodos nuevos / modificados del √°rbol. <br><br>  Creo que la innovaci√≥n m√°s comentada en C # 8 son los tipos de referencia anulables.  No escribir√© sobre ellos aqu√≠: este es un tema bastante amplio digno de un art√≠culo separado (que ya est√° en proceso de redacci√≥n).  En general, hasta ahora hemos decidido ignorar las anotaciones anulables en nuestro mecanismo de flujo de datos (es decir, las entendemos, analizamos y omitimos).  El hecho es que, a pesar del tipo de referencia no anulable de la variable, a√∫n puede escribir <i>nulo</i> en ella de manera bastante simple (o por error), lo que puede conducir a NRE al desreferenciar el enlace correspondiente.  En este caso, nuestro analizador puede ver un error similar y advertir sobre el uso de una referencia potencialmente nula (por supuesto, si ve tal asignaci√≥n en el c√≥digo) a pesar del tipo de referencia no anulable de la variable. <br><br>  Quiero se√±alar que el uso de tipos de referencia anulables y la sintaxis que lo acompa√±a abre la posibilidad de escribir c√≥digo muy interesante.  Para nosotros, llamamos a esto la "sintaxis emocional".  El siguiente c√≥digo se compila bastante bien: <br><br><pre> <code class="cpp hljs">obj.Calculate(); obj?.Calculate(); obj.Calculate(); obj!?.Calculate(); obj!!!.Calculate();</code> </pre> <br>  Por cierto, durante el curso de mi trabajo encontr√© un par de formas de 'llenar' Visual Studio usando la nueva sintaxis.  El hecho es que no puedes limitar el n√∫mero de caracteres a uno cuando pones '!'.  Es decir, puede escribir no solo un c√≥digo del formulario: <br><br><pre> <code class="cpp hljs">object temp = null!</code> </pre> <br>  pero tambi√©n: <br><br><pre> <code class="cpp hljs">object temp = null!!!;</code> </pre> <br>  Puedes pervertir, seguir adelante y escribir as√≠: <br><br><pre> <code class="cpp hljs">object temp = null!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!;</code> </pre> <br>  Este c√≥digo se compila correctamente.  Pero si solicita informaci√≥n sobre el √°rbol de sintaxis utilizando el Visualizador de sintaxis del SDK de la plataforma del compilador de .NET, Visual Studio se bloquear√°. <br><br>  Puede obtener informaci√≥n sobre el problema desde el Visor de eventos: <br><br><pre> <code class="cpp hljs">Faulting application name: devenv.exe, version: <span class="hljs-number"><span class="hljs-number">16.0</span></span><span class="hljs-number"><span class="hljs-number">.28803</span></span><span class="hljs-number"><span class="hljs-number">.352</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5cc37012</span></span> Faulting <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> name: WindowsBase.ni.dll, version: <span class="hljs-number"><span class="hljs-number">4.8</span></span><span class="hljs-number"><span class="hljs-number">.3745</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5c5bab63</span></span> Exception code: <span class="hljs-number"><span class="hljs-number">0xc00000fd</span></span> Fault offset: <span class="hljs-number"><span class="hljs-number">0x000c9af4</span></span> Faulting process id: <span class="hljs-number"><span class="hljs-number">0x3274</span></span> Faulting application start time: <span class="hljs-number"><span class="hljs-number">0x01d5095e7259362e</span></span> Faulting application path: C:\<span class="hljs-function"><span class="hljs-function">Program </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Files</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x86)</span></span></span><span class="hljs-function">\ Microsoft Visual Studio\2019\Community\Common7\IDE\devenv.exe Faulting </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">module</span></span></span><span class="hljs-function"> path: C:\WINDOWS\assembly\NativeImages_v4.0.30319_32\ WindowsBase\4480dfedf0d7b4329838f4bbf953027d\WindowsBase.ni.dll Report Id: 66d41eb2-c658-486d-b417-02961d9c3e4f Faulting package full name: Faulting package-relative application ID:</span></span></code> </pre> <br>  Si va m√°s all√° y aumenta el n√∫mero de signos de exclamaci√≥n varias veces, Visual Studio se reducir√° por s√≠ solo: ya no se necesita la ayuda de Syntax Visualizer.  Las bibliotecas Microsoft.CodeAnalysis y el compilador csc.exe tampoco resumen este c√≥digo. <br><br>  Por supuesto, estos son ejemplos sint√©ticos, pero a√∫n as√≠ este hecho me pareci√≥ divertido. <br><br><h2>  Conjunto de herramientas </h2><br>  <b>Nota</b>  Una vez m√°s me enfrento al problema de traducir la palabra 'evaluaci√≥n' en el contexto de una conversaci√≥n sobre proyectos de MSBuild.  La traducci√≥n, que parec√≠a tener el significado m√°s cercano y al mismo tiempo sonaba normal, era "construir un modelo de proyecto".  Si tiene opciones de traducci√≥n alternativas, puede escribirme, ser√° interesante leer. <br><br>  Era obvio que actualizar el conjunto de herramientas ser√≠a la tarea m√°s lenta.  M√°s precisamente, lo parec√≠a desde el principio, pero ahora me inclino a creer que lo m√°s problem√°tico fue el soporte de complementos.  En particular, esto se debi√≥ al conjunto de herramientas ya existente y al mecanismo para construir el modelo de proyecto MSBuild, que ahora funcionaba con √©xito, aunque requer√≠a expansi√≥n.  No es necesario escribir algoritmos desde cero simplificando enormemente la tarea.  Nuestra apuesta por "nuestro" conjunto de herramientas, realizada en la etapa de soporte de Visual Studio 2017, se justific√≥ una vez m√°s. <br><br>  Tradicionalmente, todo comienza con la actualizaci√≥n de los paquetes NuGet.  En la pesta√±a de administraci√≥n de paquetes NuGet para soluciones, hay un bot√≥n 'Actualizar' ... que no funciona.  Al actualizar todos los paquetes, surgieron m√∫ltiples conflictos de versiones, y resolverlos todos parec√≠a no ser muy correcto.  Una forma m√°s dolorosa, pero, al parecer, m√°s confiable es actualizar 'pieza por pieza' los paquetes Microsoft.Build / Microsoft.CodeAnalysis objetivo. <br><br>  Una de las diferencias se identific√≥ inmediatamente mediante pruebas de reglas de diagn√≥stico: la estructura del √°rbol de sintaxis para un nodo ya existente ha cambiado.  Est√° bien, corregido r√°pidamente. <br><br>  Perm√≠tame recordarle que durante el trabajo probamos analizadores (C #, C ++, Java) en proyectos de c√≥digo abierto.  Esto le permite probar bien las reglas de diagn√≥stico: encontrar, por ejemplo, falsos positivos u obtener una idea de qu√© otros casos no se han considerado (reduzca el n√∫mero de falsos negativos).  Estas pruebas tambi√©n ayudan a rastrear la posible regresi√≥n en la etapa inicial de actualizaci√≥n de bibliotecas / conjunto de herramientas.  Y esta vez no fue la excepci√≥n, ya que surgieron varios problemas. <br><br>  Un problema fue el deterioro del comportamiento dentro de las bibliotecas de CodeAnalysis.  M√°s espec√≠ficamente, en varios proyectos en el c√≥digo de la biblioteca, se produjeron excepciones durante varias operaciones: obtenci√≥n de informaci√≥n sem√°ntica, apertura de proyectos, etc. <br><br>  Los lectores atentos del art√≠culo sobre el soporte de Visual Studio 2017 recuerdan que nuestro kit de distribuci√≥n tiene un c√≥digo auxiliar: el archivo MSBuild.exe tiene un tama√±o de 0 bytes. <br><br>  Esta vez tuve que ir m√°s all√°: ahora el kit de distribuci√≥n tambi√©n contiene ap√©ndices de compilaci√≥n vac√≠os: csc.exe, vbc.exe, VBCSCompiler.exe.  Por qu√©  El camino a esto comenz√≥ con el an√°lisis de uno de los proyectos en la base de prueba, en el que aparecieron los 'diffs' de los informes: faltaban varias advertencias al usar la nueva versi√≥n del analizador. <br><br>  El problema result√≥ ser s√≠mbolos de compilaci√≥n condicional: al analizar un proyecto utilizando la nueva versi√≥n del analizador, algunos de los s√≠mbolos se extrajeron incorrectamente.  Para comprender mejor qu√© caus√≥ este problema, tuve que sumergirme en las bibliotecas de Roslyn. <br><br>  Para analizar los caracteres de compilaci√≥n condicional, use el m√©todo <i>GetDefineConstantsSwitch</i> de la clase <i>Csc</i> de la biblioteca <i>Microsoft.Build.Tasks.CodeAnalysis</i> .  El an√°lisis se realiza utilizando el m√©todo <i>String.Split</i> en varios delimitadores: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] allIdentifiers = originalDefineConstants.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">','</span></span>, <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span> });</code> </pre> <br>  Este m√©todo de an√°lisis funciona bien, todos los s√≠mbolos de compilaci√≥n condicional necesarios se extraen con √©xito.  Excavando m√°s. <br><br>  El siguiente punto clave es la llamada al m√©todo <i>ComputePathToTool</i> de la clase <i>ToolTask</i> .  Este m√©todo crea la ruta al archivo ejecutable ( <i>csc.exe</i> ) y comprueba su presencia.  Si el archivo existe, se devuelve la ruta, de lo contrario <i>se</i> devuelve un <i>valor nulo</i> . <br><br>  C√≥digo de llamada: <br><br><pre> <code class="cpp hljs">.... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> pathToTool = ComputePathToTool(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTool == null) { <span class="hljs-comment"><span class="hljs-comment">// An appropriate error should have been logged already. return false; } ....</span></span></code> </pre> <br>  Dado que no hay <i>un</i> archivo <i>csc.exe</i> (parece que, ¬øpor qu√© lo necesitamos?), <i>PathToTool</i> en esta etapa es <i>nulo</i> , y el m√©todo actual ( <i>ToolTask.Execute</i> ) completa su ejecuci√≥n con el resultado <i>falso</i> .  Como resultado, se ignoran los resultados de la tarea, incluidos los s√≠mbolos de compilaci√≥n condicional resultantes. <br><br>  Bueno, veamos qu√© sucede si coloca el archivo <i>csc.exe</i> en la ubicaci√≥n esperada. <br><br>  En este caso, <i>pathToTool</i> indica la ubicaci√≥n real del archivo existente y la ejecuci√≥n del m√©todo <i>ToolTask.Execute</i> contin√∫a.  El siguiente punto clave es la llamada al m√©todo <i>ManagedCompiler.ExecuteTool</i> .  Y comienza de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteTool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathToTool, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> responseFileCommands, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> commandLineCommands)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ProvideCommandLineArgs) { CommandLineArgs = GetArguments(commandLineCommands, responseFileCommands) .Select(arg =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskItem(arg)).ToArray(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SkipCompilerExecution) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } .... }</code> </pre> <br>  La propiedad <i>SkipCompilerExecution</i> es <i>verdadera</i> (l√≥gicamente, en realidad no estamos compilando).  Como resultado, el m√©todo de llamada (ya mencionado <i>ToolTask.Execute</i> ) verifica que el c√≥digo de <i>retorno del</i> m√©todo <i>ExecuteTool</i> sea ‚Äã‚Äã0 y, de ser as√≠, completa su ejecuci√≥n con el valor <i>verdadero</i> .  Lo que ten√≠a detr√°s de <i>csc.exe</i> estaba all√≠: el compilador real o 'Guerra y paz' ‚Äã‚Äãde Leo Tolstoi en forma de texto no importa. <br><br>  Como resultado, el problema principal surge del hecho de que la secuencia de pasos se define en el siguiente orden: <br><br><ul><li>  verificar la existencia del compilador; </li><li>  verificar si el compilador necesita ser iniciado; </li></ul><br>  No al rev√©s.  Los stubs del compilador resuelven con √©xito este problema. <br><br>  Bueno, ¬øc√≥mo surgieron los caracteres de la compilaci√≥n exitosa si no se detect√≥ el archivo csc.exe (y se ignor√≥ el resultado de la tarea)? <br><br>  Hay un m√©todo para este caso: <i>CSharpCommandLineParser.ParseConditionalCompilationSymbols</i> de la biblioteca <i>Microsoft.CodeAnalysis.CSharp</i> .  El an√°lisis tambi√©n se realiza mediante el m√©todo <i>String.Split</i> con varios delimitadores: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] values = value.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">','</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*, StringSplitOptions.RemoveEmptyEntries*/</span></span>);</code> </pre> <br>  ¬øNota la diferencia con el conjunto de delimitadores del m√©todo <i>Csc.GetDefineConstantsSwitch</i> ?  En este caso, el espacio en blanco no es un separador.  Por lo tanto, si los caracteres de compilaci√≥n condicional se escribieron con un espacio, este m√©todo los analizar√° incorrectamente. <br><br>  Esta situaci√≥n surgi√≥ en proyectos problem√°ticos: los caracteres de compilaci√≥n condicional se escribieron en ellos con un espacio y se analizaron con √©xito usando <i>GetDefineConstantsSwitch</i> , pero no <i>ParseConditionalCompilationSymbols</i> . <br><br>  Otro problema que se revel√≥ despu√©s de actualizar las bibliotecas fue el deterioro del comportamiento en varios casos, en particular, en proyectos que no se recopilaron.  Surgieron problemas en las bibliotecas Microsoft.CodeAnalysis y se nos devolvieron en forma de varias excepciones: <i>ArgumentNullException</i> (algunos registradores internos no se inicializaron), <i>NullReferenceException</i> y otros. <br><br>  Quiero hablar sobre uno de estos problemas a continuaci√≥n: me pareci√≥ bastante interesante. <br><br>  Encontramos este problema al verificar la √∫ltima versi√≥n del proyecto Roslyn: <i>se</i> lanz√≥ una <i>excepci√≥n NullReferenceException</i> desde el c√≥digo de una de las bibliotecas.  Debido a suficiente informaci√≥n detallada sobre la ubicaci√≥n del problema, r√°pidamente encontramos el c√≥digo del problema y, por inter√©s, decidimos intentar ver si el problema se repite cuando se trabaja desde Visual Studio. <br><br>  Bueno, fue posible reproducirlo en Visual Studio (el experimento se realiz√≥ en Visual Studio 16.0.3).  Para hacer esto, necesitamos una definici√≥n de clase de la siguiente forma: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C1</span></span></span><span class="hljs-class">&lt;T1, T2&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T1 val = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val is null) { } } }</code> </pre> <br>  Tambi√©n necesitaremos Syntax Visualizer (parte del SDK de .NET Compiler Platform).  Es necesario solicitar <i>TypeSymbol</i> (elemento de men√∫ "View TypeSymbol (if any)") desde el nodo del √°rbol de sintaxis de tipo <i>ConstantPatternSyntax</i> ( <i>nulo</i> ).  Despu√©s de eso, Visual Studio se reiniciar√°, y en el Visor de eventos puede ver informaci√≥n sobre el problema, en particular, encontrar el seguimiento de la pila: <br><br><pre> <code class="cpp hljs">Application: devenv.exe Framework Version: v4<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span> Description: The process was terminated due to an unhandled exception. Exception Info: System.NullReferenceException at Microsoft.CodeAnalysis.CSharp.ConversionsBase. ClassifyImplicitBuiltInConversionSlow( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet<span class="hljs-string"><span class="hljs-string">'1 &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyBuiltInConversion( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet'</span></span><span class="hljs-number"><span class="hljs-number">1</span></span> &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoForNode( Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode) at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo( Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) ....</code> </pre> <br>  Como puede ver, la causa del problema es la desreferenciaci√≥n de la referencia nula. <br><br>  Como mencion√© anteriormente, encontramos el mismo problema durante la prueba del analizador.  Si utiliza las bibliotecas de depuraci√≥n Microsoft.CodeAnalysis para compilar el analizador, puede llegar al lugar exacto depurando solicitando <i>TypeSymbol</i> desde el nodo deseado en el √°rbol de sintaxis. <br><br>  Como resultado, llegamos al m√©todo <i>ClassifyImplicitBuiltInConversionSlow</i> mencionado en el seguimiento de la pila <i>anterior</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Conversion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassifyImplicitBuiltInConversionSlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeSymbol source, TypeSymbol destination, ref HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert((object)source != null); Debug.Assert((object)destination != null); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.SpecialType == SpecialType.System_Void || destination.SpecialType == SpecialType.System_Void) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; } Conversion conversion = ClassifyStandardImplicitConversion(source, destination, ref useSiteDiagnostics); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conversion.Exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversion; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; }</code> </pre> <br>  El problema es que el par√°metro de <i>destino</i> es <i>nulo</i> en este caso.  En consecuencia, al llamar a <i>destination.SpecialType, se</i> <i>genera</i> <i>una</i> <i>NullReferenceException</i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S√≠, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug.Assert es</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> m√°s alto que desreferenciar </font><font style="vertical-align: inherit;">, pero esto no es suficiente, ya que de hecho no protege contra nada, solo ayuda a identificar el problema en las versiones de depuraci√≥n de las bibliotecas. </font><font style="vertical-align: inherit;">O no ayuda.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cambios en la construcci√≥n de un modelo de proyectos C ++ </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ no sucedi√≥ nada particularmente interesante: los algoritmos antiguos no requer√≠an modificaciones significativas, de lo que ser√≠a interesante hablar. </font><font style="vertical-align: inherit;">Hubo, quiz√°s, dos puntos en los que tiene sentido detenerse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, tuvimos que modificar los algoritmos que dependen del valor de ToolsVersion para escribirse en formato num√©rico. </font><font style="vertical-align: inherit;">Sin entrar en detalles, hay varios casos en los que necesita comparar conjuntos de herramientas y elegir, por ejemplo, una nueva versi√≥n m√°s actual. </font><font style="vertical-align: inherit;">Esta versi√≥n, respectivamente, ten√≠a un valor num√©rico m√°s alto. </font><font style="vertical-align: inherit;">Se calcul√≥ que ToolsVersion, correspondiente a la nueva versi√≥n de MSBuild / Visual Studio, ser√° igual a 16.0. </font><font style="vertical-align: inherit;">Cualquiera que sea el caso ... Por razones de inter√©s, cito una tabla sobre c√≥mo los valores de varias propiedades cambiaron en diferentes versiones de Visual Studio:</font></font><br><div class="scrollable-table"><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nombre del producto visual studio </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√∫mero de versi√≥n de Visual Studio </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Versi√≥n de herramientas </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Versi√≥n PlatformToolset </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2010 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10,0 </font></font><br></td><td>  4.0 4.0 <br></td><td>  100 <br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2012 </font></font><br></td><td>  11,0 <br></td><td>  4.0 4.0 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 110 </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2013 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 120 </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2015 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14.0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14.0 </font></font><br></td><td>  140 <br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2017 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 141 </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2019 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Actual </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 142 </font></font><br></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El chiste, por supuesto, est√° desactualizado, pero no puede evitar recordar cambios en las versiones de Windows y Xbox para comprender que predecir valores futuros (sin importar el nombre y la versi√≥n), en el caso de Microsoft, es algo inestable. </font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La soluci√≥n fue bastante simple: introdujo la priorizaci√≥n de conjuntos de herramientas (asignaci√≥n de una entidad de prioridad separada). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El segundo punto son los problemas cuando se trabaja en Visual Studio 2017 o en un entorno adyacente (por ejemplo, la presencia de la variable de entorno </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VisualStudioVersion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). El hecho es que calcular los par√°metros necesarios para construir un modelo de un proyecto C ++ es mucho m√°s complicado que construir un modelo de un proyecto .NET. En el caso de .NET, utilizamos nuestro propio conjunto de herramientas y el valor correspondiente de ToolsVersion. En el caso de C ++, podemos construir tanto en nuestros propios conjuntos de herramientas existentes como en el sistema. A partir de Build Tools en Visual Studio 2017, los conjuntos de herramientas se registran en el archivo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSBuild.exe.config</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, no en el registro. En consecuencia, no podemos obtenerlos de la lista general de conjuntos de herramientas (por ejemplo, a trav√©s de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.Toolsets</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), a diferencia de esos conjuntos de herramientas que se registran en el registro (correspondiente a &lt;= Visual Studio 2015) . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como consecuencia de todo lo anterior, no funcionar√° construir un modelo de proyecto usando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToolsVersion 15.0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ya que el sistema no ver√° el conjunto de herramientas necesario. Conjunto de herramientas m√°s actual: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actual</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- estar√° disponible al mismo tiempo, ya que este es nuestro propio conjunto de herramientas, por lo tanto, no hay tal problema para Visual Studio 2019. </font><font style="vertical-align: inherit;">La soluci√≥n result√≥ ser simple y permiti√≥ resolver el problema sin cambiar los algoritmos existentes para construir el modelo del proyecto, agregando </font><font style="vertical-align: inherit;">otro </font><font style="vertical-align: inherit;">a la lista de sus propios conjuntos de herramientas, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actual</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15.0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cambios en la construcci√≥n de un modelo de proyectos C # .NET Core </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En el marco de esta tarea, se resolvieron 2 problemas a la vez, ya que resultaron estar relacionados: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> despu√©s de agregar el conjunto de herramientas 'Actual', el an√°lisis de los proyectos .NET Core para Visual Studio 2017 dej√≥ de funcionar; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El an√°lisis de proyectos de .NET Core en un sistema donde al menos una versi√≥n de Visual Studio no estaba instalada no funcion√≥. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El problema en ambos casos era el mismo: algunos de los archivos .targets / .props b√°sicos se buscaron de forma incorrecta. </font><font style="vertical-align: inherit;">Esto llev√≥ al hecho de que no era posible construir un modelo de proyecto utilizando nuestro conjunto de herramientas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En ausencia de Visual Studio, podr√≠a ver dicho error (con la versi√≥n anterior de toolset'a - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15.0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Windows\Microsoft.NET\Framework64\ 15.0\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found.</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al compilar el modelo C # .NET Core del proyecto en Visual Studio 2017, puede ver el siguiente problema (con la versi√≥n actual del conjunto de herramientas, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actual</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\MSBuild\Current\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found. ....</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que los problemas son similares (pero se ve as√≠), puedes intentar matar dos p√°jaros de un tiro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n describo c√≥mo se resolvi√≥ este problema sin entrar en detalles t√©cnicos. Estos mismos detalles (sobre la construcci√≥n de modelos de proyectos C # .NET Core, as√≠ como el cambio de la construcci√≥n de modelos en nuestro conjunto de herramientas) est√°n esperando en uno de nuestros futuros art√≠culos. Por cierto, si lee detenidamente el texto anterior, puede notar que esta es la segunda referencia a futuros art√≠culos.</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, ¬øc√≥mo resolvimos este problema? La soluci√≥n fue expandir nuestro propio conjunto de herramientas a expensas de los principales archivos .targets / .props del SDK de .NET Core ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sdk.props</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sdk.targets</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Esto nos permiti√≥ tener m√°s control sobre la situaci√≥n, m√°s flexibilidad en la gesti√≥n de importaciones, as√≠ como en la construcci√≥n de un modelo de proyectos .NET Core en general. S√≠, nuestro conjunto de herramientas ha vuelto a crecer un poco, y tambi√©n tuvimos que agregar l√≥gica para configurar los proyectos de entorno necesarios para construir el modelo .NET Core, pero parece que vali√≥ la pena. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente, el principio del trabajo al crear un modelo de proyectos .NET Core era el siguiente: simplemente solicitamos esta construcci√≥n, y luego todo funcion√≥ a expensas de MSBuild. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, cuando hemos tomado m√°s control en nuestras propias manos, se ve un poco diferente:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> preparaci√≥n del entorno necesario para construir un modelo de proyectos .NET Core; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> construcci√≥n modelo: </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inicio de construcci√≥n utilizando archivos .targets / .props de nuestro conjunto de herramientas'a; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> construcci√≥n continua usando archivos externos. </font></font></li></ul></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De los pasos descritos anteriormente, es obvio que establecer el entorno necesario tiene dos objetivos principales: </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inicie la construcci√≥n de modelos utilizando archivos .targets / .props de su propio conjunto de herramientas; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> redirigir m√°s operaciones a archivos externos .targets / .props. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para buscar archivos .targets / .props necesarios para construir un modelo de proyectos .NET Core, se utiliza una biblioteca especial: Microsoft.DotNet.MSBuildSdkResolver. El inicio de la construcci√≥n utilizando archivos de nuestro conjunto de herramientas se resolvi√≥ mediante el uso de una variable de entorno especial utilizada por esta biblioteca: sugerimos d√≥nde importar los archivos necesarios (de nuestro conjunto de herramientas). Como la biblioteca es parte de nuestra distribuci√≥n, no hay temor de que la l√≥gica cambie repentinamente y deje de funcionar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora los archivos Sdk se importan primero de nuestro conjunto de herramientas, y dado que podemos cambiarlos f√°cilmente, el control de la l√≥gica adicional de construir el modelo pasa a nuestras manos. Por lo tanto, podemos determinar por nosotros mismos qu√© archivos deben importarse y de d√≥nde. Esto tambi√©n se aplica a Microsoft.Common.props mencionado anteriormente. Importamos este y otros archivos b√°sicos de nuestro propio conjunto de herramientas con confianza en su disponibilidad y contenido. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de eso, despu√©s de haber completado las importaciones necesarias y establecer una serie de propiedades, transferimos el control adicional de la construcci√≥n de modelos al .NET Core SDK real, donde tienen lugar el resto de las acciones necesarias.</font></font><br><br><h2>  Conclusi√≥n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, el soporte para Visual Studio 2019 fue m√°s f√°cil que el soporte para Visual Studio 2017, que, seg√∫n lo veo, se debe a varios factores. Primero, Microsoft no cambi√≥ tantas cosas como entre Visual Studio 2015 y Visual Studio 2017. S√≠, cambiamos el conjunto de herramientas principal, comenzamos a orientar los complementos para Visual Studio en asincron√≠a, pero de todos modos. El segundo, ya ten√≠amos una soluci√≥n lista con nuestro propio conjunto de herramientas y modelos de proyectos de construcci√≥n: no hab√≠a necesidad de inventar todo de nuevo, era suficiente solo para expandir la soluci√≥n existente. El soporte relativamente simple para analizar proyectos de .NET Core para nuevas condiciones (as√≠ como para casos de an√°lisis en una m√°quina donde no hay instancias de Visual Studio instaladas) debido a la expansi√≥n de nuestro sistema de construcci√≥n de modelos de proyectos tambi√©n da la esperanza de que tomamos la decisi√≥n correcta.Habiendo decidido tomar el control sobre ti mismo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pero a√∫n as√≠, me gustar√≠a repetir un pensamiento que estaba en el art√≠culo anterior nuevamente: a veces, usar soluciones preparadas no es tan simple como parece a primera vista. </font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si desea compartir este art√≠culo con una audiencia de habla inglesa, utilice el enlace a la traducci√≥n: Sergey Vasiliev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soporte de Visual Studio 2019 en PVS-Studio</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/454738/">https://habr.com/ru/post/454738/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454728/index.html">Acceso a Internet abierto: la tecnolog√≠a LUWRAIN ayuda a los usuarios ciegos</a></li>
<li><a href="../454730/index.html">Reuni√≥n de Allure Server: grabaciones de video de informes</a></li>
<li><a href="../454732/index.html">5 t√©cnicas s√≥lidas de priorizaci√≥n para equipos de TI</a></li>
<li><a href="../454734/index.html">Copia de seguridad, Parte 4: Descripci√≥n general y prueba de zbackup, restic, borgbackup</a></li>
<li><a href="../454736/index.html">Soporte de Visual Studio 2019 en PVS-Studio</a></li>
<li><a href="../454740/index.html">Mayo de 2019 Joomla Digest</a></li>
<li><a href="../454742/index.html">Al menos un truco de Vim que no conoc√≠as</a></li>
<li><a href="../454744/index.html">Descripci√≥n general de los informes de seguimiento de Java de la conferencia RigaDevDays</a></li>
<li><a href="../454748/index.html">Gu√≠a de supervivencia de MongoDB</a></li>
<li><a href="../454750/index.html">Interfaz de usuario r√°pida - galopando por Europa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>