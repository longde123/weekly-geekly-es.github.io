<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏿 🖕🏿 🦗 Introduction à Bash Shell 🛌🏼 👩‍🚀 😻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous. Ceci est une traduction du livre de préparation à l'examen RedHat RHCE. À mon avis, il est très accessible sur les bases de bash. 

 L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introduction à Bash Shell</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471242/">  Bonjour à tous.  Ceci est une traduction du livre de préparation à l'examen RedHat RHCE.  À mon avis, il est très accessible sur les bases de bash. <br><br>  Les scripts shell sont une science en soi.  Sans entrer dans les détails de tout ce qui se passe «sous le capot», vous apprendrez à utiliser les éléments de base pour écrire vos propres scripts et à analyser ce qui se passe dans les scripts shell tiers. <br><br><img src="https://habrastorage.org/webt/8w/vx/z3/8wvxz3nzeh5uaiubay0ezgvrbwm.jpeg"><br><a name="habracut"></a><br><h2>  Comprendre les éléments de base des scripts shell </h2><br>  En fait, un script shell est une liste de commandes qui sont exécutées séquentiellement, ainsi qu'une certaine logique qui permet au code d'être exécuté uniquement dans certaines conditions. <br><br>  Pour comprendre les scripts shell complexes, il est recommandé de commencer par les scripts de base. <br><br>  Ce qui suit est un script très simple: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # # #This is a script that greets the world # Usage: ./hello clear echo hello world exit 0</span></span></code> </pre> <br>  Il contient plusieurs éléments qui devraient être utilisés dans tous les scripts.  Pour commencer, il y a shebang - c'est la ligne #! / Bin / bash.  Lorsque le script est lancé à partir du shell parent, il ouvre un sous-shell dans lequel les commandes spécifiées dans le script sont exécutées. <br><br>  Ces commandes peuvent être interprétées de différentes manières.  Afin de comprendre exactement comment ils doivent être interprétés, le shebang est utilisé.  Dans l'exemple ci-dessus, shebang indique clairement que le script doit être exécuté par le shell bash. <br><br>  D'autres coquilles peuvent également être indiquées.  Par exemple, si votre script contient du code Perl, shebang devrait être #! / Usr / bin / perl.  Commencer un script avec shebang est une bonne pratique;  s'il est omis, le code du script sera exécuté par le même shell que celui utilisé pour exécuter le script. <br><br>  Immédiatement après le shebang, il y a une partie expliquant de quoi parle le script.  Quelques lignes de commentaires au début de chaque scénario sont une bonne idée.  Dans un court script, il est souvent évident de savoir ce qu'il fait, mais à mesure que le script s'allonge et que plus de gens s'impliquent dans l'écriture et le soutiennent, il devient moins clair ce que les auteurs ont l'intention de faire. <br><br>  Pour éviter cette situation, assurez-vous d'ajouter des lignes de commentaires commençant par chaque caractère #.  Les commentaires peuvent être non seulement dans les premières lignes, mais aussi au début de chaque sous-section du script.  Cela vous sera certainement utile si vous lisez votre script dans quelques mois! <br><br>  Vous pouvez également commenter non seulement les sous-sections, mais également les lignes individuelles. <br><br>  Quelle que soit la position dans laquelle il est utilisé, tout, du caractère # à la fin de la ligne, est un commentaire. <br><br>  Après le bloc de commentaires, le corps du script est localisé.  Dans l'exemple ci-dessus, ce sont plusieurs commandes qui sont exécutées séquentiellement.  Le corps du script shell peut augmenter à mesure qu'il se développe. <br><br>  À la fin du script, j'ai inclus l'instruction <b>exit 0</b> .  L'instruction exit indique au shell parent si le script a réussi.  L'état de sortie de la dernière commande du script est l'état de sortie du script lui-même, sauf si l' <b>exit 0</b> est utilisé à la fin du script. <br><br>  Il est utile de savoir que vous pouvez travailler avec <b>exit</b> pour indiquer au shell parent comment les choses se sont passées. <br><blockquote>  Introduit dans le shell parent, l'écho $?  vous permet d'interroger l'état de sortie du dernier script en cours d'exécution. <br></blockquote>  Après avoir créé le script, assurez-vous qu'il peut être exécuté.  La façon la plus courante de procéder consiste à lui appliquer un bit d'exécution.  Donc, si le nom du fichier de script est bonjour, utilisez la commande <b>chmod + x ./hello</b> pour le rendre exécutable. <br><br>  Le script peut également être exécuté comme argument de la commande bash.  Dans ce cas, entrez <b>bash ./hello</b> pour exécuter le script hello.  Si le script est exécuté comme argument de la commande bash, le fichier de script n'a pas besoin d'être exécutable. <br><br>  En fait, vous pouvez stocker le script n'importe où, mais si vous allez le stocker dans un répertoire qui n'est pas inclus dans la variable $ PATH, vous devez l'exécuter avec ./ devant le nom du script. <br><br>  Tapez <b>./hello</b> pour exécuter le script ou placez-le dans le répertoire standard inclus dans la variable $ PATH, par exemple, / usr / local / bin. <br><br>  Vous pouvez également placer le script dans le répertoire / bin, après quoi il suffit d'entrer le nom du fichier n'importe où dans le système de fichiers et le script s'exécutera. <br><br>  <b>Exemple</b> <br><br>  À l'aide de <b>vi / bin / datetime,</b> créez un fichier nommé datetime dans le répertoire / bin.  Collez ce contenu dans le fichier créé: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash #    .     ,      date who</span></span></code> </pre><br>  Après avoir enregistré le fichier, entrez <b>chmod + x / bin / datetime</b> pour donner au fichier l'autorisation de s'exécuter.  Par exemple, accédez à votre répertoire personnel à l'aide de la <b>commande cd ~</b> et entrez simplement <b>datetime</b> . <br><br>  Allez, par exemple, dans le répertoire cd ~ home et entrez simplement datetime. <br><br><pre> <code class="bash hljs">[root@localhost ~]<span class="hljs-comment"><span class="hljs-comment"># datetime Sat Sep 28 00:33:41 EDT 2019 root tty1 2019-09-25 20:28 root pts/0 2019-09-27 20:07 (comp.corp.domain.ru)</span></span></code> </pre><br><h2>  Utilisation de variables et d'entrées </h2><br>  Les scripts bash sont bien plus qu'une simple liste de commandes exécutées séquentiellement.  L'une des bonnes choses à propos des scripts est qu'ils peuvent travailler avec des variables et des entrées pour rendre le script flexible.  Dans cette section, vous apprendrez à travailler avec eux. <br><br><h3>  Utilisation de paramètres positionnels </h3><br>  Lors de l'exécution du script, vous pouvez utiliser les arguments.  Un argument est tout ce que vous mettez derrière une commande de script.  Les arguments peuvent être utilisés pour rendre le script plus flexible.  <b>Exécutez la</b> commande <b>useradd lisa</b> .  Dans cet exemple, la commande est <b>useradd</b> et son argument, <b>lisa</b> , indique ce qui doit être fait. <br><br>  À la suite d'une telle commande, un utilisateur nommé lisa doit être créé. <br><br>  Dans le script, le premier argument est <b>$ 1</b> , le deuxième argument est <b>$ 2,</b> etc. Le listing 1 montre comment les arguments peuvent être utilisés.  Essayez d'exécuter ce code en spécifiant tout nom d'utilisateur comme paramètre. <br><br>  <b>Listing 1</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # run this script with a few arguments echo The first argument is $1 echo The second argument is $2 echo The third argument is $3</span></span></code> </pre><br>  Les paramètres signifient l'entrée de données avant d'exécuter le script.  Dans ce cas, j'ai spécifié <b>lisa</b> , <b>lori</b> et <b>bob</b> comme paramètres après le nom du script d'argument: <br><br><pre> <code class="bash hljs">[root@server1 ~]<span class="hljs-comment"><span class="hljs-comment"># ./argument lisa lori bob The first argument is lisa The second argument is lori The third argument is bob [root@server1 ~]#</span></span></code> </pre><br>  Si vous avez essayé d'exécuter l'exemple de code, vous remarquerez peut-être que son contenu n'est pas parfait.  Si vous utilisez trois arguments lors de l'exécution du script à partir du Listing 1, cela fonctionnera très bien.  Si vous n'utilisez que deux arguments, le troisième est généré sans la valeur $ 3. <br><br>  Si vous utilisez quatre arguments, la quatrième valeur (qui sera stockée dans $ 4) ne sera jamais affichée.  Donc, si vous souhaitez utiliser des arguments, vous feriez mieux d'utiliser une approche plus flexible. <br><br>  <b>Listing 2</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # run this script with a few arguments echo you have entered $# arguments for i in $@ do echo $i done exit 0</span></span></code> </pre><br>  <b>Le listing 2 montre deux nouveaux éléments liés aux arguments:</b> <br><br><ul><li>  $ # Est un compteur qui indique le nombre d'arguments utilisés lors de l'exécution du script. </li><li>  $ @ Est une liste de tous les arguments qui ont été utilisés lors de l'exécution du script. </li></ul><br>  Pour répertorier les arguments qui ont été utilisés lors de l'exécution de ce script, la boucle <b>for</b> est utilisée.  Dans les boucles <b>for</b> , les instructions sont exécutées tant que la condition est vraie.  Dans ce scénario, la condition <b>pour i dans $ @</b> signifie «pour chaque argument».  Chaque fois que le script parcourt la boucle, la valeur de la variable <b>$ @ est</b> affectée à la variable <b>$ i</b> . <br><br>  Donc, tant qu'il y a des arguments, le corps du script est exécuté. <br><br>  Le corps de la boucle for commence toujours par <b>do</b> et se ferme <b>done</b> , et les commandes à exécuter sont répertoriées entre ces deux mots clés.  Ainsi, l'exemple de script utilise <b>echo</b> pour afficher la valeur de chaque argument et s'arrête lorsqu'il n'y a plus d'arguments disponibles. <br><br>  <b>Essayons le script du Listing 2 dans cet exemple:</b> <br><br><ol><li>  Tapez l' <b>argument vi</b> pour créer le fichier d'arguments et copiez le contenu du script du Listing 2 dans ce fichier. </li><li>  Enregistrez le fichier et rendez-le exécutable. </li><li>  Exécutez la commande <b>./argument abc</b> .  Vous verrez que trois lignes sont affichées. </li><li>  Exécutez la commande <b>./argument abcdef</b> .  Vous verrez qu'en plus de abc, de f sera également affiché. </li></ol><br><h2>  Variables </h2><br>  Une variable est une étiquette utilisée pour indiquer un emplacement spécifique dans la mémoire qui contient une valeur spécifique.  Les variables peuvent être définies statiquement en utilisant NAME = value ou dynamiquement.  Il existe deux solutions pour définir dynamiquement une variable: <br><br><ul><li>  Utilisez le mot clé <b>read</b> dans un script pour demander des données à l'utilisateur exécutant le script. </li><li>  Utilisez la substitution de commandes pour utiliser le résultat de la commande et l'affecter à une variable.  Par exemple, la commande <b>date +% d-% m-% y</b> affiche la date actuelle au format jour-mois-année.  Pour ce faire dans un script, vous pouvez utiliser <b>AUJOURD'HUI = $ (date +% d-% m-% y)</b> .  Pour substituer des commandes, il vous suffit de mettre la commande dont vous souhaitez utiliser le résultat entre les crochets. </li></ul><br>  Dans la section précédente sur les paramètres de position, vous avez appris comment affecter des arguments aux variables lors de l'exécution d'un script.  Dans certains cas, il peut être plus efficace de demander des informations lorsque vous constatez qu'il manque quelque chose de substantiel.  Le script ci-dessous montre comment procéder. <br><br>  <b>Listing 3.</b> Exemple de script utilisant la commande <b>read</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash if [ -z $1 ]; then echo enter a text read TEXT else TEXT=$1 fi echo you have entered the text $TEXT exit 0</span></span></code> </pre><br>  Dans le script du Listing 3, l'opérateur <b>if ... then ... else ... fi</b> est utilisé pour tester l'existence de l'argument <b>$ 1</b> .  Cela se fait à l'aide de <b>test</b> (test est une commande distincte).  La commande test peut être écrite de deux manières *: <b>test</b> ou <b>[...]</b> .  Dans l'exemple, la ligne <b>if [-z $ 1] ...</b> est exécutée pour voir le test (check) <b>-z $ 1</b> . <br><br>  * <i>- en fait trois <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sources</a> (environ. Traducteur)</i> <br><br>  <b>-z test</b> vérifie si <b>$ 1</b> existe ou non.  En d'autres termes, la ligne <b>if [-z $ 1]</b> vérifie si <b>$ 1 est</b> vide, ce qui signifie qu'aucun argument n'a été fourni lors de l'exécution de ce script.  Si c'est le cas, les commandes après l'instruction <b>then</b> sont exécutées. <br><br>  Veuillez noter que lors de l'écriture de la commande de <b>test</b> avec des crochets, il est important d'utiliser des espaces après le crochet d'ouverture et avant le crochet de fermeture, la commande ne fonctionnera pas sans espaces. <br><br>  Notez que l'instruction <b>then</b> suit immédiatement le <b>test</b> .  Cela est possible car un point-virgule (;) est utilisé.  Le point-virgule est un séparateur de commandes et peut remplacer une nouvelle ligne dans un script. <br><br>  L'instruction <b>then</b> exécute deux commandes: la commande <b>echo</b> , qui affiche le message à l'écran, et la commande <b>read</b> . <br><br>  La commande de <b>lecture</b> arrête le script afin que l'entrée utilisateur puisse être traitée et stockée dans la variable TEXT.  Par conséquent, <b>read TEXT</b> place toutes les entrées utilisateur dans la variable TEXT, qui sera utilisée plus tard dans le script. <br><br>  La partie suivante est représentée par l' <b>instruction else</b> .  Les commandes après l' <b>instruction else</b> sont exécutées dans tous les autres cas, ce qui signifie dans ce cas "sinon, si l'argument a été fourni".  Si tel est le cas, la variable TEXT est déterminée et la valeur actuelle de <b>$ 1 lui est</b> affectée. <br><br>  Remarquez comment la variable est définie: immédiatement après le nom de la variable, il y a un signe = suivi de $ 1.  Notez que vous ne devez jamais utiliser d'espaces lors de la définition de variables. <br><br>  Ensuite, les conditions if sont fermées à l'aide de l'opérateur <b>fi</b> .  Une fois la condition if terminée, vous savez avec certitude que la variable TEXT est définie et a une valeur.  L'avant-dernière ligne du script lit la valeur de la variable TEXT et mappe cette valeur à STDOUT à l'aide de la commande <b>echo</b> .  Notez que pour demander la valeur actuelle d'une variable, elle fait référence au nom de la variable, en commençant par le signe $ devant elle. <br><br>  <b>Vous pouvez vous entraîner à utiliser cet exemple lorsque vous travaillez avec une entrée.</b> <br><br><ol><li>  Ouvrez l'éditeur et créez un fichier appelé texte.  Entrez le contenu du code du Listing 3 dans ce fichier. </li><li>  Écrivez le fichier sur le disque et exécutez <b>chmod + x text</b> pour le rendre exécutable. </li><li>  Exécutez le script en exécutant <b>./text</b> et sans arguments supplémentaires.  Vous verrez qu'il demande une entrée. </li><li>  Exécutez le script en utilisant " <b>hello</b> " comme argument (./text hello).  Le résultat affichera "vous avez entré le texte bonjour" dans STDOUT. </li></ol><br><h2>  Utilisation de conditions et de boucles </h2><br>  Comme vous l'avez déjà vu, les instructions conditionnelles peuvent être utilisées dans un script.  Ces instructions conditionnelles ne sont exécutées que si une certaine condition est remplie. <br><br>  Il existe plusieurs instructions conditionnelles et boucles dans bash qui sont souvent utilisées. <br><br><ul><li>  <b>if ... then ... else</b> - utilisé pour exécuter du code si une certaine condition est remplie </li><li>  <b>for</b> - utilisé pour exécuter des commandes pour une plage de valeurs </li><li>  <b>while</b> - utilisé pour exécuter du code si une certaine condition est remplie </li><li>  <b>avant</b> - utilisé pour exécuter du code jusqu'à ce qu'une certaine condition soit remplie </li><li>  <b>cas</b> - utilisé pour évaluer un nombre limité de valeurs spécifiques </li></ul><br><h3>  si alors autrement </h3><br>  La <b>construction if then else</b> est courante pour évaluer des conditions spécifiques.  Vous en avez déjà vu un exemple.  Cette instruction conditionnelle est souvent utilisée avec la commande <b>test</b> .  Cette commande vous permet de vérifier de nombreuses choses: par exemple, non seulement si un fichier existe, mais aussi comparer des fichiers, comparer des entiers et bien plus encore. <br><blockquote>  Vous pouvez en savoir plus sur test dans la référence avec la commande man test. </blockquote><br>  La construction de base de <b>if</b> est <b>if ... then ... fi</b> . <br><br>  Il compare une condition, comme le montre l'exemple suivant: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ -z <span class="hljs-variable"><span class="hljs-variable">$1</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> no value provided <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre><br>  Dans l'extrait 3, vous avez vu comment évaluer deux conditions, y compris <b>sinon</b> dans une expression.  Le listing 4 montre comment évaluer plusieurs conditions de <b>if</b> à <b>else</b> .  Ceci est utile si vous devez vérifier de nombreuses valeurs différentes. <br><br>  Notez que cet exemple utilise également plusieurs commandes de <b>test</b> . <br><br>  <b>Listing 4</b> .  Exemple avec <b>if then else</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # run this script with one argument # the goal is to find out if the argument is a file or a directory if [ -f $1 ] then echo "$1 is a file" elif [ -d $1 ] then echo "$1 is a directory" else echo "I do not know what \$1 is" fi exit 0</span></span></code> </pre> <br><h3>  ||  et &amp;&amp; </h3><br>  Au lieu d'écrire des <b>instructions if ...</b> complètes <b>,</b> vous pouvez utiliser les opérateurs logiques <b>||</b>  ainsi que <b>&amp;&amp;</b> .  <b>||</b>  est un "OU" logique et exécutera la deuxième partie de l'instruction uniquement si la première partie n'est pas vraie;  <b>&amp;&amp;</b> est un «ET» logique et exécutera la deuxième partie de l'instruction uniquement si la première partie est vraie. <br><br>  <b>Considérez ces deux lignes:</b> <br><br><pre> <code class="bash hljs">[ -z <span class="hljs-variable"><span class="hljs-variable">$1</span></span> ] &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> no argument provided</code> </pre> <br><pre> <code class="bash hljs">ping -c 1 8.8.8.8 2&gt;/dev/null || <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> node is not available</code> </pre><br>  Le premier exemple vérifie si <b>$ 1 est</b> vide.  Si cette vérification est correcte (ce qui signifie essentiellement que la commande se termine par le code de sortie 0), la deuxième commande est exécutée. <br><br>  Dans le deuxième exemple, la commande <b>ping est</b> utilisée pour vérifier la disponibilité de l'hôte. <br>  Cet exemple utilise un "OU" logique pour afficher le texte "le nœud n'est pas disponible" en cas d'échec de la commande <b>ping</b> . <br><br>  Vous le trouverez souvent, au lieu de l' <b>instruction</b> conditionnelle <b>if</b> , <b>&amp;&amp;</b> et <b>||</b>  .  Dans l'exercice ci-dessous, vous pouvez vous entraîner à utiliser des instructions conditionnelles en utilisant <b>si ... alors ... else</b> , ou <b>&amp;&amp;</b> et <b>||</b>  . <br><br>  <b>Faites de l'exercice</b> .  Utiliser <b>si ... alors ... sinon</b> <br><br>  Dans cet exercice, vous allez travailler sur un script qui vérifie ce qu'est un fichier et ce qu'est un répertoire. <br><br><ol><li>  Lancez l'éditeur et créez un script appelé filechk. </li><li>  Copiez le contenu du Listing 4 dans ce script. </li><li>  Exécutez quelques tests avec lui, tels que <b>./filechk / etc / hosts</b> , <b>./filechck / usr</b> , <b>./filechk fichier-non-existant</b> . </li></ol><br><h2>  Pour boucle </h2><br>  La boucle <b>for</b> est une excellente solution pour le traitement des plages de données.  Dans le listing 5, vous pouvez voir le premier exemple avec <b>for</b> , où la plage est déterminée et traitée alors qu'il y a des valeurs brutes dans cette plage. <br><br>  <b>Listing 5</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # for (( COUNTER=100; COUNTER&gt;1; COUNTER-- )); do echo $COUNTER done exit 0</span></span></code> </pre> <br>  Une boucle <b>for</b> commence toujours par le mot clé for, suivie d'une condition qui doit être vérifiée.  Ceci est suivi du mot clé <b>do</b> , suivi des commandes qui doivent être exécutées.Si la condition est vraie, la boucle se termine en utilisant le mot clé <b>done</b> . <br><br>  Dans l'exemple du Listing 5, vous pouvez voir que la condition est une plage de nombres entre parenthèses affectée à la variable COUNTER. <br><br>  <b>Une petite explication</b> <br><br>  À l'intérieur <b>((...))</b> les expressions arithmétiques sont calculées et leur résultat est renvoyé.  Par exemple, dans le cas le plus simple, la construction a = $ ((5 + 3)) affectera à la variable «a» la valeur de l'expression «5 + 3», ou 8. De plus, les doubles parenthèses permettent de travailler avec des variables dans le style du langage C. <br><br>  Tout d'abord, la variable est initialisée à 100 et tant que la valeur est supérieure à 1, elle est soustraite 1 à chaque itération. Tant que la condition est vraie, la valeur de la variable $ COUNTER est affichée à l'aide de la commande <b>echo</b> . <br><br>  Dans le Listing 6, vous pouvez voir l'un de mes one-liners préférés avec <b>for</b> .  La plage est définie cette fois comme une séquence de nombres, commençant à 100 et atteignant 104. <br><br>  <b>Listing 6</b> <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {100..104}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ping –c 1 192.168.4.<span class="hljs-variable"><span class="hljs-variable">$i</span></span> &gt;/dev/null &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 192.168.4.<span class="hljs-variable"><span class="hljs-variable">$i</span></span> is up; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre><br>  Remarquez comment la plage est déterminée: vous spécifiez d'abord le premier nombre, puis deux points et indiquez le dernier nombre de la plage.  De plus, avec <b>pour i dans,</b> pour chacun de ces nombres, la variable <b>i est</b> affectée.  Chacun de ces numéros est affecté à la variable <b>i</b> , puis la commande <b>ping</b> est exécutée, où l'option <b>-c 1</b> garantit qu'une seule demande est envoyée. <br><br>  Le résultat de la commande <b>ping n'est</b> pas pris en compte, donc sa sortie est redirigée vers / dev / null.  En fonction de l'état de sortie de la commande <b>ping</b> , une partie de l'expression <b>&amp;&amp;</b> est exécutée.  Ainsi, si l'hôte est disponible, une ligne s'affiche indiquant qu'il est en cours d'exécution. <br><br><h2>  Comprendre pendant et jusqu'à </h2><br>  Si l'instruction for que vous venez de lire est utile pour travailler avec des plages d'éléments, l'instruction while est utile lorsque vous souhaitez suivre quelque chose comme l'accessibilité des processus.  Il existe également une instruction <b>until</b> , qui est exécutée tant que la condition vérifiée est fausse.  Dans le Listing 7, vous pouvez lire comment <b>while est</b> utilisé pour surveiller l'activité du processus. <br><blockquote>  Remarque  Je n'ai pas compris ce que fait ce script.  Dans mon cas, CentOS 7 est utilisé et par défaut il n'y a pas de moniteur, bien que le script indique explicitement: <pre>  utilisation: surveiller &lt;nom du processus&gt; </pre>  Quelque part pendant une demi-heure, j'ai googlé le programme de moniteur pour CetOS, mais je ne l'ai pas trouvé.  Et généralement, on ne sait pas quel moniteur latéral est ici si ps aux est utilisé.  En tout cas, je n'ai pas compris ce que fait ce script.  Une grande demande pour aider à résoudre ce problème est d'ajuster le texte et / ou le script. </blockquote>  <b>Listing 7</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # # usage: monitor &lt;processname&gt; while ps aux | grep $1 | grep -v grep &gt; /dev/tty11 do sleep 5 done clear echo your process has stopped logger $1 is no longer present mail -s "process $1 has stopped" root &lt; .</span></span></code> </pre> <br>  Le script du Listing 7 se compose de deux parties.  Tout d'abord, il y a une <b>boucle while</b> .  Deuxièmement, il y a tout ce qui doit être fait lorsque la <b>boucle while</b> n'est plus évaluée comme vraie. <br><br>  Le cœur de la <b>boucle while</b> est la commande <b>ps</b> , qui a une valeur de <b>$ 1</b> . <br><br>  Notez l'utilisation de <b>grep -v grep</b> , qui exclut les lignes contenant la <b>commande grep</b> du résultat.  N'oubliez pas que la commande <b>ps</b> inclura tous les processus en cours d'exécution, y compris la <b>commande grep</b> , à laquelle la sortie de la <b>commande</b> <b>ps</b> est transmise.  Cela peut conduire à une fausse correspondance positive. <br><br>  La sortie de la commande <b>ps aux</b> est redirigée vers / dev / tty11.  Cela vous permet de lire les résultats de tty11 plus tard, si nécessaire, mais ils ne sont pas affichés par défaut. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les instructions </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">while</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont suivies des commandes qui doivent être exécutées si la condition vérifiée est vraie. Dans ce cas, c'est la commande </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sleep 5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui suspend l'exécution du script pendant 5 secondes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tant que la condition de l'instruction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">while</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font><font style="vertical-align: inherit;">vraie, la boucle continue de s'exécuter. Si la condition est fausse (ce qui signifie dans ce cas que le processus n'est plus disponible), le cycle s'arrête et les commandes qui le suivent peuvent être exécutées. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous devez être familiarisé avec toutes ces commandes, sauf la dernière. Dans la ligne </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mail -s "le processus $ 1 s'est arrêté" root &lt;.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> le message est envoyé à l'utilisateur root à l'aide du système de messagerie interne, qui s'exécute sur Linux * par défaut. Commande de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">messagerie</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend comme premier argument le sujet du message spécifié avec l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">option -s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* - au moins sur CentOS cela fonctionne par défaut. (at. traducteur)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faites attention à </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> à la fin de l'équipe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habituellement, lorsque vous utilisez la commande </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mail</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en mode interactif, un éditeur s'ouvre dans lequel vous pouvez écrire le corps du message. Cet éditeur est fermé, fournissant une ligne qui n'a qu'une période. Dans cette commande, un point est fourni en redirigeant STDIN. Cela permet au message d'être traité sans aucune exigence supplémentaire pour l'activité de l'utilisateur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boucle while</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est l'opposé de la boucle </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">until</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dont un exemple est illustré dans le Listing 8.</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jusqu'à ce que</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> démarre une itération qui dure jusqu'à ce que la condition devienne vraie. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le Listing 8, il est utilisé pour filtrer la sortie de la commande </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">users</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> par l'occurrence de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ 1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui sera le nom d'utilisateur. </font><font style="vertical-align: inherit;">Tant que cette commande n'est pas correcte, l'itération continue. </font><font style="vertical-align: inherit;">Lorsque le nom d'utilisateur est trouvé dans la sortie utilisateur, l'itération se ferme et après la boucle </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jusqu'à</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , les </font><font style="vertical-align: inherit;">autres commandes sont exécutées. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 8</font></font></b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # until users | grep $1 &gt; /dev/null do echo $1 is not logged in yet sleep 5 done echo $1 has just logged in mail -s "$1 has just logged in" root &lt; .</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comprendre le cas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La dernière boucle d'itération importante est le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> *. L' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instruction case est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilisée pour évaluer un certain nombre de valeurs attendues. En particulier, les </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">déclarations de cas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont importantes dans les scripts de démarrage Linux, qui dans les versions précédentes étaient utilisés pour démarrer les services. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* - est-ce un cycle?</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instruction case,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous définissez chaque argument concret que vous attendez, suivi de la commande à exécuter si cet argument a été utilisé. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l'extrait 9, vous pouvez voir l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instruction case</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui était utilisée dans une version antérieure pour exécuter presque tous les services. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 9</font></font></b> <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$1</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> start) start;; stop) rm -f <span class="hljs-variable"><span class="hljs-variable">$lockfile</span></span> stop;; restart) restart;; reload) reload;; status) status ;; *) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Usage: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$0</span></span></span><span class="hljs-string"> (start|stop|restart|reload|status)"</span></span> ;; <span class="hljs-keyword"><span class="hljs-keyword">esac</span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le boîtier</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a plusieurs caractéristiques. Vient d'abord la ligne - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cas en séquence</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ceci est suivi d'une liste de toutes les valeurs possibles qui doivent être évaluées. Chaque élément est fermé par un support </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ceci est suivi d'une liste de commandes à exécuter si un argument spécifique a été utilisé. La liste des commandes est fermée par un double point-virgule ;; peut être utilisé immédiatement après la dernière commande et peut être utilisé sur une ligne distincte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez également que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s'applique à tous les autres paramètres non spécifiés précédemment. Il s'agit d'un opérateur global. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La boucle d'itération de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se termine par l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instruction esac</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que les séquences en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont exécutées dans l'ordre. </font><font style="vertical-align: inherit;">Lorsque la première correspondance est établie, l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instruction case</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n'évalue rien. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le cadre de l'évaluation, des modèles similaires au modèle peuvent être utilisés. </font><font style="vertical-align: inherit;">Ceci est montré dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*) une</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> séquence qui correspond à tout. </font><font style="vertical-align: inherit;">Mais vous pouvez également utiliser des séquences telles que start | Start | START) pour correspondre en utilisant un autre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Débogage de scripts dans Bash </font></font></h2><br>     ,   ,    .  ,       <b>bash -x</b> .    ,    ,    ,      . <br><br>   10    <b>bash -x</b> ,    ,   <b>grep</b>  ,    ,       . <br><br><pre> <code class="bash hljs">[root@server1 ~]<span class="hljs-comment"><span class="hljs-comment"># bash -x 319.sh + grep Usage: grep [OPTION]... PATTERN [FILE]... Try 'grep --help' for more information. + users + echo is not logged in yet is not logged in yet + sleep 5</span></span></code> </pre> <br><h2>   </h2><br>     ,    .           ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471242/">https://habr.com/ru/post/fr471242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471226/index.html">Linux a plusieurs visages: comment travailler sur n'importe quelle distribution</a></li>
<li><a href="../fr471228/index.html">Grokay PyTorch</a></li>
<li><a href="../fr471232/index.html">Mon expérience de connexion du LPS331AP à Omega Onion2</a></li>
<li><a href="../fr471236/index.html">Dosimètre pour Seryozha. Partie III. Radiomètre national</a></li>
<li><a href="../fr471240/index.html">«Bitchy Betty» et interfaces audio modernes: pourquoi parlent-elles d'une voix féminine?</a></li>
<li><a href="../fr471244/index.html">Code Rosetta: mesurez la longueur du code dans un grand nombre de langages de programmation, étudiez la proximité des langages entre eux</a></li>
<li><a href="../fr471248/index.html">Les régulateurs américains interdisent la distribution du jeton Telegram Open Network</a></li>
<li><a href="../fr471254/index.html">ITMO University Accelerator Startups - Début des projets de vision industrielle</a></li>
<li><a href="../fr471256/index.html">Vue.js est bon, mais est-il meilleur qu'angulaire ou réactif?</a></li>
<li><a href="../fr471258/index.html">Système de stockage / chargement de données</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>