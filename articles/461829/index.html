<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüë©‚Äçüëß üéæ ü¶ê TCP vs UDP o el futuro de los protocolos de red üìÉ ü§∂üèº üëºüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Antes de que cada servicio genere al menos 1 Mb / s de tr√°fico de Internet, surge la pregunta: ‚Äú¬øC√≥mo? sobre TCP o sobre UDP? " En las √°reas de aplica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TCP vs UDP o el futuro de los protocolos de red</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461829/">  Antes de que cada servicio genere al menos 1 Mb / s de tr√°fico de Internet, surge la pregunta: ‚Äú¬øC√≥mo?  sobre TCP o sobre UDP? "  En las √°reas de aplicaci√≥n, incluidas las plataformas de entrega, las preferencias y tradiciones de tomar tales decisiones ya se han desarrollado. <br><br>  En teor√≠a, si, por ejemplo, una vez que un desarrollador perezoso no intentara implementar su ML en Python (porque solo lo sab√≠a), lo m√°s probable es que el mundo nunca se haya sentido tan lleno de amor por el despreciable lenguaje de "codificadores s√∫per Java".  Y hoy, las debilidades de este lenguaje en el pasado contexto de aplicaci√≥n le otorgan primac√≠a incondicionalmente en el despliegue y lanzamiento de numerosos mineros A / B. <br><br>  Puede comparar mucho: ARM con Intel, iOS y Android, y Mortal Kombat con injusticia.  Y encuentre un espacio holivar, as√≠ que regrese al tema de entregar grandes vol√∫menes de contenido multiformato. <br><br>  Hace diez a√±os, todos estaban absolutamente seguros de que UDP era algo relacionado con la entrega no garantizada.  Si necesita un protocolo confiable, es TCP.  Y, contrariamente a la tradici√≥n en este art√≠culo, compararemos cosas aparentemente incomparables como TCP y UDP. <br><br><img src="https://habrastorage.org/webt/p5/tk/9z/p5tk9z_pumv5hmxly_ob3rvdikg.jpeg"><br>  <i>Precauci√≥n, debajo del corte 99 ilustraciones y diagramas y todo lo importante.</i> <br><a name="habracut"></a><br>  La comparaci√≥n la lleva a cabo el jefe de desarrollo de las plataformas Video y Tape en OK <b>Alexander Tobol</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">alatobol</a> ).  Los servicios de Video y News Feed en la red social OK - exclusivamente sobre el contenido y su entrega a todas las plataformas de clientes existentes en cualquier condici√≥n de red mala o excelente, y la cuesti√≥n de c√≥mo entregarlo, a trav√©s de TCP o UDP, es crucial. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/aXYJlizk3CQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  TCP vs UDP.  Teor√≠a m√≠nima </h2><br>  Para llegar a la comparaci√≥n, necesitamos un poco de teor√≠a b√°sica. <br><br><img src="https://habrastorage.org/webt/fd/2q/ko/fd2qkoeptll1vmmm0ptkscrhu9i.jpeg"><br><br>  ¬øQu√© sabemos sobre las redes IP?  El flujo de datos que env√≠a se divide en paquetes, una especie de recuadro negro entrega estos paquetes al cliente.  El cliente recoge paquetes y recibe un flujo de datos.  Por lo general, todo esto es transparente y no hay necesidad de pensar qu√© hay en los niveles inferiores. <br><br><img src="https://habrastorage.org/webt/dj/6r/xm/dj6rxmcr3xayjlmfnblkxet-1le.jpeg"><br><br>  El diagrama muestra la pila TCP / IP y UDP / IP.  En la parte inferior hay paquetes de Ethernet, paquetes de IP, y m√°s a nivel del sistema operativo hay TCP y UDP.  TCP y UDP en esta pila no son muy diferentes entre s√≠.  Est√°n encapsulados en paquetes IP y las aplicaciones pueden usarlos.  Para ver las diferencias, debe buscar dentro de los paquetes TCP y UDP. <br><br><img src="https://habrastorage.org/webt/mz/pr/lt/mzprltftvytepznp_xufo63xb0g.jpeg"><br><br>  Tanto all√≠ como hay puertos.  Pero <strong>en UDP solo hay una suma de comprobaci√≥n</strong> : la longitud del paquete, este protocolo es lo m√°s simple posible.  Y en TCP, hay muchos datos que indican claramente la ventana, el reconocimiento, la secuencia, los paquetes, etc.  Obviamente <strong>TCP es m√°s complejo</strong> . <br><br><blockquote>  Hablando en t√©rminos generales, TCP es un protocolo de entrega confiable, y UDP no es confiable. </blockquote><br>  Y, sin embargo, a pesar de la supuesta falta de fiabilidad de UDP, descubriremos si es posible entregar datos m√°s r√°pido y m√°s confiable que usar TCP.  Intentemos mirar la red desde adentro y entender c√≥mo funciona.  En el camino, abordaremos las siguientes preguntas: <br><br><ul><li>  ¬øPor qu√© comparar TCP o qu√© tiene de malo? </li><li>  con qu√© y con qu√© deber√≠a comparar TCP; </li><li>  qu√© hizo Google y qu√© decisi√≥n tom√≥; </li><li>  qu√© nos espera el futuro de los protocolos de red. </li></ul><br>  Este art√≠culo no tendr√° una teor√≠a: niveles y modelos de OSI, modelos matem√°ticos complejos, aunque todo se puede contar a trav√©s de ellos.  Analizaremos al m√°ximo c√≥mo tocar la red no en teor√≠a, sino con nuestras propias manos. <br><br><h2>  ¬øPor qu√© comparar TCP o qu√© tiene de malo? </h2><br>  TCP fue inventado en 1974, y despu√©s de 20 a√±os, cuando fui a la escuela, compr√© tarjetas de Internet, borr√© el c√≥digo y llam√© a alg√∫n lado.  Adem√°s, si llama de 2 noches a 7 de la ma√±ana, entonces Internet era gratis, pero era dif√≠cil comunicarse. <br><br>  Pasaron otros 20 a√±os, y los usuarios en redes inal√°mbricas m√≥viles comenzaron a prevalecer sobre los usuarios "cableados", mientras que TCP no cambi√≥ conceptualmente. <br><br><blockquote>  El mundo m√≥vil gan√≥, aparecieron los protocolos inal√°mbricos y el TCP a√∫n no cambi√≥. </blockquote><br>  Hoy, el 80% de los usuarios utilizan Wi-Fi o una red inal√°mbrica 3G-4G. <br><br><img src="https://habrastorage.org/webt/mw/a9/u4/mwa9u4ew7v6e1uevlbgrvf2jlrw.jpeg"><br><br>  En redes inal√°mbricas, hay: <br><br><ul><li>  p√©rdida de paquetes: aproximadamente el 0.6% de los paquetes que enviamos se pierden en el camino; </li><li>  reordenamiento: la reorganizaci√≥n de paquetes en lugares, en la vida real es un fen√≥meno bastante raro, pero ocurre en el 0.2% de los casos; </li><li>  jitter: cuando los paquetes se env√≠an de manera uniforme y llegan a colas con un retraso de aproximadamente 50 ms. </li></ul><br>  TCP oculta con √©xito todas estas caracter√≠sticas de transferencia de datos en redes heterog√©neas, y no necesita sumergirse en √©l. <br><br>  A continuaci√≥n, en el mapa, se encuentra la velocidad promedio de datos TCP en Rusia.  Si quita la parte occidental, est√° claro que la velocidad se mide m√°s en kilobits que en megabits. <br><br><img src="https://habrastorage.org/webt/ck/a4/y5/cka4y5puk4gyorr-uaq2xcdtuom.jpeg"><br><br>  Es decir, en promedio, para nuestros usuarios (excluyendo la parte occidental de Rusia): rendimiento de 1,1 Mbps, p√©rdida de paquetes del 0,6%, RTT (tiempo de ida y vuelta) del orden de 200 ms. <br><br><h3>  C√≥mo calcular RTT </h3><br>  Cuando vi el promedio de 200 ms, pens√© que hab√≠a un error en las estad√≠sticas y decid√≠ medir el RTT para nuestros servidores en el MSC de una manera alternativa usando RIPE Atlas.  Este es un sistema para recopilar datos sobre el estado de Internet.  La sonda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RIPE Atlas</a> est√° disponible de forma gratuita. <br><br><img src="https://habrastorage.org/webt/za/rj/3g/zarj3gndghr0wnxs4yqt_odm68a.jpeg"><br><br>  La conclusi√≥n es que lo conecta a la Internet de su hogar y recolecta "karma".  Ella trabaja durante d√≠as, algunas personas cumplen con algunos de sus pedidos sobre ella.  Entonces puede establecer varias tareas usted mismo.  Un ejemplo de tal tarea: tomar accidentalmente 30 puntos en Internet y pedir medir RTT, es decir, ejecutar el comando ping en el sitio web Odnoklassniki. <br><br><img src="https://habrastorage.org/webt/kb/qa/5k/kbqa5k7sgl6wt5modhjfpa2fg00.jpeg"><br><br>  Curiosamente, entre los puntos aleatorios hay muchos que tienen ping de 200 a 300 ms. <br><br>  En total, <strong>las redes inal√°mbricas son populares e inestables</strong> (aunque esto √∫ltimo generalmente se ignora, ya que se cree que TCP puede manejar esto): <br><br><ul><li>  M√°s del 80% de los usuarios utilizan internet inal√°mbrico; </li><li>  Los par√°metros de las redes inal√°mbricas cambian din√°micamente dependiendo, por ejemplo, del hecho de que el usuario ha doblado la esquina; </li><li>  Las redes inal√°mbricas tienen altas tasas de p√©rdida de paquetes, fluctuaciones, reordenamiento; </li><li>  Canal asim√©trico fijo, cambio de direcci√≥n IP. </li></ul><br><h3>  El consumo de contenido depende de la velocidad de Internet </h3><br>  Esto es muy f√°cil de verificar: hay muchas estad√≠sticas.  Tom√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estad√≠sticas</a> sobre el video, que dice que cuanto mayor es la velocidad de Internet en el pa√≠s, m√°s usuarios ven el video. <br><br><img src="https://habrastorage.org/webt/de/6q/_r/de6q_ruks-vpbgoo4yt5vokfkno.jpeg"><br><br>  Seg√∫n estas estad√≠sticas, Rusia tiene una Internet bastante r√°pida, pero seg√∫n nuestros datos internos, la velocidad promedio es ligeramente menor. <br><br>  A favor del hecho de que la velocidad de Internet en su conjunto es insuficiente, dice que todos los creadores de grandes aplicaciones, redes sociales, servicios de video, etc., est√°n optimizando sus servicios para trabajar en una mala red.  Despu√©s de 10 Kb de datos recibidos, puede ver un m√≠nimo de informaci√≥n en la cinta, y a una velocidad de 500 Kb puede ver videos. <br><br><h3>  C√≥mo acelerar la carga </h3><br>  En el proceso de desarrollo de la plataforma de video, nos dimos cuenta de que TCP no es muy efectivo en redes inal√°mbricas.  ¬øC√≥mo llegaste a esta conclusi√≥n? <br><br>  Decidimos acelerar la descarga e hicimos el siguiente truco. <br><br><img src="https://habrastorage.org/webt/n2/gg/xf/n2ggxfu9tzoskihc7itlm28j7ui.jpeg"><br><br>  Descargamos el video del cliente al servidor en varias transmisiones, es decir, 40 MB se dividen en 4 partes de 10 MB y se cargan en paralelo.  Lo iniciamos en Android y conseguimos que se cargue en paralelo m√°s r√°pido que en una conexi√≥n ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">demostraci√≥n</a> en el informe).  ¬°Lo m√°s interesante es que cuando lanzamos descargas paralelas en producci√≥n, vimos que en algunas regiones la velocidad de descarga aument√≥ 3 veces! <br><br><blockquote>  Cuatro conexiones TCP pueden cargar datos al servidor 3 veces m√°s r√°pido. </blockquote><br>  Entonces aumentamos la velocidad de descarga de video y concluimos que la descarga debe ser paralela. <br><br><h3>  TCP en redes inestables </h3><br>  Se puede tocar un efecto incre√≠ble con paralelismo.  Es suficiente tomar un medidor de velocidad para recibir / enviar datos (por ejemplo, prueba de velocidad) y modelador de tr√°fico (por ejemplo, acondicionador de enlace de red, si tiene una Mac). Restringimos la red a par√°metros de 1 Mbps para cargar y descargar y comenzar a aumentar la p√©rdida de paquetes. <br><br><img src="https://habrastorage.org/webt/lk/ki/j8/lkkij8appdgsvglvlp1rdt3em7s.jpeg"><br><br>  La tabla muestra RTT y p√©rdidas.  Se puede ver que en el caso de p√©rdida del 0%, la red se utiliza al 100%. <br><br>  En la pr√≥xima iteraci√≥n, aumentamos la p√©rdida de paquetes en un 5%, y vemos que la red se utiliza solo en un 74%.  Parece correcto: con una p√©rdida de paquetes del 5%, se pierde el 26% de la red.  Pero si tambi√©n aumenta el ping, quedar√° <strong>menos de la mitad del canal</strong> . <br><br><blockquote>  Si el canal tiene un RTT alto y una gran p√©rdida de paquetes, entonces una conexi√≥n TCP no utiliza completamente la red. </blockquote><br>  Otro truco muestra que si comienza a utilizar conexiones TCP paralelas (puede ejecutar varias pruebas de velocidad al mismo tiempo), puede ver el crecimiento inverso de la utilizaci√≥n del canal. <br><br><img src="https://habrastorage.org/webt/co/n7/v_/con7v_t-dxmnrsxe6e0kkakbnwm.jpeg"><br><br>  Con un aumento en el n√∫mero de conexiones TCP paralelas, la utilizaci√≥n de la red se vuelve casi igual al rendimiento, menos el porcentaje de p√©rdidas. <br><br>  Por lo tanto, result√≥: <br><br><ul><li>  Las redes m√≥viles inal√°mbricas han ganado y son inestables. </li><li>  TCP no utiliza completamente el canal en redes inestables. </li><li>  El consumo de contenido depende de la velocidad de Internet: cuanto mayor es la velocidad de Internet, m√°s usuarios ven, y amamos a nuestros usuarios y queremos que vean m√°s. </li></ul><br>  Obviamente, debe mudarse a alg√∫n lugar y considerar alternativas al TCP. <br><br><h2>  TCP vs no TCP </h2><br>  ¬øC√≥mo comparar el calor?  Hay dos opciones <br><br>  La primera opci√≥n: en el nivel de IP hay TCP y UDP, podemos permitirnos alg√∫n otro protocolo desde arriba.  Obviamente, si inicia su propio protocolo en paralelo con TCP y UDP, Firewall, Brandmauer, enrutadores y el resto del mundo involucrado en la entrega de paquetes no lo sabr√°n.  Como resultado, tendr√° que esperar durante a√±os cuando todo el equipo se actualice y comience a funcionar con el nuevo protocolo. <br><br>  La segunda opci√≥n es hacer su propio protocolo de entrega de datos confiable adem√°s de UDP no confiable.  Obviamente, puede esperar mucho tiempo hasta que Linux, Android e iOS agreguen un nuevo protocolo a su kernel, por lo que debe cortar el protocolo en el espacio de usuario. <br><br>  Esta soluci√≥n parece interesante, la llamaremos protocolo UDP hecho a s√≠ mismo.  Para comenzar a desarrollarlo, no necesita nada especial: simplemente abra el socket UDP y env√≠e los datos. <br><br><img src="https://habrastorage.org/webt/zy/zt/sn/zyztsnsutwgufcqwlhxb6qslhpg.jpeg"><br><br>  Lo desarrollaremos mientras estudiamos c√≥mo funciona la red. <br><br><h2>  TCP vs UDP hecho a s√≠ mismo </h2><br>  ¬øY en qu√© comparar? <br><br>  Las redes son diferentes: <br><br><ul><li>  Con congesti√≥n, cuando hay muchos paquetes y algunos de ellos caen debido a la congesti√≥n de canales o equipos. </li><li>  Alta velocidad con gran ida y vuelta (por ejemplo, cuando el servidor est√° relativamente lejos). </li><li>  Extra√±o: cuando nada parece estar sucediendo en la red, pero los paquetes a√∫n desaparecen simplemente porque el punto de acceso Wi-Fi est√° detr√°s de la pared. </li></ul><br>  Siempre puede tocar los perfiles de red usted mismo: seleccione uno u otro perfil en su tel√©fono y ejecute la Prueba de velocidad. <br><br><img src="https://habrastorage.org/webt/v1/0j/-p/v10j-p8absukvs6s4jn2ntd8qau.jpeg"><br><br>  Adem√°s de los perfiles de red, tambi√©n debe determinar el perfil de consumo de tr√°fico.  Aqu√≠ est√°n los que usamos: <br><br><img src="https://habrastorage.org/webt/3k/dc/fb/3kdcfbeyhjpduwbumk1n1iz2-c0.jpeg"><br><br>  Como soy responsable del video y la transmisi√≥n, los perfiles son apropiados: <br><br><ul><li>  Video de perfil, cuando se conecta y transmite este o aquel contenido.  La velocidad de conexi√≥n aumenta, como en el gr√°fico superior.  Requisitos para este protocolo: baja latencia y adaptaci√≥n de velocidad de bits. </li><li>  Opci√≥n de vista de cinta: carga de datos por impulso, consultas en segundo plano, tiempo de inactividad.  Requisitos para este protocolo: los datos recibidos se multiplexan y priorizan, la prioridad del contenido del usuario es mayor que los procesos en segundo plano, hay una cancelaci√≥n de la descarga. </li></ul><br>  Por supuesto, debe comparar los protocolos en el HTTP m√°s popular. <br><br><h3>  HTTP 1.1 y HTTP 2.0 </h3><br>  La pila est√°ndar de la d√©cada de 2000 se parec√≠a a HTTP 1.1 sobre SSL.  La pila moderna es HTTP 2.0, TLS 1.3 y todo encima de TCP. <br><br><img src="https://habrastorage.org/webt/k9/yp/ng/k9ypngmth9i_4m8pqzx5n-kipf0.jpeg"><br><br>  La principal diferencia es que HTTP 1.1 utiliza un conjunto limitado de conexiones en el navegador a un dominio, por lo que crean un dominio separado para im√°genes, datos, etc.  HTTP 2.0 ofrece una conexi√≥n multiplexada en la que se transmiten todos estos datos. <br><br><img src="https://habrastorage.org/webt/uo/aj/uu/uoajuubf2yfz_femlhzhvq6buty.jpeg"><br><br>  HTTP 1.1 funciona as√≠: hacer una solicitud, obtener datos, hacer una solicitud, obtener datos. <br><br><img src="https://habrastorage.org/webt/1y/nv/xd/1ynvxdxpfkluduputf3szhfi75a.jpeg"><br><br>  Por lo general, un navegador o una aplicaci√≥n m√≥vil lucha, es decir, una conexi√≥n para recibir im√°genes, datos por API, y simult√°neamente ejecuta una solicitud de una imagen, una API, un video, etc. <br><br><img src="https://habrastorage.org/webt/cn/ub/kl/cnubklsdxjrcuwpamcckap5_uu8.jpeg"><br><br>  El principal problema es la competencia.  No tiene control sobre las solicitudes enviadas.  Usted comprende que el usuario ya no necesita la imagen que le dio la vuelta, pero no puede hacer nada. <br><br><blockquote>  Con HTTP 1.1, a√∫n obtiene lo que solicit√≥, es dif√≠cil cancelar la descarga. </blockquote><br>  La √∫nica posibilidad de z√≥calo es cerrar la conexi√≥n.  Luego veremos por qu√© esto es malo. <br><br><h3>  Diferencias en HTTP 2.0 </h3><br>  HTTP 2.0 resuelve estos problemas: <br><br><ul><li>  binario, compresi√≥n de encabezado; </li><li>  multiplexaci√≥n de datos; </li><li>  priorizaci√≥n; </li><li>  cancelar la descarga; </li><li>  empuje del servidor </li></ul><br>  Consideremos m√°s puntos importantes para nosotros. <br><br><img src="https://habrastorage.org/webt/tb/nl/ur/tbnlurtfdzcqaxpy6_hgcphtye0.jpeg"><br><br>  Solicite una foto y API.  La imagen se da de inmediato, la API preparada despu√©s de un tiempo.  Se proporcion√≥ la API: la imagen se entreg√≥ hasta el final.  Todo esto sucede de manera transparente.  <strong>El contenido de alta prioridad se descarga anteriormente.</strong> <br><br><img src="https://habrastorage.org/webt/gw/ws/wp/gwwswpducmtjv2huz9jprbhwpha.jpeg"><br><br>  <strong>La inserci√≥n del servidor</strong> es tal cuando solicit√≥ algo espec√≠fico como una API, pero incluso en la carga en el cliente se almacenaron en cach√© las im√°genes que definitivamente ser√≠an necesarias para ver, por ejemplo, una cinta. <br><br>  Tambi√©n hay un comando <strong>Restablecer transmisi√≥n</strong> que el navegador se ejecuta solo si va entre p√°ginas, etc.  Para un cliente m√≥vil, con su ayuda, puede negarse a recibir datos sin perder la conexi√≥n. <br><br>  Por lo tanto, compararemos TCP en diferentes: <br><br><ul><li>  Perfiles de red: Wi-Fi, 3G, LTE. </li><li>  Perfiles de consumo: transmisi√≥n (video), multiplexaci√≥n y priorizaci√≥n con cancelaci√≥n de la descarga (HTTP / 2) para recibir el contenido de la cinta. </li></ul><br><h3>  Modelo sin p√©rdida </h3><br>  Comencemos la comparaci√≥n con una red simple en la que solo hay dos par√°metros: tiempo de ida y vuelta y ancho de banda. <br><br>  <b>RTT</b> es ping, el tiempo de respuesta de un paquete, la recepci√≥n del acuse de recibo o el tiempo de eco de respuesta. <br><br>  Para medir el <b>ancho de banda</b> ( <b>ancho de banda de la</b> red), enviamos un paquete de paquetes y contamos el n√∫mero de paquetes transmitidos en un determinado intervalo de tiempo. <br><br><img src="https://habrastorage.org/webt/6r/du/2l/6rdu2lwrhgztjekbwsfgvtuwdec.jpeg"><br><br>  Como trabajamos con protocolos confiables, por supuesto, hay un acuse de recibo: enviamos paquetes y recibimos confirmaci√≥n de recepci√≥n. <br><br><h3>  El problema de Internet lento </h3><br>  Al comienzo del desarrollo de nuestro servicio de video en 2013, mi amigo fue a California y decidi√≥ ver una nueva serie de su serie favorita en Odnoklassniki.  Ten√≠a un RTT de 250 ms, Wi-Fi perfecto a 400 Mbps en el campus de Google, quer√≠a ver la nueva serie en FullHD. <br><br>  ¬øCrees que pudo ver el video?  La respuesta depende de la configuraci√≥n del b√∫fer de env√≠o / recepci√≥n en nuestros servidores. <br><br><img src="https://habrastorage.org/webt/qf/sk/qj/qfskqjvyygm-klersirdlmfdreo.jpeg"><br><br>  Como tenemos un protocolo con acuse de recibo, todos los datos que no recibieron una confirmaci√≥n de entrega se almacenan en un b√∫fer.  Si el b√∫fer de env√≠o est√° limitado a 128 Kb, entonces estos 128 Kb son menores que para RTT, no podemos enviar.  Por lo tanto, de nuestra red de 400 Mbit / s, quedan 4 Mbit / s.  Esto no es suficiente para ver videos en l√≠nea en FullHD. <br><br>  Luego saqu√© el tama√±o del b√∫fer y mir√© c√≥mo la velocidad de salida de un segmento de video realmente cambia dependiendo del cambio en el tama√±o del b√∫fer.  Inmediatamente haga una reserva de que el b√∫fer de recepci√≥n se ajust√≥ autom√°ticamente, es decir  lo que envi√≥ el servidor, el cliente siempre pudo aceptar. <br><br><img src="https://habrastorage.org/webt/vj/yi/ef/vjyiefcatf55inm_ka-0b1vpake.jpeg"><br><br><blockquote>  Una receta TCP obvia: si transmite datos de alta velocidad a largas distancias, debe aumentar el b√∫fer de env√≠o. </blockquote><br>  Todo parece estar bien.  Puede ir al servicio fast.com, que mide la velocidad de su Internet a los servidores de Netflix.  Desde la oficina obtuve una velocidad de 210 Mbps.  Y luego, a trav√©s de net shaper, configur√© las condiciones de la tarea y fui a este sitio nuevamente.  Magia: obtuve 4 Mbps exactamente. <br><br><img src="https://habrastorage.org/webt/xx/sl/nr/xxslnr1m5syfgyludnghfp7d6yw.jpeg"><br><br>  No importa c√≥mo lo gire, Netflix no logr√≥ obtener un b√∫fer de m√°s de 128 KB. <br><br><h3>  Tamp√≥n </h3><br>  Para determinar el tama√±o √≥ptimo del b√∫fer, debe comprender qu√© son los paquetes sobre la marcha. <br><br><img src="https://habrastorage.org/webt/cl/ym/ws/clymwsmlyixceklwgevvv00izru.jpeg"><br><br>  Hay un estado de red: <br><br><ul><li>  los paquetes 1 y 2 ya se han enviado, se ha recibido una confirmaci√≥n para ellos; </li><li>  se enviaron los paquetes 3, 4, 5, 6, pero se desconoce el resultado de la entrega (paquetes sobre la marcha); </li><li>  otros paquetes est√°n en la cola. </li></ul><br><img src="https://habrastorage.org/webt/if/oh/m0/ifohm0lal6uotlodse6vrehnoqc.jpeg"><br><br>  Si el n√∫mero de paquetes en la marcha es igual al tama√±o del b√∫fer, entonces no es lo suficientemente grande.  En este caso, la red est√° muriendo de hambre, no totalmente utilizada. <br><br>  La situaci√≥n inversa es posible: el b√∫fer es demasiado grande.  En este caso, el b√∫fer se hincha.  ¬øPor qu√© es esto malo? <br><br><img src="https://habrastorage.org/webt/m1/4y/fk/m14yfka8426esfgz8a8xeglxko4.jpeg"><br><br>  Si hablamos de multiplexaci√≥n de datos y enviamos varias solicitudes al mismo tiempo, por ejemplo, im√°genes en la misma conexi√≥n y API, entonces, cuando toda la enorme imagen de megabytes entr√≥ en el b√∫fer, e intentamos rellenar tambi√©n la API de alta prioridad, el b√∫fer se hincha.  Tienes que esperar mucho tiempo cuando la imagen desaparece. <br><br>  Una soluci√≥n simple es ajustar autom√°ticamente el tama√±o del b√∫fer.  Ahora est√° disponible en muchos clientes y funciona de esta manera. <br><br><img src="https://habrastorage.org/webt/pm/dj/rj/pmdjrjtekrknmzgogzn6bzkgplq.jpeg"><br><br>  Si se pueden enviar muchos paquetes ahora, el b√∫fer est√° aumentando, la transferencia de datos se est√° acelerando, el tama√±o del b√∫fer est√° creciendo, todo parece ser genial. <br><br>  Pero hay un problema.  Si el b√∫fer ha aumentado, no se puede reducir tan f√°cilmente.  Esta es una tarea m√°s dif√≠cil.  Si la velocidad disminuye, se produce la misma hinchaz√≥n del b√∫fer.  El b√∫fer es bastante grande y est√° lleno, debemos esperar hasta que todos los datos se env√≠en al cliente. <br><br>  Si escribimos nuestro propio protocolo UDP, entonces todo es muy simple: tenemos acceso al b√∫fer. <br><br><img src="https://habrastorage.org/webt/ow/lz/5m/owlz5m0em5dqvtz3ni14pgc3khm.jpeg"><br><br>  Si TCP en tales situaciones simplemente agrega datos hasta el final, y no puede hacer nada, entonces en un protocolo hecho a mano puede colocar datos, por ejemplo, hacia adelante, inmediatamente despu√©s de los paquetes sobre la marcha. <br><br>  Y si viene cancelar, y el cliente dice que esta imagen ya no es necesaria, necesita los datos de la API, desplaz√≥ el contenido a√∫n m√°s, puede tirar todo esto del b√∫fer y enviar la deseada. <br><br>  ¬øC√≥mo se hace esto?  Se sabe que para restaurar paquetes, gestionar la entrega, recibir acuses de recibo, necesita alg√∫n n√∫mero de secuencia de paquetes.  Sequence_id estamos escritos solo para paquetes sobre la marcha, es decir, lo emitimos solo cuando enviamos paquetes.  Todo lo dem√°s en el b√∫fer se puede mover como queramos hasta que los paquetes desaparezcan. <br><br>  <strong>Conclusi√≥n:</strong> el b√∫fer TCP debe estar configurado correctamente, recuperar el equilibrio para no colindarse con la red y no inflar el b√∫fer.  Para su propio protocolo UDP, todo es simple: esto se puede controlar. <br><br><h3>  Modelo de red con p√©rdida </h3><br>  Pasamos a un nivel superior, la red se vuelve un poco m√°s complicada, aparece la p√©rdida de paquetes.  Para redes m√≥viles, esta es una situaci√≥n com√∫n.  Algunos de los paquetes enviados no llegan al cliente.  El algoritmo de recuperaci√≥n de retransmisi√≥n est√°ndar funciona m√°s o menos as√≠: <br><br><img src="https://habrastorage.org/webt/tg/z7/tv/tgz7tvr6zchscr49onnqepvjvje.jpeg"><br><br>  Env√≠a paquetes, por cada paquete recibe acuse de recibo.   Retransmit timeout (RTO)  RTT     ,   . <br><br>     TCP,    5% ,     50%. <br><br><img src="https://habrastorage.org/webt/ob/vi/qf/obviqfawoiesuiex2yqf_idbvei.jpeg"><br><br>  retransmit,    ,      .    ,  ,   Congestion control. <br><br><h3> Congestion control </h3><br>      flow control,    . <br><br><img src="https://habrastorage.org/webt/bc/3k/g9/bc3kg9sb5k5sppttampxxaeaypu.jpeg"><br><br><ul><li> <b>Flow control</b> ‚Äî      .  ,           ,      .    flow control  recv window,      .  flow control ‚Äî  back pressure  ,    -    . </li><li>  <b>congestion control</b>   .  ,   ‚Äî    . </li></ul><br><img src="https://habrastorage.org/webt/mf/b5/9d/mfb59d5xp1ph_irk_rhkckjpbew.jpeg"><br><br>   ,     :  ,    ,    ,      .        ,     congestion control. <br><br>    TCP window. <br><br><img src="https://habrastorage.org/webt/tj/u0/9s/tju09sic8asow88ehlwsuyfjj6q.jpeg"><br><br>     flow control  congestion control,       . <br><br>  Ejemplos: <br><br><ul><li>  TCP window = 1,       :  acknowledgement,     .. </li><li>  TCP window = 4,       ,  acknowledgement   . </li></ul><br>    ,    .  initial window  TCP = 10. <br><br><img src="https://habrastorage.org/webt/ar/jf/ja/arjfjayzxewtfl-iulsna677qa0.jpeg"><br><br>    ,  ,        . <br><br>     ? <br><br><img src="https://habrastorage.org/webt/yj/ck/_t/yjck_tpkuuze0pjmkdb5mhfrlri.jpeg"><br><br><ul><li>    ,    .     ,      . </li><li>      :   , acknowledgements   . </li><li>            -    , acknowledgements      ( ). </li></ul><br>       . <br><br><img src="https://habrastorage.org/webt/jp/6c/di/jp6cdirmtiqosalz9vw-mvkjkei.jpeg"><br><br>   ,    ,   .     :     ,     ..    ,      .   congestion control,  TCP window,    ,    . <br><br><img src="https://habrastorage.org/webt/__/w0/zg/__w0zgqdiycta2u7yla0svmhof4.jpeg"><br><br>     congestion control,   ,   ‚Äî   .      packet loss ‚Äî  ,   .        ,   ,         ‚Äî    ,    . <br><br> ,  TCP , ,   congestion control   loss-.    congestion control  loss delay,     ,   . <br><br><img src="https://habrastorage.org/webt/44/no/5k/44no5kuc601zfx2h8dm_kwoqete.jpeg"><br><br> : <br><br><ul><li> <b>Cubic</b> ‚Äî  Congestion Control  Linux 2.6.        :   ‚Äî  . </li><li> <b>BBR</b> ‚Äî   Congestion Control,    Google  2016 .   . </li></ul><br><h3> BBR Congestion Control </h3><br>   Cubic  BBR   feedback. <br><br><img src="https://habrastorage.org/webt/7u/5z/zr/7u5zzrcv5cr3eyywvi0ui75qxr8.jpeg"><br><br>       ,      ‚Äî   acknowledgement       .   : <br><br><ul><li> BBR ,    ,    ,    . </li><li> Cubic        . </li></ul><br>  A continuaci√≥n se muestra un gr√°fico del retraso versus el tiempo de conexi√≥n, que muestra lo que sucede en diferentes controles de congesti√≥n. <br><br><img src="https://habrastorage.org/webt/xn/l5/c_/xnl5c_gfgpby_vchj-lt5ftptta.jpeg"><br><br>  El BBR primero detecta el tiempo de ida y vuelta, env√≠a m√°s y m√°s paquetes, luego se da cuenta de que el b√∫fer est√° obstruido y entra en el modo de operaci√≥n con un retraso m√≠nimo. <br><br>  Cubic funciona de forma agresiva: desborda todo el b√∫fer, y cuando el b√∫fer se desborda y se produce la p√©rdida de paquetes, cubic reduce la ventana. <br><br>  Parece que, con la ayuda de BBR, ser√≠a posible resolver todos los problemas, pero hay una <strong>inquietud</strong> en las redes: los paquetes a veces se retrasan, a veces se agrupan en paquetes.  Los env√≠as con cierta frecuencia y vienen en grupos.  Peor a√∫n, cuando recibes acuses de recibo de estos paquetes, y tambi√©n de alguna manera "fluct√∫an". <br><br>  Como promet√≠ que todo podr√≠a ser tocado con las manos, entonces hacemos ping, por ejemplo, el sitio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HighLoad ++</a> , observamos el ping y consideramos la fluctuaci√≥n entre paquetes. <br><br><img src="https://habrastorage.org/webt/be/pu/fj/bepufjz6mtygfhqppfkeyvi3phq.jpeg"><br><br>  Se puede ver que los paquetes son desiguales, la fluctuaci√≥n promedio es de aproximadamente 50 ms.  Naturalmente, BBR puede estar equivocado. <br><br>  BBR es bueno porque distingue entre: p√©rdida de congesti√≥n real, p√©rdida de paquetes debido a desbordamientos del b√∫fer del dispositivo y p√©rdida aleatoria debido a una red inal√°mbrica deficiente.  Pero no funciona bien en caso de nerviosismo elevado.  ¬øC√≥mo puedo ayudarlo? <br><br><h3>  C√≥mo mejorar el control de la congesti√≥n </h3><br>  De hecho, TCP no tiene suficiente informaci√≥n como reconocimiento, solo tiene los paquetes que vio.  Tambi√©n hay un reconocimiento selectivo, que dice qu√© paquetes est√°n confirmados y cu√°les a√∫n no han llegado.  Pero esta informaci√≥n no es suficiente. <br><br><img src="https://habrastorage.org/webt/fs/9j/gm/fs9jgmfd67brdk7wynu6sqjprk8.jpeg"><br><br>  Si tiene la oportunidad de inflar el reconocimiento, a√∫n puede ahorrar todo el tiempo, no solo enviando estos paquetes, sino tambi√©n llegando al cliente.  Eso es, de hecho, en el servidor para recopilar el cliente de jitter. <br><br>  ¬øPor qu√© es generalmente efectivo inflar el reconocimiento?  Porque las redes m√≥viles son asim√©tricas.  Por ejemplo, generalmente con 3G o LTE, el 70% del ancho de banda se asigna para descargar datos y el 30% para cargar.  El transmisor cambia: cargar - descargar, cargar - descargar, y no lo afecta de ninguna manera.  Si no descarga nada, entonces simplemente est√° inactivo.  Por lo tanto, si tiene ideas interesantes, aumente el reconocimiento, no sea t√≠mido; esto no es un problema. <br><br><img src="https://habrastorage.org/webt/cv/0t/gd/cv0tgdq9vzirpmrvzx4optqe0ik.jpeg"><br><br>  Un ejemplo de c√≥mo puede usar un acuse de recibo para dividir el jitter en env√≠o y el jitter para recibir, y rastrearlos por separado.  Luego nos volvemos m√°s flexibles y entendemos cu√°ndo ocurri√≥ la p√©rdida de congesti√≥n y cu√°ndo ocurri√≥ la p√©rdida aleatoria.  Por ejemplo, puede comprender la cantidad de fluctuaci√≥n en cada direcci√≥n y configurar con mayor precisi√≥n la ventana. <br><br><img src="https://habrastorage.org/webt/ti/qj/zk/tiqjzkihljlcb2pn2oj-wdlbmkq.jpeg"><br><br><h3>  Qu√© control de congesti√≥n elegir </h3><br>  Los compa√±eros de clase son una gran red con mucho tr√°fico diferente: video, API, im√°genes.  Y hay estad√≠sticas sobre qu√© control de congesti√≥n es mejor elegir. <br><br>  BBR siempre es efectivo para video porque reduce los retrasos.  En otros casos, Cubic generalmente se usa, es bueno para fotograf√≠as.  Pero hay otras opciones. <br><br><img src="https://habrastorage.org/webt/9m/ea/gd/9meagdum2m9dvmtn4eeawrmbtay.jpeg"><br><br>  Hay docenas de diferentes opciones de control de congesti√≥n.  Para elegir el mejor, puede recopilar estad√≠sticas sobre el cliente y probar uno u otro control de congesti√≥n para diferentes tipos de perfiles de carga. <br><br>  Por ejemplo, este es el efecto de iniciar BBR en un video. <br><br><img src="https://habrastorage.org/webt/hy/h8/dh/hyh8dhiugrgtyl6vgaozjzitnxq.jpeg"><br><br>  Logramos aumentar seriamente la profundidad de visualizaci√≥n.  Google dice que tienen aproximadamente un 10% menos de almacenamiento en b√∫fer en el reproductor cuando usan BBR. <br><br>  Genial, pero ¬øqu√© pasa con nuestros clientes? <br><br><img src="https://habrastorage.org/webt/np/m1/uy/npm1uywvt78qoudkof3mkebqrj8.jpeg"><br><br>  Los clientes son un poco lentos, todos tienen Cubic y no puedes influenciarlo.  Pero est√° bien, a veces puedes paralelizar datos, y ser√° bueno. <br><br>  <strong>Conclusiones sobre el control de congesti√≥n:</strong> <br><br><ul><li>  BBR siempre es bueno para el video. </li><li>  En otros casos, si usamos nuestro propio protocolo UDP, puede llevar el control de congesti√≥n con usted. </li><li>  Desde el punto de vista de TCP, solo puede usar el control de congesti√≥n, que est√° en el n√∫cleo.  Si desea implementar su control de congesti√≥n en el n√∫cleo, debe cumplir con la especificaci√≥n TCP.  Es imposible inflar el reconocimiento, realizar cambios, porque simplemente no est√°n en el cliente. </li></ul><br><blockquote>  Si crea su protocolo UDP, tiene mucha m√°s libertad en t√©rminos de control de congesti√≥n. </blockquote><br><h3>  Multiplexaci√≥n y priorizaci√≥n </h3><br>  Esta es una nueva tendencia, todos lo est√°n haciendo ahora.  Que problemas hay  Si usamos TCP, seguramente todos (o casi todos) conocen la situaci√≥n de bloqueo de cabecera. <br><br><img src="https://habrastorage.org/webt/zv/rt/6t/zvrt6t3igpnzn4vea3lgdw7vb1e.jpeg"><br><br>  Hay varias solicitudes que se multiplexan en una sola conexi√≥n TCP.  Los enviamos a la red, pero faltaba alg√∫n paquete.  Una conexi√≥n TCP retransmitir√° este paquete; se retransmitir√° en un tiempo cercano a RTT o m√°s.  En este momento, no podremos obtener nada, aunque el b√∫fer TCP contiene datos de otra solicitud que est√° completamente listo para ser recogido. <br><br><blockquote>  Resulta que la multiplexaci√≥n a trav√©s de TCP, si usa HTTP 2.0, no siempre es efectiva en redes defectuosas. </blockquote><br>  El siguiente problema es la hinchaz√≥n del b√∫fer. <br><br><img src="https://habrastorage.org/webt/fy/zh/rw/fyzhrwlr4mmtdgxwhp-mxfa9k-y.jpeg"><br><br>  Cuando se env√≠a una imagen al cliente, el b√∫fer aumenta.  Lo enviamos durante mucho tiempo, y luego aparece una solicitud de API, y de ninguna manera se puede priorizar.  En tales casos, la priorizaci√≥n de TCP no funciona. <br><br>  Por lo tanto, si se produce una p√©rdida de paquetes, se produce un bloqueo de cabecera de l√≠nea y cuando el cliente tiene una tasa de bits variable (y esto sucede a menudo con clientes m√≥viles), aparece el efecto de bloqueo de b√∫fer.  Como resultado, ni la multiplexaci√≥n, ni la priorizaci√≥n, ni la inserci√≥n del servidor, ni todo lo dem√°s funciona, porque tenemos b√∫feres o el cliente espera algo. <br><br>  Si hacemos nuestra propia multiplexaci√≥n, entonces podemos poner varios datos all√≠. <br><br><img src="https://habrastorage.org/webt/_g/er/5g/_ger5gqpdxllo3-p1eo7ytzupce.jpeg"><br><br>  Esto no es dif√≠cil, solo agregue paquetes con n√∫meros al b√∫fer.  Sobre la marcha: no toque lo que ya se ha enviado, pero lo que a√∫n no se ha enviado se puede reorganizar.  Se ve as√≠. <br><br><img src="https://habrastorage.org/webt/9g/_v/xr/9g_vxrrlkavxucnmocy3kggc-f8.jpeg"><br><br>  Enviaron im√°genes, las dividieron en paquetes, recibieron una solicitud de API prioritaria: la insertaron y enviaron la imagen.  Incluso si falta un paquete, podemos obtener una solicitud de API preparada desde el b√∫fer, es de alta prioridad y llegar√° r√°pidamente al cliente.  En TCP, por definici√≥n, la transferencia de datos de transmisi√≥n no es posible. <br><br><h3>  Establecer una conexi√≥n </h3><br>  Si perfilamos nuestra aplicaci√≥n, veremos que la mayor√≠a de las veces la red est√° inactiva al inicio de la aplicaci√≥n, porque la conexi√≥n se establece primero antes de la API, luego obtenemos los datos, luego se establece la conexi√≥n antes de las im√°genes, se descargan estos datos, etc.  Esto siempre sucede: la red es utilizada por picos. <br><br><img src="https://habrastorage.org/webt/14/cn/ck/14cnckztbu1v-otwf__j9dqzahu.jpeg"><br><br>  Para lidiar con esto, veamos c√≥mo se establece la conexi√≥n. <br><br><img src="https://habrastorage.org/webt/ca/eb/ij/caebijcqzlqj0h5soblnfudqedo.jpeg"><br><br>  El primero es resolver DNS: no podemos hacer nada con esto.  Luego, establezca una conexi√≥n TCP, establezca una conexi√≥n segura, luego ejecute la solicitud y reciba una respuesta.  Lo m√°s interesante es que parte del trabajo que realiza el servidor cuando responde a una solicitud generalmente toma menos tiempo que establecer una conexi√≥n. <br><br>  Ahora est√° muy de moda medir n√∫meros de latencia para memoria, para discos, para otra cosa.  Puede medirlos para una red 3G, 4G y ver cu√°nto tiempo lleva, en el peor de los casos, establecer una conexi√≥n TCP con TLS. <br><br><img src="https://habrastorage.org/webt/qe/ux/1p/qeux1p7brp9mvpxeptinhubywmc.jpeg"><br><br>  ¬°Y pueden ser segundos!  Incluso en 4G hasta 700 ms tambi√©n es significativo.  Pero TCP no podr√≠a vivir tan f√°cilmente todo este tiempo. <br><br>  La conexi√≥n se basa en el algoritmo b√°sico de <strong>protocolo de enlace TCP de 3 v√≠as</strong> .  Haga syn, syn + ack, luego corrija la solicitud m√°s tarde (a la izquierda en el diagrama). <br><br><img src="https://habrastorage.org/webt/ty/mj/-a/tymj-amfsa1c4j8sirtaspnvq1o.jpeg"><br><br>  Hay <strong>TCP Fast Open</strong> (derecha).  Si ya ha conectado con este servidor, hay una cookie, puede enviar su solicitud de inmediato para RTT cero.  Para usar esto, debe crear un socket, hacer que sendto () sea el primer dato, decir que quiere FASTOPEN. <br><br><img src="https://habrastorage.org/webt/ab/kl/b9/abklb93dq3g__tw2rihxrhagkl8.jpeg"><br><br>  Nginx puede hacer todo esto: solo enci√©ndalo, todo funcionar√° (o enci√©ndalo en el n√∫cleo). <br><br><h2>  TLS </h2><br>  Vamos a comprobar que TLS es malo. <br><br>  Configur√© net shaper a 200 ms nuevamente, pinqu√© google.com y vi que RTT = 220 es mi RTT + RTT shaper.  Luego hice una solicitud a trav√©s de HTTP y HTTPS.  Descubr√≠ que a trav√©s de HTTP es posible obtener una respuesta durante RTT, es decir, TFO funciona para Google desde mi computadora.  Para HTTPS, esto tom√≥ m√°s tiempo. <br><br><img src="https://habrastorage.org/webt/po/hl/kj/pohlkjs39dl7kk3rp5kzbxrwsna.jpeg"><br><br>  Esta es una sobrecarga TLS tan com√∫n que requiere mensajer√≠a para establecer una conexi√≥n segura. <br><br><img src="https://habrastorage.org/webt/zf/j2/qn/zfj2qndcohpiok8cqpc82kiun3s.jpeg"><br><br>  Para hacer esto, pensaron por nosotros, agregaron TLS 1.3.  Tambi√©n es f√°cil de incluir en nginx. <br><br><img src="https://habrastorage.org/webt/m5/eo/i0/m5eoi0z5a2rzb4hthqlbjchxhyi.jpeg"><br><br>  Todo parece funcionar.  Pero veamos qu√© hay en nuestros clientes m√≥viles que aprovechan todo esto. <br><br><h3>  ¬øQu√© pasa con los clientes? </h3><br>  TCP Fast Open es algo genial.  Seg√∫n las estad√≠sticas <br><br><img src="https://habrastorage.org/webt/pq/yy/l8/pqyyl89jhtoulpwalg61q8pqbnw.jpeg"><br><br>  Hay muchos art√≠culos que dicen que se garantiza que establecer una conexi√≥n pasar√° un 10% m√°s r√°pido.  Pero en Android 8.1.0 (vi varios dispositivos) nadie tiene TFO.  En Android 9, vi TFO en el emulador, pero no en dispositivos reales.  IOS est√° un poco mejor.  Aqu√≠ puedes verlo: <br><br><pre><code class="plaintext hljs">sysctl -a | grep fast net.ipv4.tcp_fastopen = 0</code> </pre> <br>  ¬øPor qu√© sucedi√≥ esto?  TCP Fast Open se propuso en 2014, ahora ya es un est√°ndar, es compatible con Linux y todo es genial.  Pero existe un problema tal que el apret√≥n de manos TFO comenz√≥ a desmoronarse en algunas redes.  Esto se debe a que algunos proveedores (o algunos dispositivos) est√°n acostumbrados a inspeccionar TCP, hacer sus optimizaciones, y no esperaban que el protocolo de enlace TFO estuviera all√≠.  Por lo tanto, su implementaci√≥n tom√≥ mucho tiempo, y hasta ahora, los clientes m√≥viles no lo incluyen por defecto, al menos Android. <br><br>  Con TLS 1.3, que nos promete que la configuraci√≥n de la conexi√≥n RTT cero es a√∫n mejor.  No encontr√© ning√∫n dispositivo Android en el que funcionara.  Por lo tanto, Facebook cre√≥ la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fizz</a> .  Hace un par de meses, estuvo disponible en c√≥digo abierto, puede arrastrarlo con usted y usar TLS 1.3.  Resulta que incluso la seguridad necesita ser arrastrada, nada aparece en el n√∫cleo de esto. <br><br><img src="https://habrastorage.org/webt/07/qm/kf/07qmkfwywo3llz5nrrh04kg3a_o.jpeg"><br><br>  El diagrama muestra el uso de varias versiones de Android por parte de nuestros clientes m√≥viles.  V 9.x es bastante, donde puede aparecer TFO, y TLS1.3 no se encuentra en ning√∫n otro lugar. <br><br>  <strong>Conclusiones sobre el establecimiento de una conexi√≥n:</strong> <br><br><ul><li>  TFO no est√° disponible para el 95% de los dispositivos. </li><li>  TLS1.3 necesita ser tra√≠do consigo mismo. </li><li>  Si necesita repetir esto en UDP, transfiera todo esto a UDP y repita. </li></ul><br><img src="https://habrastorage.org/webt/n2/tj/v1/n2tjv1g-04l2jfghy_6--uqaqjc.jpeg"><br><br>  Result√≥ que el 97% de las conexiones creadas usan la clave existente, es decir, el 97% se crea para cero RTT, y solo el 3% son nuevas.  La clave se almacena en el dispositivo durante alg√∫n tiempo. <br><br>  TCP no puede presumir de ello.  En un m√°ximo del 5% de los casos, si hace todo bien, podr√° obtener el verdadero RTT cero del que todo el mundo est√° hablando ahora. <br><br><h2>  Cambio de direcci√≥n IP </h2><br>  A menudo, cuando sales de casa, tu tel√©fono cambia de Wi-Fi a 4G. <br><br><blockquote>  TCP funciona as√≠: la direcci√≥n IP ha cambiado, la conexi√≥n ha fallado. </blockquote><br><img src="https://habrastorage.org/webt/km/nu/u8/kmnuu8dtr8jeipuzx4bhpfezuwm.jpeg"><br><br>  Si escribe su protocolo UDP, es muy simple, al implementar una ID de conexi√≥n (CUID) en cada paquete, puede identificarlo, incluso si proviene de una direcci√≥n IP diferente. <br><br><img src="https://habrastorage.org/webt/xu/ga/r_/xugar_l9pbltv6419btnrimfhv8.jpeg"><br><br>  Est√° claro que debe asegurarse de que tiene la clave correcta, todo est√° descifrado, etc.  Pero, en principio, puede comenzar a responder a esta direcci√≥n, no habr√° problemas con esto. <br><br><blockquote>  En TCP, la migraci√≥n de IP es algo imposible. </blockquote><br>  Si crea su UDP y lleg√≥ al mismo servidor, debe hacer un poco de magia, incluir el CID en cada paquete y podr√° utilizar la conexi√≥n establecida al cambiar la direcci√≥n IP. <br><br><h2>  Reutilizaci√≥n de conexi√≥n </h2><br>  Todo el mundo dice que debes reutilizar las conexiones porque las conexiones son muy caras. <br><br><img src="https://habrastorage.org/webt/8-/lr/ot/8-lrot44ac9mwo6m7ue_ksezk0g.jpeg"><br><br>  Pero hay dificultades en la reutilizaci√≥n de compuestos. <br><br><img src="https://habrastorage.org/webt/_n/aa/z3/_naaz3uac-hwdd7uikndioiupry.jpeg"><br><br>  Lo m√°s probable es que mucha gente recuerde (si no, entonces vea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ) que no todos tienen direcciones p√∫blicas, pero hay NAT, que generalmente almacena mapas durante alg√∫n tiempo en el enrutador dom√©stico.  Para TCP, est√° claro cu√°nto almacenar, pero para UDP no est√° claro.  NAT opera en un tiempo de espera, si mide cuidadosamente este tiempo de espera, obtenemos que en aproximadamente 15-30 segundos m√°s del 50% de las conexiones comenzar√°n a fallar. <br><br>  Est√° bien, haremos un paquete de ping-pong durante 15 s.  Para los casos en que la conexi√≥n a√∫n est√° interrumpida, existe la migraci√≥n de IP, que a bajo costo le permite cambiar el puerto en el enrutador. <br><br><img src="https://habrastorage.org/webt/7g/mu/bf/7gmubflfj-yenwqvgiqbkc8toa8.jpeg"><br><br><h2>  Estimulaci√≥n de paquetes </h2><br>  Esto es algo muy importante si est√° haciendo su protocolo UDP. <br><br><img src="https://habrastorage.org/webt/cf/d5/97/cfd597jt4v7uopygyyu-dfsx_8s.jpeg"><br><br>  Si es muy simple, cuanto m√°s tiempo env√≠e paquetes continuamente a la red, mayor ser√° la probabilidad de p√©rdida de paquetes.  Si filtra los paquetes, la p√©rdida de paquetes ser√° menor. <br><br>  Hay muchas teor√≠as diferentes sobre c√≥mo funciona esto, pero me gusta esta. <br><br><img src="https://habrastorage.org/webt/75/79/xl/7579xlvo70vmotoqjjp3zmmplr8.jpeg"><br><br>  Hay 3 conexiones que se crean a la vez.  Tiene la llamada ventana inicial: 10 paquetes creados al mismo tiempo.  Por supuesto, el ancho de banda podr√≠a no ser suficiente en este momento.  Pero si los distribuye cuidadosamente, sep√°relos, entonces todo estar√° bien, como en la figura correcta. <br><br>  Por lo tanto, si establece una velocidad uniforme para enviar paquetes, reduzca su volumen, entonces la probabilidad de que haya un desbordamiento del b√∫fer de una sola vez se reduce.  Esto no est√° probado, pero en teor√≠a resulta as√≠. <br><br><img src="https://habrastorage.org/webt/vw/mg/vw/vwmgvw6oyq3v_yaliklp4ilnocm.jpeg"><br><br>  Cuando necesite cortar paquetes (marque el ritmo): <br><br><ul><li>  Cuando creas una ventana. </li><li>  Cuando ampl√≠a la ventana, por ejemplo, se recomienda agregar tantos paquetes como se puedan enviar para RTT / 2.  Esto no degradar√° el tiempo de entrega, pero reducir√° la p√©rdida de paquetes. </li><li>  En el caso de p√©rdida de congesti√≥n, para reducir la ventana, debe untar los paquetes a√∫n m√°s.  4/5 RTT es una figura emp√≠ricamente seleccionada. </li></ul><br><h2>  MTU </h2><br>  Al escribir su protocolo UDP, aseg√∫rese de recordar acerca de MTU.  MTU es el tama√±o de los datos que puede reenviar. <br><br><img src="https://habrastorage.org/webt/c2/7_/ow/c27_ow36h5amg3d4zkskjph_ama.jpeg"><br><br>  Enviamos paquetes desde el servidor al cliente, por ejemplo, con un tama√±o de 1500. Si hay un enrutador en la ruta que no admite este tama√±o de MTU, lo fragmentar√°.  El √∫nico problema de fragmentaci√≥n es que si se pierde un paquete, ambos se perder√°n y todo esto tendr√° que retransmitirse.  Por lo tanto, TCP tiene un algoritmo para determinar MTU - PMTU. <br><br><img src="https://habrastorage.org/webt/je/gs/ks/jegskszkwrb3pm2nghgfpplez8o.jpeg"><br><br>  Cada enrutador mira el MTU de su interfaz, lo env√≠a a un cliente, el otro lo env√≠a a su cliente, todos saben cu√°ntas MTU tienen en el cliente.  Luego, la bandera proh√≠be la fragmentaci√≥n y se env√≠an paquetes de tama√±o MTU.  Si en este momento alguien dentro de la red se da cuenta de que tiene menos MTU, entonces a trav√©s de ICMP dir√°: "Lo siento, el paquete se perdi√≥ porque se necesita fragmentaci√≥n" e indicar√° el tama√±o de la MTU.  Cambiaremos este tama√±o y continuaremos enviando.  En el peor de los casos, nuestra peque√±a sobrecarga es RTT / 2.  Esto est√° en TCP. <br><br><img src="https://habrastorage.org/webt/vl/br/fo/vlbrfo8a7p80neysmtjguosakww.jpeg"><br><br>  Si en UDP no desea molestarse con ICMP, puede hacer lo siguiente: permitir la fragmentaci√≥n al enviar datos normales.  Es decir, para enviar paquetes fragmentados, d√©jelos trabajar.  Y en paralelo para comenzar un proceso que proh√≠ba la fragmentaci√≥n, una b√∫squeda binaria seleccionar√° la MTU √≥ptima, a la que luego iremos.  Esto no es del todo efectivo, porque al principio la MTU parecer√° calentarse. <br><br>  Una opci√≥n m√°s complicada es mirar la distribuci√≥n de MTU entre clientes m√≥viles. <br><br><img src="https://habrastorage.org/webt/ie/a5/w8/iea5w8h3msrkprfxpgfhb2nkjyu.jpeg"><br><br>  Desde todos los clientes, enviamos paquetes de varios tama√±os con la prohibici√≥n de la fragmentaci√≥n.  Es decir, si el paquete no alcanza, caer√° y la MTU m√°s peque√±a deber√≠a alcanzar el 100%.  Pero hay una peque√±a p√©rdida de paquetes, por lo que hay dos diapositivas en el gr√°fico: <br><br><ol><li>  1350 bytes: en lugar del 98%, recibimos el 95% de entrega de inmediato. </li><li>  1500 bytes - MTU, despu√©s de lo cual ya el 80% de los clientes no recibir√°n dichos paquetes. </li></ol><br><blockquote>  De hecho, podemos decir esto: descuidamos el 1-2% de nuestros clientes, les dejamos vivir en paquetes fragmentados.  Pero comenzaremos de inmediato con lo que necesitamos: esto es a partir de 1350. </blockquote><br><h2>  Correcci√≥n de errores (SACK, NACK, FEC) </h2><br>  Si est√° haciendo su protocolo, debe corregir los errores.  Si falta el paquete (esto es normal para las redes inal√°mbricas), debe restaurarse. <br><br>  En el caso m√°s simple (m√°s detalles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ), hay un rel√© a trav√©s de Retransmit Time Out (RTO).  Si falta el paquete, espere el tiempo de retransmisi√≥n y env√≠elo nuevamente. <br><br>  El siguiente algoritmo es la <b>retransmisi√≥n r√°pida</b> .  Todos estos son algoritmos TCP, pero se pueden portar f√°cilmente a UDP. <br><br><img src="https://habrastorage.org/webt/hm/s1/ee/hms1eey-ntpj2x0piswhxc4e5fa.jpeg"><br><br>  Cuando el paquete se va, continuamos enviando, hay una transmisi√≥n de otros paquetes.  En este momento, el servidor dice que recibi√≥ el siguiente paquete, pero que no hab√≠a ninguno anterior.  Para hacer esto, realiza un reconocimiento complicado, que es igual al n√∫mero de paquete + 1, y establece el indicador de reconocimiento duplicado.  √âl env√≠a estos duplicados as√≠, y en el tercero generalmente entendemos que el paquete ha desaparecido y lo enviamos nuevamente. <br><br>  Lo que m√°s quieres hacer con clase, lo que no est√° en TCP y lo que proponen hacer en UDP es la <b>correcci√≥n de errores de reenv√≠o</b> . <br><br><img src="https://habrastorage.org/webt/ex/_u/gg/ex_uggyt0-4ntdgzy-vn7hvmyzg.jpeg"><br><br>  Parece que si sabemos que los paquetes pueden perderse, podemos tomar un conjunto de paquetes, agregarle un paquete XOR y solucionar el problema sin retransmisiones adicionales inmediatamente en el cliente al recibir datos.  Pero hay un problema si varios paquetes desaparecen.  Parece que se puede resolver a trav√©s de la protecci√≥n de paridad, Reed-Solomon, etc. <br><br>  Lo intentamos de esta manera, result√≥ que, de hecho, los paquetes desaparecen en paquetes. <br><br><img src="https://habrastorage.org/webt/fg/qo/jj/fgqojj1gas9pgutyyyzkla_m5ze.jpeg"><br><br>  El intervalo de paquetes promedio result√≥ ser 6. Este es un intervalo de paquetes muy inconveniente: necesita muchos c√≥digos de correcci√≥n de errores.  Al mismo tiempo, hay alg√∫n tipo de pico a las 11: no s√© por qu√©, pero los paquetes a veces desaparecen en paquetes de 11.  Debido a esta brecha de paquetes, esto no funciona. <br><br>  Google tambi√©n intent√≥ esto, todos sue√±an con FEC, pero hasta ahora nadie ha trabajado. <br><br>  Hay otra opci√≥n cuando FEC puede ayudar. <br><br><img src="https://habrastorage.org/webt/d9/tb/tw/d9tbtwafxbt_t08_j9wvarw5icc.jpeg"><br><br>  Adem√°s de retransmitir a trav√©s de Retransmit Time Out, Fast Retransmit, tambi√©n hay una <strong>sonda de p√©rdida de cola</strong> .  Esto es as√≠ cuando env√≠a datos, y la cola se ha ido.  Es decir, envi√≥ parte de los datos, envi√≥ el quinto paquete, ya lleg√≥.  Luego, los paquetes comenzaron a desaparecer, por ejemplo, porque la red fall√≥.  Los paquetes desaparecen, desaparecen, y recibi√≥ un acuse de recibo solo para el quinto paquete. <br><br>  Para comprender si se han alcanzado estos datos, despu√©s de un tiempo comienza a hacer TLP (sonda de p√©rdida de cola), pregunte si se recibe el final.  El hecho es que la transferencia de datos ha finalizado y no est√° enviando nada, entonces la retransmisi√≥n r√°pida no funcionar√°.  Para solucionar esto, haga un TLP. <br><br>  Puede agregar FEC a TLP.  Puede ver todos los paquetes que no llegaron, contar la paridad en ellos y enviar TLP con alg√∫n paquete de paridad. <br><br>  Todo esto es genial, parece funcionar.  Pero hay tal problema. <br><br><img src="https://habrastorage.org/webt/pt/y5/qm/pty5qmye2nqwrocxnp3fv5-gll4.jpeg"><br><br>  Recopilamos estad√≠sticas, y result√≥ que el 98% de los errores se reparan a trav√©s de la retransmisi√≥n r√°pida.  El resto se repara mediante Retransmit Time Out, y menos del 1% a trav√©s de TLP.  Si arregla algo m√°s FEC, ser√° menos del 0.5%. <br><br><blockquote>  TCP no es compatible con FEC.  En UDP no es dif√≠cil hacer esto, pero en el caso general, los algoritmos de recuperaci√≥n TCP est√°ndar son suficientes. </blockquote><br><h2>  Rendimiento </h2><br>  Ser√≠a posible no da√±ar el rendimiento al comparar TCP con UDP. <br><br>  TCP es un protocolo muy antiguo con muchas optimizaciones diferentes, por ejemplo, LSO (descarga de segmento grande) y zerocopy.  Ahora para UDP no est√° disponible.  Por lo tanto, el rendimiento UDP es solo del 20% en relaci√≥n con el TCP de los mismos servidores.  Pero ya hay soluciones listas para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usar</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UDP GSO</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">zerocopy</a> ) que permiten a Linux soportar esto. <br><br>  El principal problema que soporta la optimizaci√≥n para zerocopy y LSO es que se pierde el ritmo. <br><br><img src="https://habrastorage.org/webt/qu/6i/th/qu6ith66mowy_jm9iznjsstsadm.jpeg"><br><br><h2>  Tiempo de comercializaci√≥n o lo que mat√≥ a TCP </h2><br>  Recientemente, cuando las redes inal√°mbricas m√≥viles se hicieron populares, aparecieron muchos est√°ndares TCP diferentes: TLP, TFO, nuevo control de congesti√≥n, RACK, BBR y m√°s. <br><br><img src="https://habrastorage.org/webt/nq/lx/5a/nqlx5a_sq5zzvi2au81ulptczew.jpeg"><br><br><blockquote>  Pero el problema principal es que muchos de ellos no se est√°n implementando, porque se dice que TCP est√° osificado.  En muchos casos, los operadores miran los paquetes TCP y esperan ver lo que esperan.  Por lo tanto, es muy dif√≠cil cambiar. </blockquote><br>  Adem√°s, los clientes m√≥viles se actualizan durante mucho tiempo y no podemos entregar estas actualizaciones.  Si observa cu√°les son las √∫ltimas actualizaciones recientes disponibles en el cliente y qu√© hay en el servidor, puede decir que no hay casi nada en el cliente. <br><br><img src="https://habrastorage.org/webt/au/57/iw/au57iwnkvrjzkvrpo2osdo7f49e.jpeg"><br><br>  Por lo tanto, la decisi√≥n de escribir un protocolo en el espacio del usuario, al menos mientras acumule todas estas caracter√≠sticas, no parece tan mala. <br><br><img src="https://habrastorage.org/webt/6i/o6/po/6io6poew2qopzofy3vbflm3-5a8.jpeg"><br><br>  Con TCP, las funciones han estado funcionando durante a√±os.  Para su protocolo UDP, puede actualizar la versi√≥n literalmente en una actualizaci√≥n del cliente y el servidor.  Pero deber√° agregar la negociaci√≥n de la versi√≥n. <br><br><h2>  TCP vs UDP hecho a s√≠ mismo.  Pelea final </h2><br><img src="https://habrastorage.org/webt/fx/q6/ct/fxq6ctnz94vaf7pfr7jmrcbz7lu.jpeg"><br><br><ul><li>  B√∫fer de env√≠o / recepci√≥n: se puede hacer un b√∫fer mutable para su protocolo, habr√° problemas con el b√∫fer hinchado con TCP. </li><li>  Control de congesti√≥n que puede utilizar existente.  En UDP son cualquiera. </li><li>  El nuevo control de congesti√≥n es dif√≠cil de agregar a TCP, porque necesita modificar el reconocimiento, no puede hacerlo en el cliente. </li><li>  La multiplexaci√≥n es un tema cr√≠tico.  El bloqueo de encabezado de l√≠nea ocurre, cuando pierde un paquete, no puede multiplexar a TCP.  Por lo tanto, HTTP2.0 sobre TCP no deber√≠a dar un aumento serio. </li><li>  Los casos en que puede obtener una configuraci√≥n de conexi√≥n para 0-RTT en TCP son extremadamente raros, del orden del 5% y del orden del 97% para UDP de fabricaci√≥n propia. </li></ul><br><img src="https://habrastorage.org/webt/4f/_f/oe/4f_foen6zvxf5mexl8p6jfu2izm.jpeg"><br><br><ul><li>  La migraci√≥n de IP no es una caracter√≠stica tan importante, pero en el caso de suscripciones complejas y el estado de almacenamiento en el servidor, definitivamente es necesaria, pero no se implementa en TCP. </li><li>  La desvinculaci√≥n de Nat no est√° a favor de UDP.  En este caso, UDP a menudo necesita hacer paquetes de ping-pong. </li><li>  El ritmo de paquetes en UDP es simple, aunque no hay optimizaci√≥n, en TCP esta opci√≥n no funciona. </li><li>  MTU y correcci√≥n de errores son comparables. </li><li>  La velocidad de TCP, por supuesto, es m√°s r√°pida que UDP ahora, si est√° distribuyendo una tonelada de tr√°fico.  Pero luego algunas optimizaciones tardan mucho en entregarse. </li></ul><br>  Si recopila todo lo m√°s importante, entonces UDP, m√°s probablemente, tiene m√°s ventajas que desventajas. <br><br><img src="https://habrastorage.org/webt/p4/7k/ys/p47kysilkuqtb-x-zc0cwhigeoe.jpeg"><br><br>  <b>¬°Elige UDP!</b> <br><br><h2>  Probar UDP hecho a s√≠ mismo en usuarios </h2><br>  Hemos creado un banco de pruebas. <br><br><img src="https://habrastorage.org/webt/rh/er/ec/rherec8kewip9-ycek5qimdgvuw.jpeg"><br><br>  Hay un cliente en TCP y UDP.  Normalizamos el tr√°fico a trav√©s de Net Shaper, enviado a Internet y al servidor.  Un servicio REST API, el segundo con UDP.  Y UDP va a la misma API REST dentro del mismo centro de datos para verificar los datos.  Recopilamos diferentes perfiles de nuestros clientes m√≥viles y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lanzamos la prueba</a> . <br><br><img src="https://habrastorage.org/webt/sy/rf/nf/syrfnflhcgpr13bngr1y7cv5fle.jpeg"><br><br>  Al medir el promedio sobre el portal, vimos que pudimos reducir el tiempo de llamar a la API en un 10%, las im√°genes en un 7%.  La actividad de los usuarios creci√≥ solo un 1%, pero no nos rendimos, creemos que ser√° mejor. <br><br><img src="https://habrastorage.org/webt/o9/wr/bj/o9wrbjk45dk58yjji6t8boe9-xw.jpeg"><br><br>  En t√©rminos de cargas, ahora tenemos alrededor de 10 millones de usuarios en nuestro UDP hecho a s√≠ mismo, tr√°fico de hasta 80 Gb / s, 6 millones de paquetes por segundo y 20 servidores sirven para esto. <br><br><h2>  Lista de verificaci√≥n UDP <br></h2><br>  Si va a escribir su protocolo, necesita una lista de verificaci√≥n: <br><br><ul><li>  Ritmo </li><li>  Descubrimiento de MTU. </li><li>  <strong>Se requieren correcciones de errores</strong> . </li><li>  Control de flujo y control de congesti√≥n. </li><li>  Opcionalmente, puede admitir la migraci√≥n de IP, TLP es f√°cil. </li></ul><br>  Recuerde que los canales son asim√©tricos, y mientras recibe datos del servidor, su carga puede estar inactiva, intente usarla. <br><br><h2>  QUIC </h2><br>  Ser√≠a deshonesto decir que Google no lo hizo. <br><br><img src="https://habrastorage.org/webt/z0/b9/-v/z0b9-v9kmmobln4nv2yado-rble.jpeg"><br><br>  Hay un protocolo QUIC que Google implement√≥ bajo HTTP 2.0, que admite casi lo mismo. <br><br><h3>  ¬øPor qu√© QUIC no es tan r√°pido? </h3><br>  Cuando sali√≥ QUIC, se odiaba mucho el hecho de que Google dice que todo funciona m√°s r√°pido y "lo med√≠ en casa en una computadora, funciona m√°s lento". <br><br><img src="https://habrastorage.org/webt/db/5a/vd/db5avdtu1zaito8ntcmg-hdvwy8.jpeg"><br><br>  Este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo tiene un</a> mont√≥n de im√°genes y medidas. <br><br>  Bueno, resulta que hicimos todo esto en vano, ¬øla gente nos midi√≥?  Hay mediciones reales en el hogar, incluso con ejemplos de c√≥digo. <br><br><img src="https://habrastorage.org/webt/id/wr/39/idwr39saesks74hbadevlunieua.jpeg"><br><br>  De hecho, no habr√° mejoras hasta que paralelice las solicitudes, trabaje en redes reales y hasta que las p√©rdidas de paquetes se dividan en p√©rdida de congesti√≥n y p√©rdida aleatoria.  Necesitamos una emulaci√≥n real de una red real. <br><br>  Pero hay un aspecto positivo, dicen, QUIC no es ni mejor ni peor.  Por lo tanto, en redes perfectas, QUIC funciona bien. <br><br><h2>  El futuro </h2><br>  Google recientemente nombr√≥ HTTP 2.0 sobre QUIC HTTP 3, para no confundirlo, porque HTTP 2.0 podr√≠a estar sobre TCP y QUIC.  Ahora es HTTP 3. <br><br><img src="https://habrastorage.org/webt/go/ra/z4/goraz4ktgsje7ankwyipapzeow0.jpeg"><br><br>  Tambi√©n hubo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Google QUIC</a> , esto es QUIC, que se implementa en Chrome, e iQUIC, un QUIC estandarizado.  El QUIC estandarizado no se implement√≥ en ninguna parte, los servidores iQUIC est√°ndar no se dieron la mano con Google QUIC.  Ahora prometen resolver este problema, y ‚Äã‚Äãpronto estar√° disponible. <br><br><h3>  QUIC est√° en todas partes </h3><br>  Si todav√≠a no cree que TCP est√° muerto, le dir√© que cuando usa Chrome, Android y pronto iOS, y va a google, youtube, etc., entonces usa QUIC y UDP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prueba de enlace</a> ). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">QUIC ahora</a> es: <br><br><ul><li>  1.9% de todos los sitios web; </li><li>  12% de todo el tr√°fico; </li><li>  30% del tr√°fico de video en redes m√≥viles. </li></ul><br>  ¬øC√≥mo verificar que usas QUIC si no crees?  Abrir en Chrome Wireshark.  Estaba buscando iQUIC, no lo he encontrado en ning√∫n lado, pero sucede GQUIC. <br><br><img src="https://habrastorage.org/webt/t_/8v/9q/t_8v9qsq9jcgbjkf9vqqr67vw7k.jpeg"><br><br>  Tambi√©n puede conectarse en l√≠nea en su navegador y tambi√©n ver qu√© GQUIC est√° all√≠. <br><br><img src="https://habrastorage.org/webt/av/ko/p5/avkop5nphmxm6ee3rqc2hi23wzu.jpeg"><br><br><h3>  Un poco mas de futuro </h3><br>  Multipath nos espera pronto. <br><br><img src="https://habrastorage.org/webt/d8/bi/wo/d8biwobqjbdjqdn8g-wb7gegka0.jpeg"><br><br>  Cuando tiene un cliente m√≥vil que tiene Wi-Fi y 3G, puede usar ambos canales.  Multipath TCP ahora est√° en desarrollo y estar√° disponible pronto en el kernel de Linux.  Obviamente, no llegar√° a los clientes pronto, creo que se puede hacer en UDP mucho m√°s r√°pido. <br><br><img src="https://habrastorage.org/webt/pb/7o/yt/pb7oytnkrhutg6qtqlwq0jf3p4o.jpeg"><br><br>  Dado que realizamos muchas traducciones de 3 TB cada una, a menudo utilizamos tecnolog√≠as como la distribuci√≥n de CDN y p2p, cuando se necesita entregar el mismo contenido a muchos usuarios de todo el mundo. <br><br>  En IPv6 hay multidifusi√≥n con UDP, lo que permitir√° entregar paquetes a varios usuarios suscritos a la vez.  Por lo tanto, creo que las tecnolog√≠as CDN y p2p no ser√°n necesarias en el futuro cercano si entregamos todo el contenido mediante multidifusi√≥n a IPv6. <br><br><h2>  Conclusiones </h2><br>  Espero que entiendas: <br><br><ul><li>  C√≥mo funciona realmente la red, y que TCP se puede repetir sobre UDP y hacerlo mejor. </li><li>  Ese TCP no es tan malo si lo configura correctamente, pero realmente se rindi√≥ y casi ya no se est√° desarrollando. </li><li>  No conf√≠es en los que odian UDP que dicen que no trabajar√°n en el espacio del usuario.  Todos estos problemas pueden resolverse.  Pru√©balo, este es el futuro cercano. </li><li>  Si no lo cree, puede y debe tocar la red con las manos.  Mostr√© c√≥mo se puede verificar casi todo. </li></ul><br>  ¬øLe√≠ste todo y descubriste qu√© sigue? <br><br><ul><li>  Configure el protocolo (TCP, UDP, no importa) para la situaci√≥n (perfil de red + perfil de carga). </li><li>  Use las recetas TCP que le dije: TFO, b√∫fer de env√≠o / recepci√≥n, TLS1.3, CC ... </li><li>  Haga sus protocolos UDP si tiene los recursos. </li><li>  Si ha hecho su UDP, verifique en la lista de verificaci√≥n UDP que ha hecho todo lo que necesita.  Olvidando cualquier tonter√≠a como el ritmo, no funcionar√°. </li></ul><br>  Si no tiene los recursos, prepare su infraestructura para QUIC.  Tarde o temprano √©l vendr√° a ti. <br><br><blockquote>  Estamos determinando el futuro.  Decidimos qu√© protocolos usar.  Si desea usar QUIC, √∫selo, si desea su UDP o permanecer en TCP, decida el futuro usted mismo. </blockquote><br><h3>  Enlaces utiles </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Millones de videollamadas por d√≠a o "¬°Llama a mam√°!"</a>  . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estamos escribiendo nuestro protocolo sobre UDP</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Podcast sobre optimizaci√≥n de redes</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aumente la velocidad de transferencia de datos en redes defectuosas</a> . </li></ul><br><blockquote>  Hasta el 7 de septiembre, a√∫n puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enviar una solicitud</a> para Moscow <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HighLoad ++</a> y compartir c√≥mo prepara sus servicios para grandes cargas.  Pero el programa ya se est√° llenando gradualmente, desde Odnoklassniki se han recibido informes sobre la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nueva arquitectura de la</a> gr√°fica de amigos, sobre la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">optimizaci√≥n del servicio de regalos</a> para grandes cargas y sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">qu√© hacer</a> si ha optimizado todo y los datos no llegan al usuario lo suficientemente r√°pido. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461829/">https://habr.com/ru/post/461829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461817/index.html">CMake y C ++: hermanos para siempre</a></li>
<li><a href="../461819/index.html">¬øPor qu√© el dise√±o simple de un sitio web es mejor cient√≠ficamente?</a></li>
<li><a href="../461821/index.html">La nueva inmunoterapia elimin√≥ todos los tumores en una mujer con c√°ncer de seno metast√°sico</a></li>
<li><a href="../461823/index.html">Cuatro reglas mejoradas para el dise√±o de software</a></li>
<li><a href="../461827/index.html">Desarrollo de aplicaciones h√≠bridas PHP / Go con RoadRunner</a></li>
<li><a href="../461831/index.html">StealthWatch: implementaci√≥n y personalizaci√≥n. Parte 2</a></li>
<li><a href="../461833/index.html">No te pierdas en tres pinos: una representaci√≥n egoc√©ntrica del entorno.</a></li>
<li><a href="../461835/index.html">C√≥mo los gr√°ficos de Gantt simplifican y potencian la gesti√≥n de proyectos</a></li>
<li><a href="../461841/index.html">PVS-Studio investig√≥ el motor de bala del Red Dead Redemption</a></li>
<li><a href="../461845/index.html">Inversiones en bolsa como forma de preservar las finanzas: 3 m√©todos de trabajo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>