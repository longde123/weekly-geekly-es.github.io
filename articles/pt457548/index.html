<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôüÔ∏è üïç üëª Gera√ß√£o de sinal PWM multif√°sico no TMS320F28027 üßöüèº üöä üçè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Era uma vez  em uma gal√°xia distante e distante  Escrevi um pequeno artigo sobre o controlador Piccolo especializado da Texas Instruments, projetado p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gera√ß√£o de sinal PWM multif√°sico no TMS320F28027</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457548/"><p>  Era uma vez <del>  em uma gal√°xia distante e distante </del>  Escrevi um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pequeno artigo</a> sobre o controlador Piccolo especializado da Texas Instruments, projetado para controlar conversores de energia e acionamentos el√©tricos.  Esses controladores s√£o ferramentas de desenvolvimento muito poderosas em muitas tarefas e eu queria escrever algo mais sobre eles ... simples e √∫til. </p><br><p>  Recentemente, fiquei intrigado ao desenvolver um controlador para controle de motor e, consequentemente, um t√≥pico para o artigo foi formado - hoje vou falar sobre o processo de forma√ß√£o de um PWM trif√°sico para controle de motor, al√©m de explicar as diferen√ßas ben√©ficas entre o TMS320F28 e outros controladores, como STM32F334, STM32G484, XMC4200 e outros. </p><br><p>  Como suporte, usarei o controlador em desenvolvimento, infelizmente, n√£o posso falar sobre a pe√ßa de ferro em detalhes.  No entanto, se eu disser que o controlador √© baseado no pacote TMS320F28027 + DRV8353RSRGZT, voc√™ pode olhar para os dados do driver e ver o conceito geral de circuitos + h√° depura√ß√£o nessa pedra e o design de refer√™ncia est√° aberto nela. </p><br><p><img src="https://habrastorage.org/webt/bu/ps/ur/bupsur6y9nfobnpa53zqjrfodmo.jpeg" alt="Driver BLDC"></p><br><p>  Em princ√≠pio, no mesmo tipo de circuito, √© poss√≠vel controlar motores BLDC que "consomem" n√≠veis de tens√£o e trif√°sicos comuns, que j√° desejam uma sa√≠da sinusoidal.  Vou mostrar as duas op√ß√µes, como  o caminho para o seno reside na forma√ß√£o de n√≠veis de tens√£o. </p><br><p><img src="https://habrastorage.org/webt/qf/rd/ck/qfrdck6y4rcvirbws9o6zbzrfea.png" alt="Oscilograma n√∫mero 1"></p><a name="habracut"></a><br><h1 id="nemnogo-o-zheleze">  Um pouco sobre ferro </h1><br><p>  A parte de pot√™ncia do driver consiste ideologicamente em 3 conversores de meia ponte, provavelmente todos os chastotniks e controladores para controlar os motores BLDC em todos os helic√≥pteros, de forma semelhante: </p><br><p><img src="https://habrastorage.org/webt/fm/kd/3t/fmkd3tequjgg3gapytg5bvupwfw.png" alt="Ponte trif√°sica"></p><br><p>  Uma diferen√ßa - eu n√£o tenho um retificador de entrada, porque  o controlador √© alimentado inicialmente por uma tens√£o constante.  A fonte de energia no meu caso √© um conjunto de baterias de √≠on de l√≠tio na forma de c√©lulas 18650. O driver DRV8353RSRGZT usado pode controlar apenas 3 meias-pontes de energia, tamb√©m na vers√£o usada da pedra tamb√©m existem amplificadores operacionais integrados para trabalhar com deriva√ß√µes como sensores de corrente, embutidos dc / dc, que pode digerir at√© 70 ... 80V e tudo isso √© configurado de maneira muito flex√≠vel via SPI.  Por exemplo, √© muito conveniente poder ajustar a corrente m√°xima de pulso do controle do transistor. </p><br><p>  Tamb√©m nesta s√©rie existem drivers com um conjunto diferente de fun√ß√µes, por exemplo, existem com controle anal√≥gico, n√£o SPI ou sem dc / dc embutido e sem amplificador operacional.  Pelo pre√ßo, eles n√£o s√£o muito diferentes e eu peguei o mais "ousado", como voc√™ provavelmente j√° entendeu.  Essa coisa toda parece muito bonita, mas eu me aproximei frivolamente do design da liga√ß√£o do driver e consegui dois problemas significativos.  De fato, existe apenas um problema - esse √© um superaquecimento forte: </p><br><p><img src="https://habrastorage.org/webt/hh/ud/hh/hhudhh5jk3tpwowsivbvjjar66e.jpeg" alt="Termovisor"></p><br><p>  Mas esse problema foi causado por 2 raz√µes.  Na verdade, a ess√™ncia do problema √© o superaquecimento do pr√≥prio driver.  No termograma, o motorista √© carregado com uma corrente de 5A (para ele est√° quase ociosa) e nada al√©m do motorista e do pr√≥prio MK √© aquecido um pouco.  Os transistores nem s√£o vis√≠veis, eles t√™m uma temperatura de PCB, em 5A h√° escassas perdas de calor. </p><br><ul><li>  <strong>Erro n¬∫ 1</strong> <br>  Fui solicitado por um amigo meu, sinceramente, eu pensaria nisso como a √∫ltima coisa - o driver possui um dc / dc interno, que recebe 15 ... 50V de entrada e produz 3,3V para alimentar o MK, l√≥gica, comparadores e amplificadores operacionais.  Parece que meus projetos t√™m microchips LM5008 e LM5017 na forma de microchips separados e eu reduzi calmamente 60V a 3,3V sem aquecimento percept√≠vel a uma corrente de 100-150 mA, mas tudo ficou mais complicado - a efici√™ncia geral do conversor acabou sendo de 65 a 70% a uma corrente 300 mA!  O fato √© que o pr√≥prio conversor pode fornecer 3,3V, mas a efici√™ncia ser√° escassa; √© ideal definir a tens√£o de sa√≠da 10-12-15V.  Quando a sa√≠da era de 12V a 100 mA, meu motorista parou de aquecer praticamente e a efici√™ncia atingiu 88% agrad√°veis.  <strong>A solu√ß√£o para o problema</strong> √© abaixar a entrada de 15 ... 50V a 12V com a CC / CC incorporada e depois abaixar de 12V a 3,3V com uma CC / CC externa j√° barata. </li></ul><br><br><ul><li>  <strong>Erro n¬∫ 2</strong> <br>  O segundo erro √© mais √≥bvio e a primeira coisa que eu pequei nele quanto pude.  O fato √© que, para os chips do pacote QFN, o calor principal √© removido atrav√©s da "barriga", geralmente fica no GND e, por v√°rias vias (via), se agarra ao ch√£o e todo o calor vai para l√° com calma.  Inicialmente, n√£o levei em conta a escassa efici√™ncia do dc / dc embutido com uma grande diferen√ßa de tens√£o, por isso n√£o me incomodou que a queda t√©rmica ("ventre") se agarrasse a um pol√≠gono GND s√≥lido na camada interna, na camada externa n√£o havia cobre sob o ventre como pol√≠gono GND  Como resultado, verificou-se que ~ 0,5 W de calor s√£o liberados no chip e se dissipam na camada interna da placa, ou seja, a efici√™ncia √© muito baixa.  <strong>A solu√ß√£o para o problema</strong> √© que voc√™ precisa fazer um teste de aterramento na camada externa (camada inferior) e n√£o fazer isso: </li></ul><br><p><img src="https://habrastorage.org/webt/xj/hr/0g/xjhr0galowhdsrtub50fwouwj_s.png" alt="Placa de circuito"></p><br><p>  Como resultado, na segunda revis√£o do ferro, esses erros foram corrigidos: um conversor externo dc / dc 12-3.3V foi adicionado e o pol√≠gono GND foi adicionalmente preenchido na camada inferior e o chip pad foi plantado nele + o pol√≠gono interno s√≥lido foi preservado.  Ap√≥s essas melhorias, a temperatura em opera√ß√£o cont√≠nua diminuiu de +82 para +43 <sup>o</sup> C: </p><br><p><img src="https://habrastorage.org/webt/_p/t9/qf/_pt9qfhtiicqqdj-kuo_ssg2zsm.png" alt="Termograma"></p><br><p>  Como voc√™ pode ver, devido √† redu√ß√£o de perdas, a temperatura diminuiu significativamente nas mesmas condi√ß√µes, assim como o calor agora √© distribu√≠do de maneira mais uniforme na √°rea da placa e n√£o superaquece localmente o driver ou o microcontrolador.  Em princ√≠pio, tudo era de ferro, nada mais interessante aconteceu e funcionou de forma est√°vel.  Como resultado, eles podem recomendar o uso do driver <strong>DRV8353</strong> . </p><br><h1 id="realizaciya-apparatnogo-sdviga-faz-na-120suposup">  Implementa√ß√£o de uma mudan√ßa de fase de hardware de 120 <sup>o</sup> </h1><br><p>  Uma caracter√≠stica da rede trif√°sica √© que a corrente nas fases n√£o √© s√≠ncrona, mas √© deslocada em 120 <sup>o em</sup> rela√ß√£o √† rede vizinha.  O que √© essa mudan√ßa de fase de 120¬∫ em geral?  Em termos simples, essa √© uma mudan√ßa do ponto inicial da gera√ß√£o em 1/3 do per√≠odo.  Do ponto de vista matem√°tico, o per√≠odo do sinal √© <em>2œÄ</em> , o que significa que o segundo sinal deve ser movido por 2œÄ / 3 e o terceiro por 4œÄ / 3.  Do ponto de vista eletr√¥nico, o per√≠odo √© definido pelo per√≠odo de contagem regressiva do nosso timer.  Por exemplo, ao cronometrar em 60 MHz, queremos obter um PWM com uma frequ√™ncia de 50 kHz, o que significa que o per√≠odo de contagem regressiva do temporizador ser√° de 0 a 1200 (60 000 000 Hz / 50 000 Hz = 1200).  Agora, para obter 3 fases com um deslocamento de 120 <sup>o,</sup> n√£o precisamos tocar na 1¬™ fase, adicionar +400 ao valor atual da 2¬™ fase, adicionar +800 √† fase atual. </p><br><p>  Se usarmos microcontroladores no n√∫cleo do c√≥rtex, podemos implementar a mudan√ßa escrevendo uma f√≥rmula matem√°tica ou usando a sincroniza√ß√£o de eventos.  Sempre foi incr√≠vel para mim por que ST, NXP e outros n√£o apenas registravam onde o valor do turno seria gravado.  Felizmente, a TI fez isso no seu TMS320F28xxx, para definir a mudan√ßa, basta escrever um registro!  N√£o vou explicar por que a solu√ß√£o de software n√£o √© √≥tima, apenas direi que considera as f√≥rmulas MK n√£o muito rapidamente.  O profissional com sincroniza√ß√£o de eventos j√° √© mais adequado e, no stm, eu faria exatamente isso, mas essa op√ß√£o n√£o permite alterar o valor da fase em tempo real, ou seja, para alguma ponte de fase deslocada novamente, apenas a vers√£o do software permanece.  A vantagem da capacidade de controlar o hardware da fase?  Cabe a voc√™ decidir, minha tarefa √© dizer que √© poss√≠vel.  Para mim, essa √© uma vantagem √≥bvia quando falamos em controlar um acionamento el√©trico ou inversor de tens√£o com uma sa√≠da trif√°sica. </p><br><p>  Agora vamos configurar a gera√ß√£o de sinais PWM na forma de 3 pares complementares com tempo morto e mudan√ßa de fase.  At√© agora sem um seno.  Utilizarei os seguintes pares: EPWM1A + EPWM1B, EPWM2A + EPWM2B e EPWM4A + EPWM4B.  Estes s√£o os sinais que v√£o do microcontrolador para o driver. </p><br><ul><li>  <strong>Etapa 1</strong> <br>  √â necess√°rio configurar o multiplexador GPIO usando o registro <em>GPAMUX</em> para trabalhar com o PWM e desativar os <em>pull-ups da</em> sa√≠da da fonte de alimenta√ß√£o, para que, quando voc√™ a ligue, n√£o exista um log.1 em todas as pernas e as teclas n√£o sejam abertas.  A prote√ß√£o atual certamente salvar√°, mas √© melhor n√£o fazer isso.  Tamb√©m √© importante lembrar que, para acessar os registros de instala√ß√£o, √© necess√°rio obt√™-lo com o comando <em>EALLOW</em> e, em seguida, <em>reativar</em> a prote√ß√£o contra substitui√ß√£o com o comando <em>EDIS</em> . </li></ul><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitGPIOforPWM</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPAPUD.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Disable pull-up on GPIO0 (EPWM1A) GpioCtrlRegs.GPAPUD.bit.GPIO1 = 1; // Disable pull-up on GPIO1 (EPWM1B) GpioCtrlRegs.GPAMUX1.bit.GPIO0 = 1; // Configure GPIO0 as EPWM1A GpioCtrlRegs.GPAMUX1.bit.GPIO1 = 1; // Configure GPIO1 as EPWM1B GpioCtrlRegs.GPAPUD.bit.GPIO2 = 1; // Disable pull-up on GPIO2 (EPWM2A) GpioCtrlRegs.GPAPUD.bit.GPIO3 = 1; // Disable pull-up on GPIO3 (EPWM2B) GpioCtrlRegs.GPAMUX1.bit.GPIO2 = 1; // Configure GPIO2 as EPWM2A GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 1; // Configure GPIO3 as EPWM2B GpioCtrlRegs.GPAPUD.bit.GPIO6 = 1; // Disable pull-up on GPIO6 (EPWM4A) GpioCtrlRegs.GPAPUD.bit.GPIO7 = 1; // Disable pull-up on GPIO7 (EPWM4B) GpioCtrlRegs.GPAMUX1.bit.GPIO6 = 1; // Configure GPIO6 as EPWM4A GpioCtrlRegs.GPAMUX1.bit.GPIO7 = 1; // Configure GPIO7 as EPWM4B EDIS; }</span></span></code> </pre> <br><ul><li>  <strong>Etapa 2</strong> <br>  Configure a gera√ß√£o do sinal PWM.  √â necess√°rio obter uma frequ√™ncia de 50 kHz e uma mudan√ßa de fase de 120 <sup>o</sup> .  Nesse caso, eu uso o PWM usual, porque neste controlador tamb√©m h√° HRPWM, √© importante lembrar disso.  O m√≥dulo PWM √© com freq√º√™ncia na freq√º√™ncia central, ou seja, 60 MHz, mostrei como definir a frequ√™ncia PLL no primeiro artigo no TMS320, n√£o repetirei, mas no final do artigo haver√° um arquivo com o c√≥digo e ser√° poss√≠vel espiar l√°. </li></ul><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitPWM</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// EPWM Module 1 config EPwm1Regs.TBPRD = 600; // Set priod EPwm1Regs.TBPHS.half.TBPHS = 0; // Set phase EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; // Symmetrical mode EPwm1Regs.TBCTL.bit.PHSEN = TB_DISABLE; // Master enable EPwm1Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm1Regs.TBCTL.bit.SYNCOSEL = TB_CTR_ZERO; // Sync down-stream module EPwm1Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm1Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm1Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm1Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm1Regs.AQCTLA.bit.CAU = AQ_SET; EPwm1Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm1Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // enable dead-time module EPwm1Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // Active Hi complementary EPwm1Regs.DBFED = 20; // dead-time on 20 tick EPwm1Regs.DBRED = 20; // dead-time off 20 tick // EPWM Module 2 config EPwm2Regs.TBPRD = 600; EPwm2Regs.TBPHS.half.TBPHS = 400; // Set phase = 400/1200 * 360 = 120 deg EPwm2Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; EPwm2Regs.TBCTL.bit.PHSEN = TB_ENABLE; // Slave enable EPwm2Regs.TBCTL.bit.PHSDIR = TB_DOWN; // Count DOWN on sync (=120 deg) EPwm2Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm2Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; // sync flow-through EPwm2Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm2Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm2Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm2Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm2Regs.AQCTLA.bit.CAU = AQ_SET; EPwm2Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm2Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; EPwm2Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; EPwm2Regs.DBFED = 20; EPwm2Regs.DBRED = 20; // EPWM Module 4 config EPwm4Regs.TBPRD = 600; EPwm4Regs.TBPHS.half.TBPHS = 400; EPwm4Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; EPwm4Regs.TBCTL.bit.PHSEN = TB_ENABLE; EPwm4Regs.TBCTL.bit.PHSDIR = TB_UP; EPwm4Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm4Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; EPwm4Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm4Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm4Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm4Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm4Regs.AQCTLA.bit.CAU = AQ_SET; EPwm4Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm4Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; EPwm4Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; EPwm4Regs.DBFED = 20; EPwm4Regs.DBRED = 20; }</span></span></code> </pre> <br><p>  Agora, um pouco mais detalhadamente ... no registro <em>TBPRD,</em> escrevemos o per√≠odo, ou melhor, "per√≠odo / 2", porque  Se considerarmos o temporizador em ambas as dire√ß√µes, verifica-se que o per√≠odo 600 corresponde √† frequ√™ncia do sinal PWM de sa√≠da de 50 kHz no modo de par complementar.  No registro <em>TBPHS,</em> escrevemos o valor da fase pelo qual precisamos mudar, neste caso 400 de 600, o que corresponde a 2œÄ / 3.  Vale a pena notar que n√£o estamos movendo a 1¬™ fase, portanto, para o turno √© 0, para o 2¬∫ est√°gio o turno √© de 400, respectivamente, mas para o 3¬∫ est√°gio pareceria l√≥gico escrever 800, mas 800 de 600 de alguma forma n√£o realmente ... portanto, eles escrevem a mudan√ßa n√£o em rela√ß√£o √† 1¬™ fase, mas em rela√ß√£o √† anterior, ou seja, a 2¬™.  Como resultado, obtemos que na 3¬™ fase escrevemos 400 e isso corresponde a 2œÄ / 3 entre as fases 2 e 3, e como a 2¬™ j√° est√° deslocada, entre as fases 1 e 3 haver√° "2œÄ / 3 + 2œÄ / 3 = 4œÄ / 3 "e do ponto de vista da eletr√¥nica tudo parece l√≥gico. </p><br><p>  Para que as fases entendam quem est√° se movendo em rela√ß√£o a quem, √© necess√°rio um chefe, portanto, o EPWM1 ‚Äã‚Äã√© configurado usando o bit <em>PHSEN</em> no modo mestre, e EPWM2 e EPWM4, respectivamente, como escravos.  Usando os bits <em>SYNCOSEL</em> , o ‚Äúponto‚Äù de <em>sincroniza√ß√£o tamb√©m</em> √© definido, ou seja, de onde ler a mudan√ßa.  O EPWM1 ‚Äã‚Äã√© sincronizado com o in√≠cio do temporizador, ou seja, com per√≠odo zero, e o EPWM2 e o EPWM4 j√° est√£o sincronizados em rela√ß√£o √† borda do sinal do canal anterior: o canal anterior para o EPWM2 √© o EPWM1 ‚Äã‚Äãe para o EPWM4 √© o EPWM2. </p><br><p>  Agora resta ativar pares complementares e definir a dura√ß√£o do tempo morto.  Utilizando os bits <em>POLSEL</em> , definimos um PWM n√£o inverso, ou seja, ao atingir o valor definido do comparador (refer√™ncia), um log √© gerado na sa√≠da.  1. Em <em>OUT_MODE,</em> configuramos a gera√ß√£o de tempo morto na borda e na queda do sinal.  Assim, nos registros <em>DBFED</em> e <em>DBRED,</em> escreva a dura√ß√£o do tempo morto em ticks. </p><br><ul><li>  <strong>Etapa 3</strong> <br>  Agora resta escrever o valor do fator de servi√ßo no registro <em>CMPA</em> correspondente a cada canal e voc√™ pode observar o resultado. </li></ul><br><pre> <code class="cpp hljs"> EPwm1Regs.CMPA.half.CMPA = <span class="hljs-number"><span class="hljs-number">300</span></span>; <span class="hljs-comment"><span class="hljs-comment">// duty for output EPWM1A EPwm2Regs.CMPA.half.CMPA = 300; // duty for output EPWM2A EPwm4Regs.CMPA.half.CMPA = 300; // duty for output EPWM4A</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/sl/wy/6b/slwy6b5zoivfrdpbzlf9vpbsmms.png" alt="PWM trif√°sico"></p><br><p>  Voila!  As pontas de prova do oscilosc√≥pio est√£o conectadas √† sa√≠da do driver.  O canal amarelo √© o nosso EPWM1, ou seja, o mestre.  O canal azul √© EPWM2 e √© deslocado 2œÄ / 3 (ou 400 amostras) em rela√ß√£o ao canal amarelo, e o canal verde √© deslocado outras 400 amostras.  Assim, temos 3 fases, onde cada fase √© deslocada em 120 <sup>o</sup> . </p><br><p>  Agora vamos transferir as pontas de prova do oscilosc√≥pio da sa√≠da da ponte de energia para os sinais de controle que saem do microcontrolador e verificar se h√° tempo morto dentro do par complementar: </p><br><p><img src="https://habrastorage.org/webt/cd/aj/k7/cdajk7vfo9vs5d1yzvbuvtggy00.png" alt="Oscilograma n√∫mero 2"></p><br><p>  Como voc√™ pode ver, o tempo morto definido corresponde ao tempo real.  A dura√ß√£o de uma amostra √© de <em>1 / 60.000.000 Hz = 16,6 ns</em> e obtemos 20 amostras, o que equivale ao tempo morto 20,6 <em>16</em> ns = 332 ns *, que √© aproximadamente o que √© observado no oscilograma. </p><br><p>  Na verdade, onde isso pode ser √∫til, da forma que √© agora.  A op√ß√£o mais √≥bvia s√£o os conversores multif√°sicos dc / dc, para aqueles interessados ‚Äã‚Äãem pesquisar no <strong>conversor intercalado dc / dc</strong> .  Esta √© uma solu√ß√£o t√©cnica extremamente interessante que pode reduzir significativamente o tamanho das indut√¢ncias de pot√™ncia, reduzir a capacit√¢ncia de sa√≠da dos capacitores e tamb√©m aumentar a efici√™ncia.  Em um simples TMS320F28027, voc√™ pode implementar um conversor de 4 fases e tudo isso ser√° implementado com muita simplicidade no c√≥digo e apenas no hardware. </p><br><h1 id="generiruem-trehfaznoe-peremennoe-napryazhenie">  Geramos uma tens√£o alternada trif√°sica </h1><br><p>  Em muitos problemas, n√£o ser√° suficiente obter valores discretos de 0 ou VCC na sa√≠da; √© necess√°ria uma onda senoidal.  Eu tenho <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo</a> que fala sobre a forma√ß√£o de uma tens√£o alternada monof√°sica e o m√©todo "tabular" √© usado l√°, ou seja, os valores para a onda senoidal foram inicialmente calculados.  Em princ√≠pio, isso tamb√©m pode ser feito para a fase trif√°sica, mas quero mostrar uma op√ß√£o alternativa, a saber, o c√°lculo do valor do imposto em tempo real ou em tempo real. </p><br><p>  H√° um recurso.  A frequ√™ncia PWM neste caso tamb√©m √© de 50 kHz e a mudan√ßa de fase √© definida entre os per√≠odos desse sinal.  Assim, quando modulamos um sinus√≥ide com uma frequ√™ncia de 50 Hz, a mudan√ßa de fase do hardware ser√° "perdida", ela ainda estar√° presente entre os PWMs, mas n√£o dentro do sinus√≥ide, portanto, ser√° necess√°rio realizar um software.  A trigonometria √© uma coisa pesada para o TMS320F28027, mas n√£o est√° muito ocupada comigo, ent√£o conte.  Se voc√™ possui uma tarefa que exige muitos c√°lculos, precisa de um controlador com TMU e FPU, por exemplo, TMS320F280049, que pode tornar a matem√°tica muito mais r√°pida. </p><br><p>  Para carregar os valores de servi√ßo no PWM, precisamos de um temporizador, cujo per√≠odo definir√° a frequ√™ncia de amostragem.  Preciso de um per√≠odo de 20 ms (1 / 50Hz = 20 ms) e tomo o n√∫mero de etapas em um sinus√≥ide, digamos 20, como resultado, uma interrup√ß√£o deve ser gerada com uma frequ√™ncia de 0,02 s / 20 = 0,001 ms = 1 kHz e nessa interrup√ß√£o vou escrever o valor no PWM .  Para simplificar, vou pegar um cron√¥metro <em>CPU0</em> regular e configur√°-lo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitTimer0ForGenerator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; PieVectTable.TINT0 = &amp;cpu_timer0_isr; EDIS; InitCpuTimers(); ConfigCpuTimer(&amp;CpuTimer0, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>); CpuTimer0Regs.TCR.bit.TIE = <span class="hljs-number"><span class="hljs-number">1</span></span>; CpuTimer0Regs.TCR.bit.TSS = <span class="hljs-number"><span class="hljs-number">0</span></span>; IER |= M_INT1; PieCtrlRegs.PIEIER1.bit.INTx7 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Enable TINT0 in the PIE: Group 1 interrupt 7 EINT; // Enable Global interrupt INTM ERTM; // Enable Global real-time interrupt DBGM } __interrupt void cpu_timer0_isr (void) { CpuTimer0.InterruptCount++; /* *   -  . ... */ PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; // Acknowledge this interrupt to receive more interrupts from group 1 }</span></span></code> </pre> <br><p>  As <em>fun√ß√µes InitCpuTimers</em> e <em>ConfigCpuTimer s√£o</em> padr√£o, todas as configura√ß√µes est√£o nelas, basta transferir a frequ√™ncia do n√∫cleo (60 MHz) e o per√≠odo de contagem em microssegundos (1000 Œºs = 1 ms), equivalente a 1 kHz, e precis√°vamos disso.  Ent√£o, onde na fun√ß√£o de configura√ß√£o habilitamos interrup√ß√µes e passamos o endere√ßo do manipulador da nossa interrup√ß√£o, onde tudo vai acontecer. </p><br><p>  Agora √© necess√°rio "inventar" a f√≥rmula senoidal novamente, para isso voc√™ precisa ter conhecimento de trigonometria escolar e isso √© tudo.  E ent√£o ... n√≥s temos uma fun√ß√£o <strong><em>y = sin (x),</em></strong> vamos tra√ßar esta fun√ß√£o: </p><br><p><img src="https://habrastorage.org/webt/hi/bx/ey/hibxeyajv_h7l7t-mqkbkfrq6-s.png" alt="y = pecado (x)"></p><br><p>  Como voc√™ pode ver no gr√°fico, a amplitude de y varia de -1 a 1, mas queremos de 0 a 1, porque  com uma amplitude m√≠nima, temos 0V e, com um m√°ximo (equivalente a 1), temos + VCC.  Para "desenhar" -1 ... + 1, precisamos de nutri√ß√£o bipolar, mas n√£o √©.  Voc√™ precisa mudar o gr√°fico em uma dire√ß√£o positiva.  Se apenas levantarmos, ele passar√° de 0 a +2 e s√≥ podemos receber +1.  Ent√£o voc√™ precisa dividir por 2 e apenas algo!  Vamos come√ßar simplesmente dividindo e plotando para <strong><em>y = (sin (x) / 2):</em></strong> </p><br><p><img src="https://habrastorage.org/webt/t_/n0/iw/t_n0iw1fym8aboggaxk1my7r4um.png" alt="y = (sen (x) / 2)"></p><br><p>  Sim!  Agora, o gr√°fico tem um intervalo de -0,5 a +0,5, ou seja, a amplitude √© 1. J√° √© melhor, mas ainda n√£o nos livramos dos valores negativos, ent√£o vamos mudar o gr√°fico para 0,5, para isso, basta adicionar esse valor ao resultado e obter a f√≥rmula <strong><em>y = 0,5 + (sin (x) / 2)</em></strong> e plote o gr√°fico para esta fun√ß√£o: </p><br><p><img src="https://habrastorage.org/webt/df/vu/ez/dfvuez1lks2uhg0cp3tkhie9cdq.png" alt="y = 0,5 + (sin (x) / 2)"></p><br><p>  Agora tudo se tornou absolutamente perfeito: o senoide tem uma amplitude de 0 a 1, valores negativos est√£o ausentes.  A f√≥rmula <strong><em>y = 0,5 + (sin (x) / 2)</em></strong> descreve a 1¬™ fase, agora √© necess√°rio adicionar uma mudan√ßa de fase para obter as fases 2 e 3. Para fazer isso, subtraia 2œÄ / 3 e 4œÄ / 3 de <em>x,</em> respectivamente, e obtenha as f√≥rmulas para as demais fases <strong><em>y = 0,5 + (sin (x-2œÄ / 3) / 2)</em></strong> e <strong><em>y = 0,5 + (sin (x-4œÄ / 3) / 2).</em></strong>  Constru√≠mos 3 gr√°ficos e verificamos se parece com a verdade: </p><br><p><img src="https://habrastorage.org/webt/hj/kp/n9/hjkpn93-37r_rclbrevchhdzf_m.png" alt="3 fases"></p><br><p>  Nada mal!  A imagem √© semelhante √† que geralmente √© pintada nos livros did√°ticos de engenharia el√©trica quando eles falam sobre uma rede trif√°sica ou motores ass√≠ncronos.  A prop√≥sito, 2.0943 √© 2œÄ / 3 e 4.1866 √© 4œÄ / 3, respectivamente, apenas contei-os imediatamente e eles aparecem no meu c√≥digo.  Total, temos 3 equa√ß√µes: </p><br><ul><li>  Fase A - <strong><em>y = 0,5 + (sin (x) / 2)</em></strong> </li><li>  Fase B - <strong><em>y = 0,5 + (sin (x-2œÄ / 3) / 2)</em></strong> </li><li>  Fase C - <strong><em>y = 0,5 + (sin (x-4œÄ / 3) / 2)</em></strong> </li></ul><br><p>  Por parte da matem√°tica, tudo parece ser simples e claro, mas agora precisa ser adaptado √†s realidades do microcontrolador.  Nossa onda senoidal n√£o √© anal√≥gica, mas possui "etapas", ou seja, √© discreta, pois podemos definir apenas tens√£o ou 0V ou + 15V (VCC) no meu caso.  Escrevi anteriormente que terei 20 etapas, ent√£o por 1 per√≠odo terei 20 c√°lculos. </p><br><p>  Primeiro, vamos decidir o que substituir por <em>x</em> .  O per√≠odo do nosso sinus√≥ide √© <em>2œÄ</em> , o que significa que a etapa de amostragem ser√° <em>2œÄ / 20</em> .  Consequentemente, o sinus√≥ide consistir√° em 20 pontos, como se estiv√©ssemos construindo um gr√°fico sobre os pontos, e aproximados entre eles.  Como resultado, o valor no primeiro passo ser√° <strong><em>sin (2œÄ * (1/20),</em></strong> no segundo passo <strong><em>sin (2œÄ * (2/20)),</em></strong> no terceiro passo * <strong>sin (2œÄ <em>(3/20))</em></strong> e assim por diante, quando Se atingir <em>20/20</em> , isso significa o final do per√≠odo e ser√° necess√°rio come√ßar a contar novamente.Com base nos dados recebidos, vamos corrigir as f√≥rmulas: </p><br><ul><li>  Fase A - <strong><em>y = 0,5 + (sin (2œÄ * (n / N)) / 2)</em></strong> </li><li>  Fase B - <strong><em>y = 0,5 + (sin (2œÄ * (n / N) -2œÄ / 3) / 2)</em></strong> </li><li>  Fase C - <strong><em>y = 0,5 + (sin (2œÄ * (n / N) -4œÄ / 3) / 2)</em></strong> </li></ul><br><p>  Agora, agora consideramos o valor do seno em cada ponto espec√≠fico do gr√°fico.  Consequentemente, <strong>n</strong> √© o passo atual, <strong>N</strong> √© o passo total (20).  Ap√≥s essas f√≥rmulas, obtemos um valor de 0 a 1, mas, na realidade, n√£o estamos operando com uma amplitude abstrata.  A amplitude no nosso caso depende do ciclo de trabalho, porque  o dever muda de 0 a 600 (nas configura√ß√µes do PWM), ent√£o 0 √© 0 e 1 √© equivalente a 600. Com base nisso, vamos recalcul√°-lo em uma f√≥rmula real para obter o valor que ser√° carregado no <em>registro</em> do CMPA <em>PWM</em> : </p><br><ul><li>  Fase A - <strong><em>dever1 = A <em>(0,5 + (sin (2œÄ</em> (n / N)) / 2))</em></strong> </li><li>  Fase B - <strong><em>dever2 = A <em>(0,5 + (sin (2œÄ</em> (n / N) -2œÄ / 3) / 2))</em></strong> </li><li>  Fase C - <strong><em>dever4 = A <em>(0,5 + (sin (2œÄ</em> (n / N) -4œÄ / 3) / 2))</em></strong> </li></ul><br><p>  Por conseguinte, <strong>A</strong> √© o valor m√°ximo da amplitude, ou seja, 600, <strong>n</strong> √© o passo atual, <strong>N</strong> √© o n√∫mero total de passos (20).  Os valores de <strong><em>dever1, dever2, dever4</em></strong> s√£o os valores reais convertidos do fator de dever, carregados no <em>CMPA.</em>  Agora vamos escrever o c√≥digo para o manipulador de interrup√ß√µes atualizado e declarar todas as vari√°veis ‚Äã‚Äãnecess√°rias: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> activeStep = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> amplitude = <span class="hljs-number"><span class="hljs-number">600.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> allStep = <span class="hljs-number"><span class="hljs-number">20.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pi = <span class="hljs-number"><span class="hljs-number">3.1415</span></span>; <span class="hljs-comment"><span class="hljs-comment">// œÄ const float piTwo = 6.2831; // 2œÄ const float phaseShifted120deg = 2.0943; // 2œÄ/3 const float phaseShifted240deg = 4.1866; // 4œÄ/3 __interrupt void cpu_timer0_isr (void) { if (activeStep &gt;= allStep) {activeStep = 0;} activeStep++; EPwm1Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep)) / 2)))); EPwm2Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep) - phaseShifted120deg) / 2)))); EPwm4Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep) - phaseShifted240deg) / 2)))); PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; // Acknowledge this interrupt to receive more interrupts from group 1 }</span></span></code> </pre><br><p>  O c√≥digo, como voc√™ v√™, √© o mais simples, se voc√™ entender o que era necess√°rio fazer e a matem√°tica simples no problema que est√° sendo resolvido.  Cada vez que a interrup√ß√£o √© chamada, incrementamos a vari√°vel <em>activeStep</em> , que cont√©m o n√∫mero da etapa, ela muda de 0 a 20 e depois √© redefinida.  Acontece que em um per√≠odo realizamos 20 etapas e 20 c√°lculos para cada fase.  Para n√£o contar <em>2œÄ / 3</em> e <em>4œÄ / 3</em> na f√≥rmula o tempo todo, contei-os imediatamente para serem usados ‚Äã‚Äãcomo constantes. </p><br><p>  Os c√°lculos foram m√≠nimos, para este MK n√£o √© absolutamente nada.  Se desejado, o n√∫mero de pontos pode ser aumentado significativamente, por exemplo, at√© 200. Tudo depende da tarefa.  A altera√ß√£o da frequ√™ncia PWM ocorre alterando a frequ√™ncia da chamada de interrup√ß√£o e o n√∫mero de etapas.  Voc√™ tamb√©m pode alterar a <em>amplitude</em> vari√°vel e a tens√£o na sa√≠da do conversor de pot√™ncia. </p><br><p>  Depois de baixar o c√≥digo para o microcontrolador, voc√™ obter√° a imagem correspondente: </p><br><p><img src="https://habrastorage.org/webt/qf/rd/ck/qfrdck6y4rcvirbws9o6zbzrfea.png" alt="Oscilograma n√∫mero 1"></p><br><p>  Se voc√™ esticar o gr√°fico ao longo de <em>Y</em> , ser√° melhor ver os defeitos do sinal.  Isso √© uma conseq√º√™ncia do pequeno n√∫mero de etapas de amostragem; uma regra condicional se aplica: <strong>quanto mais pontos, mais bonito o sinal.</strong> </p><br><p><img src="https://habrastorage.org/webt/wh/4d/du/wh4dduwnbyshscey7rlmzs6s1mw.png" alt="Oscilograma n√∫mero 3"></p><br><h1 id="zaklyuchenie">  Conclus√£o </h1><br><p>  Hoje falei sobre o processo de forma√ß√£o de mudan√ßa de fase em sistemas multif√°sicos, em princ√≠pio, n√£o h√° nada complicado, principalmente quando se usa o TMS320F28.  O resto depende dos algoritmos, em princ√≠pio, na Internet, existem muitos artigos em que controle de mastiga√ß√£o e motores sem escova, al√©m de ass√≠ncrono e de todos os tipos, voc√™ s√≥ pode mudar a l√≥gica. </p><br><p>  Espero que este material seja √∫til e n√£o particularmente chato de ler.  Como sempre, a fonte est√° anexada: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Arquivar com o projeto para o Code Composer Studio</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457548/">https://habr.com/ru/post/pt457548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457534/index.html">Vers√µes certificadas - o rake que escolhemos</a></li>
<li><a href="../pt457538/index.html">Como posso usar m√°quinas virtuais Yandex.Cloud interrompidas e economizar na solu√ß√£o de problemas em larga escala</a></li>
<li><a href="../pt457540/index.html">Mem√≥ria persistente Intel Optane DC, um ano depois</a></li>
<li><a href="../pt457542/index.html">Hackear e proteger unidades de criptografia LUKS</a></li>
<li><a href="../pt457546/index.html">Dia da demonstra√ß√£o: por que tudo isso e como fazer? UPD + Broadcast</a></li>
<li><a href="../pt457550/index.html">Do que a ind√∫stria digital precisa ser protegida</a></li>
<li><a href="../pt457552/index.html">Alpinistas em Zafasadia. Como funcionam os promalps na torre do Lakhta Center</a></li>
<li><a href="../pt457558/index.html">An√°lise de Vulnerabilidade no EvilParcel</a></li>
<li><a href="../pt457560/index.html">A√ß√µes Tokenizadas: Como se Tornar um Investidor da Gett Antes de Fazer um IPO</a></li>
<li><a href="../pt457562/index.html">Ivideon Counter 3D: quem, como e por que contar visitantes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>