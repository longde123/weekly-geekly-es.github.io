<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🏭 👩🏾‍⚖️ ↙️ Nouvelles intéressantes Vue 3 👨🏼‍🏭 🏝️ 👨🏻‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Au lieu de l'avant-propos 
 Vue est utilisé dans tous les projets FunCorp. Nous suivons de près l'évolution du cadre, améliorons constamment le proces...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nouvelles intéressantes Vue 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/475968/"><h2>  Au lieu de l'avant-propos </h2><br>  Vue est utilisé dans tous les projets FunCorp.  Nous suivons de près l'évolution du cadre, améliorons constamment le processus de développement et mettons en œuvre les meilleures pratiques.  Et, bien sûr, nous ne pouvions pas passer à côté et ne pas traduire l'article de Philip Rakovsky, co-fondateur de VueStorefront, sur les nouvelles fonctionnalités de Vue 3 qui affectent sérieusement l'écriture de code. <br><br><img src="https://habrastorage.org/webt/ta/6z/aq/ta6zaqz4kxyqh_wh0zoo4zayqeo.png" alt="image"><br>  La dernière fois, nous avons examiné les fonctionnalités qui affectent les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">performances de Vue 3</a> .  Nous savons déjà que les applications écrites sur la nouvelle version du framework fonctionnent très rapidement, mais les performances ne sont pas le changement le plus important.  Pour la plupart des développeurs, la façon dont Vue 3 affecte la façon dont vous écrivez du code est beaucoup plus importante. <a name="habracut"></a><br><br>  Comme vous l'avez peut-être deviné, Vue 3 aura beaucoup de fonctionnalités intéressantes.  Heureusement, l'équipe Vue a ajouté plus d'améliorations et d'ajouts que de changements de rupture.  Pour cette raison, la plupart des développeurs qui connaissent Vue 2 devraient rapidement se familiariser avec la nouvelle syntaxe. <br><br>  Commençons par une API dont beaucoup d'entre vous ont peut-être entendu parler. <br><br><h2>  API de composition </h2><br>  L'API Composition est la fonctionnalité la plus discutée et la plus mentionnée de la prochaine version majeure de Vue.  La syntaxe de l'API Composition fournit une approche complètement nouvelle de l'organisation et de la réutilisation du code. <br><br>  Nous créons maintenant des composants avec une syntaxe appelée API Options.  Afin d'ajouter de la logique, nous créons des propriétés (options) dans l'objet composant, par exemple des données, des méthodes, des calculs, etc.  Le principal inconvénient de cette approche est qu'elle n'est pas du code JavaScript en tant que tel.  Vous devez savoir exactement quelles options sont disponibles dans le modèle et à quoi cela ressemblera.  Le compilateur Vue convertit les propriétés en code JavaScript fonctionnel pour vous.  En raison de cette fonctionnalité, nous ne pouvons pas utiliser complètement l'auto-complétion ou la vérification de type. <br><br>  L'API Composition résout ce problème et permet d'utiliser les mécanismes disponibles via les options utilisant des fonctions JavaScript ordinaires. <br>  L'équipe Vue décrit l'API Composition comme «une API optionnelle basée sur des fonctionnalités qui permet une utilisation flexible de la composition dans la logique des composants».  Le code écrit à l'aide de la nouvelle API est plus facile à lire, ce qui le rend plus facile à comprendre. <br><br>  Pour comprendre le fonctionnement de la nouvelle syntaxe, considérons un exemple de composant simple. <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> @</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"increment"</span></span></span><span class="hljs-tag">&gt;</span></span> Count is: {{ count }}, double is {{ double }}, click to increment. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">import</span></span></span><span class="javascript"> { ref, computed, onMounted } </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">from</span></span></span><span class="javascript"> </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'vue'</span></span></span><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">export</span></span></span><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">default</span></span></span><span class="javascript"> { setup() { </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> count = ref(</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">0</span></span></span><span class="javascript">) </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> double = computed(</span><span class="hljs-function"><span class="hljs-params"><span class="javascript"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="javascript"><span class="hljs-function"> =&gt;</span></span></span><span class="javascript"> count.value * </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">2</span></span></span><span class="javascript">) </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="javascript"><span class="hljs-function"><span class="hljs-title">increment</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ count.value++ } onMounted(</span><span class="hljs-function"><span class="hljs-params"><span class="javascript"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="javascript"><span class="hljs-function"> =&gt;</span></span></span><span class="javascript"> </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">console</span></span></span><span class="javascript">.log(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'component mounted!'</span></span></span><span class="javascript">)) </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">return</span></span></span><span class="javascript"> { count, double, increment } } } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Nous allons diviser le code en plusieurs parties et analyser ce qui se passe ici. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ref, computed, onMounted } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span></code> </pre> <br>  Comme je l'ai mentionné ci-dessus, l'API Composition présente les options des composants comme des fonctions, donc, tout d'abord, nous devons importer les fonctions nécessaires.  Dans cet exemple, nous devons créer une propriété réactive en utilisant ref calculé en utilisant calculé et accéder au hook de cycle de vie monté à l'aide de la fonction onMounted. <br><br>  Vous avez peut-être une question: quelle est cette mystérieuse méthode de configuration? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { setup() {} }</code> </pre> <br>  En bref, l'installation n'est qu'une fonction qui transmet des propriétés et des fonctions à un modèle.  Nous décrivons toutes les propriétés réactives et calculées, les crochets de cycle de vie et tous les observateurs dans la fonction de configuration, puis les renvoyons pour les utiliser dans le modèle. <br><br>  Au fait que nous ne reviendrons pas de la configuration, il n'y aura pas d'accès dans le modèle. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = ref(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  La propriété réactive de comptage est initialisée à l'aide de la fonction ref.  Il prend une primitive ou un objet et renvoie un lien réactif.  La valeur transmise sera stockée dans la propriété value du lien créé.  Par exemple, si nous voulons accéder à la valeur de count, nous devons accéder explicitement à count.value. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> double = computed(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> count.value * <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ count.value++ }</code> </pre><br>  Nous déclarons donc une double propriété calculée et une fonction d'incrémentation. <br><br><pre> <code class="javascript hljs">onMounted(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'component mounted!'</span></span>))</code> </pre> <br>  À l'aide du crochet onMounted, nous imprimons un message à la console après avoir monté le composant pour démontrer cette possibilité. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { count, double, increment }</code> </pre> <br>  Pour que les propriétés count et double et la méthode increment soient disponibles dans le modèle, nous les renvoyons depuis la méthode setup. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> @</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"increment"</span></span></span><span class="hljs-tag">&gt;</span></span> Count is: {{ count }}, double is {{ double }}. Click to increment. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Et le tour est joué!  Nous avons accès aux propriétés et méthodes de la configuration, comme si elles avaient été déclarées via l'ancienne API Options. <br><br>  Il s'agit d'un exemple simple, similaire pourrait facilement être écrit à l'aide de l'API Options. <br>  Mais l'avantage de la nouvelle API de composition n'est pas tant dans la possibilité d'écrire du code dans un style différent, mais dans les possibilités ouvertes pour la réutilisation de la logique. <br><br><h2>  Réutilisation du code avec l'API Composition </h2><br>  Examinons de plus près les avantages de la nouvelle API Composition, par exemple, pour la réutilisation de code.  Maintenant, si nous voulons utiliser un morceau de code dans plusieurs composants, nous avons deux options: les mixins et les emplacements de portée.  Les deux options ont leurs inconvénients. <br><br>  Nous voulons extraire la fonctionnalité du compteur et la réutiliser dans d'autres composants.  Voici un exemple de la façon dont cela peut être fait en utilisant l'existant et en utilisant la nouvelle API. <br><br>  Pour commencer, considérez l'implémentation à l'aide de mixins. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CounterMixin <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./mixins/counter'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { <span class="hljs-attr"><span class="hljs-attr">mixins</span></span>: [CounterMixin] }</code> </pre> <br>  Le plus gros problème avec cette approche est que nous ne savons rien de ce qui est ajouté à notre composant.  Cela rend la compréhension difficile et peut conduire à des conflits avec les propriétés et méthodes existantes. <br><br>  Considérez maintenant les emplacements avec une portée limitée. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Counter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{ count, increment }"</span></span></span><span class="hljs-tag">&gt;</span></span> {{ count }} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> @</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"increment"</span></span></span><span class="hljs-tag">&gt;</span></span>Increment<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Counter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Lorsque vous utilisez des emplacements, nous savons exactement à quelles propriétés nous avons accès via la directive v-slot, qui est assez simple à comprendre.  L'inconvénient de cette approche est que nous ne pouvons accéder qu'aux données du composant Counter. <br><br>  Considérons maintenant une implémentation utilisant l'API Composition. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = ref(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ count.value++ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { count, incrememt } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { setup () { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { count, increment } = useCounter() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { count, increment } } }</code> </pre> <br>  Il a l'air beaucoup plus élégant, non?  Nous ne sommes pas limités par un modèle ou une étendue, et nous savons exactement quelles propriétés de compteur sont disponibles.  Et du fait que useCounter n'est qu'une fonction qui renvoie des données, un bonus agréable nous permet de terminer le code dans l'éditeur.  Il n'y a pas de magie ici, donc l'éditeur peut nous aider avec la vérification de type et donner des conseils. <br><br>  L'utilisation de bibliothèques tierces semble également meilleure.  Par exemple, si nous voulons utiliser Vuex, nous pouvons importer explicitement la fonction useStore et ne pas obstruer le prototype Vue avec cette propriété. $ Store.  Cette approche vous permet de vous débarrasser des manipulations supplémentaires dans les plugins. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { commit, dispatch } = useStore()</code> </pre> <br>  Si vous souhaitez en savoir plus sur l'API Composition et ses applications, je vous recommande de lire un document dans lequel l'équipe Vue explique les raisons de la création d'une nouvelle API et propose des cas dans lesquels elle sera utile.  Il existe également un magnifique référentiel avec des exemples d'utilisation de l'API Composition de Thorsten Lünborg, l'un des membres de l'équipe de base de Vue. <br><br><h2>  Changements de configuration et de montage </h2><br>  Il y a d'autres changements importants dans la nouvelle Vue dans la façon dont nous construisons et configurons notre application.  Regardons un exemple. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App.vue'</span></span> Vue.config.ignoredElements = [<span class="hljs-regexp"><span class="hljs-regexp">/^app-/</span></span>] Vue.use(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) Vue.mixin(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) Vue.component(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) Vue.directive(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vue({ <span class="hljs-attr"><span class="hljs-attr">render</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">h</span></span></span><span class="hljs-function"> =&gt;</span></span> h(App) }).$mount(<span class="hljs-string"><span class="hljs-string">'#app'</span></span>)</code> </pre> <br>  Nous utilisons maintenant l'objet global Vue pour configurer et créer de nouvelles instances de Vue.  Toute modification que nous apportons à l'objet Vue affectera les instances et composants finaux. <br><br>  Voyons comment cela fonctionnera dans Vue 3. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createApp } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App.vue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = createApp(App) app.config.ignoredElements = [<span class="hljs-regexp"><span class="hljs-regexp">/^app-/</span></span>] app.use(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) app.mixin(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) app.component(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) app.directive(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) app.mount(<span class="hljs-string"><span class="hljs-string">'#app'</span></span>)</code> </pre> <br>  Comme vous l'avez déjà remarqué, la configuration fait référence à une instance de Vue spécifique créée à l'aide de createApp. <br><br>  Cela rend notre code plus lisible, réduit les risques de problèmes inattendus avec des plugins tiers.  Maintenant, toute bibliothèque tierce qui modifie l'objet global Vue peut affecter votre application dans un endroit inattendu (surtout s'il s'agit d'un mixage global), ce qui est impossible dans Vue 3. <br><br>  Ces changements <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sont discutés</a> dans le RFC, et peut-être à l'avenir la mise en œuvre sera différente. <br><br><h2>  Fragments </h2><br>  Une autre fonctionnalité intéressante sur laquelle nous pouvons compter dans Vue 3. <br>  Quels sont les fragments? <br>  Actuellement, un composant ne peut avoir qu'un seul élément racine, ce qui signifie que le code ci-dessous ne fonctionnera pas. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>Hello<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>World<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  La raison en est que l'instance Vue qui se cache derrière chaque composant ne peut être attachée qu'à un seul élément DOM.  Il existe maintenant un moyen de créer un composant avec plusieurs éléments racine: pour cela, vous devez écrire un composant dans un style fonctionnel qui n'a pas besoin de sa propre instance de Vue. <br><br>  Il s'avère que le même problème existe dans la communauté React, il a été résolu en utilisant l'élément Fragment virtuel. <br><br>  Cela ressemble à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Columns</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">React.Fragment</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">td</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Hello</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">td</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">td</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">World</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">td</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">React.Fragment</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); } }</span></span></code> </pre> <br>  Malgré le fait que Fragment ressemble à un élément DOM normal, il est virtuel et ne sera pas créé dans l'arborescence DOM.  Avec cette approche, nous pouvons utiliser la fonctionnalité d'un seul élément racine sans créer un élément supplémentaire dans le DOM. <br><br>  Vous pouvez maintenant utiliser des fragments dans Vue 2, mais en utilisant la bibliothèque vue-fragments, et dans Vue 3, ils fonctionneront prêts à l'emploi! <br><br><h2>  Suspense </h2><br>  Une autre excellente idée de l'écosystème React qui sera implémentée dans Vue 3 est Suspense. <br><br>  Suspense suspend le rendu du composant et affiche un stub jusqu'à ce que certaines conditions soient remplies.  À Vue London, Ewan Yu a effleuré Suspense avec désinvolture et a révélé l'API que nous pouvons attendre à l'avenir.  Le composant Suspense aura 2 emplacements: pour le contenu et pour le talon. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Suspense</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Suspended-component</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> #</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fallback</span></span></span><span class="hljs-tag">&gt;</span></span> Loading... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Suspense</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Le stub sera affiché jusqu'à ce que le composant &lt;Suspended-component /&gt; soit prêt.  Le composant Suspense peut également s'attendre à charger le composant asynchrone ou à effectuer certaines actions asynchrones dans la fonction de configuration. <br><br><h2>  Plusieurs modèles en V </h2><br>  v-model est une directive avec laquelle vous pouvez utiliser une liaison bidirectionnelle.  Nous pouvons transmettre la propriété réactive et la modifier à l'intérieur du composant. <br><br>  Nous sommes bien connus pour travailler avec des éléments de formulaire. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-model</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"property"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br>  Mais saviez-vous que le modèle v peut être utilisé avec n'importe quel composant?  Sous le capot, le modèle v ne fait que transmettre le paramètre de valeur et écouter l'événement d'entrée. <br><br>  Vous pouvez réécrire l'exemple précédent en utilisant cette syntaxe comme suit: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-bind:value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"property"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-on:input</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"property = $event.target.value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br>  Vous pouvez même modifier les noms de propriété et les événements par défaut à l'aide de l'option de modèle: <br><br><pre> <code class="javascript hljs">model: { <span class="hljs-attr"><span class="hljs-attr">prop</span></span>: <span class="hljs-string"><span class="hljs-string">'checked'</span></span>, <span class="hljs-attr"><span class="hljs-attr">event</span></span>: <span class="hljs-string"><span class="hljs-string">'change'</span></span> }</code> </pre> <br>  Comme vous pouvez le voir, la directive v-model peut être un «sucre syntaxique» très utile si nous voulons utiliser la liaison bidirectionnelle dans nos composants.  Malheureusement, il ne peut y avoir qu'un seul modèle en V par composant. <br><br>  Heureusement, dans Vue 3, ce problème sera résolu.  Nous pouvons transmettre le nom à v-model et utiliser autant de v-model que nécessaire. <br><br>  Exemple d'utilisation: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">InviteeForm</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-model:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"inviteeName"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-model:email</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"inviteeEmail"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br>  Ces changements <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sont discutés</a> dans le RFC, et peut-être à l'avenir la mise en œuvre sera différente. <br><br><h2>  Portails </h2><br>  Les portails sont des composants créés pour rendre le contenu en dehors de la hiérarchie du composant actuel.  C'est également l'une des fonctionnalités <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">implémentées dans React</a> .  Dans la documentation de React, les portails sont décrits comme suit: "Les portails vous permettent de rendre des enfants dans un nœud DOM qui est en dehors de la hiérarchie DOM du composant parent." <br><br>  Les portails sont parfaits pour implémenter des composants tels que les fenêtres modales, les fenêtres contextuelles et tous ceux qui doivent être affichés en haut de la page. <br><br>  Lorsque vous utilisez des portails, vous pouvez être sûr que les styles du composant parent n'affecteront pas le composant enfant.  Il vous permettra également d'économiser des hacks z-index sales. <br><br>  Pour chaque portail, nous devons spécifier la destination dans laquelle le contenu du portail doit être affiché. <br><br>  Ce qui suit est une option d'implémentation de la bibliothèque portal-vue, qui ajoute des portails à Vue 2. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">portal</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">to</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"destination"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>This slot content will be rendered wherever the portal-target with name 'destination' is located.<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">portal</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">portal-target</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"destination"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- This component can be located anywhere in your App. The slot content of the above portal component wilbe rendered here. --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">portal-target</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Et dans Vue 3, cette fonctionnalité sera prête à l'emploi. <br><br><h2>  Nouvelle API de directive personnalisée </h2><br>  L'API de directive personnalisée changera un peu dans Vue 3 pour mieux correspondre au cycle de vie du composant.  La création de directives deviendra plus intuitive et donc plus facile à comprendre et à apprendre pour les débutants. <br><br>  Maintenant, la déclaration de la directive utilisateur ressemble à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyDirective = { bind(el, binding, vnode, prevVnode) {}, inserted() {}, update() {}, componentUpdated() {}, unbind() {} }</code> </pre> <br>  Et dans Vue 3, cela ressemblera à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyDirective = { beforeMount(el, binding, vnode, prevVnode) {}, mounted() {}, beforeUpdate() {}, updated() {}, beforeUnmount() {}, <span class="hljs-comment"><span class="hljs-comment">// new unmounted() {} }</span></span></code> </pre> <br>  Bien que ces changements soient en rupture, ils peuvent être utilisés avec une version Vue compatible. <br><br>  Cette API est également <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discutée</a> et pourrait changer à l'avenir. <br><br><h2>  Résumé </h2><br>  À côté de l'innovation significative - l'API Composition - nous pouvons trouver plusieurs petites améliorations.  De toute évidence, Vue s'oriente vers l'amélioration de l'expérience des développeurs, vers des API simplifiées et intuitives.  C'est aussi cool de voir que l'équipe Vue a décidé d'ajouter beaucoup d'idées au cœur du cadre qui sont déjà implémentées dans des bibliothèques tierces. <br><br>  La liste ci-dessus ne contient que les améliorations et modifications les plus importantes de l'API.  Si vous souhaitez en savoir plus sur les autres, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le référentiel RFC</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr475968/">https://habr.com/ru/post/fr475968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr475948/index.html">JH Rainwater "Comment faire paître les chats" (deuxième partie): tout ce qui reste à maîtriser technique</a></li>
<li><a href="../fr475950/index.html">Pourquoi un robot devrait-il se limiter à ramasser des balles de golf? Il y a aussi le tennis</a></li>
<li><a href="../fr475956/index.html">Comment nous avons créé la technologie de reconnaissance optique de texte. OCR sur Yandex</a></li>
<li><a href="../fr475958/index.html">L'histoire de la façon dont la fille s'est réunie en informatique</a></li>
<li><a href="../fr475960/index.html">AHURATUS Smart Home Voice Assistant</a></li>
<li><a href="../fr475974/index.html">Comment nous avons fait un hackathon dans le train et ce qui en est sorti</a></li>
<li><a href="../fr475978/index.html">À quoi sert le siège du train?</a></li>
<li><a href="../fr475980/index.html">Faible connectivité, architecture et organisation d'équipe</a></li>
<li><a href="../fr475982/index.html">Comment apprendre une langue étrangère</a></li>
<li><a href="../fr475986/index.html">Présentation du PocketBook 740 Pro Reader: 7,8 pouces, protection audio et IPX8</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>