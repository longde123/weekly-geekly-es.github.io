<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüè≠ üë©üèæ‚Äç‚öñÔ∏è ‚ÜôÔ∏è Nouvelles int√©ressantes Vue 3 üë®üèº‚Äçüè≠ üèùÔ∏è üë®üèª‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Au lieu de l'avant-propos 
 Vue est utilis√© dans tous les projets FunCorp. Nous suivons de pr√®s l'√©volution du cadre, am√©liorons constamment le proces...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nouvelles int√©ressantes Vue 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/475968/"><h2>  Au lieu de l'avant-propos </h2><br>  Vue est utilis√© dans tous les projets FunCorp.  Nous suivons de pr√®s l'√©volution du cadre, am√©liorons constamment le processus de d√©veloppement et mettons en ≈ìuvre les meilleures pratiques.  Et, bien s√ªr, nous ne pouvions pas passer √† c√¥t√© et ne pas traduire l'article de Philip Rakovsky, co-fondateur de VueStorefront, sur les nouvelles fonctionnalit√©s de Vue 3 qui affectent s√©rieusement l'√©criture de code. <br><br><img src="https://habrastorage.org/webt/ta/6z/aq/ta6zaqz4kxyqh_wh0zoo4zayqeo.png" alt="image"><br>  La derni√®re fois, nous avons examin√© les fonctionnalit√©s qui affectent les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">performances de Vue 3</a> .  Nous savons d√©j√† que les applications √©crites sur la nouvelle version du framework fonctionnent tr√®s rapidement, mais les performances ne sont pas le changement le plus important.  Pour la plupart des d√©veloppeurs, la fa√ßon dont Vue 3 affecte la fa√ßon dont vous √©crivez du code est beaucoup plus importante. <a name="habracut"></a><br><br>  Comme vous l'avez peut-√™tre devin√©, Vue 3 aura beaucoup de fonctionnalit√©s int√©ressantes.  Heureusement, l'√©quipe Vue a ajout√© plus d'am√©liorations et d'ajouts que de changements de rupture.  Pour cette raison, la plupart des d√©veloppeurs qui connaissent Vue 2 devraient rapidement se familiariser avec la nouvelle syntaxe. <br><br>  Commen√ßons par une API dont beaucoup d'entre vous ont peut-√™tre entendu parler. <br><br><h2>  API de composition </h2><br>  L'API Composition est la fonctionnalit√© la plus discut√©e et la plus mentionn√©e de la prochaine version majeure de Vue.  La syntaxe de l'API Composition fournit une approche compl√®tement nouvelle de l'organisation et de la r√©utilisation du code. <br><br>  Nous cr√©ons maintenant des composants avec une syntaxe appel√©e API Options.  Afin d'ajouter de la logique, nous cr√©ons des propri√©t√©s (options) dans l'objet composant, par exemple des donn√©es, des m√©thodes, des calculs, etc.  Le principal inconv√©nient de cette approche est qu'elle n'est pas du code JavaScript en tant que tel.  Vous devez savoir exactement quelles options sont disponibles dans le mod√®le et √† quoi cela ressemblera.  Le compilateur Vue convertit les propri√©t√©s en code JavaScript fonctionnel pour vous.  En raison de cette fonctionnalit√©, nous ne pouvons pas utiliser compl√®tement l'auto-compl√©tion ou la v√©rification de type. <br><br>  L'API Composition r√©sout ce probl√®me et permet d'utiliser les m√©canismes disponibles via les options utilisant des fonctions JavaScript ordinaires. <br>  L'√©quipe Vue d√©crit l'API Composition comme ¬´une API optionnelle bas√©e sur des fonctionnalit√©s qui permet une utilisation flexible de la composition dans la logique des composants¬ª.  Le code √©crit √† l'aide de la nouvelle API est plus facile √† lire, ce qui le rend plus facile √† comprendre. <br><br>  Pour comprendre le fonctionnement de la nouvelle syntaxe, consid√©rons un exemple de composant simple. <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> @</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"increment"</span></span></span><span class="hljs-tag">&gt;</span></span> Count is: {{ count }}, double is {{ double }}, click to increment. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">import</span></span></span><span class="javascript"> { ref, computed, onMounted } </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">from</span></span></span><span class="javascript"> </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'vue'</span></span></span><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">export</span></span></span><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">default</span></span></span><span class="javascript"> { setup() { </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> count = ref(</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">0</span></span></span><span class="javascript">) </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> double = computed(</span><span class="hljs-function"><span class="hljs-params"><span class="javascript"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="javascript"><span class="hljs-function"> =&gt;</span></span></span><span class="javascript"> count.value * </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">2</span></span></span><span class="javascript">) </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="javascript"><span class="hljs-function"><span class="hljs-title">increment</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ count.value++ } onMounted(</span><span class="hljs-function"><span class="hljs-params"><span class="javascript"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="javascript"><span class="hljs-function"> =&gt;</span></span></span><span class="javascript"> </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">console</span></span></span><span class="javascript">.log(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'component mounted!'</span></span></span><span class="javascript">)) </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">return</span></span></span><span class="javascript"> { count, double, increment } } } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Nous allons diviser le code en plusieurs parties et analyser ce qui se passe ici. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ref, computed, onMounted } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span></code> </pre> <br>  Comme je l'ai mentionn√© ci-dessus, l'API Composition pr√©sente les options des composants comme des fonctions, donc, tout d'abord, nous devons importer les fonctions n√©cessaires.  Dans cet exemple, nous devons cr√©er une propri√©t√© r√©active en utilisant ref calcul√© en utilisant calcul√© et acc√©der au hook de cycle de vie mont√© √† l'aide de la fonction onMounted. <br><br>  Vous avez peut-√™tre une question: quelle est cette myst√©rieuse m√©thode de configuration? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { setup() {} }</code> </pre> <br>  En bref, l'installation n'est qu'une fonction qui transmet des propri√©t√©s et des fonctions √† un mod√®le.  Nous d√©crivons toutes les propri√©t√©s r√©actives et calcul√©es, les crochets de cycle de vie et tous les observateurs dans la fonction de configuration, puis les renvoyons pour les utiliser dans le mod√®le. <br><br>  Au fait que nous ne reviendrons pas de la configuration, il n'y aura pas d'acc√®s dans le mod√®le. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = ref(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  La propri√©t√© r√©active de comptage est initialis√©e √† l'aide de la fonction ref.  Il prend une primitive ou un objet et renvoie un lien r√©actif.  La valeur transmise sera stock√©e dans la propri√©t√© value du lien cr√©√©.  Par exemple, si nous voulons acc√©der √† la valeur de count, nous devons acc√©der explicitement √† count.value. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> double = computed(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> count.value * <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ count.value++ }</code> </pre><br>  Nous d√©clarons donc une double propri√©t√© calcul√©e et une fonction d'incr√©mentation. <br><br><pre> <code class="javascript hljs">onMounted(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'component mounted!'</span></span>))</code> </pre> <br>  √Ä l'aide du crochet onMounted, nous imprimons un message √† la console apr√®s avoir mont√© le composant pour d√©montrer cette possibilit√©. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { count, double, increment }</code> </pre> <br>  Pour que les propri√©t√©s count et double et la m√©thode increment soient disponibles dans le mod√®le, nous les renvoyons depuis la m√©thode setup. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> @</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"increment"</span></span></span><span class="hljs-tag">&gt;</span></span> Count is: {{ count }}, double is {{ double }}. Click to increment. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Et le tour est jou√©!  Nous avons acc√®s aux propri√©t√©s et m√©thodes de la configuration, comme si elles avaient √©t√© d√©clar√©es via l'ancienne API Options. <br><br>  Il s'agit d'un exemple simple, similaire pourrait facilement √™tre √©crit √† l'aide de l'API Options. <br>  Mais l'avantage de la nouvelle API de composition n'est pas tant dans la possibilit√© d'√©crire du code dans un style diff√©rent, mais dans les possibilit√©s ouvertes pour la r√©utilisation de la logique. <br><br><h2>  R√©utilisation du code avec l'API Composition </h2><br>  Examinons de plus pr√®s les avantages de la nouvelle API Composition, par exemple, pour la r√©utilisation de code.  Maintenant, si nous voulons utiliser un morceau de code dans plusieurs composants, nous avons deux options: les mixins et les emplacements de port√©e.  Les deux options ont leurs inconv√©nients. <br><br>  Nous voulons extraire la fonctionnalit√© du compteur et la r√©utiliser dans d'autres composants.  Voici un exemple de la fa√ßon dont cela peut √™tre fait en utilisant l'existant et en utilisant la nouvelle API. <br><br>  Pour commencer, consid√©rez l'impl√©mentation √† l'aide de mixins. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CounterMixin <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./mixins/counter'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { <span class="hljs-attr"><span class="hljs-attr">mixins</span></span>: [CounterMixin] }</code> </pre> <br>  Le plus gros probl√®me avec cette approche est que nous ne savons rien de ce qui est ajout√© √† notre composant.  Cela rend la compr√©hension difficile et peut conduire √† des conflits avec les propri√©t√©s et m√©thodes existantes. <br><br>  Consid√©rez maintenant les emplacements avec une port√©e limit√©e. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Counter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{ count, increment }"</span></span></span><span class="hljs-tag">&gt;</span></span> {{ count }} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> @</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"increment"</span></span></span><span class="hljs-tag">&gt;</span></span>Increment<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Counter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Lorsque vous utilisez des emplacements, nous savons exactement √† quelles propri√©t√©s nous avons acc√®s via la directive v-slot, qui est assez simple √† comprendre.  L'inconv√©nient de cette approche est que nous ne pouvons acc√©der qu'aux donn√©es du composant Counter. <br><br>  Consid√©rons maintenant une impl√©mentation utilisant l'API Composition. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = ref(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ count.value++ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { count, incrememt } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { setup () { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { count, increment } = useCounter() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { count, increment } } }</code> </pre> <br>  Il a l'air beaucoup plus √©l√©gant, non?  Nous ne sommes pas limit√©s par un mod√®le ou une √©tendue, et nous savons exactement quelles propri√©t√©s de compteur sont disponibles.  Et du fait que useCounter n'est qu'une fonction qui renvoie des donn√©es, un bonus agr√©able nous permet de terminer le code dans l'√©diteur.  Il n'y a pas de magie ici, donc l'√©diteur peut nous aider avec la v√©rification de type et donner des conseils. <br><br>  L'utilisation de biblioth√®ques tierces semble √©galement meilleure.  Par exemple, si nous voulons utiliser Vuex, nous pouvons importer explicitement la fonction useStore et ne pas obstruer le prototype Vue avec cette propri√©t√©. $ Store.  Cette approche vous permet de vous d√©barrasser des manipulations suppl√©mentaires dans les plugins. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { commit, dispatch } = useStore()</code> </pre> <br>  Si vous souhaitez en savoir plus sur l'API Composition et ses applications, je vous recommande de lire un document dans lequel l'√©quipe Vue explique les raisons de la cr√©ation d'une nouvelle API et propose des cas dans lesquels elle sera utile.  Il existe √©galement un magnifique r√©f√©rentiel avec des exemples d'utilisation de l'API Composition de Thorsten L√ºnborg, l'un des membres de l'√©quipe de base de Vue. <br><br><h2>  Changements de configuration et de montage </h2><br>  Il y a d'autres changements importants dans la nouvelle Vue dans la fa√ßon dont nous construisons et configurons notre application.  Regardons un exemple. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App.vue'</span></span> Vue.config.ignoredElements = [<span class="hljs-regexp"><span class="hljs-regexp">/^app-/</span></span>] Vue.use(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) Vue.mixin(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) Vue.component(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) Vue.directive(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vue({ <span class="hljs-attr"><span class="hljs-attr">render</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">h</span></span></span><span class="hljs-function"> =&gt;</span></span> h(App) }).$mount(<span class="hljs-string"><span class="hljs-string">'#app'</span></span>)</code> </pre> <br>  Nous utilisons maintenant l'objet global Vue pour configurer et cr√©er de nouvelles instances de Vue.  Toute modification que nous apportons √† l'objet Vue affectera les instances et composants finaux. <br><br>  Voyons comment cela fonctionnera dans Vue 3. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createApp } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App.vue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = createApp(App) app.config.ignoredElements = [<span class="hljs-regexp"><span class="hljs-regexp">/^app-/</span></span>] app.use(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) app.mixin(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) app.component(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) app.directive(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) app.mount(<span class="hljs-string"><span class="hljs-string">'#app'</span></span>)</code> </pre> <br>  Comme vous l'avez d√©j√† remarqu√©, la configuration fait r√©f√©rence √† une instance de Vue sp√©cifique cr√©√©e √† l'aide de createApp. <br><br>  Cela rend notre code plus lisible, r√©duit les risques de probl√®mes inattendus avec des plugins tiers.  Maintenant, toute biblioth√®que tierce qui modifie l'objet global Vue peut affecter votre application dans un endroit inattendu (surtout s'il s'agit d'un mixage global), ce qui est impossible dans Vue 3. <br><br>  Ces changements <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sont discut√©s</a> dans le RFC, et peut-√™tre √† l'avenir la mise en ≈ìuvre sera diff√©rente. <br><br><h2>  Fragments </h2><br>  Une autre fonctionnalit√© int√©ressante sur laquelle nous pouvons compter dans Vue 3. <br>  Quels sont les fragments? <br>  Actuellement, un composant ne peut avoir qu'un seul √©l√©ment racine, ce qui signifie que le code ci-dessous ne fonctionnera pas. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>Hello<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>World<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  La raison en est que l'instance Vue qui se cache derri√®re chaque composant ne peut √™tre attach√©e qu'√† un seul √©l√©ment DOM.  Il existe maintenant un moyen de cr√©er un composant avec plusieurs √©l√©ments racine: pour cela, vous devez √©crire un composant dans un style fonctionnel qui n'a pas besoin de sa propre instance de Vue. <br><br>  Il s'av√®re que le m√™me probl√®me existe dans la communaut√© React, il a √©t√© r√©solu en utilisant l'√©l√©ment Fragment virtuel. <br><br>  Cela ressemble √† ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Columns</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">React.Fragment</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">td</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Hello</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">td</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">td</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">World</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">td</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">React.Fragment</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); } }</span></span></code> </pre> <br>  Malgr√© le fait que Fragment ressemble √† un √©l√©ment DOM normal, il est virtuel et ne sera pas cr√©√© dans l'arborescence DOM.  Avec cette approche, nous pouvons utiliser la fonctionnalit√© d'un seul √©l√©ment racine sans cr√©er un √©l√©ment suppl√©mentaire dans le DOM. <br><br>  Vous pouvez maintenant utiliser des fragments dans Vue 2, mais en utilisant la biblioth√®que vue-fragments, et dans Vue 3, ils fonctionneront pr√™ts √† l'emploi! <br><br><h2>  Suspense </h2><br>  Une autre excellente id√©e de l'√©cosyst√®me React qui sera impl√©ment√©e dans Vue 3 est Suspense. <br><br>  Suspense suspend le rendu du composant et affiche un stub jusqu'√† ce que certaines conditions soient remplies.  √Ä Vue London, Ewan Yu a effleur√© Suspense avec d√©sinvolture et a r√©v√©l√© l'API que nous pouvons attendre √† l'avenir.  Le composant Suspense aura 2 emplacements: pour le contenu et pour le talon. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Suspense</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Suspended-component</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> #</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fallback</span></span></span><span class="hljs-tag">&gt;</span></span> Loading... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Suspense</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Le stub sera affich√© jusqu'√† ce que le composant &lt;Suspended-component /&gt; soit pr√™t.  Le composant Suspense peut √©galement s'attendre √† charger le composant asynchrone ou √† effectuer certaines actions asynchrones dans la fonction de configuration. <br><br><h2>  Plusieurs mod√®les en V </h2><br>  v-model est une directive avec laquelle vous pouvez utiliser une liaison bidirectionnelle.  Nous pouvons transmettre la propri√©t√© r√©active et la modifier √† l'int√©rieur du composant. <br><br>  Nous sommes bien connus pour travailler avec des √©l√©ments de formulaire. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-model</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"property"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br>  Mais saviez-vous que le mod√®le v peut √™tre utilis√© avec n'importe quel composant?  Sous le capot, le mod√®le v ne fait que transmettre le param√®tre de valeur et √©couter l'√©v√©nement d'entr√©e. <br><br>  Vous pouvez r√©√©crire l'exemple pr√©c√©dent en utilisant cette syntaxe comme suit: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-bind:value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"property"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-on:input</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"property = $event.target.value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br>  Vous pouvez m√™me modifier les noms de propri√©t√© et les √©v√©nements par d√©faut √† l'aide de l'option de mod√®le: <br><br><pre> <code class="javascript hljs">model: { <span class="hljs-attr"><span class="hljs-attr">prop</span></span>: <span class="hljs-string"><span class="hljs-string">'checked'</span></span>, <span class="hljs-attr"><span class="hljs-attr">event</span></span>: <span class="hljs-string"><span class="hljs-string">'change'</span></span> }</code> </pre> <br>  Comme vous pouvez le voir, la directive v-model peut √™tre un ¬´sucre syntaxique¬ª tr√®s utile si nous voulons utiliser la liaison bidirectionnelle dans nos composants.  Malheureusement, il ne peut y avoir qu'un seul mod√®le en V par composant. <br><br>  Heureusement, dans Vue 3, ce probl√®me sera r√©solu.  Nous pouvons transmettre le nom √† v-model et utiliser autant de v-model que n√©cessaire. <br><br>  Exemple d'utilisation: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">InviteeForm</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-model:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"inviteeName"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-model:email</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"inviteeEmail"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br>  Ces changements <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sont discut√©s</a> dans le RFC, et peut-√™tre √† l'avenir la mise en ≈ìuvre sera diff√©rente. <br><br><h2>  Portails </h2><br>  Les portails sont des composants cr√©√©s pour rendre le contenu en dehors de la hi√©rarchie du composant actuel.  C'est √©galement l'une des fonctionnalit√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">impl√©ment√©es dans React</a> .  Dans la documentation de React, les portails sont d√©crits comme suit: "Les portails vous permettent de rendre des enfants dans un n≈ìud DOM qui est en dehors de la hi√©rarchie DOM du composant parent." <br><br>  Les portails sont parfaits pour impl√©menter des composants tels que les fen√™tres modales, les fen√™tres contextuelles et tous ceux qui doivent √™tre affich√©s en haut de la page. <br><br>  Lorsque vous utilisez des portails, vous pouvez √™tre s√ªr que les styles du composant parent n'affecteront pas le composant enfant.  Il vous permettra √©galement d'√©conomiser des hacks z-index sales. <br><br>  Pour chaque portail, nous devons sp√©cifier la destination dans laquelle le contenu du portail doit √™tre affich√©. <br><br>  Ce qui suit est une option d'impl√©mentation de la biblioth√®que portal-vue, qui ajoute des portails √† Vue 2. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">portal</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">to</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"destination"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>This slot content will be rendered wherever the portal-target with name 'destination' is located.<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">portal</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">portal-target</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"destination"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- This component can be located anywhere in your App. The slot content of the above portal component wilbe rendered here. --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">portal-target</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Et dans Vue 3, cette fonctionnalit√© sera pr√™te √† l'emploi. <br><br><h2>  Nouvelle API de directive personnalis√©e </h2><br>  L'API de directive personnalis√©e changera un peu dans Vue 3 pour mieux correspondre au cycle de vie du composant.  La cr√©ation de directives deviendra plus intuitive et donc plus facile √† comprendre et √† apprendre pour les d√©butants. <br><br>  Maintenant, la d√©claration de la directive utilisateur ressemble √† ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyDirective = { bind(el, binding, vnode, prevVnode) {}, inserted() {}, update() {}, componentUpdated() {}, unbind() {} }</code> </pre> <br>  Et dans Vue 3, cela ressemblera √† ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyDirective = { beforeMount(el, binding, vnode, prevVnode) {}, mounted() {}, beforeUpdate() {}, updated() {}, beforeUnmount() {}, <span class="hljs-comment"><span class="hljs-comment">// new unmounted() {} }</span></span></code> </pre> <br>  Bien que ces changements soient en rupture, ils peuvent √™tre utilis√©s avec une version Vue compatible. <br><br>  Cette API est √©galement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discut√©e</a> et pourrait changer √† l'avenir. <br><br><h2>  R√©sum√© </h2><br>  √Ä c√¥t√© de l'innovation significative - l'API Composition - nous pouvons trouver plusieurs petites am√©liorations.  De toute √©vidence, Vue s'oriente vers l'am√©lioration de l'exp√©rience des d√©veloppeurs, vers des API simplifi√©es et intuitives.  C'est aussi cool de voir que l'√©quipe Vue a d√©cid√© d'ajouter beaucoup d'id√©es au c≈ìur du cadre qui sont d√©j√† impl√©ment√©es dans des biblioth√®ques tierces. <br><br>  La liste ci-dessus ne contient que les am√©liorations et modifications les plus importantes de l'API.  Si vous souhaitez en savoir plus sur les autres, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le r√©f√©rentiel RFC</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr475968/">https://habr.com/ru/post/fr475968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr475948/index.html">JH Rainwater "Comment faire pa√Ætre les chats" (deuxi√®me partie): tout ce qui reste √† ma√Ætriser technique</a></li>
<li><a href="../fr475950/index.html">Pourquoi un robot devrait-il se limiter √† ramasser des balles de golf? Il y a aussi le tennis</a></li>
<li><a href="../fr475956/index.html">Comment nous avons cr√©√© la technologie de reconnaissance optique de texte. OCR sur Yandex</a></li>
<li><a href="../fr475958/index.html">L'histoire de la fa√ßon dont la fille s'est r√©unie en informatique</a></li>
<li><a href="../fr475960/index.html">AHURATUS Smart Home Voice Assistant</a></li>
<li><a href="../fr475974/index.html">Comment nous avons fait un hackathon dans le train et ce qui en est sorti</a></li>
<li><a href="../fr475978/index.html">√Ä quoi sert le si√®ge du train?</a></li>
<li><a href="../fr475980/index.html">Faible connectivit√©, architecture et organisation d'√©quipe</a></li>
<li><a href="../fr475982/index.html">Comment apprendre une langue √©trang√®re</a></li>
<li><a href="../fr475986/index.html">Pr√©sentation du PocketBook 740 Pro Reader: 7,8 pouces, protection audio et IPX8</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>