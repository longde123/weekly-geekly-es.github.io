<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêª üõí ü•ü Casse-t√™te Kotlin, Vol. 2: un nouveau lot de puzzles üë®üèº‚Äçüíº üßñüèΩ üçó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pouvez-vous pr√©dire comment un tel code Kotlin se comportera? Compilera-t-il ce qui sortira et pourquoi? 

 Peu importe la qualit√© du langage de progr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Casse-t√™te Kotlin, Vol. 2: un nouveau lot de puzzles</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/440974/"><img src="https://habrastorage.org/webt/bj/9x/wi/bj9xwicnsccegyu2fo2xvbvglr0.png"><br><br>  Pouvez-vous pr√©dire comment un tel code Kotlin se comportera?  Compilera-t-il ce qui sortira et pourquoi? <br><br>  Peu importe la qualit√© du langage de programmation, il peut lancer de telle sorte qu'il ne reste plus qu'√† vous gratter la t√™te.  Kotlin ne fait pas exception - il contient √©galement des puzzles, m√™me si un morceau de code tr√®s court a un comportement inattendu. <br><br>  En 2017, nous avons publi√© sur Habr√© une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s√©lection de</a> tels puzzles d' <b>Anton</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Keks antonkeks</a> .  Et plus tard, il a jou√© avec nous sur Mobius avec la deuxi√®me s√©lection, et nous l'avons maintenant √©galement traduit pour Habr en une vue texte, cachant les bonnes r√©ponses sous les spoilers. <br><br>  Nous joignons √©galement l'enregistrement vid√©o du discours, si quelque chose semble incompr√©hensible dans le texte, vous pouvez √©galement la contacter. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/t387acWEK3o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  La premi√®re moiti√© des puzzles s'adresse √† ceux qui ne sont pas tr√®s familiers avec Kotlin;  la seconde moiti√© est pour les d√©veloppeurs hardcore de Kotlin.  Nous allons tout d√©marrer sur Kotlin 1.3, m√™me avec le mode progressif activ√©.  Les codes sources de Puzzler sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur GitHub</a> .  Quiconque propose de nouvelles id√©es, envoie des demandes de tirage. <br><br><h2>  Pazzler num√©ro 1 </h2><br><pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { println(print(‚Ä≥Hello‚Ä≥) == print(‚Ä≥World‚Ä≥) == <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } hello()</code> </pre> <br>  Avant nous est une simple fonction bonjour, elle ex√©cute plusieurs impressions.  Et nous lan√ßons cette fonction elle-m√™me.  Une simple question d'overclocking: que faut-il imprimer? <br><br>  a) HelloWorld <br>  b) HelloWorldfalse <br>  c) HelloWorldtrue <br>  d) Non compil√© <br><br><div class="spoiler">  <b class="spoiler_title">Bonne r√©ponse</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ce/uc/rg/ceucrgqimyvojaud8llfktt0l1s.png"><br><br>  La premi√®re option √©tait correcte.  La comparaison est d√©clench√©e une fois que les deux impressions ont d√©j√† commenc√©, elle ne peut pas commencer plus t√¥t.  Pourquoi ce code est-il compil√©?  Toute fonction autre que le retour de Nothing renvoie quelque chose.  Puisque tout dans Kotlin est une expression, m√™me le retour est aussi une expression.  Le type de retour de retour est Nothing, il est converti en n'importe quel type, vous pouvez donc comparer comme ceci.  Et l'impression renvoie Unit, de sorte que Unit peut √™tre compar√© √† Nothing un certain nombre de fois, et tout fonctionne tr√®s bien. <br></div></div><br><h2>  Pazzler num√©ro 2 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { println(n) } printInt(-<span class="hljs-number"><span class="hljs-number">2_147_483_648</span></span>.inc())</code> </pre><br>  Astuce que vous ne devinez pas: un nombre effrayant est vraiment le plus petit entier sign√© 32 bits possible. <br><br>  Ici, tout semble simple.  Kotlin a de grandes fonctions d'extension comme .inc () pour l'incr√©mentation.  Nous pouvons l'appeler sur Int, et nous pouvons imprimer le r√©sultat.  Que va-t-il se passer? <br><br>  a) -2147483647 <br>  b) -2147483649 <br>  c) 2147483647 <br>  d) Aucune de ces r√©ponses <br><br><div class="spoiler">  <b class="spoiler_title">Lancez!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/se/sa/hy/sesahyqljf-z0kyeil35hpev4ho.png"><br><br>  Comme vous pouvez le voir dans le message d'erreur, voici le probl√®me avec Long.  Mais pourquoi longtemps? <br><br>  Les fonctions d'extension ont la priorit√©, et le compilateur ex√©cute d'abord inc (), puis l'op√©rateur moins.  Si inc () est supprim√©, ce sera Int et tout fonctionnera.  Mais inc (), commen√ßant en premier, transforme 2_147_483_648 en Long, car ce nombre sans signe n√©gatif n'est plus valide Int.  Il s'av√®re Long, et alors seulement le moins est appel√©.  Tout cela ne peut plus √™tre transmis √† la fonction printInt (), car elle n√©cessite un Int. <br><br>  Si nous changeons l'appel printInt en une impression r√©guli√®re, qui peut accepter Long, la deuxi√®me option sera correcte. <br><br><img src="https://habrastorage.org/webt/qf/vf/q3/qfvfq3njfzcubm6ax7uvda6g8b4.png"><br><br>  Nous voyons que c'est en fait long.  M√©fiez-vous de cela: toutes les pi√®ces du puzzle ne peuvent pas √™tre ex√©cut√©es dans du vrai code, mais celle-ci le peut. <br></div></div><br><h2>  Pazzler num√©ro 3 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x: UInt = <span class="hljs-number"><span class="hljs-number">0</span></span>u println(x--.toInt()) println(--x)</code> </pre><br>  Dans Kotlin 1.3 est venu de nouvelles fonctionnalit√©s int√©ressantes.  En plus de la version finale de la corutine, nous <br>  ont maintenant enfin des num√©ros non sign√©s.  Cela est n√©cessaire, surtout si vous √©crivez une sorte de code r√©seau. <br><br>  Maintenant, pour les litt√©raux, il y a m√™me une lettre sp√©ciale u, nous pouvons d√©finir des constantes, nous pouvons, comme dans l'exemple, d√©cr√©menter x et convertir en Int.  Je vous rappelle qu'Int nous conna√Æt. <br><br>  Que va-t-il se passer? <br><br>  a) -1 4294967294 <br>  b) 0 4294967294 <br>  c) 0 -2 <br>  d) Non compil√© <br><br>  4294967294 est le nombre maximal de 32 bits qui peut √™tre obtenu. <br><br><div class="spoiler">  <b class="spoiler_title">Lancez!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/uj/up/ch/ujupchn07nkjmqfl8a9hnhbycha.png"><br><br>  Bonne option b. <br><br>  Ici, comme dans la version pr√©c√©dente: d'abord, toInt () est appel√© sur x, et ensuite seulement d√©cr√©mente.  Le r√©sultat de la d√©cr√©mentation non sign√© s'affiche, et c'est le maximum de unsignedInt. <br><br>  La chose la plus int√©ressante est que si vous √©crivez comme √ßa, le code ne compilera pas: <br><br><pre> <code class="kotlin hljs">println(x--.toInt()) println(--x.toInt())</code> </pre><br>  Et pour moi, il est tr√®s √©trange que la premi√®re ligne fonctionne, et la seconde - non, c'est illogique. <br><br>  Et dans la version pr√©liminaire, l'option correcte serait C, si bien fait dans JetBrains qui corrige les bugs avant la sortie de la version finale. <br></div></div><br><h2>  Pazzler num√©ro 4 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cells = arrayOf(arrayOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), arrayOf(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), arrayOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> neighbors = cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] print(neighbors)</code> </pre><br>  Nous avons rencontr√© ce cas en code r√©el.  Chez Codeborne, nous avons fait Coding Dojo, nous l'avons impl√©ment√© ensemble sur le Kotlin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Game of Life</a> .  Comme vous pouvez le voir, il n'est pas tr√®s pratique de travailler avec des tableaux √† plusieurs niveaux sur Kotlin. <br><br>  Dans Game of Life, une partie importante de l'algorithme consiste √† d√©terminer le nombre de voisins pour une cellule.  Tous les petits autour sont des voisins, et cela d√©pend si la cellule vit ou meurt.  Dans ce code, vous pouvez compter celles et supposer ce qui se passe. <br><br>  a) 6 <br>  b) 3 <br>  c) 2 <br>  d) Non compil√© <br><br><div class="spoiler">  <b class="spoiler_title">Voyons voir</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/m2/8_/j0/m28_j0aa1kg9j7aixnsj2trzsrg.png"><br><br>  La bonne r√©ponse est 3. <br><br>  Le fait est que le plus de la premi√®re ligne est d√©plac√© vers le bas, et Kotlin pense que c'est unaryPlus ().  Par cons√©quent, seules les trois premi√®res cellules sont additionn√©es.  Si nous voulons √©crire ce code sur plusieurs lignes, nous devons d√©placer le plus vers le haut. <br><br>  Ceci est un autre des ¬´mauvais puzzlers¬ª.  N'oubliez pas que dans Kotlin, vous n'avez pas besoin de transf√©rer la d√©claration vers une nouvelle ligne, sinon elle peut la consid√©rer comme unaire. <br><br><img src="https://habrastorage.org/webt/f5/-9/ew/f5-9ewbhsw0ucybzsg-7xkeld1u.png"><br><br>  Je n'ai pas vu de situations o√π unaryPlus est n√©cessaire dans le vrai code sauf DSL.  C'est un sujet tr√®s √©trange. <br><br>  C'est le prix √† payer pour l'absence de point-virgule.  S'ils l'√©taient, il serait clair quand une expression se termine et une autre commence.  Et sans eux, le compilateur doit prendre la d√©cision.  Les sauts de ligne pour le compilateur signifient tr√®s souvent qu'il est logique d'essayer d'examiner les lignes s√©par√©ment. <br><br>  Mais il existe un langage JavaScript tr√®s cool dans lequel vous ne pouvez pas non plus √©crire de points-virgules, et ce code fonctionnera toujours correctement. <br></div></div><br><h2>  Pazzler num√©ro 5 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = x?:<span class="hljs-number"><span class="hljs-number">0</span></span> + y println(sum)</code> </pre><br>  Ce casse-t√™te est pr√©sent√© par le conf√©rencier de KotlinConf, Thomas Nild. <br><br>  Kotlin a une grande fonctionnalit√© de types nullable.  Nous avons un x nul, et nous pouvons le convertir, s'il s'av√®re nul, via l'op√©rateur Elvis en une valeur normale. <br><br>  Que va-t-il se passer? <br><br>  a) 3 <br>  b) 5 <br>  c) 2 <br>  d) 0 <br><br><div class="spoiler">  <b class="spoiler_title">Lancez!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1_/zg/-o/1_zg-ozj8sgftbrk2nswebclg30.png"><br><br>  Le probl√®me est √† nouveau dans l'ordre ou la priorit√© des op√©rateurs.  Si nous reformatons ceci, alors le format officiel fera ceci: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = x ?: <span class="hljs-number"><span class="hljs-number">0</span></span>+y</code> </pre><br>  Le format sugg√®re d√©j√† que 0 + y commence en premier, puis seulement x?:.  Par cons√©quent, bien s√ªr, 2 reste, car X est deux, il n'est pas nul. <br></div></div><br><h2>  Pazzler num√©ro 6 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hops: List&lt;Hops&gt; = emptyList() ) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hops</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kind: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> atMinute: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grams: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(build: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Recipe</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = Recipe().apply(build) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Recipe.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hops</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(build: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Hops</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { hops += Hops().apply(build) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> recipe = beer { name = ‚Ä≥Simple IPA‚Ä≥ hops { name = ‚Ä≥Cascade‚Ä≥ grams = <span class="hljs-number"><span class="hljs-number">100</span></span> atMinute = <span class="hljs-number"><span class="hljs-number">15</span></span> } }</code> </pre><br>  Quand ils m'ont appel√© ici, ils m'ont promis de la bi√®re artisanale.  Je vais le chercher ce soir, je ne l'ai pas encore vu.  Kotlin a un excellent sujet - les constructeurs.  Avec quatre lignes de code, nous √©crivons notre DSL puis le cr√©ons via les g√©n√©rateurs. <br><br>  Nous cr√©ons, tout d'abord, de l'IPA, ajoutons du houblon appel√© Cascade, 100 grammes √† la 15e minute de cuisson, puis imprimons cette recette.  Qu'avons-nous fait? <br><br>  a) Recette (nom = IPA simple, houblon = [Houblon (nom = Cascade, atMinute = 15, grammes = 100)]) <br>  b) IllegalArgumentException <br>  c) Non compil√© <br>  d) Aucune de ces r√©ponses <br><br><div class="spoiler">  <b class="spoiler_title">Lancez!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ji/ci/8p/jici8p8px4kd4hnogzpvcufsrqi.png"><br><br>  Nous avons obtenu quelque chose de similaire √† de la bi√®re artisanale, mais il n'y a pas de houblon, elle a disparu.  Ils voulaient une IPA, mais ont obtenu Baltic 7. <br><br>  C'est l√† que le choc des noms s'est produit.  Le champ dans Hops est en fait appel√© kind, et dans la ligne name = ‚Ä≥ Cascade ‚Ä≥, nous utilisons name, qui est mis en cache avec le nom de la recette. <br><br>  Nous pouvons cr√©er notre propre annotation BeerLang et l'enregistrer dans le cadre du BeerLang DSL.  Maintenant, nous essayons d'ex√©cuter ce code, et il ne doit pas √™tre compil√© avec nous. <br><br><img src="https://habrastorage.org/webt/eq/i-/a3/eqi-a3r5hjxbpsy7z-rlzqlkqjg.png"><br><br>  On nous dit maintenant qu'en principe, le nom ne peut pas √™tre utilis√© dans ce contexte.  Pour cela, DSLMarker est n√©cessaire car le compilateur √† l'int√©rieur du g√©n√©rateur ne nous a pas permis d'utiliser le champ externe, si nous en avons le m√™me √† l'int√©rieur afin qu'il n'y ait pas de conflit de d√©nomination.  Le code est fix√© comme √ßa, et nous obtenons notre recette. <br><br><img src="https://habrastorage.org/webt/rv/kn/8y/rvkn8ys1t9syngob9ikmtfbgij8.png"><br></div></div><br><h2>  Pazzler num√©ro 7 </h2><br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (x) { x == <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(‚Ä≥$x TRUE‚Ä≥) x == <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(‚Ä≥$x FALSE‚Ä≥) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br>  Ce casse-t√™te est l'un des employ√©s de JetBrains.  Kotlin a une fonctionnalit√© quand.  C'est pour toutes les occasions, il vous permet d'√©crire du code cool, il est souvent utilis√© avec des classes scell√©es pour la conception d'API. <br><br>  Dans ce cas, nous avons une fonction f () qui prend un bool√©en et imprime quelque chose en fonction de true et false. <br><br>  Que va-t-il se passer? <br><br>  a) vrai VRAI;  faux faux <br>  b) vrai VRAI;  faux VRAI <br>  c) vrai FAUX;  faux faux <br>  d) Aucune de ces r√©ponses <br><br><div class="spoiler">  <b class="spoiler_title">Voyons voir</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/c6/g0/lo/c6g0loicys30gkbo0bf9cagvk20.png"><br><br>  Pourquoi  Tout d'abord, nous calculons l'expression x == true: par exemple, dans le premier cas, ce sera true == true, ce qui signifie vrai.  Et puis il y a aussi une comparaison avec le mod√®le que nous avons adopt√© quand. <br><br>  Et lorsque x est d√©fini sur false, √©valuer x == true nous donnera faux, cependant, l'√©chantillon sera √©galement faux - donc l'exemple correspondra √† l'√©chantillon. <br><br>  Il existe deux fa√ßons de corriger ce code, l'une consiste √† supprimer ¬´x ==¬ª dans les deux cas: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (x) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(‚Ä≥$x TRUE‚Ä≥) <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(‚Ä≥$x FALSE‚Ä≥) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br>  La deuxi√®me option consiste √† supprimer (x) apr√®s quand.  Lorsque fonctionne avec toutes les conditions, puis ne correspondra pas √† l'√©chantillon. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { x == <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(‚Ä≥$x TRUE‚Ä≥) x == <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(‚Ä≥$x FALSE‚Ä≥) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br></div></div><br><h2>  Pazzler num√©ro 8 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullSafeLang</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> logo = name[<span class="hljs-number"><span class="hljs-number">0</span></span>].toUpperCase() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kotlin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NullSafeLang</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = ‚Ä≥Kotlin‚Ä≥ } print(Kotlin().logo)</code> </pre><br>  Kotlin a √©t√© commercialis√© comme une langue ¬´sans danger¬ª.  Imaginez que nous ayons une classe abstraite, elle a un nom, et aussi une propri√©t√© qui renvoie le logo de cette langue: la premi√®re lettre du nom, juste au cas o√π, a fait du capital (du coup on a oubli√© de faire le capital initial). <br><br>  Comme la langue est sans danger, nous changerons le nom et nous devrons probablement obtenir le bon logo, qui est une lettre.  Qu'obtenons-nous vraiment? <br><br>  a) K <br>  b) NullPointerException <br>  c) IllegalStateException <br>  d) Non compil√© <br><br><div class="spoiler">  <b class="spoiler_title">Lancez!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bb/et/sm/bbetsm3lj5eh356zwho6z4bhzjs.png"><br><br>  Nous avons obtenu une exception NullPointerException, que nous ne devrions pas recevoir.  Le probl√®me est que le constructeur de la superclasse est appel√© en premier, le code essaie d'initialiser le logo de la propri√©t√© et prend le nom char √† partir de z√©ro, et √† ce stade, le nom est nul, donc une exception NullPointerException se produit. <br><br>  La meilleure fa√ßon de r√©soudre ce probl√®me est de proc√©der comme suit: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kotlin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NullSafeLang</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = ‚Ä≥Kotlin‚Ä≥ }</code> </pre><br>  Si nous ex√©cutons un tel code, nous obtenons "K".  Maintenant, la classe de base appellera le constructeur de la classe de base, elle appellera en fait le nom du getter et r√©cup√©rera Kotlin. <br><br>  La propri√©t√© est une excellente fonctionnalit√© de Kotlin, mais vous devez √™tre tr√®s prudent lorsque vous remplacez des propri√©t√©s, car il est tr√®s facile d'oublier, de faire une erreur ou d'assurer la mauvaise chose. <br><br></div></div><br><h2>  Pazzler num√©ro 9 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = mutableListOf&lt;() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span>) { i++ result += { print(‚Ä≥$i, $j; ‚Ä≥) } } result.forEach { it() }</code> </pre><br>  Il y a une liste mutable de certaines choses effrayantes.  Si cela vous rappelle Scala, ce n'est pas en vain, car il ressemble vraiment.  Il y a une liste lambd, nous prenons deux compteurs - I et j, incr√©mentons puis faisons quelque chose avec eux.  Que va-t-il se passer? <br><br>  a) 1 1;  2 2;  3 3 <br>  b) 1 3;  2 3;  3 3 <br>  c) 3 1;  3 2;  3 3 <br>  d) aucune de ces r√©ponses <br><br><div class="spoiler">  <b class="spoiler_title">Courons</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/y8/ap/9j/y8ap9j-cfyyuanfscsg_irflczy.png"><br><br>  Nous obtenons 3 1;  3 2;  3 3. Cela se produit car i est une variable, et elle conservera sa valeur jusqu'√† la fin de la fonction.  Et j est pass√© par valeur. <br><br>  Si au lieu de var i = 0, il y aurait val i = 0, cela ne fonctionnerait pas, mais nous ne pourrions pas incr√©menter la variable. <br><br>  Ici, dans Kotlin, nous utilisons la fermeture, cette fonctionnalit√© n'est pas en Java.  C'est tr√®s cool, mais cela peut nous mordre si nous n'utilisons pas imm√©diatement la valeur de i, mais la transmettons au lambda, qui d√©marre plus tard et voit la derni√®re valeur de cette variable.  Et j est pass√© par valeur, car les variables dans la condition de boucle - elles sont les m√™mes que val, elles ne changent plus leur valeur. <br><br>  En JavaScript, la r√©ponse serait ¬´3 3;  3 3;  3 3 ‚Äù, car rien n'est transmis par la valeur. <br><br></div></div><br><h2>  Pazzler num√©ro 10 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = print(‚Ä≥$a, $b‚Ä≥) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> d = <span class="hljs-number"><span class="hljs-number">4</span></span> foo(c &lt; a, b &gt; d)</code> </pre><br>  Nous avons une fonction foo (), prend deux bool√©ens, les imprime, tout semble simple.  Et nous avons un tas de chiffres, il reste √† voir quel chiffre est plus grand que l'autre, et d√©cider quelle option est correcte. <br><br>  a) vrai, vrai <br>  b) faux, faux <br>  c) null, null <br>  d) non compil√© <br><br><div class="spoiler">  <b class="spoiler_title">Nous lan√ßons</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/j6/m5/5c/j6m55cysqvltjnc9x67mxerzglq.png"><br><br>  Non compil√©. <br><br>  Le probl√®me est que le compilateur pense que cela est similaire aux param√®tres g√©n√©riques: avec &lt;a, b&gt;.  Bien qu'il semble que ¬´c¬ª ne soit pas une classe, il n'est pas clair pourquoi il devrait avoir des param√®tres g√©n√©riques. <br><br>  Si le code √©tait comme √ßa, cela fonctionnerait tr√®s bien: <br><br><pre> <code class="kotlin hljs">foo(c &gt; a, b &gt; d)</code> </pre><br>  Il me semble que c'est un bug dans le compilateur.  Mais quand je monte √† Andrei Breslav avec un tel casse-t√™te, il dit "c'est parce que l'analyseur est comme √ßa, ils ne voulaient pas que ce soit trop lent."  En g√©n√©ral, il trouve toujours une explication pourquoi. <br><br>  C'est malheureusement le cas.  Il a dit qu'ils ne le r√©pareraient pas, parce que l'analyseur <br>  Kotlin ne conna√Æt pas encore la s√©mantique.  L'analyse se produit d'abord, puis elle la transmet √† un autre composant du compilateur.  Malheureusement, cela restera probablement ainsi.  N'√©crivez donc pas deux de ces crochets et aucun code au milieu! <br></div></div><br><h2>  Pazzler num√©ro 11 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Container</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> items: List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;) : List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (name, items) = Container(‚Ä≥Kotlin‚Ä≥, listOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) println(‚Ä≥Hello $name, $items‚Ä≥)</code> </pre><br>  D√©l√©gu√© est une excellente fonctionnalit√© dans Kotlin.  Soit dit en passant, Andrei Breslav dit que c'est une fonctionnalit√© qu'il retirerait volontiers de la langue, il ne l'aime plus.  Maintenant, peut-√™tre, nous allons d√©couvrir pourquoi!  Et il a √©galement dit que les objets compagnons √©taient laids. <br><br>  Mais les classes de donn√©es sont vraiment belles.  Nous avons un conteneur de classe de donn√©es, il prend un nom et des √©l√©ments pour lui-m√™me.  Dans le m√™me temps, dans le conteneur, nous impl√©mentons le type d'√©l√©ments, c'est List, et nous d√©l√©guons toutes ses m√©thodes aux √©l√©ments. <br><br>  Ensuite, nous utilisons une autre fonctionnalit√© int√©ressante - la destruction.  Nous ¬´d√©truisons¬ª le nom et les √©l√©ments du conteneur et les affichons √† l'√©cran.  Tout semble simple et clair.  Que va-t-il se passer? <br><br>  a) Bonjour Kotlin, [1, 2, 3] <br>  b) Bonjour Kotlin, 1 <br>  c) Bonjour 1, 2 <br>  d) Bonjour Kotlin, 2 <br><br><div class="spoiler">  <b class="spoiler_title">Nous lan√ßons</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fn/jt/bb/fnjtbbmz1sikuctkwsxxkmih7vc.png"><br><br>  L'option la plus obscure est d.  Il s'av√®re √™tre vrai.  Il s'est av√©r√© que les articles disparaissent simplement de la collection d'articles, et non du d√©but ou de la fin, mais seulement au milieu.  Pourquoi? <br><br>  Le probl√®me de la d√©structuration est qu'en raison de la d√©l√©gation, toutes les collections de Kotlin sont √©galement <br>  ont leur propre option de d√©structuration.  Je peux √©crire val (I, j) = listOf (1, 2), et obtenir ces 1 et 2 en variables, c'est-√†-dire que List a impl√©ment√© les fonctions component1 () et <br>  component2 (). <br><br>  La classe de donn√©es a √©galement component1 () et component2 ().  Mais puisque le deuxi√®me composant dans ce cas est priv√©, celui qui est public √† List l'emporte, donc le deuxi√®me √©l√©ment est tir√© de List, et nous arrivons ici 2. La morale est tr√®s simple: ne faites pas cela, ne faites pas cela. <br></div></div><br><h2>  Pazzler num√©ro 12 </h2><br>  Le prochain casse-t√™te est tr√®s effrayant.  C'est une personne soumise qui est en quelque sorte li√©e √† Kotlin, donc il sait ce qu'il √©crit. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Any?.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asGeneric</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? T <span class="hljs-number"><span class="hljs-number">42</span></span>.asGeneric&lt;<span class="hljs-built_in"><span class="hljs-built_in">Nothing</span></span>&gt;()!!!! <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-number"><span class="hljs-number">87</span></span> println(a)</code> </pre><br>  Nous avons une fonction d'extension sur Any nullable, c'est-√†-dire qu'elle peut √™tre appliqu√©e √† n'importe quoi.  C'est une fonctionnalit√© tr√®s utile.  S'il n'est pas d√©j√† dans votre projet, cela vaut la peine d'√™tre ajout√©, car il peut mettre tout ce que vous voulez dans n'importe quoi.  Ensuite, nous prenons 42 et le jetons dans Nothing. <br><br>  Eh bien, si nous voulons √™tre s√ªrs d'avoir fait quelque chose d'important, nous pouvons le faire √† la place !!!  √©crire !!!!, le compilateur Kotlin vous permet de faire ceci: si vous manquez deux points d'exclamation, √©crivez au moins vingt-six. <br><br>  Ensuite, nous faisons si (vrai), et puis moi-m√™me je ne comprends rien ... Choisissons imm√©diatement ce qui se passe. <br><br>  a) 87 <br>  b) Kotlin.Unit <br>  c) Exception ClassCastException <br>  d) Non compil√© <br><br><div class="spoiler">  <b class="spoiler_title">Regarder</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/_t/g7/l-/_tg7l-vw0wze-y2vu_dix7cnvni.png"><br><br>  Il est tr√®s difficile de donner une explication logique.  Tr√®s probablement, l'unit√© ici est due au fait qu'il n'y a plus rien √† pousser l√†-bas.  Ce code n'est pas valide, mais il fonctionne car nous avons utilis√© Nothing.  Nous avons t√©l√©charg√© quelque chose dans Nothing, et il s'agit d'un type sp√©cial qui indique au compilateur qu'une instance de ce type ne doit jamais appara√Ætre.  Le compilateur sait que s'il y a la possibilit√© de l'apparition de Nothing, ce qui est impossible par d√©finition, alors vous ne pouvez pas v√©rifier plus loin, c'est une situation impossible. <br><br>  Tr√®s probablement, c'est un bug dans le compilateur, l'√©quipe JetBrains a m√™me dit que peut-√™tre ce bug sera corrig√© un jour, ce n'est pas tr√®s prioritaire.  L'astuce est que nous avons tromp√© le compilateur ici √† cause de cette distribution.  Si vous supprimez la ligne 42.asGeneric &lt;Rien&gt; () !!!  et arr√™tez de tricher, le code arr√™tera de compiler.  Et si nous partons, le compilateur devient fou, pense que c'est une expression impossible, et bourre tout ce qui s'y trouve. <br><br>  Je comprends cela.  Peut-√™tre qu'un jour l'expliquera mieux. <br><br></div></div><br><h2>  Pazzler num√©ro 13 </h2><br>  Nous avons une fonctionnalit√© tr√®s int√©ressante.  Vous pouvez utiliser l'injection de d√©pendance, ou vous pouvez vous en passer, cr√©er des singletones via un objet et ex√©cuter votre programme √† la perfection.  Pourquoi avez-vous besoin de Koin, Dagger ou quelque chose?  Les tests, cependant, seront difficiles. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any?) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = javaClass.simpleName } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> B : A(C) <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> C : A(B) println(Bx) println(Cx)</code> </pre><br>  Nous avons une classe A ouverte √† l'h√©ritage, elle prend quelque chose en elle-m√™me, nous cr√©ons deux objets, un singleton, B et C, tous deux h√©ritent de A et se transmettent.  Autrement dit, un excellent cycle se forme.  Ensuite, nous imprimons ce que B et C ont obtenu. <br><br>  a) nul;  nul <br>  b) C;  nul <br>  c) ExceptionInInitializerError <br>  d) Non compil√© <br><br><div class="spoiler">  <b class="spoiler_title">Nous lan√ßons</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/lf/ic/tc/lfictczohzri2l2os2w5xpypbfw.png"><br><br>  L'option correcte est C;  nul <br><br>  On pourrait penser que lorsque le premier objet est initialis√©, le second n'est pas encore l√†.  Mais, lorsque nous en d√©duisons, C manque de B. Autrement dit, l'ordre inverse est obtenu: pour une raison quelconque, le compilateur a d√©cid√© d'initialiser C en premier, puis il a initialis√© B avec C. Cela semble illogique, il serait logique, au contraire, nul ;  B. <br><br>  Mais le compilateur a essay√© de faire quelque chose, il n‚Äôa pas r√©ussi, il a laiss√© nul l√† et a d√©cid√© de ne rien nous jeter.  √áa pourrait √™tre comme √ßa aussi. <br><br>  Le cas √©ch√©ant?  dans le type de param√®tre, supprimer?, cela ne fonctionnera pas. <br><br><img src="https://habrastorage.org/webt/re/mh/6n/remh6n7bggwrm2ig962qbh1uvlu.png"><br><br>  Nous pouvons dire au compilateur que lorsque null a √©t√© r√©solu, il a essay√©, mais a √©chou√©, mais quoi?  non, il nous jette une exception qu'il est impossible de faire un cycle. <br></div></div><br><h2>  Pazzler ‚Ññ14 </h2><br>  La version 1.3 a publi√© de superbes nouvelles coroutines dans Kotlin.  J'ai longtemps r√©fl√©chi √† la mani√®re de trouver un casse-t√™te sur la corutine, afin que quelqu'un puisse le comprendre.  Je pense que pour certaines personnes, tout code avec des coroutines est un casse-t√™te. <br><br>  Dans la version 1.3, certains noms de fonction ont chang√©, comme dans la version 1.2 de l'API exp√©rimentale.  Par exemple, buildSequence () est renomm√© simplement sequence ().  Autrement dit, nous pouvons faire d'excellentes s√©quences avec la fonction de rendement, des boucles infinies, puis nous pouvons essayer de tirer quelque chose de cette s√©quence. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> coroutines.yieldNoOne <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = sequence { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) yield(n++) } println(x.take(<span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre><br>  Ils ont dit avec des coroutines que toutes les primitives sympas qui sont dans d'autres langages, comme le rendement, peuvent √™tre faites comme des fonctions de biblioth√®que, parce que le rendement est une fonction de suspension qui peut √™tre interrompue. <br><br>  Que va-t-il se passer? <br><br>  a) [1, 2, 3] <br>  b) [0, 1, 2] <br>  c) Boucle infinie <br>  d) Aucune de ces r√©ponses <br><br><div class="spoiler">  <b class="spoiler_title">Lancez!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/dh/p2/s3/dhp2s3ugmoll1vijctjtmlxgmtm.png"><br><br>  L'option correcte est la derni√®re. <br><br>  La s√©quence est un engin paresseux, et quand on s'y accroche, elle est aussi paresseuse.  Mais si vous ajoutez toList, il affichera vraiment [0, 1, 2]. <br><br>  La bonne r√©ponse n'est pas du tout li√©e aux coroutines.  Les coroutines fonctionnent vraiment, elles sont faciles √† utiliser.  Pour la fonction s√©quence et rendement, vous n'avez m√™me pas besoin de connecter une biblioth√®que avec des coroutines, tout est d√©j√† dans la biblioth√®que standard. <br></div></div><br><h2>  Pazzler ‚Ññ15 </h2><br>  Ce casse-t√™te est √©galement ma√Ætris√© par le d√©veloppeur de JetBrains.  Il y a un tel code infernal: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> whatAmI = {-&gt;}.<span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> Function&lt;*&gt;.(){}() println(whatAmI)</code> </pre><br>  Quand je l'ai vu pour la premi√®re fois, pendant KotlinConf, je ne pouvais pas dormir, j'ai essay√© de comprendre ce que c'√©tait.  Un tel code cryptique peut √™tre √©crit dans Kotlin, donc si quelqu'un pensait que Scalaz √©tait effrayant, alors dans Kotlin c'est √©galement possible. <br><br>  Imaginons: <br><br>  a) Kotlin.Unit <br>  b) Kotlin.Rien <br>  c) Non compil√© <br>  d) Aucune de ces r√©ponses <br><br><div class="spoiler">  <b class="spoiler_title">Courons</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fk/xy/o_/fkxyo_vljbjpo9gv1lak7ubr_1a.png"><br><br>  Nous avons obtenu une unit√© qui est venue de nulle part. <br><br>  Pourquoi?  Nous attribuons d'abord la variable lambda: {-&gt;} - c'est un code valide, vous pouvez √©crire un lambda vide.  Il n'a pas de param√®tres, il ne renvoie rien.  En cons√©quence, il renvoie Unit. <br><br>  Nous attribuons un lambda √† la variable et √©crivons imm√©diatement l'extension √† ce lambda, puis l'ex√©cutons.  En fait, il r√©servera simplement Kotlin.Unit. <br><br>  Ensuite, sur cette lambda, vous pouvez √©crire une fonction d'extension: <br><br><pre> <code class="kotlin hljs">.<span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> Function&lt;*&gt;.(){}</code> </pre><br>  Il est d√©clar√© sur le type Function &lt;*&gt;, et ce que nous avons en haut lui convient √©galement.  En fait, c'est Function &lt;Unit&gt;, mais je n'ai pas √©crit Unit que ce n'√©tait pas clair.  Savez-vous comment fonctionne un ast√©risque dans Kotlin?     ,    Java.    ,    . <br><br>     ,    Unit  {},      ,  void-. ,   ,  .  -,      ‚Äî   . <br></div></div><br>    .    ,  Kotlin ‚Äî  .   iOS-     ,    ,   Kotlin   ! <br><blockquote>       Mobius,  :  <b>Mobius</b>  <b>22-23   </b> .   Kotlin    ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ¬´Coroutining Android Apps¬ª        .        ( Android,   iOS),      ‚Äî  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,   <b>1 </b>   . <br><br>  :     ,            ‚Äî  <b>6 </b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>  . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440974/">https://habr.com/ru/post/fr440974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440958/index.html">Comment j'ai essay√© de corriger une recherche de carte pour les pilotes. 2e partie</a></li>
<li><a href="../fr440960/index.html">Orange Pi 2G-IOT: carte du champ de mines</a></li>
<li><a href="../fr440962/index.html">Les fournisseurs de communication vont obliger √† conclure des contrats pour la connexion de b√¢timents r√©sidentiels</a></li>
<li><a href="../fr440966/index.html">Connexion des capteurs KELLER √† MATLAB</a></li>
<li><a href="../fr440972/index.html">L'Universit√© Innopolis accueillera la premi√®re √©cole internationale de conception de v√©hicules autonomes de Russie</a></li>
<li><a href="../fr440976/index.html">J'ai scann√© toute l'Autriche et trouv√© ...</a></li>
<li><a href="../fr440978/index.html">Thermostat d'ambiance programmable sans fil Wi-Fi avec moniteur de qualit√© de l'air et autres fonctionnalit√©s utiles</a></li>
<li><a href="../fr440980/index.html">Quels cadeaux attendent les hommes le 23 f√©vrier? R√©sultats de l'enqu√™te</a></li>
<li><a href="../fr440984/index.html">Comment la r√©duction du taux d'acquisition nous affectera (titulaires de carte) - 2</a></li>
<li><a href="../fr440986/index.html">Locomotives: ce que nous savons sur les wagons automoteurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>