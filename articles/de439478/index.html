<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏻 👩🏼‍🎤 🧜🏿 Unterhaltsames C #. Fünf Beispiele für Kaffeepausen 🌛 👎🏻 📨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nachdem wir bereits mehr als einen Artikel über die Veeam Academy geschrieben haben , haben wir beschlossen, eine kleine interne Küche zu eröffnen und...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unterhaltsames C #. Fünf Beispiele für Kaffeepausen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/439478/">  Nachdem wir bereits mehr als einen Artikel über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Veeam Academy geschrieben haben</a> , haben wir beschlossen, eine kleine interne Küche zu eröffnen und Ihnen einige Beispiele in C # anzubieten, die wir mit unseren Schülern analysieren.  Bei der Zusammenstellung haben wir uns von der Tatsache leiten lassen, dass unser Publikum unerfahrene Entwickler sind, aber es kann auch für erfahrene Programmierer interessant sein, unter die Katze zu schauen.  Unser Ziel ist es zu zeigen, wie tief das Kaninchenloch ist, und gleichzeitig die Merkmale der internen Struktur von C # zu erklären. <br><br>  Auf der anderen Seite freuen wir uns über Kommentare von erfahrenen Kollegen, die entweder auf Mängel in unseren Beispielen hinweisen oder ihre eigenen teilen.  Sie verwenden solche Fragen gerne bei Interviews, also haben wir alle sicher etwas zu erzählen. <br><br>  Wir hoffen, dass unsere Auswahl für Sie nützlich ist, Ihnen hilft, Ihr Wissen aufzufrischen oder einfach nur zu lächeln. <br><br><img src="https://habrastorage.org/webt/wm/5l/4q/wm5l4qgp5-jl50kt_2oswu4tyu8.jpeg" alt="Bild"><br><a name="habracut"></a><br><h4>  Beispiel 1 </h4><br>  Strukturen in C #.  Mit ihnen haben selbst erfahrene Entwickler oft Fragen, die so oft von allen Arten von Online-Tests verwendet werden. <br><br>  Unser erstes Beispiel ist ein Beispiel für Achtsamkeit und Wissen darüber, wohin sich der using-Block ausdehnt.  Und auch ein ziemliches Thema für die Kommunikation während des Interviews. <br><br>  Betrachten Sie den Code: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> SDummy : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _dispose; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _dispose = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _dispose; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SDummy(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (d) { Console.WriteLine(d.GetDispose()); } Console.WriteLine(d.GetDispose()); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Was wird die Hauptmethode auf der Konsole drucken?</b> <div class="spoiler_text">  Beachten Sie, dass SDummy eine Struktur ist, die die IDisposable-Schnittstelle implementiert, sodass Variablen vom Typ SDummy im using-Block verwendet werden können. <br><br>  Gemäß <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der C # -Sprachenspezifikation wird die</a> Verwendung der Anweisung für signifikante Typen zur Kompilierungszeit zu einem Try-finally-Block erweitert: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Console.WriteLine(d.GetDispose()); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { ((IDisposable)d).Dispose(); }</code> </pre><br>  In unserem Code wird die GetDispose () -Methode innerhalb des using-Blocks aufgerufen, der das Boolesche Feld _dispose zurückgibt, dessen Wert noch nicht für das d-Objekt festgelegt wurde (es wird nur in der Dispose () -Methode festgelegt, die noch nicht aufgerufen wurde), und daher wird der Wert zurückgegeben Der Standardwert ist False.  Was weiter? <br><br>  Und dann das interessanteste. <br>  Eine Zeile in einem finally-Block ausführen <br><pre> <code class="cs hljs"> ((IDisposable)d).Dispose();</code> </pre><br>  führt normalerweise zum Boxen.  Dies ist beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> nicht schwer zu erkennen (wählen Sie oben rechts in den Ergebnissen zuerst C # und dann IL aus): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4p/b5/ix/4pb5ixpt4bwwwgrgiqeopcstdsg.jpeg" alt="Bild" width="80%"></div><br>  In diesem Fall wird die Dispose-Methode bereits für ein anderes Objekt und überhaupt nicht für das d-Objekt aufgerufen. <br>  Führen Sie unser Programm aus und stellen Sie sicher, dass das Programm auf der Konsole wirklich "False False" anzeigt.  Aber ist es so einfach?  :) :) <br><br>  In der Tat passiert keine Verpackung.  Was laut Eric Lippert zur Optimierung getan wird (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ). <br>  Aber wenn es keine Verpackung gibt (was an sich überraschend erscheinen mag), warum wird auf dem Bildschirm "Falsch Falsch" und nicht "Falsch Richtig" angezeigt, da "Entsorgen" jetzt auf dasselbe Objekt angewendet werden sollte?!? <br><br>  Und hier nicht dazu! <br>  Schauen Sie sich an, worauf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C # -Compiler</a> unser Programm erweitert: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> SDummy : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _dispose; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _dispose = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _dispose; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { SDummy sDummy = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(SDummy); SDummy sDummy2 = sDummy; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Console.WriteLine(sDummy.GetDispose()); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { ((IDisposable)sDummy2).Dispose(); } Console.WriteLine(sDummy.GetDispose()); } }</code> </pre><br><br>  Es gibt eine neue Variable sDummy2, auf die die Dispose () -Methode angewendet wird! <br>  Woher kommt diese versteckte Variable? <br>  Wenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wir uns noch einmal</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation zu</a> : <br><blockquote>  Eine using-Anweisung der Form 'using (Ausdrucks-) Anweisung' hat die gleichen drei möglichen Erweiterungen.  In diesem Fall ist ResourceType implizit der Typ zur Kompilierungszeit des Ausdrucks ... Die Variable 'resource' ist in der eingebetteten Anweisung nicht zugänglich und für sie unsichtbar. <br></blockquote><br>  T.O.  Die sDummy-Variable ist unsichtbar und für die eingebettete Anweisung des using-Blocks nicht zugänglich. Alle Operationen in diesem Ausdruck werden mit einer anderen sDummy2-Variablen ausgeführt. <br><br>  Infolgedessen gibt die Main-Methode "False False" und nicht "False True" an die Konsole aus, wie viele derjenigen, die dieses Beispiel zum ersten Mal angetroffen haben, glauben.  Beachten Sie in diesem Fall, dass keine Verpackung vorhanden ist, sondern eine zusätzliche versteckte Variable erstellt wird. <br><br>  Die allgemeine Schlussfolgerung lautet: Veränderliche Werttypen sind böse, die am besten vermieden werden. <br><br>  Ein ähnliches Beispiel wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier betrachtet</a> .  Wenn das Thema interessant ist, empfehlen wir einen Blick. <br><br>  Ich möchte mich ganz besonders bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">SergeyT</a> für wertvolle Kommentare zu diesem Beispiel bedanken. <br><br></div></div><br><br><h4>  Beispiel 2 </h4><br>  Konstruktoren und die Reihenfolge ihrer Aufrufe sind eines der Hauptthemen jeder objektorientierten Programmiersprache.  Manchmal kann eine solche Folge von Aufrufen das Programm im unerwartetsten Moment überraschen und, noch schlimmer, sogar „ausfüllen“. <br><br>  Betrachten Sie also die MyLogger-Klasse: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyLogger</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> MyLogger innerInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyLogger(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyLogger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Static Logger Constructor"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyLogger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Instance Logger Constructor"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> MyLogger Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> innerInstance; } } }</code> </pre><br>  Angenommen, diese Klasse verfügt über eine Geschäftslogik, die wir zur Unterstützung der Protokollierung benötigen (die Funktionalität ist derzeit nicht so wichtig). <br><br>  Mal sehen, was in unserer MyLogger-Klasse ist: <br><br><ol><li>  Statischer Konstruktor angegeben </li><li>  Es gibt einen privaten Konstruktor ohne Parameter </li><li>  Geschlossene statische Variable innerInstance definiert </li><li>  Und es gibt eine offene statische Eigenschaft von Instance für die Kommunikation mit der Außenwelt </li></ol><br>  Um die Analyse dieses Beispiels zu vereinfachen, haben wir den Konstruktoren der Klasse eine einfache Konsolenausgabe hinzugefügt. <br><br>  Außerhalb der Klasse (ohne Tricks wie Reflektion) können wir nur die öffentliche statische Instanzeigenschaft verwenden, die wir folgendermaßen aufrufen können: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger = MyLogger.Instance; } }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Was wird dieses Programm ausgeben?</b> <div class="spoiler_text">  Wir alle wissen, dass ein statischer Konstruktor aufgerufen wird, bevor auf ein Mitglied der Klasse zugegriffen wird (mit Ausnahme von Konstanten).  In diesem Fall wird es nur einmal innerhalb der Anwendungsdomäne gestartet. <br><br>  In unserem Fall wenden wir uns dem Klassenmitglied zu - der Instance-Eigenschaft, die dazu führen sollte, dass der statische Konstruktor zuerst gestartet wird, und dann wird der Konstruktor der Klasseninstanz aufgerufen.  Das heißt,  Das Programm gibt Folgendes aus: <br><br>  <b>Statischer Logger-Konstruktor</b> <b><br></b>  <b>Instanzlogger-Konstruktor</b> <b><br></b> <br><br>  Nach dem Starten des Programms gelangen wir jedoch auf die Konsole: <br><br>  <b>Instanzlogger-Konstruktor</b> <b><br></b>  <b>Statischer Logger-Konstruktor</b> <b><br></b> <br><br>  Wie so?  Instanzkonstruktor arbeitete vor dem statischen Konstruktor?!? <br>  Antwort: Ja! <br><br>  Und hier ist warum. <br><br>  Der C # ECMA-334-Standard gibt für statische Klassen Folgendes an: <br><br>  <i>17.4.5.1: „Wenn in der Klasse ein statischer Konstruktor (§17.11) vorhanden ist, erfolgt die Ausführung der statischen Feldinitialisierer unmittelbar vor der Ausführung dieses statischen Konstruktors.</i> <i><br></i>  <i>...</i> <i><br></i>  <i>17.11: ... Wenn eine Klasse statische Felder mit Initialisierern enthält, werden diese Initialisierer unmittelbar vor der Ausführung des statischen Konstruktors in Textreihenfolge ausgeführt</i> <br><br>  (Was in einer freien Übersetzung bedeutet: Wenn die Klasse einen statischen Konstruktor enthält, beginnt die Initialisierung der statischen Felder sofort, BEVOR der statische Konstruktor startet. <br>  ... <br>  Wenn die Klasse statische Felder mit Initialisierern enthält, werden diese Initialisierer in der Reihenfolge im Programmtext gestartet, BEVOR der statische Konstruktor ausgeführt wird.) <br><br>  In unserem Fall wird das statische Feld innerInstance zusammen mit dem Initialisierer deklariert, der der Konstruktor der Klasseninstanz ist.  Gemäß dem ECMA-Standard muss der Initialisierer aufgerufen werden, bevor der statische Konstruktor aufgerufen wird.  Was in unserem Programm passiert: Der Instanzkonstruktor, der der Initialisierer des statischen Feldes ist, wird VOR dem statischen Konstruktor aufgerufen.  Stimmen Sie ganz unerwartet zu. <br><br>  Beachten Sie, dass dies nur für statische Feldinitialisierer gilt.  Im Allgemeinen wird ein statischer Konstruktor aufgerufen, BEVOR der Konstruktor der Klasseninstanz aufgerufen wird. <br><br>  Wie zum Beispiel hier: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyLogger</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyLogger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Static Logger Constructor"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyLogger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Instance Logger Constructor"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyLogger(); } }</code> </pre><br>  Das Programm wird voraussichtlich auf der Konsole ausgegeben: <br><br>  <b>Statischer Logger-Konstruktor</b> <b><br></b>  <b>Instanzlogger-Konstruktor</b> <b><br></b> <br></div></div><br><img src="https://habrastorage.org/webt/zr/ee/h3/zreeh3h-fqruztz8hdljydmzl1q.jpeg" alt="Bild"><br><br><h4>  Beispiel 3 </h4><br>  Programmierer müssen häufig Hilfsfunktionen (Dienstprogramme, Helfer usw.) schreiben, um ihr Leben zu erleichtern.  Typischerweise sind solche Funktionen recht einfach und benötigen oft nur wenige Codezeilen.  Aber Sie können sogar aus heiterem Himmel stolpern. <br><br>  Angenommen, wir müssen eine Funktion implementieren, die die Zahl auf Ungerade prüft (d. H. Dass die Zahl ohne Rest nicht durch 2 teilbar ist). <br><br>  Eine Implementierung könnte folgendermaßen aussehen: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isOddNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (i % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Auf den ersten Blick ist alles in Ordnung und zum Beispiel für die Zahlen 5.7 und 11 werden wir voraussichtlich wahr. <br><br><div class="spoiler">  <b class="spoiler_title">Was gibt die Funktion isOddNumber (-5) zurück?</b> <div class="spoiler_text">  -5 ist eine ungerade Zahl, aber als Antwort auf unsere Funktion erhalten wir False! <br>  Lassen Sie uns herausfinden, was der Grund ist. <br><br>  Laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MSDN</a> wird über den Rest des% Division-Operators Folgendes geschrieben: <br>  "Für ganzzahlige Operanden ist das Ergebnis von a% b der Wert, der durch a - (a / b) * b erzeugt wird." <br>  In unserem Fall erhalten wir für a = -5, b = 2: <br>  -5% 2 = (-5) - ((-5) / 2) * 2 = -5 + 4 = -1 <br>  Aber -1 ist immer nicht gleich 1, was unser Ergebnis False erklärt. <br><br>  Der% -Operator reagiert empfindlich auf das Vorzeichen von Operanden.  Um solche „Überraschungen“ nicht zu erhalten, ist es daher besser, das Ergebnis mit Null zu vergleichen, die kein Vorzeichen hat: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isOddNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (i % <span class="hljs-number"><span class="hljs-number">2</span></span> != <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br>  Oder Sie erhalten eine separate Funktion zum Überprüfen der Parität und zum Implementieren der Logik: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEvenNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (i % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isOddNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !isEvenNumber(i); }</code> </pre><br></div></div><br><h4>  Beispiel 4 </h4><br>  Jeder, der in C # programmiert hat, hat sich wahrscheinlich mit LINQ getroffen, was so praktisch ist, um mit Sammlungen zu arbeiten, Abfragen zu erstellen, Daten zu filtern und zu aggregieren ... <br><br>  Wir werden nicht unter die Haube von LINQ schauen.  Vielleicht machen wir es ein anderes Mal. <br><br>  Betrachten Sie in der Zwischenzeit ein kleines Beispiel: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] dataArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> summResult = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> selectedData = dataArray.Select( x =&gt; { summResult += x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }); Console.WriteLine(summResult);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Was wird dieser Code ausgeben?</b> <div class="spoiler_text">  Wir erhalten auf dem Bildschirm den Wert der Variablen summResult, der gleich dem Anfangswert ist, d.h.  0. <br><br>  Warum ist das passiert? <br><br>  Und weil die Definition einer LINQ-Abfrage und der Start dieser Abfrage zwei Operationen sind, die separat ausgeführt werden.  Daher bedeutet die Definition einer Anforderung nicht deren Start / Ausführung. <br><br>  Die Variable summResult wird in einem anonymen Delegaten in der Select-Methode verwendet: Elemente des dataArray-Arrays werden nacheinander sortiert und der Variablen summResult hinzugefügt. <br><br>  Wir können davon ausgehen, dass unser Code die Summe der Elemente des dataArray-Arrays druckt.  Aber LINQ funktioniert nicht so. <br><br>  Betrachten Sie die Variable selectedData.  Das Schlüsselwort var lautet "syntaktischer Zucker", was in vielen Fällen die Größe des Programmcodes verringert und dessen Lesbarkeit verbessert.  Der reale Typ der Variable selectedData implementiert die IEnumerable-Schnittstelle.  Das heißt,  Unser Code sieht folgendermaßen aus: <br><br><pre> <code class="cs hljs"> IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; selectedData = dataArray.Select( x =&gt; { summResult += x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; });</code> </pre><br>  Hier definieren wir die Abfrage (Abfrage), aber die Abfrage selbst startet nicht.  Auf ähnliche Weise können Sie mit der Datenbank arbeiten, indem Sie die SQL-Abfrage als Zeichenfolge angeben. Um das Ergebnis zu erhalten, beziehen Sie sich auf die Datenbank und führen Sie diese Abfrage explizit aus. <br><br>  Das heißt, wir haben bisher nur eine Anfrage gestellt, diese aber nicht gestartet.  Aus diesem Grund bleibt der Wert der Variablen summResult unverändert.  Eine Abfrage kann beispielsweise mit den Methoden ToArray, ToList oder ToDictionary gestartet werden: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] dataArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> summResult = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//        selectedData IEnumerable&lt;int&gt; selectedData = dataArray.Select( x =&gt; { summResult += x; return x; }); //   selectedData selectedData.ToArray(); //    summResult Console.WriteLine(summResult);</span></span></code> </pre><br>  Dieser Code zeigt bereits den Wert der Variablen summResult an, der der Summe aller Elemente des dataArray-Arrays entspricht und 15 entspricht. <br><br>  Wir haben es herausgefunden.  Und was wird dieses Programm dann auf dem Bildschirm anzeigen? <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] dataArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//1 var summResult = dataArray.Sum() + dataArray.Skip(3).Take(2).Sum(); //2 var groupedData = dataArray.GroupBy(x =&gt; x).Select( //3 x =&gt; { summResult += x.Key; return x.Key; }); Console.WriteLine(summResult); //4</span></span></code> </pre><br>  Die Variable groupedData (Zeile 3) implementiert tatsächlich die IEnumerable-Schnittstelle und definiert im Wesentlichen die Anforderung an die dataArray-Datenquelle.  Dies bedeutet, dass diese Anforderung explizit ausgeführt werden muss, damit ein anonymer Delegat arbeitet, der den Wert der Variablen summResult ändert.  Es gibt jedoch keinen solchen Start in unserem Programm.  Daher wird der Wert der Variablen summResult nur in Zeile 2 geändert, und wir können bei unseren Berechnungen nicht alles andere berücksichtigen. <br><br>  Dann ist es einfach, den Wert der Variablen summResult zu berechnen, der jeweils 15 + 7 beträgt, d.h.  22. <br></div></div><br><h4>  Beispiel 5 </h4><br>  Sagen wir gleich - wir betrachten dieses Beispiel bei unseren Vorlesungen an der Akademie nicht, aber manchmal diskutieren wir es während der Kaffeepausen eher als Scherz. <br><br>  Trotz der Tatsache, dass dies unter dem Gesichtspunkt der Bestimmung des Entwicklerniveaus kaum bezeichnend ist, haben wir dieses Beispiel in mehreren verschiedenen Tests getroffen.  Vielleicht wird es aus Gründen der Vielseitigkeit verwendet, da es in C und C ++ sowie in C # und Java gleich funktioniert. <br><br>  Lassen Sie es also eine Codezeile geben: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)+(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)-(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)+(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Was ist der Wert der Variablen i?</b> <div class="spoiler_text">  Antwort: 1 <br><br>  Sie könnten denken, dass hier numerische Arithmetik über die Größen jedes Typs in Bytes verwendet wird, da die Zeichen "+" und "-" hier für die Typkonvertierung eher unerwartet auftreten. <br><br>  In C # ist bekannt, dass der Integer-Typ 4 Bytes lang, 8 Byte lang und char 2 ist. <br><br>  Dann ist es leicht zu glauben, dass unsere Codezeile dem folgenden arithmetischen Ausdruck entspricht: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = (<span class="hljs-number"><span class="hljs-number">4</span></span>)+(<span class="hljs-number"><span class="hljs-number">2</span></span>)-(<span class="hljs-number"><span class="hljs-number">4</span></span>)+(<span class="hljs-number"><span class="hljs-number">8</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre><br>  Dies ist jedoch nicht so.  Und um durch solch eine falsche Argumentation zu verwirren und zu lenken, kann das Beispiel zum Beispiel folgendermaßen geändert werden: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)+(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)-(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)+(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)-<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>);</code> </pre><br>  Die Zeichen "+" und "-" werden in diesem Beispiel nicht als binäre arithmetische Operationen verwendet, sondern als unäre Operatoren.  Dann ist unsere Codezeile nur eine Folge von expliziten Typkonvertierungen, gemischt mit Aufrufen unärer Operationen, die wie folgt geschrieben werden können: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)( <span class="hljs-comment"><span class="hljs-comment">// call explicit operator int(char), ie char to int +( // call unary operator + (char)( // call explicit operator char(int), ie int to char -( // call unary operator - (int)( // call explicit operator int(long), ie long to int +( // call unary operator + (long)( // call explicit operator long(int), ie int to long -1 ) ) ) ) ) ) );</span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/webt/0a/wm/vn/0awmvncxvmyw1jzjgc_uavq8rf8.jpeg" alt="Bild"><br><br><h3>  Interessiert an Lernen an der Veeam Academy? </h3><br>  Jetzt gibt es ein Set für frühlingsintensive C # in St. Petersburg, und wir laden alle ein, sich auf der Website der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Veeam Academy</a> Online-Tests zu unterziehen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> <br><br>  Der Kurs beginnt am 18. Februar 2019, dauert bis Mitte Mai und ist wie immer völlig kostenlos.  Die Registrierung für alle, die sich einem Eingangstest unterziehen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">möchten,</a> ist bereits auf der Website der Akademie verfügbar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">akademy.veeam.ru</a> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vg/k6/ol/vgk6olkeyayj8hqamzvva75ycrk.jpeg" alt="Bild" width="50%"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439478/">https://habr.com/ru/post/de439478/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439466/index.html">Die Mondumlaufsonde der NASA machte die ersten Bilder der chinesischen Chang'e-4-Station - zwei Pixel Licht</a></li>
<li><a href="../de439468/index.html">Wohin die Suche nach dem perfekten SCADA führt</a></li>
<li><a href="../de439470/index.html">Deutschland plant, die Kohle in naher Zukunft aufzugeben</a></li>
<li><a href="../de439472/index.html">Automatisierung der Grenzkontrolle innerhalb des Unternehmens</a></li>
<li><a href="../de439476/index.html">Cockney Slang: moderne Geschichte und sozialer Status</a></li>
<li><a href="../de439480/index.html">Nachgeben oder warum verlangsamt sich Ihr CRM (und CRM)?</a></li>
<li><a href="../de439482/index.html">devleads - (un) finanzielle Motivation</a></li>
<li><a href="../de439484/index.html">Abrufen von Aufzählungsdaten in einer Automapper-Perspektive</a></li>
<li><a href="../de439486/index.html">.NET-Referenztypen im Vergleich zu Werttypen. Teil 1</a></li>
<li><a href="../de439488/index.html">QA Meetup Videoaufzeichnung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>