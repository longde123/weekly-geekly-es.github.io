<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∑üèª üë¨ üê™ Anda tidak bisa hanya mengambil dan menulis PILIH jika vendor tidak mengizinkannya ... tetapi kami akan menulis üëßüèº üñêüèæ üëâüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR: GitHub: // PastorGL / AQLSelectEx . 





 Sekali, bukan di musim dingin, tetapi sudah di musim dingin, dan khususnya beberapa bulan yang lalu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anda tidak bisa hanya mengambil dan menulis PILIH jika vendor tidak mengizinkannya ... tetapi kami akan menulis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435902/"><p>  TL; DR: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub: // PastorGL / AQLSelectEx</a> . </p><br><p><img src="https://habrastorage.org/webt/lk/ke/y2/lkkey2_mk3a-rbhftk9jja_vlyw.png" alt="Aerospike AQL SELECT"></p><br><p>  Sekali, bukan di musim dingin, tetapi sudah di musim dingin, dan khususnya beberapa bulan yang lalu, untuk proyek yang sedang saya kerjakan (sesuatu yang berbasis Geospasial berdasarkan Big Data), saya membutuhkan penyimpanan NoSQL / Nilai-Kunci yang cepat. </p><br><p> Kami mengunyah terabyte kode sumber dengan bantuan Apache Spark, tetapi hasil akhir perhitungan, runtuh ke jumlah yang konyol (hanya jutaan catatan), perlu disimpan di suatu tempat.  Dan sangat diinginkan untuk menyimpan sedemikian rupa sehingga dapat dengan cepat ditemukan dan dikirim menggunakan metadata yang terkait dengan setiap baris hasil (ini adalah satu digit) (tetapi ada cukup banyak dari mereka). </p><a name="habracut"></a><br><p>  Format tumpukan Khadupov dalam hal ini tidak banyak berguna, dan database relasional pada jutaan catatan melambat, dan set metadata tidak begitu tetap sehingga cocok dengan skema kaku dari RDBMS - PostgreSQL biasa dalam kasus kami.  Tidak, ini biasanya mendukung JSON, tetapi masih memiliki masalah dengan indeks pada jutaan rekaman.  Indeks membengkak, menjadi perlu untuk mempartisi tabel, dan kerepotan dengan administrasi dimulai nafig-nafig. </p><br><p>  Secara historis, MongoDB digunakan sebagai NoSQL pada proyek, tetapi seiring berjalannya waktu, monga menunjukkan dirinya semakin buruk (terutama dalam hal stabilitas), sehingga secara bertahap dinonaktifkan.  Pencarian cepat untuk alternatif yang lebih modern, lebih cepat, kurang buggy, dan umumnya lebih baik mengarah ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aerospike</a> .  Banyak pria berkepala besar mendukungnya, dan saya memutuskan untuk memeriksanya. </p><br><p>  Tes menunjukkan bahwa, pada kenyataannya, data disimpan dalam cerita langsung dari pekerjaan Spark dengan peluit, dan pencarian dalam jutaan catatan jauh lebih cepat daripada di mong.  Dan dia makan lebih sedikit memori.  Tapi ternyata satu "tetapi."  API klien solder aero murni fungsional, dan tidak bersifat deklaratif. </p><br><p>  Untuk merekam dalam cerita, ini tidak penting, karena semua sama, semua jenis bidang dari setiap catatan yang dihasilkan harus ditentukan secara lokal dalam pekerjaan itu sendiri - dan konteksnya tidak hilang.  Gaya fungsional ada di sini, terutama karena menulis kode dengan cara yang berbeda tidak akan berhasil.  Tetapi dalam moncong web, yang seharusnya mengunggah hasilnya ke dunia luar, dan merupakan aplikasi web semi biasa, akan jauh lebih logis untuk membentuk SQL SELECT standar dari formulir pengguna, yang akan penuh dengan DAN dan ATAU - yaitu <strong>predikat</strong> , - dalam klausa WHERE. </p><br><p>  Saya akan menjelaskan perbedaannya dengan contoh sintetis: </p><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> foo, bar, baz, qux, quux <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> namespace.set <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (baz!=<span class="hljs-string"><span class="hljs-string">'a'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (foo&gt;<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (bar&lt;=<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> foo&gt;<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> quux <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'%force%'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> (qux <span class="hljs-keyword"><span class="hljs-keyword">WITHIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CAST</span></span>(<span class="hljs-string"><span class="hljs-string">'{\"type\": \"Polygon\", \"coordinates\": [0.0, 0.0],[1.0, 0.0],[1.0, 1.0],[0.0, 1.0],[0.0, 0.0]}'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> GEOJSON)</code> </pre> <br><p>  - mudah dibaca dan relatif jelas catatan mana yang ingin diterima pelanggan.  Jika Anda memasukkan permintaan seperti itu ke dalam log secara langsung, maka Anda dapat menariknya nanti untuk debugging secara manual.  Yang sangat nyaman saat mengurai segala macam situasi aneh. </p><br><p>  Sekarang mari kita lihat panggilan ke API predikat dengan gaya fungsional: </p><br><pre> <code class="java hljs">Statement reference = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Statement(); reference.setSetName(<span class="hljs-string"><span class="hljs-string">"set"</span></span>); reference.setNamespace(<span class="hljs-string"><span class="hljs-string">"namespace"</span></span>); reference.setBinNames(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>, <span class="hljs-string"><span class="hljs-string">"bar"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"qux"</span></span>, <span class="hljs-string"><span class="hljs-string">"quux"</span></span>); reference.setFillter(Filter.stringNotEqual(<span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"a"</span></span>)); reference.setPredExp(<span class="hljs-comment"><span class="hljs-comment">// 20 expressions in RPN PredExp.integerBin("foo") , PredExp.integerValue(2) , PredExp.integerGreater() , PredExp.integerBin("bar") , PredExp.integerValue(3) , PredExp.integerLessEq() , PredExp.integerBin("foo") , PredExp.integerValue(5) , PredExp.integerGreater() , PredExp.or(2) , PredExp.and(2) , PredExp.stringBin("quux") , PredExp.stringValue(".*force.*") , PredExp.stringRegex(RegexFlag.ICASE) , PredExp.and(2) , PredExp.geoJSONBin("qux") , PredExp.geoJSONValue("{\"type\": \"Polygon\", \"coordinates\": [0.0, 0.0],[1.0, 0.0],[1.0, 1.0],[0.0, 1.0],[0.0, 0.0]}") , PredExp.geoJSONWithin() , PredExp.not() , PredExp.or(2) );</span></span></code> </pre> <br><p>  Inilah dinding kode, dan bahkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">notasi Polandia terbalik</a> .  Tidak, saya mengerti bahwa mesin stack sederhana dan nyaman untuk implementasi dari sudut pandang programmer dari mesin itu sendiri, tetapi untuk puzzle dan menulis predikat di RPN dari aplikasi klien ... Saya pribadi tidak ingin memikirkan vendor, saya ingin saya sebagai konsumen API ini Itu nyaman.  Dan predikat bahkan dengan ekstensi klien vendor (secara konsep mirip dengan Java Persistence Kriteria API) tidak nyaman untuk ditulis.  Dan masih tidak ada SELECT yang dapat dibaca di log kueri. </p><br><p>  Secara umum, SQL diciptakan untuk menulis pertanyaan berbasis kriteria di dalamnya dalam bahasa burung, dekat dengan alam.  Jadi, orang bertanya-tanya, apa-apaan ini? </p><br><p>  Tunggu, ada sesuatu yang tidak beres ... Pada KDPV, apakah ada tangkapan layar dari dokumentasi resmi aerosoldering, di mana SELECT dijelaskan sepenuhnya? </p><br><p>  Ya, dijelaskan.  Itu hanya AQL - ini adalah utilitas pihak ketiga yang ditulis oleh kaki kiri belakang pada malam yang gelap, dan ditinggalkan oleh vendor tiga tahun lalu selama versi aerosoldering sebelumnya.  Ini tidak ada hubungannya dengan pustaka klien, meskipun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditulis pada katak</a> - termasuk. </p><br><p>  Versi tiga tahun lalu tidak memiliki predikat API, dan karenanya di AQL tidak ada dukungan untuk predikat, dan semua yang setelah WHERE sebenarnya adalah panggilan ke indeks (sekunder atau primer).  Yaitu, lebih dekat ke ekstensi SQL seperti USE atau WITH.  Artinya, Anda tidak bisa hanya mengambil sumber AQL, membongkar mereka menjadi suku cadang, dan menggunakannya dalam aplikasi Anda untuk panggilan predikat. </p><br><p>  Selain itu, seperti yang saya katakan, itu ditulis pada malam gelap dengan kaki kiri belakang, dan tidak mungkin untuk melihat <a href="">tata bahasa</a> ANTLR4 yang AQL mem-parsing permintaan tanpa air mata.  Ya, untuk seleraku.  Untuk beberapa alasan, saya suka ketika definisi tata bahasa deklaratif tidak dicampur dengan potongan-potongan kode katak, dan mie yang sangat keren diseduh di sana. </p><br><p>  Yah, untungnya, saya juga sepertinya tahu bagaimana melakukan ANTLR.  Benar, untuk waktu yang lama saya tidak mengambil checker, dan terakhir kali saya menulisnya di bawah versi ketiga.  Keempat - itu jauh lebih baik, karena yang ingin menulis tur AST manual, jika semuanya ditulis sebelum kita, dan ada pengunjung normal, jadi mari kita mulai. </p><br><p>  Kami menggunakan <a href="">sintaks SQLite</a> sebagai basis, dan mencoba membuang semua yang tidak perlu.  Kami hanya membutuhkan SELECT, dan tidak lebih. </p><br><pre> <code class="plaintext hljs">grammar SQLite; simple_select_stmt : ( K_WITH K_RECURSIVE? common_table_expression ( ',' common_table_expression )* )? select_core ( K_ORDER K_BY ordering_term ( ',' ordering_term )* )? ( K_LIMIT expr ( ( K_OFFSET | ',' ) expr )? )? ; select_core : K_SELECT ( K_DISTINCT | K_ALL )? result_column ( ',' result_column )* ( K_FROM ( table_or_subquery ( ',' table_or_subquery )* | join_clause ) )? ( K_WHERE expr )? ( K_GROUP K_BY expr ( ',' expr )* ( K_HAVING expr )? )? | K_VALUES '(' expr ( ',' expr )* ')' ( ',' '(' expr ( ',' expr )* ')' )* ; expr : literal_value | BIND_PARAMETER | ( ( database_name '.' )? table_name '.' )? column_name | unary_operator expr | expr '||' expr | expr ( '*' | '/' | '%' ) expr | expr ( '+' | '-' ) expr | expr ( '&lt;&lt;' | '&gt;&gt;' | '&amp;' | '|' ) expr | expr ( '&lt;' | '&lt;=' | '&gt;' | '&gt;=' ) expr | expr ( '=' | '==' | '!=' | '&lt;&gt;' | K_IS | K_IS K_NOT | K_IN | K_LIKE | K_GLOB | K_MATCH | K_REGEXP ) expr | expr K_AND expr | expr K_OR expr | function_name '(' ( K_DISTINCT? expr ( ',' expr )* | '*' )? ')' | '(' expr ')' | K_CAST '(' expr K_AS type_name ')' | expr K_COLLATE collation_name | expr K_NOT? ( K_LIKE | K_GLOB | K_REGEXP | K_MATCH ) expr ( K_ESCAPE expr )? | expr ( K_ISNULL | K_NOTNULL | K_NOT K_NULL ) | expr K_IS K_NOT? expr | expr K_NOT? K_BETWEEN expr K_AND expr | expr K_NOT? K_IN ( '(' ( select_stmt | expr ( ',' expr )* )? ')' | ( database_name '.' )? table_name ) | ( ( K_NOT )? K_EXISTS )? '(' select_stmt ')' | K_CASE expr? ( K_WHEN expr K_THEN expr )+ ( K_ELSE expr )? K_END | raise_function ;</code> </pre> <br><p>  Hmm ... Terlalu banyak untuk SELECT.  Dan jika cukup mudah untuk menyingkirkan kelebihan, maka ada satu hal buruk lagi mengenai struktur solusi yang dihasilkan. </p><br><p>  Tujuan utamanya adalah untuk menerjemahkan ke dalam predikat API dengan RPN dan mesin stack tersirat.  Dan di sini expr atom tidak berkontribusi pada transformasi semacam itu dengan cara apa pun, karena itu menyiratkan analisis normal dari kiri ke kanan.  Ya, dan didefinisikan secara rekursif. </p><br><p>  Yaitu, kita bisa mendapatkan contoh sintetis kami, tetapi itu akan dibaca persis seperti yang tertulis, dari kiri ke kanan: </p><br><pre> <code class="plaintext hljs">(foo&gt;2  (bar&lt;=3  foo&gt;5)  quux _ '%force%')  (qux _('{\"type\": \"Polygon\", \"coordinates\": [0.0, 0.0],[1.0, 0.0],[1.0, 1.0],[0.0, 1.0],[0.0, 0.0]}')</code> </pre> <br><p>  Ada tanda kurung yang menentukan prioritas parsing (yang berarti bahwa Anda perlu menjuntai bolak-balik di stack), dan juga beberapa operator berperilaku seperti panggilan fungsi. </p><br><p>  Dan kita perlu urutan ini: </p><br><pre> <code class="plaintext hljs">foo 2 &gt; bar 3 &lt;= foo 5 &gt;   quux ".*force.*" _  qux "{\"type\": \"Polygon\", \"coordinates\": [0.0, 0.0],[1.0, 0.0],[1.0, 1.0],[0.0, 1.0],[0.0, 0.0]}" _  </code> </pre> <br><p>  Brr, timah, otak yang buruk untuk membaca.  Tetapi tanpa tanda kurung, tidak ada kemunduran dan kesalahpahaman dengan urutan panggilan.  Dan bagaimana kita menerjemahkan satu ke yang lain? </p><br><p>  Dan kemudian di otak yang buruk, terjadi choc!  - Halo, ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shunting Yard</a> klasik dari banyak orang.  prof.  Dijkstra!  Biasanya, dukun okolobigdatovskimi seperti saya tidak perlu algoritma, karena kami hanya mentransfer prototipe yang sudah ditulis oleh data-satanis dari python ke katak, dan kemudian untuk kinerja solusi yang lama dan membosankan yang diperoleh dengan metode rekayasa murni (== shamanistic), dan tidak ilmiah . </p><br><p>  Tapi kemudian tiba-tiba menjadi perlu untuk mengetahui algoritma.  Atau setidaknya gagasan tentang itu.  Untungnya, tidak seluruh program universitas telah dilupakan selama beberapa tahun terakhir, dan karena saya ingat tentang mesin yang ditumpuk, saya juga dapat menggali sesuatu yang lain tentang algoritma terkait. </p><br><p>  Baiklah  Dalam tata bahasa yang dipertajam oleh Shunting Yard, SELECT di tingkat atas akan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">select_stmt : K_SELECT ( STAR | column_name ( COMMA column_name )* ) ( K_FROM from_set )? ( (K_USE | K_WITH) index_expr )? ( K_WHERE where_expr )? ; where_expr : ( atomic_expr | OPEN_PAR | CLOSE_PAR | logic_op )+ ; logic_op : K_NOT | K_AND | K_OR ; atomic_expr : column_name ( equality_op | regex_op ) STRING_LITERAL | ( column_name | meta_name ) ( equality_op | comparison_op ) NUMERIC_LITERAL | column_name map_op iter_expr | column_name list_op iter_expr | column_name geo_op cast_expr ;</code> </pre> <br><p>  Artinya, token yang sesuai dengan tanda kurung adalah signifikan, dan seharusnya tidak ada expr rekursif.  Sebaliknya, akan ada banyak private_expr, dan semuanya terbatas. </p><br><p>  Dalam kode pada katak, yang mengimplementasikan pengunjung untuk pohon ini, semuanya sedikit lebih membuat ketagihan - sesuai ketat dengan algoritma, yang dengan sendirinya memproses logika_op yang menggantung dan menyeimbangkan kurung.  Saya tidak akan memberikan kutipan ( <a href="">lihat</a> sendiri <a href="">GC</a> ), tetapi saya akan memberikan pertimbangan berikut. </p><br><p>  Menjadi jelas mengapa penulis aero spike tidak repot-repot dengan dukungan predikat di AQL, dan meninggalkannya tiga tahun lalu.  Karena diketik dengan ketat, dan aero spike itu sendiri disajikan sebagai cerita tanpa skema.  Jadi tidak mungkin untuk mengambil dan mengeluarkan kueri dari SQL kosong tanpa skema yang telah ditentukan.  Ups </p><br><p>  Tapi kita semua hangus, dan yang paling penting, sombong.  Kami membutuhkan skema dengan tipe bidang, sehingga akan ada skema dengan tipe bidang.  Selain itu, perpustakaan klien sudah memiliki semua definisi yang diperlukan, mereka hanya perlu diambil.  Meskipun saya harus menulis banyak kode untuk setiap jenis (lihat tautan yang sama, dari baris 56). </p><br><p>  Sekarang inisialisasi ... </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> HashMap FOO_BAR_BAZ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap() {{ put(<span class="hljs-string"><span class="hljs-string">"namespace.set0"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap() {{ put(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>, ParticleType.INTEGER); put(<span class="hljs-string"><span class="hljs-string">"bar"</span></span>, ParticleType.DOUBLE); put(<span class="hljs-string"><span class="hljs-string">"baz"</span></span>, ParticleType.STRING); put(<span class="hljs-string"><span class="hljs-string">"qux"</span></span>, ParticleType.GEOJSON); put(<span class="hljs-string"><span class="hljs-string">"quux"</span></span>, ParticleType.STRING); put(<span class="hljs-string"><span class="hljs-string">"quuux"</span></span>, ParticleType.LIST); put(<span class="hljs-string"><span class="hljs-string">"corge"</span></span>, ParticleType.MAP); put(<span class="hljs-string"><span class="hljs-string">"corge.uier"</span></span>, ParticleType.INTEGER); }}); put(<span class="hljs-string"><span class="hljs-string">"namespace.set1"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap() {{ put(<span class="hljs-string"><span class="hljs-string">"grault"</span></span>, ParticleType.INTEGER); put(<span class="hljs-string"><span class="hljs-string">"garply"</span></span>, ParticleType.STRING); }}); }}; AQLSelectEx selectEx = AQLSelectEx.forSchema(FOO_BAR_BAZ);</code> </pre> <br><p>  ... dan voila, sekarang permintaan sintetis kami dengan sederhana dan jelas tersentak dari aerosoldering: </p><br><pre> <code class="java hljs">Statement statement = selectEx.fromString(<span class="hljs-string"><span class="hljs-string">"SELECT foo,bar,baz,qux,quux FROM namespace.set WITH (baz='a') WHERE (foo&gt;2 AND (bar &lt;=3 OR foo&gt;5) AND quux LIKE '%force%') OR NOT (qux WITHIN CAST('{\"type\": \"Polygon\", \"coordinates\": [0.0, 0.0],[1.0, 0.0],[1.0, 1.0],[0.0, 1.0],[0.0, 0.0]}' AS GEOJSON)"</span></span>);</code> </pre> <br><p>  Dan untuk mengonversi formulir dari moncong web ke permintaan itu sendiri, kami mengambil satu ton kode yang telah lama ditulis di moncong web ... ketika akhirnya sampai ke proyek, jika tidak pelanggan telah meletakkannya di rak untuk saat ini.  Sayang sekali, sial, aku menghabiskan waktu hampir seminggu. </p><br><p>  Saya harap saya menghabiskannya dengan manfaat, dan perpustakaan AQLSelectEx akan bermanfaat bagi seseorang, dan pendekatan itu sendiri akan menjadi tutorial yang sedikit lebih realistis daripada artikel lain dari hub yang berurusan dengan ANTLR. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435902/">https://habr.com/ru/post/id435902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435892/index.html">Intisari materi menarik untuk pengembang seluler # 281 (pada 7 - 13 Januari)</a></li>
<li><a href="../id435894/index.html">Kelas privat. Bersembunyi di php</a></li>
<li><a href="../id435896/index.html">Menggunakan DiagnosticSource dalam .NET Core: Theory</a></li>
<li><a href="../id435898/index.html">Apa yang harus dipikirkan pada wawancara NALSD</a></li>
<li><a href="../id435900/index.html">Enkapsulasi itu</a></li>
<li><a href="../id435904/index.html">AI menerjemahkan aktivitas otak ke dalam ucapan</a></li>
<li><a href="../id435906/index.html">Penyimpanan Cluster Pacemaker + DRBD (Dual primer) + ctdb</a></li>
<li><a href="../id435908/index.html">Web asketis: prototipe pasar loak saat bepergian dan js</a></li>
<li><a href="../id435910/index.html">Mengapa BSD kalah dalam pertempuran dengan GNU / Linux?</a></li>
<li><a href="../id435912/index.html">Masalah utama pengembangan antarmuka modern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>