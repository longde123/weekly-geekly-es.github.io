<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏼 🚵 👩🏼‍🔬 Blockchain Quorum: intégration au code Java 👨🏽‍🤝‍👨🏻 👩🏻‍💻 🦉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 


 Pour ceux qui sont intéressés par le sujet de la blockchain, ce n'est un secret pour personne qu'en plus des blockchains publiques,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blockchain Quorum: intégration au code Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462549/"><p>  Bonjour, Habr! </p><br><p>  Pour ceux qui sont intéressés par le sujet de la blockchain, ce n'est un secret pour personne qu'en plus des blockchains publiques, comme <em>Ethereum</em> , <em>Bitcoin</em> , <em>Zcash</em> , etc., il y a aussi leurs "frères" d'entreprise (privés) "qui sont en quelque sorte meilleurs que les réseaux publics, mais dans quelque chose qu'ils perdent pour eux.  Parmi les réseaux les plus connus, je pense que vous pouvez nommer <em>Quorum</em> (fournisseur - <strong>JP Morgan Chase</strong> ), <em>Pantheon</em> (fournisseur - <strong>PegaSys</strong> ) et <em>Hyperledger</em> (géré par <strong>The Linux Foundation</strong> ).  Malgré le fait qu'il y a beaucoup de décisions publiques, les entreprises sont de plus en plus intéressées par les blockchains privées car elles sont en mesure de fournir le niveau de confidentialité nécessaire, les transactions sont plus rapides et ainsi de suite. <a name="habracut"></a>  Les différences entre les chaînes de blocs privées et publiques, ainsi que leurs avantages et inconvénients, ne font pas l'objet de cet article.  Si vous êtes intéressé à lire à ce sujet, c'est par exemple un tel article sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Medium</a> . </p><br><p>  Dans cet article, je voudrais vous expliquer comment vous pouvez utiliser la blockchain <em>Quorum</em> pour développer vos applications avec la prise en charge des transactions privées et publiques.  Pour démontrer les capacités, nous allons écrire une petite application <em>Java / Spring</em> qui acceptera les demandes de déployer (déployer) des contrats intelligents, d'exécuter des transactions et de lire les données d'un contrat intelligent.  En fait, voici la pile technologique qui sera utilisée dans l'article: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java 8</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gradle 5.2.1</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cadre de printemps</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Web3j</a> (bibliothèque pour travailler avec des transactions publiques dans des réseaux de type Ethereum) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Web3j-quorum</a> (bibliothèque pour travailler avec des transactions privées dans le réseau Quorum) </li></ul><br><h1 id="nemnogo-obschey-informacii-o-quorum">  Quelques informations générales sur Quorum </h1><br><p>  <em>Quorum</em> est un projet avec du code open source sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> , dont le but est de fournir une blockchain qui permettrait d'effectuer des transactions non seulement publiquement mais également en mode privé.  D'un point de vue technique, <em>Quorum</em> est une mise à niveau d' <em>Ethereum</em> , il a également son propre client <em>Geth</em> modifié pour pouvoir effectuer des transactions privées. </p><br><p>  Un ajout important est également les services <em>enclaves</em> , qui sont responsables du stockage, du cryptage et de la distribution des transactions privées entre eux.  Il existe maintenant 2 services d' <em>enclave de ce type</em> : </p><br><ol><li>  <strong>Constellation</strong> - écrite en Haskell, la première version de l' <em>enclave</em> , mais maintenant elle ne se développe plus, et très probablement à l'avenir, elle sera abandonnée au profit d'une nouvelle; </li><li>  <strong>Tessera</strong> - un nouveau service, écrit en <em>Java</em> , soutenu par les développeurs de JP Morgan Chase, a plus d'options pour l'intégration avec la base de données et la gestion des informations sensibles (par exemple, il y a une option d'intégration avec <em>HashiCorp Vault</em> pour la gestion des secrets). </li></ol><br><p>  Quant aux transactions, du point de vue de l'interface d' <em>Ethereum</em> ordinaire <em>,</em> peu de choses ont changé (et c'est bien).  Pour envoyer une transaction privée, en plus des informations habituelles sur la transaction, vous devez également spécifier le paramètre <strong>privateFor</strong> - il s'agit du <strong>tableau de</strong> lignes, et ces lignes sont des clés publiques du nœud <em>enclave</em> .  À l'aide de ces clés, les transactions de <em>charge utile</em> sont <em>cryptées</em> et la charge <em>utile</em> est répartie entre les nœuds <strong>Tessera</strong> à l'intérieur de la blockchain. </p><br><p>  Pour une connaissance plus approfondie de <em>Quorum</em> , comment cela fonctionne et comment développer le réseau de blockchain, vous pouvez le trouver sur le site officiel (un lien vers la documentation, ainsi qu'un lien vers le tutoriel sur la façon de lancer une blockchain de test, je vais laisser à la fin de l'article). </p><br><h1 id="razrabotka-java-prilozheniya">  Développement d'applications Java </h1><br><p>  À titre d'exemple, je vais montrer une petite API RESTful écrite en <em>Java / Spring</em> , avec <em>Gradle</em> comme outil de gestion de construction et de dépendance qui chargera le contrat intelligent dans la blockchain, remplira la fonction de changer l'état du contrat et lira l'état du contrat intelligent. </p><br><p>  Avant de commencer le développement lui-même, je dois clarifier quelque chose.  Malgré le fait que <em>Quorum</em> dispose officiellement de 2 options de transaction, je préfère les diviser en 3 types: </p><br><ol><li>  Transactions <em>publiques</em> - les transactions sont entièrement visibles pour tous les participants au réseau (y compris la <em>charge utile</em> ), le nœud <em>enclave</em> ne participe ni au traitement ni au stockage de la transaction.  Les transactions publiques dans <em>Quorum</em> ne <em>sont</em> pas différentes des transactions sur le réseau <em>Ethereum</em> ; </li><li>  Transactions <em>autorisées</em> - les transactions sont essentiellement privées, mais pour plusieurs participants au réseau, c'est-à-dire sur le réseau public, nous avons des informations sur la transaction et l'état de son exécution, mais au lieu d'une <em>charge utile</em> réelle sur le réseau public, nous n'avons qu'une chaîne de hachage de 64 bits, qui est un identifiant pour une <em>charge utile</em> réelle dans un nœud d' <em>enclave</em> , le nœud d' <em>enclave</em> lui-même est responsable de la signature, du cryptage, du stockage et de la distribution de la <em>charge utile</em> entre les participants à la transaction spécifiés; </li><li>  Transactions <em>privées</em> - diffère des <em>autorisations</em> dans la mesure où la transaction n'est disponible que pour le nœud qui a créé cette transaction, les autres participants au réseau ne peuvent pas voir les transactions de <em>charge utile</em> . <br>  J'utiliserai cette classification tout au long de l'article. </li></ol><br><p> Pour commencer, je vais vous montrer à quoi ressemblera le fichier de construction - <code>gradle.build</code> : </p><br><pre> <code class="plaintext hljs">plugins { id 'org.springframework.boot' version '2.1.6.RELEASE' id 'java' } apply plugin: 'io.spring.dependency-management' group = 'com.github' version = '1.0' sourceCompatibility = '1.8' configurations { compileOnly { extendsFrom annotationProcessor } } repositories { mavenCentral() } test { testLogging.showStandardStreams = true } dependencies { implementation 'org.springframework.boot:spring-boot-starter-webflux' implementation group: 'org.web3j', name: 'quorum', version: '4.0.6' implementation group: 'org.web3j', name: 'core', version: '4.1.0' implementation group: 'org.web3j', name: 'codegen', version: '4.1.0' compileOnly 'org.projectlombok:lombok' annotationProcessor 'org.projectlombok:lombok' annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor' testImplementation 'org.springframework.boot:spring-boot-starter-test' testImplementation 'io.projectreactor:reactor-test' } task generateWrappers(type: JavaExec) { group 'Demo' description 'Generates wrappers for smart-contracts' classpath = sourceSets.main.runtimeClasspath main = 'com.github.quorum.utils.WrappersGenerator' }</code> </pre> <br><p>  Un peu d'explication: </p><br><ol><li>  <code>org.web3j.core</code> - dépendance pour travailler avec les transactions sur le réseau <em>Ethereum</em> et les transactions publiques sur le réseau <em>Quorum</em> </li><li>  <code>org.web3j.quorum</code> - dépendance pour travailler avec des transactions privées sur le réseau <em>Quorum</em> </li><li>  <code>org.web3j.codegen</code> - dépendance pour générer des <code>org.web3j.codegen</code> pour les contrats intelligents <em>Solidity</em> </li><li>  <em>generateWrappers</em> - Gradle-task pour générer <em>des</em> wrappers <em>Java à</em> partir de contrats intelligents <em>Solidity</em> </li></ol><br><p>  Ensuite, je vais vous montrer le code de contrat intelligent qui sera utilisé dans cet article: Fichier <code>QuorumDemo.sol</code> : </p><br><pre> <code class="plaintext hljs">pragma solidity 0.5.0; /** * @dev Smart-Contract for demonstration purposes. */ contract QuorumDemo { string public user; /** * @dev Rewrite user name in storage. */ function writeUser(string calldata _user) public { user = _user; } }</code> </pre> <br><p>  Le contrat est intentionnellement simplifié, mais il suffit aux fins de notre article.  Si vous connaissez <em>Solidity</em> , vous pouvez ignorer l'explication: </p><br><ul><li>  <code>string public user</code> - une variable publique de type <em>chaîne</em> et le nom d' <em>utilisateur</em> .  Contrairement à <em>Java</em> , <em>Solidity</em> génère automatiquement un <em>getter</em> pour les variables publiques, vous n'avez donc pas besoin de l'implémenter manuellement. </li><li>  <code>function writeUser(...)</code> - la fonction de changer la valeur d'une variable, en fait - <em>setter</em> . </li></ul><br><p>  Pour créer un <code>Java-wrapper</code> partir d'un contrat intelligent, vous devez placer le fichier dans le dossier <code>src/main/solidity/contracts</code> avec n'importe quel nom, par exemple <code>QuorumDemo.sol</code> . <br>  Ensuite, exécutez Gradle-task <em>generateWrappers avec la</em> commande: </p><br><pre> <code class="plaintext hljs">gradle generateWrappers</code> </pre> <br><p>  Une fois cette tâche terminée, un <em>wrapper Java</em> sera créé dans <code>src/main/java/com/github/quorum/component/wrappers</code> , avec lequel vous pouvez déjà travailler en code <em>Java</em> . </p><br><p>  Pour que le backend puisse signer des transactions, nous devons pouvoir recevoir des transactions de <em>charge utile</em> avant de les envoyer.  Pour cela, il serait intéressant de l'obtenir directement à partir de la classe <em>Java-wrapper</em> .  Ici, j'ai créé 2 méthodes dans le wrapper.  La première méthode renvoie simplement l' <em>ABI du</em> contrat, qui peut être utilisé pour télécharger un nouveau contrat intelligent.  La deuxième méthode est la formation d'une transaction pour changer le statut d'un contrat intelligent.  Voici le code de ces méthodes: </p><br><pre> <code class="plaintext hljs">public static String getBinary() { return BINARY; } public static String getDataOnWriteUser(final String user) { final Function function = new Function( FUNC_WRITEUSER, Arrays.asList(new Utf8String(user)), Collections.emptyList() ); return FunctionEncoder.encode(function); }</code> </pre> <br><p>  En les insérant dans le <em>wrapper Java</em> généré, vous pouvez recevoir la <em>charge utile</em> des transactions. </p><br><p>  Ensuite, nous avons besoin d'un moyen pratique d'envoyer des transactions à la blockchain, de préférence avec la même interface pour les transactions privées et publiques.  Par conséquent, j'ai créé une interface de gestionnaire de transactions et 2 de son implémentation: </p><br><ol><li>  <code>TesseraTransactionManager</code> , pour l'envoi de transactions privées </li><li>  <code>GethTransactionManager</code> , pour l'envoi de transactions publiques </li></ol><br><p>  Prenons-les à part.  Code <code>TesseraTransactionManager</code> : </p><br><pre> <code class="plaintext hljs">@Slf4j public class TesseraTransactionManager implements TransactionManager { private static final byte ATTEMPTS = 20; private static final int SLEEP_DURATION = 100; private final Quorum quorum; private final String fromAddress; private final QuorumTransactionManager quorumTxManager; private final TransactionReceiptProcessor txReceiptProcessor; public TesseraTransactionManager( Quorum quorum, Credentials credentials, String publicKey, List&lt;String&gt; privateFor, Tessera tessera ) { this.quorum = quorum; this.fromAddress = credentials.getAddress(); this.quorumTxManager = new QuorumTransactionManager(quorum, credentials, publicKey, privateFor, tessera); this.txReceiptProcessor = new PollingTransactionReceiptProcessor(quorum, SLEEP_DURATION, ATTEMPTS); } @Override public TransactionReceipt executeTransaction( final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data) { while (true) { try { final EthSendTransaction ethSendTx = sendTransaction(gasPrice, gasLimit, to, data); if (ethSendTx.hasError() &amp;&amp; NONCE_TOO_LOW_ERROR_MESSAGE.equals(ethSendTx.getError().getMessage())) { log.warn("[BLOCKCHAIN] try to re-send transaction cause error {}", ethSendTx.getError().getMessage()); continue; } return processResponse(ethSendTx); } catch (TransactionException ex) { log.error("[BLOCKCHAIN] exception while receiving TransactionReceipt from Quorum node", ex); throw new RuntimeException(ex); } catch (Exception ex) { log.error("[BLOCKCHAIN] exception while sending transaction to Quorum node", ex); throw new RuntimeException(ex); } } } private EthSendTransaction sendTransaction( final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data) throws IOException { final BigInteger nonce = getNonce(); final RawTransaction rawTransaction = RawTransaction.createTransaction(nonce, gasPrice, gasLimit, to, data); return this.quorumTxManager.signAndSend(rawTransaction); } private TransactionReceipt processResponse(final EthSendTransaction transactionResponse) throws IOException, TransactionException { if (transactionResponse.hasError()) { throw new RuntimeException( "[BLOCKCHAIN] error processing transaction request: " + transactionResponse.getError().getMessage() ); } final String transactionHash = transactionResponse.getTransactionHash(); return this.txReceiptProcessor.waitForTransactionReceipt(transactionHash); } private BigInteger getNonce() throws IOException { final EthGetTransactionCount ethGetTxCount = this.quorum.ethGetTransactionCount( this.fromAddress, DefaultBlockParameterName.PENDING).send(); return ethGetTxCount.getTransactionCount(); } }</code> </pre> <br><ul><li>  <code>TransactionReceipt executeTransaction(...)</code> - implémentation de l'interface, une méthode pour effectuer des transactions sur le réseau et gérer les erreurs si elles se produisent.  Renvoie un objet avec le résultat d'une transaction; </li><li>  <code>EthSendTransaction sendTransaction(...)</code> - une méthode pour signer et envoyer des transactions à la blockchain.  Renvoie un objet avec le statut de transaction et son hachage; </li><li>  <code>TransactionReceipt processResponse(...)</code> - une méthode qui attend que la transaction se termine et renvoie <code>TransactionReceipt</code> après son exécution; </li><li>  <code>BigInteger getNonce()</code> - Retourne "nonce" du réseau. </li></ul><br><p>  Et le code <code>GethTransactionManager</code> : </p><br><pre> <code class="plaintext hljs">@Slf4j public class GethTransactionManager extends FastRawTransactionManager implements TransactionManager { private static final byte ATTEMPTS = 20; private static final int SLEEP_DURATION = 100; private final TransactionReceiptProcessor txReceiptProcessor; public GethTransactionManager(Web3j web3j, Credentials credentials) { this(web3j, credentials, new PollingTransactionReceiptProcessor(web3j, SLEEP_DURATION, ATTEMPTS)); } public GethTransactionManager(Web3j web3j, Credentials credentials, TransactionReceiptProcessor txReceiptProcessor) { super(web3j, credentials, txReceiptProcessor); this.txReceiptProcessor = txReceiptProcessor; } @Override public TransactionReceipt executeTransaction( final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data) { while (true) { try { final EthSendTransaction ethSendTx = sendTransaction(gasPrice, gasLimit, to, data, BigInteger.ZERO); if (ethSendTx != null &amp;&amp; ethSendTx.hasError() &amp;&amp; NONCE_TOO_LOW_ERROR_MESSAGE.equals(ethSendTx.getError().getMessage())) { log.warn("[BLOCKCHAIN] try to re-send transaction cause error: {}", ethSendTx.getError().getMessage()); continue; } return this.txReceiptProcessor.waitForTransactionReceipt(ethSendTx.getTransactionHash()); } catch (TransactionException ex) { log.error("[BLOCKCHAIN] exception while receiving TransactionReceipt from Quorum node", ex); throw new RuntimeException(ex); } catch (IOException ex) { log.error("[BLOCKCHAIN] exception while sending transaction to Quorum node", ex); throw new RuntimeException(ex); } } } @Override public EthSendTransaction sendTransaction( final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data, final BigInteger value ) throws IOException { return super.sendTransaction(gasPrice, gasLimit.add(BigInteger.valueOf(21_000L)), to, data, value); } }</code> </pre> <br><ul><li>  <code>TransactionReceipt executeTransaction(...)</code> - implémentation de l'interface, une méthode pour effectuer des transactions sur le réseau et gérer les erreurs si elles se produisent.  Renvoie un objet avec le résultat d'une transaction; </li><li>  <code>EthSendTransaction sendTransaction(...)</code> est une méthode qui appelle la méthode <code>EthSendTransaction sendTransaction(...)</code> pour envoyer une transaction à la blockchain. </li></ul><br><p>  Le gestionnaire des demandes qui parviennent à l' <em>API</em> : </p><br><pre> <code class="plaintext hljs">@Slf4j @Component public class RequestHandler { private final Web3j web3j; private final Quorum quorum; private final Tessera tessera; private final Credentials credentials; private final BlockchainConfig blockchainConfig; private String deployedContract; @Autowired public RequestHandler( @Qualifier("initWeb3j") Web3j web3j, Quorum quorum, Tessera tessera, Credentials credentials, BlockchainConfig blockchainConfig ) { this.web3j = web3j; this.quorum = quorum; this.tessera = tessera; this.credentials = credentials; this.blockchainConfig = blockchainConfig; } /** * Deploy new smart-contract. * * @param serverRequest * - {@link ServerRequest} object with request information * @return {@link ServerResponse} object with response data */ public Mono&lt;ServerResponse&gt; deployContract(final ServerRequest serverRequest) { return serverRequest .bodyToMono(APIRequest.class) .map(this::getTransactionManager) .map(this::deployContract) .flatMap(this::generateResponse); } private TransactionManager getTransactionManager(final APIRequest apiRequest) { log.info("[HANDLER] privateFor = {}", apiRequest.getPrivateFor()); TransactionManager txManager; if (isPrivate(apiRequest.getPrivateFor())) { if (apiRequest.getPrivateFor().size() == 0) { apiRequest.getPrivateFor().add(this.blockchainConfig.getTesseraPublicKey()); } txManager = new TesseraTransactionManager(this.quorum, this.credentials, this.blockchainConfig.getTesseraPublicKey(), apiRequest.getPrivateFor(), this.tessera); } else { txManager = new GethTransactionManager(this.web3j, this.credentials); } return txManager; } private boolean isPrivate(final List&lt;String&gt; limitedTo) { return limitedTo == null || limitedTo.size() == 0 || !limitedTo.get(0).equals("public"); } private APIResponse deployContract(final TransactionManager txManager) { log.info("[HANDLER] deploying new smart-contract"); final String data = QuorumDemo.getBinary(); final TransactionReceipt txReceipt = txManager.executeTransaction(GAS_PRICE, DEPLOY_GAS_LIMIT, null, data); final APIResponse apiResponse = APIResponse.newInstance(txReceipt); this.deployedContract = txReceipt.getContractAddress(); log.info("[HANDLER] contract has been successfully deployed. Result: {}", apiResponse.getMap()); return apiResponse; } private Mono&lt;ServerResponse&gt; generateResponse(final APIResponse apiResponse) { return ServerResponse .ok() .body(Mono.just(apiResponse.getMap()), Map.class); } /** * Send transaction on update user in smart-contract. * * @param serverRequest * - {@link ServerRequest} object with request information * @return {@link ServerResponse} object with response data */ public Mono&lt;ServerResponse&gt; updateUser(final ServerRequest serverRequest) { return serverRequest .bodyToMono(APIRequest.class) .map(this::sendTransaction) .flatMap(this::generateResponse); } private APIResponse sendTransaction(final APIRequest apiRequest) { final TransactionManager txManager = getTransactionManager(apiRequest); log.info("[HANDLER] sending new transaction"); final String data = QuorumDemo.getDataOnWriteUser(apiRequest.getUser()); final TransactionReceipt txReceipt = txManager.executeTransaction(GAS_PRICE, TX_GAS_LIMIT, this.deployedContract, data); final APIResponse apiResponse = APIResponse.newInstance(txReceipt); log.info("[HANDLER] transaction has been successfully executed. Result: {}", apiResponse.getMap()); return apiResponse; } /** * Read user from smart-contract. * * @param serverRequest * - {@link ServerRequest} object with request information * @return {@link ServerResponse} object with response data */ public Mono&lt;ServerResponse&gt; getUser(final ServerRequest serverRequest) { final APIResponse apiResponse = getUser(); return generateResponse(apiResponse); } private APIResponse getUser() { log.info("[HANDLER] reading user from smart-contract"); final QuorumDemo quorumDemo = QuorumDemo.load(this.deployedContract, this.web3j, this.credentials, new StaticGasProvider(GAS_PRICE, DEPLOY_GAS_LIMIT)); final String user = readUserFromSmartContract(quorumDemo); final APIResponse apiResponse = APIResponse.newInstance(user); log.info("[HANDLER] user: '{}'", user); return apiResponse; } private String readUserFromSmartContract(final QuorumDemo quorumDemo) { try { return quorumDemo.user().send().getValue(); } catch (Exception ex) { log.info("[HANDLER] exception while reading user from smart-contract: {}", ex); return null; } } }</code> </pre> <br><p>  Je vais maintenant expliquer quelles méthodes sont responsables de quoi. <br>  <code>Mono&lt;ServerResponse&gt; deployContract(...)</code> méthode <code>Mono&lt;ServerResponse&gt; deployContract(...)</code> - décrit la logique générale du <code>Mono&lt;ServerResponse&gt; deployContract(...)</code> contrat intelligent, public et privé. <br>  <code>TransactionManager getTransactionManager(...)</code> méthode <code>TransactionManager getTransactionManager(...)</code> - renvoie l'objet d'implémentation du gestionnaire de transactions en fonction du type de transaction.  Pour cela, le paramètre request contiendra le paramètre <strong>privateFor</strong> , qui est un tableau de chaînes de clés publiques <em>Tessera</em> . <br>  <code>boolean isPrivate(...)</code> méthode <code>boolean isPrivate(...)</code> - renvoie "true" si le paramètre <strong>privateFor est</strong> vide (transaction <em>privée</em> ) ou a une liste de clés publiques (transaction <em>autorisée</em> ).  Renvoie "false" si le paramètre <strong>privateFor n'est</strong> pas vide et que le premier élément du tableau est égal à "public". <br>  <code>APIResponse deployContract(...)</code> - envoie la transaction de déploiement à la blockchain. <br>  Méthode <code>Mono&lt;ServerResponse&gt; generateResponse(...)</code> - génère un objet avec une réponse au client. <br>  Méthode <code>Mono&lt;ServerResponse&gt; updateUser(...)</code> - décrit la logique générale de la transaction pour changer le statut du contrat intelligent. <br>  <code>APIResponse sendTransaction(...)</code> - envoie une transaction de changement d'état à la blockchain. <br>  <code>APIResponse getUser()</code> - décrit la logique générale de lecture des informations d'un contrat intelligent et renvoie une réponse au client. <br>  Méthode de <code>String readUserFromSmartContract(...)</code> - lit l'état du contrat intelligent et renvoie le résultat. </p><br><p>  Le code d'application complet est disponible dans le référentiel <em>GitHub</em> , un lien vers lequel sera à la fin de cet article. </p><br><h1 id="proverka">  Vérifier </h1><br><p>  Pour tester les 3 types de transactions, j'ai écrit des classes de test (le code est dans le dépôt <em>GitHub</em> ).  Pour ce faire, j'ai déployé une blockchain avec 3 nœuds <em>Quorum</em> (3 nœuds <em>Geth</em> + 3 nœuds <em>Tessera</em> ).  3 Les nœuds de <em>quorum</em> sont les nœuds minimaux requis pour vérifier tous les types de transactions.  Gardez cela à l'esprit si vous voulez l'essayer vous-même. </p><br><h2 id="public-tranzakcii">  Transactions publiques </h2><br><p>  Pour exécuter un scénario de test avec une transaction publique, vous devez exécuter la commande suivante: </p><br><pre> <code class="plaintext hljs">gradle test --tests *.PublicTransactionsTests</code> </pre> <br><p>  Ce scénario de test enverra 3 demandes d' <em>API</em> .  Le premier est le déploiement du contrat intelligent sur la blockchain, le second est le changement de statut du contrat et la troisième demande est la lecture des informations du contrat intelligent.  À la suite du test, vous verrez approximativement les journaux suivants (les adresses sur votre réseau différeront, ainsi que les hachages de transaction): </p><br><pre> <code class="plaintext hljs">[HANDLER] privateFor = [public] [HANDLER] deploying new smart-contract [HANDLER] contract has been successfully deployed. Result: {contract_address=0xf9425b94e459805da09950f5988071692d925097, transaction_hash=0x31bc179f8cd12c640d1663f3df51ce6da1fbc2875f2b724c3911108fcd19a5d0} [HANDLER] privateFor = [public] [HANDLER] sending new transaction [HANDLER] transaction has been successfully executed. Result: {contract_address=null, transaction_hash=0x33ba66d5deec33f3142bfa190a0d37d0ff07c2e66b06037f5b5ff9578154a3ff} [HANDLER] reading user from smart-contract [HANDLER] user: 'Public Test User'</code> </pre> <br><p>  En général, ces journaux indiquent que les 3 opérations ont réussi.  Les 3 premiers journaux - appartiennent à la demande de déploiement du contrat intelligent, les 3 prochains journaux - appartiennent à la transaction et les 2 derniers - pour lire les informations du contrat intelligent. <br>  Le fait que dans le résultat du chargement du contrat, nous voyons <strong>contract_address</strong> , mais dans le cas d'une transaction simple - non, c'est tout à fait normal, car la deuxième fois, nous ne déployons pas le contrat, mais réalisons la transaction sur un contrat intelligent existant. </p><br><p>  <em>Vérifions</em> maintenant ce que <em>Geth nous</em> montre, <em>exécutons</em> la commande suivante pour nous connecter à l'interface <em>IPC du</em> processus <em>Geth</em> du client: </p><br><pre> <code class="plaintext hljs">geth attach /path/to/ipc</code> </pre> <br><p>  Une fois que nous nous sommes «habitués» au processus, vous pouvez revoir complètement toutes les informations nécessaires.  Examinons la <code>TransactionReceipt</code> TransactionReceipt sur le déploiement d'un nouveau contrat intelligent en exécutant la commande (le hachage de la transaction doit être configuré et extrait des journaux de test): </p><br><pre> <code class="plaintext hljs">web3.eth.getTransactionReceipt('0x31bc179f8cd12c640d1663f3df51ce6da1fbc2875f2b724c3911108fcd19a5d0');</code> </pre> <br><p>  En conséquence, nous voyons ce qui suit: </p><br><p><img src="https://habrastorage.org/webt/so/jm/yw/sojmyw_4gei16afdq47ypzmvtru.png"></p><br><p>  Nous nous intéressons aux paramètres suivants: </p><br><ul><li>  "contractAddress" - sinon "null", alors nous comprenons qu'il s'agit d'une transaction pour le déploiement d'un contrat intelligent; </li><li>  "status" - dans ce cas, il est égal à "0x1" - ce qui signifie que la transaction a réussi. </li></ul><br><p>  Et regardons la transaction elle-même.  En exécutant la commande: </p><br><pre> <code class="plaintext hljs">web3.eth.getTransaction('0x31bc179f8cd12c640d1663f3df51ce6da1fbc2875f2b724c3911108fcd19a5d0');</code> </pre> <br><p>  Résultat: </p><br><p><img src="https://habrastorage.org/webt/ju/jq/86/jujq86cugnifanot96ypy_hvusm.png"></p><br><p>  Nous nous intéressons ici aux paramètres suivants: </p><br><ul><li>  "input" est une transaction de <em>charge utile</em> ; </li><li>  "v" - en général, c'est un paramètre pour <em>ECDSA</em> , l'algorithme de signature numérique, mais maintenant nous nous intéressons à autre chose - la signification de la variable.  C'est important parce que dans les transactions publiques et privées, ce sera différent.  "0x1c" ("28" dans le système décimal) et "0x1b" ("27" dans le système décimal) sont typiques pour les transactions publiques, et "0x25" ("37" dans le système décimal) et "0x26" ("38" en décimal). système) - ce sont des codes de transaction privés. </li></ul><br><p>  Vous pouvez également vérifier que sur d'autres nœuds, les informations ne diffèrent pas de ce que nous avons vu maintenant. </p><br><p>  Vous pouvez maintenant afficher les modifications de l'état des transactions du contrat intelligent.  Exécutez la commande: </p><br><pre> <code class="plaintext hljs">web3.eth.getTransactionReceipt('0x33ba66d5deec33f3142bfa190a0d37d0ff07c2e66b06037f5b5ff9578154a3ff');</code> </pre> <br><p>  Résultat: </p><br><p><img src="https://habrastorage.org/webt/zz/8g/a-/zz8ga-le8lswmr7vkizq5tu_zog.png"></p><br><p>  Nous nous intéressons aux paramètres suivants: </p><br><ul><li>  "to" - nous voyons que la transaction est allée au contrat intelligent tant attendu; </li><li>  "status" - il est égal à "0x1", ce qui signifie que la transaction a réussi. </li></ul><br><p>  Transaction: </p><br><p><img src="https://habrastorage.org/webt/t9/yh/xp/t9yhxp0-hzbkvylmous8p--ft2e.png"></p><br><p>  Rien d'inhabituel, mais vous pouvez vérifier les informations sur les autres nœuds, c'est utile. </p><br><h2 id="private-tranzakcii">  Transactions privées </h2><br><p>  Pour exécuter un scénario de test avec une transaction privée, vous devez exécuter la commande suivante: </p><br><pre> <code class="plaintext hljs">gradle test --tests *.PrivateTransactionsTests</code> </pre> <br><p>  Comme dans le cas de test avec les transactions publiques, ce cas de test déploiera un nouveau contrat intelligent, exécutera une transaction de changement d'état et lira les informations du changement dans le contrat intelligent. </p><br><p>  Par conséquent, le programme écrira les journaux suivants: </p><br><pre> <code class="plaintext hljs">[HANDLER] privateFor = [] [HANDLER] deploying new smart-contract [HANDLER] contract has been successfully deployed. Result: {contract_address=0x3e2284d92842f781b83cc7e56fbb074ab15f9a90, transaction_hash=0x8fd619bd9a526f83e29d7b417551e174862f7503ef430eb45793509d05039595} [HANDLER] privateFor = [] [HANDLER] sending new transaction [HANDLER] transaction has been successfully executed. Result: {contract_address=null, transaction_hash=0x72a0458a7b313c8a1c18269ae160e140c6a6e41cb2fd087c64cf665b08a6aefb} [HANDLER] reading user from smart-contract [HANDLER] user: 'Private Test User'</code> </pre> <br><p>  Le changement, par rapport aux transactions publiques, est le paramètre <strong>privateFor</strong> - il a maintenant la valeur d'un tableau vide. <br>  Vérifions <code>TransactionReceipt</code> pour une transaction.  Équipe: </p><br><pre> <code class="plaintext hljs">web3.eth.getTransactionReceipt('0x8fd619bd9a526f83e29d7b417551e174862f7503ef430eb45793509d05039595');</code> </pre> <br><p>  Résultat: </p><br><p><img src="https://habrastorage.org/webt/qx/aj/1g/qxaj1gluf9gl-o-rwbwaa6-oww8.png"></p><br><p>  Parmi les changements, par rapport aux transactions publiques, il convient de dire que vous ne verrez pas la quantité de gaz dépensée pour la transaction - <strong>gasUsed</strong> et <strong>cumulativeGasUsed</strong> ont une valeur de "0". <br>  Voyons maintenant la transaction elle-même.  Exécutez la commande: </p><br><pre> <code class="plaintext hljs">web3.eth.getTransaction('0x8fd619bd9a526f83e29d7b417551e174862f7503ef430eb45793509d05039595');</code> </pre> <br><p>  En conséquence, nous verrons ceci: </p><br><p><img src="https://habrastorage.org/webt/of/zj/ud/ofzjuds-akmr-koc9ed9dasubnq.png"></p><br><p>  Ce qui mérite d'être noté dans cette transaction: </p><br><ol><li>  Comme je l'ai mentionné au début de cet article, au lieu d'une véritable transaction de <em>charge utile</em> , vous verrez une ligne fixe de 64 octets (128 caractères) dans le champ de <strong>saisie</strong> .  Cette ligne est l'identifiant des données dans le référentiel <em>Tessera</em> , vous pouvez obtenir des données réelles sur demande auprès de <em>Tessera</em> . </li><li>  "v" - au lieu des codes "0x1c" ou "0x1b" comme dans les transactions publiques, pour les transactions privées, vous verrez "0x26" ou "0x25". </li></ol><br><p>  Vérifions maintenant le <code>TransactionReceipt</code> et la transaction elle-même pour changer le statut du contrat (vous connaissez déjà les commandes).  Résultat: </p><br><p><img src="https://habrastorage.org/webt/of/zj/ud/ofzjuds-akmr-koc9ed9dasubnq.png"></p><br><p><img src="https://habrastorage.org/webt/cw/mp/vk/cwmpvk3hjzcnh51isapyhecpkf0.png"></p><br><p>  En principe, nous n'apprendrons rien de nouveau de cette transaction privée. </p><br><h2 id="permissioned-tranzakcii">  Transactions autorisées </h2><br><p>  Comme il s'agit également de transactions privées, elles sont simplement privées, non pas pour un nœud, mais pour plusieurs, les résultats de ces transactions ne différeront pas des transactions privées.  Vous pouvez faire une différence si vous essayez d'obtenir des informations d'un nœud qui a été spécifié dans <strong>privateFor</strong> et d'un nœud dont la clé publique n'est pas enregistrée dans <strong>privateFor</strong> (vous pouvez obtenir des informations du premier nœud et pas du deuxième). <br>  Pour exécuter un scénario de test avec des transactions privées pour plusieurs participants au réseau (transactions autorisées), vous devez exécuter la commande suivante: </p><br><pre> <code class="plaintext hljs">gradle test --tests *.PermissionTransactionsTests</code> </pre> <br><p>  Journaux de l' <em>API Java</em> : </p><br><pre> <code class="plaintext hljs">[HANDLER] privateFor = [wQTHrl/eqa7TvOz9XJcazsp4ZuncfxHb8c1J1njIOGA=] [HANDLER] deploying new smart-contract [HANDLER] contract has been successfully deployed. Result: {contract_address=0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd, transaction_hash=0x585980bec88aa8a0fe5caffe6d6f24b82d3cd381fcf72fdd8e2102ce67799f01} [HANDLER] privateFor = [wQTHrl/eqa7TvOz9XJcazsp4ZuncfxHb8c1J1njIOGA=] [HANDLER] sending new transaction [HANDLER] transaction has been successfully executed. Result: {contract_address=null, transaction_hash=0x47edc0d00fa9447b2da9f5a78f44602f96145497238cb1ce1d879afb351a3cbe} [HANDLER] reading user from smart-contract [HANDLER] user: 'Permissioned Test User'</code> </pre> <br><p>  Les résultats dans le client <em>Geth</em> , sur le déploiement du nouveau contrat intelligent, <code>TransactionReceipt</code> et la transaction elle-même, respectivement: </p><br><p><img src="https://habrastorage.org/webt/nk/cs/do/nkcsdozorvcuh7gv7kxspwovxmm.png"></p><br><p><img src="https://habrastorage.org/webt/bc/z5/1u/bcz51u6c28aussavjw7fdieayuq.png"></p><br><p>  Et la transaction de changement d'état, <code>TransactionReceipt</code> et la transaction elle-même: </p><br><p><img src="https://habrastorage.org/webt/4f/al/lt/4falltfjniekypa5r38xu8j6tzo.png"></p><br><p><img src="https://habrastorage.org/webt/tq/-s/ta/tq-stauf7_6a00ts7qgkzif0p18.png"></p><br><h3 id="http-zaprosy">  Demandes HTTP </h3><br><p>  Malgré le fait que nous avons vu comment les transactions publiques diffèrent des transactions privées du point de vue du client <em>Geth</em> , cela ne montre pas une réelle restriction à l'obtention d'informations.  Par conséquent, afin de vous montrer qu'il est vraiment possible de limiter le nombre de nœuds pouvant lire votre transaction, je vais effectuer plusieurs requêtes en utilisant <em>CURL</em> pour 3 nœuds pour lire les informations du smart contract (les requêtes concerneront <em>des</em> transactions <em>privées</em> et <em>persécutées</em> ). <br>  Les requêtes HTTP auront 2 paramètres dans le corps de la requête: </p><br><ol><li>  "endpoint" - directement le noeud final au noeud <em>Quorum</em> , vous devez vous connecter au noeud. </li><li>  "contractAddress" est l'adresse du contrat à partir de laquelle les données seront lues. </li></ol><br><p>  Dans mon cas, "endopint" aura un hôte - <em>localhost</em> - mais différents ports pour 3 nœuds de <em>quorum</em> : 22000 (toutes les transactions ont été effectuées à partir de ce nœud), 22001 (sa clé publique a été spécifiée dans les transactions autorisées), 22002 (ne devrait pas avoir accès à informations). </p><br><p>  Commençons par une transaction <em>privée</em> (seul un nœud sur le port 22000 devrait pouvoir afficher les informations dans un contrat intelligent). </p><br><p>  Demande <em>CURL</em> sur le nœud qui a effectué la transaction: </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22000", "contractAddress": "0x3e2284d92842f781b83cc7e56fbb074ab15f9a90" }'</code> </pre> <br><p>  En conséquence, nous avons obtenu ce qui suit: </p><br><pre> <code class="plaintext hljs">{"data":{"user":"Private Test User"}}</code> </pre> <br><p>  Cela signifie que le nœud a la possibilité de visualiser les informations dans un contrat intelligent. </p><br><p>  Voyons maintenant ce que le nœud du port 22001 nous renvoie.  Demande <em>CURL</em> : </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22001", "contractAddress": "0x3e2284d92842f781b83cc7e56fbb074ab15f9a90" }'</code> </pre> <br><p>  Super!        : </p><br><pre> <code class="plaintext hljs">{"data":{"status_code":500,"description":"Something went wrong"}}</code> </pre> <br><p>     ,        - —    ! </p><br><p>     , 3- . <em>CURL</em> : </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22002", "contractAddress": "0x3e2284d92842f781b83cc7e56fbb074ab15f9a90" }'</code> </pre> <br><p>  Super! API  : </p><br><pre> <code class="plaintext hljs">{"data":{"status_code":500,"description":"Something went wrong"}}</code> </pre> <br><p>   ,        .     "permissioned" . </p><br><p>  <em>CURL</em>       "permissioned" -  ,    22000: </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22000", "contractAddress": "0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd" }'</code> </pre> <br><p> : </p><br><pre> <code class="plaintext hljs">{"data":{"user":"Permissioned Test User"}}</code> </pre> <br><p>  ,         ,   ,       . </p><br><p>       -   ,         -,       . <em>CURL</em> : </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22001", "contractAddress": "0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd" }'</code> </pre> <br><p>  Super!         : </p><br><pre> <code class="plaintext hljs">{"data":{"user":"Permissioned Test User"}}</code> </pre> <br><p>      ,          ,    . <em>CURL</em> : </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22002", "contractAddress": "0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd" }'</code> </pre> <br><p>  Super!         -.    . </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>      ,    <em>Quorum blockchain</em>   Java .      ,    -     . </p><br><p>   : </p><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation sur le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quorum</font></font></em></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Réseau de test de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quorum</font></font></em></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></em></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canal de </font><em><font style="vertical-align: inherit;">quorum</font></em><font style="vertical-align: inherit;"> dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slack</font></font></em></a> </li></ol><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Merci de votre attention! </font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462549/">https://habr.com/ru/post/fr462549/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462539/index.html">Évitez la trigonométrie</a></li>
<li><a href="../fr462541/index.html">Utilisation du conditionnel au printemps</a></li>
<li><a href="../fr462543/index.html">Meetup Java à Raiffeisenbank</a></li>
<li><a href="../fr462545/index.html">Blocage des télégrammes, sous-réseau Hetzner / 16, expérience avec ILV</a></li>
<li><a href="../fr462547/index.html">SGX Malvar: comment les méchants exploitent la nouvelle technologie d'Intel à de mauvaises fins</a></li>
<li><a href="../fr462551/index.html">Questions fréquentes des développeurs sur les tests</a></li>
<li><a href="../fr462553/index.html">Un peu simple. Conception de test. Partie 1</a></li>
<li><a href="../fr462555/index.html">Discussion: que faire si vous travaillez sans cookies - nous vous disons quelles sont les alternatives</a></li>
<li><a href="../fr462563/index.html">Webinaire «Comment survivre à la conformité?» La meilleure approche pour répondre aux exigences réglementaires »</a></li>
<li><a href="../fr462565/index.html">Comment préparer les données pour SAP Process Mining by Celonis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>