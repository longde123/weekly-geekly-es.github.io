<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÜüèº üöµ üë©üèº‚Äçüî¨ Blockchain Quorum: int√©gration au code Java üë®üèΩ‚Äçü§ù‚Äçüë®üèª üë©üèª‚Äçüíª ü¶â</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 


 Pour ceux qui sont int√©ress√©s par le sujet de la blockchain, ce n'est un secret pour personne qu'en plus des blockchains publiques,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blockchain Quorum: int√©gration au code Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462549/"><p>  Bonjour, Habr! </p><br><p>  Pour ceux qui sont int√©ress√©s par le sujet de la blockchain, ce n'est un secret pour personne qu'en plus des blockchains publiques, comme <em>Ethereum</em> , <em>Bitcoin</em> , <em>Zcash</em> , etc., il y a aussi leurs "fr√®res" d'entreprise (priv√©s) "qui sont en quelque sorte meilleurs que les r√©seaux publics, mais dans quelque chose qu'ils perdent pour eux.  Parmi les r√©seaux les plus connus, je pense que vous pouvez nommer <em>Quorum</em> (fournisseur - <strong>JP Morgan Chase</strong> ), <em>Pantheon</em> (fournisseur - <strong>PegaSys</strong> ) et <em>Hyperledger</em> (g√©r√© par <strong>The Linux Foundation</strong> ).  Malgr√© le fait qu'il y a beaucoup de d√©cisions publiques, les entreprises sont de plus en plus int√©ress√©es par les blockchains priv√©es car elles sont en mesure de fournir le niveau de confidentialit√© n√©cessaire, les transactions sont plus rapides et ainsi de suite. <a name="habracut"></a>  Les diff√©rences entre les cha√Ænes de blocs priv√©es et publiques, ainsi que leurs avantages et inconv√©nients, ne font pas l'objet de cet article.  Si vous √™tes int√©ress√© √† lire √† ce sujet, c'est par exemple un tel article sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Medium</a> . </p><br><p>  Dans cet article, je voudrais vous expliquer comment vous pouvez utiliser la blockchain <em>Quorum</em> pour d√©velopper vos applications avec la prise en charge des transactions priv√©es et publiques.  Pour d√©montrer les capacit√©s, nous allons √©crire une petite application <em>Java / Spring</em> qui acceptera les demandes de d√©ployer (d√©ployer) des contrats intelligents, d'ex√©cuter des transactions et de lire les donn√©es d'un contrat intelligent.  En fait, voici la pile technologique qui sera utilis√©e dans l'article: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java 8</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gradle 5.2.1</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cadre de printemps</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Web3j</a> (biblioth√®que pour travailler avec des transactions publiques dans des r√©seaux de type Ethereum) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Web3j-quorum</a> (biblioth√®que pour travailler avec des transactions priv√©es dans le r√©seau Quorum) </li></ul><br><h1 id="nemnogo-obschey-informacii-o-quorum">  Quelques informations g√©n√©rales sur Quorum </h1><br><p>  <em>Quorum</em> est un projet avec du code open source sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> , dont le but est de fournir une blockchain qui permettrait d'effectuer des transactions non seulement publiquement mais √©galement en mode priv√©.  D'un point de vue technique, <em>Quorum</em> est une mise √† niveau d' <em>Ethereum</em> , il a √©galement son propre client <em>Geth</em> modifi√© pour pouvoir effectuer des transactions priv√©es. </p><br><p>  Un ajout important est √©galement les services <em>enclaves</em> , qui sont responsables du stockage, du cryptage et de la distribution des transactions priv√©es entre eux.  Il existe maintenant 2 services d' <em>enclave de ce type</em> : </p><br><ol><li>  <strong>Constellation</strong> - √©crite en Haskell, la premi√®re version de l' <em>enclave</em> , mais maintenant elle ne se d√©veloppe plus, et tr√®s probablement √† l'avenir, elle sera abandonn√©e au profit d'une nouvelle; </li><li>  <strong>Tessera</strong> - un nouveau service, √©crit en <em>Java</em> , soutenu par les d√©veloppeurs de JP Morgan Chase, a plus d'options pour l'int√©gration avec la base de donn√©es et la gestion des informations sensibles (par exemple, il y a une option d'int√©gration avec <em>HashiCorp Vault</em> pour la gestion des secrets). </li></ol><br><p>  Quant aux transactions, du point de vue de l'interface d' <em>Ethereum</em> ordinaire <em>,</em> peu de choses ont chang√© (et c'est bien).  Pour envoyer une transaction priv√©e, en plus des informations habituelles sur la transaction, vous devez √©galement sp√©cifier le param√®tre <strong>privateFor</strong> - il s'agit du <strong>tableau de</strong> lignes, et ces lignes sont des cl√©s publiques du n≈ìud <em>enclave</em> .  √Ä l'aide de ces cl√©s, les transactions de <em>charge utile</em> sont <em>crypt√©es</em> et la charge <em>utile</em> est r√©partie entre les n≈ìuds <strong>Tessera</strong> √† l'int√©rieur de la blockchain. </p><br><p>  Pour une connaissance plus approfondie de <em>Quorum</em> , comment cela fonctionne et comment d√©velopper le r√©seau de blockchain, vous pouvez le trouver sur le site officiel (un lien vers la documentation, ainsi qu'un lien vers le tutoriel sur la fa√ßon de lancer une blockchain de test, je vais laisser √† la fin de l'article). </p><br><h1 id="razrabotka-java-prilozheniya">  D√©veloppement d'applications Java </h1><br><p>  √Ä titre d'exemple, je vais montrer une petite API RESTful √©crite en <em>Java / Spring</em> , avec <em>Gradle</em> comme outil de gestion de construction et de d√©pendance qui chargera le contrat intelligent dans la blockchain, remplira la fonction de changer l'√©tat du contrat et lira l'√©tat du contrat intelligent. </p><br><p>  Avant de commencer le d√©veloppement lui-m√™me, je dois clarifier quelque chose.  Malgr√© le fait que <em>Quorum</em> dispose officiellement de 2 options de transaction, je pr√©f√®re les diviser en 3 types: </p><br><ol><li>  Transactions <em>publiques</em> - les transactions sont enti√®rement visibles pour tous les participants au r√©seau (y compris la <em>charge utile</em> ), le n≈ìud <em>enclave</em> ne participe ni au traitement ni au stockage de la transaction.  Les transactions publiques dans <em>Quorum</em> ne <em>sont</em> pas diff√©rentes des transactions sur le r√©seau <em>Ethereum</em> ; </li><li>  Transactions <em>autoris√©es</em> - les transactions sont essentiellement priv√©es, mais pour plusieurs participants au r√©seau, c'est-√†-dire sur le r√©seau public, nous avons des informations sur la transaction et l'√©tat de son ex√©cution, mais au lieu d'une <em>charge utile</em> r√©elle sur le r√©seau public, nous n'avons qu'une cha√Æne de hachage de 64 bits, qui est un identifiant pour une <em>charge utile</em> r√©elle dans un n≈ìud d' <em>enclave</em> , le n≈ìud d' <em>enclave</em> lui-m√™me est responsable de la signature, du cryptage, du stockage et de la distribution de la <em>charge utile</em> entre les participants √† la transaction sp√©cifi√©s; </li><li>  Transactions <em>priv√©es</em> - diff√®re des <em>autorisations</em> dans la mesure o√π la transaction n'est disponible que pour le n≈ìud qui a cr√©√© cette transaction, les autres participants au r√©seau ne peuvent pas voir les transactions de <em>charge utile</em> . <br>  J'utiliserai cette classification tout au long de l'article. </li></ol><br><p> Pour commencer, je vais vous montrer √† quoi ressemblera le fichier de construction - <code>gradle.build</code> : </p><br><pre> <code class="plaintext hljs">plugins { id 'org.springframework.boot' version '2.1.6.RELEASE' id 'java' } apply plugin: 'io.spring.dependency-management' group = 'com.github' version = '1.0' sourceCompatibility = '1.8' configurations { compileOnly { extendsFrom annotationProcessor } } repositories { mavenCentral() } test { testLogging.showStandardStreams = true } dependencies { implementation 'org.springframework.boot:spring-boot-starter-webflux' implementation group: 'org.web3j', name: 'quorum', version: '4.0.6' implementation group: 'org.web3j', name: 'core', version: '4.1.0' implementation group: 'org.web3j', name: 'codegen', version: '4.1.0' compileOnly 'org.projectlombok:lombok' annotationProcessor 'org.projectlombok:lombok' annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor' testImplementation 'org.springframework.boot:spring-boot-starter-test' testImplementation 'io.projectreactor:reactor-test' } task generateWrappers(type: JavaExec) { group 'Demo' description 'Generates wrappers for smart-contracts' classpath = sourceSets.main.runtimeClasspath main = 'com.github.quorum.utils.WrappersGenerator' }</code> </pre> <br><p>  Un peu d'explication: </p><br><ol><li>  <code>org.web3j.core</code> - d√©pendance pour travailler avec les transactions sur le r√©seau <em>Ethereum</em> et les transactions publiques sur le r√©seau <em>Quorum</em> </li><li>  <code>org.web3j.quorum</code> - d√©pendance pour travailler avec des transactions priv√©es sur le r√©seau <em>Quorum</em> </li><li>  <code>org.web3j.codegen</code> - d√©pendance pour g√©n√©rer des <code>org.web3j.codegen</code> pour les contrats intelligents <em>Solidity</em> </li><li>  <em>generateWrappers</em> - Gradle-task pour g√©n√©rer <em>des</em> wrappers <em>Java √†</em> partir de contrats intelligents <em>Solidity</em> </li></ol><br><p>  Ensuite, je vais vous montrer le code de contrat intelligent qui sera utilis√© dans cet article: Fichier <code>QuorumDemo.sol</code> : </p><br><pre> <code class="plaintext hljs">pragma solidity 0.5.0; /** * @dev Smart-Contract for demonstration purposes. */ contract QuorumDemo { string public user; /** * @dev Rewrite user name in storage. */ function writeUser(string calldata _user) public { user = _user; } }</code> </pre> <br><p>  Le contrat est intentionnellement simplifi√©, mais il suffit aux fins de notre article.  Si vous connaissez <em>Solidity</em> , vous pouvez ignorer l'explication: </p><br><ul><li>  <code>string public user</code> - une variable publique de type <em>cha√Æne</em> et le nom d' <em>utilisateur</em> .  Contrairement √† <em>Java</em> , <em>Solidity</em> g√©n√®re automatiquement un <em>getter</em> pour les variables publiques, vous n'avez donc pas besoin de l'impl√©menter manuellement. </li><li>  <code>function writeUser(...)</code> - la fonction de changer la valeur d'une variable, en fait - <em>setter</em> . </li></ul><br><p>  Pour cr√©er un <code>Java-wrapper</code> partir d'un contrat intelligent, vous devez placer le fichier dans le dossier <code>src/main/solidity/contracts</code> avec n'importe quel nom, par exemple <code>QuorumDemo.sol</code> . <br>  Ensuite, ex√©cutez Gradle-task <em>generateWrappers avec la</em> commande: </p><br><pre> <code class="plaintext hljs">gradle generateWrappers</code> </pre> <br><p>  Une fois cette t√¢che termin√©e, un <em>wrapper Java</em> sera cr√©√© dans <code>src/main/java/com/github/quorum/component/wrappers</code> , avec lequel vous pouvez d√©j√† travailler en code <em>Java</em> . </p><br><p>  Pour que le backend puisse signer des transactions, nous devons pouvoir recevoir des transactions de <em>charge utile</em> avant de les envoyer.  Pour cela, il serait int√©ressant de l'obtenir directement √† partir de la classe <em>Java-wrapper</em> .  Ici, j'ai cr√©√© 2 m√©thodes dans le wrapper.  La premi√®re m√©thode renvoie simplement l' <em>ABI du</em> contrat, qui peut √™tre utilis√© pour t√©l√©charger un nouveau contrat intelligent.  La deuxi√®me m√©thode est la formation d'une transaction pour changer le statut d'un contrat intelligent.  Voici le code de ces m√©thodes: </p><br><pre> <code class="plaintext hljs">public static String getBinary() { return BINARY; } public static String getDataOnWriteUser(final String user) { final Function function = new Function( FUNC_WRITEUSER, Arrays.asList(new Utf8String(user)), Collections.emptyList() ); return FunctionEncoder.encode(function); }</code> </pre> <br><p>  En les ins√©rant dans le <em>wrapper Java</em> g√©n√©r√©, vous pouvez recevoir la <em>charge utile</em> des transactions. </p><br><p>  Ensuite, nous avons besoin d'un moyen pratique d'envoyer des transactions √† la blockchain, de pr√©f√©rence avec la m√™me interface pour les transactions priv√©es et publiques.  Par cons√©quent, j'ai cr√©√© une interface de gestionnaire de transactions et 2 de son impl√©mentation: </p><br><ol><li>  <code>TesseraTransactionManager</code> , pour l'envoi de transactions priv√©es </li><li>  <code>GethTransactionManager</code> , pour l'envoi de transactions publiques </li></ol><br><p>  Prenons-les √† part.  Code <code>TesseraTransactionManager</code> : </p><br><pre> <code class="plaintext hljs">@Slf4j public class TesseraTransactionManager implements TransactionManager { private static final byte ATTEMPTS = 20; private static final int SLEEP_DURATION = 100; private final Quorum quorum; private final String fromAddress; private final QuorumTransactionManager quorumTxManager; private final TransactionReceiptProcessor txReceiptProcessor; public TesseraTransactionManager( Quorum quorum, Credentials credentials, String publicKey, List&lt;String&gt; privateFor, Tessera tessera ) { this.quorum = quorum; this.fromAddress = credentials.getAddress(); this.quorumTxManager = new QuorumTransactionManager(quorum, credentials, publicKey, privateFor, tessera); this.txReceiptProcessor = new PollingTransactionReceiptProcessor(quorum, SLEEP_DURATION, ATTEMPTS); } @Override public TransactionReceipt executeTransaction( final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data) { while (true) { try { final EthSendTransaction ethSendTx = sendTransaction(gasPrice, gasLimit, to, data); if (ethSendTx.hasError() &amp;&amp; NONCE_TOO_LOW_ERROR_MESSAGE.equals(ethSendTx.getError().getMessage())) { log.warn("[BLOCKCHAIN] try to re-send transaction cause error {}", ethSendTx.getError().getMessage()); continue; } return processResponse(ethSendTx); } catch (TransactionException ex) { log.error("[BLOCKCHAIN] exception while receiving TransactionReceipt from Quorum node", ex); throw new RuntimeException(ex); } catch (Exception ex) { log.error("[BLOCKCHAIN] exception while sending transaction to Quorum node", ex); throw new RuntimeException(ex); } } } private EthSendTransaction sendTransaction( final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data) throws IOException { final BigInteger nonce = getNonce(); final RawTransaction rawTransaction = RawTransaction.createTransaction(nonce, gasPrice, gasLimit, to, data); return this.quorumTxManager.signAndSend(rawTransaction); } private TransactionReceipt processResponse(final EthSendTransaction transactionResponse) throws IOException, TransactionException { if (transactionResponse.hasError()) { throw new RuntimeException( "[BLOCKCHAIN] error processing transaction request: " + transactionResponse.getError().getMessage() ); } final String transactionHash = transactionResponse.getTransactionHash(); return this.txReceiptProcessor.waitForTransactionReceipt(transactionHash); } private BigInteger getNonce() throws IOException { final EthGetTransactionCount ethGetTxCount = this.quorum.ethGetTransactionCount( this.fromAddress, DefaultBlockParameterName.PENDING).send(); return ethGetTxCount.getTransactionCount(); } }</code> </pre> <br><ul><li>  <code>TransactionReceipt executeTransaction(...)</code> - impl√©mentation de l'interface, une m√©thode pour effectuer des transactions sur le r√©seau et g√©rer les erreurs si elles se produisent.  Renvoie un objet avec le r√©sultat d'une transaction; </li><li>  <code>EthSendTransaction sendTransaction(...)</code> - une m√©thode pour signer et envoyer des transactions √† la blockchain.  Renvoie un objet avec le statut de transaction et son hachage; </li><li>  <code>TransactionReceipt processResponse(...)</code> - une m√©thode qui attend que la transaction se termine et renvoie <code>TransactionReceipt</code> apr√®s son ex√©cution; </li><li>  <code>BigInteger getNonce()</code> - Retourne "nonce" du r√©seau. </li></ul><br><p>  Et le code <code>GethTransactionManager</code> : </p><br><pre> <code class="plaintext hljs">@Slf4j public class GethTransactionManager extends FastRawTransactionManager implements TransactionManager { private static final byte ATTEMPTS = 20; private static final int SLEEP_DURATION = 100; private final TransactionReceiptProcessor txReceiptProcessor; public GethTransactionManager(Web3j web3j, Credentials credentials) { this(web3j, credentials, new PollingTransactionReceiptProcessor(web3j, SLEEP_DURATION, ATTEMPTS)); } public GethTransactionManager(Web3j web3j, Credentials credentials, TransactionReceiptProcessor txReceiptProcessor) { super(web3j, credentials, txReceiptProcessor); this.txReceiptProcessor = txReceiptProcessor; } @Override public TransactionReceipt executeTransaction( final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data) { while (true) { try { final EthSendTransaction ethSendTx = sendTransaction(gasPrice, gasLimit, to, data, BigInteger.ZERO); if (ethSendTx != null &amp;&amp; ethSendTx.hasError() &amp;&amp; NONCE_TOO_LOW_ERROR_MESSAGE.equals(ethSendTx.getError().getMessage())) { log.warn("[BLOCKCHAIN] try to re-send transaction cause error: {}", ethSendTx.getError().getMessage()); continue; } return this.txReceiptProcessor.waitForTransactionReceipt(ethSendTx.getTransactionHash()); } catch (TransactionException ex) { log.error("[BLOCKCHAIN] exception while receiving TransactionReceipt from Quorum node", ex); throw new RuntimeException(ex); } catch (IOException ex) { log.error("[BLOCKCHAIN] exception while sending transaction to Quorum node", ex); throw new RuntimeException(ex); } } } @Override public EthSendTransaction sendTransaction( final BigInteger gasPrice, final BigInteger gasLimit, final String to, final String data, final BigInteger value ) throws IOException { return super.sendTransaction(gasPrice, gasLimit.add(BigInteger.valueOf(21_000L)), to, data, value); } }</code> </pre> <br><ul><li>  <code>TransactionReceipt executeTransaction(...)</code> - impl√©mentation de l'interface, une m√©thode pour effectuer des transactions sur le r√©seau et g√©rer les erreurs si elles se produisent.  Renvoie un objet avec le r√©sultat d'une transaction; </li><li>  <code>EthSendTransaction sendTransaction(...)</code> est une m√©thode qui appelle la m√©thode <code>EthSendTransaction sendTransaction(...)</code> pour envoyer une transaction √† la blockchain. </li></ul><br><p>  Le gestionnaire des demandes qui parviennent √† l' <em>API</em> : </p><br><pre> <code class="plaintext hljs">@Slf4j @Component public class RequestHandler { private final Web3j web3j; private final Quorum quorum; private final Tessera tessera; private final Credentials credentials; private final BlockchainConfig blockchainConfig; private String deployedContract; @Autowired public RequestHandler( @Qualifier("initWeb3j") Web3j web3j, Quorum quorum, Tessera tessera, Credentials credentials, BlockchainConfig blockchainConfig ) { this.web3j = web3j; this.quorum = quorum; this.tessera = tessera; this.credentials = credentials; this.blockchainConfig = blockchainConfig; } /** * Deploy new smart-contract. * * @param serverRequest * - {@link ServerRequest} object with request information * @return {@link ServerResponse} object with response data */ public Mono&lt;ServerResponse&gt; deployContract(final ServerRequest serverRequest) { return serverRequest .bodyToMono(APIRequest.class) .map(this::getTransactionManager) .map(this::deployContract) .flatMap(this::generateResponse); } private TransactionManager getTransactionManager(final APIRequest apiRequest) { log.info("[HANDLER] privateFor = {}", apiRequest.getPrivateFor()); TransactionManager txManager; if (isPrivate(apiRequest.getPrivateFor())) { if (apiRequest.getPrivateFor().size() == 0) { apiRequest.getPrivateFor().add(this.blockchainConfig.getTesseraPublicKey()); } txManager = new TesseraTransactionManager(this.quorum, this.credentials, this.blockchainConfig.getTesseraPublicKey(), apiRequest.getPrivateFor(), this.tessera); } else { txManager = new GethTransactionManager(this.web3j, this.credentials); } return txManager; } private boolean isPrivate(final List&lt;String&gt; limitedTo) { return limitedTo == null || limitedTo.size() == 0 || !limitedTo.get(0).equals("public"); } private APIResponse deployContract(final TransactionManager txManager) { log.info("[HANDLER] deploying new smart-contract"); final String data = QuorumDemo.getBinary(); final TransactionReceipt txReceipt = txManager.executeTransaction(GAS_PRICE, DEPLOY_GAS_LIMIT, null, data); final APIResponse apiResponse = APIResponse.newInstance(txReceipt); this.deployedContract = txReceipt.getContractAddress(); log.info("[HANDLER] contract has been successfully deployed. Result: {}", apiResponse.getMap()); return apiResponse; } private Mono&lt;ServerResponse&gt; generateResponse(final APIResponse apiResponse) { return ServerResponse .ok() .body(Mono.just(apiResponse.getMap()), Map.class); } /** * Send transaction on update user in smart-contract. * * @param serverRequest * - {@link ServerRequest} object with request information * @return {@link ServerResponse} object with response data */ public Mono&lt;ServerResponse&gt; updateUser(final ServerRequest serverRequest) { return serverRequest .bodyToMono(APIRequest.class) .map(this::sendTransaction) .flatMap(this::generateResponse); } private APIResponse sendTransaction(final APIRequest apiRequest) { final TransactionManager txManager = getTransactionManager(apiRequest); log.info("[HANDLER] sending new transaction"); final String data = QuorumDemo.getDataOnWriteUser(apiRequest.getUser()); final TransactionReceipt txReceipt = txManager.executeTransaction(GAS_PRICE, TX_GAS_LIMIT, this.deployedContract, data); final APIResponse apiResponse = APIResponse.newInstance(txReceipt); log.info("[HANDLER] transaction has been successfully executed. Result: {}", apiResponse.getMap()); return apiResponse; } /** * Read user from smart-contract. * * @param serverRequest * - {@link ServerRequest} object with request information * @return {@link ServerResponse} object with response data */ public Mono&lt;ServerResponse&gt; getUser(final ServerRequest serverRequest) { final APIResponse apiResponse = getUser(); return generateResponse(apiResponse); } private APIResponse getUser() { log.info("[HANDLER] reading user from smart-contract"); final QuorumDemo quorumDemo = QuorumDemo.load(this.deployedContract, this.web3j, this.credentials, new StaticGasProvider(GAS_PRICE, DEPLOY_GAS_LIMIT)); final String user = readUserFromSmartContract(quorumDemo); final APIResponse apiResponse = APIResponse.newInstance(user); log.info("[HANDLER] user: '{}'", user); return apiResponse; } private String readUserFromSmartContract(final QuorumDemo quorumDemo) { try { return quorumDemo.user().send().getValue(); } catch (Exception ex) { log.info("[HANDLER] exception while reading user from smart-contract: {}", ex); return null; } } }</code> </pre> <br><p>  Je vais maintenant expliquer quelles m√©thodes sont responsables de quoi. <br>  <code>Mono&lt;ServerResponse&gt; deployContract(...)</code> m√©thode <code>Mono&lt;ServerResponse&gt; deployContract(...)</code> - d√©crit la logique g√©n√©rale du <code>Mono&lt;ServerResponse&gt; deployContract(...)</code> contrat intelligent, public et priv√©. <br>  <code>TransactionManager getTransactionManager(...)</code> m√©thode <code>TransactionManager getTransactionManager(...)</code> - renvoie l'objet d'impl√©mentation du gestionnaire de transactions en fonction du type de transaction.  Pour cela, le param√®tre request contiendra le param√®tre <strong>privateFor</strong> , qui est un tableau de cha√Ænes de cl√©s publiques <em>Tessera</em> . <br>  <code>boolean isPrivate(...)</code> m√©thode <code>boolean isPrivate(...)</code> - renvoie "true" si le param√®tre <strong>privateFor est</strong> vide (transaction <em>priv√©e</em> ) ou a une liste de cl√©s publiques (transaction <em>autoris√©e</em> ).  Renvoie "false" si le param√®tre <strong>privateFor n'est</strong> pas vide et que le premier √©l√©ment du tableau est √©gal √† "public". <br>  <code>APIResponse deployContract(...)</code> - envoie la transaction de d√©ploiement √† la blockchain. <br>  M√©thode <code>Mono&lt;ServerResponse&gt; generateResponse(...)</code> - g√©n√®re un objet avec une r√©ponse au client. <br>  M√©thode <code>Mono&lt;ServerResponse&gt; updateUser(...)</code> - d√©crit la logique g√©n√©rale de la transaction pour changer le statut du contrat intelligent. <br>  <code>APIResponse sendTransaction(...)</code> - envoie une transaction de changement d'√©tat √† la blockchain. <br>  <code>APIResponse getUser()</code> - d√©crit la logique g√©n√©rale de lecture des informations d'un contrat intelligent et renvoie une r√©ponse au client. <br>  M√©thode de <code>String readUserFromSmartContract(...)</code> - lit l'√©tat du contrat intelligent et renvoie le r√©sultat. </p><br><p>  Le code d'application complet est disponible dans le r√©f√©rentiel <em>GitHub</em> , un lien vers lequel sera √† la fin de cet article. </p><br><h1 id="proverka">  V√©rifier </h1><br><p>  Pour tester les 3 types de transactions, j'ai √©crit des classes de test (le code est dans le d√©p√¥t <em>GitHub</em> ).  Pour ce faire, j'ai d√©ploy√© une blockchain avec 3 n≈ìuds <em>Quorum</em> (3 n≈ìuds <em>Geth</em> + 3 n≈ìuds <em>Tessera</em> ).  3 Les n≈ìuds de <em>quorum</em> sont les n≈ìuds minimaux requis pour v√©rifier tous les types de transactions.  Gardez cela √† l'esprit si vous voulez l'essayer vous-m√™me. </p><br><h2 id="public-tranzakcii">  Transactions publiques </h2><br><p>  Pour ex√©cuter un sc√©nario de test avec une transaction publique, vous devez ex√©cuter la commande suivante: </p><br><pre> <code class="plaintext hljs">gradle test --tests *.PublicTransactionsTests</code> </pre> <br><p>  Ce sc√©nario de test enverra 3 demandes d' <em>API</em> .  Le premier est le d√©ploiement du contrat intelligent sur la blockchain, le second est le changement de statut du contrat et la troisi√®me demande est la lecture des informations du contrat intelligent.  √Ä la suite du test, vous verrez approximativement les journaux suivants (les adresses sur votre r√©seau diff√©reront, ainsi que les hachages de transaction): </p><br><pre> <code class="plaintext hljs">[HANDLER] privateFor = [public] [HANDLER] deploying new smart-contract [HANDLER] contract has been successfully deployed. Result: {contract_address=0xf9425b94e459805da09950f5988071692d925097, transaction_hash=0x31bc179f8cd12c640d1663f3df51ce6da1fbc2875f2b724c3911108fcd19a5d0} [HANDLER] privateFor = [public] [HANDLER] sending new transaction [HANDLER] transaction has been successfully executed. Result: {contract_address=null, transaction_hash=0x33ba66d5deec33f3142bfa190a0d37d0ff07c2e66b06037f5b5ff9578154a3ff} [HANDLER] reading user from smart-contract [HANDLER] user: 'Public Test User'</code> </pre> <br><p>  En g√©n√©ral, ces journaux indiquent que les 3 op√©rations ont r√©ussi.  Les 3 premiers journaux - appartiennent √† la demande de d√©ploiement du contrat intelligent, les 3 prochains journaux - appartiennent √† la transaction et les 2 derniers - pour lire les informations du contrat intelligent. <br>  Le fait que dans le r√©sultat du chargement du contrat, nous voyons <strong>contract_address</strong> , mais dans le cas d'une transaction simple - non, c'est tout √† fait normal, car la deuxi√®me fois, nous ne d√©ployons pas le contrat, mais r√©alisons la transaction sur un contrat intelligent existant. </p><br><p>  <em>V√©rifions</em> maintenant ce que <em>Geth nous</em> montre, <em>ex√©cutons</em> la commande suivante pour nous connecter √† l'interface <em>IPC du</em> processus <em>Geth</em> du client: </p><br><pre> <code class="plaintext hljs">geth attach /path/to/ipc</code> </pre> <br><p>  Une fois que nous nous sommes ¬´habitu√©s¬ª au processus, vous pouvez revoir compl√®tement toutes les informations n√©cessaires.  Examinons la <code>TransactionReceipt</code> TransactionReceipt sur le d√©ploiement d'un nouveau contrat intelligent en ex√©cutant la commande (le hachage de la transaction doit √™tre configur√© et extrait des journaux de test): </p><br><pre> <code class="plaintext hljs">web3.eth.getTransactionReceipt('0x31bc179f8cd12c640d1663f3df51ce6da1fbc2875f2b724c3911108fcd19a5d0');</code> </pre> <br><p>  En cons√©quence, nous voyons ce qui suit: </p><br><p><img src="https://habrastorage.org/webt/so/jm/yw/sojmyw_4gei16afdq47ypzmvtru.png"></p><br><p>  Nous nous int√©ressons aux param√®tres suivants: </p><br><ul><li>  "contractAddress" - sinon "null", alors nous comprenons qu'il s'agit d'une transaction pour le d√©ploiement d'un contrat intelligent; </li><li>  "status" - dans ce cas, il est √©gal √† "0x1" - ce qui signifie que la transaction a r√©ussi. </li></ul><br><p>  Et regardons la transaction elle-m√™me.  En ex√©cutant la commande: </p><br><pre> <code class="plaintext hljs">web3.eth.getTransaction('0x31bc179f8cd12c640d1663f3df51ce6da1fbc2875f2b724c3911108fcd19a5d0');</code> </pre> <br><p>  R√©sultat: </p><br><p><img src="https://habrastorage.org/webt/ju/jq/86/jujq86cugnifanot96ypy_hvusm.png"></p><br><p>  Nous nous int√©ressons ici aux param√®tres suivants: </p><br><ul><li>  "input" est une transaction de <em>charge utile</em> ; </li><li>  "v" - en g√©n√©ral, c'est un param√®tre pour <em>ECDSA</em> , l'algorithme de signature num√©rique, mais maintenant nous nous int√©ressons √† autre chose - la signification de la variable.  C'est important parce que dans les transactions publiques et priv√©es, ce sera diff√©rent.  "0x1c" ("28" dans le syst√®me d√©cimal) et "0x1b" ("27" dans le syst√®me d√©cimal) sont typiques pour les transactions publiques, et "0x25" ("37" dans le syst√®me d√©cimal) et "0x26" ("38" en d√©cimal). syst√®me) - ce sont des codes de transaction priv√©s. </li></ul><br><p>  Vous pouvez √©galement v√©rifier que sur d'autres n≈ìuds, les informations ne diff√®rent pas de ce que nous avons vu maintenant. </p><br><p>  Vous pouvez maintenant afficher les modifications de l'√©tat des transactions du contrat intelligent.  Ex√©cutez la commande: </p><br><pre> <code class="plaintext hljs">web3.eth.getTransactionReceipt('0x33ba66d5deec33f3142bfa190a0d37d0ff07c2e66b06037f5b5ff9578154a3ff');</code> </pre> <br><p>  R√©sultat: </p><br><p><img src="https://habrastorage.org/webt/zz/8g/a-/zz8ga-le8lswmr7vkizq5tu_zog.png"></p><br><p>  Nous nous int√©ressons aux param√®tres suivants: </p><br><ul><li>  "to" - nous voyons que la transaction est all√©e au contrat intelligent tant attendu; </li><li>  "status" - il est √©gal √† "0x1", ce qui signifie que la transaction a r√©ussi. </li></ul><br><p>  Transaction: </p><br><p><img src="https://habrastorage.org/webt/t9/yh/xp/t9yhxp0-hzbkvylmous8p--ft2e.png"></p><br><p>  Rien d'inhabituel, mais vous pouvez v√©rifier les informations sur les autres n≈ìuds, c'est utile. </p><br><h2 id="private-tranzakcii">  Transactions priv√©es </h2><br><p>  Pour ex√©cuter un sc√©nario de test avec une transaction priv√©e, vous devez ex√©cuter la commande suivante: </p><br><pre> <code class="plaintext hljs">gradle test --tests *.PrivateTransactionsTests</code> </pre> <br><p>  Comme dans le cas de test avec les transactions publiques, ce cas de test d√©ploiera un nouveau contrat intelligent, ex√©cutera une transaction de changement d'√©tat et lira les informations du changement dans le contrat intelligent. </p><br><p>  Par cons√©quent, le programme √©crira les journaux suivants: </p><br><pre> <code class="plaintext hljs">[HANDLER] privateFor = [] [HANDLER] deploying new smart-contract [HANDLER] contract has been successfully deployed. Result: {contract_address=0x3e2284d92842f781b83cc7e56fbb074ab15f9a90, transaction_hash=0x8fd619bd9a526f83e29d7b417551e174862f7503ef430eb45793509d05039595} [HANDLER] privateFor = [] [HANDLER] sending new transaction [HANDLER] transaction has been successfully executed. Result: {contract_address=null, transaction_hash=0x72a0458a7b313c8a1c18269ae160e140c6a6e41cb2fd087c64cf665b08a6aefb} [HANDLER] reading user from smart-contract [HANDLER] user: 'Private Test User'</code> </pre> <br><p>  Le changement, par rapport aux transactions publiques, est le param√®tre <strong>privateFor</strong> - il a maintenant la valeur d'un tableau vide. <br>  V√©rifions <code>TransactionReceipt</code> pour une transaction.  √âquipe: </p><br><pre> <code class="plaintext hljs">web3.eth.getTransactionReceipt('0x8fd619bd9a526f83e29d7b417551e174862f7503ef430eb45793509d05039595');</code> </pre> <br><p>  R√©sultat: </p><br><p><img src="https://habrastorage.org/webt/qx/aj/1g/qxaj1gluf9gl-o-rwbwaa6-oww8.png"></p><br><p>  Parmi les changements, par rapport aux transactions publiques, il convient de dire que vous ne verrez pas la quantit√© de gaz d√©pens√©e pour la transaction - <strong>gasUsed</strong> et <strong>cumulativeGasUsed</strong> ont une valeur de "0". <br>  Voyons maintenant la transaction elle-m√™me.  Ex√©cutez la commande: </p><br><pre> <code class="plaintext hljs">web3.eth.getTransaction('0x8fd619bd9a526f83e29d7b417551e174862f7503ef430eb45793509d05039595');</code> </pre> <br><p>  En cons√©quence, nous verrons ceci: </p><br><p><img src="https://habrastorage.org/webt/of/zj/ud/ofzjuds-akmr-koc9ed9dasubnq.png"></p><br><p>  Ce qui m√©rite d'√™tre not√© dans cette transaction: </p><br><ol><li>  Comme je l'ai mentionn√© au d√©but de cet article, au lieu d'une v√©ritable transaction de <em>charge utile</em> , vous verrez une ligne fixe de 64 octets (128 caract√®res) dans le champ de <strong>saisie</strong> .  Cette ligne est l'identifiant des donn√©es dans le r√©f√©rentiel <em>Tessera</em> , vous pouvez obtenir des donn√©es r√©elles sur demande aupr√®s de <em>Tessera</em> . </li><li>  "v" - au lieu des codes "0x1c" ou "0x1b" comme dans les transactions publiques, pour les transactions priv√©es, vous verrez "0x26" ou "0x25". </li></ol><br><p>  V√©rifions maintenant le <code>TransactionReceipt</code> et la transaction elle-m√™me pour changer le statut du contrat (vous connaissez d√©j√† les commandes).  R√©sultat: </p><br><p><img src="https://habrastorage.org/webt/of/zj/ud/ofzjuds-akmr-koc9ed9dasubnq.png"></p><br><p><img src="https://habrastorage.org/webt/cw/mp/vk/cwmpvk3hjzcnh51isapyhecpkf0.png"></p><br><p>  En principe, nous n'apprendrons rien de nouveau de cette transaction priv√©e. </p><br><h2 id="permissioned-tranzakcii">  Transactions autoris√©es </h2><br><p>  Comme il s'agit √©galement de transactions priv√©es, elles sont simplement priv√©es, non pas pour un n≈ìud, mais pour plusieurs, les r√©sultats de ces transactions ne diff√©reront pas des transactions priv√©es.  Vous pouvez faire une diff√©rence si vous essayez d'obtenir des informations d'un n≈ìud qui a √©t√© sp√©cifi√© dans <strong>privateFor</strong> et d'un n≈ìud dont la cl√© publique n'est pas enregistr√©e dans <strong>privateFor</strong> (vous pouvez obtenir des informations du premier n≈ìud et pas du deuxi√®me). <br>  Pour ex√©cuter un sc√©nario de test avec des transactions priv√©es pour plusieurs participants au r√©seau (transactions autoris√©es), vous devez ex√©cuter la commande suivante: </p><br><pre> <code class="plaintext hljs">gradle test --tests *.PermissionTransactionsTests</code> </pre> <br><p>  Journaux de l' <em>API Java</em> : </p><br><pre> <code class="plaintext hljs">[HANDLER] privateFor = [wQTHrl/eqa7TvOz9XJcazsp4ZuncfxHb8c1J1njIOGA=] [HANDLER] deploying new smart-contract [HANDLER] contract has been successfully deployed. Result: {contract_address=0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd, transaction_hash=0x585980bec88aa8a0fe5caffe6d6f24b82d3cd381fcf72fdd8e2102ce67799f01} [HANDLER] privateFor = [wQTHrl/eqa7TvOz9XJcazsp4ZuncfxHb8c1J1njIOGA=] [HANDLER] sending new transaction [HANDLER] transaction has been successfully executed. Result: {contract_address=null, transaction_hash=0x47edc0d00fa9447b2da9f5a78f44602f96145497238cb1ce1d879afb351a3cbe} [HANDLER] reading user from smart-contract [HANDLER] user: 'Permissioned Test User'</code> </pre> <br><p>  Les r√©sultats dans le client <em>Geth</em> , sur le d√©ploiement du nouveau contrat intelligent, <code>TransactionReceipt</code> et la transaction elle-m√™me, respectivement: </p><br><p><img src="https://habrastorage.org/webt/nk/cs/do/nkcsdozorvcuh7gv7kxspwovxmm.png"></p><br><p><img src="https://habrastorage.org/webt/bc/z5/1u/bcz51u6c28aussavjw7fdieayuq.png"></p><br><p>  Et la transaction de changement d'√©tat, <code>TransactionReceipt</code> et la transaction elle-m√™me: </p><br><p><img src="https://habrastorage.org/webt/4f/al/lt/4falltfjniekypa5r38xu8j6tzo.png"></p><br><p><img src="https://habrastorage.org/webt/tq/-s/ta/tq-stauf7_6a00ts7qgkzif0p18.png"></p><br><h3 id="http-zaprosy">  Demandes HTTP </h3><br><p>  Malgr√© le fait que nous avons vu comment les transactions publiques diff√®rent des transactions priv√©es du point de vue du client <em>Geth</em> , cela ne montre pas une r√©elle restriction √† l'obtention d'informations.  Par cons√©quent, afin de vous montrer qu'il est vraiment possible de limiter le nombre de n≈ìuds pouvant lire votre transaction, je vais effectuer plusieurs requ√™tes en utilisant <em>CURL</em> pour 3 n≈ìuds pour lire les informations du smart contract (les requ√™tes concerneront <em>des</em> transactions <em>priv√©es</em> et <em>pers√©cut√©es</em> ). <br>  Les requ√™tes HTTP auront 2 param√®tres dans le corps de la requ√™te: </p><br><ol><li>  "endpoint" - directement le noeud final au noeud <em>Quorum</em> , vous devez vous connecter au noeud. </li><li>  "contractAddress" est l'adresse du contrat √† partir de laquelle les donn√©es seront lues. </li></ol><br><p>  Dans mon cas, "endopint" aura un h√¥te - <em>localhost</em> - mais diff√©rents ports pour 3 n≈ìuds de <em>quorum</em> : 22000 (toutes les transactions ont √©t√© effectu√©es √† partir de ce n≈ìud), 22001 (sa cl√© publique a √©t√© sp√©cifi√©e dans les transactions autoris√©es), 22002 (ne devrait pas avoir acc√®s √† informations). </p><br><p>  Commen√ßons par une transaction <em>priv√©e</em> (seul un n≈ìud sur le port 22000 devrait pouvoir afficher les informations dans un contrat intelligent). </p><br><p>  Demande <em>CURL</em> sur le n≈ìud qui a effectu√© la transaction: </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22000", "contractAddress": "0x3e2284d92842f781b83cc7e56fbb074ab15f9a90" }'</code> </pre> <br><p>  En cons√©quence, nous avons obtenu ce qui suit: </p><br><pre> <code class="plaintext hljs">{"data":{"user":"Private Test User"}}</code> </pre> <br><p>  Cela signifie que le n≈ìud a la possibilit√© de visualiser les informations dans un contrat intelligent. </p><br><p>  Voyons maintenant ce que le n≈ìud du port 22001 nous renvoie.  Demande <em>CURL</em> : </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22001", "contractAddress": "0x3e2284d92842f781b83cc7e56fbb074ab15f9a90" }'</code> </pre> <br><p>  Super!        : </p><br><pre> <code class="plaintext hljs">{"data":{"status_code":500,"description":"Something went wrong"}}</code> </pre> <br><p>     ,        - ‚Äî    ! </p><br><p>     , 3- . <em>CURL</em> : </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22002", "contractAddress": "0x3e2284d92842f781b83cc7e56fbb074ab15f9a90" }'</code> </pre> <br><p>  Super! API  : </p><br><pre> <code class="plaintext hljs">{"data":{"status_code":500,"description":"Something went wrong"}}</code> </pre> <br><p>   ,        .     "permissioned" . </p><br><p>  <em>CURL</em>       "permissioned" -  ,    22000: </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22000", "contractAddress": "0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd" }'</code> </pre> <br><p> : </p><br><pre> <code class="plaintext hljs">{"data":{"user":"Permissioned Test User"}}</code> </pre> <br><p>  ,         ,   ,       . </p><br><p>       -   ,         -,       . <em>CURL</em> : </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22001", "contractAddress": "0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd" }'</code> </pre> <br><p>  Super!         : </p><br><pre> <code class="plaintext hljs">{"data":{"user":"Permissioned Test User"}}</code> </pre> <br><p>      ,          ,    . <em>CURL</em> : </p><br><pre> <code class="plaintext hljs">curl -X POST \ http://127.0.0.1:8080/user \ -H 'Content-Type: application/json' \ -d '{ "endpoint": "http://127.0.0.1:22002", "contractAddress": "0xf1cc0ba22bd0d18fc9acb22dd57795a3f2fb4ebd" }'</code> </pre> <br><p>  Super!         -.    . </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>      ,    <em>Quorum blockchain</em>   Java .      ,    -     . </p><br><p>   : </p><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation sur le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quorum</font></font></em></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©seau de test de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quorum</font></font></em></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></em></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canal de </font><em><font style="vertical-align: inherit;">quorum</font></em><font style="vertical-align: inherit;"> dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slack</font></font></em></a> </li></ol><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Merci de votre attention! </font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462549/">https://habr.com/ru/post/fr462549/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462539/index.html">√âvitez la trigonom√©trie</a></li>
<li><a href="../fr462541/index.html">Utilisation du conditionnel au printemps</a></li>
<li><a href="../fr462543/index.html">Meetup Java √† Raiffeisenbank</a></li>
<li><a href="../fr462545/index.html">Blocage des t√©l√©grammes, sous-r√©seau Hetzner / 16, exp√©rience avec ILV</a></li>
<li><a href="../fr462547/index.html">SGX Malvar: comment les m√©chants exploitent la nouvelle technologie d'Intel √† de mauvaises fins</a></li>
<li><a href="../fr462551/index.html">Questions fr√©quentes des d√©veloppeurs sur les tests</a></li>
<li><a href="../fr462553/index.html">Un peu simple. Conception de test. Partie 1</a></li>
<li><a href="../fr462555/index.html">Discussion: que faire si vous travaillez sans cookies - nous vous disons quelles sont les alternatives</a></li>
<li><a href="../fr462563/index.html">Webinaire ¬´Comment survivre √† la conformit√©?¬ª La meilleure approche pour r√©pondre aux exigences r√©glementaires ¬ª</a></li>
<li><a href="../fr462565/index.html">Comment pr√©parer les donn√©es pour SAP Process Mining by Celonis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>