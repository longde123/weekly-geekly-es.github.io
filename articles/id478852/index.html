<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪🏻 🔛 🕝 Pengantar GitOps untuk OpenShift 👩🏼‍🔬 💃🏼 📁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kita akan berbicara tentang prinsip dan model GitOps, serta bagaimana model ini diimplementasikan pada platform OpenShift. Panduan online unt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar GitOps untuk OpenShift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/478852/">  Hari ini kita akan berbicara tentang prinsip dan model GitOps, serta bagaimana model ini diimplementasikan pada platform OpenShift.  Panduan online untuk topik ini tersedia di <a href="https://learn.openshift.com/introduction/gitops-introduction/%3FextIdCarryOver%3Dtrue%26sc_cid%3D701f2000001OH74AAG">sini</a> . <br><br><img src="https://habrastorage.org/webt/sk/g4/vk/skg4vkilbd51gs_dk6vk3-emy2o.jpeg" width="100%"><br><br>  Singkatnya, GitOps adalah serangkaian metode praktis untuk menggunakan permintaan tarikan Git untuk mengelola infrastruktur dan konfigurasi aplikasi.  Repositori Git dalam GitOps dianggap sebagai satu sumber tunggal informasi tentang status sistem, dan setiap perubahan dalam status ini dipantau dan diaudit sepenuhnya. <br><a name="habracut"></a><br>  Gagasan pelacakan perubahan di GitOps sama sekali tidak baru, pendekatan ini telah lama digunakan hampir di mana-mana ketika bekerja dengan kode sumber aplikasi.  GitOps hanya mengimplementasikan fungsi yang serupa (memeriksa pemeriksaan, menarik permintaan, tag, dll.) Ketika mengelola infrastruktur dan konfigurasi aplikasi dan memberikan keuntungan yang sama seperti dalam hal pengelolaan kode sumber. <br><br>  Untuk GitOps, tidak ada definisi akademis atau seperangkat aturan yang disetujui, hanya seperangkat prinsip yang menjadi dasar praktik ini: <br><br><ul><li>  Deskripsi deklaratif dari sistem disimpan dalam repositori Git (konfigurasi, pemantauan, dll.). </li><li>  Perubahan status dilakukan melalui permintaan tarik. </li><li>  Keadaan sistem yang berjalan selaras dengan data dalam repositori menggunakan permintaan push Git. </li></ul><br><h3>  Prinsip GitOps </h3><br><ul><li>  <b>Definisi sistem digambarkan sebagai kode sumber.</b> </li></ul><br>  Konfigurasi sistem dianggap sebagai kode, sehingga dapat disimpan dan secara otomatis diversi dalam repositori Git, yang berfungsi sebagai satu-satunya sumber kebenaran.  Pendekatan ini memudahkan untuk meluncurkan dan mengembalikan perubahan ke sistem. <br><br><ul><li>  <b>Keadaan yang diinginkan dan konfigurasi sistem diatur dan diversi dalam Git</b> </li></ul><br>  Dengan menyimpan dan membuat versi dalam Git keadaan sistem yang diinginkan, kami mendapatkan kemampuan untuk dengan mudah menggulung dan mengembalikan perubahan ke sistem dan aplikasi.  Kami juga dapat menggunakan mekanisme keamanan Git untuk mengontrol kepemilikan kode dan memverifikasi keasliannya. <br><br><ul><li>  <b>Perubahan konfigurasi dapat diterapkan secara otomatis menggunakan permintaan tarik.</b> </li></ul><br>  Menggunakan permintaan Git pull, kita dapat dengan mudah mengontrol bagaimana perubahan diterapkan pada konfigurasi dalam repositori.  Misalnya, mereka dapat dikirim untuk verifikasi ke anggota tim lain atau dijalankan melalui tes CI, dll. <br><br>  Dan pada saat yang sama Anda tidak perlu memberikan otoritas admin ke kanan dan kiri.  Untuk melakukan perubahan konfigurasi, pengguna memiliki izin yang cukup di repositori Git tempat konfigurasi ini disimpan. <br><br><ul><li>  <b>Perbaiki Konfigurasi Drift yang Tidak Terkontrol</b> </li></ul><br>  Ketika keadaan yang diinginkan dari sistem disimpan dalam repositori Git, kita hanya dapat menemukan perangkat lunak yang akan mengontrol bahwa keadaan sistem saat ini sesuai dengan keadaan yang diinginkan.  Jika tidak, maka perangkat lunak ini harus - tergantung pada pengaturan - baik memperbaiki perbedaan sendiri atau memberi tahu kami tentang penyimpangan konfigurasi. <br><br><h3>  Model GitOps untuk OpenShift </h3><br><h4>  Rekonsiliasi Sumber Daya On-Cluster </h4><br>  Menurut model ini, cluster memiliki pengontrol yang bertanggung jawab untuk membandingkan sumber daya Kubernetes (file YAML) di repositori Git dengan sumber daya cluster nyata.  Dalam hal perbedaan, pengontrol mengirimkan pemberitahuan dan, mungkin, mengambil tindakan untuk menghilangkan ketidakkonsistenan.  Model GitOps ini digunakan oleh Anthos Config Management dan Weaveworks Flux. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/c9/p2/lhc9p2tphyarqpe6jrsh10fgo7e.png"></div><br><br><h4>  Rekonsiliasi Sumber Daya Eksternal (Push) </h4><br>  Model ini dapat dianggap sebagai variasi dari yang sebelumnya, ketika kami memiliki satu atau lebih pengontrol yang bertanggung jawab untuk menyinkronkan sumber daya berpasangan "Git repository - Kubernetes cluster".  Perbedaannya di sini adalah bahwa setiap cluster yang dikelola tidak harus memiliki pengontrol terpisah.  Pasangan kluster Git - k8s sering didefinisikan sebagai CRD definisi sumber daya khusus, yang menggambarkan bagaimana pengontrol harus melakukan sinkronisasi.  Dalam model ini, pengontrol membandingkan repositori Git yang ditentukan dalam CRD dengan sumber daya dari cluster Kubernetes, yang juga didefinisikan dalam CRD, dan melakukan tindakan yang sesuai berdasarkan hasil perbandingan.  Secara khusus, model GitOps digunakan dalam ArgoCD. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/51/ip/zw51ipo5hqcn8ccnc8vfqkqbc88.png"></div><br><br><h3>  GitOps pada Platform OpenShift </h3><br><h4>  Administrasi Infrastruktur Multicluster Kubernetes </h4><br>  Dengan penyebaran Kubernetes dan semakin populernya strategi multi-cloud dan komputasi tepi, jumlah rata-rata cluster OpenShift per pelanggan juga meningkat. <br><br>  Misalnya, saat menggunakan komputasi periferal, kelompok pelanggan tunggal dapat digunakan dalam ratusan atau bahkan ribuan.  Akibatnya, ia dipaksa untuk mengelola beberapa cluster OpenShift yang independen atau terkoordinasi di cloud publik dan di lokasi. <br><br>  Pada saat yang sama, banyak masalah yang harus diselesaikan, khususnya: <br><br><ul><li>  Untuk mengontrol bahwa cluster berada dalam kondisi yang identik (konfigurasi, pemantauan, penyimpanan, dll.) </li><li>  Menciptakan kembali (atau mengembalikan) cluster sesuai dengan kondisi yang diketahui. </li><li>  Buat cluster baru sesuai dengan kondisi yang diketahui. </li><li>  Tarik perubahan pada beberapa cluster OpenShift. </li><li>  Kembalikan perubahan ke beberapa kluster OpenShift. </li><li>  Tautan konfigurasi berpola dengan lingkungan yang berbeda. </li></ul><br><h4>  Konfigurasi aplikasi </h4><br>  Selama siklus hidup mereka, aplikasi sering melewati rantai cluster (dev, stage, dll) sebelum mereka masuk ke cluster produksi.  Selain itu, karena persyaratan ketersediaan dan skalabilitas, pelanggan sering menggunakan aplikasi pada beberapa kluster di lokasi atau di beberapa wilayah platform cloud publik. <br><br>  Dalam hal ini, tugas-tugas berikut harus diselesaikan: <br><ul><li>  Pastikan perpindahan aplikasi (binari, konfigurasi, dll.) Antar kluster (dev, stage, dll.). </li><li>  Gabungkan perubahan dalam aplikasi (binari, konfigurasi, dll.) Di beberapa cluster OpenShift. </li><li>  Kembalikan perubahan dalam aplikasi ke tingkat kondisi yang diketahui sebelumnya. </li></ul><br><h3>  Skenario Penggunaan OpenShift GitOps </h3><br><h4>  1. Terapkan perubahan dari repositori Git </h4><br>  Administrator cluster dapat menyimpan konfigurasi cluster OpenShift di repositori Git dan secara otomatis menerapkannya untuk membuat cluster baru tanpa usaha ekstra dan membawanya ke kondisi yang identik dengan kondisi yang diketahui yang tersimpan dalam repositori Git. <br><br><h4>  2. Sinkronkan dengan Manajer Rahasia </h4><br>  Administrator juga akan merasa berguna untuk menyinkronkan objek rahasia OpenShift dengan perangkat lunak yang sesuai seperti Vault untuk mengelolanya menggunakan alat yang dibuat khusus untuk ini. <br><br><h4>  3. Kontrol konfigurasi drift </h4><br>  Admin hanya akan mendukung jika OpenShift GitOps akan mendeteksi dan memperingatkan tentang perbedaan antara konfigurasi nyata dan yang ditentukan dalam repositori, sehingga Anda dapat dengan cepat menanggapi penyimpangan. <br><br><h4>  4. Notifikasi Drift Konfigurasi </h4><br>  Ini akan sangat berguna ketika admin ingin mencari tahu tentang konfigurasi drift dengan cepat untuk mengambil tindakan yang tepat sendiri. <br><br><h4>  5. Sinkronisasi manual konfigurasi saat melayang </h4><br>  Mengizinkan administrator untuk menyinkronkan klaster OpenShift dengan repositori Git jika terjadi konfigurasi melayang untuk mengembalikan kluster dengan cepat ke kondisi yang diketahui sebelumnya. <br><br><h4>  6. Sinkronisasi otomatis dari konfigurasi drift </h4><br>  Administrator juga dapat mengonfigurasi OpenShift cluster untuk secara otomatis menyinkronkan dengan repositori ketika drift terdeteksi, sehingga konfigurasi cluster selalu cocok dengan konfigurasi di Git. <br><br><h4>  7. Beberapa Cluster - Satu Repositori </h4><br>  Admin dapat menyimpan konfigurasi beberapa cluster OpenShift yang berbeda dalam satu repositori Git dan menerapkannya secara selektif sesuai kebutuhan. <br><br><h4>  8. Hierarki konfigurasi cluster (pewarisan) </h4><br>  Admin dapat mengatur hierarki konfigurasi cluster di repositori (stage, prod, portofolio aplikasi, dll. Dengan pewarisan).  Dengan kata lain, ini dapat menentukan bagaimana konfigurasi harus diterapkan - ke satu atau beberapa cluster. <br><br>  Misalnya, jika administrator menetapkan hierarki "Cluster Produksi (prod) → Cluster Sistem X → Cluster Produksi Sistem X" di repositori Git, maka konfigurasi berikut diterapkan pada kluster produksi System X: <br><br><ul><li>  Konfigurasi umum untuk semua kluster produksi. </li><li>  Konfigurasi untuk sistem cluster X. </li><li>  Konfigurasi untuk kluster produksi sistem X. </li></ul><br><h4>  9. Pola dan konfigurasi menimpa </h4><br>  Administrator dapat mengesampingkan set konfigurasi yang diwariskan dan nilainya, misalnya, untuk menyempurnakan konfigurasi untuk kluster tertentu yang akan diterapkan. <br><br><h4>  10. Termasuk secara selektif dan pengecualian untuk konfigurasi, konfigurasi aplikasi </h4><br>  Administrator dapat mengatur kondisi untuk menerapkan atau tidak menerapkan konfigurasi tertentu untuk kluster dengan karakteristik tertentu. <br><br><h4>  11. Dukungan pola </h4><br>  Pengembang akan merasa berguna untuk memilih bagaimana sumber daya aplikasi akan ditentukan (Helm Chart, murni Kubernetes yaml, dll.) Untuk menggunakan format yang paling cocok untuk setiap aplikasi spesifik. <br><br><h3>  Alat GitOps pada platform OpenShift </h3><br><h4>  Argocd </h4><br>  ArgoCD mengimplementasikan model Rekonsiliasi Sumber Daya Eksternal dan menawarkan UI terpusat untuk mengatur hubungan antara cluster dan repositori Git dengan cara satu-ke-banyak.  Kerugian dari program ini termasuk ketidakmampuan untuk mengelola aplikasi sementara ArgoCD tidak berfungsi. <br><br>  <a href="https://argoproj.github.io/argo-cd/">Situs web resmi</a> <br><br><h4>  Fluks </h4><br>  Flux mengimplementasikan model On-Cluster Resource Reconcile, dan sebagai hasilnya, tidak ada manajemen terpusat dari repositori definisi, yang merupakan titik lemah.  Di sisi lain, justru karena kurangnya sentralisasi, kemampuan untuk mengelola aplikasi dipertahankan bahkan ketika satu cluster gagal. <br><br>  <a href="https://fluxcd.io/">Situs web resmi</a> <br><br><h3>  Instal ArgoCD pada OpenShift </h3><br>  ArgoCD menawarkan antarmuka baris perintah dan konsol web yang sangat baik, jadi kami tidak akan mempertimbangkan Flux dan alternatif lain di sini. <br><br>  Untuk menggunakan ArgoCD pada platform OpenShift 4, ikuti langkah-langkah ini sebagai administrator cluster: <br><br><h4>  Menyebarkan komponen ArgoCD pada platform OpenShift </h4><br><pre><code class="plaintext hljs"># Create a new namespace for ArgoCD components oc create namespace argocd # Apply the ArgoCD Install Manifest oc -n argocd apply -f https://raw.githubusercontent.com/argoproj/argo-cd/v1.2.2/manifests/install.yaml # Get the ArgoCD Server password ARGOCD_SERVER_PASSWORD=$(oc -n argocd get pod -l "app.kubernetes.io/name=argocd-server" -o jsonpath='{.items[*].metadata.name}')</code> </pre> <br><h4>  Perbaikan Server ArgoCD agar dilihat oleh OpenShift Route </h4><br><pre> <code class="plaintext hljs"># Patch ArgoCD Server so no TLS is configured on the server (--insecure) PATCH='{"spec":{"template":{"spec":{"$setElementOrder/containers":[{"name":"argocd-server"}],"containers":[{"command":["argocd-server","--insecure","--staticassets","/shared/app"],"name":"argocd-server"}]}}}}' oc -n argocd patch deployment argocd-server -p $PATCH # Expose the ArgoCD Server using an Edge OpenShift Route so TLS is used for incoming connections oc -n argocd create route edge argocd-server --service=argocd-server --port=http --insecure-policy=Redirect</code> </pre> <br><h4>  Menyebarkan ArgoCD Cli Tool </h4><br><pre> <code class="plaintext hljs"># Download the argocd binary, place it under /usr/local/bin and give it execution permissions curl -L https://github.com/argoproj/argo-cd/releases/download/v1.2.2/argocd-linux-amd64 -o /usr/local/bin/argocd chmod +x /usr/local/bin/argocd</code> </pre> <br><h4>  Ubah kata sandi admin, ArgoCD Server </h4><br><pre> <code class="plaintext hljs"># Get ArgoCD Server Route Hostname ARGOCD_ROUTE=$(oc -n argocd get route argocd-server -o jsonpath='{.spec.host}') # Login with the current admin password argocd --insecure --grpc-web login ${ARGOCD_ROUTE}:443 --username admin --password ${ARGOCD_SERVER_PASSWORD} # Update admin's password argocd --insecure --grpc-web --server ${ARGOCD_ROUTE}:443 account update-password --current-password ${ARGOCD_SERVER_PASSWORD} --new-password</code> </pre> <br>  Setelah menyelesaikan langkah-langkah ini, Anda dapat bekerja dengan ArgoCD Server melalui konsol web ArgoCD WebUI atau alat baris perintah ArgoCD Cli. <br>  <a href="https://blog.openshift.com/is-it-too-late-to-integrate-gitops/">https://blog.openshift.com/is-it-too-late-to-integrate-gitops/</a> <br><br><h3>  GitOps - Tidak Pernah Terlambat </h3><br>  “Kereta telah pergi” - inilah yang mereka katakan tentang situasi ketika kesempatan untuk melakukan sesuatu terlewatkan.  Dalam kasus OpenShift, keinginan untuk segera mulai menggunakan platform keren baru ini sering kali menciptakan situasi seperti itu dengan pengelolaan dan pemeliharaan rute, penyebaran, dan objek OpenShift lainnya.  Tetapi apakah peluang selalu benar-benar terlewatkan? <br><br>  Melanjutkan serangkaian artikel tentang <a href="https://blog.openshift.com/introduction-to-gitops-with-openshift/">GitOps</a> , hari ini kami akan menunjukkan cara mengubah aplikasi yang dibuat secara manual dan sumber dayanya menjadi proses tertentu di mana GitOps toolkit mengontrol semuanya.  Untuk melakukan ini, pertama-tama kita menggunakan aplikasi httpd dengan tangan kita.  Tangkapan layar di bawah ini menunjukkan bagaimana kami membuat namespace, penyebaran, dan layanan, dan kemudian mengekspos layanan ini untuk membuat rute. <br><br><pre> <code class="plaintext hljs">oc create -f https://raw.githubusercontent.com/openshift/federation-dev/master/labs/lab-4-assets/namespace.yaml oc create -f https://raw.githubusercontent.com/openshift/federation-dev/master/labs/lab-4-assets/deployment.yaml oc create -f https://raw.githubusercontent.com/openshift/federation-dev/master/labs/lab-4-assets/service.yaml oc expose svc/httpd -n simple-app</code> </pre> <br>  Jadi, kami memiliki aplikasi yang dibuat secara manual.  Sekarang itu harus ditransfer di bawah kendali GitOps tanpa kehilangan ketersediaan.  Singkatnya, ia melakukan ini: <br><br><ul><li>  Buat repositori Git untuk kode tersebut. </li><li>  Kami mengekspor objek kami saat ini dan memuatnya ke repositori Git. </li><li>  Pilih dan gunakan toolkit GitOps. </li><li>  Tambahkan repositori kami ke toolkit ini. </li><li>  Kami mendefinisikan aplikasi di toolkit GitOps kami. </li><li>  Lakukan uji coba aplikasi menggunakan GitOps toolkit. </li><li>  Kami menyinkronkan objek menggunakan toolkit GitOps. </li><li>  Kami mengaktifkan pemangkasan dan sinkronisasi otomatis objek. </li></ul><br>  Seperti yang disebutkan dalam <a href="https://blog.openshift.com/introduction-to-gitops-with-openshift/">artikel</a> sebelumnya, GitOps memiliki satu dan hanya satu sumber informasi tentang semua objek di kluster Kubernet (s) - repositori Git.  Selanjutnya, kami melanjutkan dari premis bahwa organisasi Anda sudah menggunakan repositori Git.  Ini bisa publik atau pribadi, tetapi harus tersedia untuk cluster Kubernetes.  Ini bisa menjadi repositori yang sama dengan kode aplikasi, atau repositori terpisah yang dibuat khusus untuk penyebaran.  Disarankan agar Anda memiliki izin ketat di repositori, karena objek rahasia, rute, dan hal-hal sensitif keamanan lainnya akan disimpan di sana. <br><br>  Dalam contoh kita, kita akan membuat repositori publik baru di GitHub.  Anda dapat memberi nama apa pun yang Anda suka, kami menggunakan nama blogpost. <br><br>  Jika file YAML objek tidak disimpan secara lokal atau di Git, Anda harus menggunakan binari oc atau kubectl.  Pada tangkapan layar di bawah, kami meminta YAML untuk namespace, penyebaran, layanan, dan rute kami.  Sebelum itu, kami mengkloning repositori yang baru dibuat dan pindah ke sana dengan perintah cd. <br><br><pre> <code class="plaintext hljs">oc get namespace simple-app -o yaml --export &gt; namespace.yaml oc get deployment httpd -o yaml -n simple-app --export &gt; deployment.yaml oc get service httpd -o yaml -n simple-app --export &gt; service.yaml oc get route httpd -o yaml -n simple-app --export &gt; route.yaml</code> </pre> <br>  Sekarang perbaiki file deployment.yaml untuk menghapus bidang yang tidak dapat disinkronkan oleh Argo CD. <br><br><pre> <code class="plaintext hljs">sed -i '/\sgeneration: .*/d' deployment.yaml</code> </pre> <br>  Selain itu, Anda perlu mengubah rute.  Kami pertama-tama akan mengatur variabel multiline, dan kemudian mengganti masuknya: null dengan isi dari variabel ini. <br><br><pre> <code class="plaintext hljs">export ROUTE=" ingress:\\ - conditions:\\ - status: 'True'\\ type: Admitted" sed -i "s/ ingress: null/$ROUTE/g" route.yaml</code> </pre> <br>  Jadi, dengan file yang diurutkan, masih menyimpannya di repositori Git.  Setelah itu, repositori ini menjadi satu-satunya sumber informasi, dan segala perubahan manual pada objek harus dilarang keras. <br><br><pre> <code class="plaintext hljs">git commit -am 'initial commit of objects' git push origin master</code> </pre> <br>  Selanjutnya, kami melanjutkan dari fakta bahwa ArgoCD sudah digunakan untuk Anda (bagaimana melakukan ini, lihat <a href="https://blog.openshift.com/introduction-to-gitops-with-openshift/">posting</a> sebelumnya).  Oleh karena itu, kami menambah CD Argo repositori yang kami buat yang berisi kode aplikasi dari contoh kami.  Pastikan Anda menentukan repositori yang Anda buat sebelumnya. <br><br><pre> <code class="plaintext hljs">argocd repo add https://github.com/cooktheryan/blogpost</code> </pre> <br>  Sekarang buat aplikasinya.  Aplikasi menetapkan nilai sehingga GitOps toolkit memahami repositori dan jalur mana yang harus digunakan, yang OpenShift diperlukan untuk mengelola objek, serta cabang repositori tertentu yang diperlukan, dan apakah sumber daya harus disinkronkan secara otomatis. <br><br><pre> <code class="plaintext hljs">argocd app create --project default \ --name simple-app --repo https://github.com/cooktheryan/blogpost.git \ --path . --dest-server https://kubernetes.default.svc \ --dest-namespace simple-app --revision master --sync-policy none</code> </pre> <br>  Setelah aplikasi ditentukan dalam CD Argo, toolkit ini mulai memeriksa objek yang sudah dikerahkan untuk kepatuhan dengan definisi dalam repositori.  Dalam contoh kami, sinkronisasi otomatis dan pembersihan dinonaktifkan, sehingga elemen-elemennya belum berubah.  Harap dicatat bahwa di antarmuka Argo CD, aplikasi kami akan memiliki status "Tidak Sinkron" (Tidak disinkronkan), karena tidak ada label label yang ditempelkan ArgoCD. <br>  Itulah sebabnya, ketika kami memulai sinkronisasi beberapa saat kemudian, penempatan kembali objek tidak akan dilakukan. <br><br>  Sekarang jalankan uji coba untuk memastikan bahwa tidak ada kesalahan dalam file kami. <br><br><pre> <code class="plaintext hljs">argocd app sync simple-app --dry-run</code> </pre> <br>  Jika tidak ada kesalahan, maka Anda dapat melanjutkan ke sinkronisasi. <br><br><pre> <code class="plaintext hljs">argocd app sync simple-app</code> </pre> <br>  Setelah menjalankan perintah get argocd pada aplikasi kita, kita akan melihat bahwa status aplikasi telah berubah menjadi Healthy or Synced.  Ini berarti bahwa semua sumber daya di repositori Git sekarang sesuai dengan sumber daya yang sudah digunakan. <br><br><pre> <code class="plaintext hljs">argocd app get simple-app Name: simple-app Project: default Server: https://kubernetes.default.svc Namespace: simple-app URL: https://argocd-server-route-argocd.apps.example.com/applications/simple-app Repo: https://github.com/cooktheryan/blogpost.git Target: master Path: . Sync Policy: &lt;none&gt; Sync Status: Synced to master (60e1678) Health Status: Healthy ...</code> </pre> <br>  Tetapi sekarang Anda dapat mengaktifkan sinkronisasi dan pembersihan otomatis untuk memastikan bahwa tidak ada yang akan dibuat secara manual dan bahwa setiap kali objek dibuat atau diperbarui dalam repositori, penyebaran akan dilakukan. <br><br><pre> <code class="plaintext hljs">argocd app set simple-app --sync-policy automated --auto-prune</code> </pre> <br>  Jadi, kami berhasil mentransfer ke aplikasi GitOps yang awalnya tidak menggunakan GitOps. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id478852/">https://habr.com/ru/post/id478852/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id478840/index.html">Di mana penciptaan pasar dimulai. Bagian dua</a></li>
<li><a href="../id478844/index.html">Ketakutan dan Kebencian pada IT</a></li>
<li><a href="../id478846/index.html">Systemd, skrip dan timer interaktif</a></li>
<li><a href="../id478848/index.html">Evolusi fotografi digital</a></li>
<li><a href="../id478850/index.html">Penamaan Kotak CSS</a></li>
<li><a href="../id478854/index.html">Pertempuran server web. Bagian 1 - HTTP bercerai dari kenyataan:</a></li>
<li><a href="../id478856/index.html">SD-WAN - tren dan perkiraan terkini untuk tahun 2020</a></li>
<li><a href="../id478858/index.html">Membandingkan Sesi Pembuatan Profil di Admin XHProf</a></li>
<li><a href="../id478862/index.html">Bagaimana pengujian frontend diatur di Yandex.Market dan mengapa kami menolak rilis mingguan</a></li>
<li><a href="../id478866/index.html">Meet Space - Produk Baru dari JetBrains</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>