<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò• ‚¨ÜÔ∏è üë®‚Äçüë®‚Äçüë¶‚Äçüë¶ Sobre a quest√£o da multiplica√ß√£o, extra√ß√£o de raiz quadrada, substitui√ß√£o de importa√ß√µes e a empresa Milander üë®üèø‚Äçüî¨ üë© üíΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúEntropia, uma fonte erg√≥dica, um espa√ßo de mensagem multidimensional, bits, polissemia, o processo de Markov - todas essas palavras soam muito impres...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sobre a quest√£o da multiplica√ß√£o, extra√ß√£o de raiz quadrada, substitui√ß√£o de importa√ß√µes e a empresa Milander</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437326/"><h4>  ‚ÄúEntropia, uma fonte erg√≥dica, um espa√ßo de mensagem multidimensional, bits, polissemia, o processo de Markov - todas essas palavras soam muito impressionantes, em qualquer ordem em que forem colocadas.  Se voc√™ organiz√°-los na ordem correta, eles adquirem um determinado conte√∫do te√≥rico.  E um especialista de verdade √†s vezes pode encontrar uma solu√ß√£o para os problemas pr√°ticos do dia a dia com a ajuda deles. ‚Äù <br><br>  John PIRS "N√£o vejo o mal" <br></h4><br>  Este post est√° cheio de discuss√µes sobre a otimiza√ß√£o sutil de opera√ß√µes matem√°ticas no MK com recursos limitados, bem como avalia√ß√µes subjetivas de v√°rios aspectos do desenvolvimento de software incorporado. <br><br>  Aqueles a quem esse aviso n√£o assustou, pergunto em gato. <br><a name="habracut"></a><br>  Antes de continuarmos a descrever o procedimento para extrair uma raiz quadrada de um n√∫mero inteiro, a opera√ß√£o √© inversa ao quadrado e, consequentemente, multiplicada, vamos falar sobre o √∫ltimo. <br><br>  Suponha que tenhamos a oportunidade de multiplicar um n√∫mero de 8 bits por um n√∫mero de 8 bits, obtendo um resultado de 16 bits (8 * 8 = 16), como podemos obter a implementa√ß√£o da opera√ß√£o 16 * 16 = 32 com base nessa opera√ß√£o.  A maneira √≥bvia √© representar 16 como a soma de dois 8, ent√£o obtemos <br><br> <code>(16)*(16)=(1(8)*256+2(8))*1(8)*256+2(8)) =1*1*256*256+1*2*256+2*1*256+2*2</code> <br> <br>  Se na express√£o resultante substituirmos a multiplica√ß√£o por 256 por um deslocamento √† esquerda por 8 d√≠gitos, obteremos um algoritmo completamente funcional.  Vamos estimar o tempo gasto na implementa√ß√£o - precisamos de 4 multiplica√ß√µes de 8 * 8 = 16 e 4 adi√ß√µes de n√∫meros de 4 bytes 32 + 32 = 32.  Para o AVR do tipo MK, obtemos 4 * 2 + 4 * 4 = 24 ciclos, mas isso √© para uma solu√ß√£o "frontal".  Vamos tentar melhorar o resultado.  O fato de n√£o precisarmos de 4, mas de 3 adi√ß√µes e uma atribui√ß√£o simplifica um pouco a situa√ß√£o, j√° que o zeramento inicial do resultado n√£o √© necess√°rio, mas ainda n√£o o levamos em considera√ß√£o, embora fosse necess√°rio e o tempo total deveria ser de 24 + 4 = 28 ciclos.  Mas, se levarmos em conta a presen√ßa de uma mudan√ßa nos tr√™s primeiros termos (respectivamente, temos que o m√≠nimo (dois bytes baixos) √© zero e n√£o faz sentido adicion√°-lo ao resultado), teremos que adicionar n√£o 4 bytes, mas tr√™s e dois, o que reduzir√° tempo de execu√ß√£o para 1 * 2 + 2 = 4 medidas e obtenha 20 medidas.  Al√©m disso, podemos prestar aten√ß√£o ao fato de que o primeiro e o √∫ltimo termo n√£o se cruzam, o que nos permite substituir o zeramento da metade mais alta do resultado pela atribui√ß√£o do primeiro termo e reduzir o tempo de execu√ß√£o por outros 2 ciclos de rel√≥gio para 18. Al√©m disso, usando os recursos arquitet√¥nicos, ou seja, a presen√ßa do comando de transfer√™ncia de registro pares, salve mais duas medidas e o resultado final - 16 medidas em vez dos 28 originais - um pouco, mas √© legal. <br><br>  M√©todos de otimiza√ß√£o semelhantes funcionam para a opera√ß√£o 32 * 32 = 32, para a qual voc√™ pode reduzir o tempo de execu√ß√£o do esperado 4 * 4 * (2 + 4) + 4 = 100 ciclos de clock para (3 + 5 + 4 + 3) + (5 + 3 +3) + (4 + 3) + 3 = 36 compassos, o que n√£o √© nada mau.  Bem, ao final da considera√ß√£o de v√°rias op√ß√µes de multiplica√ß√£o, observamos que 16 * 16 = 16 podem ser obtidos em 3 + 3 + 3 = 9 ciclos.  Observe que todas essas considera√ß√µes s√£o v√°lidas apenas sob a suposi√ß√£o de que existe uma opera√ß√£o 8 * 8 = 16 para 2 medidas e, se n√£o estiver no MK de destino, o tempo de execu√ß√£o de todas as outras vers√µes da opera√ß√£o definitivamente n√£o se tornar√° mais r√°pido. <br><br>  Vamos resumir o tempo necess√°rio para realizar a multiplica√ß√£o (8 * 8 = 8 2, 8 * 8 = 16 9, 16 * 16 = 16 16, 16 * 16 = 32 36) e agora considerar o problema original. <br><br>  Precisamos extrair a raiz inteira quadrada do n√∫mero de 32 bits H, ou seja, encontrar o maior n√∫mero de 16 bits n de modo que n * n &lt;= H.  Todos n√≥s do curso secund√°rio conhecemos o m√©todo de aproxima√ß√£o sucessiva √† raiz quadrada (n = (N / n '+ n) / 2), mas ao us√°-lo, teremos que dividir os n√∫meros inteiros, e essa √© uma opera√ß√£o que consome muito tempo. <br><br>  Portanto, outros esquemas de c√°lculo foram desenvolvidos, um dos quais √© o m√©todo de aproxima√ß√£o bit a bit, que no pseudo-c√≥digo tem a seguinte apar√™ncia: <br><br><ul><li>  valores iniciais -&gt; n = 0;  b = 0x8000; </li><li>  execute 16 vezes -&gt; se ((n + b) * (n + b)&gt; = H) n = n + b;  b = b &gt;&gt; 1; </li></ul><br>  Voc√™ pode estimar imediatamente o tempo gasto nessa op√ß√£o 16 (o n√∫mero de bits do resultado) * (2 (organiza√ß√£o do ciclo) +2 (adi√ß√£o) + X (multiplica√ß√£o) +5 (compara√ß√£o e solu√ß√£o) +2 (modifica√ß√£o do resultado) / 2 (m√©dia intervalo) +2 (deslocamento de bits)) = 16 * (12 + X).  Voc√™ pergunta por que na f√≥rmula X, em vez do n√∫mero 16, e acontece que uma emboscada nos aguardava, j√° que estamos escrevendo em C, e n√£o em montador.  O fato √© que na biblioteca padr√£o n√£o h√° opera√ß√£o de multiplica√ß√£o com uma altera√ß√£o na profundidade de bits e n√£o podemos aplicar 16 * 16 = 32, mas somos for√ßados a usar 32 * 32 = 32, o que leva a X = 36 em vez de X = 16 e o ‚Äã‚Äãvalor final √© 16 * 48 = 768 ciclos de rel√≥gio para extrair o valor inteiro da raiz quadrada de um n√∫mero de 32 bits. <br><br>  Claro, isso √© muito melhor que o m√©todo Newton, mas um pouco demais, vamos ver o que pode ser feito. <br>  Portanto, √© √≥bvio que a maior parte do tempo √© gasta no c√°lculo do pr√≥ximo resultado da multiplica√ß√£o.  Obviamente, voc√™ pode reescrev√™-lo no assembler e usar a vers√£o mais barata da multiplica√ß√£o, obtendo 16 * (12 + 16) = 448 ticks, mas deixaremos esse caminho como √∫ltimo recurso.  Considere o processo com mais cuidado e veja que n√£o calculamos a multiplica√ß√£o de um n√∫mero aleat√≥rio por si s√≥, mas sim a multiplica√ß√£o do valor anterior com algum aumento, e o quadrado do valor anterior √© conhecido.  Portanto, podemos recorrer a um esquema de diferen√ßas com base na f√≥rmula (n + b) * (n + b) = n * n + 2 * n * b + b * b.  √Ä primeira vista, parece uma zombaria - em vez de uma multiplica√ß√£o, precisamos fazer quatro partes e at√© duas adi√ß√µes de n√∫meros longos (32 bits).  Mas vamos come√ßar a entender: j√° temos n * n, b * b, considerando que √© f√°cil obter b = b '/ 2, como b' * b '/ 4, e da mesma forma 2 * n * b = 2 * n * b '/ 2. <br><br>  Surge o seguinte esquema de c√°lculo: <br><br><ol><li>  valores iniciais -&gt; nn = 0;  n = 0;  b = 0x8000;  bb = b * b; </li><li>  repita 16 vezes -&gt; se (nn + n + bb&gt; = H) {n = n + b;  nn = nn + bb + n};  bb &gt;&gt; 2;  b&gt; 1; </li></ol><br>  Estimamos os custos de implementa√ß√£o 16 * (2 (organiza√ß√£o do ciclo) +12 (atribui√ß√£o e duas adi√ß√µes) +5 (compara√ß√£o e solu√ß√£o) + (2 (adi√ß√£o) +8 (duas adi√ß√µes)) / 2 (intervalo m√©dio) +8 (desloque-se para a direita em 2) +2 (desloque-se para a direita) = 16 * 34 = 544 ciclos de rel√≥gio.Melhor que com a multiplica√ß√£o incorreta de 32 * 32, mas ainda temos reservas. <br><br>  O que s√£o - vamos prestar aten√ß√£o √† opera√ß√£o mais cara - adicionando e comparando um total de 17 ciclos de clock e refazendo o loop principal do algoritmo: <br>  2. repetir 16 vezes -&gt; T = H-bb-n;  se (T&gt; = 0) {H = T;  n = n + b);};  bb &gt;&gt; 2;  b&gt; 1; <br>  Ent√£o, o tempo de execu√ß√£o do ciclo ser√° 16 * (2 (organiza√ß√£o do ciclo) +12 (c√°lculo da nova diferen√ßa) +1 (compara√ß√£o e solu√ß√£o) + ((4 (atribui√ß√£o) +2 (adi√ß√£o)) / 2 (meio tempo m√©dio) +8 +2) = 16 * 28 = 448 ciclos, se voc√™ levar em conta as peculiaridades da arquitetura, poder√° salvar outros 2 + 2 = 4 * 16 = 64 ciclos e manter-se em menos de 400 ciclos. <br><br>  Temos um resultado ainda melhor, como quando usamos a multiplica√ß√£o correta 16 * 16 = 32, mas sem o assembler, "em C puro".  No entanto, h√° um n√∫mero negativo significativo - se tudo √© intuitivo na vers√£o com multiplica√ß√£o, a variante com um esquema de diferen√ßas sem coment√°rios d√° a impress√£o de uma sess√£o de magia negra, voc√™ deve escolher.  Observe tamb√©m que trocamos o n√∫mero de medidas por mem√≥ria adicional para vari√°veis ‚Äã‚Äãintermedi√°rias, o que geralmente acontece. <br><br>  Nota necess√°ria - n√£o obtivemos um ganho significativo (√†s vezes) em compara√ß√£o com multiplica√ß√µes, pois temos uma implementa√ß√£o r√°pida de 8 * 8 = 16.  Se ele estiver ausente no MK (e isso acontecer) ou n√£o for t√£o r√°pido (e isso tamb√©m acontecer), o esquema de diferen√ßas se tornar√° v√°rias vezes mais r√°pido, pois utiliza apenas opera√ß√µes padr√£o de adi√ß√£o e turno, que s√£o garantidas em qualquer MK. <br><br>  Parecia que n√£o funcionaria melhor, mas, ao que parece, ainda existem reservas para aumentar o desempenho do algoritmo.  Vamos tentar usar outro m√©todo cl√°ssico de acelera√ß√£o - dividir e conquistar.  E se voc√™ primeiro extrair a raiz quadrada da metade mais antiga do argumento e refin√°-la?  Primeiro de tudo, mostramos que isso √© fundamentalmente poss√≠vel.  De fato, apresentamos o argumento na forma H = H '&lt;&lt; 16 + H' 'e o resultado na forma n = n' &lt;&lt; 8 + n ''.  Como n '' &lt;256, seu quadrado obviamente ser√° menor que o quadrado do n√∫mero n = n '&lt;&lt; 8 + 256 = (n' + 1) &lt;&lt; 8.  Daqui resulta que a parte mais alta do resultado n√£o excede a raiz quadrada da parte mais alta do argumento. <br><br>  A implementa√ß√£o dessa abordagem √© deixada para o leitor curioso. <br>  O que essa abordagem nos fornecer√°, porque o n√∫mero total de itera√ß√µes permanecer√° inalterado - podemos realizar a primeira metade das itera√ß√µes com n√∫meros de menor dura√ß√£o, e isso leva a uma redu√ß√£o nos custos de tempo.  Essa abordagem pode ser aplicada √† variante com multiplica√ß√£o e √† variante da diferen√ßa; o ganho total ser√° de at√© um quarto do tempo total de execu√ß√£o. <br><br>  Nota necess√°ria - a aplicabilidade dessa abordagem n√£o √© de todo √≥bvia. Ao implementar para MKs como o AVR, a acelera√ß√£o da execu√ß√£o ocorre, mas para algumas arquiteturas, por exemplo, para x86, a desacelera√ß√£o da opera√ß√£o apareceu inesperadamente.  Aparentemente, trabalhar com dados n√£o nativos (16 bits) nessa arquitetura √© significativamente mais caro no tempo do que com nativos (32 bits).  N√£o conduzi um estudo aprofundado, mas o fato ocorreu e devo relat√°-lo para evitar mal-entendidos. <br><br>  Mas isso n√£o √© tudo.  Como j√° embarcamos no caminho da separa√ß√£o e do dom√≠nio, por que n√£o ir al√©m - extraia a raiz dos bits passo a passo, come√ßando pelos mais antigos (come√ßando pelos mais jovens √© contraproducente no nosso caso).  O esquema do algoritmo √© o mesmo - adicionamos a pr√≥xima por√ß√£o de bits no resultado atual e tentamos adicionar o pr√≥ximo bit ao resultado, verificando se ultrapassamos o valor raiz.  A peculiaridade √© que s√≥ podemos verificar os bits mais altos do argumento, at√© chegarmos aos bits mais baixos. <br><br>  Ao implementar, usamos mais um truque - em vez de mover nossos n√∫meros subtra√≠dos para a direita, moveremos nosso argumento decrementado para a esquerda, o significado n√£o muda e a velocidade aumenta.  Aumenta devido a dois fatores - 1) basta subtrair apenas n√∫meros de 16 bits (h√° uma peculiaridade e isso deve ser levado em considera√ß√£o, mas estamos considerando um estudo de caso, vout) e 2) n√£o precisamos mudar o quadrado do pr√≥ximo bit, pois sempre ser√° igual a um.  Mas voc√™ tem que pagar por tudo neste mundo e teremos um deslocamento da diferen√ßa estendida (6 bytes) para a esquerda e 2 bits por rel√≥gio.  Veja pseudo c√≥digo <br><br><ol><li>  valores iniciais -&gt; n = 0;  H1 = 0; </li><li>  repita 16 vezes -&gt; (H1, H) &lt;&lt; 2;  T = H1-n-1;  se (T&gt; 0) {H1 = T;  n = n + 2};  n &lt;&lt; 1; </li></ol><br>  e avalie o tempo de execu√ß√£o, obtendo 16 * (12 (turno estendido) +4 (calculando a diferen√ßa) +1 (solu√ß√£o) +2 (atribui√ß√£o) +1 (aumento) +2 (turno)) = 16 * 22 = 352 medidas, talvez , o resultado est√° quase perfeito.  Ao implementar esta op√ß√£o, existem pequenas armadilhas, deixo isso de novo para o leitor curioso (bem, ele consegue o emprego). <br><br>  Bem, na conclus√£o da se√ß√£o que me levou a escrever este post.  Existe uma biblioteca McuCpp absolutamente maravilhosa, de autoria de Anton Chizhov, na qual, com base na classe de autoria loki, Andriescu √© extraordinariamente elegante (bem, na medida em que a eleg√¢ncia possa ser aplicada aos modelos C ++), trabalhe com pinos &lt;a ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/KonstantinChizhov/ Mcucpp</a> ¬ªTenho grande respeito pelo autor mencionado (ambos) e, recentemente, em conex√£o com as circunst√¢ncias, que discutirei mais adiante, olhei as fontes desta biblioteca e mais uma vez admirado. <br><br>  No entanto, entre outros arquivos, vi template_utils.h, no qual algumas rotinas auxiliares foram implementadas e, entre elas, uma raiz inteira de um n√∫mero de 32 bits.  O fato de usar o algoritmo de aproxima√ß√£o seq√ºencial mais simples com multiplica√ß√£o n√£o √© assustador, pois esse algoritmo n√£o perde muito em velocidade, mas na capacidade de compreens√£o, ele oferece muitos pontos √† frente e ainda vence.  Mas n√£o gostei muito do fato de ter sido implementado de maneira imprecisa (em termos de desempenho), porque "as crian√ßas podem v√™-lo".  A imprecis√£o consiste em representar o n√∫mero selecionado com 32 bits, porque sabemos firmemente que a raiz do n√∫mero de 32 bits n√£o ultrapassar√° 16 bits, ent√£o por que precisamos mudar zero bytes.  E este √© exatamente o caso em que o pr√≥prio compilador nunca tentar√° realizar a otimiza√ß√£o e deve ajud√°-lo. <br><br>  Convers√£o de fun√ß√£o √≥bvia <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> add = <span class="hljs-number"><span class="hljs-number">0x8000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> i = <span class="hljs-number"><span class="hljs-number">16</span></span>; i !=<span class="hljs-number"><span class="hljs-number">0</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> rootGuess = result | add; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> guess = rootGuess * rootGuess; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= guess) { result = rootGuess; } add &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  nos permite salvar 2 ciclos em um deslocamento de bit e 2 ciclos na cria√ß√£o do pr√≥ximo fator em cada ciclo, e organizar o ciclo na forma indicada s√£o outros 4 ciclos (eu sei que o compilador pode fazer essa otimiza√ß√£o para n√≥s, mas por que n√£o ajud√°-lo explicitamente ), o que √© bastante bom para altera√ß√µes de c√≥digo puramente cosm√©ticas que n√£o afetam sua compreensibilidade. <br><br>  Nota posterior - um coment√°rio me fez pensar que seria mais correto <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint_fast8_t</span></span> i= ...)</code> </pre> <br>  Obrigado Oleg pela ajuda. <br><br>  A cereja no bolo √© a fun√ß√£o de extrair toda a raiz quadrada do n√∫mero do sinal localizado logo abaixo, que afirma ser ‚àö-1 = 65635 = -1 Por outro lado, por que n√£o, o que √© pior do que qualquer outro resultado, isso n√£o √© exce√ß√£o para n√≥s? causa no MK, e a raiz quadrada inteira de um n√∫mero negativo n√£o existe. <br><br>  Bem, a conclus√£o sobre o motivo pelo qual me voltei para a biblioteca de Anton Chizhov.  Fui solicitado por um post recente sobre o RTOS dom√©stico para MK sob o nome MAX (MultiAgent Coherent System) - veja a ep√≠grafe do post anunciado por seus criadores e portado para o MK fabricado por Milander.  Nota - este post n√£o √© de forma alguma material promocional e logo ficar√° claro para os leitores.  Dos autores do mcucpp mencionados acima, o SO usou a implementa√ß√£o de um buffer de anel (sem diminuir as vantagens da biblioteca Anton, devo dizer que essa parte n√£o √© uma refer√™ncia e ainda √© uma formula√ß√£o suave, sobre a qual escrevi em outro post que n√£o publicarei).  Como trabalho em estreita colabora√ß√£o com as instala√ß√µes de produ√ß√£o de Milander, o material me interessou e eu seguimos o link para o site dos desenvolvedores. <br><br>  Aqui come√ßa o pr√≥ximo grito de Yaroslavna. <br><br>  No ano passado, quando a cria√ß√£o do RTOS dom√©stico foi anunciada pela primeira vez, baixei uma descri√ß√£o do produto de software deste site, mas de alguma forma minhas m√£os n√£o chegaram ao estudo.  Pela natureza da minha atividade, eu tenho que lidar com componentes dom√©sticos (eu entendo o suficiente ...), ent√£o seria bom ter o software apropriado.  Lembrando que, no lan√ßamento do ano passado, o diretor da empresa falou sobre os milh√µes de rublos gastos no desenvolvimento e a grande equipe que trabalhava na cria√ß√£o desse produto de software, decidi ver a vers√£o de teste dispon√≠vel para download gratuito e aqui estou compartilhando os resultados. <br><br>  Para come√ßar, a descri√ß√£o por meio ano quase caiu pela metade (de 115 para 55 p√°ginas) e, se o desaparecimento de aplicativos com capturas de tela descrevendo o processo de lan√ßamento de produtos da "Descri√ß√£o do programa" √© bem-vindo, n√£o a apar√™ncia desses materiais (para a cria√ß√£o dos quais Gastei, embora n√£o seja muito significativo, mas ainda tempo e dinheiro) em um documento como o "Guia do Operador". Pessoalmente, estou perplexo.  Al√©m disso, na primeira frase do documento, vemos um desvio franco da verdade, uma vez que o pr√≥prio RTOS n√£o se destina a "criar programas" de forma alguma, por algum motivo os autores n√£o se permitiram tais declara√ß√µes na vers√£o anterior do documento, a influ√™ncia do servi√ßo de marketing √© sentida.  Ele tamb√©m fornece que, se a descri√ß√£o costumava estar na pasta / docs do diret√≥rio raiz, e isso era l√≥gico, agora est√° oculto em / toolchain / macs / docs, bem, como disseram na minha juventude: "todo mundo est√° louco √† sua maneira", seguimos em frente. <br><br>  Come√ßo a olhar para a descri√ß√£o, olhando para o c√≥digo fonte (ele est√° gentilmente inclu√≠do na vers√£o de teste) e, perplexo, encontro a aus√™ncia de drivers de dispositivos perif√©ricos adaptados para trabalhar com este sistema operacional.  Primeiro, sugeri que esse √© um recurso do teste; depois, no f√≥rum, nas informa√ß√µes dos desenvolvedores, acho que realmente n√£o h√° drivers, mas eles est√£o trabalhando nisso.  Mais de seis meses (seis meses, Carl, na verdade, quase um ano) a partir do momento em que o sistema operacional foi lan√ßado para o MK, e eles trabalham com drivers.  Naturalmente, ou como se costuma dizer, n√£o √© preciso dizer que n√£o se pode falar de terceiros (sistema de arquivos, pilha de rede, pilha USB).  Uma ideia engra√ßada dos autores sobre os requisitos para o desenvolvimento de software para o MK, tudo bem, dirigiu novamente. <br><br>  Ou seja, o SO declarado, cujo recurso destacado √© a organiza√ß√£o da intera√ß√£o dentro de um sistema com v√°rios controladores, n√£o possui meios nativos de organizar essa intera√ß√£o.  O que temos na linha de fundo - e temos gerenciamento de tarefas, na verdade, um sheduler, servi√ßo de tempo m√≠nimo e meios de sincronizar tarefas, e isso √© tudo - engra√ßado, para dizer o m√≠nimo.  Tudo bem, analisaremos ainda mais, mesmo em um conjunto de componentes que s√£o interessantes solu√ß√µes poss√≠veis, especialmente considerando que em um site (n√£o na empresa do fabricante) vi um "exame" do c√≥digo fonte deste sistema operacional por refer√™ncia.  Este documento disse que o produto de software n√£o usa componentes de terceiros (importa√ß√£o) e √© original, seria necess√°rio ter certeza. <br><br>  A primeira observa√ß√£o √© que, se voc√™ usar arquivos ARM originais inclu√≠dos no pacote de c√≥digo-fonte para portar para uma arquitetura espec√≠fica do Cortex-M0 (BE1T 1986), isso ser√° muito semelhante ao uso de fragmentos de texto de terceiros (importados) - pessoalmente acho que esse √© o uso, mas Provavelmente n√£o sei tudo.  Bem, e em segundo lugar, o c√≥digo-fonte do sheduler e dos componentes relacionados ao gerenciamento de tarefas √© realmente original e n√£o tem an√°logos (pelo menos n√£o conhe√ßo nenhum), mas esse √© o tipo de originalidade quando recordo a frase do velho xam√£ do filme "O esp√≠rito maligno de Yambuya" sobre o grande ca√ßador: "Corte as orelhas, cozinhe e coma - voc√™ teria adivinhado?" <br><br>  Vou tentar explicar - no design do sistema operacional em geral e no RTOS em particular, uma das quest√µes complexas √© a quest√£o de garantir o acesso de todos os processos no sistema a um recurso compartilhado - tempo de execu√ß√£o do processador.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O fato √© que um sistema projetado incorretamente (e uma tarefa mal escrita) pode bloquear a execu√ß√£o de todas as tarefas com uma prioridade mais baixa, o que certamente ir√° confundir o programador. N√£o se trata de executar opera√ß√µes proibidas, como controle de interrup√ß√£o (este √© um t√≥pico para uma discuss√£o separada e simplesmente n√£o possui uma solu√ß√£o na estrutura de MKs simples, embora os autores do SO em quest√£o afirmem ter resolvido esse problema usando o MPU), mas de execu√ß√£o cont√≠nua sem esperar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse problema √© amplamente conhecido, pode ser resolvido de diferentes maneiras, h√° extensa literatura dispon√≠vel sobre esse assunto, como regra, um conjunto de filas de tarefas com prioridades diferentes e um sheduler modificado s√£o usados. Isso requer certos custos para organizar filas com tempo de acesso O (1) e, por exemplo, no FREE-RTOS, ao tentar definir mais de 20 poss√≠veis n√≠veis de prioridade, o programador recebe uma pergunta confusa do compilador e se ele realmente precisa tanto (e mesmo se essa pergunta existe uma resposta afirmativa, sem modificar o c√≥digo fonte, voc√™ n√£o pode obter tantas prioridades).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, fiquei um pouco surpreso ao descobrir que o sistema operacional em quest√£o permite que voc√™ tenha at√© 60 prioridades (e at√© mais). </font><font style="vertical-align: inherit;">A surpresa se espalhou quando olhei atrav√©s da fonte. </font><font style="vertical-align: inherit;">Em vez de filas de tarefas separadas com prioridades iguais, os autores usam uma fila (tamb√©m existe uma segunda fila de tarefas bloqueadas) pronta para a execu√ß√£o de tarefas, o que ajuda a economizar mem√≥ria (provavelmente esse era o objetivo de uma solu√ß√£o) devido ao fato de que</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a opera√ß√£o de adicionar uma tarefa √† fila se torna O (n) e </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isso torna imposs√≠vel o uso de um sheduler modificado - na minha opini√£o, um pouco caro por 20 * (3 * 4) = 240 bytes de RAM. </font><font style="vertical-align: inherit;">A solu√ß√£o √© incomumente original, mas, do meu ponto de vista, essa √© sua √∫nica vantagem.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em geral, eu ainda n√£o entendia o motivo pelo qual os autores receberiam dinheiro (mas ainda n√£o decidiram fazer isso, a julgar pelo f√≥rum) e quais solu√ß√µes e recursos espec√≠ficos tornam poss√≠vel dar ao software um nome t√£o retumbante. Especialmente considerando a quantidade de software fornecida gratuitamente por v√°rios fornecedores de MK (√© claro, importados). Enquanto navegava no f√≥rum da empresa na tentativa de encontrar uma resposta, vi refer√™ncias ao produto de software mcucpp mencionado anteriormente (os autores da MAKS foram supostamente inspirados pelas id√©ias de Chizhov - tr√™s vezes ha), nas quais descobri uma falha menor descrita acima.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A conclus√£o desta se√ß√£o √© que, se outras decis√µes sobre substitui√ß√£o de importa√ß√µes no campo de software forem implementadas de maneira semelhante com resultados de qualidade semelhante, as perspectivas de constru√ß√£o de sistemas embarcados dom√©sticos me parecer√£o muito mal definidas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concluindo, eu gostaria de voltar ao manual (n√£o, n√£o um desenvolvedor de SO, nem quero mencion√°-lo ao lado de bons desenvolvedores) do desenvolvedor da empresa e fabricante do MK - Milander mencionado. Voc√™ faz bons microcontroladores (n√£o vou mentir, eles s√£o inferiores em par√¢metros aos an√°logos estrangeiros, mas n√£o fatalmente), por exemplo, ao mesmo tempo (em 2013), o BE1T era quase o melhor entre os colegas de classe, mas no quintal de 2019 e durante esse per√≠odo muitos os alcan√ßaram. e superado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas, se o bom MK produzido pela empresa n√£o tiver:</font></font><br><br><ol><li>  (  ,   )  ( ,   ,    ,  ,  ), </li><li>      (   ), </li><li>      ()      2, </li><li>       HAL, CMSIS (- ), </li><li>       , </li><li>        , </li><li>      (3rd part),  , </li><li>       , </li><li>       , </li><li>    ,     (,   ,     ..)     ¬´ ¬ª, </li><li>  ,   ,         (    , , MIT   ,  ¬´      ¬ª),        ,    (?). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, tudo isso n√£o aparece por si s√≥ e custa dinheiro, mas parece-me que uma empresa do seu n√≠vel poderia arcar com o trabalho de 5 pessoas por seis meses para criar tudo isso acima (com exce√ß√£o da cl√°usula, talvez cl√°usula 10, embora agora todas sejam significativas e muitos pequenos fabricantes de MK t√™m seu pr√≥prio IDE). </font><font style="vertical-align: inherit;">Se isso for realizado, o solo desaparecer√° para a apar√™ncia de artesanato, como o SO descrito neste post. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora possa ser que eu n√£o saiba algo e, na verdade, n√£o seja t√£o simples, √© uma pena que seja realmente assim. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pe√ßo desculpas antecipadamente se minhas anota√ß√µes parecerem muito duras, foi voc√™ (Milander) que eu n√£o quis ofender.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437326/">https://habr.com/ru/post/pt437326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437316/index.html">O Internet Development Institute nomeou sites que podem ser desconectados no RuNet desde 1¬∫ de fevereiro</a></li>
<li><a href="../pt437318/index.html">Migra√ß√£o perfeita (quase) entre as principais vers√µes do PostgreSQL usando replica√ß√£o l√≥gica</a></li>
<li><a href="../pt437320/index.html">√çndice de desenvolvimento da esfera de m√≠dia de 2018: estagna√ß√£o da televis√£o, aumento da confian√ßa na m√≠dia informal</a></li>
<li><a href="../pt437322/index.html">O estado est√° envolvido no BigDate</a></li>
<li><a href="../pt437324/index.html">Beijo sangrento: propriedades de vasorelaxa√ß√£o da saliva de morcegos vampiros</a></li>
<li><a href="../pt437330/index.html">devleads - fale sobre burnout</a></li>
<li><a href="../pt437332/index.html">Dois por cento do "gato" ou quem fotografou o Mestre Yoda?</a></li>
<li><a href="../pt437334/index.html">O que acontecer√° em 1¬∫ de fevereiro?</a></li>
<li><a href="../pt437336/index.html">De Penza a Berlim: hist√≥ria da mudan√ßa do Automator de Teste</a></li>
<li><a href="../pt437342/index.html">Como escolher uma plataforma para vigil√¢ncia por v√≠deo: Cloud vs. DVR / NVR / VMS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>