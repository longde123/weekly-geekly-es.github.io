<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüç≥ üéâ ‚öïÔ∏è Eventmaschine sch√ºtzt den Lebenszyklus ü§£ ü§¶üèª üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haftungsausschluss: Dieser Artikel beschreibt eine nicht offensichtliche L√∂sung f√ºr ein nicht offensichtliches Problem. Vor dem Rauschen  Eier  Um es ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eventmaschine sch√ºtzt den Lebenszyklus</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431048/"><blockquote>  Haftungsausschluss: Dieser Artikel beschreibt eine nicht offensichtliche L√∂sung f√ºr ein nicht offensichtliches Problem.  Vor dem Rauschen <del>  Eier </del>  Um es in die Praxis umzusetzen, empfehle ich, den Artikel bis zum Ende zu lesen und zweimal dar√ºber nachzudenken. </blockquote><p><img src="https://habrastorage.org/webt/sb/cj/hs/sbcjhsnrjjqhgrl0xcpicmvzn40.png" alt="aber warum"></p><br><p>  Hallo allerseits!  Wenn wir mit Code arbeiten, m√ºssen wir uns oft mit dem <em>Status</em> befassen.  Ein solcher Fall ist der Lebenszyklus von Objekten.  Das Verwalten eines Objekts mit mehreren m√∂glichen Zust√§nden kann eine sehr nicht triviale Aufgabe sein.  F√ºgen Sie hier eine asynchrone Ausf√ºhrung hinzu, und die Aufgabe wird um eine Gr√∂√üenordnung kompliziert.  Es gibt eine effektive und nat√ºrliche L√∂sung.  In diesem Artikel werde ich √ºber die Ereignismaschine und deren Implementierung in Go sprechen. </p><a name="habracut"></a><br><h2 id="zachem-upravlyat-sostoyaniem">  Warum den Staat verwalten? </h2><br><p>  Lassen Sie uns zun√§chst das Konzept selbst definieren.  Das einfachste Beispiel f√ºr einen Status: Dateien und verschiedene Verbindungen.  Sie k√∂nnen nicht einfach eine Datei nehmen und lesen.  Es muss zuerst ge√∂ffnet werden und am Ende <del>  vorzugsweise </del>  Achten Sie darauf, zu schlie√üen.  Es stellt sich heraus, dass die aktuelle Aktion vom Ergebnis der vorherigen Aktion abh√§ngt: Das Lesen h√§ngt von der √ñffnung ab.  Das gespeicherte Ergebnis ist der Status. </p><br><p>  Das Hauptproblem mit dem Staat ist die Komplexit√§t.  Jeder Status verkompliziert den Code automatisch.  Sie m√ºssen die Ergebnisse von Aktionen im Speicher speichern und der Logik verschiedene Pr√ºfungen hinzuf√ºgen.  Deshalb sind zustandslose Architekturen f√ºr Programmierer so attraktiv - niemand will <del>  √Ñrger </del>  Schwierigkeiten.  Wenn die Ergebnisse Ihrer Aktionen keinen Einfluss auf die Ausf√ºhrungslogik haben, ben√∂tigen Sie keinen Status. </p><br><p>  Es gibt jedoch eine Eigenschaft, mit der Sie mit den Schwierigkeiten rechnen m√ºssen.  F√ºr einen Status m√ºssen Sie eine bestimmte Reihenfolge von Aktionen einhalten.  Im Allgemeinen sollten solche Situationen vermieden werden, dies ist jedoch nicht immer m√∂glich.  Ein Beispiel ist der Lebenszyklus von Programmobjekten.  Dank eines guten Zustandsmanagements kann ein vorhersagbares Verhalten von Objekten mit einem komplexen Lebenszyklus erzielt werden. </p><br><p>  Lassen Sie uns nun herausfinden, wie man es <em>cool macht</em> . </p><br><h2 id="avtomat-kak-sposob-resheniya-problem">  Automatisch, um Probleme zu l√∂sen </h2><br><p><img src="https://habrastorage.org/webt/eg/qd/1o/egqd1oejaztizauope6waesapm0.jpeg" alt="AK74"></p><br><p>  Wenn Menschen √ºber Zust√§nde sprechen, fallen ihnen sofort endliche Zustandsmaschinen ein.  Dies ist logisch, da ein Automat die nat√ºrlichste Art ist, einen Zustand zu verwalten. </p><br><blockquote>  Ich werde mich nicht mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Theorie der Automaten befassen</a> , da es im Internet mehr als genug Informationen gibt. </blockquote><p>  Wenn Sie nach Beispielen f√ºr Finite-State-Maschinen f√ºr Go suchen, werden Sie auf jeden Fall einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lexer von Rob Pike</a> treffen.  Ein gutes Beispiel f√ºr einen Automaten, bei dem die verarbeiteten Daten das Eingabealphabet sind.  Dies bedeutet, dass Zustands√ºberg√§nge durch den vom Lexer verarbeiteten Text verursacht werden.  Elegante L√∂sung f√ºr ein bestimmtes Problem. </p><br><p>  Das Wichtigste zu verstehen ist, dass ein Automat eine L√∂sung f√ºr ein streng spezifisches Problem ist.  Bevor Sie es als Abhilfe f√ºr alle Probleme betrachten, m√ºssen Sie die Aufgabe daher vollst√§ndig verstehen.  Insbesondere die Entit√§t, die Sie steuern m√∂chten: </p><br><ul><li>  Zust√§nde - Lebenszyklus; </li><li>  Ereignisse - was genau bewirkt den √úbergang in jeden Zustand; </li><li>  Arbeitsergebnis - Ausgabedaten; </li><li>  Ausf√ºhrungsmodus (synchron / asynchron); </li><li>  Hauptanwendungsf√§lle. </li></ul><br><p>  Der Lexer ist wundersch√∂n, √§ndert jedoch nur den Status aufgrund von Daten, die er selbst verarbeitet.  Aber was ist mit der Situation, wenn der Benutzer √úberg√§nge aufruft?  Hier kann die Eventmaschine helfen. </p><br><h2 id="realnyy-primer">  Echtes Beispiel </h2><br><p> Um es klarer zu machen, werde ich ein Beispiel aus der <code>phono</code> analysieren. </p><br><blockquote>  Um vollst√§ndig in den Kontext einzutauchen, k√∂nnen Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einleitenden Artikel</a> lesen.  Dies ist f√ºr dieses Thema nicht erforderlich, hilft jedoch dabei, besser zu verstehen, was wir verwalten. </blockquote><br><h3 id="a-chem-upravlyaem">  Und was verwalten wir? </h3><br><p>  <code>phono</code> basiert auf der DSP-Pipeline.  Es besteht aus drei Verarbeitungsstufen.  Jede Stufe kann eine bis mehrere Komponenten umfassen: </p><br><p><img src="https://habrastorage.org/webt/go/ym/ep/goymepjg4pds_picireejjsshnq.png" alt="pipe_diagram"></p><br><ol><li>  <code>pipe.Pump</code> (englische Pumpe) ist eine obligatorische Stufe f√ºr den <code>pipe.Pump</code> , immer nur eine Komponente. </li><li>  <code>pipe.Processor</code> (englischer Handler) - eine optionale Stufe <strong>der</strong> Klangverarbeitung von 0 bis N Komponenten. </li><li>  <code>pipe.Sink</code> (englische Sp√ºle) - eine obligatorische Stufe <strong>der Schall√ºbertragung</strong> von 1 bis N Komponenten. </li></ol><br><p>  Eigentlich werden wir den F√∂rdererlebenszyklus verwalten. </p><br><h3 id="zhiznennyy-cikl">  Lebenszyklus </h3><br><p>  So sieht das <code>pipe.Pipe</code> Zustandsdiagramm aus. </p><br><p><img src="https://habrastorage.org/webt/le/ni/xq/lenixqpvoh0zaq9j2aftrqprtvg.png" alt="pipe_lifecycle"></p><br><p>  <em>Kursivschrift</em> kennzeichnet √úberg√§nge, die durch die interne Ausf√ºhrungslogik verursacht werden.  <strong>Fett</strong> - √úberg√§nge, die durch Ereignisse verursacht werden.  Das Diagramm zeigt, dass die Zust√§nde in zwei Typen unterteilt sind: </p><br><ul><li>  <strong>Ruhezust√§nde</strong> - <code>ready</code> und <code>paused</code> , Sie k√∂nnen nur nach Ereignis von ihnen springen </li><li>  <em>aktive Zust√§nde</em> - <code>running</code> und <code>pausing</code> , √úberg√§nge nach Ereignis und aufgrund der Ausf√ºhrungslogik </li></ul><br><p>  Vor einer detaillierten Analyse des Codes ein klares Beispiel f√ºr die Verwendung aller Zust√§nde: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// PlayWav  .wav    portaudio  -. func PlayWav(wavFile string) error { bufferSize := phono.BufferSize(512) //      w, err := wav.NewPump(wavFile, bufferSize) //  wav pump if err != nil { return err } pa := portaudio.NewSink( //  portaudio sink bufferSize, w.WavSampleRate(), w.WavNumChannels(), ) p := pipe.New( //  pipe.Pipe    ready w.WavSampleRate(), pipe.WithPump(w), pipe.WithSinks(pa), ) p.Run() //    running   p.Run() errc := p.Pause() //    pausing   p.Pause() err = pipe.Wait(errc) //     paused if err != nil { return err } errc = p.Resume() //    running   p.Resume() err = pipe.Wait(errc) //     ready if err != nil { return err } return pipe.Wait(p.Close()) //      }</span></span></code> </pre> <br><p>  Nun, das Wichtigste zuerst. </p><br><blockquote>  Der gesamte Quellcode ist im <a href="">Repository</a> verf√ºgbar. </blockquote><br><h3 id="sostoyaniya-i-sobytiya">  Staaten und Ereignisse </h3><br><p>  Beginnen wir mit dem Wichtigsten. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// state      . type state interface { listen(*Pipe, target) (state, target) //    transition(*Pipe, eventMessage) (state, error) //   } // idleState  .        . type idleState interface { state } // activeState  .         //   . type activeState interface { state sendMessage(*Pipe) state //    } //  . type ( idleReady struct{} activeRunning struct{} activePausing struct{} idlePaused struct{} ) //  . var ( ready idleReady running activeRunning paused idlePaused pausing activePausing )</span></span></code> </pre> <br><p>  Dank separater Typen werden √úberg√§nge auch f√ºr jeden Status separat deklariert.  Dies vermeidet das riesige <del>  W√ºrstchen </del>  √úbergangsfunktionen mit verschachtelten <code>switch</code> .  Die Zust√§nde selbst enthalten keine Daten oder Logik.  F√ºr sie k√∂nnen Sie Variablen auf Paketebene deklarieren, um dies nicht jedes Mal zu tun.  Die <code>state</code> wird f√ºr den Polymorphismus ben√∂tigt.  <code>activeState</code> <code>idleState</code> etwas sp√§ter √ºber <code>activeState</code> und <code>idleState</code> sprechen. </p><br><p>  Der zweitwichtigste Teil unserer Maschine sind Ereignisse. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// event  . type event int //  . const ( run event = iota pause resume push measure cancel ) // target      . type target struct { state idleState //   errc chan error //   ,     } // eventMessage   ,    . type eventMessage struct { event //   params params //   components []string // id  target //      }</span></span></code> </pre> <br><p>  Betrachten Sie ein einfaches Beispiel, um zu verstehen, warum der <code>target</code> ben√∂tigt wird.  Wir haben ein neues F√∂rderband geschaffen, es ist <code>ready</code> .  F√ºhren Sie es nun mit <code>p.Run()</code> .  Das <code>run</code> wird an die Maschine gesendet, die Pipeline geht in den <code>running</code> .  Wie kann man herausfinden, wann der F√∂rderer fertig ist?  Hier hilft uns der Zieltyp.  Es zeigt an, welcher Ruhezustand nach dem Ereignis zu erwarten ist.  In unserem Beispiel wird die Pipeline nach Abschluss der Arbeiten wieder in den <code>ready</code> .  Das gleiche im Diagramm: </p><br><p><img src="https://habrastorage.org/webt/h8/4i/xv/h84ixvb5dd_2gdbnrcd3kggwyzg.png"></p><br><p>  Nun mehr zu den Arten von Staaten.  Genauer gesagt √ºber die <code>activeState</code> <code>idleState</code> und <code>activeState</code> .  Schauen wir uns die <code>listen(*Pipe, target) (state, target)</code> f√ºr verschiedene Arten von Stufen an: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// listen     ready. func (s idleReady) listen(p *Pipe, t target) (state, target) { return p.idle(s, t) } // listen     running. func (s activeRunning) listen(p *Pipe, t target) (state, target) { return p.active(s, t) }</span></span></code> </pre> <br><p>  <code>pipe.Pipe</code> hat verschiedene Funktionen, um auf einen √úbergang zu warten!  Was ist dort? </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// idle     .    . func (p *Pipe) idle(s idleState, t target) (state, target) { if s == t.state || s == ready { t = t.dismiss() //  ,  target } for { var newState state var err error select { case e := &lt;-p.events: //   newState, err = s.transition(p, e) //    if err != nil { e.target.handle(err) } else if e.hasTarget() { t.dismiss() t = e.target } } if s != newState { return newState, t // ,    } } } // active     .     , //   . func (p *Pipe) active(s activeState, t target) (state, target) { for { var newState state var err error select { case e := &lt;-p.events: //   newState, err = s.transition(p, e) //    if err != nil { //  ? e.target.handle(err) // ,    } else if e.hasTarget() { // ,  target t.dismiss() //   t = e.target //   } case &lt;-p.provide: //     newState = s.sendMessage(p) //    case err, ok := &lt;-p.errc: //   if ok { //   ,  interrupt(p.cancel) //   t.handle(err) //    } //    ,  return ready, t //    ready } if s != newState { return newState, t // ,    } } }</span></span></code> </pre> <br><p>  Somit k√∂nnen wir verschiedene Kan√§le in verschiedenen Zust√§nden h√∂ren.  Auf diese Weise k√∂nnen Sie beispielsweise w√§hrend einer Pause keine Nachrichten senden. Wir h√∂ren nur nicht auf den entsprechenden Kanal. </p><br><h3 id="konstruktor-i-start-avtomata">  Konstruktor und Startmaschine </h3><br><p><img src="https://habrastorage.org/webt/bk/h2/zn/bkh2znujbo_omto9lyhcq-ixp-e.png"></p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// New      . //      ready. func New(sampleRate phono.SampleRate, options ...Option) *Pipe { p := &amp;Pipe{ UID: phono.NewUID(), sampleRate: sampleRate, log: log.GetLogger(), processors: make([]*processRunner, 0), sinks: make([]*sinkRunner, 0), metrics: make(map[string]measurable), params: make(map[string][]phono.ParamFunc), feedback: make(map[string][]phono.ParamFunc), events: make(chan eventMessage, 1), //    cancel: make(chan struct{}), //     provide: make(chan struct{}), consume: make(chan message), } for _, option := range options { //   option(p)() } go p.loop() //    return p }</span></span></code> </pre> <br><p>  Neben der Initialisierung und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionsoptionen</a> beginnt eine separate Goroutine mit dem Hauptzyklus.  Schau ihn dir an: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// loop ,     nil . func (p *Pipe) loop() { var s state = ready //   t := target{} for s != nil { s, t = s.listen(p, t) //      p.log.Debug(fmt.Sprintf("%v is %T", p, s)) } t.dismiss() close(p.events) //    } // listen     ready. func (s idleReady) listen(p *Pipe, t target) (state, target) { return p.idle(s, t) } // transition       . func (s idleReady) transition(p *Pipe, e eventMessage) (state, error) { switch e.event { case cancel: interrupt(p.cancel) return nil, nil case push: e.params.applyTo(p.ID()) p.params = p.params.merge(e.params) return s, nil case measure: for _, id := range e.components { e.params.applyTo(id) } return s, nil case run: if err := p.start(); err != nil { return s, err } return running, nil } return s, ErrInvalidState }</span></span></code> </pre> <br><p>  Der F√∂rderer wird im Vorgriff auf Ereignisse erstellt und eingefroren. </p><br><h3 id="pora-rabotat">  Zeit zu arbeiten </h3><br><p>  Rufen Sie <code>p.Run()</code> ! </p><br><p><img src="https://habrastorage.org/webt/wv/vi/vs/wvvivsokwwjkjvvcibg-kyvi9m0.png"></p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Run   run  . //     pipe.Close  . func (p *Pipe) Run() chan error { runEvent := eventMessage{ event: run, target: target{ state: ready, //    errc: make(chan error, 1), }, } p.events &lt;- runEvent return runEvent.target.errc } // listen     running. func (s activeRunning) listen(p *Pipe, t target) (state, target) { return p.active(s, t) } // transition       . func (s activeRunning) transition(p *Pipe, e eventMessage) (state, error) { switch e.event { case cancel: interrupt(p.cancel) err := Wait(p.errc) return nil, err case measure: e.params.applyTo(p.ID()) p.feedback = p.feedback.merge(e.params) return s, nil case push: e.params.applyTo(p.ID()) p.params = p.params.merge(e.params) return s, nil case pause: return pausing, nil } return s, ErrInvalidState } // sendMessage   . func (s activeRunning) sendMessage(p *Pipe) state { p.consume &lt;- p.newMessage() return s }</span></span></code> </pre> <br><p>  <code>running</code> generiert Nachrichten und wird ausgef√ºhrt, bis die Pipeline abgeschlossen ist. </p><br><h3 id="sdelay-pauzu">  Pause </h3><br><p>  W√§hrend der Ausf√ºhrung des F√∂rderers k√∂nnen wir ihn anhalten.  In diesem Zustand generiert die Pipeline keine neuen Nachrichten.  Rufen Sie dazu die Methode <code>p.Pause()</code> . </p><br><p><img src="https://habrastorage.org/webt/-2/9k/xz/-29kxztxwy56ftsphj9-blcbkei.png"></p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Pause   pause  . //     pipe.Close  . func (p *Pipe) Pause() chan error { pauseEvent := eventMessage{ event: pause, target: target{ state: paused, //    errc: make(chan error, 1), }, } p.events &lt;- pauseEvent return pauseEvent.target.errc } // listen     pausing. func (s activePausing) listen(p *Pipe, t target) (state, target) { return p.active(s, t) } // transition       . func (s activePausing) transition(p *Pipe, e eventMessage) (state, error) { switch e.event { case cancel: interrupt(p.cancel) err := Wait(p.errc) return nil, err case measure: e.params.applyTo(p.ID()) p.feedback = p.feedback.merge(e.params) return s, nil case push: e.params.applyTo(p.ID()) p.params = p.params.merge(e.params) return s, nil } return s, ErrInvalidState } // sendMessage   .   -, //      .    //    ,      .  , // ,   , : // 1.     // 2.      func (s activePausing) sendMessage(p *Pipe) state { m := p.newMessage() if len(m.feedback) == 0 { m.feedback = make(map[string][]phono.ParamFunc) } var wg sync.WaitGroup //     wg.Add(len(p.sinks)) //   Sink for _, sink := range p.sinks { param := phono.ReceivedBy(&amp;wg, sink.ID()) // - m.feedback = m.feedback.add(param) } p.consume &lt;- m //   wg.Wait() // ,     return paused }</span></span></code> </pre> <br><p>  Sobald alle Empf√§nger die Nachricht erhalten, wechselt die Pipeline <code>paused</code> Zustand.  Wenn die Nachricht die letzte ist, erfolgt der √úbergang in den <code>ready</code> . </p><br><h3 id="snova-za-rabotu">  Zur√ºck zur Arbeit! </h3><br><p>  Rufen Sie <code>p.Resume()</code> , um den <code>paused</code> Status zu <code>p.Resume()</code> . </p><br><p><img src="https://habrastorage.org/webt/vq/gu/dj/vqgudjnhdlifwyb6acyrkpbmkek.png"></p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Resume   resume  . //     pipe.Close  . func (p *Pipe) Resume() chan error { resumeEvent := eventMessage{ event: resume, target: target{ state: ready, errc: make(chan error, 1), }, } p.events &lt;- resumeEvent return resumeEvent.target.errc } // listen     paused. func (s idlePaused) listen(p *Pipe, t target) (state, target) { return p.idle(s, t) } // transition       . func (s idlePaused) transition(p *Pipe, e eventMessage) (state, error) { switch e.event { case cancel: interrupt(p.cancel) err := Wait(p.errc) return nil, err case push: e.params.applyTo(p.ID()) p.params = p.params.merge(e.params) return s, nil case measure: for _, id := range e.components { e.params.applyTo(id) } return s, nil case resume: return running, nil } return s, ErrInvalidState }</span></span></code> </pre> <br><p>  Hier ist alles trivial, die Pipeline geht wieder in <code>running</code> . </p><br><h3 id="svorachivaemsya">  Machen Sie es sich bequem </h3><br><p>  Der F√∂rderer kann aus jedem Zustand angehalten werden.  Daf√ºr gibt es <code>p.Close()</code> . </p><br><p><img src="https://habrastorage.org/webt/va/lt/tz/valttzm_l7cqsibb6mi1ntxh6vy.png"></p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Close   cancel  . //      . //    ,   . func (p *Pipe) Close() chan error { resumeEvent := eventMessage{ event: cancel, target: target{ state: nil, //   errc: make(chan error, 1), }, } p.events &lt;- resumeEvent return resumeEvent.target.errc }</span></span></code> </pre> <br><h2 id="komu-eto-nado">  Wer braucht das? </h2><br><p>  Nicht f√ºr jedermann.  Um genau zu verstehen, wie der Status verwaltet wird, m√ºssen Sie Ihre Aufgabe verstehen.  Es gibt genau zwei Umst√§nde, unter denen <em>Sie</em> eine ereignisbasierte asynchrone Maschine verwenden k√∂nnen: </p><br><ol><li>  Komplexer Lebenszyklus - Es gibt drei oder mehr Zust√§nde mit nichtlinearen √úberg√§ngen. </li><li>  Es wird eine asynchrone Ausf√ºhrung verwendet. </li></ol><br><p>  Obwohl die Ereignismaschine das Problem l√∂st, ist es ein ziemlich kompliziertes Muster.  Daher sollte es mit gro√üer Sorgfalt und nur nach einem vollst√§ndigen Verst√§ndnis aller Vor- und Nachteile verwendet werden. </p><br><h2 id="ssylki">  Referenzen </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phono</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lexer Rob Pike</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431048/">https://habr.com/ru/post/de431048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431036/index.html">"Die ganze Welt - Analyse" oder "Analyse"</a></li>
<li><a href="../de431040/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 340 (19. - 25. November 2018)</a></li>
<li><a href="../de431042/index.html">PHP Digest Nr. 144 (12. - 26. November 2018)</a></li>
<li><a href="../de431044/index.html">Die Staatsanwaltschaft zahlt zum ersten Mal f√ºr die illegale Sperrung der Website</a></li>
<li><a href="../de431046/index.html">Wie Z-Index tats√§chlich funktioniert</a></li>
<li><a href="../de431050/index.html">Die Illusion von Reinheit: Beeinflusst die Mineralisierung von Wasser seine Qualit√§t und wie hilft uns das TDS-Messger√§t?</a></li>
<li><a href="../de431052/index.html">Frontend DevDay: Karten, Teams, zwei Abfragen</a></li>
<li><a href="../de431056/index.html">USPACE: Drohnenzeit</a></li>
<li><a href="../de431058/index.html">Erste Schritte mit Unicorn Engine</a></li>
<li><a href="../de431060/index.html">Deutsches ID-Spoofing mit Online-Authentifizierung und Fl√ºchtlingsfinanzierung in Deutschland</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>