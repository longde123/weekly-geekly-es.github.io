<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✌️ 👸🏿 👦🏾 排序混乱 🏜️ 🛶 🤱🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="正如实践所表明的那样，出现问题的绝大部分不是因为解决方案本身，而是因为系统组件之间的通信是如何发生的。 如果系统组件之间的通信混乱，那么，由于您没有尝试很好地编写单个组件，因此整个系统将发生故障。 


 注意事项 里面的自行车。 
 问题或问题陈述 


 不久前，它碰巧在一家公司的项目上工作，该...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>排序混乱</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442380/"><p>正如实践所表明的那样，出现问题的绝大部分不是因为解决方案本身，而是因为系统组件之间的通信是如何发生的。 如果系统组件之间的通信混乱，那么，由于您没有尝试很好地编写单个组件，因此整个系统将发生故障。 </p><br><p> 注意事项 里面的自行车。 </p><a name="habracut"></a><br><h1 id="problematika-ili-postanovka-zadachi"> 问题或问题陈述 </h1><br><p> 不久前，它碰巧在一家公司的项目上工作，该公司将CRM，ERM系统和衍生产品之类的乐趣带给了大众。 此外，该公司发布了一种相当全面的产品，从收银机软件到呼叫中心，可以租用最多200人的话务员。 </p><br><p> 我本人致力于呼叫中心的前端应用程序。 </p><br><p> 不难想象，正是来自所有系统组件的信息才流入操作员的应用程序。 而且，如果我们考虑到它不是一个单一的操作员，而是一个经理和管理员的事实，那么您可以想象应用程序应该“消化”并相互关联的通信和信息量。 </p><br><p> 当该项目已经启动甚至运行稳定时，系统的透明性问题就出现了。 </p><br><p> 这就是重点。 有很多组件，它们都使用其数据源。 但是几乎所有这些组件都曾经被编写为独立产品。 那不是作为整个系统的组成部分，而是作为单独的销售决定。 结果，它们之间没有单一的（系统）API，也没有共同的通信标准。 </p><br><p> 我会解释。 某些组件发送JSON，“某人”发送带有键的行：里面的值，“某人”通常发送二进制文件，并随便使用它。 但是，呼叫中心的最终应用程序必须完全掌握并以某种方式处理它。 嗯，最重要的是，系统中没有链接可以识别出数据格式/结构已更改。 如果某个组件昨天发送了JSON，而今天决定发送二进制文件-没人会看到这一点。 仅最终应用程序将按预期开始崩溃。 </p><br><p> 很快就变得清楚了（因为我周围的人，而不是我，因为我在设计阶段就谈到了这个问题），组件之间缺乏“统一的通信语言”会导致严重的问题。 </p><br><p> 最简单的情况是客户端要求更改某些数据集。 例如，他们将任务分给年轻人，后者“持有”用于处理商品/服务数据库的组件。 他完成了自己的工作，实现了新的数据集，对他而言，混蛋，一切正常。 但是，更新之后的第二天……哦……呼叫中心中的应用程序突然开始无法正常工作。 </p><br><p> 您可能已经猜到了。 我们的英雄不仅更改了数据集，还更改了其组件发送到系统的数据结构。 结果，呼叫中心应用程序根本无法再使用此组件，并且其他依赖项沿链飞行。 </p><br><p> 他们开始考虑我们实际上想走的路。 因此，我们为可能的解决方案制定了以下要求： </p><br><p>  <strong>首先</strong> ，数据结构中的任何更改应立即在系统中“突出显示”。 如果有人在某处进行了更改，而这些更改与系统的预期不兼容，则在组件测试阶段应发生一个错误，该错误已被更改。 </p><br><p>  <strong>第二个</strong> 。 不仅应在编译期间检查数据类型，还应在运行时检查数据类型。 </p><br><p>  <strong>第三</strong> 。 由于大量具有完全不同技能水平的人员在组件上工作，因此描述语言应该更简单。 </p><br><p>  <strong>第四</strong> 。 无论采用哪种解决方案，都应尽可能方便地使用它。 如果可能，IDE应尽可能突出显示。 </p><br><p> 首先想到的是实现protobuf。 简单，易读且容易。 严格的数据键入。 这似乎是医生命令的。 但可惜，并非所有protobuf语法看起来都很简单。 此外，即使是已编译的协议也需要附加的库，但是protobuf不支持Javascript，这是社区工作的结果。 总的来说，他们拒绝了。 </p><br><p> 然后出现了用JSON描述协议的想法。 好吧，有多少容易？ </p><br><p> 好吧，然后我辞职了。 在这个职位上本该完成的，因为在我离开后，没有其他人开始特别关注这个问题。 </p><br><p> 但是，考虑到几个个人项目，组件之间的通信问题再次发挥了全部潜力，我决定自己开始实施该想法。 下面将讨论什么。 </p><br><p> 因此，我提请您注意<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ceres</a>项目，其中包括： </p><br><ul><li> 协议生成器 </li><li> 提供者 </li><li> 客户 </li><li> 实施运输 </li></ul><br><h1 id="protokol"> 协议书 </h1><br><p> 我们的任务是做到： </p><br><ul><li> 在系统中设置消息结构很容易。 </li><li> 确定所有消息字段的数据类型很容易。 </li><li> 可以定义辅助实体并引用它们。 </li><li> 当然，IDE会突出显示所有这些内容 </li></ul><br><p> 我认为，以一种完全自然的方式，作为将协议转换成的语言，Typescript被选择为非纯Javascript。 也就是说，协议生成器所做的只是将JSON转换为Typescript。 </p><br><p> 要描述系统中可用的消息，您只需知道什么是JSON。 我敢肯定，没有人有任何问题。 </p><br><p> 除了提供Hello World之外，我还提供了不少讲究的示例-聊天。 </p><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Events"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"NewMessage"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"ChatMessage"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"UsersListUpdated"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"users"</span></span>: <span class="hljs-string"><span class="hljs-string">"Array&lt;User&gt;"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"Requests"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"GetUsers"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"AddUser"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: <span class="hljs-string"><span class="hljs-string">"User"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"Responses"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"UsersList"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"users"</span></span>: <span class="hljs-string"><span class="hljs-string">"Array&lt;User&gt;"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"AddUserResult"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"error?"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"ChatMessage"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"nickname"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"utf8String"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"created"</span></span>: <span class="hljs-string"><span class="hljs-string">"datetime"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"User"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"nickname"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.1"</span></span> }</code> </pre> <br><p> 一切都非常简单。 我们有几个NewMessage和UsersListUpdated事件。 以及几个UsersList和AddUserResult请求。 还有两个实体：ChatMessage和User。 </p><br><p> 如您所见，描述非常透明且易于理解。 关于规则的一些知识。 </p><br><ul><li>  JSON中的对象将成为生成的协议中的类 </li><li> 属性值是数据类型定义或对类（实体）的引用 </li><li> 从生成协议的角度来看，嵌套对象将成为“嵌套”类，也就是说，嵌套对象将继承其父级的所有属性。 </li></ul><br><p> 现在，您需要做的就是生成一个协议以开始使用它。 </p><br><pre> <code class="bash hljs">npm install ceres.protocol -g ceres.protocol -s chat.protocol.json -o chat.protocol.ts -r</code> </pre> <br><p> 结果，我们得到了Typescript生成的协议。 我们连接并使用： </p><br><img src="https://habrastorage.org/getpro/habr/post_images/c1b/826/96a/c1b82696aecdf2ccc5b5ededd9e7818b.gif" alt="图片"><br><p> 因此，该协议已经为开发人员提供了一些帮助： </p><br><ul><li>  IDE突出显示了协议中的内容。  IDE还突出显示了所有预期的属性。 </li><li>  Typescript，它肯定会告诉我们数据类型是否有问题。 当然，这是在开发阶段完成的，但是协议本身已经在运行时检查数据类型，并且如果检测到违规，则引发异常 </li><li> 通常，您可以忘记验证。 该协议将进行所有必要的检查。 </li><li> 生成的协议不需要任何其他库。 他需要工作的所有内容，已经包含在内。 而且非常方便。 </li></ul><br><blockquote> 是的，至少可以说，所生成协议的大小可能会让您感到惊讶。 但是，不要忘了压缩，生成的协议文件很适合自己使用。 </blockquote><p> 现在我们可以“打包”邮件并发送 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> message: Protocol.ChatMessage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.ChatMessage({ <span class="hljs-attr"><span class="hljs-attr">nickname</span></span>: <span class="hljs-string"><span class="hljs-string">'noname'</span></span>, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>, <span class="hljs-attr"><span class="hljs-attr">created</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> packet: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span> = message.stringify(); <span class="hljs-comment"><span class="hljs-comment">// Send packet somewhere</span></span></code> </pre> <br><p> 在此处进行保留很重要，数据包将是一个字节数组，从流量负载的角度来看，这是非常好的且正确的，因为发送相同的JSON“成本”当然会更昂贵。 但是，该协议有一个窍门-在调试模式下，它将生成可读的JSON，以便开发人员可以“查看”流量并查看会发生什么。 </p><br><p> 这是在运行时直接完成的。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> message: Protocol.ChatMessage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.ChatMessage({ <span class="hljs-attr"><span class="hljs-attr">nickname</span></span>: <span class="hljs-string"><span class="hljs-string">'noname'</span></span>, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>, <span class="hljs-attr"><span class="hljs-attr">created</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() }); <span class="hljs-comment"><span class="hljs-comment">// Switch to debug mode Protocol.Protocol.state.debug(true); // Now packet will be present as JSON string const packet: string = message.stringify(); // Send packet somewhere</span></span></code> </pre> <br><p> 在服务器（或任何其他收件人）上，我们可以轻松地将邮件拆包： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> smth = Protocol.parse(packet); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smth <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Oops. Something wrong with this packet. } if (Protocol.ChatMessage.instanceOf(smth) === true) { // This is chat message }</span></span></code> </pre> <br><p> 该协议支持所有主要数据类型： </p><br><table><thead><tr><th> 型式 </th><th> 价值观 </th><th> 内容描述 </th><th> 大小，字节 </th></tr></thead><tbody><tr><td>  utf8String </td><td></td><td>  UTF8编码的字符串 </td><td>  X </td></tr><tr><td>  asciiString </td><td></td><td>  ASCII字符串 </td><td>  1个字符-1个字节 </td></tr><tr><td>  int8 </td><td>  -128至127 </td><td></td><td>  1个 </td></tr><tr><td>  int16 </td><td>  -32768至32767 </td><td></td><td>  2 </td></tr><tr><td>  int32 </td><td>  -2147483648至2147483647 </td><td></td><td>  4 </td></tr><tr><td>  uint8 </td><td>  0至255 </td><td></td><td>  1个 </td></tr><tr><td>  uint16 </td><td>  0至65535 </td><td></td><td>  2 </td></tr><tr><td>  uint32 </td><td>  0至4294967295 </td><td></td><td>  4 </td></tr><tr><td>  float32 </td><td>  1.2x10 <sup>-38</sup>至3.4x10 <sup>38</sup> </td><td></td><td>  4 </td></tr><tr><td>  float64 </td><td>  <sup>5.0x10 -324</sup>至<sup>1.8x10</sup> <sup>308</sup> </td><td></td><td>  8 </td></tr><tr><td> 布尔值 </td><td></td><td></td><td>  1个 </td></tr></tbody></table><br><p> 在协议中，这些数据类型称为原始数据。 但是，该协议的另一个功能是它允许您添加自己的数据类型（称为“其他数据类型”）。 </p><br><p> 例如，您可能已经注意到<strong>ChatMessage</strong>具有一个带有<strong>日期时间</strong>数据类型的<strong>创建</strong>字段。 在应用程序级别-此类型对应于<strong>Date</strong> ，并且协议内部将其存储为<strong>uint32</strong> （并发送）。 </p><br><p> 将类型添加到协议中非常简单。 例如，如果我们要具有<strong>电子邮件</strong>数据类型，请对协议中的以下消息说： </p><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"User"</span></span>: { <span class="hljs-string"><span class="hljs-string">"nickname"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span>, <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">"email"</span></span> }, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.1"</span></span> }</code> </pre> <br><p> 您所需要做的就是为电子邮件类型编写一个定义。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AdvancedTypes: { [key:string]: any} = { <span class="hljs-attr"><span class="hljs-attr">email</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// Binary type or primitive type binaryType : 'asciiString', // Initialization value. This value is used as default value init : '""', // Parse value. We should not do any extra decode operations with it parse : (value: string) =&gt; { return value; }, // Also we should not do any encoding operations with it serialize : (value: string) =&gt; { return value; }, // Typescript type tsType : 'string', // Validation function to valid value validate : (value: string) =&gt; { if (typeof value !== 'string'){ return false; } if (value.trim() === '') { // Initialization value is "''", so we allow use empty string. return true; } const validationRegExp = /^(([^&lt;&gt;()\[\]\\.,;:\s@"]+(\.[^&lt;&gt;()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/gi; return validationRegExp.test(value); }, } };</span></span></code> </pre> <br><p> 仅此而已。 通过生成协议，我们获得了对新<strong>电子邮件</strong>数据类型的支持。 当我们尝试使用错误的地址创建实体时，会出现错误 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user: Protocol.User = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.User({ <span class="hljs-attr"><span class="hljs-attr">nickname</span></span>: <span class="hljs-string"><span class="hljs-string">'Brad'</span></span>, <span class="hljs-attr"><span class="hljs-attr">email</span></span>: <span class="hljs-string"><span class="hljs-string">'not_valid_email'</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user);</code> </pre> <br><p> 喔... </p><br><pre> <code class="bash hljs">Error: Cannot create class of <span class="hljs-string"><span class="hljs-string">"User"</span></span> due error(s): - Property <span class="hljs-string"><span class="hljs-string">"email"</span></span> has wrong value; validation was failed with value <span class="hljs-string"><span class="hljs-string">"not_valid_email"</span></span>.</code> </pre> <br><p> 因此，该协议根本不允许“不良”数据进入系统。 </p><br><p> 请注意，在定义新的数据类型时，我们指定了几个关键属性： </p><br><ul><li>  <strong>binaryType-</strong>对原始数据类型的引用，应用于存储，编码/解码数据。 在这种情况下，我们指示该地址是一个ascii字符串。 </li><li>  <strong>tsType</strong>是对Javascript类型的引用，即在Javascript环境中应如何表示数据类型。 在这种情况下，我们正在谈论<strong>字符串</strong> </li><li> 还值得注意的是，仅在生成协议时才需要定义新的数据类型。 在输出中，我们获得了已包含新数据类型的生成协议。 </li></ul><br><blockquote> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ceres.protocol上</a>查看有关所有协议功能的详细信息。 </blockquote><br><h1 id="provayder-i-klient"> 提供者和客户 </h1><br><p> 总的来说，协议本身可以用于组织通信。 但是，如果我们谈论的是浏览器和nodejs，则提供程序和客户端都可用。 </p><br><h2 id="klient"> 顾客 </h2><br><h3 id="sozdanie"> 创作 </h3><br><p> 要创建客户端，您需要客户端和传输。 </p><br><p> 安装方式 </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Install consumer (client) npm install ceres.consumer --save # Install transport npm install ceres.consumer.browser.ws --save</span></span></code> </pre> <br><p> 创作 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transport, { ConnectionParameters } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer.browser.ws'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Consumer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create transport const transport:Transport = new Transport(new ConnectionParameters({ host: 'http://localhost', port: 3005, wsHost: 'ws://localhost', wsPort: 3005, })); // Create consumer const consumer: Consumer = new Consumer(transport);</span></span></code> </pre> <br><blockquote> 客户端和提供者都是专门为协议设计的。 也就是说，它们仅适用于协议（ceres.protocol）。 </blockquote><br><h3 id="sobytiya"> 大事记 </h3><br><p> 创建客户端后，开发人员可以订阅事件 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transport, { ConnectionParameters } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer.browser.ws'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Consumer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create transport const transport:Transport = new Transport(new ConnectionParameters({ host: 'http://localhost', port: 3005, wsHost: 'ws://localhost', wsPort: 3005, })); // Create consumer const consumer: Consumer = new Consumer(transport); // Subscribe to event consumer.subscribe(Protocol.Events.NewMessage, (message: Protocol.Events.NewMessage) =&gt; { console.log(`New message came: ${message.message}`); }).then(() =&gt; { console.log('Subscription to "NewMessage" is done'); }).catch((error: Error) =&gt; { console.log(`Fail to subscribe to "NewMessage" due error: ${error.message}`); });</span></span></code> </pre> <br><p> 请注意，只有在消息数据完全正确的情况下，客户端才会调用事件处理程序。 换句话说，我们的应用程序受到保护以防止错误数据，并且<strong>NewMessage</strong>事件处理程序将始终以<strong>Protocol.Events.NewMessage</strong>实例作为参数来调用。 </p><br><p> 当然，客户端可以生成事件。 </p><br><pre> <code class="javascript hljs">consumer.emit(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Events.NewMessage({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'This is new message'</span></span> })).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`New message was sent`</span></span>); }).catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error: </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Error</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Fail to send message due error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error.message}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre> <br><p> 请注意，我们没有在任何地方指定事件名称，我们只是使用协议中指向类的链接，或者传递它的实例。 </p><br><p> 我们还可以通过指定类型为<code>{ [key: string]: string }</code>的简单对象作为第二个参数，将消息发送给有限的一组收件人。 在ceres中，此对象称为<strong>query</strong> 。 </p><br><pre> <code class="javascript hljs">consumer.emit( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Events.NewMessage({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'This is new message'</span></span> }), { <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">"UK"</span></span> } ).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`New message was sent`</span></span>); }).catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error: </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Error</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Fail to send message due error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error.message}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre> <br><p> 因此，通过另外指示<code>{ location: "UK" }</code> ，我们可以确保只有已将自己的位置标识为英国的客户才能收到此消息。 </p><br><p> 要将客户端本身与特定<strong>查询</strong>相关联，您只需调用<strong>ref</strong>方法： </p><br><pre> <code class="javascript hljs">consumer.ref({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'12345678'</span></span>, <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">'UK'</span></span> }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Client successfully bound with query`</span></span>); });</code> </pre> <br><p> 在将客户端与<strong>查询</strong>连接后，他就有机会接收“个人”或“组”消息。 </p><br><h3 id="zaprosy"> 咨询处 </h3><br><p> 我们也可以提出要求 </p><br><pre> <code class="javascript hljs">consumer.request( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Requests.GetUsers(), <span class="hljs-comment"><span class="hljs-comment">// Request Protocol.Responses.UsersList // Expected response ).then((response: Protocol.Responses.UsersList) =&gt; { console.log(`Available users: ${response.users}`); }).catch((error: Error) =&gt; { console.log(`Fail to get users list due error: ${error.message}`); });</span></span></code> </pre> <br><p> 值得注意的是，作为第二个参数，我们指定了预期的结果（ <strong>Protocol.Responses.UsersList</strong> ），这意味着仅当响应是<strong>UsersList</strong>的实例时，我们的请求才会成功完成，在所有其他情况下，我们将“落入”赶上 同样，这可以确保我们避免处理不正确的数据。 </p><br><p> 客户本人也可以与可以处理请求的人员交谈。 为此，您只需要“确定”自己为该请求的“负责人”即可。 </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequestGetUsers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request: Protocol.Requests.GetUsers, callback: (error: Error | null, results : any </span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Get user list somehow const users: Protocol.User[] = []; // Prepare response const response = new Protocol.Responses.UsersList({ users: users }); // Send response callback(null, response); // Or send error // callback(new Error(`Something is wrong`)) }; consumer.listenRequest(Protocol.Requests.GetUsers, processRequestGetUsers, { location: "UK" }).then(() =&gt; { console.log(`Consumer starts listen request "GetUsers"`); });</span></span></code> </pre> <br><p> 注意，可选地，作为第三个参数，我们可以指定一个可用于标识客户端的<strong>查询</strong>对象。 因此，如果有人发送带有查询的<strong>查询</strong> ，例如<code>{ location: "RU" }</code> ，那么我们的客户将不会收到这样的请求，因为他的查询<code>{ location: "UK" }</code> 。 </p><br><p>  <strong>查询</strong>可以包含无限数量的属性。 例如，您可以指定以下内容 </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">"UK"</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"managers"</span></span> }</code> </pre> <br><p> 然后，除了完整的<strong>查询</strong>匹配外，我们还将成功处理以下查询： </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">"UK"</span></span> }</code> </pre> <br><p> 或 </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"managers"</span></span> }</code> </pre> <br><h2 id="provayder"> 提供者 </h2><br><h3 id="sozdanie-1"> 创作 </h3><br><p> 要创建提供程序（以及创建客户端），您需要提供程序和传输。 </p><br><p> 安装方式 </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Install provider npm install ceres.provider --save # Install transport npm install ceres.provider.node.ws --save</span></span></code> </pre> <br><p> 创作 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transport, { ConnectionParameters } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.provider.node.ws'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Provider <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.provider'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create transport const transport:Transport = new Transport(new ConnectionParameters({ port: 3005 })); // Create provider const provider: Provider = new Provider(transport);</span></span></code> </pre> <br><p> 从创建提供程序的那一刻起，它就可以接受来自客户端的连接。 </p><br><h3 id="sobytiya-1"> 大事记 </h3><br><p> 与客户端一样，提供程序也可以“监听”消息并生成消息。 </p><br><p> 倾听 </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Subscribe to event provider.subscribe(Protocol.Events.NewMessage, (message: Protocol.Events.NewMessage) =&gt; { console.log(`New message came: ${message.message}`); });</span></span></code> </pre> <br><p> 产生 </p><br><pre> <code class="javascript hljs">provider.emit(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Events.NewMessage({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'This message from provider'</span></span> }));</code> </pre> <br><h3 id="zaprosy-1"> 咨询处 </h3><br><p> 当然，提供者可以（并且应该）“监听”请求 </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequestGetUsers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request: Protocol.Requests.GetUsers, clientID: string, callback: (error: Error | null, results : any </span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Request from client </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${clientId}</span></span></span><span class="hljs-string"> was gotten.`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Get user list somehow const users: Protocol.User[] = []; // Prepare response const response = new Protocol.Responses.UsersList({ users: users }); // Send response callback(null, response); // Or send error // callback(new Error(`Something is wrong`)) }; provider.listenRequest(Protocol.Requests.GetUsers, processRequestGetUsers).then(() =&gt; { console.log(`Consumer starts listen request "GetUsers"`); });</span></span></code> </pre> <br><p> 与客户端只有一个区别，提供者除请求正文外还将收到唯一的<strong>clientId</strong> ，该<strong>ID</strong>将自动分配给所有连接的客户端。 </p><br><h1 id="primer"> 例子 </h1><br><p> 实际上，我真的不想让您从文档摘录中感到无聊，我相信只要看一小段代码，对您来说就会更加容易和有趣。 </p><br><p> 您可以通过下载<a href="">源代码</a>并执行几个简单的操作来轻松安装聊天示例 </p><br><p> 客户端安装和启动 </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chat/client npm install npm start</code> </pre> <br><p> 客户端将在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http：// localhost：3000上</a>可用。 立即与客户端打开几个选项卡，以查看“通信”。 </p><br><p> 提供程序（服务器）的安装和启动 </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chat/server npm install ts-node ./server.ts</code> </pre> <br><p> 我确定您熟悉<strong>ts-node</strong>程序包，但如果不熟悉，它将允许您运行TS文件。 如果您不想安装，请编译服务器，然后运行JS文件。 </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chat/server npm run build node ./build/server/server.js</code> </pre> <br><h1 id="sho-opyat"> 什么啊 再次？ </h1><br><p> 由于从Protobuf到BMW的铁杆Joynr，已经有许多可行的解决方案，因此人们预想着为什么要发明另一辆自行车的问题，我只能说这对我很有趣。 整个项目都是在没有工作的情况下，仅靠个人主动完成的，这是我的业余时间。 </p><br><p> 这就是为什么您的反馈对我<strong>特别重要</strong> 。 为了以某种方式激励您，我可以保证，对于github上的每个星星，我都会抚摸它的仓鼠（从某种程度上来说，我不喜欢它）。 对于叉子，呃，我要抓他的pussiko ... brrrr。 </p><br><p>  <em>仓鼠不是我的，儿子的仓鼠</em> 。 </p><br><p> 另外，该项目将在几周内对我以前的同事（我在帖子开头提到并且对alfa版本感兴趣的人）进行测试。 目标是调试并在多个组件上运行。 我真的希望它能起作用。 </p><br><h1 id="ssylki-i-pakety"> 链接和包装 </h1><br><p> 该项目由两个存储库托管 </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ceres</a>来源：ceres.provider，ceres.consumer和今天可用的所有交通工具。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ceres.protocol</a>协议生成器源 </li></ul><br><p>  NPM以下软件包可用 </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ceres.protocol</a>协议生成器 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ceres.provider</a>提供者 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">消费</a>客户 </li><li> 基于长轮询的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ceres.provider.node.longpoll</a>传输提供程序 </li><li>  <a href="">ceres.provider.node.ws</a>基于Web Socket的提供程序的传输 </li><li> 基于长轮询的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ceres.consumer.browser.longpoll</a>客户端传输 </li><li>  <a href="">ceres.consumer.browser.ws</a>基于Web套接字的客户端传输 </li></ul><br><p> 好又轻。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN442380/">https://habr.com/ru/post/zh-CN442380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN442370/index.html">从“ node_modules”文件夹中延迟加载功能模块</a></li>
<li><a href="../zh-CN442372/index.html">在语言环境中进行可靠的编程。 第2部分-挑战者</a></li>
<li><a href="../zh-CN442374/index.html">基于DSP的升压转换器的开发：工作原理，计算，原型设计</a></li>
<li><a href="../zh-CN442376/index.html">零售地块密度</a></li>
<li><a href="../zh-CN442378/index.html">在Booking com界面中单击一下可能会破坏假期或为什么工作评分系统很重要</a></li>
<li><a href="../zh-CN442384/index.html">扩展标准音频系统的功能</a></li>
<li><a href="../zh-CN442386/index.html">Thymeleaf：方言布局+ Spring Boot 2</a></li>
<li><a href="../zh-CN442392/index.html">NodeJS记录正确</a></li>
<li><a href="../zh-CN442396/index.html">3月4日至3月10日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN442402/index.html">最重要的。 与外部服务集成</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>