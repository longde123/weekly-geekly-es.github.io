<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÉ üìù üñ•Ô∏è Acesso aos pneus Redd nas pontes FTDI üßíüèΩ üë©üèæ‚Äçü§ù‚Äçüë©üèΩ ‚úã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Conclu√≠mos um grande bloco te√≥rico mostrando como construir um subsistema FPGA para o complexo Redd; como organizar a comunica√ß√£o entre o FPGA e o pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Acesso aos pneus Redd nas pontes FTDI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477662/">  Conclu√≠mos um grande bloco te√≥rico mostrando como construir um subsistema FPGA para o complexo Redd;  como organizar a comunica√ß√£o entre o FPGA e o processador central do complexo;  qu√£o f√°cil √© salvar fluxos de dados de alta velocidade na RAM, que est√° diretamente conectada ao FPGA, para posterior transfer√™ncia lenta para o processador central (ou vice-versa, para colocar dados nessa RAM para posterior sa√≠da r√°pida no canal).  Revisamos as t√©cnicas de rastreamento do processador Nios II.  Podemos otimizar o desempenho do sistema do processador com base no Nios II para que o trabalho seja o mais eficiente poss√≠vel.  Em geral, estudamos toda a teoria m√≠nima necess√°ria, e seria hora de come√ßar a praticar projetando um dispositivo n√£o muito complexo, mas praticamente √∫til ... Mas h√° uma MAS. <br><br>  Pelos coment√°rios dos artigos, notei que alguns leitores acreditam que Redd e FPGA s√£o como Lenin e o Partido.  Que eles est√£o inextricavelmente ligados.  De fato, isso n√£o √© verdade.  Eu s√≥ queria come√ßar uma conversa sobre o complexo Redd com algo interessante, mas o que poderia ser mais interessante que o FPGA?  Bem, e iniciando uma conversa, interromper de relance √© est√∫pido.  E, finalmente, o grande bloco l√≥gico est√° completo.  E para mostrar que os FPGAs est√£o longe de todo o Redd, proponho fazer aproximadamente tr√™s artigos sobre coisas que n√£o est√£o relacionadas a eles.  Bem, e tendo completado este bloco, j√° v√° para a pr√°tica de FPGA. <br><br><img src="https://habrastorage.org/webt/nu/nw/7p/nunw7p7f7c5hcnmlsv7haliroz8.png"><br><a name="habracut"></a><br><h2>  1. Introdu√ß√£o </h2><br>  O mais surpreendente √© que, assim que decidi fazer uma digress√£o em outros t√≥picos, os bons chefes me jogaram em uma batalha dif√≠cil em um projeto em que o trabalho est√° em andamento com a linguagem VHDL e o Xilinx FPGA.  Primeiro, √© por isso que durante muito tempo n√£o peguei uma caneta em geral e, em segundo lugar, fica claro que a prepara√ß√£o de artigos pr√°ticos exige um grande n√∫mero de experimentos.  √â um pouco dif√≠cil lidar com VHDL / Verilog e Xilinx / Altera ao mesmo tempo.  Portanto, uma pausa nas hist√≥rias sobre FPGAs teria que ser feita de qualquer maneira. <br><br>  Ent√£o  No <a href="https://habr.com/ru/post/452656/">primeiro artigo da s√©rie,</a> j√° examinamos o diagrama estrutural do complexo Redd.  Vamos fazer mais uma vez. <br><br><img src="https://habrastorage.org/webt/vf/hv/da/vfhvda1kmsax-zkxaue4xu_ysmk.png"><br><br>  No artigo de hoje, √© improv√°vel que os especialistas em Linux encontrem muitas informa√ß√µes valiosas, mas vale a pena examinar as imagens superficialmente.  Aqueles que, como eu, est√£o acostumados a trabalhar no Windows, encontrar√£o uma lista de t√©cnicas prontas que permitem trabalhar com o complexo.  Em geral, este artigo trar√° as habilidades desses e de outros grupos de leitores para um denominador comum. <br><br><div class="spoiler">  <b class="spoiler_title">Artigos anteriores do ciclo</b> <div class="spoiler_text"><ol><li>  <a href="https://habr.com/ru/post/452656/">Desenvolvimento do ‚Äúfirmware‚Äù mais simples para FPGAs instalados no Redd e depura√ß√£o usando o teste de mem√≥ria como exemplo.</a> </li><li>  <a href="https://habr.com/ru/post/453682/">Desenvolvimento do ‚Äúfirmware‚Äù mais simples para FPGAs instalados em Redd.</a>  <a href="https://habr.com/ru/post/453682/">Parte 2. C√≥digo do programa.</a> </li><li>  <a href="https://habr.com/ru/post/454938/">Desenvolvimento de n√∫cleo pr√≥prio para incorpora√ß√£o em um sistema de processador baseado em FPGA.</a> </li><li>  <a href="https://habr.com/ru/post/456008/">Desenvolvimento de programas para o processador central Redd no exemplo de acesso ao FPGA.</a> </li><li>  <a href="https://habr.com/ru/post/462253/">As primeiras experi√™ncias usando o protocolo de streaming no exemplo da comunica√ß√£o da CPU e do processador no FPGA do Redd.</a> </li><li>  <a href="https://habr.com/ru/post/464795/">Merry Quartusel, ou como o processador ganhou vida.</a> </li><li>  <a href="https://habr.com/ru/post/467353/">M√©todos de otimiza√ß√£o de c√≥digo para Redd.</a>  <a href="https://habr.com/ru/post/467353/">Parte 1: efeito de cache.</a> </li><li>  <a href="https://habr.com/ru/post/468027/">M√©todos de otimiza√ß√£o de c√≥digo para Redd.</a>  <a href="https://habr.com/ru/post/468027/">Parte 2: mem√≥ria n√£o armazenada em cache e opera√ß√£o de barramento paralelo.</a> </li><li>  <a href="https://habr.com/ru/post/469985/">Otimiza√ß√£o abrangente de c√≥digo: substituindo um gerador de rel√≥gio para melhorar o desempenho do sistema.</a> </li></ol><br></div></div><br><h2>  Blocos UART (portas seriais) </h2><br>  No diagrama de blocos, vemos o controlador FT4232 que implementa 4 portas seriais (UART): <br><br><img src="https://habrastorage.org/webt/75/bh/hy/75bhhyfnu_19uedfnkc7bzyrido.png"><br><br>  Mas se voc√™ falar um pouco mais globalmente, o complexo Redd n√£o ter√° quatro, mas seis portas seriais.  Os quatro mencionados acima t√™m n√≠veis de CMOS e mais dois s√£o soldados na placa-m√£e, porque o complexo √© baseado em um PC comum. <br><br><img src="https://habrastorage.org/webt/14/vj/pl/14vjplsdplqalj4lcm-4g4nmnvg.png"><br><br>  Conseq√ºentemente, eles t√™m n√≠veis - RS232 (mais ou menos 12 volts).  Portas RS232 - tudo fica claro com elas, elas s√£o exibidas na forma de dois conectores DB-9 padr√£o, <br><br><img src="https://habrastorage.org/webt/xk/d0/h6/xkd0h6xvaxlz7gxl8v-r4t9n8de.png"><br><br>  e onde procurar linhas com n√≠veis de CMOS?  Em geral - em um conector comum.  Sua pinagem √© mostrada no diagrama do circuito el√©trico.  Entre outras coisas, existem contatos correspondentes ao UART. <br><br><img src="https://habrastorage.org/webt/nm/pv/cr/nmpvcraxowuy0oea7wkin1aqulu.png"><br><br>  Externamente, esse conector tem a seguinte apar√™ncia: <br><br><img src="https://habrastorage.org/webt/mf/qa/8h/mfqa8hkbar6y7u8shn39eiend2a.png"><br><br>  Como us√°-lo depende da tarefa.  Voc√™ pode fazer um chicote para conectar cada dispositivo.  Essa abordagem √© √∫til se algu√©m usar o complexo Redd para testar dispositivos fabricados periodicamente do mesmo tipo.  Mas o principal objetivo do complexo ainda √© depurar o equipamento que est√° sendo desenvolvido.  E, nesse caso, √© mais f√°cil se conectar a ele de forma tempor√°ria.  Esse padr√£o tempor√°rio √© vis√≠vel nos protetores de tela para todos os artigos: os fios Aruino s√£o inseridos diretamente no conector.  √â claro que contar contatos ainda √© um prazer e, se eles desaparecerem acidentalmente, √© t√£o dif√≠cil restaurar a troca que √© mais f√°cil reconectar tudo do zero;  portanto, para facilitar a vida √∫til, existe uma placa riser √† qual voc√™ pode conectar pelo menos com a ajuda de conectores de duas linhas, pelo menos com a mesma fia√ß√£o do Arduino. <br><br><img src="https://habrastorage.org/webt/rb/we/66/rbwe66z9f5eahs3efqpxq93di6e.png"><br><br><h2>  Acesso ao software UART </h2><br>  A porta serial √© um elemento bem estabelecido e bem padronizado; portanto, o trabalho com ela n√£o passa por algumas bibliotecas FTDI espec√≠ficas, mas por meios padr√£o.  Vamos ver como essas ferramentas ficam no Linux. <br><br><h4>  Nomes de portas </h4><br>  De v√°rios artigos e f√≥runs na rede, segue-se que os nomes das portas fornecidas pelos adaptadores USB-Serial est√£o no formato / dev / ttyUSB0, / dev / ttyUSB1 e assim por diante.  No Linux, todos os dispositivos podem ser visualizados usando os mesmos comandos da exibi√ß√£o de diret√≥rios comuns (na verdade, os dispositivos s√£o os mesmos arquivos).  Vamos ver quais nomes est√£o em nosso sistema.  N√≥s damos o comando: <br>  <b>ls / dev /</b> <br><br><img src="https://habrastorage.org/webt/dj/ho/4g/djho4ghfwyceuqy6fjzezh3gyo8.png"><br><br>  Os nomes que nos interessam est√£o destacados em vermelho.  Algo muitos deles.  Qual porta corresponde a qu√™?  Aqueles que s√£o bem versados ‚Äã‚Äãno Linux conhecem milhares de feiti√ßos para todas as ocasi√µes.  Mas para aqueles que ainda trabalharam com o Windows 3.1 (bem, em paralelo com a ent√£o bastante animada RT-11), ainda √© dif√≠cil lembrar, com a idade a nova √© mais dif√≠cil de lembrar.  Portanto, √© mais f√°cil encontrar tudo o tempo todo, usando maneiras simples.  E destaquei a entrada desse caminho simples com uma moldura verde.  Serial do subdiret√≥rio condicional.  Agora estamos vendo o espa√ßo <b>para</b> nome <b>/ dev /</b> .  E vamos ver o espa√ßo <b>/ dev / serial</b> : <br><br><img src="https://habrastorage.org/webt/kw/fc/31/kwfc3189zwxl3ut80xwehvplt70.png"><br><br>  √ìtimo!  N√≥s nos aprofundamos na hierarquia, observamos o espa√ßo <b>/ dev / serial / by-id</b> .  Olhando para o futuro, direi que, para a exibi√ß√£o correta, voc√™ precisa usar o <b>comando ls</b> com a op√ß√£o <b>‚Äìl</b> (obrigado ao meu chefe pelo esclarecimento).  Ou seja, damos o comando: <br>  <b>ls ‚Äìl / dev / serial / by-id</b> <br><br><img src="https://habrastorage.org/webt/qq/vl/vd/qqvlvdgcgak3c5cembrbmj4myue.png"><br><br>  Por um lado, est√° tudo bem.  Agora sabemos quais nomes no espa√ßo <b>/ dev / ttyUSBX</b> correspondem a qual dispositivo.  Em particular, as portas organizadas pela ponte FT4232 (Quad) t√™m nomes de <b>ttyUSB3</b> a <b>ttyUSB6</b> .  Mas, por outro lado, ao considerar esse site, percebi que em Paris, na c√¢mara de pesos e medidas, deve haver necessariamente uma sala na qual o padr√£o da bagun√ßa √© colocado ... Porque, de alguma forma, voc√™ precisa ser capaz de medir seu valor.  Bem, digamos que a falta de portas <b>/ dev / ttyUSB0</b> e <b>/ dev / ttyUSB1</b> possa ser facilmente explicada.  Mas como explicar que as portas ‚Äúnativas‚Äù baseadas na prole da ponte FTDI instalada s√£o numeradas das tr√™s principais e o controlador Prolific de terceiros, inserido em um projeto espec√≠fico, recebeu a porta n√∫mero 2?  Como algu√©m pode trabalhar nesse ambiente?  Amanh√£ algu√©m conectar√° outro controlador ao complexo (j√° que o complexo permite que diferentes grupos de desenvolvedores trabalhem com equipamentos diferentes ao mesmo tempo), e as portas se mover√£o novamente.  Quais portas precisamos registrar no arquivo de configura√ß√£o para um aplicativo em funcionamento? <br><br>  Acontece que nem tudo √© t√£o ruim.  Primeiramente, o nome amarelo <b>/ dev / ttyUSB3</b> e o nome azul <b>/ dev / serial / by-id / usb-FTDI_Quad_RS232-HS-if00-port0</b> s√£o dois aliases do mesmo dispositivo.  E a segunda op√ß√£o tamb√©m pode ser apresentada como o nome da porta, mas j√° √© mais permanente que a primeira.  √â verdade que, neste caso, tudo est√° um pouco ruim.  Um controlador externo baseado no FT4232 pode ser conectado ao complexo e j√° ser√° necess√°rio lidar com sua numera√ß√£o.  E aqui "em segundo lugar" vem em nosso aux√≠lio.  Ou seja, outra conven√ß√£o de nomenclatura alternativa.  Lembramos que o <b>diret√≥rio / dev / serial</b> continha n√£o apenas o subdiret√≥rio <b>/ by-id</b> , mas tamb√©m o subdiret√≥rio <b>/ by-path</b> .  Verificamos seu conte√∫do (ele est√° localizado na parte inferior da pr√≥xima figura, sob uma linha vermelha). <br><br><img src="https://habrastorage.org/webt/y1/mm/xa/y1mmxabnvjburuzedzirgzusjbm.png"><br><br>  Tudo aqui est√° ligado √† arquitetura f√≠sica.  E eu j√° disse muitas vezes que todos os controladores dentro do complexo s√£o soldados aos quadros, para que a hierarquia interna n√£o mude.  Portanto, o nome <b>/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.0-port0</b> ser√° o mais dif√≠cil. <br><br>  No total, temos a seguinte maneira de procurar o nome da porta (isso deve ser feito uma vez, os resultados para sua inst√¢ncia do complexo podem ser colocados na tabela e usados ‚Äã‚Äãconstantemente): <br><br><ol><li>  Emita o comando <b>ls ‚Äìl / dev / serial / by-id</b> . </li><li>  Emita o <b>comando ls ‚Äìl / dev / serial / by-path</b> . </li><li>  A partir dos resultados do ponto 1, encontre o nome da porta correspondente √† porta necess√°ria da ponte requerida.  Encontre o mesmo nome da porta nos resultados do par√°grafo 2. Pegue o nome f√≠sico correspondente a este par√°grafo. </li></ol><br>  Para as portas atendidas pelo controlador na placa-m√£e, tudo √© um pouco mais complicado.  Aqui voc√™ n√£o pode fazer o caminho a partir do comando mais simples " <b>ls / dev</b> ", mas precisa se lembrar de algo (bem, ou pelo menos lembre-se de que pode entrar em contato aqui para obter ajuda).  Em todo lugar, diz que os nomes de porta t√≠picos s√£o <b>ttyS0-ttyS3</b> .  A quest√£o permanece: em que nomes as portas reais de nosso sistema?  Encontrei o seguinte feiti√ßo respondendo a essa pergunta: <br>  <b>ls / sys / class / tty / * / device / driver</b> <br><br>  Aqui est√° a resposta do sistema: <br><br><img src="https://habrastorage.org/webt/oc/gi/v7/ocgiv7g8ffmcmzr_bfypwrn__6g.png"><br><br>  Acontece que precisamos usar os nomes <b>/ dev / ttyS2</b> e <b>/ dev / ttyS3</b> .  Por que - eu n√£o sei.  Mas uma coisa agrada: aqui n√£o est√£o previstas mudan√ßas especiais; portanto, essas constantes podem ser lembradas e usadas sem medo de que elas mudem. <br><br><h4>  Desenvolvimento de c√≥digo </h4><br>  Ao desenvolver, voc√™ deve usar o maravilhoso <b>Guia de Programa√ß√£o Serial para Sistemas Operacionais POSIX</b> (o primeiro link direto que voc√™ obt√©m √© <a href="https://www.cmrr.umn.edu/~strupp/serial.html" rel="nofollow">https://www.cmrr.umn.edu/~strupp/serial.html</a> , mas ningu√©m sabe quanto tempo vai durar).  √â especialmente importante que ele ensine como trabalhar com um conjunto completo de sinais, porque as portas do complexo est√£o totalmente implementadas.  √â verdade que hoje usaremos apenas as linhas Tx e Rx. <br><br>  Geralmente dou os resultados do oscilograma, mas agora estou em condi√ß√µes quase reais: o complexo est√° localizado onde minhas m√£os n√£o alcan√ßam, ent√£o n√£o consigo conectar a sonda do oscilosc√≥pio.  Para ver pelo menos algum resultado, a meu pedido, os colegas adicionaram algumas postagens ao complexo de acordo com o seguinte esquema cl√°ssico: <br><br><img src="https://habrastorage.org/webt/4k/it/be/4kitbevmwnyxbllumfdz0qzr2a0.png"><br><br>  Vamos tentar transferir de uma porta para outra.  No nosso caso, as portas <b>/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.2-port0</b> e <b>/dev/serial/by-path/pci-0000:00:15.0- est√£o conectadas usb-0: 6.5: 1.3-port0</b> . <br><br>  J√° discutimos como os programas para o processador central Redd s√£o escritos em um dos <a href="https://habr.com/ru/post/456008/">artigos anteriores</a> . Portanto, hoje nos restringiremos apenas ao texto do programa escrito sob a impress√£o do documento <b>Guia de programa√ß√£o serial para sistemas operacionais POSIX</b> .  Na verdade, o principal ponto interessante √© mudar a estrat√©gia de recep√ß√£o para leitura sem bloqueio, o resto √© trivial.  No entanto, considerando a bagun√ßa nos exemplos da rede sobre esse t√≥pico, √© melhor ter uma amostra trivial em m√£os (ser√° mostrado mais adiante que mesmo um exemplo baseado neste maravilhoso documento n√£o funcionou 100%, o c√≥digo abaixo difere dos c√¢nones descritos em uma linha, mas mais sobre isso abaixo). <br><br><div class="spoiler">  <b class="spoiler_title">O mesmo c√≥digo de amostra</b> <div class="spoiler_text"><pre><code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;unistd.h&gt; /* UNIX standard function definitions */ #include &lt;fcntl.h&gt; /* File control definitions */ #include &lt;errno.h&gt; /* Error number definitions */ #include &lt;termios.h&gt; /* POSIX terminal control definitions */ int OpenUART(const char* portName, speed_t baudRate) { //   int fd = open(portName, O_RDWR | O_NOCTTY | O_NDELAY); //     if (fd == -1) { return fd; } //     fcntl(fd, F_SETFL, FNDELAY); //    termios options; tcgetattr(fd, &amp;options); // ,       // ,   .  ... cfsetspeed(&amp;options, baudRate); //    ... // 1  ,   , 8    options.c_cflag &amp;= ~PARENB; options.c_cflag &amp;= ~CSTOPB; options.c_cflag &amp;= ~CSIZE; options.c_cflag |= CS8; options.c_cflag |= (CLOCAL | CREAD); // , ... tcsetattr(fd, TCSANOW, &amp;options); return fd; } int main() { printf("hello from ReddUARTTest!\n"); int fd1 = OpenUART("/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.3-port0", 9600); int fd2 = OpenUART("/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.2-port0", 9600); if ((fd1 != -1) &amp;&amp; (fd2 != -1)) { static const unsigned char dataForSend[] = {0xff,0xfe,0xfd,0xfb}; //      write(fd1, dataForSend, sizeof(dataForSend)); unsigned char dataForReceive[128]; ssize_t cnt = 0; //     ,  , //         int readSteps = 0; //      ,   while (cnt &lt; (ssize_t)sizeof(dataForSend)) { readSteps += 1; ssize_t rd = read(fd2, dataForReceive + cnt, sizeof(dataForReceive) - cnt); //   - ,     if (rd &lt;= 0) { usleep(1000); } else //  -   { cnt += rd; } } //   printf("%d read operations\n", readSteps); printf("Read Data: "); for (unsigned int i = 0; i &lt; cnt; i++) { printf("%X ", dataForReceive[i]); } printf("\n"); } else { printf("Error with any port open!\n"); } //   if (fd1 != -1) { close(fd1); } if (fd2 != -1) { close(fd2); } return 0; }</code> </pre> <br></div></div><br>  Executar - obtemos o resultado previsto: <br><br><pre> <code class="plaintext hljs">hello from ReddUARTTest! 14 read operations Read Data: FF FE FD FB</code> </pre><br>  Pode-se ver que 4 bytes ocuparam 14 tentativas, ou seja, a leitura n√£o estava bloqueando.  √Äs vezes, o sistema retornava um estado "sem novos dados" e o programa dormia por um milissegundo. <br><br>  Em geral, est√° tudo bem, mas sem um oscilosc√≥pio, n√£o posso ter certeza de que duas portas baseadas no mesmo chip realmente definem a velocidade.  Eu j√° pulei no fato de que a velocidade era a mesma (pois ele tinha um controlador), mas n√£o o que eu pedi.  Vamos pelo menos verificar de alguma forma que seja pelo menos controlado.  Para fazer isso, definirei a velocidade da porta de recebimento para dobrar a velocidade da porta de transmiss√£o.  E, conhecendo a f√≠sica do processo de transfer√™ncia de dados, voc√™ pode prever como esses dados s√£o distorcidos durante a recep√ß√£o.  Vejamos a transfer√™ncia do byte 0xff em forma gr√°fica.  Bit S - start (sempre existe zero), bit P - stop (sempre existe um), 0-7 - bits de dados (para a constante 0xFF - todas as unidades). <br><br><img src="https://habrastorage.org/webt/kx/0p/cz/kx0pczh7nor5fcn1nhkor8nrwum.png"><br><br>  Agora, vamos sobrepor essa visualiza√ß√£o com uma vis√£o de como tudo ser√° visto por um receptor operando com o dobro da velocidade: <br><br><img src="https://habrastorage.org/webt/mp/n7/qn/mpn7qngefktxruxtyrex7ykrpwk.png"><br><br>  √ìtimo.  O valor "1111 1110" deve ser aceito (os dados avan√ßam o bit menos significativo), ou seja, 0xFE.  A segunda metade do valor transmitido n√£o afeta a recep√ß√£o, pois as unidades correspondem ao sil√™ncio na linha.  Ou seja, transmitimos um byte, um byte tamb√©m vir√°. <br><br>  Construiremos o mesmo gr√°fico para verifica√ß√£o, que corresponder√° ao valor 0xFE transmitido: <br><br><img src="https://habrastorage.org/webt/do/e6/x2/doe6x2t9aapieqiat4gtkp9j8_y.png"><br><br>  Espere o valor "1111 1000" ou 0xF8.  Bem, vamos verificar o que esperar com o valor passado 0xFD: <br><br><img src="https://habrastorage.org/webt/c9/er/d0/c9erd0bsjla_b5bkwpmmzbqnrlm.png"><br><br>  Obtemos o valor 0xE6.  Bem, para o valor transmitido 0xFB obtemos o 0x9E recebido (voc√™ pode plotar o gr√°fico e ver por si mesmo).  √ìtimo!  Alteramos uma √∫nica linha no aplicativo de teste, substituindo a velocidade de 9600 por 19200: <br><br><pre> <code class="plaintext hljs"> int fd2 = OpenUART("/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.2-port0", 19200);</code> </pre><br>  Come√ßamos e obtemos este resultado do trabalho: <br><br><pre> <code class="plaintext hljs">hello from ReddUARTTest! 9 read operations Read Data: FE F8 E6 9E</code> </pre><br>  A prop√≥sito, em v√£o n√£o realizei essa verifica√ß√£o.  Inicialmente, usei outras fun√ß√µes de configura√ß√£o de velocidade (par cfsetispeed / cfsetospeed) e elas n√£o funcionaram!  Gra√ßas a esse teste, o problema foi identificado e resolvido em tempo h√°bil.  Ao trabalhar com equipamentos, voc√™ nunca pode confiar na intui√ß√£o.  Tudo deve ser verificado! <br><br><h4>  Gerenciamento de linha de energia 220 volts </h4><br>  Em geral, as linhas de energia de 220 volts n√£o est√£o relacionadas ao t√≥pico do artigo (pontes FTDI), mas est√£o relacionadas ao t√≥pico desta se√ß√£o (portas seriais).  Vamos dar uma olhada r√°pida neles. <br><br><img src="https://habrastorage.org/webt/fj/py/1f/fjpy1fqzjfykydgxo28fctebh1c.png"><br><br>  Quando listamos as portas, vimos este nome: <br><br><img src="https://habrastorage.org/webt/rt/0g/k7/rt0gk7ammjno5n1hgfh5waz85ri.png"><br><br>  Esta √© uma porta serial virtual.  √â t√£o virtual que n√£o importa quais par√¢metros ela possui (velocidade da porta, n√∫mero de bits, formato de paridade etc.).  N√£o importa quais par√¢metros ele tenha sido definido, ele ainda ser√° capaz de lidar com comandos perfeitamente.  E s√£o essas equipes que controlam as tomadas no complexo. <br><br><img src="https://habrastorage.org/webt/yc/ry/sk/ycryskkv2xpfkxnex41xbn5pooo.png"><br><br>  Ao desenvolver o sistema de comando, foi decidido abandonar interfaces de comando complexas.  O gerenciamento usa um byte, sem seq√º√™ncias de caracteres de enquadramento e outros detalhes, embora o byte seja textual (para que possa ser convenientemente transferido do terminal durante a depura√ß√£o).  Essa concis√£o √© facilmente explicada: a interface de cadeias permite lidar com interfer√™ncias em um canal UART inseguro.  Por√©m, no nosso caso, fisicamente, o trabalho passa pelo canal USB, protegido por c√≥digos de controle c√≠clico.  O processamento do fluxo de retorno requer a grava√ß√£o de c√≥digo adicional ou a libera√ß√£o constante de buffers, o que nem sempre √© conveniente.  √â por isso que n√£o h√° refer√™ncias para seq√º√™ncias de caracteres, n√£o h√° respostas.  Acredita-se que o canal seja est√°vel.  Se voc√™ deseja uma resposta, pode solicit√°-la explicitamente.  Ou seja, o desempenho do bloco sempre pode ser facilmente verificado enviando um byte extra ap√≥s o comando. <br><br>  Considere os comandos que podem ser enviados: <br><div class="scrollable-table"><table><tbody><tr><th>  A equipe </th><th>  Nomea√ß√£o </th></tr><tr><td>  'A' </td><td>  Ligue a primeira tomada </td></tr><tr><td>  'a' </td><td>  Desligue a primeira tomada </td></tr><tr><td>  'B' </td><td>  Ligue a segunda tomada </td></tr><tr><td>  'b' </td><td>  Desligue a segunda tomada </td></tr><tr><td>  'C' </td><td>  Ligue a terceira tomada (se houver) </td></tr><tr><td>  'c' </td><td>  Desligue a terceira tomada (se houver) </td></tr><tr><td>  '?' </td><td>  Restaurar status da sa√≠da </td></tr></tbody></table></div><br>  O comando '?'  (ponto de interroga√ß√£o) √© o √∫nico que retorna uma resposta.  Em resposta, sempre v√™m 3 bytes, cada um dos quais corresponde ao estado de uma das sa√≠das.  Na verdade, os estados correspondem aos comandos.  Por exemplo, 'abc' - todas as tr√™s tomadas est√£o desativadas, 'Abc' - a primeira est√° ligada, a segunda e a terceira est√£o desativadas etc. <br><br>  Para experimentos com este subsistema, sugiro n√£o escrever um programa especial (n√£o √© diferente do fornecido anteriormente, apenas os dados enviados √†s portas ser√£o diferentes), mas usando as ferramentas do SO e jogando interativamente com soquetes. <br><br>  Ap√≥s muitas experi√™ncias com o rastreamento da porta atrav√©s do comando cat e o envio de comandos em uma janela paralela usando o programa echo, percebi que, por algum motivo, n√£o consigo obter resultados em um par de terminais ssh baseados em massa (mesmo jogando com as portas com as quais apenas que ele experimentou perfeitamente com seu programa).  Portanto, eu tive que instalar o programa minicom padr√£o.  Deixe-me lembr√°-lo do comando de instala√ß√£o: <br>  <b>sudo apt-get minicom</b> <br><br>  Em seguida, execute-o com o comando: <br>  <b>minicom ‚ÄìD / dev / ttyACM0</b> <br><br>  O nome da porta √© curto, porque com experimentos manuais √© mais f√°cil entrar.  No trabalho de software, como sempre, √© melhor usar um nome vinculado √† hierarquia de hardware.  Mais uma vez, observo que n√£o configuro nenhum outro par√¢metro de porta porque √© virtual.  Funcionar√° com todas as configura√ß√µes. <br><br>  Em seguida, pressionamos o ponto de interroga√ß√£o no terminal e instantaneamente (sem avan√ßo de linha) obtemos uma resposta <br><br><img src="https://habrastorage.org/webt/41/my/-j/41my-jjk9cffmmflot_zk_ph0ck.png"><br><br>  Isso significa que todas as tomadas est√£o desativadas no momento.  Digamos que queremos ligar a segunda tomada.  Pressione o capital 'B'.  N√£o h√° rea√ß√£o na tela.  Pressione '?' Novamente, temos uma nova linha com a resposta: <br><br><img src="https://habrastorage.org/webt/5i/uz/-r/5iuz-rrjfbmier5bfmazwx1svb0.png"><br><br>  Tudo funciona.  N√£o se esque√ßa de desligar 220 volts (comando 'b').  Voc√™ pode sair do terminal pressionando sucessivamente ctrl + A e, em seguida, X. A experi√™ncia est√° conclu√≠da. <br><br><h2>  Pneus SPI e I <sup>2</sup> C </h2><br>  Os barramentos SPI (que tamb√©m podem funcionar no modo Quad-SPI) e I <sup>2</sup> C s√£o implementados em combina√ß√£o com pontes universais.  Ou seja, em geral, o complexo possui duas pontes, cada uma das quais pode ser ativada no modo SPI ou em I <sup>2</sup> C. No diagrama estrutural, a se√ß√£o correspondente √© assim: <br><br><img src="https://habrastorage.org/webt/uy/lp/6k/uylp6kc6vcqjrlwluk5nxzpcezc.png"><br><br>  A ess√™ncia de ligar os barramentos finais √© vis√≠vel no diagrama do circuito el√©trico.  Considere apenas um dos dois controladores: <br><br><img src="https://habrastorage.org/webt/ah/rj/ah/ahrjahvujglcs3uoxl-wsdxfcpy.png"><br><br>  Assim, os barramentos SPI e I <sup>2</sup> C n√£o se cruzam de forma alguma.  Restri√ß√µes ao uso conjunto s√£o determinadas apenas por restri√ß√µes impostas pela FTDI no controlador FT4222H.  Infelizmente, a documenta√ß√£o afirma que apenas uma interface pode estar ativa por vez: <br><br><img src="https://habrastorage.org/webt/zc/7d/dw/zc7ddwfm-tstpt9lumoydqexceu.png"><br><br>  Como gerenciar as linhas CFG1_0..CFG1_1 e CFG2_0..CFG2_1, nos encontraremos no pr√≥ximo artigo.  Agora acreditamos que todos eles foram anulados. <br><br>  Em geral, o trabalho com o controlador est√° muito bem descrito no documento <b>FT4222H USB2.0 TO QUADSPI / I2C BRIDGE IC</b> ; portanto, n√£o consideraremos os recursos dos modos de opera√ß√£o dos controladores.  Tudo est√° muito claro no documento mencionado. <br><br>  Quanto ao suporte de software, sua descri√ß√£o pode ser encontrada no documento n√£o menos not√°vel <b>AN_329 Guia do Usu√°rio da LibFT4222</b> .  J√° trabalhamos com a ponte FTDI duas vezes: na segunda metade <a href="https://habr.com/ru/post/456008/">deste artigo</a> e na segunda metade.  Portanto, comparando este documento com esses artigos, voc√™ pode descobrir rapidamente e come√ßar a escrever seu pr√≥prio c√≥digo.  Deixe-me mostrar o c√≥digo de refer√™ncia que envia os dados para o barramento SPI, sem considerar os detalhes de sua implementa√ß√£o; parece dolorosamente que j√° foi analisado com o FT2232. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo que envia dados para o barramento SPI.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include "../ftd2xx/ftd2xx.h" #include "../LibFT4222/inc/LibFT4222.h" void SpiTest (int pos) { FT_HANDLE ftHandle = NULL; FT_STATUS ftStatus; FT4222_STATUS ft4222Status; //   ftStatus = FT_Open(pos, &amp;ftHandle); if (FT_OK != ftStatus) { // open failed printf ("error: Cannot Open FTDI Device\n"); return; } ft4222Status = FT4222_SPIMaster_Init(ftHandle, SPI_IO_SINGLE, CLK_DIV_4, CLK_IDLE_LOW, CLK_LEADING, 0x01); if (FT4222_OK != ft4222Status) { printf ("error: Cannot switch to SPI Master Mode\n"); // spi master init failed return; } uint8 wrBuf [] = {0x9f,0xff,0xff,0xff,0xff,0xff,0xff}; uint8 rdBuf [sizeof (wrBuf)]; uint16 dwRead; ft4222Status = FT4222_SPIMaster_SingleReadWrite (ftHandle,rdBuf,wrBuf,sizeof (wrBuf),&amp;dwRead,TRUE); if (FT4222_OK != ft4222Status) { printf ("error: Error on ReadWrite\n"); } else { printf ("received: "); for (int i=0;i&lt;6;i++) { printf ("0x%X ",rdBuf[i]); } printf ("\n"); } FT4222_UnInitialize(ftHandle); FT_Close(ftHandle); }</code> </pre><br></div></div><br><h4>  SPI Bus Parts </h4><br>  Os desenvolvedores de c√≥digo para microcontroladores geralmente usam o barramento SPI como um gerador de uma frequ√™ncia predeterminada.  De fato, os pulsos gerados de maneira puramente program√°tica via linhas GPIO dependem de muitos fatores.  Em primeiro lugar, a ramifica√ß√£o, a rota√ß√£o do loop requer ciclos do processador.  Em segundo lugar, interrup√ß√µes, DMA e outros fatores imprevistos podem interferir no processador.  O SPI √© mais ou menos est√°vel, saiba como conseguir colocar bytes no buffer.  Uma aplica√ß√£o t√≠pica do bloco SPI, que n√£o tem rela√ß√£o direta com esse pr√≥prio SPI, √© o controle dos LEDs RGB, para os quais a precis√£o de definir a dura√ß√£o dos pulsos √© muito importante. <br><br>  Infelizmente, isso n√£o √© aceit√°vel para pontes FTDI.  O fragmento de c√≥digo acima ir√° gerar esses pulsos no barramento: <br><br><img src="https://habrastorage.org/webt/dv/zx/pe/dvzxpe6cevog4qaklf2zy8tkdye.png"><br><br>  Nesse caso, as regras de opera√ß√£o do SPI n√£o s√£o violadas; do ponto de vista desse barramento, tudo funciona corretamente.  Lembre-se de que as solu√ß√µes personalizadas habituais nos controladores n√£o funcionar√£o aqui.  √â verdade que o complexo possui muitos conectores USB gratuitos.  Todos os blocos n√£o padronizados podem ser desenvolvidos separadamente e conectados a eles. <br><br><h4>  Pe√ßas para pneus I <sup>2</sup> C </h4><br>  A √∫nica coisa que faz sentido √© indicar a aus√™ncia de resistores de pull-up para o barramento I <sup>2</sup> C na lateral do complexo.  Mas isso √© normal: no lado do dispositivo de trabalho, ainda h√° um elevador.  Atualmente, um pull-up pode ser em qualquer voltagem; portanto, √© l√≥gico que ele esteja definido no dispositivo de destino. <br><br><h2>  Conclus√£o </h2><br>  Hoje, adquirimos habilidades pr√°ticas no trabalho com pneus implementados pelas pontes FTDI.  Em geral, trabalhar com eles √© padr√£o, mas todo o conhecimento √© resumido em um √∫nico artigo, para n√£o procur√°-los pouco a pouco.  Da pr√≥xima vez, consideraremos um m√≥dulo que controla dispositivos n√£o padr√£o, implementado com base no controlador STM32.  No diagrama estrutural, esta se√ß√£o corresponde a ele: <br><br><img src="https://habrastorage.org/webt/ic/w4/9g/icw49gdqjdx26qahasd425ul-sm.png"><br><br>  Mas, realmente, tudo √© um pouco mais interessante l√° ... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt477662/">https://habr.com/ru/post/pt477662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt477648/index.html">MVCC no PostgreSQL-3. Vers√µes de linha</a></li>
<li><a href="../pt477650/index.html">Criptografia do tr√°fego TLS de acordo com os algoritmos GOST-2012 com Stunnel</a></li>
<li><a href="../pt477654/index.html">Tentando a inst√¢ncia aprimorada do operador em Java 14</a></li>
<li><a href="../pt477656/index.html">Ainda assim, por que voc√™ precisa fazer?</a></li>
<li><a href="../pt477658/index.html">Restaura√ß√£o ativa: a recupera√ß√£o de desastres pode ser mais r√°pida? Muito mais r√°pido?</a></li>
<li><a href="../pt477668/index.html">29 de novembro, 18:00 - devleads-mitap</a></li>
<li><a href="../pt477672/index.html">Direitos e obriga√ß√µes dos membros da equipe: aspectos legais e culturais</a></li>
<li><a href="../pt477674/index.html">AI significa amor?</a></li>
<li><a href="../pt477678/index.html">Perspectivas para a televis√£o digital na R√∫ssia</a></li>
<li><a href="../pt477680/index.html">Nossas m√£os n√£o s√£o para t√©dio: restaurar o cluster Rook nos K8s</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>