<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¥üèº üï≥Ô∏è ü§π Demo AresDB: ferramenta de an√°lise em tempo real de fonte aberta baseada em GPU do Uber ü§òüèø üë©üèº‚Äç‚öïÔ∏è üö¥üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gra√ßas √† an√°lise em tempo real, n√≥s, funcion√°rios da Uber, temos uma id√©ia do estado das coisas e da efici√™ncia do trabalho e, com base nos dados, dec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Demo AresDB: ferramenta de an√°lise em tempo real de fonte aberta baseada em GPU do Uber</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/440072/"><p>  Gra√ßas √† an√°lise em tempo real, n√≥s, funcion√°rios da Uber, temos uma id√©ia do estado das coisas e da efici√™ncia do trabalho e, com base nos dados, decidimos como melhorar a qualidade do trabalho na plataforma Uber.  Por exemplo, a equipe do projeto monitora o estado do mercado e identifica poss√≠veis problemas em nossa plataforma;  software baseado em modelos de aprendizado de m√°quina prev√™ ofertas e demanda de passageiros por motoristas;  especialistas em processamento de dados est√£o melhorando os modelos de aprendizado de m√°quina - por sua vez, para melhorar a qualidade da previs√£o. </p><br><p><img src="https://habrastorage.org/webt/ii/ml/9e/iiml9el5ttzjjxvz6jrx1ff_zng.png"></p><br><p>  No passado, para an√°lise em tempo real, usamos solu√ß√µes de banco de dados de outras empresas, mas nenhuma atendia a todos os nossos crit√©rios de funcionalidade, escalabilidade, efici√™ncia, custo e requisitos operacionais. </p><br><p>  Lan√ßado em novembro de 2018, o AresDB √© uma ferramenta de an√°lise em tempo real de c√≥digo aberto.  Ele usa uma fonte de alimenta√ß√£o n√£o convencional, processadores gr√°ficos (GPU), que permite aumentar a escala da an√°lise.  A tecnologia GPU, uma promissora ferramenta de an√°lise em tempo real, avan√ßou significativamente nos √∫ltimos anos, tornando-a ideal para computa√ß√£o paralela em tempo real e processamento de dados. </p><br><p>  Nas se√ß√µes a seguir, descrevemos a estrutura do AresDB e como essa solu√ß√£o interessante para an√°lise em tempo real nos permitiu unificar, simplificar e melhorar de maneira mais eficiente e racional as solu√ß√µes de banco de dados Uber para an√°lise em tempo real.  Esperamos que, depois de ler este artigo, voc√™ experimente o AresDB como parte de seus pr√≥prios projetos e tamb√©m verifique sua utilidade! </p><a name="habracut"></a><br><h3 id="prilozheniya-uber-dlya-analiza-v-realnom-vremeni">  Aplicativos de an√°lise em tempo real Uber </h3><br><p>  A an√°lise dos dados √© fundamental para o sucesso do Uber.  Entre outras fun√ß√µes, ferramentas anal√≠ticas s√£o usadas para resolver as seguintes tarefas: </p><br><ul><li>  Construindo <strong>pain√©is</strong> para monitorar m√©tricas de neg√≥cios. </li><li>  Tomar <strong>decis√µes autom√°ticas</strong> (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">determinar o custo de uma viagem</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">identificar casos de fraude</a> ) com base nas m√©tricas de resumo coletadas. </li><li>  Crie <strong>consultas aleat√≥rias</strong> para diagnosticar, solucionar problemas e solucionar problemas de opera√ß√µes comerciais. </li></ul><br><p>  Categorizamos essas fun√ß√µes com requisitos diferentes da seguinte maneira: </p><br><p><img src="https://habrastorage.org/webt/oa/sp/lm/oasplm7jy6mqhkoevqutusej-sa.png"></p><br><p>  Os pain√©is e os sistemas de tomada de decis√£o usam sistemas de an√°lise em tempo real para criar consultas semelhantes em subconjuntos de dados relativamente pequenos, mas altamente importantes (com o mais alto n√≠vel de relev√¢ncia dos dados) com QPS alto e baixa lat√™ncia. </p><br><h3 id="potrebnost-v-drugom-analiticheskom-module">  Necessidade de outro m√≥dulo anal√≠tico </h3><br><p>  O problema mais comum que o Uber usa ferramentas de an√°lise em tempo real para resolver √© calcular popula√ß√µes de s√©ries temporais.  Esses c√°lculos d√£o uma id√©ia das intera√ß√µes do usu√°rio, para que possamos melhorar a qualidade dos servi√ßos de acordo.  Com base neles, solicitamos indicadores para determinados par√¢metros (por exemplo, dia, hora, identificador da cidade e status da viagem) por um determinado per√≠odo de tempo para dados filtrados aleatoriamente (ou √†s vezes combinados).  Ao longo dos anos, o Uber implantou v√°rios sistemas projetados para resolver esse problema de v√°rias maneiras. </p><br><p>  Aqui est√£o algumas solu√ß√µes de terceiros que usamos para resolver esse tipo de problema: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Apache Pinot</a> , um banco de dados anal√≠tico de c√≥digo aberto distribu√≠do escrito em Java, √© adequado para an√°lise de dados em larga escala.  O Pinot usa uma arquitetura lambda interna para consultar dados de pacotes e dados em tempo real no armazenamento de colunas, um √≠ndice de bits invertido para filtragem e uma √°rvore em estrela para armazenar em cache os resultados agregados.  No entanto, ele n√£o oferece suporte a deduplica√ß√£o com base em chave, atualiza√ß√£o ou inser√ß√£o, mesclagem ou recursos avan√ßados de consulta, como filtragem geoespacial.  Al√©m disso, como o Pinot √© um banco de dados baseado em JVM, a consulta √© muito cara em termos de uso de mem√≥ria. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Elasticsearch √©</a> usado pelo Uber para resolver v√°rias tarefas de an√°lise de streaming.  Ele √© constru√≠do com base na biblioteca Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lucene</a> , que armazena documentos para pesquisa de palavras-chave em texto completo e um √≠ndice invertido.  O sistema √© amplo e expandido para suportar dados agregados.  Um √≠ndice invertido fornece filtragem, mas n√£o √© otimizado para armazenar e filtrar dados com base em intervalos de tempo.  Os registros s√£o armazenados na forma de documentos JSON, o que imp√µe custos adicionais para fornecer acesso ao reposit√≥rio e solicita√ß√µes.  Como o Pinot, o Elasticsearch √© um banco de dados baseado em JVM e, consequentemente, n√£o suporta a fun√ß√£o de jun√ß√£o, e a execu√ß√£o da consulta ocupa uma grande quantidade de mem√≥ria. </li></ul><br><p>  Embora essas tecnologias tenham seus pontos fortes, eles n√£o possu√≠am alguns dos recursos necess√°rios para o nosso caso de uso.  Precis√°vamos de uma solu√ß√£o unificada, simplificada e otimizada e, em sua pesquisa, trabalhamos em uma dire√ß√£o fora do padr√£o (mais precisamente, dentro da GPU). </p><br><h3 id="ispolzovanie-gpu-dlya-analiza-v-realnom-vremeni">  Usando GPU para an√°lise em tempo real </h3><br><p>  Para renderiza√ß√£o realista de imagens com alta taxa de quadros, as GPUs processam simultaneamente um grande n√∫mero de formas e pixels em alta velocidade.  Embora a tend√™ncia de aumentar a frequ√™ncia de clock das unidades de processamento de dados nos √∫ltimos anos tenha come√ßado a diminuir, o n√∫mero de transistores no chip aumentou apenas de acordo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">com a lei de Moore</a> .  Como resultado, a velocidade de computa√ß√£o da GPU, medida em gigaflops por segundo (Gflops / s), est√° aumentando rapidamente.  A Figura 1 abaixo mostra uma compara√ß√£o da tend√™ncia te√≥rica de velocidade (Gflops / s) da GPU NVIDIA e da CPU Intel ao longo dos anos: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/mq/gh/wg/mqghwgau9j51rlgs_hratcvmw7i.png"></a> </p><br><p>  <em>Figura 1. Compara√ß√£o do desempenho da CPU e GPU de ponto flutuante de precis√£o √∫nica ao longo de v√°rios anos.</em>  <em>Imagem tirada do Guia de Programa√ß√£o CUDA C da Nvidia.</em> </p><br><p>  Ao desenvolver o mecanismo de solicita√ß√£o de an√°lise em tempo real, a decis√£o de integrar a GPU foi natural.  No Uber, uma solicita√ß√£o t√≠pica de an√°lise em tempo real exige o processamento de dados em alguns dias com milh√µes ou at√© bilh√µes de registros, filtrando-os e resumindo-os em um curto per√≠odo de tempo.  Essa tarefa computacional se encaixa perfeitamente no modelo de processamento paralelo da GPU de uso geral, porque eles: </p><br><ul><li>  Eles processam dados em paralelo com uma velocidade muito alta. </li><li>  Eles fornecem uma velocidade computacional mais alta (Gflops / s), o que os torna excelentes para executar tarefas computacionais complexas (em blocos de dados) que podem ser paralelizadas. </li><li>  Eles oferecem maior desempenho (sem demora) na troca de dados entre a unidade de computa√ß√£o e o armazenamento (ALU e GPU de mem√≥ria global) em compara√ß√£o com as unidades de processamento central (CPUs), tornando-os ideais para o processamento de tarefas de E / S de mem√≥ria paralela, que requer uma quantidade significativa de dados. </li></ul><br><p>  Focando no uso de um banco de dados anal√≠tico baseado em GPU, n√≥s - do ponto de vista de nossas necessidades - avaliamos v√°rias solu√ß√µes anal√≠ticas existentes que usam GPUs: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Kinetica</a> , uma ferramenta anal√≠tica baseada em GPU, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">chegou ao</a> mercado em 2009, inicialmente para uso no Ex√©rcito dos EUA e em ag√™ncias de intelig√™ncia.  Embora demonstre o alto potencial da tecnologia GPU na an√°lise, descobrimos que, para nossas condi√ß√µes de uso, muitas fun√ß√µes importantes est√£o ausentes, incluindo altera√ß√£o do esquema, inser√ß√£o ou atualiza√ß√£o parcial, compacta√ß√£o de dados, configura√ß√£o de disco e mem√≥ria no n√≠vel da coluna e conex√£o por rela√ß√µes geoespaciais. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O OmniSci</a> , um m√≥dulo de consulta SQL de c√≥digo aberto, parecia uma op√ß√£o promissora, mas ao avaliar o produto, percebemos que faltava alguns recursos importantes para uso no Uber, como a desduplica√ß√£o.  Embora o OminiSci tenha introduzido o c√≥digo-fonte aberto de seu projeto em 2017, ap√≥s analisar sua solu√ß√£o com base em C ++, chegamos √† conclus√£o de que nem alterar nem ramificar sua base de c√≥digo √© praticamente vi√°vel. </li><li>  As ferramentas de an√°lise em tempo real baseadas em GPU, incluindo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GPUQP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CoGaDB</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GPUDB</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ocelot</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OmniDB</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Virginian</a> , s√£o frequentemente usadas em institui√ß√µes educacionais e de pesquisa.  No entanto, considerando seus objetivos acad√™micos, essas decis√µes se concentram no desenvolvimento de algoritmos e conceitos de teste, em vez de resolver problemas do mundo real.  Por esse motivo, n√£o os levamos em considera√ß√£o - nas condi√ß√µes de nosso volume e escala. </li></ul><br><p>  No geral, esses sistemas demonstram a enorme vantagem e o potencial de processamento de dados usando a tecnologia GPU e nos inspiraram a criar nossa pr√≥pria solu√ß√£o de an√°lise em tempo real da GPU, adaptada √†s necessidades do Uber.  Com base nesses conceitos, desenvolvemos e abrimos o c√≥digo fonte do AresDB. </p><br><h3 id="obzor-arhitektury-aresdb">  Vis√£o geral da arquitetura do AresDB </h3><br><p>  Em um n√≠vel alto, o AresDB armazena a maioria dos dados na mem√≥ria do host (RAM, que est√° conectada √† CPU), usa a CPU para processar dados e discos recebidos para recuperar dados.  Durante o per√≠odo de solicita√ß√£o, o AresDB transfere dados da mem√≥ria do host para a mem√≥ria da GPU para processamento paralelo na GPU.  Conforme mostrado na Figura 2 abaixo, o AresDB inclui armazenamento de mem√≥ria, armazenamento de metadados e disco: </p><br><p><img src="https://habrastorage.org/webt/my/o0/1h/myo01hflityxzcgrlcfrecplyxc.png"><br>  <em>Figura 2. A arquitetura exclusiva do AresDB inclui armazenamento de mem√≥ria, disco e armazenamento de metadados.</em> </p><br><h3 id="tablicy">  Tabelas </h3><br><p>  Diferentemente da maioria dos sistemas de gerenciamento de banco de dados relacional (RDBMS), o AresDB n√£o possui um escopo de banco de dados ou esquema.  Todas as tabelas pertencem ao mesmo escopo em um cluster / inst√¢ncia do AresDB, que permite aos usu√°rios acess√°-las diretamente.  Os usu√°rios armazenam seus dados na forma de tabelas de fatos e tabelas de dimens√µes. </p><br><p>  <strong>Tabela de fatos</strong> </p><br><p>  A tabela de fatos armazena um fluxo intermin√°vel de eventos de s√©ries temporais.  Os usu√°rios usam uma tabela de fatos para armazenar eventos / fatos que ocorrem em tempo real, e cada evento √© associado √† hora do evento, e a tabela √© frequentemente consultada pela hora do evento.  Como exemplo do tipo de informa√ß√£o armazenada na tabela de fatos, podemos nomear viagens, onde cada viagem √© um evento, e a hora de uma solicita√ß√£o de viagem √© frequentemente indicada como a hora do evento.  Se v√°rios registros de data e hora estiverem associados a um evento, apenas um registro de data e hora ser√° indicado como a hora do evento e ser√° exibido na tabela de fatos. </p><br><p>  <strong>Tabela de medi√ß√£o</strong> </p><br><p>  A tabela de medidas armazena as caracter√≠sticas atuais das instala√ß√µes (incluindo cidades, clientes e motoristas).  Por exemplo, os usu√°rios podem armazenar informa√ß√µes sobre a cidade, em particular o nome da cidade, fuso hor√°rio e pa√≠s, na tabela de medidas.  Diferentemente das tabelas de fatos, que est√£o em constante crescimento, as tabelas de dimens√µes s√£o sempre limitadas em tamanho (por exemplo, para Uber, a tabela de cidades √© limitada pelo n√∫mero real de cidades no mundo).  As tabelas de medidas n√£o requerem uma coluna de tempo especial. </p><br><h3 id="tipy-dannyh">  Tipos de dados </h3><br><p>  A tabela abaixo mostra os tipos de dados atuais suportados pelo AresDB: </p><br><p><img src="https://habrastorage.org/webt/zj/vl/9v/zjvl9v3bezbrorzdbv71ricwzoq.png"></p><br><p>  No AresDB, as seq√º√™ncias de caracteres s√£o convertidas em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">enumera√ß√µes</a> automaticamente antes de entrarem no banco de dados para aumentar a conveni√™ncia de armazenamento e efici√™ncia da consulta.  Isso permite verifica√ß√µes de igualdade com distin√ß√£o entre mai√∫sculas e min√∫sculas, mas n√£o suporta opera√ß√µes avan√ßadas, como concatena√ß√£o, substrings, m√°scaras e correspond√™ncia de express√£o regular.  No futuro, pretendemos adicionar a op√ß√£o de suporte de linha completa. </p><br><h3 id="osnovnye-funkcii">  Fun√ß√µes principais </h3><br><p>  A arquitetura do AresDB suporta os seguintes recursos: </p><br><ul><li>  <strong>Armazenamento baseado em coluna com compacta√ß√£o</strong> para aumentar a efici√™ncia do armazenamento (menos mem√≥ria em bytes para armazenamento de dados) e efici√™ncia da consulta (menos troca de dados entre a mem√≥ria da CPU e a mem√≥ria da GPU ao processar uma solicita√ß√£o) </li><li>  <strong>Atualiza√ß√£o ou inser√ß√£o em tempo real com desduplica√ß√£o da chave prim√°ria</strong> para melhorar a precis√£o dos dados e atualizar os dados em tempo real em alguns segundos </li><li>  <strong>Processamento de solicita√ß√£o de GPU</strong> para <strong>processamento</strong> de dados de <strong>GPU</strong> altamente paralelo com baixa lat√™ncia de solicita√ß√£o (de fra√ß√µes de segundo a v√°rios segundos) </li></ul><br><h3 id="stolbchatoe-hranilische">  Armazenamento da coluna </h3><br><p>  <strong>Vetor</strong> </p><br><p>  O AresDB armazena todos os dados em um formato de coluna.  Os valores de cada coluna s√£o armazenados como um vetor de valor da coluna.  O marcador de confian√ßa / incerteza dos valores em cada coluna √© armazenado em um vetor zero separado, enquanto o marcador de confian√ßa de cada valor √© apresentado como um bit. </p><br><p>  <strong>Armazenamento ativo</strong> </p><br><p>  O AresDB armazena dados da coluna n√£o compactados e n√£o classificados (vetores ativos) no armazenamento ativo.  Os registros de dados no armazenamento ativo s√£o divididos em pacotes (ativos) de um determinado volume.  Novos pacotes s√£o criados quando os dados s√£o recebidos, enquanto pacotes antigos s√£o exclu√≠dos ap√≥s o arquivamento de registros.  O √≠ndice de chave prim√°ria √© usado para localizar registros de desduplica√ß√£o e atualiza√ß√£o.  A Figura 3 abaixo mostra como organizamos os registros ativos e usamos o valor da chave prim√°ria para determinar sua localiza√ß√£o: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/sa/ak/mk/saakmkzjumbdukxzaizxhmjbcik.png"></a> <br>  <em>Figura 3. Usamos o valor da chave prim√°ria para determinar a localiza√ß√£o do pacote e a posi√ß√£o de cada registro dentro do pacote.</em> </p><br><p> Os valores de cada coluna no pacote s√£o armazenados como um vetor de coluna.  O marcador de confiabilidade / incerteza dos valores em cada vetor de valor √© armazenado como um vetor zero separado, e o marcador de confiabilidade de cada valor √© apresentado como um bit.  Na Figura 4 abaixo, oferecemos um exemplo com cinco valores para a coluna <code>city_id</code> : </p><br><p> <a href=""><img src="https://habrastorage.org/webt/zp/bs/ld/zpbsldqk0yij-dvewowbgawy8eq.png"></a> <br>  <em>Figura 4. Armazenamos valores (valor real) e vetores zero (marcador de confian√ßa) de colunas n√£o compactadas na tabela de dados.</em> </p><br><h3 id="arhivnoe-hranilische">  Armazenamento de arquivo </h3><br><p>  O AresDB tamb√©m armazena dados de coluna conclu√≠dos, classificados e compactados (vetores de archive) no armazenamento de archive atrav√©s de tabelas de fatos.  Os registros no armazenamento do arquivo morto tamb√©m s√£o distribu√≠dos em lotes.  Diferentemente dos pacotes ativos, o pacote de archive armazena registros por dia, de acordo com o Tempo Universal Coordenado (UTC).  Um pacote de archive usa o n√∫mero de dias como identificador de pacote desde o Unix Epoch. </p><br><p>  Os registros s√£o armazenados na forma classificada de acordo com uma ordem de classifica√ß√£o da coluna definida pelo usu√°rio.  Como mostra a Figura 5 abaixo, classificamos primeiro pela coluna <code>city_id</code> e depois pela coluna status: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ah/qm/dm/ahqmdmonjmy4trbjpzf7lqqdm10.png"></a> <br>  <em>Figura 5. Classificamos todas as linhas por city_id, depois por estado e, em seguida, compactamos cada coluna por codifica√ß√£o de grupo.</em>  <em>Ap√≥s a classifica√ß√£o e compacta√ß√£o, cada coluna receber√° um vetor cont√°bil.</em> </p><br><p>  O objetivo de definir a ordem de classifica√ß√£o do usu√°rio para as colunas √© o seguinte: </p><br><ul><li>  Maximizando o efeito de compacta√ß√£o classificando colunas com um pequeno n√∫mero de elementos em primeiro lugar.  A compacta√ß√£o m√°xima melhora a efici√™ncia do armazenamento (menos bytes s√£o necess√°rios para armazenar dados) e a efici√™ncia da consulta (menos bytes s√£o transferidos entre a mem√≥ria da CPU e a mem√≥ria da GPU). </li><li>  Fornecendo uma pr√©-filtragem conveniente baseada em intervalo para filtros equivalentes comuns, por exemplo, city_id = 12.  A pr√©-filtragem minimiza o n√∫mero de bytes necess√°rios para transferir dados entre a mem√≥ria da CPU e a mem√≥ria da GPU, o que maximiza a efici√™ncia da consulta. </li></ul><br><p>  Uma coluna √© compactada apenas se estiver presente na ordem de classifica√ß√£o especificada pelo usu√°rio.  N√£o estamos tentando compactar colunas com um grande n√∫mero de elementos, pois isso economiza pouca mem√≥ria. </p><br><p>  Ap√≥s a classifica√ß√£o, os dados para cada coluna qualificada s√£o compactados usando uma op√ß√£o de codifica√ß√£o de grupo espec√≠fica.  Al√©m do vetor de valor e do vetor zero, introduzimos um vetor de contabilidade para representar novamente o mesmo valor. </p><br><h3 id="priem-dannyh-v-realnom-vremeni-s-podderzhkoy-funkciy-obnovleniya-i-vstavki">  Recep√ß√£o de dados em tempo real com suporte para fun√ß√µes de atualiza√ß√£o e inser√ß√£o </h3><br><p>  Os clientes recebem dados atrav√©s da API HTTP publicando um service pack.  Um service pack √© um formato bin√°rio ordenado especial que minimiza o uso de espa√ßo enquanto mant√©m o acesso aleat√≥rio aos dados. </p><br><p>  Quando o AresDB recebe o service pack, ele primeiro grava o service pack no log da opera√ß√£o de recupera√ß√£o.  Quando um service pack √© adicionado ao final do log de eventos, o AresDB identifica e ignora as entradas atrasadas nas tabelas de fatos para uso no armazenamento ativo.  Um registro √© considerado "atrasado" se o hor√°rio do evento for anterior ao hor√°rio do arquivo desconectado.  Para registros que n√£o s√£o considerados "atrasados", o AresDB usa o √≠ndice de chave prim√°ria para localizar o pacote dentro do armazenamento ativo onde voc√™ deseja inseri-los.  Conforme mostrado na Figura 6 abaixo, novos registros (n√£o encontrados anteriormente com base no valor da chave prim√°ria) s√£o inseridos no espa√ßo vazio e os registros existentes s√£o atualizados diretamente: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/px/y9/ee/pxy9eenpxhgejwvtih8gg37rppu.png"></a> <br>  <em>Figura 6. Quando os dados s√£o recebidos, ap√≥s adicionar o service pack ao log de eventos, as entradas "atrasadas" s√£o adicionadas √† fila reversa e outras entradas ao armazenamento ativo.</em> </p><br><h3 id="arhivirovanie">  Arquivamento </h3><br><p>  Quando os dados s√£o recebidos, os registros s√£o adicionados / atualizados no armazenamento ativo ou adicionados √† fila reversa, aguardando a coloca√ß√£o no armazenamento do arquivo morto. </p><br><p>  Periodicamente, iniciamos um processo agendado, chamado de arquivamento, em rela√ß√£o aos registros do armazenamento ativo para anexar novos registros (registros que nunca foram arquivados antes) ao armazenamento do arquivo morto.  O processo de arquivamento processa apenas registros no armazenamento ativo com o tempo do evento no intervalo entre o tempo de desligamento antigo (tempo de desligamento do √∫ltimo processo de arquivamento) e o novo tempo de desligamento (novo tempo de desligamento com base no par√¢metro de atraso de arquivamento no esquema da tabela). </p><br><p>  O hor√°rio do evento de registro √© usado para determinar em quais registros do pacote de archive devem ser combinados ao compactar dados do archive em pacotes di√°rios.  O arquivamento n√£o requer deduplica√ß√£o do √≠ndice do valor da chave prim√°ria durante a mesclagem, pois apenas os registros no intervalo entre o antigo e o novo tempo de desligamento s√£o arquivados. </p><br><p>  A Figura 7 abaixo mostra um gr√°fico de acordo com a hora do evento de um registro espec√≠fico. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/6t/l6/uc/6tl6ucxgbni_inkqwjo8u0pxcrs.png"></a> <br>  <em>Figura 7. Usamos o tempo do evento e o tempo da viagem para definir os registros como novos (ativos) e antigos (a hora do evento √© anterior ao tempo arquivado do evento da viagem).</em> </p><br><p>  Nesse caso, o intervalo de arquivamento √© o intervalo de tempo entre os dois processos de arquivamento, e o atraso no arquivamento √© o per√≠odo ap√≥s o hor√°rio do evento, mas at√© que o evento seja arquivado.  Ambos os par√¢metros s√£o definidos nas configura√ß√µes do esquema da tabela AresDB. </p><br><h3 id="obratnoe-zapolnenie">  Preenchimento </h3><br><p>  Conforme mostrado na Figura 7 acima, os registros antigos (cuja hora do evento √© anterior √† hora do arquivamento do evento de desligamento) das tabelas de fatos s√£o adicionados √† fila reversa e, finalmente, s√£o processados ‚Äã‚Äãcomo parte do processo de aterramento.  Os gatilhos desse processo tamb√©m s√£o o tempo ou o tamanho da fila reversa, se atingir um n√≠vel limite.  Comparado ao processo de adicionar dados ao armazenamento ativo, o preenchimento √© ass√≠ncrono e relativamente mais caro em termos de CPU e recursos de mem√≥ria.  O preenchimento √© usado nos seguintes cen√°rios: </p><br><ul><li>  Processando dados aleat√≥rios e muito atrasados </li><li>  Captura manual de dados hist√≥ricos de um fluxo de dados upstream </li><li>  Inserindo dados hist√≥ricos em colunas adicionadas recentemente </li></ul><br><p>  Diferentemente do arquivamento, o processo de preenchimento √© idempotente e requer desduplica√ß√£o com base no valor da chave prim√°ria.  Os dados preench√≠veis ficar√£o vis√≠veis para as consultas. </p><br><p>  A fila reversa √© mantida na mem√≥ria com um tamanho predefinido e, com uma grande carga de aterro, o processo ser√° bloqueado para o cliente at√© que a fila seja limpa iniciando o processo de aterro. </p><br><h3 id="obrabotka-zaprosa">  Processamento de solicita√ß√£o </h3><br><p>  Na implementa√ß√£o atual, o usu√°rio precisa usar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ares Query Language</a> (AQL) criada pelo Uber para executar consultas no AresDB.  O AQL √© uma linguagem eficaz para consultas anal√≠ticas de s√©ries temporais e n√£o segue a sintaxe padr√£o do SQL, como ‚ÄúSELECT FROM WHERE GROUP BY‚Äù, como outras linguagens semelhantes ao SQL.  Em vez disso, o AQL √© usado em campos estruturados e pode ser inclu√≠do nos objetos JSON, YAML e Go.  Por exemplo, em vez da <code>/SELECT (*) /FROM   /GROUP BY city_id, /WHERE  = ¬´¬ª /AND request_at &gt;= 1512000000</code> , a variante AQL equivalente em JSON √© escrita da seguinte maneira: </p><br><pre> <code class="plaintext hljs">{ ‚Äútable‚Äù: ‚Äútrips‚Äù, ‚Äúdimensions‚Äù: [ {‚ÄúsqlExpression‚Äù: ‚Äúcity_id‚Äù} ], ‚Äúmeasures‚Äù: [ {‚ÄúsqlExpression‚Äù: ‚Äúcount(*)‚Äù} ], ;‚Äù&gt; ‚ÄúrowFilters‚Äù: [ ‚Äústatus = 'completed'‚Äù ], ‚ÄútimeFilter‚Äù: { ‚Äúcolumn‚Äù: ‚Äúrequest_at‚Äù, ‚Äúfrom‚Äù: ‚Äú2 days ago‚Äù } }</code> </pre> <br><p>  No formato JSON, o AQL oferece aos desenvolvedores de um painel e sistema de tomada de decis√£o um algoritmo de consulta de programa mais conveniente que o SQL, permitindo que eles possam compor consultas e manipul√°-las facilmente usando o c√≥digo sem se preocupar com coisas como a inje√ß√£o de SQL.  Ele atua como um formato de consulta universal para arquiteturas t√≠picas de navegadores da web, servidores externos e internos at√© o banco de dados (AresDB).  Al√©m disso, o AQL fornece uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sintaxe</a> conveniente para filtragem por hora e lote, com suporte para seu pr√≥prio fuso hor√°rio.  Al√©m disso, o idioma suporta v√°rias fun√ß√µes, como subconsultas impl√≠citas, para evitar erros comuns em consultas e facilita o processo de an√°lise e reescrita de consultas para desenvolvedores da interface interna. </p><br><p>  Apesar dos muitos benef√≠cios que o AQL oferece, sabemos que a maioria dos engenheiros est√° mais familiarizada com o SQL.  O fornecimento de uma interface SQL para execu√ß√£o de consultas √© uma das pr√≥ximas etapas que consideraremos como parte de nossos esfor√ßos para melhorar a intera√ß√£o com os usu√°rios do AresDB. </p><br><p>  O fluxograma de execu√ß√£o da consulta AQL √© mostrado na Figura 8 abaixo: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/c7/bo/qq/c7boqqkfrjkqgn8i2zeb1ji6wje.png"></a> <br>  <em>Figura 8. O fluxograma de consulta do AresDB usa nossa pr√≥pria linguagem de consulta AQL para processar e recuperar dados de maneira r√°pida e eficiente.</em> </p><br><h3 id="kompilyaciya-zaprosov">  Compila√ß√£o de consultas </h3><br><p>  Uma consulta AQL √© compilada no contexto interno da consulta.  Express√µes em filtros, medidas e par√¢metros s√£o analisados ‚Äã‚Äãem √°rvores de sintaxe abstrata (AST) para processamento adicional atrav√©s de um processador gr√°fico (GPU). </p><br><h3 id="zagruzka-dannyh">  Carregamento de dados </h3><br><p>  O AresDB usa pr√©-filtros para filtrar dados de arquivamento mais baratos antes de envi√°-los √† GPU para processamento paralelo.  Como os dados arquivados s√£o classificados de acordo com a ordem das colunas configuradas, alguns filtros podem usar essa ordem de classifica√ß√£o e o m√©todo de pesquisa bin√°ria para determinar o intervalo apropriado de correspond√™ncia.  Em particular, filtros equivalentes para todas as colunas X classificadas inicialmente e um filtro de intervalo opcional para as colunas classificadas X + 1 podem ser usados ‚Äã‚Äãcomo filtros preliminares, conforme mostrado na Figura 9 abaixo. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/mq/gj/cw/mqgjcwi-es1twxn2navrzd6bhki.png"></a> <br>  <em>Figura 9. O AresDB pr√©-filtra os dados da coluna antes de envi√°-los √† GPU para processamento.</em> </p><br><p>  Ap√≥s a pr√©-filtragem, somente os valores verdes (que atendem √†s condi√ß√µes do filtro) devem ser enviados √† GPU para processamento paralelo.  Os dados de entrada s√£o carregados na GPU e processados ‚Äã‚Äãum pacote por vez.  Isso inclui pacotes ativos e pacotes de arquivamento. </p><br><p>  O AresDB usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fluxos CUDA</a> para pipelining e processamento de dados.  Para cada solicita√ß√£o, dois fluxos s√£o aplicados alternadamente para processamento em dois est√°gios sobrepostos.  Na Figura 10 abaixo, oferecemos um gr√°fico que ilustra esse processo. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/gg/b-/hv/ggb-hvvb1tbno_uq2rbokxu1ehi.png"></a> <br>  <em>Figura 10. No AresDB, dois threads CUDA transmitem e processam dados alternadamente.</em> </p><br><h3 id="vypolnenie-zaprosa">  Execu√ß√£o de consulta </h3><br><p>  Por uma quest√£o de simplicidade, o AresDB usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a biblioteca Thrust</a> para implementar procedimentos de execu√ß√£o de consultas, que oferecem blocos de um algoritmo paralelo ajustado para uma r√°pida implementa√ß√£o de consultas na ferramenta atual. </p><br><p>  No Thrust, os dados vetoriais de entrada e sa√≠da s√£o avaliados usando iteradores de acesso aleat√≥rio.  Cada encadeamento da GPU procura por iteradores de entrada em sua posi√ß√£o de trabalho, l√™ os valores e executa c√°lculos e depois grava o resultado na posi√ß√£o correspondente no iterador de sa√≠da. </p><br><p>  Para avaliar express√µes do AresDB, segue o modelo "um operador por n√∫cleo" (OOPK). </p><br><p>  Na Figura 11 abaixo, esse procedimento √© demonstrado usando o exemplo AST gerado a partir da express√£o de dimens√£o <code>request_at ‚Äì request_at % 86400</code> no est√°gio de compila√ß√£o do pedido: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/rq/zd/cq/rqzdcq1dpy3vnwhi8tjqppsxroq.png"></a> <br>  <em>Figura 11. O AresDB usa o modelo OOPK para avaliar express√µes.</em> </p><br><p>  No modelo OOPK, o mecanismo de consulta AresDB ignora cada n√≥ folha da √°rvore AST e retorna um iterador para o n√≥ de origem.  Se o n√≥ raiz tamb√©m for finito, a a√ß√£o raiz ser√° executada diretamente no iterador de entrada. </p><br><p>  Para cada n√≥ n√£o-raiz n√£o-raiz ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">opera√ß√£o de m√≥dulo</a> neste exemplo), um vetor de espa√ßo de trabalho tempor√°rio √© alocado para armazenar o resultado intermedi√°rio obtido da express√£o <code>request_at% 86400</code> .  Usando o Thrust, uma fun√ß√£o do kernel √© iniciada para calcular o resultado dessa instru√ß√£o na GPU.  Os resultados s√£o armazenados no iterador da √°rea de trabalho. </p><br><p>  Para um n√≥ raiz, a fun√ß√£o kernel √© executada da mesma maneira que para um n√≥ n√£o raiz e n√£o finito.  V√°rias a√ß√µes de sa√≠da s√£o executadas com base no tipo de express√£o, descrito em detalhes abaixo: </p><br><ul><li>  Filtragem para reduzir o n√∫mero de elementos do vetor de entrada </li><li>  Gravando dados de sa√≠da de medi√ß√£o em um vetor de medi√ß√£o para mesclagem de dados subsequente </li><li>  Registre a sa√≠da dos par√¢metros no vetor de par√¢metros para mesclagem de dados subsequente </li></ul><br><p>  Ap√≥s avaliar a express√£o, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classifica√ß√£o</a> e a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">transforma√ß√£o</a> s√£o executadas para finalmente combinar os dados.  Nas opera√ß√µes de classifica√ß√£o e transforma√ß√£o, usamos os valores do vetor de dimens√£o como valores-chave para classifica√ß√£o e transforma√ß√£o, e os valores do vetor de par√¢metro como valores para combinar dados.  Assim, linhas com valores de dimens√£o semelhantes s√£o agrupadas e combinadas.  A Figura 12 abaixo mostra esse processo de classifica√ß√£o e convers√£o. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ki/wn/hg/kiwnhgruuhvlm2wenraxbrwhwwk.png"></a> <br>  <em>Figura 12. Ap√≥s avaliar a express√£o, o AresDB classifica e converte os dados de acordo com os valores-chave dos vetores de medi√ß√£o (valor-chave) e par√¢metros (valor).</em> </p><br><p>  O AresDB tamb√©m suporta as seguintes fun√ß√µes avan√ßadas de consulta: </p><br><ul><li>  Associa√ß√£o: o AresDB atualmente suporta uma op√ß√£o de associa√ß√£o de hash entre a tabela de fatos e a tabela de dimens√µes </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estimando o n√∫mero de itens do Hyperloglog</a> : O AresDB usa o algoritmo Hyperloglog </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Geo Intersect</a> : atualmente, o AresDB suporta apenas opera√ß√µes interconectadas entre o GeoPoint e o GeoShape </li></ul><br><h3 id="upravlenie-resursami">  Gerenciamento de recursos </h3><br><p>  Como um banco de dados baseado na mem√≥ria interna, o AresDB deve gerenciar os seguintes tipos de uso de mem√≥ria: </p><br><p><img src="https://habrastorage.org/webt/20/_4/bb/20_4bbooneymuteoxhig9tqcdjk.png"></p><br><p>  Quando o AresDB √© inicializado, ele usa o or√ßamento de mem√≥ria compartilhada configurado.  O or√ßamento √© dividido em todos os seis tipos de mem√≥ria e tamb√©m deve deixar espa√ßo suficiente para o sistema operacional e outros processos.  Esse or√ßamento tamb√©m inclui uma estimativa de congestionamento configurada estaticamente, um armazenamento de dados ativo monitorado pelo servidor e dados arquivados que o servidor pode decidir baixar e excluir, dependendo do or√ßamento de mem√≥ria restante. <br>  A Figura 13 abaixo mostra o modelo de mem√≥ria do host do AresDB. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/no/dq/2t/nodq2t_tlr0fn-cy6ubrdwpqofi.png"></a> <br>  <em>Figura 13. O AresDB gerencia seu pr√≥prio uso de mem√≥ria para que n√£o exceda o or√ßamento total do processo configurado.</em> </p><br><p>  O AresDB permite que os usu√°rios definam dias de pr√©-carregamento e prioridades no n√≠vel da coluna para tabelas de fatos e pr√©-carregam dados arquivados apenas nos dias de pr√©-carregamento.  Os dados que n√£o foram baixados anteriormente s√£o carregados na mem√≥ria a partir do disco sob demanda.  Quando preenchido, o AresDB tamb√©m exclui dados arquivados da mem√≥ria do host.  Os princ√≠pios da remo√ß√£o do AresDB s√£o baseados nos seguintes par√¢metros: n√∫mero de dias de pr√©-carregamento, prioridades das colunas, dia da compila√ß√£o do pacote e tamanho da coluna. </p><br><p>  O AresDB tamb√©m gerencia v√°rios dispositivos da GPU e simula os recursos do dispositivo como threads da GPU e mem√≥ria do dispositivo, rastreando o uso da mem√≥ria da GPU para processar solicita√ß√µes.  O AresDB gerencia dispositivos da GPU por meio de um gerenciador de dispositivos que modela os recursos do dispositivo em duas dimens√µes (threads da GPU e mem√≥ria do dispositivo) e rastreia o uso da mem√≥ria ao processar solicita√ß√µes.  Ap√≥s compilar a solicita√ß√£o, o AresDB permite aos usu√°rios estimar a quantidade de recursos necess√°rios para concluir a solicita√ß√£o.  Os requisitos de mem√≥ria do dispositivo devem ser atendidos antes que a solicita√ß√£o seja resolvida;  se atualmente houver mem√≥ria insuficiente em qualquer dispositivo, a solicita√ß√£o dever√° aguardar.  Atualmente, o AresDB pode executar uma ou mais solicita√ß√µes no mesmo dispositivo GPU ao mesmo tempo, se o dispositivo atender a todos os requisitos de recursos. </p><br><p>  Na implementa√ß√£o atual, o AresDB n√£o armazena em cache a entrada na mem√≥ria do dispositivo para reutiliza√ß√£o em v√°rias solicita√ß√µes.  O AresDB visa dar suporte a consultas em conjuntos de dados que s√£o constantemente atualizados em tempo real e mal armazenados em cache corretamente.  Nas vers√µes futuras do AresDB, pretendemos implementar fun√ß√µes para armazenar dados em cache na mem√≥ria da GPU, o que ajudar√° a otimizar o desempenho da consulta. </p><br><h3 id="primer-ispolzovaniya-obzornaya-informacionnaya-panel-uber">  Exemplo de uso: painel de vis√£o geral do Uber </h3><br><p>  No Uber, usamos o AresDB para criar pain√©is para obter informa√ß√µes comerciais em tempo real.  O AresDB √© respons√°vel por armazenar eventos prim√°rios com atualiza√ß√µes constantes e calcular m√©tricas cr√≠ticas para eles em uma fra√ß√£o de segundo, gra√ßas aos recursos da GPU a baixo custo, para que os usu√°rios possam usar os pain√©is interativamente.  Por exemplo, dados de viagem anonimizados com um longo per√≠odo de validade no data warehouse s√£o atualizados por v√°rios servi√ßos, incluindo nosso sistema de despacho, sistemas de pagamento e pre√ßos.  Para fazer uso eficiente dos dados de viagem, os usu√°rios dividem e dividem dados em diferentes dimens√µes para obter informa√ß√µes sobre solu√ß√µes em tempo real. </p><br><p>  Ao usar o AresDB, o painel do Uber √© um painel de an√°lise generalizado usado pelas equipes da empresa para produzir m√©tricas relevantes e respostas em tempo real para melhorar a experi√™ncia do usu√°rio. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/p-/8e/k6/p-8ek6nx3gioyhngzczop7oh1jw.png"></a> <br> <em> 14.       Uber  AresDB           .</em> </p><br><p>     ,  ,    : </p><br><p> <strong> ( )</strong> </p><br><p><img src="https://habrastorage.org/webt/he/7a/q4/he7aq4btwhfbdgmj3qy-npinpyy.png"></p><br><p> <strong> ( )</strong> </p><br><p><img src="https://habrastorage.org/webt/wi/ox/pb/wioxpbxuygxvf3lg3gs0velx-rc.png"></p><br><h3 id="shemy-tablic-v-aresdb">    AresDB </h3><br><p>     ,  ,       AresDB   : </p><br><p><img src="https://habrastorage.org/webt/uz/ur/hq/uzurhq1u-nkwue6eq7zqepbyqiu.jpeg"></p><br><p>    ,       ,    ,    ,        ,       . </p><br><p>       <a href="">  AresDB</a>      ,  Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kafka</a> ,       ,  Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Flink</a>  Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Spark</a> . </p><br><h3 id="primery-zaprosov-dlya-aresdb">    AresDB </h3><br><p>           , ¬´   ¬ª  ¬´ ¬ª.         ,  -.           24         AQL: </p><br><p><img src="https://habrastorage.org/webt/po/1m/1u/po1m1uit03geewuvntsviruc5pw.jpeg"></p><br><p> <strong>   : <br></strong>         ,        ,   . </p><br><p><img src="https://habrastorage.org/webt/63/wr/9h/63wr9hhyak0furssgtfxa_bcj98.png"></p><br><p>      ,    AresDB    ,     ,                 . AresDB       ,       ,          . </p><br><h3 id="sleduyuschie-shagi">  Pr√≥ximas etapas </h3><br><p> AresDB    Uber         ,            .     ,  ,       AresDB    . </p><br><p>         : </p><br><ul><li> <strong> </strong> :         AresDB,  ,     ,        . </li><li> <strong>   </strong> :      AresDB   2018        ,           ,      AresDB    . </li><li> <strong>  </strong> :       ,     ,          ,       . </li><li> <strong>  </strong> :           ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   (LLVM)</a>    GPU. </li></ul><br><p> AresDB  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a>   Apache.     AresDB     . </p><br><p> <em>          ,         .</em> </p><br><h3 id="blagodarnosti">  Agradecimentos </h3><br><p> <em>    (Kate Zhang),   (Jennifer Anderson),   (Nikhil Joshi),   (Abhi Khune),   (Shengyue Ji),   (Chinmay Soman),   (Xiang Fu),   (David Chen)    (Li Ning)  ,      !</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt440072/">https://habr.com/ru/post/pt440072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt440060/index.html">TensorFlow no Apache Ignite</a></li>
<li><a href="../pt440062/index.html">Planejando com prazer. Como configuramos processos sem gerentes</a></li>
<li><a href="../pt440064/index.html">Data centers √† sua escolha: Londres, Moscou, Zurique, S√£o Petersburgo</a></li>
<li><a href="../pt440066/index.html">Extens√µes VSCode para facilitar o desenvolvimento de JavaScript e Vue</a></li>
<li><a href="../pt440070/index.html">Julia, descida de gradiente e m√©todo simplex</a></li>
<li><a href="../pt440074/index.html">Roskomos considera incorreto comparar os motores Raptor Ilona Mask e RD-180</a></li>
<li><a href="../pt440076/index.html">Tradu√ß√£o e interpreta√ß√£o de publicidade do ingl√™s para o russo</a></li>
<li><a href="../pt440078/index.html">Dispositivo compilador r√°pido. Parte 4</a></li>
<li><a href="../pt440084/index.html">10 bilh√µes de exporta√ß√µes de software √© insignificante</a></li>
<li><a href="../pt440086/index.html">Mundo dos v√≠rus do MS-DOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>