<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò∂ üï§ ü•õ Entwicklung des C-Compilers f√ºr den neuen Multiclet-Neuroprozessor ü§∂ üë∞üèº üï¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Auf einer Konferenz der Entwickler von System- und Werkzeugsoftware - OS DAY 2016, die am 9. und 10. Juni 2016 in Innopolis (Kasan) stattfand, als ein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung des C-Compilers f√ºr den neuen Multiclet-Neuroprozessor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480962/"><img src="https://habrastorage.org/webt/nm/q_/3x/nmq_3x1b_eccqomclbciqkb5go8.jpeg"><br><br>  Auf einer Konferenz der Entwickler von System- und Werkzeugsoftware - OS DAY 2016, die am 9. und 10. Juni 2016 in Innopolis (Kasan) stattfand, als ein Bericht √ºber die vielzellige Architektur er√∂rtert wurde, wurde der Gedanke ge√§u√üert, dass dies zur L√∂sung von Problemen der k√ºnstlichen Intelligenz am effektivsten ist.  Die Bedingungen f√ºr die Entwicklung eines neuen Allzweckprozessors f√ºr KI-Aufgaben haben sich in diesem Jahr entwickelt. <br><br>  Der Neuroprozessor S2 Multiclet, dessen Projekt erstmals auf dem Huawei Innovation Forum 2019 vorgestellt wurde, ist eine Weiterentwicklung der Multicell-Architektur.  Es unterscheidet sich von zuvor erstellten Mehrfachzellen mit einem Befehlssystem, n√§mlich der Einf√ºhrung neuer Typen von kleinen Daten (mit Fest- und Gleitkommazahlen) und Operationen mit diesen.  Die Anzahl der Zellen wurde erh√∂ht - 256 und die Frequenz - 2,5 GHz, was eine Spitzenleistung von 81,9 TFlops bei 16F liefern und dementsprechend im Hinblick auf neuronale Berechnungen mit den F√§higkeiten moderner spezialisierter ASIC - TPUs (TPU - 3: 90 TFlops bei 16F) vergleichbar machen sollte 16F). <br><br>  Da die Effizienz der Verwendung von Prozessoren in hohem Ma√üe von der Optimalit√§t des Compilers abh√§ngt, wurde ein Schema zur Codeoptimierung entwickelt. <br>  Lassen Sie es uns genauer betrachten. <br><a name="habracut"></a><br>  Der <a href="https://habr.com/ru/post/434982/">vorherige Artikel</a> erw√§hnte Compiler-Optimierungen, die es wert sind, implementiert zu werden.  Dort finden Sie Materialien zur vielzelligen Architektur, wenn Sie nicht bereits damit vertraut sind. <br><br><h4>  Befehle mit zwei Argumenten mit zwei Konstanten generieren </h4><br>  Mit dem Prozessor S1 wurde ein neues Befehlsformat eingef√ºhrt, mit dem beide Argumente als konstanter Wert angegeben werden k√∂nnen.  Auf diese Weise k√∂nnen Sie die Anzahl der Befehle im Code verringern und unn√∂tige Befehle wie Laden, um Konstanten in den Switch zu laden, entfernen. <br><br>  Zum Beispiel: <br><br><pre><code class="plaintext hljs">load_l func wr_l @1, #SP</code> </pre> <br>  kann ersetzt werden durch: <br><br><pre> <code class="plaintext hljs">wr_l func, #SP</code> </pre> <br>  Oder sogar zwei Teams gleichzeitig: <br><br><pre> <code class="plaintext hljs">load_l [foo] load_l [bar] add_l @1, @2</code> </pre> <br>  Es gibt zwei konstante Adressen, und das Lesen daraus kann auch direkt in die Argumente des Befehls eingesetzt werden: <br><br><pre> <code class="plaintext hljs">add_l [foo], [bar]</code> </pre><br>  Diese Optimierung wurde f√ºr alle implementiert, die dieses Format unterst√ºtzen.  Leider hat es sich aus zwei Gr√ºnden als sehr unwirksam erwiesen: <br><br><ul><li>  Die Anzahl der Situationen, in denen eine solche Optimierung durchgef√ºhrt werden kann, ist sehr gering.  Im Arbitrierungscode treten selten Situationen auf, in denen Sie zwei im Voraus bekannte Werte irgendwie verarbeiten m√ºssen.  Meistens werden solche Dinge in der Kompilierungsphase entschieden, und es bleibt nur noch wenig zur Laufzeit zu tun.  Normalerweise sind dies einige Operationen an Adressen, die wiederum konstant sind. </li><li>  Das Entfernen des Ladebefehls befreit den Prozessor nicht vom Prozess des Erzeugens der Konstante, sondern nur vom Abrufen eines separaten Ladebefehls, der nur eine schwache Beschleunigung ergibt, und selbst dann nicht immer. </li></ul><br><h4>  Optimierung der √úbertragung von virtuellen Registern zwischen Basiseinheiten </h4><br>  In LLVM sind Basisbl√∂cke lineare Abschnitte, in denen Code ohne Verzweigung ausgef√ºhrt wird.  Abs√§tze in einer mehrzelligen Architektur erf√ºllen genau die gleiche Funktion. Daher spiegelt ein Absatz beim Generieren eines Codes in den meisten F√§llen einen Basisblock wider.  In Prozessor R1 wurde jede √úbertragung von virtuellen Registern zwischen Abs√§tzen durch den Speicher ausgef√ºhrt, indem der Wert des gew√ºnschten Registers in den Stapel geschrieben und in den Absatz zur√ºckgelesen wurde, der dieses Register ben√∂tigt.  Dieser Mechanismus ist in zwei Teile unterteilt: √úbertragung des virtuellen Registers in einen anderen Absatz zur direkten Verwendung und √úbertragung des virtuellen Registers als Parameter f√ºr den Phi-Knoten. <br><br>  Phi-Knoten sind eine Folge der <a href="https://ru.wikipedia.org/wiki/SSA" rel="nofollow">SSA-Form (Static Single Assignment),</a> in der die LLVM-Pr√§sentationssprache dargestellt wird.  In dieser Form kann eine Variable (oder, wie bei LLVM IR - Virtual Registers) nur einmal geschrieben werden.  Zum Beispiel dieser Pseudocode: <br><br><pre> <code class="cpp hljs">a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span>; b = a;</code> </pre> <br>  Wird nicht in SSA-Form dargestellt, da der Wert der Variablen <b>a</b> √ºberschrieben werden kann.  Der Code kann in dieser Form umgeschrieben werden, wenn Sie den Phi-Knoten verwenden: <br><br><pre> <code class="cpp hljs">a1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) a2 = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> a3 = <span class="hljs-number"><span class="hljs-number">3</span></span>; b = phi(a2, a3);</code> </pre> <br>  Der Phi-Knoten w√§hlt a2 oder a3 aus, je nachdem, woher der Kontrollfluss stammt: <br><img src="https://habrastorage.org/webt/ug/rw/-b/ugrw-brljdidipmpwg-iobfvjkm.png"><br>  In LLVM IR phi werden Knoten als separate Anweisung implementiert, die unterschiedliche virtuelle Register ausw√§hlt, abh√§ngig davon, von welcher Basiseinheit die Steuerung stammt.  Die Implementierung dieses Befehls durch den Speicher auf dem Prozessor ist recht einfach: Verschiedene Basisbl√∂cke schreiben verschiedene Daten in dieselbe Speicherzelle, und am Standort-Phi-Knoten wird diese Speicherzelle gelesen, und die Daten sind abh√§ngig vom vorherigen Basisblock unterschiedlich. <br><br>  Das SSA-Formular impliziert, dass der Wert dort beim Initialisieren des Registers immer der gleiche ist.  Wenn die direkte √úbertragung von virtuellen Registern ausgef√ºhrt wird und der Wert jedes virtuellen Registers in eine separate Speicherzelle geschrieben wird, ist die SSA-Bedingung problemlos erf√ºllt: Die Daten befinden sich im Speicher, bis sie √ºberschrieben werden.  Wenn wir das Register jedoch √ºber den Switch √ºbertragen m√∂chten, m√ºssen wir uns daran erinnern, dass seine Gr√∂√üe nur 63 Zellen betr√§gt und jeder Wert verschwindet, wenn 63 Befehle ausgef√ºhrt werden.  Daher ist es unm√∂glich, das virtuelle Register durch den Schalter zu √ºbertragen, wenn es in einem ersten Absatz geschrieben und nach dem Abschluss von Hunderten anderer verwendet wird.  es bleibt nur die Erinnerung. <br>  Die Implementierung dieser Optimierung wurde genau mit der Optimierung von Phi-Knoten begonnen, da im Gegensatz zur direkten √úbertragung von virtuellen Registern die Parameterwerte f√ºr den Phi-Knoten immer direkt in den vorherigen Abs√§tzen (Basisbl√∂cken) initialisiert werden, sodass Sie nicht viel dar√ºber nachdenken k√∂nnen, ob der Schalter gro√ü genug ist wenn wir diese Parameter durchlaufen wollen. <br><br>  Mit Multicellular Assembler k√∂nnen Sie den Ergebnissen von Befehlen Namen zuweisen und deren Ergebnisse anhand dieses Namens verwenden.  Anstatt dass jeder Programmierer berechnen muss, wie viele Befehle dieses Ergebnis zur√ºckerhalten hat, berechnet der Assembler dies selbst: <br><br><pre> <code class="plaintext hljs">result := add_l [A], [B] ; ;    ; wr_l @result, C</code> </pre> <br>  Dieser Mechanismus funktioniert perfekt im aktuellen Absatz, da es sich um einen linearen Abschnitt handelt und die Reihenfolge der Befehle dort bekannt ist.  Dies wird aktiv verwendet, wenn der Compiler Code generiert: Allen Befehlen werden Namen zugewiesen, und der Compiler muss sich nicht um die Nummerierung der Befehle k√ºmmern.  Genauer gesagt, es war nicht notwendig, denn wenn wir das Ergebnis eines Befehls in einem anderen Absatz ausf√ºhren lassen m√∂chten, funktioniert der Mechanismus nicht: In der Assembler-Phase ist es unm√∂glich herauszufinden, welcher Absatz vom vorherigen tats√§chlich ausgef√ºhrt wurde, wenn der aktuelle mehrere Eingaben enth√§lt.  Daher besteht die einzige M√∂glichkeit darin, √ºber die Nummer auf die Ergebnisse der Mannschaften zuzugreifen.  Aus diesem Grund k√∂nnen Sie nicht einfach zus√§tzliche Datens√§tze / Lesungen aus dem Speicher in benachbarten Abs√§tzen entfernen und die Registerverweise aus dem Lesebefehl durch den Befehl im vorherigen Absatz ersetzen. <br><br>  Hier ist eine sehr wichtige Konsequenz zu beachten: Wenn ein Absatz mehrere Eingaben hat, kann sich <b>@ 1</b> im ersten Befehl dieses Abschnitts auf ganz unterschiedliche Ergebnisse beziehen, je nachdem, welcher Absatz der vorherige war.  Phi Node ist so eine Situation.  Zuvor wurden in allen Basisbl√∂cken, die den Phi-Knoten initialisierten, Daten in dieselbe Speicherzelle geschrieben, und anstelle des Phi-Knotens wurde ein Lesevorgang aus dieser Zelle durchgef√ºhrt.  Daher war es absolut unwichtig, an welcher Stelle sich in den vorhergehenden Abs√§tzen in dieser Zelle ein Datensatz befand, ebenso wie an welcher Stelle diese Zelle gelesen wurde.  Wenn Sie die Verwendung von Speicher loswerden - es √§ndert sich. <br><br>  Damit Phi-Hosts einen Switch anstelle des Speichers verwenden k√∂nnen, wurde Folgendes ausgef√ºhrt: <br><br><ol><li>  Alle Phi-Knoten in der aktuellen Basiseinheit werden gez√§hlt (und es k√∂nnen auch mehrere vorhanden sein), sind mit einer Seriennummer gekennzeichnet und in dieser Reihenfolge angeordnet </li><li>  F√ºr jeden Phi-Knoten werden die ihn initialisierenden <b>Basisbl√∂cke</b> umgangen und mit Befehlen zum Laden der Werte in den Switch ( <b>loadu_q</b> ) versehen, die durch die Seriennummer des entsprechenden Phi-Knotens gekennzeichnet sind </li><li>  Der phi-Befehl des Knotens selbst wird ebenfalls durch <b>loadu_q</b> mit seiner Seriennummer ersetzt </li><li>  Alle hinzugef√ºgten Befehle werden in der angegebenen Reihenfolge neu angeordnet </li></ol><br>  Der vierte Punkt ist aus dem bereits angegebenen Grund erforderlich: Wenn der Befehl <b>loadu_q @ 3</b> speziell f√ºr seinen Phi-Knoten auf das Ergebnis zugreifen soll, sollten alle initialisierenden Abs√§tze des Befehls, die Daten in den Switch laden, in genau derselben Reihenfolge sein.  Lassen Sie uns ein Beispiel f√ºr das tats√§chliche Ergebnis des Kompilierens von Code geben, in dem sich zwei Phi-Knoten in einer Basiseinheit befinden. <br><br>  Abs√§tze mit Initialisierern f√ºr Phi-Knoten: <br><br><pre> <code class="plaintext hljs">LBB1_27: LBB1_30: SR4 := loadu_q @1 setjf_l @0, LBB1_31 setjf_l @0, LBB1_31 SR4 := loadu_q [#SP + 8] SR5 := loadu_q [#SP + 16] SR5 := loadu_q [#SP] SR6 := loadu_l 0x1 SR6 := add_l @SR4, 0xffffffff SR7 := add_l @SR6, [@SR4] loadu_q @SR5 wr_l @SR7, @SR4 loadu_q @SR6 loadu_q @SR6 complete loadu_q @SR5 complete</code> </pre><br>  Ein Absatz mit zwei Phi-Knoten: <br><br><pre> <code class="plaintext hljs">LBB1_31: SR4 := loadu_q @2 SR5 := loadu_q @2 SR6 := loadu_l [#SP + 124] SR7 := loadu_l [#SP + 120] setjf_l @0, @SR7 setrg_q #RETV, @SR4 wr_l @SR5, @SR6 setrg_q #SP, #SP + 120 complete</code> </pre> <br>  Zuvor gab es anstelle von <b>loadu_q-</b> Befehlen <b>Schreib-</b> und <b>Lesezugriffe</b> in den Speicher. <br>  Bei der Implementierung dieser Optimierung gab es auch einige Probleme, die nicht im Voraus vorhergesehen wurden: <br><br><ul><li>  Bei einigen vorhandenen Codeoptimierungen werden Befehle an bestimmten Stellen neu angeordnet, z. B. indem die Adresse des n√§chsten Absatzes an den Anfang des aktuellen Absatzes gesetzt wird oder die Position der Lese- / Schreibbefehle im Speicher am Anfang bzw. Ende des Absatzes.  Diese Optimierungen treten nach Operationen mit Phi-Knoten auf (den sogenannten LLVM-Anweisungen vor Prozessoranweisungen), sodass sie h√§ufig die erstellte Reihenfolge von <b>loadu_q-</b> Befehlen st√∂ren.  Um die Arbeit dieser Optimierungen nicht zu st√∂ren, musste ich einen separaten LLVM-Durchlauf erstellen, der die Befehle f√ºr Phi-Knoten nach allen anderen Manipulationen mit den Befehlen in der richtigen Reihenfolge anordnet. </li><li>  Es stellte sich heraus, dass eine Situation auftreten kann, in der eine Basiseinheit Phi-Knoten f√ºr zwei verschiedene Basiseinheiten initialisiert.  Das hei√üt, nach dem angegebenen Algorithmus werden diese <b>Basisbl√∂cke</b> zu dem <b>loadu_q-</b> Initialisierungsbefehl f√ºr jeden Phi-Knoten hinzugef√ºgt.  In diesem Fall gibt es, selbst wenn sie nur einen Phi-Knoten haben, im Initialisierungsabschnitt zwei <b>loadu_q-Befehle</b> , die logischerweise beide an letzter Stelle stehen sollten, was nat√ºrlich unm√∂glich ist.  Gl√ºcklicherweise sind solche Situationen recht selten. Wenn es also eine solche Basiseinheit gibt, in der Phi-Knoten f√ºr mehr als eine andere Basiseinheit initialisiert sind, verwendet im √ºbrigen nur die erste den Schalter gem√§√ü dem Algorithmus - wie zuvor - √ºber den Speicher. </li></ul><br>  All diese Optimierungen von Phi-Knoten k√∂nnen noch etwas erg√§nzt werden.  Wenn Sie sich <b>beispielsweise den</b> obigen Absatz <b>LBB1_30 ansehen</b> , k√∂nnen Sie feststellen, dass mit <b>loadu_q-Befehlen</b> Werte geladen werden, die an keiner anderen Stelle verwendet werden.  Wenn Sie also <b>loadu_q</b> entfernen und die Befehle, mit denen diese Werte erstellt werden, in derselben Reihenfolge <b>festlegen, werden</b> mit den Befehlen <b>loadu_q @ 2</b> im n√§chsten Abschnitt auch die richtigen Werte geladen. <br><br><h4>  Benchmarks </h4><br>  Die aktuellen Optimierungsergebnisse wurden an den Benchmarks CoreMark und WhetStone getestet. Eine Beschreibung hierzu finden Sie im <a href="https://habr.com/ru/post/434982/">vorherigen Artikel</a> .  Beginnen wir mit den CoreMark-Ergebnissen auf dem S2-Core im Vergleich zu den alten Ergebnissen (fr√ºhere Version des Compilers auf dem S1-Core). <br><div class="scrollable-table"><table><tbody><tr><th>  CPU </th><th>  <b>Multiclet s2</b> </th><th>  Multiclet s1 </th><th>  Elbrus-4C (E2S) </th><th>  Texas Inst.  AM5728 ARM Cortex-A15 </th><th>  Baikal-t1 </th><th>  Intel Core i7 7700K </th></tr><tr><td>  Taktfrequenz, MHz </td><td>  <b>2500</b> </td><td>  1600 </td><td>  800 </td><td>  1500 </td><td>  1200 </td><td>  4500 </td></tr><tr><td>  CoreMark-Gesamtscore </td><td>  <b>122425</b> </td><td>  18356 </td><td>  8850 </td><td>  15789 </td><td>  13142 </td><td>  182128 </td></tr></tbody></table></div><br>  Die relativen CoreMark / MHz-Werte werden im Histogramm angezeigt: <br><br><img src="https://habrastorage.org/webt/nw/c6/kw/nwc6kwtqwiejo48poskzc0zrzky.png"><br><br>  Um eine Sch√§tzung der Beschleunigung nur aufgrund der Optimierung von Phi-Knoten zu erhalten, k√∂nnen Sie den CoreMark-Indikator auf einer Mehrfachzelle auf S1- und S2-Kernen f√ºr eine Frequenz von 1600 MHz neu berechnen: Sie betragen 1147 bzw. 1224, was einer Steigerung von 6,7% entspricht. <br><br>  Bei WhetStone ist die Situation etwas anders.  √Ñnderungen im Kernel haben hier das Ergebnis beeinflusst, au√üerdem l√§uft dieser Benchmark auf einem Kern (Multicell) und wird in Megahertz berechnet, so dass die Prozessorfrequenz keine Rolle spielt. <br><br>  Whetstone Scorecard: <br><div class="scrollable-table"><table><tbody><tr><th>  CPU </th><th>  <b>MultiClet S2</b> </th><th>  MultiClet S1 </th><th>  Core i7 4820K </th><th>  ARM v8-A53 </th></tr><tr><td>  MWIPS / MHz </td><td>  <b>0,326</b> </td><td>  0,342 </td><td>  0,887 </td><td>  0,642 </td></tr><tr><td>  MFLOPS1 / MHz </td><td>  <b>0,141</b> </td><td>  0,156 </td><td>  0,341 </td><td>  0,268 </td></tr><tr><td>  MFLOPS2 / MHz </td><td>  <b>0,094</b> </td><td>  0,111 </td><td>  0,308 </td><td>  0,241 </td></tr><tr><td>  MFLOPS3 / MHz </td><td>  <b>0,108</b> </td><td>  0,124 </td><td>  0,167 </td><td>  0,239 </td></tr><tr><td>  COS MOPS / MHz </td><td>  <b>0,007</b> </td><td>  0,008 </td><td>  0,023 </td><td>  0,028 </td></tr><tr><td>  EXP MOPS / MHz </td><td>  <b>0,005</b> </td><td>  0,005 </td><td>  0,014 </td><td>  0,004 </td></tr><tr><td>  FIXPT MOPS / MHz </td><td>  <b>0,115</b> </td><td>  0,116 </td><td>  0,998 </td><td>  1,197 </td></tr><tr><td>  WENN MOPS / MHz </td><td>  <b>0,196</b> </td><td>  0,196 </td><td>  1.504 </td><td>  1,436 </td></tr><tr><td>  EQUAL MOPS / MHz </td><td>  <b>0,156</b> </td><td>  0,149 </td><td>  0,251 </td><td>  0,439 </td></tr></tbody></table></div><br>  Jetzt ist klar, dass selbst bei Verwendung der vorherigen Version des Compilers auf dem S1-Kernel der Gesamtindex h√∂her ist, was haupts√§chlich auf die MFLOPS1-3-Gleitkommatests zur√ºckzuf√ºhren ist.  Dieser Nachteil wurde beim Testen bemerkt und wird durch die Tatsache verursacht, dass der interne F√∂rderer des Gleitkomma-Blocks in S2 im Vergleich zu S1 einen Schritt mehr ist.  Infolgedessen verloren aufeinanderfolgende Ketten datenbezogener Befehle einen Takt f√ºr jeden Befehl.  Die Notwendigkeit f√ºr diesen Schritt wurde durch eine Verringerung der Dauer des Taktzyklus (eine Erh√∂hung der Frequenz des Prozessors von 1,6 GHz auf 2,5 GHz und eine Erh√∂hung der Nomenklatur von Befehlen, beispielsweise das Auftreten des Multiplikationsbefehls mit der Akkumulation von MAC) verursacht.  Diese Entscheidung ist vor√ºbergehend.  Die Arbeiten zur Verk√ºrzung der Pipeline sind im Gange und werden in Zukunft behoben, es wurden jedoch Tests mit der aktuellen Version von S2 durchgef√ºhrt. <br><br>  Um die Beschleunigung der Compileroptimierung zu bewerten, wurde WhetStone auch in einer fr√ºheren Version kompiliert und in der aktuellen Version von S2 gestartet.  Der Gesamtindikator betrug 0,3068 MWIPS / MHz gegen√ºber 0,3267 MWIPS / MHz beim neuen Compiler, d. H.  Dies zeigt eine Beschleunigung von 6,5% aufgrund der obigen Optimierungen. <br><br>  Mit dem entwickelten und getesteten Optimierungssystem k√∂nnen Sie in Zukunft das n√§chste Optimierungsschema implementieren, n√§mlich die direkte √úbertragung virtueller Register √ºber den Switch.  Wie bereits erw√§hnt, kann nicht jede Kopie des virtuellen Registers √ºber den Switch erstellt werden.  Aufgrund der begrenzten Gr√∂√üe des Schalters und der Unf√§higkeit, korrekt auf die Ergebnisse der vorherigen Abs√§tze zuzugreifen, wenn es mehrere Einstiegspunkte f√ºr den aktuellen gibt (dies wird teilweise durch Phi-Knoten gel√∂st), besteht die einzige m√∂gliche Option darin, virtuelle Register von einem Absatz direkt in den n√§chsten zu kopieren, es gibt jedoch nur einen vorherigen .  In der Tat sind solche F√§lle nicht so selten. Oft ist es notwendig, Daten so direkt zu √ºbertragen, obwohl es nat√ºrlich schwierig ist, vorab mitzuteilen, wie viel Codebeschleunigung sie bewirken wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480962/">https://habr.com/ru/post/de480962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480950/index.html">Analyse des Android-Quiz vom Stand hh.ru auf der Mobius 2019 in Moskau</a></li>
<li><a href="../de480954/index.html">Aufgabennummer 1. Finden Sie Geschlecht und Verwandtschaftsgrad heraus</a></li>
<li><a href="../de480956/index.html">Wie ich einen Weg gefunden habe, alle Citimobil-Fahrer zu verfolgen</a></li>
<li><a href="../de480958/index.html">Satellitenverbindung. √úbersicht der Betreiberfirmen und ein bisschen √ºber das Rating</a></li>
<li><a href="../de480960/index.html">Finden Sie verlorene Dateien in mehreren Xcode-Zielen</a></li>
<li><a href="../de480964/index.html">Was ist die Fresnel-Zone und CCQ (Client Connection Quality) oder die grundlegenden Faktoren f√ºr eine hochwertige drahtlose Br√ºcke</a></li>
<li><a href="../de480970/index.html">10 Best Practices zum Sichern von Docker-Images. Teil 1</a></li>
<li><a href="../de480974/index.html">Anwendungsentwicklung in VK Mini Apps</a></li>
<li><a href="../de480976/index.html">JSON-RPC-API-Testbibliothek</a></li>
<li><a href="../de480978/index.html">Gibt es ein Leben nach Signora?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>