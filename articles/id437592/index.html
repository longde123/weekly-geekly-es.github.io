<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾 🤙🏿 🏵️ Arsitektur Lapisan Eksekusi Tugas Asinkron 👨🏼‍🌾 🤟🏾 💪🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam aplikasi seluler jejaring sosial, pengguna suka, menulis komentar, lalu membalik-balik feed, memulai video, dan meletakkan yang serupa lagi. Sem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arsitektur Lapisan Eksekusi Tugas Asinkron</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/437592/">  Dalam aplikasi seluler jejaring sosial, pengguna suka, menulis komentar, lalu membalik-balik feed, memulai video, dan meletakkan yang serupa lagi.  Semua ini cepat dan hampir bersamaan.  Jika implementasi logika bisnis dari aplikasi benar-benar memblokir, maka pengguna tidak akan dapat pergi ke rekaman sampai suka untuk merekam dengan segel diunggah.  Tetapi pengguna tidak akan menunggu, oleh karena itu, di sebagian besar aplikasi seluler tugas asinkron berfungsi, yang dimulai dan diselesaikan secara terpisah satu sama lain.  Pengguna melakukan beberapa tugas secara bersamaan dan mereka tidak memblokir satu sama lain.  Satu tugas tidak sinkron dimulai dan dijalankan sementara pengguna memulai yang berikutnya. <br><br><img src="https://habrastorage.org/webt/on/8u/ys/on8uys9oib69dbqrfu4xfnnq-0u.png"><br><br>  Dalam menguraikan laporan <b>Stepan Goncharov</b> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsConf,</a> kita akan menyentuh asynchrony: kita akan mempelajari arsitektur aplikasi mobile, membahas mengapa kita harus memisahkan lapisan untuk melakukan tugas-tugas yang tidak sinkron, kita akan menganalisis persyaratan dan solusi yang ada, kita akan melalui pro dan kontra, dan mempertimbangkan salah satu implementasi dari pendekatan ini.  Kami juga belajar bagaimana mengelola tugas yang tidak sinkron, mengapa setiap tugas memiliki ID sendiri, apa saja strategi pelaksanaannya dan bagaimana mereka membantu menyederhanakan dan mempercepat pengembangan seluruh aplikasi. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tBC5Zoxcgbk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>Tentang pembicara: Stepan Goncharov</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">stepango</a> ) bekerja di Grab - seperti Uber, tetapi di Asia Tenggara.  Dia telah terlibat dalam pengembangan Android selama lebih dari 9 tahun.  Tertarik pada Kotlin sejak 2014, dan sejak 2016 - menggunakannya di prod.  Diorganisir oleh Kelompok Pengguna Kotlin di Singapura.  Ini adalah salah satu alasan mengapa semua contoh kode ada di Kotlin, dan bukan karena itu modis. <br><br>  Kami akan melihat satu pendekatan untuk merancang komponen aplikasi Anda.  Ini adalah panduan untuk bertindak bagi mereka yang ingin menambahkan komponen baru ke aplikasi, dengan mudah mendesainnya, dan kemudian mengembangkannya.  Pengembang iOS dapat menggunakan pendekatan iOS.  Pendekatan ini juga berlaku untuk platform lain.  Saya telah tertarik dengan Kotlin sejak 2014, jadi semua contoh akan ada dalam bahasa ini.  Tapi jangan khawatir - Anda dapat menulis hal yang sama dalam bahasa Swift, Objective-C, dan lainnya. <br><br>  Mari kita mulai dengan masalah dan kerugian dari <b>Ekstensi Reaktif</b> .  Masalah adalah tipikal dari primitif asinkron lainnya, jadi kami katakan RX - ingat masa depan dan janji, dan semuanya akan bekerja sama. <br><br><h2>  Masalah RX </h2><br>  <b>Ambang entri tinggi</b> .  RX cukup rumit dan besar - memiliki 270 operator, dan tidak mudah untuk mengajar seluruh tim untuk menggunakannya dengan benar.  Kami tidak akan membahas masalah ini - ini berada di luar cakupan laporan. <br><br>  Di RX, Anda harus <b>mengelola langganan Anda secara manual, serta memantau siklus hidup aplikasi</b> .  Jika Anda telah berlangganan Single atau Observable, Anda <b>tidak dapat membandingkannya dengan SIngle lain</b> , karena Anda akan selalu menerima objek baru dan akan selalu ada langganan yang berbeda untuk runtime.  <b>Di RX tidak ada cara untuk membandingkan langganan dan aliran</b> . <br><br>  Kami akan mencoba menyelesaikan beberapa masalah ini.  Kami akan memecahkan setiap masalah satu kali, dan kemudian menggunakan kembali hasilnya. <br><br><h2>  Masalah nomor 1: melakukan satu tugas lebih dari sekali </h2><br>  Masalah umum dalam pengembangan adalah pekerjaan yang tidak perlu dan pengulangan tugas yang sama lebih dari sekali.  Bayangkan kita memiliki formulir untuk memasukkan data dan tombol simpan.  Ketika ditekan, permintaan dikirim, tetapi jika Anda mengklik beberapa kali saat formulir disimpan, maka beberapa permintaan yang sama akan dikirim.  Kami memberikan tombol untuk menguji QA, mereka menekan 40 kali dalam satu detik - kami menerima 40 permintaan, karena, misalnya, animasi tidak punya waktu untuk bekerja. <br><br>  Bagaimana cara mengatasi masalah tersebut?  Masing-masing pengembang memiliki pendekatan favoritnya sendiri untuk menyelesaikan: satu akan menempel <code>debounce</code> , yang lain akan memblokir tombol untuk berjaga-jaga melalui <code>clickable = false</code>  Tidak ada pendekatan umum, sehingga bug ini akan muncul atau menghilang dari aplikasi kita.  Kami menyelesaikan masalah hanya ketika QA memberi tahu kami: "Oh, saya klik di sini, dan itu rusak"! <br><br><h3>  Solusi yang scalable? </h3><br>  Untuk menghindari situasi seperti itu, kami akan membungkus RX atau kerangka kerja asinkron lainnya - <b>kami akan menambahkan ID ke semua operasi asinkron</b> .  Idenya sederhana - kita perlu beberapa cara untuk membandingkannya, karena biasanya metode ini tidak ada dalam kerangka kerja.  Kami dapat menyelesaikan tugas, tetapi kami tidak tahu apakah itu sudah selesai atau belum. <br><br>  Sebut pembungkus kami "Act" - nama lain sudah diambil.  Untuk melakukan ini, buat <code>typealias</code> kecil dan <code>interface</code> sederhana di mana hanya ada satu bidang: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> Id = String <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Act</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: Id }</code> </pre> <br>  Ini nyaman dan sedikit mengurangi jumlah kode.  Nantinya, jika String tidak menyukainya, kami akan menggantinya dengan yang lain.  Dalam potongan kode kecil ini, kami mengamati fakta lucu. <br><br><blockquote>  Antarmuka dapat berisi properti. </blockquote><br>  Untuk programmer yang datang dari Jawa, ini tidak terduga.  Biasanya mereka menambahkan metode <code>getId()</code> di dalam antarmuka, tetapi ini adalah solusi yang salah, dari sudut pandang Kotlin. <br><br><h3>  Bagaimana kita mendesain? </h3><br>  Penyimpangan kecil.  Saat mendesain, saya mematuhi dua prinsip.  Yang pertama adalah <b>memecah persyaratan komponen dan implementasi menjadi potongan-potongan kecil</b> .  Ini memungkinkan kontrol granular atas penulisan kode.  Ketika Anda membuat komponen besar dan mencoba melakukan semuanya sekaligus, ini buruk.  Biasanya komponen ini tidak berfungsi dan Anda mulai memasukkan kruk, jadi saya mendorong Anda untuk menulis dalam langkah-langkah kecil yang terkontrol dan menikmatinya.  Prinsip kedua adalah <b>memeriksa operabilitas</b> setelah setiap langkah dan <b>ulangi prosedur</b> lagi. <br><br><h3>  Mengapa ID tidak cukup? </h3><br>  Mari kita kembali ke masalahnya.  Kami mengambil langkah pertama - kami menambahkan ID, dan semuanya sederhana - antarmuka dan bidang.  Ini tidak memberi kami apa pun, karena antarmuka tidak mengandung implementasi apa pun dan tidak berfungsi sendiri, tetapi memungkinkan Anda untuk membandingkan operasi. <br><br>  Selanjutnya, kami akan menambahkan komponen yang akan memungkinkan kami untuk menggunakan antarmuka dan memahami bahwa kami ingin menjalankan beberapa jenis permintaan untuk kedua kalinya saat ini tidak diperlukan.  Hal pertama yang akan kita lakukan adalah <b>memperkenalkan abstraksi baru</b> . <br><br><h3>  Memperkenalkan Abstraksi Baru: MapDisposable </h3><br>  Penting untuk memilih nama yang tepat dan abstraksi yang familier bagi pengembang yang bekerja di basis kode Anda.  Karena saya punya contoh tentang RX, kami akan menggunakan konsep RX dan nama-nama yang mirip dengan yang digunakan oleh pengembang perpustakaan.  Jadi kita dapat dengan mudah menjelaskan kepada rekan kerja kita apa yang mereka lakukan, mengapa, dan bagaimana cara kerjanya.  Untuk memilih nama, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi CompositeDiposable</a> . <br><br>  Mari kita buat antarmuka MapDisposable kecil yang <b>berisi informasi</b> tentang tugas-tugas saat ini dan <b>panggilan buang () pada penghapusan</b> .  Saya tidak akan memberikan implementasinya, Anda dapat melihat semua sumber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di GitHub saya</a> . <br><br>  Kami memanggil MapDisposable dengan cara ini karena komponen akan bekerja seperti Peta, tetapi akan memiliki properti CompositeDiposable. <br><br><h3>  Memperkenalkan Abstraksi Baru: ActExecutor </h3><br>  Komponen abstrak berikutnya adalah <b>ActExecutor.</b>  Itu mulai atau tidak memulai tugas baru, tergantung pada MapDisposable dan delegasi penanganan kesalahan.  Cara memilih nama - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat dokumentasi</a> . <br><br>  Ambil analogi terdekat dari JDK.  Ini memiliki Pelaksana di mana Anda dapat melewati utas dan melakukan sesuatu.  Menurut saya ini komponen yang keren dan dirancang dengan baik, jadi mari kita ambil sebagai dasarnya. <br><br>  Kami membuat ActExecutor dan antarmuka yang sederhana untuknya, mengikuti prinsip langkah-langkah kecil yang sederhana.  Nama itu sendiri mengatakan bahwa itu adalah komponen yang kami kirimkan sesuatu dan mulai melakukan sesuatu.  ActExecutor memiliki satu metode di mana kami melewati <code>Act</code> dan, untuk berjaga-jaga, menangani kesalahan, karena tanpa mereka tidak ada cara. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActExecutor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = ::logError) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapDisposable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">, disposable: ()</span></span></span></span> -&gt; T) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br>  MapDisposable juga terbatas: ambil antarmuka Peta dan salin isi, <code>add</code> , dan <code>remove</code> metode dari itu.  Metode <code>add</code> berbeda dari Map: argumen kedua adalah lambda untuk keindahan dan kenyamanan.  Kemudahannya adalah kita dapat menyinkronkan lambda untuk mencegah <b>kondisi balapan yang</b> tidak terduga.  Tetapi kita tidak akan membicarakan hal ini, kita akan melanjutkan tentang arsitektur. <br><br><h3>  Implementasi Antarmuka </h3><br>  Kami telah mendeklarasikan semua antarmuka dan akan mencoba menerapkan sesuatu yang sederhana.  Ambil <b>CompletableAct</b> dan <b>SingleAct</b> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletableAct</span></span></span><span class="hljs-class"> </span></span>( <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: Id, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> completable: Completable ) : Act <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SingleAct</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T : Any</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: Id, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> single: Single&lt;T&gt; ) : Act</code> </pre> <br>  CompletableAct adalah pembungkus lebih dari Completable.  Dalam kasus kami, ini hanya berisi ID - yang kami butuhkan.  SingleAct hampir sama.  Kita dapat mengimplementasikan Maybe and Flowable juga, tetapi tetap pada dua implementasi pertama. <br><br>  Untuk Single, kami menentukan tipe Generik <code>&lt;T : Any&gt;</code> .  Sebagai pengembang Kotlin, saya lebih suka menggunakan pendekatan seperti itu. <br><br><blockquote>  Coba gunakan Non-Null Generics. </blockquote><br>  Sekarang kami memiliki seperangkat antarmuka, kami menerapkan beberapa logika untuk mencegah eksekusi permintaan yang sama. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActExecutorImpl</span></span></span><span class="hljs-class"> </span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> map: MapDisposable ): ActExecutor { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ) = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { map.contains(act.id) -&gt; { log(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${act.id}</span></span></span><span class="hljs-string"> - in progress"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> startExecution(act, e) log(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${act.id}</span></span></span><span class="hljs-string"> - Started"</span></span>) } }</code> </pre> <br>  Kami mengambil Peta dan memeriksa apakah ada permintaan di dalamnya.  Jika tidak, kami mulai menjalankan permintaan dan menambahkannya ke Peta tepat saat runtime.  Setelah eksekusi dengan hasil apa pun: kesalahan atau keberhasilan, hapus permintaan dari Peta. <br><br>  Untuk sangat penuh perhatian - tidak ada sinkronisasi, tetapi sinkronisasi ada dalam kode sumber di GitHub. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startExecution</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> removeFromMap = { mapDisposable.remove(act.id) } mapDisposable.add(act.id) { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (act) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> CompletableAct -&gt; act.completable .doFinally(removeFromMap) .subscribe({}, e) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> SingleAct&lt;*&gt; -&gt; act.single .doFinally(removeFromMap) .subscribe({}, e) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalArgumentException() } }</code> </pre> <br><blockquote>  Gunakan lambdas sebagai argumen terakhir untuk meningkatkan keterbacaan kode.  Itu indah dan kolega Anda akan berterima kasih. </blockquote><br>  Kami akan menggunakan beberapa chip Kotlin lagi dan menambahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi ekstensi</a> untuk Completable dan Single.  Dengan mereka, kita tidak perlu mencari metode pabrik untuk membuat CompletableAct dan SingleAct - kita akan membuatnya melalui fungsi ekstensi. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Completable.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toAct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Act = CompletableAct(id, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T: Any&gt;</span></span></span><span class="hljs-function"> Single</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toAct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Act = SingleAct(id, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre> <br><blockquote>  Fungsi ekstensi dapat ditambahkan ke kelas apa pun. </blockquote><br><h3>  Hasil </h3><br>  Kami telah menerapkan beberapa komponen dan logika yang sangat sederhana.  Sekarang aturan utama yang harus kita ikuti adalah <b>tidak memaksa berlangganan dengan tangan</b> .  Ketika kami ingin mengeksekusi sesuatu - kami memberikannya melalui Executor.  Seperti halnya dengan utas - tidak ada yang memulai sendiri. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">act</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS).toAct(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>) executor.apply { execute(act()) execute(act()) execute(act()) } Hello - Act Started Hello - Act Duplicate Hello - Act Duplicate Hello - Act Finished</code> </pre> <br>  Kami pernah menyetujui dalam tim, dan sekarang selalu ada jaminan bahwa sumber daya aplikasi kami tidak akan dihabiskan untuk pelaksanaan permintaan yang identik dan tidak perlu. <br><br>  Masalah pertama terpecahkan.  Sekarang mari kita memperluas solusi untuk memberikan fleksibilitas. <br><br><h2>  Masalah nomor 2: tugas apa yang harus dibatalkan? </h2><br>  Seperti halnya dalam kasus di mana perlu untuk <b>membatalkan permintaan berikutnya</b> , kami mungkin perlu membatalkan yang sebelumnya.  Misalnya, kami mengedit informasi tentang pengguna kami untuk pertama kalinya dan mengirimkannya ke server.  Untuk beberapa alasan, pengirimannya memakan waktu lama dan tidak selesai.  Kami mengedit profil pengguna lagi dan mengirim permintaan yang sama untuk kedua kalinya.  Dalam hal ini, tidak masuk akal untuk menghasilkan ID khusus untuk permintaan - informasi dari upaya kedua lebih relevan, dan <b>permintaan sebelumnya dibatalkan</b> . <br><br>  Solusi saat ini tidak akan berfungsi, karena itu akan selalu membatalkan eksekusi permintaan dengan informasi yang relevan.  Kita perlu mengembangkan solusi untuk mengatasi masalah dan menambah fleksibilitas.  Untuk melakukan ini, mengerti apa yang kita semua inginkan?  Tapi kami ingin memahami tugas apa yang harus dibatalkan, bagaimana tidak menyalin-menempel dan memanggilnya apa. <br><br><h3>  Tambahkan komponen </h3><br>  Kami menyebut strategi perilaku kueri dan membuat dua antarmuka untuk mereka: <b>StrategyHolder</b> dan <b>Strategy</b> .  Kami juga membuat 2 objek yang bertanggung jawab atas strategi yang diterapkan. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrategyHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> strategy: Strategy } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KillMe</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Strategy</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SaveMe : Strategy()</code> </pre> <br>  Saya tidak menggunakan <b>enum</b> - Saya lebih menyukai <b>kelas yang disegel</b> .  Mereka lebih ringan, mengkonsumsi lebih sedikit memori, dan mereka lebih mudah dan lebih nyaman untuk diperluas. <br><br><blockquote>  Kelas yang disegel lebih mudah diperluas dan ditulis lebih pendek. </blockquote><br><h3>  Memperbarui Komponen yang Ada </h3><br>  Pada titik ini, semuanya sederhana.  Kami memiliki antarmuka yang sederhana, sekarang akan menjadi pewaris StrategyHolder.  Karena ini adalah antarmuka, tidak ada masalah dengan warisan.  Dalam implementasi CompletableAct kami akan memasukkan <code>override</code> lain dan menambahkan nilai default di sana untuk memastikan bahwa perubahan akan tetap kompatibel dengan kode yang ada. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Act</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StrategyHolder { val id: String } class CompletableAct</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: String, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> completable: Completable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> strategy: Strategy = SaveMe ) : Act</code> </pre> <br><h3>  Strategi </h3><br>  Saya memilih strategi <b>SaveMe</b> , yang tampak jelas bagi saya.  Strategi ini hanya membatalkan permintaan berikut - permintaan pertama akan selalu hidup sampai selesai. <br><br>  Kami bekerja sedikit pada implementasi kami.  Kami memiliki metode eksekusi, dan sekarang kami telah menambahkan pemeriksaan strategi di sana. <br><br><ul><li>  Jika strategi <b>SaveMe</b> sama dengan apa yang kami lakukan sebelumnya, maka tidak ada yang berubah. <br></li><li>  Jika strateginya adalah <b>KillMe</b> , bunuh permintaan sebelumnya dan luncurkan yang baru. <br></li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { map.contains(act.id) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (act.strategy) { KillMe -&gt; { map.remove(act.id) startExecution(act, e) } SaveMe -&gt; log(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${act.id}</span></span></span><span class="hljs-string"> - Act duplicate"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; startExecution(act, e) }</code> </pre> <br><h3>  Hasil </h3><br>  Kami dapat dengan mudah mengelola strategi dengan menulis kode minimal.  Pada saat yang sama, kolega kami senang, dan kami bisa melakukan sesuatu seperti ini. <br><br><pre> <code class="kotlin hljs">executor.apply { execute(Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS) .toAct(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>, KillMe)) execute(Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS) .toAct(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>, KillMe)) execute(Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS) .toAct(<span class="hljs-string"><span class="hljs-string">"Hello«, KillMe)) } Hello - Act Started Hello - Act Canceled Hello - Act Started Hello - Act Canceled Hello - Act Started Hello - Act Finished</span></span></code> </pre> <br>  Kami membuat tugas yang tidak sinkron, melewati strategi, dan setiap kali kami memulai tugas baru, semua yang sebelumnya, dan bukan yang berikutnya, akan dibatalkan. <br><br><h2>  Masalah nomor 3: strategi tidak cukup </h2><br>  Mari kita beralih ke satu masalah menarik yang saya temui di beberapa proyek.  Kami akan memperluas solusi kami untuk menangani kasus yang lebih rumit.  Salah satu kasus ini, terutama yang relevan untuk jejaring sosial, adalah <b>"suka / tidak suka"</b> .  Ada pos dan kami ingin menyukainya, tetapi sebagai pengembang kami tidak ingin memblokir seluruh UI, dan menampilkan dialog di layar penuh dengan memuat sampai permintaan selesai.  Ya, dan pengguna tidak akan senang.  Kami ingin menipu pengguna: ia menekan tombol dan, seolah-olah hal seperti itu sudah terjadi - animasi yang indah telah dimulai.  Tetapi pada kenyataannya, tidak ada yang seperti - kita menunggu sampai penipuan menjadi kenyataan.  Untuk mencegah penipuan, kami harus secara transparan menangani ketidaksukaan bagi pengguna. <br><br>  Akan menyenangkan untuk menangani ini dengan benar sehingga pengguna mendapatkan hasil yang diinginkan.  Tetapi sulit bagi kami, sebagai pengembang, untuk menangani <b>permintaan yang berbeda dan saling eksklusif</b> setiap kali. <br><br>  Ada terlalu banyak pertanyaan.  Bagaimana memahami bahwa kueri terkait?  Bagaimana cara menyimpan koneksi ini?  Bagaimana menangani skrip yang rumit dan tidak menyalin-menempel?  Bagaimana memberi nama komponen baru?  Tugasnya kompleks, dan apa yang sudah kami implementasikan tidak cocok untuk solusinya. <br><br><h3>  Grup dan strategi untuk grup </h3><br>  Buat antarmuka sederhana yang disebut <b>GroupStrategyHolder</b> .  Ini sedikit lebih rumit - dua bidang, bukan satu. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupStrategyHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> groupStrategy: GroupStrategy <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> groupKey: String } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupStrategy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Default</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GroupStrategy</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> KillGroup : GroupStrategy()</code> </pre> <br>  Selain strategi untuk permintaan tertentu, kami memperkenalkan entitas baru - sekelompok permintaan.  Grup ini juga akan memiliki strategi.  Kami hanya akan mempertimbangkan opsi paling sederhana dengan dua strategi: <b>Default</b> - strategi default ketika kami tidak melakukan apa pun dengan kueri, dan <b>KillGroup</b> - membunuh semua pertanyaan yang ada dari grup dan meluncurkan yang baru. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Act</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StrategyHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GroupStrategyHolder { val id: String } class CompletableAct</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: String, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> completable: Completable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> strategy: Strategy = SaveMe, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> groupStrategy: GroupStrategy = Default <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> groupKey: String = <span class="hljs-string"><span class="hljs-string">""</span></span> ) : Act</code> </pre><br>  Kami mengulangi langkah-langkah yang saya bicarakan sebelumnya: kami mengambil antarmuka, memperluas dan menambahkan dua bidang tambahan ke CompletableAct dan SingleAct. <br><br><h3>  Perbarui implementasi </h3><br>  Kami kembali ke metode Jalankan.  Tugas ketiga lebih rumit, tetapi solusinya cukup sederhana: kami memeriksa strategi grup untuk permintaan tertentu dan, jika itu adalah KillGroup, kami membunuh seluruh grup dan menjalankan logika yang biasa. <br><br><pre> <code class="kotlin hljs">MapDisposable -&gt; GroupDisposable ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (act.groupStrategy == KillGroup) groupDisposable.removeGroup(act.groupKey) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { groupDisposable.contains(act.groupKey, act.id) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (act.strategy) { KillMe -&gt; { stop(act.groupKey, act.id) startExecution(act, e) } SaveMe -&gt; log(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${act.id}</span></span></span><span class="hljs-string"> - Act duplicate"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; startExecution(act, e) } }</code> </pre> <br>  Masalahnya kompleks, tetapi kami sudah memiliki infrastruktur yang cukup memadai - kami dapat mengembangkannya dan menyelesaikan masalah.  Jika Anda melihat hasil kami, apa yang perlu kita lakukan sekarang? <br><br><h3>  Hasil </h3><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">act</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>= Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS).toAct( id = id, groupStrategy = KillGroup, groupKey = <span class="hljs-string"><span class="hljs-string">"Like-Dislike-PostId-1234"</span></span> ) executor.apply { execute(act(“Like”)) execute(act(“Dislike”)) execute(act(“Like”)) } Like - Act Started Like - Act Canceled Dislike - Act Started Dislike - Act Canceled Like - Act Started Like - Act Finished</code> </pre> <br>  Jika kami membutuhkan kueri yang rumit, kami menambahkan dua bidang: groupStrategy dan ID grup.  ID grup adalah parameter khusus, karena untuk mendukung banyak permintaan suka / tidak suka paralel, Anda perlu membuat grup untuk setiap pasangan permintaan yang termasuk dalam objek yang sama.  Dalam hal ini, Anda dapat memberi nama grup Suka-Tidak Suka-PostId dan tambahkan ID posting di sana.  Setiap kali kami menyukai posting yang berdekatan, kami akan yakin bahwa semuanya berfungsi dengan baik untuk posting sebelumnya, dan untuk posting berikutnya. <br><br>  Dalam contoh sintetik kami, kami mencoba menjalankan urutan suka-tidak suka-suka.  Ketika kami melakukan tindakan pertama, dan kemudian yang kedua - yang sebelumnya dibatalkan dan yang berikutnya membatalkan ketidaksukaan sebelumnya.  Inilah yang saya inginkan. <br><br>  Dalam contoh terakhir, kami menggunakan parameter bernama untuk membuat Kisah Para Rasul.  Ini membantu pembacaan kode yang keren, terutama ketika ada banyak parameter. <br><br><blockquote>  Untuk membaca lebih mudah, gunakan parameter bernama. </blockquote><br><h2>  Arsitektur </h2><br>  Mari kita lihat bagaimana keputusan ini dapat mempengaruhi arsitektur kita.  Pada proyek, saya sering melihat bahwa View Model atau Presenter mengambil banyak tanggung jawab, seperti peretasan, untuk menangani situasi dengan suka / tidak suka.  Biasanya semua logika ini dalam Model Tampilan: banyak kode duplikat dengan penguncian tombol, penangan LifeCycle, langganan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d2c/a94/35b/d2ca9435bf58a6a261edbf1e7eb046ba.png"><br><br>  Segala sesuatu yang Pelaku kita lakukan sekarang adalah baik dalam Presenter atau View Model.  Jika arsitekturnya matang, pengembang dapat membawa logika ini ke beberapa jenis interaksi atau kasus penggunaan, tetapi logika itu digandakan di beberapa tempat. <br><br>  Setelah kami mengadopsi Pelaksana, Model Tampilan menjadi lebih sederhana dan semua logika disembunyikan dari mereka.  Jika Anda pernah membawa ini ke Presenter dan interkom, maka Anda tahu bahwa interkom dan Presenter semakin mudah.  Secara umum, saya puas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef8/215/4c3/ef82154c3a09b62d063ed02ff4d40267.png"><br><br><h2>  Apa lagi yang ingin ditambahkan? </h2><br>  Kelebihan lain dari solusi saat ini adalah bahwa ia dapat diperluas.  Apa lagi yang ingin kita tambahkan sebagai pengembang yang bekerja pada aplikasi seluler dan berjuang dengan bug dan banyak permintaan bersamaan setiap hari? <br><br><h3>  Kemungkinan </h3><br>  <b>Implementasi dari siklus hidup</b> tetap di belakang layar, tetapi sebagai pengembang ponsel, kita semua selalu memikirkan hal ini dan khawatir sehingga tidak ada yang akan mengalir.  Saya ingin <b>menyimpan dan mengembalikan</b> permintaan restart aplikasi. <br><br>  <b>Rantai panggilan.</b>  Karena pembungkus rantai RX, dimungkinkan untuk membuat cerita bersambung, karena secara default RX tidak membuat cerita bersambung. <br><br>  Hanya sedikit orang yang tahu berapa banyak permintaan bersamaan berjalan pada titik waktu tertentu dalam aplikasi mereka.  Saya tidak akan mengatakan bahwa ini adalah masalah besar untuk aplikasi kecil dan menengah.  Tetapi untuk aplikasi besar yang melakukan banyak pekerjaan di latar belakang, senang memahami penyebab gangguan dan keluhan pengguna.  Tanpa infrastruktur tambahan, pengembang tidak memiliki informasi untuk memahami alasannya: mungkin alasannya ada di UI, atau mungkin dalam sejumlah besar permintaan konstan di latar belakang.  Kami dapat memperluas solusi kami dan menambahkan beberapa jenis <b>metrik</b> . <br><br>  Mari kita pertimbangkan kemungkinan secara lebih rinci. <br><br><h3>  Pemrosesan siklus hidup </h3><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActExecutorImpl</span></span></span></span>( lifecycle: Lifecycle ) : ActExecutor { inir { lifecycle.doOnDestroy { cancelAll() } } ...</code> </pre> <br>  Ini adalah contoh implementasi siklus hidup.  Dalam kasus yang paling sederhana - dengan <code>Destroy</code> fragmen atau dibatalkan dengan <code>Activity</code> , kami <b>meneruskan lifecycle-handler kepada Pelaksana kami</b> , dan ketika <b>peristiwa onDestroy terjadi, kami menghapus semua permintaan</b> .  Ini adalah solusi sederhana yang menghilangkan kebutuhan untuk menyalin-menempelkan kode serupa di View Models.  LifeData melakukan hal yang kurang lebih sama. <br><br><h3>  Menyimpan / Memulihkan </h3><br>  Karena kita memiliki pembungkus, kita dapat membuat <b>kelas terpisah untuk Kisah Para Rasul</b> , di dalamnya akan ada logika untuk membuat tugas-tugas yang tidak sinkron.  Selanjutnya, kita dapat <b>menyimpan</b> nama ini ke basis data dan <b>mengembalikannya dari basis data saat startup aplikasi</b> menggunakan metode pabrik atau yang serupa. <br><br>  Pada saat yang sama, kami akan mendapatkan kesempatan pekerjaan offline dan kami akan memulai kembali permintaan yang dilengkapi dengan kesalahan saat Internet muncul.  Dengan tidak adanya Internet atau dengan kesalahan permintaan, kami menyimpannya ke database, dan kemudian mengembalikan dan menjalankannya lagi.  Jika Anda dapat melakukan ini dengan RX biasa tanpa pembungkus tambahan, silakan tulis di komentar, itu akan menarik. <br><br><h3>  Rantai panggilan </h3><br>  Kita juga dapat <b>mengikat Kisah Para Rasul kita</b> .  Opsi ekstensi lainnya adalah <b>menjalankan rantai kueri</b> .  Misalnya, Anda memiliki satu entitas yang perlu dibuat di server, dan entitas lain, yang tergantung pada yang pertama, harus dibuat tepat pada saat kami yakin bahwa permintaan pertama berhasil.  Ini juga bisa dilakukan.  Tentu saja, ini tidak sepele, tetapi memiliki kelas yang mengontrol peluncuran semua tugas asinkron dimungkinkan.  Menggunakan RX telanjang lebih sulit dilakukan. <br><br><h3>  Metrik </h3><br>  Sangat menarik untuk melihat <b>berapa banyak permintaan paralel dilakukan rata-rata di latar belakang</b> .  Memiliki metrik, Anda dapat memahami penyebab keluhan pengguna tentang kelesuan.  ,         ,    . <br><br>          ,  , , <b>   </b>  ,   -    -    10%   .    ,    . <br><br><h2>  Kesimpulan </h2><br> <b>  </b> —  ,    . «»      .       ,         ,  ,  ,    . <br><br>       ,      ,   .   —   - , ,  —   .    — .  ,           .       . <b>      </b> . <br><br> <b>     </b> .    Kotlin,              . , <b>    </b> . <br><br><blockquote>       AppsConf 2018,      <b> AppsConf 2019</b> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a>  38 : ,  Android, UX, , - , , Kotlin. <br><br>   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">youtube-</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>    <b>22–23 </b>    . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437592/">https://habr.com/ru/post/id437592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437582/index.html">Tinjauan umum tentang Vue.js 2.6</a></li>
<li><a href="../id437584/index.html">Dasar-Dasar Matematika dari Tata Letak Otomatis</a></li>
<li><a href="../id437586/index.html">Kami membuat aplikasi suara menggunakan contoh Google Assistant</a></li>
<li><a href="../id437588/index.html">Apakah lebih menyenangkan untuk dikembangkan untuk ponsel daripada untuk web?</a></li>
<li><a href="../id437590/index.html">Nomor latensi pada iPhone</a></li>
<li><a href="../id437594/index.html">Bagaimana saya menghilangkan penyebab kegagapan dan melewatkan bingkai di semua game, dan juga secara tidak sengaja menurunkan suhu hingga 15 derajat</a></li>
<li><a href="../id437596/index.html">OTRS: Otentikasi, otorisasi, dan sinkronisasi LDAP (FreeIPA, AD)</a></li>
<li><a href="../id437598/index.html">Bagaimana cara menyimpan sistem gim dari PC rumahan dengan cara virtualisasi</a></li>
<li><a href="../id437600/index.html">opencv4arts: Gambarkan kotaku, Vincent</a></li>
<li><a href="../id437602/index.html">Profil proyek Persatuan dengan Android Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>