<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¥üèº ü§µüèº üõë So beschleunigen Sie das Entladen von LZ4 in ClickHouse ü¶Ö üöØ üò∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie Abfragen in ClickHouse ausf√ºhren, k√∂nnen Sie feststellen, dass im Profiler an einer der ersten Stellen h√§ufig die Funktion LZ_decompress_fast...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So beschleunigen Sie das Entladen von LZ4 in ClickHouse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/452778/"> Wenn Sie Abfragen in ClickHouse ausf√ºhren, k√∂nnen Sie feststellen, dass im Profiler an einer der ersten Stellen h√§ufig die Funktion LZ_decompress_fast sichtbar ist.  Warum passiert das?  Diese Frage wurde zum Grund f√ºr die gesamte Studie zur Auswahl des besten Dekomprimierungsalgorithmus.  Hier ver√∂ffentliche ich die gesamte Studie und die Kurzversion finden Sie in meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> √ºber HighLoad ++ Siberia. <br><br>  ClickHouse-Daten werden in komprimierter Form gespeichert.  Und w√§hrend der Ausf√ºhrung von Anforderungen versucht ClickHouse fast nichts zu tun - verwenden Sie ein Minimum an CPU-Ressourcen.  Es kommt vor, dass alle Berechnungen, die eine Weile dauern k√∂nnen, bereits gut optimiert sind und die Anforderung vom Benutzer gut geschrieben wurde.  Dann bleibt die Freigabe durchzuf√ºhren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/057/302/aba/057302aba5041790af404c2c781c4dd3.png"><br><br>  Die Frage ist - warum kann das Entladen von LZ4 ein Engpass sein?  Es scheint, dass LZ4 ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sehr leichter Algorithmus ist</a> : Die Komprimierungsrate liegt je nach Daten normalerweise zwischen 1 und 3 GB / s pro Prozessorkern.  Dies ist deutlich mehr als die Geschwindigkeit des Festplattensubsystems.  Dar√ºber hinaus verwenden wir alle verf√ºgbaren Kernel und die Erweiterung skaliert linear √ºber alle physischen Kernel. <br><a name="habracut"></a><br>  Es sind jedoch zwei Punkte zu beachten.  Zun√§chst werden komprimierte Daten von der Festplatte gelesen, und die Komprimierungsrate wird in der Menge der nicht komprimierten Daten angegeben.  Wenn das Komprimierungsverh√§ltnis gro√ü genug ist, muss fast nichts von den Datentr√§gern gelesen werden.  Gleichzeitig werden jedoch viele komprimierte Daten generiert, was sich nat√ºrlich auf den CPU-Verbrauch auswirkt: Der Umfang der Datenkomprimierungsarbeit bei LZ4 ist nahezu proportional zum Volumen der komprimierten Daten. <br><br>  Zweitens ist das Lesen von Daten von Datentr√§gern m√∂glicherweise √ºberhaupt nicht erforderlich, wenn sich die Daten im Cache befinden.  Dazu k√∂nnen Sie sich auf den Seitencache verlassen oder Ihren eigenen Cache verwenden.  In einer Spaltendatenbank ist die Verwendung des Caches effizienter, da nicht alle Spalten in den Cache fallen, sondern nur h√§ufig verwendete.  Aus diesem Grund ist LZ4 in Bezug auf die CPU-Auslastung h√§ufig ein Engpass. <br><br>  Daher noch zwei Fragen.  Wenn die Datenkomprimierung "verlangsamt" wird, sollten sie m√∂glicherweise √ºberhaupt nicht komprimiert werden?  In der Praxis ist diese Annahme jedoch bedeutungslos.  K√ºrzlich war es in ClickHouse m√∂glich, nur zwei Datenkomprimierungsoptionen zu konfigurieren - LZ4 und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zstandard</a> .  Der Standardwert ist LZ4.  Durch Umschalten auf Zstandard k√∂nnen Sie die Komprimierung st√§rker und langsamer machen.  Bis vor kurzem war es jedoch unm√∂glich, die Komprimierung vollst√§ndig zu deaktivieren - LZ4 wird als angemessenes Minimum angesehen, das immer verwendet werden kann.  Deshalb liebe ich den LZ4 wirklich.  :) :) <br><br>  Aber k√ºrzlich erschien im englischsprachigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chat-Chat von</a> ClickHouse ein mysteri√∂ser Fremder, der sagte, er habe ein sehr schnelles Festplattensubsystem (NVMe SSD) und alles h√§nge von der Komprimierung ab - es w√§re sch√∂n, es ausschalten zu k√∂nnen.  Ich antwortete, dass es keine solche M√∂glichkeit gibt, aber es ist einfach hinzuzuf√ºgen.  Einige Tage sp√§ter erhielten wir eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Poolanforderung</a> , die die Methode der <code>none</code> implementiert.  Ich fragte nach den Ergebnissen - wie sehr dies half, wie schnell die Anfragen waren.  Die Person sagte, dass sich diese neue Funktion in der Praxis als nutzlos herausstellte, da Daten ohne Komprimierung zu viel Platz beanspruchten. <br><br>  Die zweite Frage lautet: Wenn es einen Cache gibt, warum nicht die bereits unkomprimierten Daten darin speichern?  Dies ist zul√§ssig - in vielen F√§llen wird es m√∂glich sein, die Notwendigkeit einer Dekompression zu beseitigen.  Und in ClickHouse gibt es einen solchen Cache - einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cache aus erweiterten Bl√∂cken</a> .  Es ist jedoch schade, aufgrund der geringen Effizienz viel RAM daf√ºr auszugeben.  Es rechtfertigt sich nur bei kleinen, aufeinanderfolgenden Anfragen, die fast dieselben Daten verwenden. <br><br>  Allgemeine √úberlegung: Daten sollten vorzugsweise immer komprimiert werden.  Brennen Sie sie immer auf eine komprimierte Festplatte.  √úber das Netzwerk auch mit Komprimierung √ºbertragen.  Meiner Meinung nach sollte die Standardkomprimierung als gerechtfertigt angesehen werden, selbst wenn die √úbertragung in ein 10-Gigabit-Netzwerk ohne √úberzeichnung innerhalb des Rechenzentrums erfolgt und die √úbertragung von Daten ohne Komprimierung zwischen Rechenzentren im Allgemeinen nicht akzeptabel ist. <br><br><h3>  Warum LZ4? </h3><br>  Warum wird LZ4 verwendet?  Ist es m√∂glich, etwas noch einfacher zu w√§hlen?  Im Prinzip ist es m√∂glich und es ist richtig und n√ºtzlich.  Aber schauen wir uns zuerst an, zu welcher Klasse von Algorithmen LZ4 geh√∂rt. <br><br>  Erstens h√§ngt es nicht vom Datentyp ab.  Wenn Sie beispielsweise im Voraus wissen, dass Sie ein Array von Ganzzahlen haben, k√∂nnen Sie eine der vielen Varianten des VarInt-Algorithmus verwenden - dies ist effizienter f√ºr die CPU.  Zweitens h√§ngt LZ4 nicht zu stark von den erforderlichen Annahmen im Datenmodell ab.  Angenommen, Sie haben eine geordnete Zeitreihe von Sensorablesungen - ein Array mit Nummern vom Typ float.  Dann k√∂nnen Sie die Deltas berechnen und dann weiter komprimieren, was im Hinblick auf das Kompressionsverh√§ltnis effizienter ist. <br><br>  Das hei√üt, LZ4 kann problemlos f√ºr alle Byte-Arrays verwendet werden - f√ºr alle Dateien.  Nat√ºrlich hat er seine eigene Spezialisierung (mehr dazu weiter unten), und in einigen F√§llen ist ihre Verwendung bedeutungslos.  Wenn Sie es jedoch als Allzweckalgorithmus bezeichnen, ist dies ein kleiner Fehler.  Beachten Sie, dass LZ4 dank des internen Ger√§ts den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RLE-</a> Algorithmus automatisch als Sonderfall implementiert. <br><br>  Eine andere Frage: Ist LZ4 der optimalste Algorithmus dieser Klasse f√ºr die Kombination von Geschwindigkeit und Kompressionskraft?  Solche Algorithmen werden als Pareto-Grenze bezeichnet - dies bedeutet, dass es keinen anderen Algorithmus gibt, der in einem Indikator streng besser und in anderen nicht schlechter ist (und sogar in einer Vielzahl von Datens√§tzen).  Es gibt Algorithmen, die schneller sind, aber ein niedrigeres Komprimierungsverh√§ltnis ergeben, und es gibt Algorithmen, die mehr komprimieren, aber gleichzeitig langsamer komprimieren oder dekomprimieren. <br><br>  Tats√§chlich ist die LZ4 keine Pareto-Grenze.  Es gibt Optionen, die etwas besser sind.  Dies ist beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LZTURBO</a> aus einem bestimmten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Powturbo</a> .  Dank der Community auf encode.ru (dem gr√∂√üten und ungef√§hr einzigen Forum f√ºr Datenkomprimierung) besteht kein Zweifel an der Zuverl√§ssigkeit der Ergebnisse.  Der Entwickler verteilt den Quellcode oder die Bin√§rdateien jedoch nicht, sondern gibt sie nur an einen begrenzten Personenkreis zum Testen oder f√ºr viel Geld weiter (wie bisher noch niemand bezahlt hat).  Es lohnt sich auch, auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lizard</a> (ehemals LZ5) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Density</a> zu achten.  Sie k√∂nnen bei der Auswahl einer bestimmten Komprimierungsstufe etwas besser als LZ4 arbeiten.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Achten Sie auch</a> auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LZSSE</a> - eine √§u√üerst interessante Sache.  Es ist jedoch besser, es nach dem Lesen dieses Artikels anzusehen. <br><br><h3>  Wie funktioniert LZ4? </h3><br>  Schauen wir uns an, wie LZ4 im Allgemeinen funktioniert.  Dies ist eine der Implementierungen des LZ77-Algorithmus: L und Z geben die Namen der Autoren (Lempel und Ziv) und 77 an - 1977, als der Algorithmus ver√∂ffentlicht wurde.  Es gibt viele andere Implementierungen: QuickLZ, FastLZ, BriefLZ, LZF, LZO sowie gzip und zip bei Verwendung niedriger Komprimierungsstufen. <br><br>  Ein mit LZ4 komprimierter Datenblock enth√§lt eine Folge von Datens√§tzen (Befehlen, Anweisungen) zweier Typen: <br><br><ol><li>  Literal: "Nehmen Sie die n√§chsten N Bytes wie sie sind und kopieren Sie sie in das Ergebnis." </li><li>  √úbereinstimmung (√úbereinstimmung): "Nehmen Sie N Bytes, die bereits durch den Versatzversatz von der aktuellen Position dekomprimiert wurden." </li></ol><br>  Ein Beispiel.  Vor der Komprimierung: <br> <code>Hello world Hello</code> <br> <br>  Nach der Komprimierung: <br> <code>literals 12 "Hello world " match 5 12</code> <br> <br>  Wenn wir einen komprimierten Block nehmen und ihn mit dem Cursor durchlaufen und diese Befehle ausf√ºhren, erhalten wir als Ergebnis die anf√§nglichen, nicht komprimierten Daten. <br><br>  Wir haben uns grob angesehen, wie die Daten dekomprimiert werden.  Der Punkt ist auch klar: Um eine Komprimierung durchzuf√ºhren, codiert der Algorithmus sich wiederholende Bytesequenzen unter Verwendung von √úbereinstimmungen. <br><br>  Klar und einige Eigenschaften.  Dieser Algorithmus ist byteorientiert - er zerlegt einzelne Bytes nicht, sondern kopiert sie nur vollst√§ndig.  Hier liegt beispielsweise der Unterschied zur Entropiecodierung.  Zum Beispiel ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zstd</a> eine Zusammensetzung aus LZ77 und Entropiecodierung. <br><br>  Beachten Sie, dass die Gr√∂√üe des komprimierten Blocks nicht zu gro√ü gew√§hlt wird, um beim Entladen nicht viel RAM zu verbrauchen.  um den Direktzugriff in einer komprimierten Datei (die aus vielen komprimierten Bl√∂cken besteht) nicht zu verlangsamen;  und manchmal, damit der Block in einen CPU-Cache passt.  Sie k√∂nnen beispielsweise 64 KB ausw√§hlen, sodass Puffer f√ºr komprimierte und nicht komprimierte Daten in den L2-Cache passen und die H√§lfte verbleibt. <br><br>  Wenn wir eine gr√∂√üere Datei komprimieren m√ºssen, verketten wir einfach die komprimierten Bl√∂cke.  Gleichzeitig ist es bequem, neben jedem komprimierten Block zus√§tzliche Daten zu platzieren - Gr√∂√üen, Pr√ºfsumme. <br><br>  Der maximale Offset f√ºr das Match ist in LZ4 - 64 Kilobyte begrenzt.  Dieser Wert wird als Schiebefenster bezeichnet.  In der Tat bedeutet dies, dass √úbereinstimmungen in einem Fenster von 64 Kilobyte Gr√∂√üe mit dem Cursor erfolgen k√∂nnen, der sich mit dem Cursor bewegt, wenn sich der Cursor vorw√§rts bewegt. <br><br>  Schauen wir uns nun an, wie Daten komprimiert werden - mit anderen Worten, wie √ºbereinstimmende Sequenzen in einer Datei gefunden werden.  Nat√ºrlich k√∂nnen Sie das Suffix trie verwenden (gro√üartig, wenn Sie davon geh√∂rt haben).  Es gibt Optionen, bei denen die l√§ngste √ºbereinstimmende Sequenz garantiert zu den vorherigen Bytes im Komprimierungsprozess geh√∂rt.  Dies wird als optimales Parsen bezeichnet und ergibt ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fast</a> besseres Komprimierungsverh√§ltnis f√ºr ein festes komprimiertes Blockformat.  Es gibt jedoch effektivere Optionen - wenn wir eine ausreichend gute √úbereinstimmung in den Daten finden, aber nicht unbedingt die l√§ngste.  Der effizienteste Weg, dies zu finden, ist die Verwendung einer Hash-Tabelle. <br><br>  Dazu gehen wir mit dem Cursor durch den Quelldatenblock und nehmen einige Bytes nach dem Cursor.  Zum Beispiel 4 Bytes.  Hash sie und f√ºge den Offset vom Anfang des Blocks in die Hash-Tabelle ein - wo diese 4 Bytes aufeinander trafen.  Der Wert 4 hei√üt min-match - mit Hilfe einer solchen Hash-Tabelle k√∂nnen wir √úbereinstimmungen von mindestens 4 Bytes finden. <br><br>  Wenn wir uns die Hash-Tabelle angesehen haben und dort bereits ein Datensatz vorhanden ist und der Versatz das Schiebefenster nicht √ºberschreitet, pr√ºfen wir, wie viele weitere Bytes nach diesen vier Bytes √ºbereinstimmen.  Vielleicht f√§llt noch viel mehr zusammen.  Es ist auch m√∂glich, dass eine Kollision in der Hash-Tabelle aufgetreten ist und nichts √ºbereinstimmt.  Dies ist normal - Sie k√∂nnen den Wert in der Hash-Tabelle einfach durch einen neuen ersetzen.  Kollisionen in der Hash-Tabelle f√ºhren einfach zu einem niedrigeren Komprimierungsverh√§ltnis, da weniger √úbereinstimmungen vorhanden sind.  √úbrigens wird diese Art von Hash-Tabelle (mit fester Gr√∂√üe und ohne Kollisionsaufl√∂sung) als Cache-Tabelle, als Cache-Tabelle bezeichnet.  Dies ist auch logisch - im Falle einer Kollision vergisst die Cache-Tabelle nur den alten Datensatz. <br><blockquote>  Die Aufgabe f√ºr den aufmerksamen Leser.  Die Daten seien ein Array von Zahlen wie UInt32 im Little-Endian-Format, das Teil einer Folge nat√ºrlicher Zahlen ist: 0, 1, 2 ... Erkl√§ren Sie, warum diese Daten bei Verwendung von LZ4 nicht komprimiert werden (die Menge der komprimierten Daten ist nicht geringer als die Menge der nicht komprimierten Daten). </blockquote><h3>  Wie man Dinge beschleunigt </h3><br>  Deshalb m√∂chte ich das Entladen von LZ4 beschleunigen.  Mal sehen, wie der Entladezyklus aussieht.  Hier ist die Schleife im Pseudocode: <br><br><pre>  w√§hrend (...)
 {
     read (input_pos, literal_length, match_length);<font></font>
<font></font>
     copy (output_pos, input_pos, literal_length);
     output_pos + = literal_length;<font></font>
<font></font>
     read (input_pos, match_offset);<font></font>
<font></font>
     copy (output_pos, output_pos - match_offset,
         match_length);
     output_pos + = match_length;
 }} </pre><br>  Das LZ4-Format ist so konzipiert, dass sich Literale und √úbereinstimmungen in einer komprimierten Datei abwechseln.  Und nat√ºrlich steht das W√∂rtliche immer an erster Stelle (denn von Anfang an hat das Match nichts zu bieten).  Daher werden ihre L√§ngen zusammen codiert. <br><br>  In der Tat ist alles etwas komplizierter.  Ein Byte wird aus der Datei gelesen und zwei Halbbytes daraus entnommen, in denen Zahlen von 0 bis 15 codiert sind. Wenn die entsprechende Zahl nicht gleich 15 ist, wird dies als L√§nge des Literals bzw. der √úbereinstimmung betrachtet.  Und wenn es 15 ist, ist die L√§nge l√§nger und es wird in den folgenden Bytes codiert.  Dann wird das n√§chste Byte gelesen und sein Wert zur L√§nge addiert.  Wenn es gleich 255 ist, fahren wir fort - wir lesen das n√§chste Byte auf die gleiche Weise. <br><br>  Beachten Sie, dass das maximale Komprimierungsverh√§ltnis f√ºr das LZ4-Format 255 nicht erreicht. Und die zweite (nutzlose) Beobachtung: Wenn Ihre Daten sehr redundant sind, erh√∂ht die Verwendung von LZ4 das Komprimierungsverh√§ltnis doppelt. <br><br>  Wenn wir die L√§nge des Literal (und dann auch die L√§nge der √úbereinstimmung und den Versatz der √úbereinstimmung) lesen, reicht es aus, um einfach zwei Speicherelemente zu kopieren, um sie zu l√∂sen. <br><br><h3>  So kopieren Sie ein St√ºck Speicher </h3><br>  Es scheint, dass Sie die <code>memcpy</code> Funktion verwenden k√∂nnen, die nur zum Kopieren von Speicherelementen dient.  Dies ist jedoch nicht optimal und immer noch falsch. <br><br>  Warum ist die Verwendung der memcpy-Funktion nicht optimal?  Weil sie: <br><br><ol><li>  befindet sich normalerweise in der libc-Bibliothek (und die libc-Bibliothek wird normalerweise dynamisch verkn√ºpft, und der memcpy-Aufruf erfolgt indirekt √ºber PLT). </li><li>  nicht im Einklang mit dem in der Kompilierungszeit unbekannten Gr√∂√üenargument, </li><li>  unternimmt gro√üe Anstrengungen, um die "Schw√§nze" eines Speicherfragments, die nicht ein Vielfaches der Gr√∂√üe eines Maschinenworts oder Registers haben, korrekt zu verarbeiten. </li></ol><br>  Der letzte Punkt ist der wichtigste.  Angenommen, wir haben die memcpy-Funktion gebeten, genau 5 Bytes zu kopieren.  Es w√§re sehr gut, 8 Bytes gleichzeitig mit zwei movq-Anweisungen zu kopieren. <br><br> <code>Hello world <font color="#0fc000">Hello</font> <font color="#ff0000">wo</font> ... <br> ^^^^^ <font color="#ff0000">^^^</font> - src <br> ^^^^^ <font color="#ff0000">^^^</font> - dst</code> <br> <br>  Aber dann werden wir drei zus√§tzliche Bytes kopieren - das hei√üt, wir werden den √ºbertragenen Puffer ins Ausland schreiben.  Die <code>memcpy</code> Funktion hat nicht das Recht, dies zu tun. Da wir einige Daten in unserem Programm √ºberschreiben, wird es eine ‚ÄûPassage‚Äú aus dem Speicher geben.  Und wenn wir an einer nicht ausgerichteten Adresse geschrieben haben, k√∂nnen sich diese zus√§tzlichen Bytes auf einer nicht zugewiesenen virtuellen Speicherseite oder auf einer Seite ohne Schreibzugriff befinden.  Dann bekommen wir Segfault (das ist gut). <br><br>  In unserem Fall k√∂nnen wir jedoch fast immer zus√§tzliche Bytes schreiben.  Wir k√∂nnen zus√§tzliche Bytes im Eingabepuffer lesen, solange sich die zus√§tzlichen Bytes vollst√§ndig darin befinden.  Unter den gleichen Bedingungen k√∂nnen wir zus√§tzliche Bytes in den Ausgabepuffer schreiben - da wir sie bei der n√§chsten Iteration trotzdem √ºberschreiben. <br><br>  Diese Optimierung ist bereits in der urspr√ºnglichen LZ4-Implementierung enthalten: <br><br><pre>  inline void copy8 (UInt8 * dst, const UInt8 * src)
 {
     memcpy (dst, src, 8);  /// Eigentlich wird memcpy hier nicht aufgerufen.
 }}<font></font>
<font></font>
 inline void wildCopy8 (UInt8 * dst, const UInt8 * src, UInt8 * dst_end)
 {
     tun
     {
         copy8 (dst, src);
         dst + = 8;
         src + = 8;
     } while (dst &lt;dst_end);
 }} </pre><br>  Um diese Optimierung nutzen zu k√∂nnen, m√ºssen Sie nur √ºberpr√ºfen, ob wir weit genug vom Rand des Puffers entfernt sind.  Dies sollte kostenlos sein, da wir bereits pr√ºfen, ob die Puffergrenzen √ºberschritten werden.  Und die Verarbeitung der letzten paar Bytes - das "Ende" der Daten - kann nach der Hauptschleife erfolgen. <br><br>  Es gibt jedoch noch einige Feinheiten.  Der Zyklus enth√§lt zwei Kopien - Literal und Match.  Bei Verwendung der Funktion LZ4_decompress_fast (anstelle von LZ4_decompress_safe) wird die Pr√ºfung jedoch einmal durchgef√ºhrt - wenn das Literal kopiert werden muss.  Beim Kopieren einer √úbereinstimmung wird keine √úberpr√ºfung durchgef√ºhrt, aber <a href="">die LZ4-Formatspezifikation</a> selbst enth√§lt Bedingungen, die es erm√∂glichen, sie zu vermeiden: <br><br><blockquote>  Die letzten 5 Bytes sind immer Literale <br>  Die letzte √úbereinstimmung muss mindestens 12 Byte vor dem Ende des Blocks beginnen. <br>  Folglich kann ein Block mit weniger als 13 Bytes nicht komprimiert werden. </blockquote><br>  Speziell ausgew√§hlte Eingabedaten k√∂nnen ein Speicherlaufwerk verursachen.  Wenn Sie die Funktion LZ4_decompress_fast verwenden, ben√∂tigen Sie Schutz vor fehlerhaften Daten.  Komprimierte Daten sollten mindestens eine Pr√ºfsumme sein.  Wenn Sie Schutz vor einem Angreifer ben√∂tigen, verwenden Sie die Funktion LZ4_decompress_safe.  Andere Optionen: Nehmen Sie eine kryptografische Hash-Funktion als Pr√ºfsumme, die jedoch mit ziemlicher Sicherheit die gesamte Leistung beeintr√§chtigt.  entweder mehr Speicher f√ºr Puffer zuweisen;  Weisen Sie entweder Speicher f√ºr Puffer mit einem separaten Aufruf von mmap zu und erstellen Sie eine Schutzseite. <br><br>  Wenn ich einen Code sehe, der Daten von 8 Bytes kopiert, frage ich sofort - warum genau 8 Bytes?  Sie k√∂nnen 16 Bytes mit SSE-Registern kopieren: <br><br><pre>  inline void copy16 (UInt8 * dst, const UInt8 * src)
 {
 #if __SSE2__
     _mm_storeu_si128 (reinterpret_cast &lt;__ m128i *&gt; (dst),
         _mm_loadu_si128 (reinterpret_cast &lt;const __m128i *&gt; (src)));
 #else
     memcpy (dst, src, 16);
 #endif
 }}<font></font>
<font></font>
 inline void wildCopy16 (UInt8 * dst, const UInt8 * src, UInt8 * dst_end)
 {
     tun
     {
         copy16 (dst, src);
         dst + = 16;
         src + = 16;
     } while (dst &lt;dst_end);
 }} </pre><br>  Das Kopieren von 32 Byte f√ºr AVX und 64 Byte f√ºr AVX-512 funktioniert √§hnlich.  Au√üerdem k√∂nnen Sie den Zyklus mehrmals erweitern.  Wenn Sie sich jemals angesehen haben, wie <code>memcpy</code> implementiert ist, dann ist dies genau der <code>memcpy</code> Ansatz.  (√úbrigens wird der Compiler in diesem Fall die Schleife weder erweitern noch vektorisieren. Dies erfordert das Einf√ºgen umst√§ndlicher √úberpr√ºfungen.) <br><br>  Warum wird dies in der urspr√ºnglichen LZ4-Implementierung nicht durchgef√ºhrt?  Erstens ist es nicht offensichtlich, ob dies besser oder schlechter ist.  Das Ergebnis h√§ngt von der Gr√∂√üe der Fragmente ab, die kopiert werden m√ºssen.  Pl√∂tzlich sind sie alle kurz und zus√§tzliche Arbeit wird nutzlos sein?  Und zweitens werden die Bedingungen im LZ4-Format zerst√∂rt, die es Ihnen erm√∂glichen, unn√∂tigen Brunch in der inneren Schleife zu vermeiden. <br><br>  Trotzdem werden wir diese Option vorerst ber√ºcksichtigen. <br><br><h3>  Tricky Kopie </h3><br>  Zur√ºck zur Frage - ist es immer m√∂glich, Daten auf diese Weise zu kopieren?  Angenommen, wir m√ºssen eine √úbereinstimmung kopieren, dh ein St√ºck Speicher aus dem Ausgabepuffer, der sich in einem gewissen Versatz hinter dem Cursor befindet, an die Position dieses Cursors kopieren. <br><br>  Stellen Sie sich einen einfachen Fall vor: Sie m√ºssen 5 Bytes mit Offset 12 kopieren: <br><br> <code><font color="#0fc000">Hello</font> world ........... <br> ^^^^^ - src <br> ^^^^^ - dst <br> <br> Hello world <font color="#0fc000">Hello</font> <font color="#a8a8a8">wo</font> ... <br> ^^^^^ - src <br> ^^^^^ - dst</code> <br> <br>  Es gibt jedoch einen komplizierteren Fall - wenn wir ein St√ºck Speicher kopieren m√ºssen, dessen L√§nge gr√∂√üer als der Versatz ist.  Das hei√üt, es zeigt teilweise Daten an, die noch nicht in den Ausgabepuffer geschrieben wurden. <br><br>  Kopieren Sie 10 Bytes mit Offset 3: <br><br> <code><font color="#0fc000">abc</font> ............. <br> ^^^^^^^^^^ - src <br> ^^^^^^^^^^ - dst <br> <br> abc <font color="#0fc000">abcabcabca</font> ... <br> ^^^^^^^^^^ - src <br> ^^^^^^^^^^ - dst</code> <br> <br>  W√§hrend des Komprimierungsprozesses haben wir alle Daten, und eine solche √úbereinstimmung kann durchaus gefunden werden.  Die Funktion <code>memcpy</code> eignet sich nicht zum Kopieren: Sie unterst√ºtzt nicht den Fall, dass sich die Bereiche der Speicherfragmente √ºberschneiden.  Die <code>memmove</code> Funktion <code>memmove</code> auch nicht geeignet, da das Speicherfragment, von dem die Daten <code>memmove</code> werden sollen, noch nicht vollst√§ndig initialisiert ist.  Sie m√ºssen kopieren, als w√ºrden wir byteweise kopieren. <br><br><pre>  op [0] = match [0];
 op [1] = match [1];
 op [2] = match [2];
 op [3] = match [3];
 ... </pre><br><br>  So funktioniert es: <br><br> <code><font color="#0fc000">a</font> bc <font color="#0fc000">a</font> ............ <br> ^ - src <br> ^ - dst <br> <br> a <font color="#0fc000">b</font> ca <font color="#0fc000">b</font> ........... <br> ^ - src <br> ^ - dst <br> <br> ab <font color="#0fc000">c</font> ab <font color="#0fc000">c</font> .......... <br> ^ - src <br> ^ - dst <br> <br> abc <font color="#0fc000">a</font> bc <font color="#0fc000">a</font> ......... <br> ^ - src <br> ^ - dst <br> <br> abca <font color="#0fc000">b</font> ca <font color="#0fc000">b</font> ........ <br> ^ - src <br> ^ - dst</code> <br> <br>  Das hei√üt, wir m√ºssen eine sich wiederholende Sequenz erstellen.  In der urspr√ºnglichen LZ4-Implementierung wurde √ºberraschend unverst√§ndlicher Code daf√ºr geschrieben: <br><br><pre>  const unsigned dec32table [] = {0, 1, 2, 1, 4, 4, 4, 4};
 const int dec64table [] = {0, 0, 0, -1, 0, 1, 2, 3};<font></font>
<font></font>
 const int dec64 = dec64table [Offset];
 op [0] = match [0];
 op [1] = match [1];
 op [2] = match [2];
 op [3] = match [3];
 match + = dec32table [offset];
 memcpy (op + 4, match, 4);
 match - = dec64; </pre><br>  Wir kopieren die ersten 4 Bytes byteweise, verschieben sie um eine magische Zahl, kopieren die n√§chsten 4 Bytes als Ganzes und verschieben den Zeiger so, dass er mit einer anderen magischen Zahl √ºbereinstimmt.  Der Code-Autor ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jan Collet</a> ) hat aus irgendeinem l√§cherlichen Grund vergessen, einen Kommentar zu hinterlassen, was dies bedeutet.  Dar√ºber hinaus sind Variablennamen verwirrend.  Beide hei√üen dec ... table, aber wir addieren eine davon und subtrahieren die andere.  Au√üerdem ist ein anderer nicht signiert und der andere ist int.  Es lohnt sich jedoch, Tribut zu zollen: Erst k√ºrzlich hat der Autor diesen Platz im Code verbessert. <br><br>  So funktioniert es tats√§chlich.  Kopieren Sie die ersten 4 Bytes: <br><br> <code>abc <font color="#0fc000">abca</font> ......... <br> ^^^^ - src <br> ^^^^ - dst</code> <br> <br>  Jetzt k√∂nnen Sie 4 Bytes gleichzeitig kopieren: <br><br> <code>abcabca <font color="#0fc000">bcab</font> ..... <br> ^^^^ - src <br> ^^^^ - dst</code> <br> <br>    ,  8  : <br><br> <code>abcabcabcab <font color="#0fc000">cabcabca</font> ..... <br> ^^^^^^^^ - src <br> ^^^^^^^^ - dst</code> <br> <br>     ,      ‚Äî   .  Folgendes ist passiert: <br><br><pre> inline void copyOverlap8(UInt8 * op, const UInt8 *&amp; match, const size_t offset)
 {<font></font>
    /// 4 % n.<font></font>
    /// Or if 4 % n is zero, we use n.<font></font>
    /// It gives equivalent result, but is better CPU friendly for unknown reason.<font></font>
    static constexpr int shift1[] = { 0, 1, 2, 1, 4, 4, 4, 4 };<font></font>
<font></font>
    /// 8 % n - 4 % n<font></font>
    static constexpr int shift2[] = { 0, 0, 0, 1, 0, -1, -2, -3 };<font></font>
<font></font>
    op[0] = match[0];<font></font>
    op[1] = match[1];<font></font>
    op[2] = match[2];<font></font>
    op[3] = match[3];<font></font>
<font></font>
    match += shift1[offset];<font></font>
    memcpy(op + 4, match, 4);<font></font>
    match += shift2[offset];<font></font>
 }} </pre><br> ,  ,   . ,     ,     ‚Äî   16 . <br><br>    ¬´ ¬ª    ,     ( <code>offset &lt; 16</code>   ,  <code>offset &lt; 8</code> ).  ()     16-   : <br><br><pre> inline void copyOverlap16(UInt8 * op, const UInt8 *&amp; match, const size_t offset)
 {<font></font>
    /// 4 % n.<font></font>
    static constexpr int shift1[]<font></font>
        = { 0, 1, 2, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };<font></font>
<font></font>
    /// 8 % n - 4 % n<font></font>
    static constexpr int shift2[]<font></font>
        = { 0, 0, 0, 1, 0, -1, -2, -3, -4, 4, 4, 4, 4, 4, 4, 4 };<font></font>
<font></font>
    /// 16 % n - 8 % n<font></font>
    static constexpr int shift3[]<font></font>
        = { 0, 0, 0, -1, 0, -2, 2, 1, 8, -1, -2, -3, -4, -5, -6, -7 };<font></font>
<font></font>
    op[0] = match[0];<font></font>
    op[1] = match[1];<font></font>
    op[2] = match[2];<font></font>
    op[3] = match[3];<font></font>
<font></font>
    match += shift1[offset];<font></font>
    memcpy(op + 4, match, 4);<font></font>
    match += shift2[offset];<font></font>
    memcpy(op + 8, match, 8);<font></font>
    match += shift3[offset];<font></font>
 }} </pre><br>       ?  ,        SIMD-,       16 ,         ( 1  15). ,   ,      . <br><br>    ‚Äî   <code>pshufb</code> (  packed shuffle bytes)    SSSE3 (  S).    16- .      .   ‚Äî ¬´¬ª:       0  15 ‚Äî    ,       . ,      127 ‚Äî     . <br><br>  Hier ist ein Beispiel: <br><br><pre> xmm0: abc.............<font></font>
xmm1: 0120120120120120<font></font>
<font></font>
pshufb %xmm1, %xmm0<font></font>
<font></font>
xmm0: abcabcabcabcabca </pre><br>           ‚Äî      !      : <br><br><pre> inline void copyOverlap16Shuffle(UInt8 * op, const UInt8 *&amp; match, const size_t offset)
 {<font></font>
#ifdef __SSSE3__<font></font>
<font></font>
    static constexpr UInt8 __attribute__((__aligned__(16))) masks[] =<font></font>
     {<font></font>
        0, 1, 2, 1, 4, 1, 4, 2, 8, 7, 6, 5, 4, 3, 2, 1, /* offset = 0, not used as mask, but for shift amount instead */<font></font>
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* offset = 1 */<font></font>
        0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,<font></font>
        0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0,<font></font>
        0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3,<font></font>
        0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0,<font></font>
        0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3,<font></font>
        0, 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0, 1,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3, 4, 5, 6,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0, 1, 2,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0, 1,<font></font>
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0,<font></font>
     };<font></font>
<font></font>
    _mm_storeu_si128(reinterpret_cast&lt;__m128i *&gt;(op),<font></font>
        _mm_shuffle_epi8(<font></font>
            _mm_loadu_si128(reinterpret_cast&lt;const __m128i *&gt;(match)),<font></font>
            _mm_load_si128(reinterpret_cast&lt;const __m128i *&gt;(masks) + offset)));<font></font>
<font></font>
    match += masks[offset];<font></font>
<font></font>
#else<font></font>
    copyOverlap16(op, match, offset);<font></font>
 #endif
 }} </pre><br>  <code>_mm_shuffle_epi8</code> ‚Äî  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">intrinsic</a> ,    <code>pshufb</code> . <br><br>          ,    ?  SSSE3 ‚Äî    ,   2006 .  AVX2  ,      32 ,      16- .     packed shuffle bytes,  vector permute bytes ‚Äî  ,    .  AVX-512 VBMI    ,    64 ,        .      ARM NEON ‚Äî   vtbl (vector table lookup),     8 . <br><br>  ,    <code>pshufb</code>  64- MMX-,   8 .         . ,        ,   16  (  ). <br><br>   Highload++ Siberia         ,    8          (  ) ‚Äî       ! <br><br><h3>    if </h3><br> ,    ,   16 .         ? <br><br>  ,       .      ,           ,  ,         .    ,     . <br><br> ,    . , ,    ,      65 536 .        65 536    .           , ,  65 551 .  ,  ,       96   128  ‚Äî     .     ,           ¬´¬ª      mmap    (     madvice).      - page faults.         ,    . <br><br><h3>   ? </h3><br> ,    ,     : <br><br><ol><li>   16   8. </li><li>  shuffle-   <code>offset &lt; 16</code> . </li><li>    if. </li></ol><br>              . <br><br>  Beispiel 1: <br> Xeon E2650v2,  .,  AppVersion. <br> reference: 1.67 GB/sec. <br> 16 bytes, shuffle: 2.94 GB/sec ( 76% ). <br><br>  Beispiel 2: <br> Xeon E2650v2,  .,  ShowsSumPosition. <br> reference: 2.30 GB/sec. <br> 16 bytes, shuffle: 1.91 GB/sec ( 20% ). <br><br>   ,         .     ,    .   - ,   .   ,      .     ‚Äî       16 .  :    ,     ,   . <br><br>   ,     C++      :  8-  16-  ;     shuffle-. <br><br><pre> template &lt;size_t copy_amount, bool use_shuffle&gt;<font></font>
void NO_INLINE decompressImpl(<font></font>
     const char * const source,<font></font>
     char * const dest,<font></font>
     size_t dest_size) </pre><br>        ,         shuffle  .     ,   : <br><br><pre> sudo echo 'performance' | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor<font></font>
kill -STOP $(pidof firefox) $(pidof chromium) </pre><br>        ¬´¬ª  (c  Xeon E5645),           ,    . ,         ,    .    ,    shuffle-,   ,      16- . <br><br>         : <br><br><pre> sudo kill -STOP $(pidof python) $(pidof perl) $(pgrep -u skynet) $(pidof cqudp-client) </pre><br>    .    thermal throttling  power capping. <br><br><h3>     </h3><br> ,      ,        .         ,         ,    .       .       , ,     .   : ClickHouse      ,       ,         .       ,             (       ‚Äî  ?).      . <br><br>      ,    ,      .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">¬´ ¬ª</a> .   ,      ,           ,    . <br><br>      ,   .        .       -        .             ‚Äî   ClickHouse      64 . ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   .) <br><br>  ,     ¬´ ¬ª, ,    .      ,     ,   ,   -   .           .            ,          ,    .      . <br><br>         ,          ,       .    ¬´¬ª     ,    .     ,        .    Thompson Sampling. <br><br> ,   ,    .  ‚Äî      :  ,  .          .     ,     .       ,           C++.     ‚Äî ,     -   ,   ;     . <br><br>     ?      ,       .    . -,      ,         . -,  ,   ,   ¬´¬ª . <br><br> ,  ,           Thompson Sampling ‚Äî   (   ,        ).   ,         ,         - ,     ,      .           ,     . <br><br>   ,   ¬´¬ª .   ,     ,        ¬´¬ª,     .      ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> .    ,     ,       . <br><br>       ,   ,    ,    ,   ¬´¬ª: <br><br><pre> /// For better convergence, we don't use proper estimate of stddev.<font></font>
/// We want to eventually separate between two algorithms even in case<font></font>
/// when there is no statistical significant difference between them.<font></font>
double sigma() const<font></font>
 {<font></font>
    return mean() / sqrt(adjustedCount());<font></font>
 }}<font></font>
<font></font>
double sample(pcg64 &amp; rng) const<font></font>
 {
     ...<font></font>
    return std::normal_distribution&lt;&gt;(mean(), sigma())(rng);<font></font>
 }} </pre><br>    ,       ‚Äî    memory latencies. <br><br>   ,         ,       ‚Äî    LZ4    . <br><br>  ,    : <br> ‚Äî reference (baseline):  LZ4   ; <br> ‚Äî variant 0:   8 ,   shuffle; <br> ‚Äî variant 1:   8 ,  shuffle; <br> ‚Äî variant 2:   16 ,   shuffle; <br> ‚Äî variant 3:   16 ,  shuffle; <br> ‚Äî ¬´¬ª ,            . <br><br><h3>    CPU </h3><br>       CPU,    ,  .  ,   CPU   ? <br><br>         ClickHouse   ,  256    100    ( 256  ).  ,  CPU  ,      .      CPU: <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5-2650 v2 @ 2.60GHz <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5-2660 v4 @ 2.00GHz <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5-2660 0 @ 2.20GHz <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5645 @ 2.40GHz <br> ‚Äî Intel Xeon E312xx (Sandy Bridge) <br> ‚Äî AMD Opteron(TM) Processor 6274 <br> ‚Äî AMD Opteron(tm) Processor 6380 <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5-2683 v4 @ 2.10GHz <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5530 @ 2.40GHz <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5440 @ 2.83GHz <br> ‚Äî Intel¬Æ Xeon¬Æ CPU E5-2667 v2 @ 3.30GHz <br><br>    ‚Äî ,   R&amp;D: <br> ‚Äî AMD EPYC 7351 16-Core Processor ‚Äî    AMD. <br> ‚Äî Cavium ThunderX2 ‚Äî     x86,  AArch64.    SIMD-   .    224   56  . <br><br>  13 ,        256   6  (reference, 0, 1, 2, 3, adaptive),    10 ,   .  199 680 ,    . <br><br> ,    CPU  .         :      LZ4    (   ‚Äî  ).  ,  Cavium   .       ClickHouse,   ¬´¬ª Xeon E5-2650 v2         ,      ,   ClickHouse    x86. <br><br><pre> ‚îå‚îÄcpu‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄref‚îÄ‚î¨‚îÄadapt‚îÄ‚î¨‚îÄ‚îÄmax‚îÄ‚î¨‚îÄbest‚îÄ‚î¨‚îÄadapt_boost‚îÄ‚î¨‚îÄmax_boost‚îÄ‚î¨‚îÄadapt_over_max‚îÄ‚îê<font></font>
‚îÇ E5-2667 v2 @ 3.30GHz ‚îÇ 2.81 ‚îÇ 3.19 ‚îÇ 3.15 ‚îÇ 3 ‚îÇ 1.14 ‚îÇ 1.12 ‚îÇ 1.01 ‚îÇ<font></font>
‚îÇ E5-2650 v2 @ 2.60GHz ‚îÇ 2.5 ‚îÇ 2.84 ‚îÇ 2.81 ‚îÇ 3 ‚îÇ 1.14 ‚îÇ 1.12 ‚îÇ 1.01 ‚îÇ<font></font>
‚îÇ E5-2683 v4 @ 2.10GHz ‚îÇ 2.26 ‚îÇ 2.63 ‚îÇ 2.59 ‚îÇ 3 ‚îÇ 1.16 ‚îÇ 1.15 ‚îÇ 1.02 ‚îÇ<font></font>
‚îÇ E5-2660 v4 @ 2.00GHz ‚îÇ 2.15 ‚îÇ 2.49 ‚îÇ 2.46 ‚îÇ 3 ‚îÇ 1.16 ‚îÇ 1.14 ‚îÇ 1.01 ‚îÇ<font></font>
‚îÇ AMD EPYC 7351 ‚îÇ 2.03 ‚îÇ 2.44 ‚îÇ 2.35 ‚îÇ 3 ‚îÇ 1.20 ‚îÇ 1.16 ‚îÇ 1.04 ‚îÇ<font></font>
‚îÇ E5-2660 0 @ 2.20GHz ‚îÇ 2.13 ‚îÇ 2.39 ‚îÇ 2.37 ‚îÇ 3 ‚îÇ 1.12 ‚îÇ 1.11 ‚îÇ 1.01 ‚îÇ<font></font>
‚îÇ E312xx (Sandy Bridge) ‚îÇ 1.97 ‚îÇ 2.2 ‚îÇ 2.18 ‚îÇ 3 ‚îÇ 1.12 ‚îÇ 1.11 ‚îÇ 1.01 ‚îÇ<font></font>
‚îÇ E5530 @ 2.40GHz ‚îÇ 1.65 ‚îÇ 1.93 ‚îÇ 1.94 ‚îÇ 3 ‚îÇ 1.17 ‚îÇ 1.18 ‚îÇ 0.99 ‚îÇ<font></font>
‚îÇ E5645 @ 2.40GHz ‚îÇ 1.65 ‚îÇ 1.92 ‚îÇ 1.94 ‚îÇ 3 ‚îÇ 1.16 ‚îÇ 1.18 ‚îÇ 0.99 ‚îÇ<font></font>
‚îÇ AMD Opteron 6380 ‚îÇ 1.47 ‚îÇ 1.58 ‚îÇ 1.56 ‚îÇ 1 ‚îÇ 1.07 ‚îÇ 1.06 ‚îÇ 1.01 ‚îÇ<font></font>
‚îÇ AMD Opteron 6274 ‚îÇ 1.15 ‚îÇ 1.35 ‚îÇ 1.35 ‚îÇ 1 ‚îÇ 1.17 ‚îÇ 1.17 ‚îÇ 1 ‚îÇ<font></font>
‚îÇ E5440 @ 2.83GHz ‚îÇ 1.35 ‚îÇ 1.33 ‚îÇ 1.42 ‚îÇ 1 ‚îÇ 0.99 ‚îÇ 1.05 ‚îÇ 0.94 ‚îÇ<font></font>
‚îÇ Cavium ThunderX2 ‚îÇ 0.84 ‚îÇ 0.87 ‚îÇ 0.87 ‚îÇ 0 ‚îÇ 1.04 ‚îÇ 1.04 ‚îÇ 1 ‚îÇ<font></font>
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò </pre><br> ref, adapt, max ‚Äî       (,            ). best ‚Äî      ,  0  3. adapt_boost ‚Äî        baseline. max_boost ‚Äî          baseline. adapt_over_max ‚Äî         . <br><br>  ,    x86      12‚Äì20%.   ARM    4%,   ,         .  ,        ¬´¬ª              Intel. <br><br><h3>  Schlussfolgerungen </h3><br>       . ,   LZ4     12‚Äì20%,            .           .      ,         . <br><br>    ,     ,    ¬´¬ª ,    ZStandard level 1  LZ4:      IO    . <br><br>           ‚Äî ,      .          ,       . <br><br>    :         . LZ4    ,   Lizard, Density  LZSSE  ,    . ,    LZ4      LZSSE  ClickHouse. <br><br>       LZ4 :         .          :      ,   .             . ,   inc-  dec-   <a href=""></a> .  ,           12‚Äì15%     32 ,    16,   .       32  ‚Äî     ,     <a href=""> </a> . <br><br>       ,  ,          page cache  userspace (   mmap,    O_DIRECT  userspace page cache ‚Äî     ),      - (  CityHash128  CRC32-C,    HighwayHash, FARSH  XXH3).         ,       . <br><br>   ,     master,            .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  HighLoad++ Siberia,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452778/">https://habr.com/ru/post/de452778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452766/index.html">Progressive Streaming-Technologie oder das Ansehen von 4k-Videos √ºber das Netzwerk ohne Friese</a></li>
<li><a href="../de452768/index.html">So gestalten Sie ein Produkt, wenn Sie sich f√ºr den Eintritt in den ausl√§ndischen Markt entscheiden</a></li>
<li><a href="../de452772/index.html">5 Fortgeschrittene Go-Testtechniken</a></li>
<li><a href="../de452774/index.html">Dell XPS 13 9380: zuverl√§ssiger und sehr kompakter Laptop f√ºr ernsthafte Gesch√§fte</a></li>
<li><a href="../de452776/index.html">N.M.D. (Nicht mein Gesch√§ft)</a></li>
<li><a href="../de452780/index.html">Mobius 2019 Piter: Kostenloses Live-Streaming und alles andere</a></li>
<li><a href="../de452788/index.html">Der Kampf um Qualit√§t in Webanwendungen, Depressionen, Drachen und Westeros</a></li>
<li><a href="../de452790/index.html">OpenCV 4.0 und 4.1 - was ist neu?</a></li>
<li><a href="../de452792/index.html">Solid State SSD-√úberpr√ºfung f√ºr Unternehmensbenutzer Kingston DC500R</a></li>
<li><a href="../de452794/index.html">√úber die Lokalisierung von Produkten. Teil eins: Wo soll ich anfangen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>