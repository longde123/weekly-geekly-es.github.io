<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëéüèΩ üëáüèΩ üèõÔ∏è Uso de cuentas inteligentes de Waves: de subastas a programas de bonificaci√≥n ‚úäüèæ üë©üèΩ‚Äçüíª ‚è∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Blockchain a menudo se asocia solo con criptomonedas, pero el alcance de la tecnolog√≠a DLT es mucho m√°s amplio. Una de las √°reas m√°s prometedoras para...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uso de cuentas inteligentes de Waves: de subastas a programas de bonificaci√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/442238/"><img src="https://habrastorage.org/webt/pi/sa/8g/pisa8gy_wbapc-kdf-n026wjuko.png" alt="imagen"><br><br>  <i>Blockchain a menudo se asocia solo con criptomonedas, pero el alcance de la tecnolog√≠a DLT es mucho m√°s amplio.</i>  <i>Una de las √°reas m√°s prometedoras para usar blockchain es un contrato inteligente que se ejecuta autom√°ticamente y no requiere confianza entre las partes que lo concluyeron.</i> <i><br></i> <br>  <b>RIDE - lenguaje para contratos inteligentes</b> <br><br>  Waves ha desarrollado un lenguaje especial para contratos inteligentes: RIDE.  Su documentaci√≥n completa est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Y aqu√≠, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un art√≠culo sobre este tema</a> sobre Habr√©. <br><br>  El contrato en RIDE es un predicado y devuelve "verdadero" o "falso" en la salida.  En consecuencia, una transacci√≥n se escribe en la cadena de bloques o se rechaza.  Un contrato inteligente garantiza plenamente el cumplimiento de las condiciones especificadas.  La generaci√≥n de transacciones a partir de un contrato en RIDE actualmente no es posible. <br><a name="habracut"></a><br>  Hoy en d√≠a, hay dos tipos de contratos inteligentes de Waves: cuentas inteligentes y activos inteligentes.  Una cuenta inteligente es una cuenta de usuario normal, pero se configura un script que controla todas las transacciones.  Un script de cuenta inteligente podr√≠a verse as√≠: <br><br><pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> | <span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  tx es una transacci√≥n procesada que permitimos usar el mecanismo de coincidencia de patrones solo si no es una transacci√≥n de transferencia.  La coincidencia de patrones RIDE se utiliza para verificar el tipo de transacci√≥n.  En el script de la cuenta inteligente, se pueden procesar todos los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tipos de transacciones</a> existentes. <br><br>  Adem√°s, se pueden declarar variables en el script, se pueden utilizar construcciones "if-then-else" y otros m√©todos para la verificaci√≥n completa de las condiciones.  Para que los contratos tengan finalizaci√≥n comprobable y complejidad (costo), que es f√°cil de predecir antes del inicio del contrato, RIDE no contiene bucles y operadores como jump. <br><br>  Entre otras caracter√≠sticas de las cuentas de Waves est√° la presencia de un "estado", es decir, el estado de la cuenta.  Se puede escribir un n√∫mero infinito de pares (clave, valor) en el estado de la cuenta mediante transacciones de datos (DataTransaction).  Adem√°s, esta informaci√≥n se puede procesar tanto a trav√©s de la API REST como directamente en el contrato inteligente. <br><br>  Cada transacci√≥n puede contener una serie de pruebas, en las que puede ingresar la firma del participante, la identificaci√≥n de la transacci√≥n necesaria, etc. <br><br>  Trabajar con RIDE a trav√©s del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IDE le</a> permite ver la forma compilada del contrato (si est√° compilado), crear nuevas cuentas y establecer scripts para √©l, as√≠ como enviar transacciones a trav√©s de la l√≠nea de comando. <br><br>  Para un ciclo completo, incluida la creaci√≥n de una cuenta, la instalaci√≥n de un contrato inteligente y el env√≠o de transacciones, tambi√©n puede usar la biblioteca para interactuar con la API REST (por ejemplo, C #, C, Java, JavaScript, Python, Rust, Elixir).  Para comenzar a trabajar con el IDE, simplemente haga clic en el bot√≥n NUEVO. <br><br>  Las posibilidades de usar contratos inteligentes son amplias: desde la prohibici√≥n de transacciones a ciertas direcciones (la "lista negra") hasta dApps complejas. <br><br>  <i>Ahora veamos ejemplos espec√≠ficos del uso de contratos inteligentes en los negocios: durante las subastas, los seguros y la creaci√≥n de programas de lealtad.</i> <i><br></i> <br>  <b>Subastas</b> <br><br>  Una de las condiciones para una subasta exitosa es la transparencia: los licitantes deben asegurarse de que sea imposible manipular las ofertas.  Esto se puede lograr gracias a blockchain, donde los datos sin cambios en todas las apuestas y el momento en que se realizaron estar√°n disponibles para todos los participantes. <br><br>  En la cadena de bloques Waves, las ofertas se pueden registrar en el estado de la cuenta de la subasta a trav√©s de DataTransaction. <br><br>  Tambi√©n puede establecer la hora de inicio y finalizaci√≥n de la subasta utilizando n√∫meros de bloque: la frecuencia de generaci√≥n de bloques en la cadena de bloques Waves es de aproximadamente <b>60</b> segundos. <br><br>  <i><b>1. Subasta de precios en alza en ingl√©s</b></i> <br><br>  Participantes en la subasta en ingl√©s, compitiendo entre s√≠.  Cada nueva apuesta debe exceder la anterior.  La subasta finaliza cuando ya no hay m√°s ganas de superar la √∫ltima oferta.  En este caso, el mejor postor debe proporcionar la cantidad declarada. <br><br>  Tambi√©n hay una opci√≥n de subasta en la que el vendedor establece el precio m√≠nimo para el lote, y el precio final debe excederlo.  De lo contrario, el lote permanece sin vender. <br><br>  En este ejemplo, estamos trabajando con una cuenta especialmente creada para la subasta.  La duraci√≥n de la subasta es de 3000 bloques, y el precio inicial del lote es de 0.001 ONDAS.  Un participante puede hacer una apuesta enviando una DataTransaction con la clave de "precio" y el valor de su oferta, en las pruebas de transacci√≥n, debe agregar la clave p√∫blica y la firma del remitente. <br><br>  El precio de la nueva apuesta debe ser m√°s alto que el precio actual de esta clave, y el participante debe tener al menos [new_state + comisi√≥n] tokens en la cuenta.  La direcci√≥n del postor debe ingresarse en el campo "remitente" en DataTransaction, y la altura actual del bloque de la oferta debe estar dentro del per√≠odo de la subasta. <br><br>  Si al final de la subasta el postor ha establecido el precio m√°s alto, puede enviar ExchangeTransaction para pagar el lote correspondiente al precio indicado y al par de divisas. <br><br><pre> <code class="scala hljs">let startHeight = <span class="hljs-number"><span class="hljs-number">384120</span></span> let finishHeight = startHeight + <span class="hljs-number"><span class="hljs-number">3000</span></span> let startPrice = <span class="hljs-number"><span class="hljs-number">100000</span></span> #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let token = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; #,      let currentPrice = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #    then extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> startPrice #    let newPrice = extract(getInteger(d.data, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #       let pk = d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) let priceIsBigger = newPrice &gt; currentPrice let fee = <span class="hljs-number"><span class="hljs-number">700000</span></span> let hasMoney = wavesBalance(address) + fee &gt;= newPrice let correctFields = size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; extract(getString(d.data, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>)) == toBase58String(address.bytes) startHeight &lt;= height &amp;&amp; height &lt;= finishHeight &amp;&amp; priceIsBigger &amp;&amp; hasMoney &amp;&amp; correctFields &amp;&amp; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o : <span class="hljs-type"><span class="hljs-type">Order</span></span> =&gt; #       let pk = o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) let senderIsWinner = address == addressFromString(extract(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>))) #,    ,    let correctAssetPair = o.assetPair.amountAsset == token &amp;&amp; ! isDefined(o.assetPair.priceAsset) let correctAmount = o.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> let correctPrice = o.price == extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) height &gt; finishHeight &amp;&amp; senderIsWinner &amp;&amp; correctAssetPair &amp;&amp; correctAmount &amp;&amp; correctPrice &amp;&amp; sigVerify(o.bodyBytes, o.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <i><b>2. Subasta holandesa de precios a la baja</b></i> <br><br>  En una subasta holandesa, inicialmente se ofrece un lote a un precio superior al que el comprador est√° dispuesto a pagar.  El precio se reduce paso a paso hasta que uno de los participantes acepta comprar el lote al precio actual. <br><br>  En este ejemplo, utilizamos las mismas constantes que en la anterior, as√≠ como el paso de precio al bajar delta.  El gui√≥n de la cuenta comprueba si el participante es realmente el primero en apostar.  En las pruebas de transacci√≥n, debe agregar la clave p√∫blica y la firma del remitente. De lo contrario, la cadena de bloques no acepta DataTransaction. <br><br><pre> <code class="scala hljs">let startHeight = <span class="hljs-number"><span class="hljs-number">384120</span></span> let finishHeight = startHeight + <span class="hljs-number"><span class="hljs-number">3000</span></span> let startPrice = <span class="hljs-number"><span class="hljs-number">100000000</span></span> let delta = <span class="hljs-number"><span class="hljs-number">100</span></span> #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let token = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; let currentPrice = startPrice - delta * (height - startHeight) #   -  <span class="hljs-string"><span class="hljs-string">"price"</span></span> let newPrice = extract(getInteger(d.data, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #       let pk = d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) let correctFields = extract(getString(d.data, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>)) == toBase58String(address.bytes) &amp;&amp; size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; newPrice == currentPrice #,         <span class="hljs-string"><span class="hljs-string">"sender"</span></span> let noBetsBefore = !isDefined(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>)) let fee = <span class="hljs-number"><span class="hljs-number">700000</span></span> let hasMoney = wavesBalance(address) - fee &gt;= newPrice startHeight &lt;= height &amp;&amp; height &lt;= finishHeight &amp;&amp; noBetsBefore &amp;&amp; hasMoney &amp;&amp; correctFields &amp;&amp; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o : <span class="hljs-type"><span class="hljs-type">Order</span></span> =&gt; #       let pk = o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) #,           sender let senderIsWinner = address == addressFromString(extract(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>))) #,  mount   ,   - - waves let correctAssetPair = o.assetPair.amountAsset == token &amp;&amp; ! isDefined(o.assetPair.priceAsset) let correctAmount = o.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> let correctPrice = o.price == extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) height &gt; finishHeight &amp;&amp; senderIsWinner &amp;&amp; correctAssetPair &amp;&amp; correctAmount &amp;&amp; correctPrice &amp;&amp; sigVerify(o.bodyBytes, o.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], o.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br>  <i><b>3. Subasta de pago total</b></i> <br><br>  "Todo pago": una subasta, en la que todos los participantes pagan la oferta, pagan, independientemente de qui√©n gane el lote.  Cada nuevo participante paga la apuesta, y el participante que ha realizado la apuesta m√°xima gana el lote. <br><br>  En nuestro ejemplo, cada participante de la subasta hace una oferta a trav√©s de DataTransaction con (clave, valor) * = ("ganador", direcci√≥n), ("precio", precio).  Dicha DataTransaction se aprueba solo si para este participante ya existe una TransferTransaction con su firma y su tasa es m√°s alta que todas las anteriores.  La subasta contin√∫a hasta llegar al final. <br><br><pre> <code class="scala hljs">let startHeight = <span class="hljs-number"><span class="hljs-number">1000</span></span> let endHeight = <span class="hljs-number"><span class="hljs-number">2000</span></span> let token = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d: <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; #   -  <span class="hljs-string"><span class="hljs-string">"price"</span></span> let newPrice = extract(getInteger(d.data, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #       let pk = d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>] let address = addressFromPublicKey(pk) #        let proofTx = extract(transactionById(d.proofs[<span class="hljs-number"><span class="hljs-number">2</span></span>])) height &gt; startHeight &amp;&amp; height &lt; endHeight &amp;&amp; size(d.data) == <span class="hljs-number"><span class="hljs-number">2</span></span> #,   ,    ,   ,    &amp;&amp; extract(getString(d.data, <span class="hljs-string"><span class="hljs-string">"winner"</span></span>)) == toBase58String(address.bytes) &amp;&amp; newPrice &gt; extract(getInteger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"price"</span></span>)) #,    &amp;&amp; sigVerify(d.bodyBytes, d.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], d.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) #  ,    &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> proofTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> tr : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; tr.sender == address &amp;&amp; tr.amount == newPrice <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) || ( height &gt; endHeight &amp;&amp; extract(getString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"winner"</span></span>)) == toBase58String((addressFromRecipient(t.recipient)).bytes) &amp;&amp; t.assetId == token &amp;&amp; t.amount == <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre> <br>  <b>Seguros / Crowdfunding</b> <br><br>  Considere una situaci√≥n en la que necesita asegurar los activos de los usuarios de p√©rdidas financieras.  Por ejemplo, el usuario desea obtener una garant√≠a de que si el token se deprecia, podr√° devolver el monto total pagado por estos tokens y est√° listo para pagar una cantidad razonable de seguro. <br><br>  Para implementar esto, debe emitir "tokens de seguro".  Luego, se instala un script en la cuenta del titular de la p√≥liza que le permite ejecutar solo aquellas ExchangeTransactions que cumplan ciertas condiciones. <br><br>  Para evitar el doble gasto, debe solicitar al usuario que env√≠e DataTransaction por adelantado a la cuenta del titular de la p√≥liza con (key, value) = (adquirirTransactionId, sellOrderId) y proh√≠ba enviar DataTransactions con la clave ya utilizada. <br><br>  Por lo tanto, las pruebas de usuario deben contener el ID de transacci√≥n de la compra del token de seguro.  El par de divisas debe ser el mismo que en la transacci√≥n de compra.  El costo tambi√©n debe ser igual al registrado al momento de la compra, menos el precio del seguro. <br><br>  Se entiende que posteriormente la cuenta de seguro canjea las fichas de seguro del usuario a un precio no inferior al precio al que las compr√≥: la cuenta de seguro crea ExchangeTransaction, el usuario firma el pedido (si la transacci√≥n se completa correctamente), la cuenta de seguro firma el segundo pedido y la transacci√≥n completa y lo env√≠a a blockchain . <br><br>  Si la compra no ocurre, el usuario puede crear un Pedido de acuerdo con las reglas descritas en el script y enviar la transacci√≥n a la cadena de bloques.  Para que el usuario pueda devolver el dinero gastado en la compra de tokens asegurados. <br><br><pre> <code class="scala hljs">let insuranceToken = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let freezePeriod = <span class="hljs-number"><span class="hljs-number">150000</span></span> let insurancePrice = <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { #, ,   -,              <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; size(d.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !isDefined(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o : <span class="hljs-type"><span class="hljs-type">Order</span></span> =&gt; #     ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isDefined(o.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) then sigVerify(o.bodyBytes, o.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], o.senderPublicKey) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #     ,         let purchaseTx = transactionById(o.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) let purchaseTxHeight = extract(transactionHeightById(o.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>])) #    <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> purchaseTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> purchase : <span class="hljs-type"><span class="hljs-type">ExchangeTransaction</span></span> =&gt; let correctSender = purchase.sender == o.sender let correctAssetPair = o.assetPair.amountAsset == insuranceToken &amp;&amp; purchase.sellOrder.assetPair.amountAsset == insuranceToken &amp;&amp; o.assetPair.priceAsset == purchase.sellOrder.assetPair.priceAsset let correctPrice = o.price == purchase.price - insurancePrice &amp;&amp; o.amount == purchase.amount let correctHeight = height &gt; purchaseTxHeight + freezePeriod #,   -   <span class="hljs-type"><span class="hljs-type">ID</span></span>   let correctProof = extract(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(purchase.id))) == o.id correctSender &amp;&amp; correctAssetPair &amp;&amp; correctPrice &amp;&amp; correctHeight &amp;&amp; correctProof <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre><br>  Un token de seguro puede convertirse en un activo inteligente, por ejemplo, para prohibir su transferencia a terceros. <br><br>  Este esquema tambi√©n se puede implementar para tokens de crowdfunding, que se devuelven a los propietarios si no se ha recaudado la cantidad necesaria. <br><br>  <b>Impuestos de transacci√≥n</b> <br><br>  Los contratos inteligentes tambi√©n son aplicables en los casos en que es necesario recaudar impuestos de cada transacci√≥n con varios tipos de activos.  Esto se puede hacer a trav√©s de un nuevo activo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">patrocinado</a> para transacciones con activos inteligentes: <br><br>  1. Lanzamos FeeCoin, que se enviar√° a los usuarios a un precio fijo: 0.01 WAVES = 0.001 FeeCoin. <br><br>  2. Establecimos patrocinio para FeeCoin y el tipo de cambio: 0.001 WAVES = 0.001 FeeCoin. <br><br>  3. Configuramos el siguiente script para el activo inteligente: <br><br><pre> <code class="scala hljs">let feeAssetId = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' let taxDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; t.feeAssetId == feeAssetId &amp;&amp; t.fee == t.amount / taxDivisor <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e: <span class="hljs-type"><span class="hljs-type">ExchangeTransaction</span></span>| <span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  Ahora, cada vez que alguien transfiere N activos inteligentes, le dar√° a FeeCoin la cantidad de N / taxDivisor (que puede comprarle por 10 * N / taxDivisor WAVES), y usted le dar√° al minero N / taxDivisor WAVES.  Como resultado, su beneficio (impuesto) ser√° de 9 * N / taxDivisor WAVES. <br><br>  Tambi√©n puede gravar usando un script de activos inteligentes y MassTransferTransaction: <br><br><pre> <code class="scala hljs">let taxDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t : <span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; let twoTransfers = size(t.transfers) == <span class="hljs-number"><span class="hljs-number">2</span></span> let issuerIsRecipient = t.transfers[<span class="hljs-number"><span class="hljs-number">0</span></span>].recipient == addressFromString(<span class="hljs-string"><span class="hljs-string">"3MgkTXzD72BTfYpd9UW42wdqTVg8HqnXEfc"</span></span>) let taxesPaid = t.transfers[<span class="hljs-number"><span class="hljs-number">0</span></span>].amount &gt;= t.transfers[<span class="hljs-number"><span class="hljs-number">1</span></span>].amount / taxDivisor twoTransfers &amp;&amp; issuerIsRecipient &amp;&amp; taxesPaid <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br>  <b>Cashback y programas de fidelizaci√≥n</b> <br><br>  El reembolso es un tipo de programa de fidelizaci√≥n en el que una parte de la cantidad gastada en un producto o servicio se devuelve al comprador. <br><br>  Al implementar este caso utilizando una cuenta inteligente, debemos verificar las pruebas de la misma manera que lo hicimos en el caso del seguro.  Para evitar el doble gasto, antes de recibir un reembolso, el usuario debe enviar una DataTransaction con (clave, valor) = (buyTransactionId, cashbackTransactionId). <br><br>  Tambi√©n debemos prohibir las claves existentes utilizando una DataTransaction.  cashbackDivisor: una unidad dividida por la parte de cashback.  Es decir  si el porcentaje de devoluci√≥n de efectivo es 0.1, entonces el divisor de devoluci√≥n de efectivo 1 / 0.1 = 10. <br><br><pre> <code class="scala hljs">let cashbackToken = base58<span class="hljs-symbol"><span class="hljs-symbol">'8jfD2JBLe23XtCCSQoTx5eAW5QCU6Mbxi3r78aNQLcN</span></span>f' #     let <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = extract(tx.sender) let cashbackDivisor = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { #, ,   -,              <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> d : <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; size(d.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !isDefined(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, d.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; #     ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isDefined(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) then sigVerify(e.bodyBytes, e.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], e.senderPublicKey) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #     ,         let purchaseTx = transactionById(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>]) let purchaseTxHeight = extract(transactionHeightById(e.proofs[<span class="hljs-number"><span class="hljs-number">7</span></span>])) #    <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> purchaseTx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> purchase : <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; let correctSender = purchase.sender == e.sender let correctAsset = e.assetId == cashbackToken let correctPrice = e.amount == purchase.amount / cashbackDivisor #,   -   <span class="hljs-type"><span class="hljs-type">ID</span></span>   let correctProof = extract(getBinary(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, toBase58String(purchase.id))) == e.id correctSender &amp;&amp; correctAsset &amp;&amp; correctPrice &amp;&amp; correctProof <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], tx.senderPublicKey) }</code> </pre> <br>  <b>Intercambio at√≥mico</b> <br><br>  El intercambio at√≥mico permite a los usuarios intercambiar activos sin la ayuda de un intercambio.  En un intercambio at√≥mico, se requiere que ambos participantes en la transacci√≥n lo confirmen dentro de un cierto per√≠odo de tiempo. <br><br>  Si al menos uno de los participantes no proporciona la confirmaci√≥n correcta de la transacci√≥n dentro del tiempo asignado para la transacci√≥n, la transacci√≥n se cancela y no se realiza ning√∫n intercambio. <br><br>  En nuestro ejemplo, utilizaremos el siguiente script de cuenta inteligente: <br><br><pre> <code class="scala hljs">let <span class="hljs-type"><span class="hljs-type">Bob</span></span> = <span class="hljs-type"><span class="hljs-type">Address</span></span>(base58<span class="hljs-symbol"><span class="hljs-symbol">'3NBVqYXrapgJP9atQccdBPAgJPwHDKkh6A</span></span>8') let <span class="hljs-type"><span class="hljs-type">Alice</span></span> = <span class="hljs-type"><span class="hljs-type">Address</span></span>(base58<span class="hljs-symbol"><span class="hljs-symbol">'3PNX6XwMeEXaaP1rf5MCk8weYeF7z2vJZB</span></span>g') let beforeHeight = <span class="hljs-number"><span class="hljs-number">100000</span></span> let secret = base58<span class="hljs-symbol"><span class="hljs-symbol">'BN6RTYGWcwektQfSFzH8raYo9awaLgQ7pLyWLQY4S4F</span></span>5' <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t: <span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; let txToBob = t.recipient == <span class="hljs-type"><span class="hljs-type">Bob</span></span> &amp;&amp; sha256(t.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>]) == secret &amp;&amp; <span class="hljs-number"><span class="hljs-number">20</span></span> + beforeHeight &gt;= height let backToAliceAfterHeight = height &gt;= <span class="hljs-number"><span class="hljs-number">21</span></span> + beforeHeight &amp;&amp; t.recipient == <span class="hljs-type"><span class="hljs-type">Alice</span></span> txToBob || backToAliceAfterHeight <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  <i>En el pr√≥ximo art√≠culo, consideraremos el uso de cuentas inteligentes en instrumentos financieros, como opciones, futuros y facturas.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442238/">https://habr.com/ru/post/442238/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442226/index.html">Este contenido no est√° disponible en su pa√≠s: noticias que no puede aprender de Rusia</a></li>
<li><a href="../442230/index.html">¬øCu√°l de los desarrolladores que viven en la misma ciudad gana m√°s: trabajando de forma remota o en la oficina?</a></li>
<li><a href="../442232/index.html">Registrador de bobina Slf4j alternativo</a></li>
<li><a href="../442234/index.html">Colonia Ep√≠logo</a></li>
<li><a href="../442236/index.html">¬øPor qu√© Dodo Pizza necesita 250 desarrolladores?</a></li>
<li><a href="../442242/index.html">Noticias de √∫ltima hora: Lanzamiento de la planta de c√©lulas solares m√°s grande del hemisferio occidental</a></li>
<li><a href="../442244/index.html">Rust 1.33 Lanzamiento</a></li>
<li><a href="../442248/index.html">La NASA aprob√≥ el lanzamiento de prueba no tripulado de Dragon-2</a></li>
<li><a href="../442250/index.html">Reaccionar y Vue: fortalezas</a></li>
<li><a href="../442252/index.html">Python Code Life Cycle - Modelo de tiempo de ejecuci√≥n de CPython</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>