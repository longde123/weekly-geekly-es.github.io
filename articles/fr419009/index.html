<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüè≠ üöü üéà clang et IDE: une histoire d'amiti√© et d'amiti√© üßïüèª üë©üèø‚Äçü§ù‚Äçüë®üèª üëî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pour moi, cela a commenc√© il y a six ans et demi, lorsque, par la volont√© du destin, j'ai √©t√© entra√Æn√© dans un projet ferm√©. Dont le projet - ne deman...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>clang et IDE: une histoire d'amiti√© et d'amiti√©</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419009/"><p><img src="https://habrastorage.org/webt/yi/u_/xb/yiu_xbaeyduzvwqklgpu5xujgvo.png" align="left">  Pour moi, cela a commenc√© il y a six ans et demi, lorsque, par la volont√© du destin, j'ai √©t√© entra√Æn√© dans un projet ferm√©.  Dont le projet - ne demandez pas, je ne dirai pas.  Je peux seulement dire que son id√©e √©tait simple comme un r√¢teau: int√©grer le front-end de clang dans l'IDE.  Eh bien, comme cela a √©t√© fait r√©cemment dans QtCreator, dans CLion (dans un sens), etc. Clang √©tait alors une √©toile montante, beaucoup se penchaient sur la possibilit√© d'utiliser enfin le parseur C ++ √† part enti√®re presque gratuitement.  Et l'id√©e, pour ainsi dire, √©tait litt√©ralement dans l'air (et l'auto-compl√©tion du code int√©gr√© √† l'API clang √©tait comme sugg√©r√© par Be), il fallait juste le prendre et le faire.  Mais, comme l'a dit Boromir, "Vous ne pouvez pas simplement le prendre, et ...".  C'est donc arriv√© dans ce cas.  Pour plus de d√©tails - Bienvenue sous cat. </p><a name="habracut"></a><br><h2 id="snachala-o-horoshem">  Tout d'abord bon </h2><br><p>  Les avantages de l'utilisation de clang en tant qu'analyseur int√©gr√© dans l'IDE C ++ sont bien s√ªr.  Au final, les fonctions IDE ne se limitent pas uniquement √† l'√©dition de fichiers.  Il s'agit d'une base de donn√©es de caract√®res, de t√¢ches de navigation et de d√©pendances, et bien plus encore.  Et ici, un compilateur √† part enti√®re se dirige vers toute sa hauteur, car ma√Ætriser toute la puissance du pr√©processeur et des mod√®les dans un analyseur syntaxique relativement simple est une t√¢che non triviale.  Parce que vous devez g√©n√©ralement faire beaucoup de compromis, ce qui affecte √©videmment la qualit√© de l'analyse du code.  Qui s'en soucie - peut regarder, par exemple, l'analyseur int√©gr√© de QtCeator ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyseur C ++ Qt Creator</a> </p><br><p>  Au m√™me endroit, dans le code source de QtCreator, vous pouvez voir que ce qui pr√©c√®de n'est pas tout ce que l'IDE requiert de l'analyseur.  De plus, vous avez besoin d'au moins: </p><br><ul><li>  coloration syntaxique (lexicale et s√©mantique) </li><li>  toutes sortes d'indices "√† la vol√©e" avec affichage d'informations sur le symbole </li><li>  des conseils sur ce qui ne va pas avec le code et comment le corriger / le compl√©ter </li><li>  Ach√®vement du code dans une grande vari√©t√© de contextes </li><li>  le refactoring le plus divers </li></ul><br><p>  Par cons√©quent, sur les avantages √©num√©r√©s pr√©c√©demment (vraiment s√©rieux!), Les avantages s'arr√™tent et la douleur commence.  Pour mieux comprendre cette douleur, vous pouvez d'abord voir le rapport d'Anastasia Kazakova ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">anastasiak2512</a> ) sur ce qui est r√©ellement requis de l'analyseur de code int√©gr√© √† l'IDE: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4giOynD7Emg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="sut-problemy">  L'essence du probl√®me </h2><br><p>  Mais c'est simple, m√™me si cela peut ne pas √™tre √©vident √† premi√®re vue.  En r√©sum√©, alors: clang est un <em>compilateur</em> .  Et fait r√©f√©rence au code en tant que <em>compilateur</em> .  Et aiguis√© par le fait que le code lui est donn√© d√©j√† compl√©t√©, et non le talon du fichier qui est maintenant ouvert dans l'√©diteur IDE.  Les compilateurs n'aiment pas les bits de fichiers, comme les constructions incompl√®tes, les identifiants mal √©crits, le <strong>retour</strong> au lieu du <strong>retour</strong> et les autres d√©lices qui peuvent survenir ici et maintenant dans l'√©diteur.  Bien s√ªr, avant la compilation, tout cela sera nettoy√©, corrig√©, align√©.  Mais ici et maintenant, dans l'√©diteur, c'est ce que c'est.  Et c'est sous cette forme que l'analyseur int√©gr√© √† l'IDE arrive √† la table toutes les 5 √† 10 secondes.  Et si sa version auto-√©crite "comprend" parfaitement qu'il s'agit d'un produit semi-fini, alors clang - non.  Et tr√®s surpris.  Ce qui se passe √† la suite d'une telle surprise d√©pend "de", comme on dit. </p><br><p>  Heureusement, clang tol√®re assez bien les erreurs de code.  N√©anmoins, il peut y avoir des surprises - r√©tro-√©clairage disparaissant soudainement, courbe auto-compl√©t√©e, diagnostics √©tranges.  Vous devez √™tre pr√©par√© √† tout cela.  De plus, le clang n'est pas omnivore.  Il a le droit de ne rien accepter dans les en-t√™tes du compilateur, qui sont utilis√©s ici et maintenant pour construire le projet.  Intrins√®ques d√©licates, extensions non standard et autres, euh ..., fonctionnalit√©s - tout cela peut conduire √† des erreurs d'analyse dans les endroits les plus inattendus.  Et, bien s√ªr, la performance.  Modifier un fichier de grammaire sur Boost.Spirit ou travailler sur un projet bas√© sur llvm sera un plaisir.  Mais, √† propos de tout plus en d√©tail. </p><br><h2 id="kod-polufabrikat">  Code pr√©fabriqu√© </h2><br><p>  Supposons donc que vous ayez commenc√© un nouveau projet.  Votre environnement a g√©n√©r√© un espace par d√©faut pour main.cpp, et vous y avez √©crit: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { foo(10) }</span></span></span></span></code> </pre> <br><p>  Du point de vue du C ++, franchement, le code n'est pas valide.  Il n'y a pas de d√©finition de la fonction foo (...) dans le fichier, la ligne n'est pas termin√©e, etc. Mais ... Vous venez de commencer.  Ce code a droit √† ce type.  Comment ce code per√ßoit-il un IDE avec un analyseur automatique (dans ce cas CLion)? </p><br><p><img src="https://habrastorage.org/webt/us/8y/ni/us8yni2bzf5zpm6epgx_uh7m4bs.png"></p><br><p>  Et si vous cliquez sur l'ampoule, vous pouvez voir ceci: </p><br><p><img src="https://habrastorage.org/webt/p2/ej/h4/p2ejh4woiuojsq19oq90rmozhrm.png"></p><br><p>  Un tel IDE, sachant quelque chose, euh, plus sur ce qui se passe, offre l'option tr√®s attendue: cr√©er une fonction √† partir du contexte d'utilisation.  Super offre, je pense.  Comment se comporte l'IDE bas√© sur les clangs (dans ce cas, Qt Creator 4.7)? </p><br><p><img src="https://habrastorage.org/webt/ql/pa/hj/qlpahj0vu5of_my6s1ymrelsa3o.png"></p><br><p>  Et qu'est-ce qui est propos√© pour rectifier la situation?  Mais rien!  Seul renommage standard! </p><br><p><img src="https://habrastorage.org/webt/kk/0m/pt/kk0mptuuwnufqjugzumnoisnyms.png"></p><br><p>  La raison de ce comportement est tr√®s simple: pour clang, ce texte est complet (et il ne peut rien y avoir d'autre).  Et il construit l'AST sur la base de cette hypoth√®se.  Et puis tout est simple: clang voit un identifiant non d√©fini auparavant.  Il s'agit de texte en C ++ (pas en C).  Aucune hypoth√®se n'est faite sur la nature de l'identifiant - il n'est pas d√©fini, donc un morceau de code n'est pas valide.  Et dans AST pour cette ligne, rien n'appara√Æt.  Elle n'est tout simplement pas l√†.  Et ce qui n'est pas dans AST est impossible √† analyser.  C'est dommage, ennuyeux, d'accord. </p><br><p>  L'analyseur int√©gr√© √† l'IDE provient de quelques autres hypoth√®ses.  Il <em>sait</em> que le code n'est pas termin√©.  Que le programmeur est en train de pr√©cipiter la pens√©e et que les doigts derri√®re elle n'ont pas le temps.  Par cons√©quent, tous les identificateurs ne peuvent pas √™tre d√©finis.  Un tel code, bien s√ªr, est incorrect du point de vue des normes √©lev√©es de qualit√© du compilateur, mais l'analyseur sait ce qui peut √™tre fait avec un tel code et propose des options.  Options tout √† fait raisonnables. </p><br><p>  Au moins jusqu'√† la version 3.7 (incluse), des probl√®mes similaires se sont produits dans ce code: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; class Temp { public: int i; }; template&lt;typename T&gt; class Foo { public: int Bar(Temp tmp) { Tpl(tmp); } private: template&lt;typename U&gt; void Tpl(U val) { Foo&lt;U&gt; tmp(val); tmp. } int member; }; int main() { return 0; }</span></span></span></span></code> </pre> <br><p>  √Ä l'int√©rieur des m√©thodes de classe de mod√®le, la saisie semi-automatique bas√©e sur les clangs ne fonctionnait pas.  Pour autant que j'ai r√©ussi √† le d√©couvrir, la raison en √©tait l'analyse en deux passes des mod√®les.  La saisie semi-automatique dans clang est d√©clench√©e lors de la premi√®re passe, lorsque les informations sur les types r√©ellement utilis√©s peuvent ne pas √™tre suffisantes.  Dans clang 5.0 (√† en juger par les notes de publication), cela a √©t√© corrig√©. </p><br><p>  D'une mani√®re ou d'une autre, des situations dans lesquelles le compilateur n'est pas en mesure de cr√©er le bon AST (ou de tirer les bonnes conclusions √† partir du contexte) dans le code √©dit√© peuvent bien √™tre.  Et dans ce cas, l'IDE ne "verra" tout simplement pas les sections de texte correspondantes et ne pourra en aucun cas aider le programmeur.  Ce qui, bien s√ªr, n'est pas g√©nial.  La capacit√© de travailler efficacement avec un code incorrect est ce dont l'analyseur a besoin dans l'IDE et ce dont le compilateur normal n'a pas du tout besoin.  Par cons√©quent, l'analyseur dans l'EDI peut utiliser de nombreuses heuristiques, qui pour le compilateur peuvent √™tre non seulement inutiles, mais √©galement nuisibles.  Et pour y impl√©menter deux modes de fonctionnement - eh bien, vous devez encore convaincre les d√©veloppeurs. </p><br><h2 id="eta-rol---rugatelnaya">  "Ce r√¥le est abusif!" </h2><br><p>  L'IDE du programmeur est g√©n√©ralement un (enfin, deux), mais il existe de nombreux projets et cha√Ænes d'outils.  Et, bien s√ªr, je ne veux pas faire de gestes suppl√©mentaires pour passer d'une cha√Æne d'outils √† une cha√Æne d'outils, d'un projet √† l'autre.  Un ou deux clics, et la configuration de build passe de Debug √† Release, et le compilateur de MSVC √† MinGW.  Mais l'analyseur de code dans l'IDE reste le m√™me.  Et il doit, avec le syst√®me de build, passer d'une configuration √† une autre, d'une cha√Æne d'outils √† une autre.  Une cha√Æne d'outils peut √™tre une sorte d'exotique ou de croix.  Et la t√¢che de l'analyseur ici est de continuer √† analyser correctement le code.  Si possible avec un minimum d'erreurs. </p><br><p>  clang est assez omnivore.  Il peut √™tre forc√© d'accepter les extensions de compilateur de Microsoft, le compilateur gcc.  Il peut √™tre pass√© des options au format de ces compilateurs, et clang les comprendra m√™me.  Mais tout cela ne garantit pas que clang acceptera n'importe quel cap des abats collect√©s dans le r√©servoir gcc.  Tout __builtin_intrinsic_xxx peut devenir une pierre d'achoppement pour lui.  Ou les constructions de langage que la version actuelle de clang dans l'EDI ne prend tout simplement pas en charge.  Tr√®s probablement, cela n'affectera pas la qualit√© de la construction AST pour le fichier actuellement √©dit√©.  Mais la cr√©ation d'une base de caract√®res globale ou la sauvegarde d'en-t√™tes pr√©compil√©s peut se casser.  Et cela peut √™tre un grave probl√®me.  Un probl√®me similaire pourrait se r√©v√©ler √™tre un code similaire non pas dans les en-t√™tes des cha√Ænes d'outils ou des tiers, mais dans les en-t√™tes ou les codes source du projet.  Soit dit en passant, tout cela est une raison suffisamment importante pour dire explicitement au syst√®me de construction (et √† l'IDE) quels fichiers d'en-t√™te pour votre projet sont "√©trangers".  Cela peut vous faciliter la vie. </p><br><p>  Encore une fois, l'IDE a √©t√© initialement con√ßu pour √™tre utilis√© avec diff√©rents compilateurs, param√®tres, cha√Ænes d'outils et plus encore.  Con√ßu pour traiter du code dont certains √©l√©ments ne sont pas pris en charge.  Le cycle de sortie de l'IDE (pas tous :)) est plus court que celui des compilateurs, par cons√©quent, il est possible de r√©cup√©rer plus rapidement de nouvelles fonctionnalit√©s et de r√©pondre aux probl√®mes d√©tect√©s.  Dans le monde des compilateurs, tout est un peu diff√©rent: le cycle de sortie est d'au moins un an, les probl√®mes de compatibilit√© entre compilateurs sont r√©solus par compilation conditionnelle et transmis aux √©paules du d√©veloppeur.  Le compilateur n'a pas besoin d'√™tre universel et omnivore - sa complexit√© est d√©j√† √©lev√©e.  clang ne fait pas exception. </p><br><h2 id="borba-za-skorost">  Le combat pour la vitesse </h2><br><p>  Cette partie du temps pass√© √† l'IDE, lorsque le programmeur n'est pas assis dans le d√©bogueur, il √©dite le texte.  Et son d√©sir naturel ici est de le rendre confortable (sinon pourquoi un IDE? Puis-je me d√©brouiller avec un bloc-notes!) Le confort, en particulier, implique la vitesse de r√©action √©lev√©e de l'√©diteur aux changements de texte et la pression sur les touches de raccourci.  Comme Anastasia l'a correctement not√© dans son rapport, si cinq secondes apr√®s avoir appuy√© sur Ctrl + Espace, l'environnement n'a pas r√©pondu avec l'apparition d'un menu ou d'une liste de saisie semi-automatique, c'est terrible (s√©rieusement, essayez-le vous-m√™me).  En chiffres, cela signifie que l'analyseur int√©gr√© √† l'IDE a environ une seconde pour √©valuer les modifications dans le fichier et reconstruire l'AST, et un autre et demi ou deux pour offrir au d√©veloppeur un choix contextuel.  Deuxi√®mement.  Eh bien, peut-√™tre deux.  En outre, le comportement attendu est que si le d√©veloppeur a modifi√© le .h-nickname, puis est pass√© au .cpp-shnik, les modifications apport√©es seront "visibles".  Les fichiers, les voici, ouverts dans les fen√™tres voisines.  Et maintenant, un calcul simple.  Si clang, lanc√© √† partir de la ligne de commande, peut faire face au code source en environ dix √† vingt secondes, alors quelle est la raison de croire que lorsqu'il est lanc√© √† partir de l'IDE, il va faire face au code source beaucoup plus rapidement et s'int√©grer dans cette seconde ou deux?  Autrement dit, cela fonctionnera un ordre de grandeur plus rapidement?  En g√©n√©ral, cela pourrait √™tre termin√©, mais je ne le ferai pas. </p><br><p>  Environ dix √† vingt secondes √† la source, bien s√ªr, j'exag√®re.  Bien que, si une API lourde est incluse ou, par exemple, boost.spirit avec Hana pr√™t, et que tout cela soit activement utilis√© dans le texte, 10 √† 20 secondes sont toujours de bonnes valeurs.  Mais m√™me si l'AST est pr√™t quelques secondes apr√®s trois ou quatre apr√®s le lancement de l'analyseur int√©gr√© - c'est d√©j√† long.  √Ä condition que ces lancements soient aussi r√©guliers (pour maintenir le mod√®le de code et l'index dans un √©tat coh√©rent, surlign√©, rapide, etc.), ainsi qu'√† la demande - l'ach√®vement du code est √©galement le lancement du compilateur.  Est-il possible de r√©duire ce temps d'une mani√®re ou d'une autre?  Malheureusement, dans le cas de l'utilisation de clang comme analyseur, il n'y a pas beaucoup de possibilit√©s.  Raison: il s'agit d'un outil tiers dans lequel ( <em>id√©alement</em> ) des modifications ne peuvent pas √™tre apport√©es.  Autrement dit, creuser dans le code clang avec perftool, optimiser, simplifier certaines branches - ces fonctionnalit√©s ne sont pas disponibles et vous devez faire avec ce que l'API externe fournit (dans le cas de l'utilisation de libclang, il est √©galement assez √©troit). </p><br><p>  La premi√®re solution, √©vidente et, en fait, la seule consiste √† utiliser des en-t√™tes pr√©compil√©s g√©n√©r√©s dynamiquement.  Avec une mise en ≈ìuvre ad√©quate, la solution est mortelle.  Augmente parfois la vitesse de compilation au moins.  Son essence est simple: l'environnement collecte tous les en-t√™tes tiers (ou en-t√™tes en dehors de la racine du projet) dans un seul fichier .h, cr√©e pch √† partir de ce fichier, puis inclut implicitement ce pch dans chaque source.  Bien s√ªr, un effet secondaire √©vident appara√Æt: dans le code source ( <em>au stade de l'√©dition</em> ), on peut voir des symboles qui n'y sont pas inclus.  Mais c'est une charge pour la vitesse.  Je dois choisir.  Et tout irait bien, sinon pour un petit probl√®me: clang est toujours un compilateur.  Et, √©tant un compilateur, il n'aime pas les erreurs de code.  Et si tout √† coup (tout √† coup! - voir la section pr√©c√©dente) il y a des erreurs dans les en-t√™tes, alors le fichier .pch n'est pas cr√©√©.  Au moins, c'√©tait jusqu'√† la version 3.7.  Depuis, quelque chose a-t-il chang√© √† cet √©gard?  Je ne sais pas, on soup√ßonne que non.  H√©las, il n'y a plus aucune possibilit√© de v√©rifier. </p><br><p>  H√©las, les options alternatives ne sont pas disponibles pour la m√™me raison: clang est un compilateur et une chose ¬´en soi¬ª.  Intervenir activement dans le processus de g√©n√©ration AST, en quelque sorte faire fusionner AST √† partir de diff√©rentes pi√®ces, maintenir des bases de symboles externes et te et te te - h√©las, toutes ces fonctionnalit√©s ne sont pas disponibles.  Seulement API externe, uniquement hardcore et param√®tres disponibles via les options de compilation.  Et puis analyse de l'AST r√©sultant.  Si vous vous asseyez sur la version C ++ de l'API, alors un peu plus d'opportunit√©s deviennent disponibles.  Par exemple, vous pouvez jouer avec des FrontendActions personnalis√©es, effectuer des r√©glages plus fins pour les options de compilation, etc. Mais dans ce cas, le point principal ne changera pas - le texte √©dit√© (ou index√©) sera compil√© ind√©pendamment des autres et compl√®tement.  C‚Äôest tout.  Le point. </p><br><p>  Peut-√™tre (peut-√™tre!) Un jour, il y aura une fourchette de clang en amont sp√©cialement con√ßue pour √™tre utilis√©e dans le cadre de l'IDE.  C'est possible.  Mais pour l'instant, tout est comme √ßa.  Supposons que l'int√©gration de l'√©quipe de Qt Creator (√† l'√©tape "finale") avec libclang ait pris sept ans.  J'ai essay√© QtC 4.7 avec un moteur bas√© sur libclang - j'avoue que j'aime personnellement l'ancienne version (sur l'auto-√©crite) plus simplement parce qu'elle fonctionne mieux sur mes cas: elle invite et met en √©vidence, et tout le reste.  Je ne m'engagerai pas √† estimer combien d'heures humaines ils ont consacr√©es √† cette int√©gration, mais j'ose sugg√©rer que pendant ce temps, il serait possible de terminer mon propre analyseur.  Pour autant que je sache (par des indications indirectes), l'√©quipe travaillant sur CLion envisage avec prudence l'int√©gration avec libclang / clang ++.  Mais ce sont des hypoth√®ses purement personnelles.  L'int√©gration au niveau du protocole du serveur de langues est une option int√©ressante, mais sp√©cifiquement pour le cas C ++, j'ai tendance √† consid√©rer cela plus comme un palliatif pour les raisons √©num√©r√©es ci-dessus.  Il transf√®re simplement les probl√®mes d'un niveau d'abstraction √† un autre.  Mais je me trompe peut-√™tre pour le LSP - l'avenir.  Voyons voir.  Mais de toute fa√ßon, la vie des d√©veloppeurs d'IDE modernes pour C ++ est pleine d'aventures - avec clang comme backend, ou sans. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr419009/">https://habr.com/ru/post/fr419009/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418999/index.html">[Annonce, Peter] Rencontre JUG.ru avec Andrei Belyaev et Alexei Stukalov - Troll opprime CUBA: FAQ</a></li>
<li><a href="../fr419001/index.html">5 ¬´super comp√©tences¬ª n√©cessaires au travail de demain</a></li>
<li><a href="../fr419003/index.html">R√©sum√© des nouvelles de la blockchain</a></li>
<li><a href="../fr419005/index.html">Excursion au poste 220/110/20</a></li>
<li><a href="../fr419007/index.html">Textures for 64k intro: comment c'est fait aujourd'hui</a></li>
<li><a href="../fr419011/index.html">Jinja2 dans le monde C ++, deuxi√®me partie. Rendu</a></li>
<li><a href="../fr419013/index.html">Attribution bas√©e sur l'entonnoir pour les entreprises SaaS B2B - car nous avons consid√©r√© la valeur de tous les efforts de marketing</a></li>
<li><a href="../fr419017/index.html">Nouveaut√©s de ConstraintLayout 1.1</a></li>
<li><a href="../fr419019/index.html">AlterEgo: un appareil qui peut lire (certaines) pens√©es</a></li>
<li><a href="../fr419021/index.html">Les principaux types d'impression et leurs fonctionnalit√©s</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>