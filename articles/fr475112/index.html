<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🉐 ⚽️ 👩🏿‍🤝‍👨🏻 Authentifiez-moi. Si tu peux ... 👰 💇🏾 😤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'entends souvent des questions comme "Comment implémenter l'authentification dans une application Android?", "Où stocker un code PIN?", "Hé mec, sera...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Authentifiez-moi. Si tu peux ...</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redmadrobot/blog/475112/"><p><img src="https://habrastorage.org/webt/p9/kd/qs/p9kdqsyke71dvzl72vxr24da0yc.jpeg"></p><br><p>  J'entends souvent des questions comme "Comment implémenter l'authentification dans une application Android?", "Où stocker un code PIN?", "Hé mec, serai-je en sécurité si j'implémente une fonctionnalité d'authentification de cette manière?"  et beaucoup du genre.  Je me suis vraiment fatigué de répondre à ces questions, alors j'ai décidé d'écrire toutes mes pensées à ce sujet une fois pour les partager avec tous les intervenants. </p><a name="habracut"></a><br><h1 id="table-of-contents">  Table des matières </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Authentification: pourquoi dois-je le faire?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Manière simple</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Faisons mieux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La bonne façon</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mais attendez, qu'en est-il de la biométrie?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Suis-je complètement protégé?</a> </li></ul><br><a name="why-do-I-have-to-do-it"></a><br><h1 id="authentication-why-do-i-have-to-do-it">  Authentification: pourquoi dois-je le faire? </h1><br><p>  Commençons par la définition.  <strong>L'authentification</strong> (du grec: αὐθεντικός authentikos, "réel, authentique", de αὐθέντης authentes, "auteur") est l'acte de prouver une assertion, telle que l'identité d'un utilisateur de système informatique. </p><br><p>  Donc, si votre application contient des informations sensibles (les informations de tout utilisateur sont sensibles à mon humble avis), vous devez ajouter un scénario d'authentification à l'application pour empêcher tout accès non autorisé à ces informations. </p><br><p>  Les scénarios d'authentification les plus courants sont les suivants: </p><br><ul><li>  Identifiant + mot de passe </li><li>  Mot de passe principal </li><li>  PIN (4 chiffres ou plus) </li><li>  Biométrie </li></ul><br><p>  Naturellement, l'authentification de <strong>connexion et de mot de passe</strong> vient de votre application depuis un back-end et la sécurité de ce mécanisme nous laisserons à l'équipe d'assurance de la sécurité du back-end;) N'oubliez pas d'implémenter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'épinglage de clé publique</a> . </p><br><p>  <strong>L'</strong> authentification par <strong>mot de passe principal</strong> est très rarement utilisée et uniquement dans les applications qui nécessitent un haut niveau de sécurité (par exemple, les gestionnaires de mots de passe). </p><br><p>  Ainsi, nous n'avons que deux scénarios les plus populaires: un <strong>code PIN</strong> et la <strong>biométrie</strong> .  Ils sont assez conviviaux et relativement faciles à mettre en œuvre (en fait ils ne le sont pas ...).  Dans cet article, nous couvrirons les principaux aspects de la mise en œuvre correcte de ces fonctionnalités. </p><br><a name="simple-way"></a><br><h1 id="simple-way">  Manière simple </h1><br><p>  Imaginez, vous êtes un développeur Android et votre code vous fait gagner de l'argent.  Vous ne vous inquiétez de rien et vous n'avez pas vraiment besoin d'une expertise sérieuse en matière de sécurité des applications mobiles.  Mais un jour, un manager vient vous voir et vous donne pour tâche de "mettre en place une authentification supplémentaire via un code PIN et une empreinte digitale dans notre application".  L'histoire commence ici ... </p><br><p>  Pour implémenter l'authentification PIN, vous devez créer quelques écrans comme ceux-ci: <br><img src="https://habrastorage.org/webt/7i/fe/0u/7ife0uw4kwm-yybqkot0pkvwue8.png"><img src="https://habrastorage.org/webt/mp/bl/ou/mpblouhttk5kpu9u5haezm6659i.png"></p><br><p>  Et écrivez ce code pour créer et vérifier votre code PIN </p><br><pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">savePin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { preferences.edit().putString(StorageKey.PIN, pin).apply() }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">authenticate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { authenticationState.value = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pinIsValid(pin)) { AuthenticationState.AUTHENTICATED } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AuthenticationState.INVALID_AUTHENTICATION } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pinIsValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> preferences.getString(StorageKey.PIN, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) == pin }</code> </pre> <br><p>  C'est tout!  Maintenant, vous avez un système d'authentification cool via un code PIN.  Félicitations.  C'était si facile, non? </p><br><p>  Bien sûr, vous avez déjà saisi l'ironie de mes mots.  Cette façon est terriblement mauvaise, car un code PIN est stocké en texte brut.  Si un malware accède d'une manière ou d'une autre au stockage interne de l'application, il obtiendra le code PIN de l'utilisateur tel quel.  Vous pouvez me demander "Pourquoi est-ce si mauvais? C'est juste un code PIN d'authentification locale ...".  Oui, mais les utilisateurs ont tendance à définir le même code PIN partout.  Par conséquent, la connaissance d'un code PIN utilisateur permet à un intrus d'élargir la surface d'attaque. </p><br><p>  De plus, un tel schéma d'authentification ne vous permet pas d'implémenter le cryptage des données utilisateur basé sur un code PIN de manière sécurisée (nous en parlerons plus tard). </p><br><a name="lets-make-it-better"></a><br><h1 id="lets-make-it-better">  Faisons mieux </h1><br><p>  Comment pouvons-nous améliorer notre mise en œuvre précédente?  La première approche évidente consiste à extraire un hachage de votre code PIN et à le stocker. </p><br><blockquote>  Une <strong>fonction de hachage</strong> est une fonction qui peut être utilisée pour mapper des données de taille arbitraire à des valeurs de taille fixe.  Les valeurs renvoyées par une fonction de hachage sont appelées valeurs de hachage, codes de hachage, résumés ou simplement hachages.  Les valeurs sont utilisées pour indexer une table de taille fixe appelée table de hachage.  L'utilisation d'une fonction de hachage pour indexer une table de hachage est appelée adressage de stockage de hachage ou de dispersion. </blockquote><p>  Il existe de nombreuses fonctions de hachage disponibles dans Android Framework (dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java Cryptography Architecture</a> , pour être précis), mais aujourd'hui, chacune n'est pas considérée comme sécurisée.  Je ne recommande pas d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MD5</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SHA-1 en</a> raison de collisions.  SHA-256 est un bon choix pour la plupart des tâches. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha256</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byteArray: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteArray</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ByteArray { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> digest = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA-256"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: NoSuchAlgorithmException) { MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> with(digest) { update(byteArray) digest() } }</code> </pre> <br><p>  <code>savePin(...)</code> notre <code>savePin(...)</code> pour stocker le code PIN haché </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">savePin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hashedPin = sha256(pin.toByteArray()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encodedHash = Base64.encodeToString(hashedPin, Base64.DEFAULT) preferences.edit().putString(StorageKey.PIN, encodedHash).apply() }</code> </pre> <br><p>  L'utilisation du hachage est un bon début, mais le hachage nu n'est pas suffisant pour notre tâche.  Dans la vie réelle, un attaquant a déjà <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pré-calculé</a> tous les hachages PIN à 4 chiffres.  Il sera en mesure de déchiffrer assez facilement tous ces NIP hachés volés.  Il existe une approche pour y faire face - un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sel</a> . </p><br><blockquote>  En cryptographie, un <strong>sel</strong> est des données aléatoires qui sont utilisées comme entrée supplémentaire pour une fonction unidirectionnelle qui «hache» les données, un mot de passe ou une phrase secrète.  Les sels sont utilisés pour protéger les mots de passe dans le stockage.  Historiquement, un mot de passe était stocké en texte brut sur un système, mais avec le temps, des protections supplémentaires ont été développées pour protéger le mot de passe d'un utilisateur contre la lecture du système.  Un sel est l'une de ces méthodes. </blockquote><p>  Pour ajouter un sel à notre mécanisme de sécurité, nous devons changer le code ci-dessus de cette manière </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lengthByte: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ByteArray { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> random = SecureRandom() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salt = ByteArray(lengthByte) random.nextBytes(salt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> salt }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">savePin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salt = Salt.generate() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> saltedPin = pin.toByteArray() + salt <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hashedPin = Sha256.hash(saltedPin) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encodedHash = Base64.encodeToString(hashedPin, Base64.DEFAULT) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encodedSalt = Base64.encodeToString(salt, Base64.DEFAULT) preferences.edit() .putString(StorageKey.PIN, encodedHash) .putString(StorageKey.SALT, encodedSalt) .apply() }</code> </pre> <br><p>  Remarque, vous devez stocker le sel avec le code PIN car vous devez calculer le hachage résultant (en utilisant du sel) à chaque fois lors de la vérification du code PIN à partir de la saisie utilisateur. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pinIsValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encodedSalt = preferences.getString(StorageKey.SALT, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encodedHashedPin = preferences.getString(StorageKey.PIN, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salt = Base64.decode(encodedSalt, Base64.DEFAULT) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> storedHashedPin = Base64.decode(encodedHashedPin, Base64.DEFAULT) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> enteredHashedPin = Sha256.hash(pin.toByteArray() + salt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> storedHashedPin contentEquals enteredHashedPin }</code> </pre> <br><p>  Comme vous pouvez le voir, le code n'est toujours pas si difficile à comprendre, mais la sécurité de cette solution est devenue beaucoup plus forte.  Je dirai même plus, cette approche est tout à fait prête à la production pour la plupart des applications qui ne nécessitent pas un haut niveau de sécurité. </p><br><p>  "Mais si j'ai besoin d'une solution beaucoup plus sûre?", Demandez-vous.  Ok, suivez-moi. </p><br><a name="the-right-way"></a><br><h1 id="the-right-way">  La bonne façon </h1><br><p>  Discutons de plusieurs points d'amélioration de notre approche d'authentification. </p><br><p>  Premièrement, le principal défaut des "hachages ordinaires" (et même des "hachages ordinaires salés") est la vitesse relativement élevée d'une attaque par force brute (environ des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">milliards de hachages par minute</a> ).  Pour éliminer cette faille, nous devons utiliser une fonction KDF spéciale comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PBKDF2</a> qui est nativement prise en charge par Android Framework.  Bien sûr, il existe une certaine différence entre les fonctions KDF et vous voudrez probablement choisir l'autre, mais cela sort du cadre de cet article.  Je vais vous donner plusieurs liens utiles sur ce sujet à la fin de l'article. </p><br><p>  Deuxièmement, nous n'avons pas de cryptage des données utilisateur à ce stade.  Il existe de nombreuses façons de l'implémenter et je vais vous montrer la plus simple et la plus fiable.  Ce sera un ensemble de deux bibliothèques et du code autour d'eux. </p><br><p>  Écrivons une usine de création de clés PBKDF2 pour commencer. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Pbkdf2Factory { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> DEFAULT_ITERATIONS = <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> DEFAULT_KEY_LENGTH = <span class="hljs-number"><span class="hljs-number">256</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secretKeyFactory <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.O) { SecretKeyFactory.getInstance(<span class="hljs-string"><span class="hljs-string">"PBKDF2withHmacSHA1"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { SecretKeyFactory.getInstance(<span class="hljs-string"><span class="hljs-string">"PBKDF2withHmacSHA256"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( passphraseOrPin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CharArray</span></span></span></span><span class="hljs-function"><span class="hljs-params">, salt: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteArray</span></span></span></span><span class="hljs-function"><span class="hljs-params">, iterations: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = DEFAULT_ITERATIONS, outputKeyLength: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = DEFAULT_KEY_LENGTH )</span></span></span></span>: SecretKey { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> keySpec = PBEKeySpec(passphraseOrPin, salt, iterations, outputKeyLength) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> secretKeyFactory.generateSecret(keySpec) } }</code> </pre> <br><p>  Maintenant armé de cette usine, nous devons refactoriser nos <code>savePin()</code> et <code>pinIsValid()</code> </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">savePin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salt = Salt.generate() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secretKey = Pbkdf2Factory.createKey(pin.toCharArray(), salt) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encodedKey = Base64.encodeToString(secretKey.encoded, Base64.DEFAULT) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encodedSalt = Base64.encodeToString(salt, Base64.DEFAULT) preferences.edit() .putString(StorageKey.KEY, encodedKey) .putString(StorageKey.SALT, encodedSalt) .apply() pinIsCreated.value = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pinIsValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encodedSalt = preferences.getString(StorageKey.SALT, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encodedKey = preferences.getString(StorageKey.KEY, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salt = Base64.decode(encodedSalt, Base64.DEFAULT) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> storedKey = Base64.decode(encodedKey, Base64.DEFAULT) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> enteredKey = Pbkdf2Factory.createKey(pin.toCharArray(), salt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> storedKey contentEquals enteredKey.encoded }</code> </pre> <br><p>  Ainsi, nous venons d'atténuer le principal défaut de notre solution précédente.  C'est bien, et maintenant nous devons ajouter le cryptage des données utilisateur.  Pour l'implémenter, nous prendrons ces bibliothèques: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tink</a> - Une bibliothèque multi-plateforme multi-langue qui fournit des API cryptographiques qui sont sécurisées, faciles à utiliser correctement et difficiles (euh) à abuser. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jetpack Security</a> - Lisez et écrivez des fichiers chiffrés et des préférences partagées en suivant les meilleures pratiques de sécurité. </li></ul><br><p>  Pour obtenir un bon stockage crypté, nous devons écrire un tel code: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encryptedStorage <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { EncryptedSharedPreferences.create( <span class="hljs-string"><span class="hljs-string">"main_storage"</span></span>, <span class="hljs-string"><span class="hljs-string">"main_storage_key"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV, EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM ) } ... }</code> </pre> <br><p>  C'est tout.  Plus tard, nous pouvons travailler avec lui comme s'il s'agissait de <code>SharedPreferences</code> régulières, mais toutes les données seront cryptées.  Maintenant, nous pouvons facilement remplacer l'implémentation précédente. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreatePinViewModel</span></span></span></span>(application: Application) : AndroidViewModel(application) { ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> preferences <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { getApplication&lt;App&gt;().encryptedStorage } ... }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputPinViewModel</span></span></span></span>(application: Application) : AndroidViewModel(application) { ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> preferences <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { getApplication&lt;App&gt;().encryptedStorage } ... }</code> </pre> <br><p>  Résumons le sous-total.  Nous avons une clé assez sécurisée dérivée d'un code PIN et une approche assez fiable pour la stocker.  Cela a l'air cool, mais pas suffisant.  Et si nous supposons que l'attaquant a eu accès à notre appareil et en a extrait toutes les données.  En théorie, il a tous les composants pour décrypter les données en ce moment.  Pour résoudre ce problème, nous devons réaliser deux choses: </p><br><ul><li>  un code PIN n'est pas stocké du tout </li><li>  les opérations de chiffrement sont basées sur le code PIN </li></ul><br><p>  Comment pouvons-nous atteindre ces objectifs sans réécrire tout le code?  C'est facile!  Dans la mesure où nous utilisons Tink, nous pouvons appliquer sa fonction de cryptage nommée en tant que données associées. </p><br><blockquote>  Données associées à authentifier, mais non chiffrées.  Les données associées sont facultatives, ce paramètre peut donc être nul.  Dans ce cas, la valeur nulle équivaut à un tableau d'octets vide (de longueur nulle).  Pour un décryptage réussi, les mêmes données associées doivent être fournies avec le texte chiffré. </blockquote><p>  Voilà!  Nous pouvons utiliser un code PIN comme données associées pour atteindre nos objectifs désignés.  Ainsi, la possibilité ou l'impossibilité de décrypter les données utilisateur agira comme un indicateur de l'exactitude du code PIN.  Ce schéma fonctionne généralement comme suit: </p><br><img src="https://habrastorage.org/webt/gt/b8/lp/gtb8lp4qsvavlqyyopgju6pmyxy.png" width="50%" height="50%"><br><p>  Si un utilisateur entre un code PIN incorrect, vous recevrez <strong>GeneralSecurityException</strong> en essayant de décrypter le jeton d'accès.  Ainsi, l'implémentation finale pourrait ressembler à ceci: </p><br><div class="spoiler">  <b class="spoiler_title">Afficher le code</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreatePinViewModel</span></span></span></span>(application: Application): AndroidViewModel(application) { ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fakeAccessToken = <span class="hljs-string"><span class="hljs-string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZWNyZXQiOiJXZSdyZSBoaXJpbmcgOykifQ.WZrEWG-l3VsJzJrbnjn2BIYO68gHIGyat6jrw7Iu-Rw"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> preferences <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { getApplication&lt;App&gt;().encryptedStorage } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> aead <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { getApplication&lt;App&gt;().pinSecuredAead } ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">savePin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salt = Salt.generate() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secretKey = Pbkdf2Factory.createKey(pin.toCharArray(), salt) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encryptedToken = aead.encrypt( fakeAccessToken.toByteArray(), secretKey.encoded ) preferences.edit { putString(StorageKey.TOKEN, Base64.encodeToString( encryptedToken, Base64.DEFAULT )) putString(StorageKey.SALT, Base64.encodeToString(salt, Base64.DEFAULT)) putBoolean(StorageKey.PIN_IS_ENABLED, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } ... } }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputPinViewModel</span></span></span></span>(application: Application) : AndroidViewModel(application) { ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> preferences <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { getApplication&lt;App&gt;().encryptedStorage } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> aead <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { getApplication&lt;App&gt;().pinSecuredAead } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">authenticate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { authenticationState.value = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pinIsValid(pin)) { AuthenticationState.AUTHENTICATED } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AuthenticationState.INVALID_AUTHENTICATION } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pinIsValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pin: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salt = Base64.decode( preferences.getString(StorageKey.SALT, <span class="hljs-literal"><span class="hljs-literal">null</span></span>), Base64.DEFAULT ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secretKey = Pbkdf2Factory.createKey(pin.toCharArray(), salt) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> token = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encryptedToken = Base64.decode( preferences.getString(StorageKey.TOKEN, <span class="hljs-literal"><span class="hljs-literal">null</span></span>), Base64.DEFAULT ) aead.decrypt(encryptedToken, secretKey.encoded) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: GeneralSecurityException) { <span class="hljs-literal"><span class="hljs-literal">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> token?.isNotEmpty() ?: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre> </div></div><br><p>  Beau résultat!  Maintenant, nous ne stockons plus le code PIN, et toutes les données sont cryptées par défaut.  Bien sûr, il existe de nombreuses façons d'améliorer cette implémentation si vous le souhaitez.  Je viens de montrer le principe de base. </p><br><a name="what-about-biometrics"></a><br><h1 id="but-wait-what-about-biometrics">  Mais attendez, qu'en est-il de la biométrie? </h1><br><p>  Je ne pense pas que la "biométrie" soit une question de sécurité.  Je préfère le nommer "une fonctionnalité utilisateur très pratique".  Et c'est une guerre sainte terriblement ancienne entre commodité et sécurité.  Mais la plupart des utilisateurs aiment ce type d'authentification et nous, en tant que développeurs, devons l'implémenter de la manière la plus sécurisée possible. </p><br><p>  Malheureusement, la mise en œuvre de l'authentification biométrique est assez délicate.  C'est pourquoi je vais commencer par vous montrer un principe d'implémentation commun et donner quelques explications.  Après cela, nous plongerons profondément dans le code. </p><br><img src="https://habrastorage.org/webt/v-/dn/et/v-dnetfch9xp5ixpzghi-f1t1co.png" width="70%" height="70%"><br><p>  Ce schéma contient une nuance importante: <strong>la clé secrète est enregistrée sur le disque</strong> .  Bien sûr, pas sous forme de texte brut, mais néanmoins. </p><br><p>  Comme vous pouvez le voir, nous avons créé une nouvelle clé de cryptage dans le magasin de clés et nous utilisons cette clé pour crypter notre clé secrète dérivée d'un code PIN.  Un tel schéma nous permet de ne pas rechiffrer toutes les données lors du changement d'une méthode d'authentification.  De plus, nous avons toujours la possibilité de saisir un code PIN si l'authentification biométrique a échoué pour une raison quelconque.  Ok, écrivons beaucoup de code. </p><br><p>  Tout d'abord, je vais montrer les changements dans le flux de création de code PIN: </p><br><div class="spoiler">  <b class="spoiler_title">Afficher le code</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreatePinViewModel</span></span></span></span>(application: Application): AndroidViewModel(application) { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ANDROID_KEY_STORE = <span class="hljs-string"><span class="hljs-string">"AndroidKeyStore"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> KEY_NAME = <span class="hljs-string"><span class="hljs-string">"biometric_key"</span></span> } ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> biometricEnableDialog = MutableLiveData&lt;SingleLiveEvent&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt;&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> biometricParams = MutableLiveData&lt;BiometricParams&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authenticationCallback = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : BiometricPrompt.AuthenticationCallback() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAuthenticationError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(errorCode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, errString: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CharSequence</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onAuthenticationError(errorCode, errString) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAuthenticationSucceeded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AuthenticationResult</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onAuthenticationSucceeded(result) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encryptedSecretKey = result.cryptoObject?.cipher?.doFinal( secretKey.encoded ) preferences.edit { putString(StorageKey.KEY, Base64.encodeToString( encryptedSecretKey, Base64.DEFAULT )) } pinIsCreated.postValue(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAuthenticationFailed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onAuthenticationFailed() } } ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> biometricManager <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { getApplication&lt;App&gt;().biometricManager } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> keyStore = KeyStore.getInstance(ANDROID_KEY_STORE) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secretKey: SecretKey ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enableBiometric</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(isEnabled: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { generateKey() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cipher = createCipher().also { preferences.edit { putString(StorageKey.KEY_IV, Base64.encodeToString(it.iv, Base64.DEFAULT)) } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> promptInfo = createPromptInfo() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cryptoObject = BiometricPrompt.CryptoObject(cipher) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isEnabled) { biometricParams.value = BiometricParams(isEnabled, promptInfo, cryptoObject) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { pinIsCreated.value = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPromptInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: BiometricPrompt.PromptInfo { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BiometricPrompt.PromptInfo.Builder() .setTitle(<span class="hljs-string"><span class="hljs-string">"Create biometric authorization"</span></span>) .setSubtitle(<span class="hljs-string"><span class="hljs-string">"Touch your biometric sensor"</span></span>) .setNegativeButtonText(<span class="hljs-string"><span class="hljs-string">"Cancel"</span></span>) .build() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { keyStore.load(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> keyProperties = PURPOSE_ENCRYPT or PURPOSE_DECRYPT <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> builder = KeyGenParameterSpec.Builder(KEY_NAME, keyProperties) .setBlockModes(BLOCK_MODE_CBC) .setUserAuthenticationRequired(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) .setEncryptionPaddings(ENCRYPTION_PADDING_NONE) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> keyGenerator = KeyGenerator.getInstance( KEY_ALGORITHM_AES, ANDROID_KEY_STORE ) keyGenerator.run { <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(builder.build()) generateKey() } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { authenticationCallback.onAuthenticationError( BiometricConstants.ERROR_NO_DEVICE_CREDENTIAL, e.localizedMessage ) } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCipher</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Cipher { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> key = with(keyStore) { load(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) getKey(KEY_NAME, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Cipher.getInstance( <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$KEY_ALGORITHM_AES</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BLOCK_MODE_CBC</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ENCRYPTION_PADDING_NONE</span></span></span><span class="hljs-string">"</span></span> ).apply { <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(Cipher.ENCRYPT_MODE, key) } } }</code> </pre> </div></div><br><p>  Je serais heureux si Google incluait Tink dans la biométrie, mais ... Nous devons écrire ce code standard avec Cipher et KeyStore.  Ce code est assez familier aux personnes qui travaillent avec la cryptographie dans Android, mais je veux prêter votre attention aux rembourrages de cryptage.  Oui, pour empêcher l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">attaque par Padding Oracle,</a> nous n'utilisons pas du tout de padding.  Ainsi, nous atténuons les risques lors du stockage de la clé secrète sur le disque. </p><br><p>  Le code de vérification biométrique est très similaire: </p><br><div class="spoiler">  <b class="spoiler_title">Afficher le code</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputPinViewModel</span></span></span></span>(application: Application) : AndroidViewModel(application) { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ANDROID_KEY_STORE = <span class="hljs-string"><span class="hljs-string">"AndroidKeyStore"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> KEY_NAME = <span class="hljs-string"><span class="hljs-string">"biometric_key"</span></span> } ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> biometricErrorMessage = MutableLiveData&lt;SingleLiveEvent&lt;String&gt;&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> biometricParams = MutableLiveData&lt;BiometricParams&gt;() ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> biometricManager <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { getApplication&lt;App&gt;().biometricManager } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> keyStore = KeyStore.getInstance(ANDROID_KEY_STORE) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authenticationCallback = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : BiometricPrompt.AuthenticationCallback() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAuthenticationError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(errorCode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, errString: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CharSequence</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onAuthenticationError(errorCode, errString) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAuthenticationSucceeded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AuthenticationResult</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onAuthenticationSucceeded(result) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encryptedSecretKey = Base64.decode( preferences.getString(StorageKey.KEY, <span class="hljs-string"><span class="hljs-string">""</span></span>), Base64.DEFAULT ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secretKey = result.cryptoObject?.cipher?.doFinal(encryptedSecretKey) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> token = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> encryptedToken = Base64.decode( preferences.getString(StorageKey.TOKEN, <span class="hljs-literal"><span class="hljs-literal">null</span></span>), Base64.DEFAULT ) aead.decrypt(encryptedToken, secretKey) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: GeneralSecurityException) { <span class="hljs-literal"><span class="hljs-literal">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> state = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token?.isNotEmpty() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { AuthenticationState.AUTHENTICATED } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AuthenticationState.INVALID_AUTHENTICATION } authenticationState.postValue(state) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAuthenticationFailed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onAuthenticationFailed() } } ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biometricAuthenticate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preferences.contains(StorageKey.KEY)) { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (biometricManager.canAuthenticate()) { BiometricManager.BIOMETRIC_SUCCESS -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> promptInfo = createPromptInfo() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cryptoObject = BiometricPrompt.CryptoObject(createCipher()) biometricParams.value = BiometricParams(promptInfo, cryptoObject) } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { biometricErrorMessage.value = SingleLiveEvent( <span class="hljs-string"><span class="hljs-string">"Biometric authentication isn't configured"</span></span> ) } } ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPromptInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: BiometricPrompt.PromptInfo { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BiometricPrompt.PromptInfo.Builder() .setTitle(<span class="hljs-string"><span class="hljs-string">"Biometric login for my app"</span></span>) .setSubtitle(<span class="hljs-string"><span class="hljs-string">"Log in using your biometric credential"</span></span>) .setNegativeButtonText(<span class="hljs-string"><span class="hljs-string">"Cancel"</span></span>) .build() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCipher</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Cipher { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> key = with(keyStore) { load(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) getKey(KEY_NAME, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Cipher.getInstance( <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$KEY_ALGORITHM_AES</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$BLOCK_MODE_CBC</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ENCRYPTION_PADDING_NONE</span></span></span><span class="hljs-string">"</span></span> ).apply { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> iv = Base64.decode( preferences.getString(StorageKey.KEY_IV, <span class="hljs-literal"><span class="hljs-literal">null</span></span>), Base64.DEFAULT ) <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(Cipher.DECRYPT_MODE, key, IvParameterSpec(iv)) } } }</code> </pre> </div></div><br><p>  Faites attention à l' <code>authenticationCallback.onAuthenticationSucceeded</code> , elle contient la logique clé de l'authentification post-biométrique.  En fait, il s'agit d'une implémentation alternative de la méthode <code>pinIsValid()</code> .  Si vous ne comprenez pas bien ce qui se passe dans les deux blocs de code précédents, veuillez vous référer à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle biométrique</a> . </p><br><a name="am-i-completely-protected"></a><br><h1 id="am-i-completely-protected">  Suis-je complètement protégé? </h1><br><p>  Nous avons fait beaucoup de choses intéressantes pour réaliser l'authentification avec un code PIN et la biométrie, mais est-ce si fiable et sécurisé?  Bien sûr, nous avons fait de notre mieux, mais il y a quelques points à prendre en compte. </p><br><p>  Un code PIN classique ne comporte que quatre chiffres et son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">entropie</a> est trop faible.  Donc, ce type de code n'est pas assez sûr à utiliser.  Malgré tout ce que nous avons fait, il est possible qu'un intrus puisse déchiffrer ce code.  Oui, il doit effectuer l'ingénierie inverse de votre application et comprendre comment vous cryptez les données des utilisateurs, mais néanmoins.  Si un attaquant est suffisamment motivé, il le fera sans hésitation. </p><br><p>  Le deuxième point concerne les smartphones enracinés.  En ce qui concerne les appareils enracinés, vous pouvez jeter toutes vos tentatives d'assurance de sécurité.  Tout malware avec un accès root peut contourner tous les mécanismes de sécurité.  Par conséquent, vous devez ajouter des fonctionnalités de sécurité et des contrôles supplémentaires à l'application.  Je vous suggère deux choses les plus simples pour atténuer ces défauts: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SafetyNet</a> - il fournit un ensemble de services et d'API qui aident à protéger votre application contre les menaces de sécurité, y compris la falsification d'appareil, les URL incorrectes, les applications potentiellement dangereuses et les faux utilisateurs </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Obfuscation</a> - <strong>n'oubliez pas</strong> que ProGuard <strong>n'est pas</strong> un outil d'obfuscation!  ProGuard concerne la réduction et la réduction des ressources, pas l'obscurcissement ou la sécurité.  Utilisez quelque chose comme DexGuard, DexProtector, etc. </li></ul><br><p>  L'utilisation de SafetyNet et l'obfuscation sont une bonne étape suivante après avoir appliqué les approches de cet article.  Si vous constatez des inexactitudes, des failles de sécurité ou d'autres conneries, faites-le moi savoir.  Vous pouvez trouver tout le code de l'article sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . </p><br><p>  Et la prochaine fois, je vous montrerai comment implémenter une authentification PIN à l'aide d'un back-end.  Restez à l'écoute. </p><br><h3 id="useful-links">  Liens utiles </h3><br><ul><li>  Fonctions KDF: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Argon2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">scrypt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Une approche alternative pour crypter les préférences partagées (RU)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Entropie de l'information</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Travaillez avec les données de manière plus sécurisée</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr475112/">https://habr.com/ru/post/fr475112/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr475098/index.html">Automatisation de l'approvisionnement des affiches cinéma en ligne</a></li>
<li><a href="../fr475100/index.html">Comment utiliser la crypto pour créer un «bien public» sans risque pour les investisseurs</a></li>
<li><a href="../fr475104/index.html">Nous parcourons les modules: Navigation dans une application multi-modules avec Jetpack</a></li>
<li><a href="../fr475106/index.html">Les principales annonces de la conférence Microsoft Ignite 2019</a></li>
<li><a href="../fr475110/index.html">.NET Core avec Jupyter Notebooks - avant-première 1</a></li>
<li><a href="../fr475114/index.html">Présentation de .NET Core 3.1 Preview 2</a></li>
<li><a href="../fr475116/index.html">.NET Core 3 pour Windows Desktop</a></li>
<li><a href="../fr475124/index.html">Cas: Instagram Automation. Vendez-vous via des publications sur les réseaux sociaux?</a></li>
<li><a href="../fr475126/index.html">Moscou Node.js Meetup 10: Architecture des applications Node.js, Hot Reload dans Node.js et un rapport secret</a></li>
<li><a href="../fr475128/index.html">Modélisation NURBS dans Rhino 3D et T-Spline</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>