<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏻 👎 🤽🏽 使用RxJS进行反应式编程的基础。 第2部分。操作员和管道 🙋🏼 🧕 ☦️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在上一篇文章中，我们研究了什么是溪流以及它们与之一起吃。 在新部分中，我们将熟悉RxJS提供的用于创建流的方法，什么是运算符，管道以及如何使用它们。 

 系列文章“使用RxJS进行反应式编程的基础知识”： 



- 第1部分。反应性和流量 
- 第3部分。高阶可观察物 

 RxJS具有丰富的A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用RxJS进行反应式编程的基础。 第2部分。操作员和管道</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444290/"><img src="https://habrastorage.org/webt/rj/7g/bm/rj7gbmr84swtbidqadkbgh5bg3q.png"><br><br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章中，</a>我们研究了什么是溪流以及它们与之一起吃。 在新部分中，我们将熟悉RxJS提供的用于创建流的方法，什么是运算符，管道以及如何使用它们。 <br><br> 系列文章“使用RxJS进行反应式编程的基础知识”： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分。反应性和流量</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3部分。高阶可观察物</a> </li></ul><br><br>  RxJS具有丰富的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">API</a> 。 该文档描述了一百多种方法。 为了稍微了解它们，我们将编写一个简单的应用程序，在实践中，我们将看到反应式代码的外观。 您会发现，如果您从反应性的角度看这些相同的任务，这些任务以前看起来像是例行的工作，需要编写大量代码，但它们是一个不错的解决方案。 但是在开始实践之前，我们将研究如何以图形方式表示流程，并熟悉用于创建和处理流程的便捷方法。 <a name="habracut"></a><br><br><h4> 线程的图形表示 </h4><br> 为了清楚地说明特定流程的行为，我将使用反应式方法中采用的符号。 回顾上一篇文章中的示例： <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { observer.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); observer.next(<span class="hljs-number"><span class="hljs-number">2</span></span>); observer.complete(); });</code> </pre> <br> 以下是其图形表示形式： <br><br><img src="https://habrastorage.org/webt/2p/57/dp/2p57dpdbntj2zamojjekvgxfp08.png"><br><br> 流程通常描绘为一条直线。 如果流发出任何值，则将其在线上显示为圆圈。 显示屏中的一条直线是结束流的信号。 要显示错误，请使用符号-“×”。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { observer.error(); });</code> </pre><br><img src="https://habrastorage.org/webt/qo/7i/ut/qo7iutxhycufjmujmhhbvjzxz5w.png"><br><br><h4> 一线流 </h4><br> 在我的实践中，我很少需要直接创建自己的Observable实例。 大多数创建线程的方法已经在RxJS中。 要创建一个发出值1和2的流，使用of方法就足够了： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  of方法接受任意数量的参数，并返回Observable的完成实例。 订阅后，它将发出接收到的值并完成： <br><br><img src="https://habrastorage.org/webt/2p/57/dp/2p57dpdbntj2zamojjekvgxfp08.png"><br><br> 如果要将数组表示为流，则可以使用from方法。  from方法作为参数需要任何可迭代的对象（数组，字符串等）或promise，并将该对象投影到流上。 这是从字符串获得的流的样子： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(<span class="hljs-string"><span class="hljs-string">'abc'</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/y7/ky/nd/y7kynd1a6oolkik-adnjnriav6e.png"><br><br> 因此，您可以在流中包装一个Promise： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(promise);</code> </pre><br><img src="https://habrastorage.org/webt/rc/us/sr/rcussrgfjolqzykg9ao3lkj_aj4.png"><br><br>  <b>注意：</b>经常将线程与promise进行比较。 实际上，它们只有一个共同点-一种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">推动</a>变更传播的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">策略</a> 。 其余的是完全不同的实体。  Promise不能产生多个值。 它只能执行解决或拒绝操作，即 只有两个状态。 流可以传输多个值，并且可以重用。 <br><br> 您还记得与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一篇文章</a>间隔时间的示例吗？ 此流是一个计时器，用于计算从订阅时刻起的秒数。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { observer.next(counter++); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { clearInterval(intervalId); } });</code> </pre><br> 这是您可以在一行中实现相同内容的方法： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/yd/ju/ks/ydjuksn4esnkrup6euizzcnqwm8.png"><br><br> 最后，是一种允许您为DOM元素创建事件流的方法： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = fromEvent(domElementRef, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>);</code> </pre><br> 作为值，此流将接收和发射keyup事件对象。 <br><br><h4> 管道和操作员 </h4><br>  Pipe是在5.5版的RxJS中添加的Observable类方法。 多亏了它，我们可以构建运算符链来顺序处理流中接收到的值。 管道是连接操作员的单向通道。 运算符本身是RxJS中描述的常规函数​​，用于处理流中的值。 <br><br> 例如，他们可以转换该值并将其进一步传递到流，或者它们可以充当过滤器，并且如果它们不满足指定条件，则不会跳过任何值。 <br><br> 让我们看看实际的运算符。 使用map运算符将流中的每个值乘以2： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value * <span class="hljs-number"><span class="hljs-number">2</span></span>) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br> 这是应用地图运算符之前流的外观： <br><br><img src="https://habrastorage.org/webt/ns/a_/fh/nsa_fhvt6qqz_yktb4yl4jgac-k.png"><br><br> 在map语句之后： <br><br><img src="https://habrastorage.org/webt/5_/vt/ku/5_vtku2aaynipw8jt4gae9iotlc.png"><br><br> 让我们使用过滤器运算符。 该语句的工作原理与Array类中的filter函数类似。 该方法将函数作为第一个参数，该参数描述一个条件。 如果流中的值满足条件，则将其传递： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>).pipe( <span class="hljs-comment"><span class="hljs-comment">//     filter(value =&gt; value % 2 !== 0), map(value = value * 2) ).subscribe({ next: console.log });</span></span></code> </pre><br> 这是我们流的整个方案的外观： <br><br><img src="https://habrastorage.org/webt/ke/ne/wm/kenewmpioakcrwofit2b2x2k-je.png"><br><br> 过滤后： <br><br><img src="https://habrastorage.org/webt/l1/xr/z1/l1xrz1kaxs96xuz7t35k_6safny.png"><br><br> 后图： <br><br><img src="https://habrastorage.org/webt/uv/za/va/uvzavasqypswdfiqk51esahuu0g.png"><br><br>  <b>注意：</b>管道！==订阅。 管道方法声明流行为，但不订阅。 在调用subscribe方法之前，流将无法开始工作。 <br><br><h4> 我们正在编写一个应用程序 </h4><br> 既然我们已经弄清楚了什么是管道和操作员，那么您就可以开始练习了。 我们的应用程序将执行一个简单的任务：根据所有者的昵称显示打开的github存储库列表。 <br><br> 将有一些要求： <br><br><ul><li> 如果输入的字符串少于3个字符，则不要执行API请求； </li><li> 为了不满足用户输入的每个字符的请求，应在访问API之前将反跳延迟设置为700毫秒。 </li></ul><br> 要搜索存储库，我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">github API</a> 。 我建议自己在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">stackblitz</a>上运行示例。 在那里，我列出了完成的实现。 文章末尾提供了链接。 <br><br> 让我们从html标记开始。 让我们描述输入和ul元素： <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br> 然后，在js或ts文件中，我们使用浏览器API获取到当前元素的链接： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'input'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ul = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'ul'</span></span>);</code> </pre><br> 我们还需要一种将执行对github API的请求的方法。 以下是getUsersRepsFromAPI函数的代码，该函数接受用户的昵称并使用访存执行ajax请求。 然后返回一个promise，将成功的响应转换为json： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getUsersRepsFromAPI = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">username</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">`https://api.github.com/users/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ username }</span></span></span><span class="hljs-string">/repos`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(url) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(response.ok) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json(); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">''</span></span>); }); }</code> </pre><br> 接下来，我们编写一个方法，该方法将列出存储库的名称： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> recordRepsToList = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; reps.length; i++) { <span class="hljs-comment"><span class="hljs-comment">//    ,    if (!ul.children[i]) { const newEl = document.createElement('li'); ul.appendChild(newEl); } //      const li = ul.children[i]; li.innerHTML = reps[i].name; } //    while (ul.children.length &gt; reps.length) { ul.removeChild(ul.lastChild); } }</span></span></code> </pre><br> 准备工作已经完成。 现在该看看实际使用的RxJS。 我们需要监听输入的keyup事件。 首先，我们必须了解，以被动方式，我们要与流程一起工作。 幸运的是，RxJS已经提供了类似的选项。 记住我上面提到的fromEvent方法。 我们使用它： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keyUp = fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>); keyUp.subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br> 现在，我们的事件以流的形式呈现。 如果我们查看控制台中显示的内容，我们将看到一个KeyboardEvent类型的对象。 但是我们需要一个用户输入的值。 这是管道方法和地图运算符派上用场的地方： <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br> 我们着手执行要求。 首先，当输入的值包含两个以上字符时，我们将执行查询。 为此，请使用过滤器运算符： <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) )</code> </pre><br> 我们处理了第一个要求。 我们继续第二个。 我们需要实施去抖动。  RxJS有一个debounceTime语句。 该运算符作为第一个参数采用毫秒数，在该毫秒数内，值将在传递之前保持不变。 在这种情况下，每个新值都会重置计时器。 因此，在输出处我们得到了最后一个值，此后经过了700毫秒。 <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) )</code> </pre><br> 没有debounceTime的情况下，我们的流可能是这样的： <br><br><img src="https://habrastorage.org/webt/c4/tl/lc/c4tllccvfohixydheaohwj2wcvy.png"><br><br> 这就是通过此语句传递的相同流的样子： <br><br><img src="https://habrastorage.org/webt/o0/lg/lx/o0lglx4knoa6ulhkaafuvxyhl1o.png"><br><br> 使用debounceTime，我们将不太可能使用该API，这将节省流量并减轻服务器的负担。 <br><br> 为了进行其他优化，我建议使用另一个运算符-distingutilChanged。 这种方法可以避免重复。 最好使用一个示例来展示其工作： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(<span class="hljs-string"><span class="hljs-string">'aaabccc'</span></span>).pipe( distinctUntilChanged() )</code> </pre><br> 如果没有distinctUntilChanged： <br><br><img src="https://habrastorage.org/webt/ti/ng/7j/ting7jpkqbe1bgfb713x5wleaki.png"><br><br> 带有distinctUntilChanged： <br><br><img src="https://habrastorage.org/webt/kv/is/-1/kvis-1lx1hwylsyg4dfvuf4tgoa.png"><br><br> 在debounceTime语句之后立即添加此语句。 因此，如果由于某种原因新值与前一个值一致，我们将不会访问API。 当用户输入新字符然后再次擦除它们时，可能会发生类似情况。 由于我们实施了延迟，因此只有最后一个值会落入流中，这是我们已经拥有的答案。 <br><br><h4> 转到服务器 </h4><br> 现在我们已经可以描述请求的逻辑和响应的处理。 虽然我们只能与承诺合作。 因此，我们描述了另一个将调用getUsersRepsFromAPI方法的地图运算符。 在观察者中，我们描述了承诺的处理逻辑： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*  !     RxJS    promise,      */</span></span> fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> getUsersRepsFromAPI(value)) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">promise</span></span></span><span class="hljs-function"> =&gt;</span></span> promise.then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps)) });</code> </pre><br> 目前，我们已经实现了我们想要的一切。 但是我们的示例有一个很大的缺点：没有错误处理。 我们的观察者只得到一个诺言，却不知道会出问题。 <br><br> 当然，我们可以在下一个方法中实现承诺，但是由于这个原因，我们的代码将越来越像“回调地狱”。 如果突然我们需要再执行一个请求，那么代码的复杂性将会增加。 <br><br>  <b>注意：</b>在RxJS代码中使用promise被认为是反模式。 与可观察的相比，承诺有许多缺点。 它无法撤消，也不能重复使用。 如果您有选择，请选择可观察的。  Observable类的toPromise方法也是如此。 实现此方法是为了与无法与流一起使用的库兼容。 <br><br> 我们可以使用from方法将promise投影到流上，但是此方法充满了对subscription方法的其他调用，并且还会导致代码的增长和复杂性。 <br><br> 可以使用mergeMap运算符解决此问题： <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value))) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log })</code> </pre><br> 现在我们不需要编写承诺处理逻辑。  from方法生成一个承诺流，并由mergeMap运算符对其进行处理。 如果成功实现了诺言，则调用下一个方法，观察者将收到完成的对象。 如果发生错误，将调用error方法，并且我们的观察者将在控制台中输出错误。 <br><br>  mergeMap运算符与我们之前使用的运算符略有不同；它属于所谓的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">高阶Observables</a> ，我将在下一篇文章中进行讨论。 但是，展望未来，我会说mergeMap方法本身订阅了流。 <br><br><h4> 错误处理 </h4><br> 如果我们的线程收到错误，则它将终止。 而且，如果我们在发生错误后尝试与应用程序进行交互，则由于线程已完成，因此我们将不会得到任何反应。 <br><br> 在这里catchError运算符将为我们提供帮助。 仅当流中发生错误时才引发catchError。 它允许您拦截它，对其进行处理并返回流中的常规值，这不会导致其完成。 <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value))), catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log })</code> </pre><br> 我们在catchError中捕获错误，而是返回带有空数组的流。 现在，当发生错误时，我们将清除存储库列表。 但是随后流程再次结束。 <br><br> 问题是catchError用新的替换了我们原来的流。 然后我们的观察者只听他的话。 当of流发出一个空数组时，将调用complete方法。 <br><br> 为了不替换原始线程，我们从mergeMap运算符内部的from线程调用catchError运算符。 <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value)).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ) }) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log })</code> </pre><br> 因此，我们的原始流将不会注意到任何东西。 而不是错误，它将获得一个空数组。 <br><br><h4> 结论 </h4><br> 我们终于开始练习，并了解管道和操作员的用途。 我们研究了如何使用RxJS提供的丰富API减少代码。 当然，我们的应用程序尚未完成，在下一部分中，我们将分析如何在一个线程中处理另一个线程，以及如何取消我们的http请求，以节省应用程序的更多流量和资源。 为了让您看到其中的区别，我列出了一个不使用RxJS的示例，您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">在此处</a>看到它。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">此链接中，</a>您将找到当前应用程序的完整代码。 为了生成电路，我使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">RxJS可视化工具</a> 。 <br><br> 希望本文能帮助您更好地了解RxJS的工作原理。 祝您学习顺利！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN444290/">https://habr.com/ru/post/zh-CN444290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN444278/index.html">如何使成千上万的人阅读针对Habr的英语文章：3个简单技巧</a></li>
<li><a href="../zh-CN444282/index.html">7个用于学习英语的Chrome扩展程序</a></li>
<li><a href="../zh-CN444284/index.html">作曲家和命令行完成</a></li>
<li><a href="../zh-CN444286/index.html">PTZ摄像机解析：内部内容及其工作方式</a></li>
<li><a href="../zh-CN444288/index.html">新的移动应用程序LampTest.ru</a></li>
<li><a href="../zh-CN444294/index.html">俄罗斯公务航空的运作方式（FBO中心）</a></li>
<li><a href="../zh-CN444296/index.html">为美国，德国和加拿大的潜在移民提供6种有用的资源和服务</a></li>
<li><a href="../zh-CN444298/index.html">科学家称他们可以重塑活体恐龙5年</a></li>
<li><a href="../zh-CN444300/index.html">莫斯科交易所交易和清算系统架构的演变。 第一部分</a></li>
<li><a href="../zh-CN444302/index.html">莫斯科交易所交易和清算系统架构的演变。 第二部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>