<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏽 🕓 👸🏾 VVVVVV ??? VVVVVV !!! :) 🤯 👨🏻‍⚕️ 🛁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si vous lisez ce texte, cela signifie que vous avez pensé que quelque chose n'allait pas avec le titre de l'article, ou que vous y avez vu le nom d'un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>VVVVVV ??? VVVVVV !!! :)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/484166/">  Si vous lisez ce texte, cela signifie que vous avez pensé que quelque chose n'allait pas avec le titre de l'article, ou que vous y avez vu le nom d'un jeu informatique familier.  VVVVVV est un jeu de plateforme indépendant qui a conquis le cœur de nombreux joueurs avec sa simplicité externe agréable et sa complexité interne tout aussi agréable.  Il y a quelques jours, VVVVVV a eu 10 ans, et l'auteur du jeu - Terry Cavanagh - a célébré cette fête avec la publication de son code source.  Qu'est-ce qui est «savoureux»?  Lisez la réponse dans cet article. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/i1/ij/g8/i1ijg8lekultgdxwi426mbnaers.png" alt="Figure 1"></div><br><a name="habracut"></a><br><h2>  Présentation </h2><br>  Oh, VVVVVV ... Je me souviens comment je l'ai rencontré peu de temps après la sortie, et, étant un grand fan de jeux rétro pixel, je l'ai heureusement installé sur mon ordinateur.  Je me souviens de mes premières impressions: «Et alors, c'est tout?  Il suffit de courir dans les pièces carrées? »J'ai pensé après quelques minutes de jeu.  Je ne savais pas encore ce qui m'attendait.  Dès que j'ai quitté le lieu de départ, je me suis retrouvé dans un monde bidimensionnel petit mais confus et orné, plein de paysages inhabituels et d'artefacts de pixels inconnus de moi. <br><br>  Ce jeu m'a entraîné.  Malgré la grande complexité, habilement battue par le contrôle inhabituel de l'époque (le personnage principal ne sait pas sauter, mais est capable d'inverser la direction du vecteur de gravité pour moi), je l'ai complètement dépassé.  Je ne sais pas combien de fois mon personnage est mort à ce moment-là, mais je suis sûr que le nombre de morts se mesure en dizaines de centaines.  Pourtant, il y a un charme unique dans ce jeu :) <br><br>  Revenons au code source <a href="https://habr.com/ru/post/483518/">présenté en l'honneur de l'anniversaire du jeu</a> . <br><br>  En ce moment, je suis C ++ - le développeur de l'équipe PVS-Studio - un analyseur de code statique pour C, C ++, C # et Java.  En plus du développement lui-même, nous sommes également engagés dans la promotion de notre produit.  Pour nous, l'une des meilleures façons de le faire est d'écrire des articles sur la vérification des projets open source.  Nos lecteurs reçoivent des articles intéressants sur des sujets de programmation, et nous avons l'occasion de démontrer clairement les capacités de PVS-Studio.  Par conséquent, lorsque j'ai appris l'ouverture du code source VVVVVV, je ne pouvais tout simplement pas passer. <br><br>  Dans cet article, nous examinerons quelques erreurs intéressantes trouvées par l'analyseur PVS-Studio dans le code VVVVVV, ainsi qu'une analyse détaillée de ces erreurs.  Remettez le vecteur de gravité en position «basse» et asseyez-vous: nous commençons! <br><br><h2>  Aperçu des alertes émises par l'analyseur </h2><br><h3>  Avertissement 1 </h3><br>  <a href="https://www.viva64.com/ru/w/v512/">V512</a> Un appel de la fonction 'sprintf' entraînera un débordement de la mémoire tampon 'fileSearch'.  FileSystemUtils.cpp 307 <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_PATH 260 .... void PLATFORM_migrateSaveData(char *output) { char oldLocation[MAX_PATH]; char newLocation[MAX_PATH]; char oldDirectory[MAX_PATH]; char fileSearch[MAX_PATH]; .... </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Same place, different layout. */</span></span></span><span class="hljs-meta"> strcpy(oldDirectory, output); sprintf(fileSearch, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s\\*.vvvvvv"</span></span></span><span class="hljs-meta">, oldDirectory); .... }</span></span></code> </pre> <br>  Comme vous pouvez le voir, les <i>lignes</i> <i>fileSearch</i> et <i>oldDirectory</i> ont la même taille: 260 caractères.  La chaîne de formatage (le troisième argument de <i>sprintf</i> ) après avoir remplacé le contenu de la chaîne <i>oldDirectory</i> en elle ressemblera à ceci: <br><br><pre> <code class="cpp hljs">&lt;i&gt;_oldDirectory\*.vvvvvv&lt;/i&gt;</code> </pre> <br>  Cette chaîne fait 9 caractères de plus que l'ancien <i>répertoire d'</i> origine.  C'est cette séquence de caractères qui sera ensuite écrite dans <i>fileSearch</i> .  Que se passe-t-il si la chaîne <i>oldDirectory</i> dépasse 251?  La chaîne résultante sera plus longue que <i>fileSearch</i> ne peut accepter, ce qui entraînera l'écriture en dehors du tableau.  Quel type de données dans la RAM peut être endommagé et quel résultat cela conduira à une question rhétorique :) <br><br><h3>  Avertissement 2 </h3><br>  <a href="https://www.viva64.com/ru/w/v519/">V519</a> La variable 'background' reçoit des valeurs successives deux fois.  C'est peut-être une erreur.  Vérifier les lignes: 1367, 1373. Map.cpp 1373 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> mapclass::loadlevel(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-comment"><span class="hljs-comment">//The Warpzone tmap = warplevel.loadlevel(rx, ry, game, obj); fillcontent(tmap); roomname = warplevel.roomname; tileset = 1; background = 3; // &lt;= dwgfx.rcol = warplevel.rcol; dwgfx.backgrounddrawn = false; warpx = warplevel.warpx; warpy = warplevel.warpy; background = 5; // &lt;= if (warpy) background = 4; if (warpx) background = 3; if (warpx &amp;&amp; warpy) background = 5; break; .... }</span></span></code> </pre> <br>  Une même variable se voit attribuer une valeur deux fois de suite.  De plus, entre les affectations, cette variable n'est utilisée nulle part.  Étrange ... Peut-être que cette séquence ne viole pas la logique du programme, mais de telles affectations en elles-mêmes parlent d'une certaine confusion lors de l'écriture de code.  Que ce soit réellement une erreur ne peut être dit que par l'auteur.  Bien qu'il existe des exemples plus brillants de cette erreur dans le code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::loadquick(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pKey == <span class="hljs-string"><span class="hljs-string">"frames"</span></span>) { frames = atoi(pText); frames = <span class="hljs-number"><span class="hljs-number">0</span></span>; } .... }</code> </pre> <br>  Il est déjà clair ici que quelque part ici se trouve soit une erreur de logique, soit au moins une affectation inutile.  Peut-être que la deuxième ligne a été écrite temporairement pour le débogage, puis ils ont oublié de la supprimer.  Au total, PVS-Studio a émis 8 avertissements concernant de telles situations. <br><br><h3>  Avertissement 3 </h3><br>  <a href="https://www.viva64.com/ru/w/v808/">V808</a> L'objet 'pKey' de type 'basic_string' a été créé mais n'a pas été utilisé.  editor.cpp 1866 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> editorclass::load(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;_path) { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pElem-&gt;Value())</span></span></span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pKey == <span class="hljs-string"><span class="hljs-string">"edEntities"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (TiXmlElement *edEntityEl = pElem-&gt;FirstChildElement(); edEntityEl; edEntityEl = edEntityEl-&gt;NextSiblingElement()) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(edEntityEl-&gt;Value())</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= //const char* pText = edEntityEl-&gt;GetText() ; if (edEntityEl-&gt;GetText() != NULL) { edentity[i].scriptname = std::string(edEntityEl-&gt;GetText()); } edEntityEl-&gt;QueryIntAttribute("x", &amp;edentity[i].x); edEntityEl-&gt;QueryIntAttribute("y", &amp;edentity[i].y); edEntityEl-&gt;QueryIntAttribute("t", &amp;edentity[i].t); edEntityEl-&gt;QueryIntAttribute("p1", &amp;edentity[i].p1); edEntityEl-&gt;QueryIntAttribute("p2", &amp;edentity[i].p2); edEntityEl-&gt;QueryIntAttribute("p3", &amp;edentity[i].p3); edEntityEl-&gt;QueryIntAttribute("p4", &amp;edentity[i].p4); edEntityEl-&gt;QueryIntAttribute("p5", &amp;edentity[i].p5); edEntityEl-&gt;QueryIntAttribute("p6", &amp;edentity[i].p6); i++; } EditorData::GetInstance().numedentities = i; } .... }</span></span></code> </pre> <br>  Code très bizarre.  L'analyseur met en garde contre la variable <i>pKey</i> créée mais non utilisée, mais en fait, le problème s'est avéré plus intéressant.  J'ai spécifiquement marqué d'une flèche la ligne sur laquelle l'avertissement a été émis, car cette fonction contient plusieurs définitions de ligne avec le nom <i>pKey</i> .  Oui, une autre variable de ce type est déclarée à l'intérieur de la boucle <i>for</i> et, par son nom, elle chevauche celle déclarée à l'extérieur de la boucle. <br><br>  Ainsi, si vous accédez à la valeur de la chaîne <i>pKey en</i> dehors de la boucle <i>for</i> , vous obtiendrez une valeur égale à <i>pElem-&gt; Value ()</i> , mais si vous faites de même à l'intérieur de la boucle, vous obtiendrez une valeur égale à <i>edEntityEl-&gt; Value ()</i> .  Le chevauchement des noms est une erreur plutôt grossière, qui peut être très difficile à trouver par vous-même lors de la révision du code. <br><br><h3>  Avertissement 4 </h3><br>  Performances <a href="https://www.viva64.com/ru/w/v805/">réduites du V805</a> .  Il est inefficace d'identifier une chaîne vide en utilisant la construction 'strlen (str)&gt; 0'.  Un moyen plus efficace consiste à vérifier: str [0]! = '\ 0'.  physfs.c 1604 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *prefDir = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PHYSFS_getPrefDir</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *org, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *app)</span></span></span><span class="hljs-function"> </span></span>{ .... assert(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(prefDir) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prefDir; } <span class="hljs-comment"><span class="hljs-comment">/* PHYSFS_getPrefDir */</span></span></code> </pre> <br>  L'analyseur a trouvé une place pour une microoptimisation potentielle.  Il utilise la fonction <i>strlen</i> pour vérifier une chaîne de style C pour void.  Cette fonction "parcourt" tous les éléments de la chaîne et vérifie chacun pour leur égalité au terminal zéro ('\ 0').  Si une grande chaîne est entrée, chacun de ses caractères sera toujours comparé à une chaîne zéro. <br><br>  Mais il suffit de vérifier que la chaîne n'est pas vide!  Pour ce faire, découvrez simplement si le premier caractère de la chaîne est un zéro terminal.  Par conséquent, pour optimiser cette vérification à l'intérieur de l'assertion, vous devez écrire: <br><br><pre> <code class="cpp hljs">str[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'\0'</span></span></code> </pre> <br>  C'est la recommandation que l'analyseur nous donne.  Bien sûr, l'appel de la fonction strlen est dans la condition de macro <i>assert</i> , il ne sera donc exécuté que dans la version de débogage, où la vitesse n'est pas si importante.  Dans la version finale, l'appel de fonction disparaîtra et le code fonctionnera rapidement.  Néanmoins, j'ai voulu démontrer les capacités de l'analyseur à proposer des microoptimisations. <br><br><h3>  Avertissement 5 </h3><br>  Pour afficher l'erreur suivante, j'ai besoin de joindre deux <i>morceaux</i> de code ici: la déclaration de la classe <i>entclass</i> et son constructeur.  Commençons par l'annonce: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entclass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: entclass(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outside</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Fundamentals bool active, invis; int type, size, tile, rule; int state, statedelay; int behave, animate; float para; int life, colour; //Position and velocity int oldxp, oldyp; float ax, ay, vx, vy; int cx, cy, w, h; float newxp, newyp; bool isplatform; int x1, y1, x2, y2; //Collision Rules int onentity; bool harmful; int onwall, onxwall, onywall; //Platforming specific bool jumping; bool gravity; int onground, onroof; int jumpframe; //Animation int framedelay, drawframe, walkingframe, dir, actionframe; int yp; int xp; };</span></span></code> </pre> <br>  Le constructeur de cette classe ressemble à ceci: <br><br><pre> <code class="cpp hljs">entclass::entclass() { clear(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> entclass::clear() { <span class="hljs-comment"><span class="hljs-comment">// Set all values to a default, // required for creating a new entity active = false; invis = false; type = 0; size = 0; tile = 0; rule = 0; state = 0; statedelay = 0; life = 0; colour = 0; para = 0; behave = 0; animate = 0; xp = 0; yp = 0; ax = 0; ay = 0; vx = 0; vy = 0; w = 16; h = 16; cx = 0; cy = 0; newxp = 0; newyp = 0; x1 = 0; y1 = 0; x2 = 320; y2 = 240; jumping = false; gravity = false; onground = 0; onroof = 0; jumpframe = 0; onentity = 0; harmful = false; onwall = 0; onxwall = 0; onywall = 0; isplatform = false; framedelay = 0; drawframe = 0; walkingframe = 0; dir = 0; actionframe = 0; }</span></span></code> </pre> <br>  Assez de champs, non?  Il n'est pas surprenant qu'une erreur se cache ici, à laquelle PVS-Studio a émis un avertissement: <br><br>  <a href="https://www.viva64.com/ru/w/v730/">V730</a> Il est possible que tous les membres d'une classe ne soient pas initialisés à l'intérieur du constructeur.  Pensez à inspecter: oldxp, oldyp.  Ent.cpp 3 <br><br>  Comme vous pouvez le voir, dans une liste si grande, l'initialisation de deux champs de la classe a été perdue.  Ainsi, leurs valeurs sont restées indéfinies, à cause de quoi, ailleurs dans le programme, une valeur inconnue peut être lue et utilisée à partir d'eux.  Il est très difficile de détecter une telle erreur à travers les yeux. <br><br><p><img src="https://habrastorage.org/webt/mi/8n/du/mi8nduqzzi75r1jhntbsqwarlns.png" alt="Figure 2"></p><br><br><h3>  Avertissement 6 </h3><br>  Considérez le code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> mapclass::loadlevel(....) { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; tmap; .... tmap = otherlevel.loadlevel(rx, ry, game, obj); fillcontent(tmap); .... <span class="hljs-comment"><span class="hljs-comment">//  tmap    . }</span></span></code> </pre> <br>  Avertissement PVS-studio: V688 La variable locale 'tmap' possède le même nom que l'un des membres de la classe, ce qui peut entraîner une confusion.  Map.cpp 1192 <br><br>  En effet, si vous regardez à l'intérieur de la classe <i>mapclass</i> , vous pouvez y trouver le même vecteur avec le même nom: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mapclass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; roomdeaths; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; roomdeathsfinal; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; areamap; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; contents; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; explored; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vmult; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; tmap; <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... };</span></span></code> </pre> <br>  Malheureusement, déclarer un vecteur du même nom dans une fonction rend le vecteur déclaré dans la classe invisible.  Il s'avère que dans toute la fonction de niveau de <i>charge, le</i> vecteur <i>tmap</i> ne change qu'à l'intérieur de la fonction.  Le vecteur déclaré dans la classe reste inchangé! <br><br>  Fait intéressant, PVS-Studio a découvert jusqu'à 20 fragments de code de ce type!  Pour la plupart, ils sont associés à des variables temporaires, qui, par commodité, ont été déclarées membres de la classe.  L'auteur du jeu (et son seul développeur) a lui-même écrit qu'il avait cette mauvaise habitude.  Vous pouvez lire à ce sujet dans un article auquel j'ai lié au début de cet article. <br><br>  Il note également qu'une telle dénomination a conduit à des bogues nuisibles et difficiles à attraper.  Eh bien, de tels bugs peuvent vraiment être dangereux, mais utiliser une analyse statique pour les détecter ne sera pas difficile :) <br><br><h3>  Avertissement 7 </h3><br>  <a href="https://www.viva64.com/ru/w/v601/">V601</a> Le type entier est implicitement <a href="https://www.viva64.com/ru/w/v601/">converti en</a> type char.  Game.cpp 4997 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::loadquick(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pKey == <span class="hljs-string"><span class="hljs-string">"totalflips"</span></span>) { totalflips = atoi(pText); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pKey == <span class="hljs-string"><span class="hljs-string">"hardestroom"</span></span>) { hardestroom = atoi(pText); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } else if (pKey == "hardestroomdeaths") { hardestroomdeaths = atoi(pText); } .... }</span></span></code> </pre> <br>  Pour comprendre quel est le problème, regardons les définitions des variables de la section de code donnée: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Some stats: int totalflips; std::string hardestroom; int hardestroomdeaths;</span></span></code> </pre> <br>  Les variables <i>totalflips</i> et <i>hardestroomdeaths</i> sont de type entier, et donc leur attribuer le résultat à la fonction <i>atoi</i> est tout à fait normal.  Mais que se passe-t-il si vous affectez une valeur entière à <i>std :: string</i> ?  Il s'avère que du point de vue de la langue, une telle mission est tout à fait valable.  En conséquence, une valeur incompréhensible sera écrite dans la variable <i>hardestroom</i> ! <br><br><h3>  Avertissement 8 </h3><br>  <a href="https://www.viva64.com/ru/w/v1004/">V1004</a> Le pointeur 'pElem' a été utilisé de manière non sécurisée après avoir été vérifié par rapport à nullptr.  Vérifiez les lignes: 1739, 1744. editor.cpp 1744 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> editorclass::load(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;_path) { .... <span class="hljs-function"><span class="hljs-function">TiXmlHandle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hDoc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;doc)</span></span></span></span>; TiXmlElement *pElem; <span class="hljs-function"><span class="hljs-function">TiXmlHandle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hRoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; version = <span class="hljs-number"><span class="hljs-number">0</span></span>; { pElem = hDoc.FirstChildElement().Element(); <span class="hljs-comment"><span class="hljs-comment">// should always have a valid root // but handle gracefully if it does if (!pElem) { printf("No valid root! Corrupt level file?\n"); } pElem-&gt;QueryIntAttribute("version", &amp;version); // &lt;= // save this for later hRoot = TiXmlHandle(pElem); } .... }</span></span></code> </pre> <br>  L'analyseur avertit que le pointeur <i>pElem est</i> utilisé de manière non sécurisée immédiatement après avoir été vérifié pour <i>nullptr</i> .  Pour vous assurer que l'analyseur a raison, jetez un œil à la définition de la fonction <i>Element ()</i> , dont la valeur de retour initialise le pointeur <i>pElem</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** @deprecated use ToElement. Return the handle as a TiXmlElement. This may return null. */</span></span> <span class="hljs-function"><span class="hljs-function">TiXmlElement *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Element</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ToElement(); }</code> </pre> <br>  Comme vous pouvez le voir dans le commentaire, cette fonction peut retourner <i>null</i> . <br><br>  Imaginez maintenant que cela s'est vraiment produit.  Que se passera-t-il dans ce cas?  Le fait est qu'une telle situation ne sera en aucun cas gérée.  Oui, un message s'affiche indiquant que quelque chose s'est mal passé, mais littéralement une ligne sous le pointeur incorrect sera déréférencée.  Un tel déréférencement, à son tour, entraînera soit un plantage du programme, soit un comportement indéfini.  C'est une erreur assez grave. <br><br><h3>  Avertissement 9 </h3><br>  Dans la section suivante du code, PVS-Studio a émis quatre avertissements: <ul><li>  <a href="https://www.viva64.com/ru/w/v560/">V560</a> Une partie de l'expression conditionnelle est toujours vraie: x&gt; = 0. editor.cpp 1137 </li><li>  <a href="https://www.viva64.com/ru/w/v560/">V560</a> Une partie de l'expression conditionnelle est toujours vraie: y&gt; = 0. editor.cpp 1137 </li><li>  <a href="https://www.viva64.com/ru/w/v560/">V560</a> Une partie de l'expression conditionnelle est toujours vraie: x &lt;40. editor.cpp 1137 </li><li>  <a href="https://www.viva64.com/ru/w/v560/">V560</a> Une partie de l'expression conditionnelle est toujours vraie: y &lt;30. editor.cpp 1137 </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> editorclass::at( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> at(<span class="hljs-number"><span class="hljs-number">0</span></span>,y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(y&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> at(x,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x&gt;=<span class="hljs-number"><span class="hljs-number">40</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> at(<span class="hljs-number"><span class="hljs-number">39</span></span>,y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(y&gt;=<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> at(x,<span class="hljs-number"><span class="hljs-number">29</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; y&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x&lt;<span class="hljs-number"><span class="hljs-number">40</span></span> &amp;&amp; y&lt;<span class="hljs-number"><span class="hljs-number">30</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contents[x+(levx*<span class="hljs-number"><span class="hljs-number">40</span></span>)+vmult[y+(levy*<span class="hljs-number"><span class="hljs-number">30</span></span>)]]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Tous les avertissements s'appliquent à la dernière instruction <i>if</i> .  Le problème est que les quatre vérifications qui y sont effectuées renverront toujours <i>true</i> .  Je ne dirais pas que c'est une grave erreur, mais cela s'est avéré assez drôle.  L'auteur a décidé de prendre cette fonction au sérieux et, au cas où, a de nouveau vérifié chaque variable :) <br><br>  Cette vérification peut être supprimée, car  le thread d'exécution n'atteindra jamais l'expression " <i>return 0;</i> " de toute façon.  Bien que cela ne change pas la logique du programme, cela le libérera des contrôles inutiles et du code mort. <br><br><h3>  Avertissement 10 </h3><br>  Dans son article sur l'anniversaire du jeu, Terry dit avec ironie que l'un des éléments qui contrôlent la logique du jeu était un énorme changement de la fonction <i>Game :: updatestate ()</i> , qui est immédiatement responsable d'un grand nombre d'états de jeu différents.  Et il était assez attendu que je trouve l'avertissement suivant: <br><br>  <a href="https://www.viva64.com/ru/w/v2008/">V2008</a> Complexité cyclomatique: 548. Envisagez de refactoriser la fonction 'Game :: updatestate'.  Game.cpp 612 <br><br>  Oui, vous avez bien compris: PVS-Studio a estimé la complexité cyclomatique d'une fonction à 548 unités.  Cinq cent quarante huit !!!  Je comprends cela - "code soigné".  Et cela malgré le fait qu'en fait, il n'y a rien de plus qu'une expression de commutateur dans une fonction.  Dans le commutateur lui-même, j'ai compté plus de 300 expressions de cas. <br><br>  Dans notre bureau, il y a une petite compétition entre les auteurs pour l'article le plus long.  J'apporterais volontiers tout le code de fonction ici (3450 lignes), mais une telle victoire serait malhonnête, donc je me limiterai à me <a href="">référer</a> simplement à l'énorme commutateur.  Je recommande de le suivre et d'évaluer toute l'échelle vous-même!  Soit dit en passant, en plus de <i>Game :: updatestate ()</i> , PVS-Studio a trouvé jusqu'à 44 fonctions avec une complexité cyclomatique excessive, dont 10 ont une complexité de plus de 200. <br><br><p><img src="https://habrastorage.org/webt/pu/s9/a2/pus9a2tqqeyzmdkg90auf5r2d0q.png" alt="Figure 3"></p><br><br><h2>  Conclusion </h2><br>  Je pense que les erreurs écrites suffisent pour l'article.  Oui, il y a eu beaucoup d'erreurs dans le projet, mais c'est exactement l'astuce: après avoir présenté son code, Terry Cavanagh a montré qu'il n'était pas nécessaire d'être un bon programmeur pour faire un bon jeu.  Maintenant, après 10 ans, Terry se souvient de ces moments avec ironie.  Il est important d'apprendre de vos erreurs et la pratique est la meilleure façon de le faire.  Et si votre pratique peut encore donner naissance à un jeu comme VVVVVVV, alors c'est généralement magnifique!  Ehh ... je vais y aller et je vais probablement y jouer à nouveau :) <br><br>  Ce ne sont pas toutes les erreurs trouvées dans le code du jeu.  Si vous voulez voir par vous-même ce que vous pouvez trouver d'autre, je vous suggère de <a href="https://www.viva64.com/ru/pvs-studio-download/">télécharger et d'essayer PVS-Studio</a> !  N'oubliez pas non plus que pour les projets open source, nous <a href="https://www.viva64.com/ru/b/0614/">fournissons une</a> licence gratuite. <br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/484388/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: George Gribkov.  <a href="https://habr.com/en/company/pvs-studio/blog/484388/">VVVVVV ???</a>  <a href="https://habr.com/en/company/pvs-studio/blog/484388/">VVVVVV !!!</a>  <a href="https://habr.com/en/company/pvs-studio/blog/484388/">:)</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484166/">https://habr.com/ru/post/fr484166/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484150/index.html">5 nouveaux outils pour créer du contenu amusant</a></li>
<li><a href="../fr484152/index.html">Contrôleur PAC haute vitesse WISE-5580</a></li>
<li><a href="../fr484154/index.html">Méthode de résolution du système d'équations diophantiennes</a></li>
<li><a href="../fr484160/index.html">Talent insaisissable: la Russie perd les meilleurs professionnels de l'informatique</a></li>
<li><a href="../fr484164/index.html">L'histoire du livre et l'avenir des bibliothèques</a></li>
<li><a href="../fr484168/index.html">Nous écrivons notre stratégie de défilement virtuel depuis Angular CDK</a></li>
<li><a href="../fr484170/index.html">Mettre à jour Check Point de R77.30 à 80.20</a></li>
<li><a href="../fr484172/index.html">Intégration continue dans Unity: comment réduire le temps d'assemblage et économiser des ressources + ligne de paiement en cadeau</a></li>
<li><a href="../fr484174/index.html">Castle buvant dans des conditions "extrêmes" ou comment nous avons participé au spectacle "DOZOR"</a></li>
<li><a href="../fr484176/index.html">Implémentation du modèle de statut dans Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>