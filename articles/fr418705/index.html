<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìü üçç üéç Les bases de Futex üí£ üéÖ üë™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Futex (futex - abr√©viation de "Fast userspace mutex") est un m√©canisme propos√© par les d√©veloppeurs Linux d'IBM en 2002 et entr√© dans le noyau fin 200...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les bases de Futex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/418705/">  Futex (futex - abr√©viation de "Fast userspace mutex") est un m√©canisme propos√© par les d√©veloppeurs Linux d'IBM en 2002 et entr√© dans le noyau fin 2003.  L'id√©e principale √©tait de fournir un moyen plus efficace de synchroniser les threads utilisateur avec un nombre minimum d'appels au noyau du syst√®me d'exploitation. <br><br>  Dans cet article, nous allons passer en revue les futex, essayer de comprendre les principes de leur travail et les utiliser √©galement comme briques pour construire des objets de synchronisation de niveau sup√©rieur (et qui nous sont familiers). <br><br>  Un point important: les futexes sont un outil de bas niveau; il vaut la peine de l'utiliser directement uniquement lors du d√©veloppement de biblioth√®ques fondamentales, comme la biblioth√®que standard C / C ++.  Il est tr√®s peu probable que vous ayez besoin d'utiliser des futex dans une application r√©guli√®re. <br><a name="habracut"></a><br><h3>  La motivation </h3><br>  Avant l'av√®nement des futex, il √©tait n√©cessaire de faire des appels syst√®me (en utilisant, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">semop</a> ) √† chaque fois pour contr√¥ler l'acc√®s aux ressources partag√©es √† partir de plusieurs threads, ce qui, comme vous le savez, est gourmand en ressources, car chaque appel n√©cessite de basculer le contexte du mode utilisateur vers le mode noyau.  Avec l'augmentation du nombre de c≈ìurs dans les processeurs modernes et l'augmentation du nombre de threads dans les logiciels d'application, cela est devenu un probl√®me important.  C'est encore plus ¬´offensant¬ª, √©tant donn√© que tous ces appels ne portent aucune fonction appliqu√©e, ne mettent en ≈ìuvre aucune logique m√©tier, mais garantissent uniquement le bon fonctionnement du reste du code. <br><br>  La proposition d'ajouter un nouveau concept de ¬´futex¬ª au syst√®me d'exploitation reposait sur une simple observation: dans la plupart des cas, une tentative de capture d'un objet de synchronisation r√©ussit la premi√®re fois.  Les programmeurs √©crivent le logiciel de mani√®re √† ce que le plus de temps possible passe du verrouillage au d√©verrouillage, ce qui signifie qu'il y a de tr√®s grandes chances qu'une tentative de capture d'un autre thread ne rencontre pas d'obstacles.  Lorsqu'un flux atteint un tel objet de synchronisation ¬´gratuit¬ª, nous pouvons le capturer sans effectuer d'appel syst√®me en utilisant des op√©rations atomiques relativement bon march√©.  Et il y a de tr√®s grandes chances que l'op√©ration atomique r√©ussisse. <br><br>  Dans ce cas rare, lorsque nous essayons toujours d'acc√©der √† une ressource bloqu√©e par un autre thread, une op√©ration atomique renvoie une erreur.  Dans ce cas, nous avons deux options.  Nous pouvons soit tourner dans un spin-lock du mode utilisateur, en attendant la lib√©ration de la ressource (qui va manger les ressources CPU), soit demander au noyau de nous mettre en mode veille, en attendant la lib√©ration de la ressource.  C'est l√† que les futex entrent en sc√®ne. <br><br><h3>  Utilisation simple des futex - attente et √©veil </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'appel syst√®me futex</a> combine une grande vari√©t√© de fonctionnalit√©s.  Nous ne consid√©rerons pas ici les options complexes (certaines d'entre elles sont si √©labor√©es qu'elles ne sont m√™me pas d√©crites dans la documentation officielle), mais nous nous concentrerons sur les op√©rations FUTEX_WAIT et FUTEX_WAKE.  La description dans la documentation officielle servira de bonne base: <br><blockquote>  L'appel syst√®me futex () fournit aux programmes une m√©thode pour attendre qu'une certaine condition devienne vraie.  En r√®gle g√©n√©rale, cet appel syst√®me utilise une construction de blocage dans le contexte de la synchronisation de la m√©moire partag√©e.  Lors de l'utilisation de futex, les principales op√©rations de synchronisation sont effectu√©es dans l'espace utilisateur.  Les programmes de l'espace utilisateur ex√©cutent l'appel syst√®me futex () uniquement lorsqu'il est n√©cessaire que le programme passe en mode veille pendant une longue p√©riode jusqu'√† ce que la condition devienne vraie.  En outre, futex () peut √™tre utilis√© pour r√©veiller des processus ou des threads qui attendent une condition sp√©cifique. </blockquote>  Autrement dit, un futex est une construction de noyau qui aide le code utilisateur √† synchroniser les threads en cas de probl√®me.  Certains processus (ou threads) peuvent attendre des √©v√©nements dans un appel FUTEX_WAIT, tandis que d'autres peuvent appeler ces √©v√©nements avec FUTEX_WAKE.  L'attente fonctionne efficacement - les threads en attente sont suspendus par le noyau et n'utilisent pas les ressources du processeur jusqu'√† ce qu'ils soient r√©veill√©s lorsqu'un √©v√©nement attendu se produit. <br><br>  Prenez le temps de lire la documentation dans son int√©gralit√©.  Eh bien, ou du moins lisez les sections sur FUTEX_WAIT et FUTEX_WAKE. <br><br>  Regardons un <a href="">exemple simple</a> qui montre l'utilisation de base des futex pour coordonner le travail de deux processus. <br><br>  Processus enfant: <br><br><ol><li>  Attend 0xA dans l'emplacement de m√©moire g√©n√©ral </li><li>  √âcrit la valeur 0xB dans cet emplacement </li></ol><br>  Processus parent √† ce moment: <br><br><ol><li>  √âcrit une valeur 0xA dans un emplacement de m√©moire partag√©e </li><li>  Attend que 0xB y apparaisse </li></ol><br>  Une telle ¬´poign√©e de main¬ª entre deux processus.  Voici le code: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shm_id = shmget(IPC_PRIVATE, <span class="hljs-number"><span class="hljs-number">4096</span></span>, IPC_CREAT | <span class="hljs-number"><span class="hljs-number">0666</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shm_id &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"shmget"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* shared_data = shmat(shm_id, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); *shared_data = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> forkstatus = fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forkstatus &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forkstatus == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   printf("child waiting for A\n"); wait_on_futex_value(shared_data, 0xA); printf("child writing B\n"); //  0xB         *shared_data = 0xB; wake_futex_blocking(shared_data); } else { //   printf("parent writing A\n"); //  0xA         *shared_data = 0xA; wake_futex_blocking(shared_data); printf("parent waiting for B\n"); wait_on_futex_value(shared_data, 0xB); // Wait for the child to terminate. wait(NULL); shmdt(shared_data); } return 0; }</span></span></code> </pre> <br>  Faites attention aux appels POSIX pour allouer la m√©moire partag√©e entre les processus.  Nous ne pouvions pas utiliser l'allocation de m√©moire habituelle ici, car m√™me la m√™me adresse de pointeurs dans diff√©rents processus pointerait en fait vers des blocs de m√©moire diff√©rents (uniques √† chaque processus). <br><br>  Il convient de noter que cet exemple s'√©carte quelque peu des canons, car le futex a √©t√© cr√©√© √† l'origine pour attendre un changement dans une certaine signification ¬´de quelque chose de sp√©cifique √† n'importe quoi¬ª, et non ¬´de quelque chose √† quelque chose de sp√©cifique¬ª.  J'ai donn√© cet exemple afin de d√©montrer une telle possibilit√©, et ci-dessous nous consid√©rerons la version de base (sur elle nous impl√©mentons le mutex). <br><br>  Et voici le code de la fonction wait_on_futex_value: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_on_futex_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* futex_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(futex_addr, FUTEX_WAIT, val, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno != EAGAIN) { perror(<span class="hljs-string"><span class="hljs-string">"futex"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*futex_addr == val) { <span class="hljs-comment"><span class="hljs-comment">//    return; } } else { abort(); } } }</span></span></code> </pre> <br>  La t√¢che principale de cette fonction (en plus, en fait, l'appel syst√®me futex) est un cycle dans lequel nous nous ex√©cutons lorsque nous nous r√©veillons faux (ne nous int√©ressant pas).  Cela peut se produire lorsqu'une nouvelle valeur, mais non attendue par nous, est install√©e dans l'emplacement de m√©moire partag√©e.  Eh bien, ou dans le cas o√π un autre processus a √©t√© r√©veill√© plus t√¥t que le n√¥tre (cela ne peut pas arriver dans notre cas particulier, mais d'une mani√®re plus g√©n√©rale c'est possible). <br><br>  La s√©mantique de Futex est assez compliqu√©e!  L'appel FUTEX_WAIT retournera imm√©diatement si la valeur √† l'adresse futex n'est pas √©gale √† l'argument pass√© val.  Dans notre cas, cela peut se produire si le processus enfant attendait avant que le parent n'√©crive la valeur 0xA dans l'emplacement.  Dans ce cas, le futex renvoie la valeur EAGAIN. <br><br>  Et voici le code de la fonction wake_futex_blocking: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wake_futex_blocking</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* futex_addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(futex_addr, FUTEX_WAKE, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"futex wake"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } }</code> </pre> <br>  Il s'agit d'un wrapper de blocage sur FUTEX_WAKE qui fonctionnera rapidement et renverra une valeur, quel que soit le nombre d'auditeurs qui l'attendent.  Dans notre exemple, cela est utilis√© dans le cadre d'une ¬´poign√©e de main¬ª, mais d'autres utilisations sont possibles. <br><br><h3>  Les Futex sont des files d'attente du noyau pour du code personnalis√©. </h3><br>  Autrement dit, un futex est une file d'attente g√©r√©e par le noyau pour r√©soudre des t√¢ches de code personnalis√©es.  Il permet au code utilisateur de demander au noyau de suspendre l'ex√©cution de son thread jusqu'√† ce qu'un √©v√©nement se produise, et √† l'autre thread en m√™me temps de signaler cet √©v√©nement et de r√©veiller tous les threads qui l'attendent.  Plus t√¥t, nous avons mentionn√© la possibilit√© d'organiser un verrou tournant en mode utilisateur, en attendant que certaines conditions soient remplies.  Cependant, la file d'attente dans le noyau est une bien meilleure alternative, car elle nous √©vite des milliards d'instructions de processeur gaspill√©es ex√©cut√©es dans une boucle d'attente. <br><br>  Voici le sch√©ma de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Un aper√ßu et une mise √† jour</a> du futex <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬ª</a> sur LWN: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/476/433/d4e/476433d4e5a9ba7dcd840a7fe5eb3d87.png" alt="image"><br><br>  Dans le code du noyau Linux, les futex sont impl√©ment√©s dans le fichier kernel / futex.c.  Le noyau stocke une table de hachage o√π les cl√©s sont des adresses - pour trouver rapidement la file d'attente souhait√©e et y ajouter le processus d'appel.  Bien s√ªr, tout n'est pas si simple - apr√®s tout, le noyau lui-m√™me doit synchroniser l'acc√®s aux donn√©es √† l'int√©rieur, et prendre en charge toutes sortes d'options suppl√©mentaires pour futeksov. <br><br><h3>  Attente limit√©e dans le temps avec FUTEX_WAIT </h3><br>  L'appel syst√®me futex a un param√®tre de d√©lai d'attente qui permet √† l'utilisateur de sp√©cifier combien de temps il est pr√™t √† attendre.  Voici un <a href="">exemple</a> complet o√π cela est mis en ≈ìuvre, mais voici la partie cl√©: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"child waiting for A\n"</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout</span></span></span><span class="hljs-class"> = {</span></span>.tv_sec = <span class="hljs-number"><span class="hljs-number">0</span></span>, .tv_nsec = <span class="hljs-number"><span class="hljs-number">500000000</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> t1 = time_ns(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(shared_data, FUTEX_WAIT, <span class="hljs-number"><span class="hljs-number">0xA</span></span>, &amp;timeout, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"child woken up rc=%d errno=%s, elapsed=%llu\n"</span></span>, futex_rc, futex_rc ? strerror(errno) : <span class="hljs-string"><span class="hljs-string">""</span></span>, time_ns() - t1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; *shared_data == <span class="hljs-number"><span class="hljs-number">0xA</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br>  Si l'attente est retard√©e de 500 ms, la fonction futex se terminera et √† la prochaine it√©ration de la boucle, nous pourrons en quelque sorte r√©agir √† cela (afficher quelque chose √† l'√©cran, √©crire dans le journal, continuer l'attente ou arr√™ter). <br><br><h3>  Utiliser un futex pour impl√©menter un mutex </h3><br>  Nous avons commenc√© cet article avec le fait que les futex sont d'une utilit√© pratique dans l'impl√©mentation d'objets de synchronisation de niveau sup√©rieur.  Essayons de les utiliser (ainsi que atomiques) pour impl√©menter le mutex classique.  L'impl√©mentation ci-dessous est bas√©e sur le code de l'article ¬´Futexes are Tricky¬ª √©crit par Ulrich Drepper. <br><br>  Pour cet exemple, j'utilise C ++, principalement pour la capacit√© √† utiliser atomics de la norme C ++ 11.  Vous pouvez trouver le code complet <a href="">ici</a> , mais la partie la plus importante est: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Mutex() : atom_(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = cmpxchg(&amp;atom_, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// If the lock was previously unlocked, there's nothing else for us to do. // Otherwise, we'll probably have to wait. if (c != 0) { do { // If the mutex is locked, we signal that we're waiting by setting the // atom to 2. A shortcut checks is it's 2 already and avoids the atomic // operation in this case. if (c == 2 || cmpxchg(&amp;atom_, 1, 2) != 0) { // Here we have to actually sleep, because the mutex is actually // locked. Note that it's not necessary to loop around this syscall; // a spurious wakeup will do no harm since we only exit the do...while // loop when atom_ is indeed 0. syscall(SYS_futex, (int*)&amp;atom_, FUTEX_WAIT, 2, 0, 0, 0); } // We're here when either: // (a) the mutex was in fact unlocked (by an intervening thread). // (b) we slept waiting for the atom and were awoken. // // So we try to lock the atom again. We set teh state to 2 because we // can't be certain there's no other thread at this exact point. So we // prefer to err on the safe side. } while ((c = cmpxchg(&amp;atom_, 0, 2)) != 0); } } void unlock() { if (atom_.fetch_sub(1) != 1) { atom_.store(0); syscall(SYS_futex, (int*)&amp;atom_, FUTEX_WAKE, 1, 0, 0, 0); } } private: // 0 means unlocked // 1 means locked, no waiters // 2 means locked, there are waiters in lock() std::atomic&lt;int&gt; atom_; };</span></span></code> </pre><br>  Dans ce code, la fonction cmpxhg est un simple wrapper pour une utilisation plus pratique des atomes: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// An atomic_compare_exchange wrapper with semantics expected by the paper's // mutex - return the old value stored in the atom. int cmpxchg(std::atomic&lt;int&gt;* atom, int expected, int desired) { int* ep = &amp;expected; std::atomic_compare_exchange_strong(atom, ep, desired); return *ep; }</span></span></code> </pre> <br>  Cet exemple de code contient de nombreux commentaires expliquant la logique de son fonctionnement.  Cela ne fera pas de mal, car il existe un risque important que vous souhaitiez en √©crire une version l√©g√®rement plus simple, mais compl√®tement incorrecte.  Quant √† ce code - il n'est pas non plus parfait en tout.  Par exemple, il essaie de faire une hypoth√®se sur un p√©riph√©rique interne de type std :: atomic, en castant son contenu en int * pour le passer √† l'appel futex.  Ce n'est g√©n√©ralement pas le cas.  Le code se compile et s'ex√©cute sur Linux x64, mais nous n'avons aucune garantie de compatibilit√© avec d'autres plates-formes.  Pour l'obtenir, nous devons ajouter une couche de d√©pendance de plate-forme pour les atomes.  Comme ce n'est pas le sujet de cet article (et aussi parce qu'il est tr√®s peu probable que vous m√©langiez des futex dans un module C ++), nous omettons cette impl√©mentation.  Ce n'est qu'une d√©monstration! <br><br><h3>  Mutibes Glibc et verrous de bas niveau </h3><br>  Nous sommes donc arriv√©s au point o√π la glibc impl√©mente les threads POSIX, dont une partie est le type pthread_mutex_t.  Comme je l'ai dit au d√©but de cet article, les futex ne sont pas tout √† fait ce dont un d√©veloppeur ordinaire aura besoin.  Ils sont utilis√©s par les biblioth√®ques d'ex√©cution ou quelque chose de tr√®s sp√©cialis√© pour impl√©menter des primitives de synchronisation de niveau sup√©rieur.  Dans ce contexte, il est int√©ressant d'examiner la mise en ≈ìuvre du mutex pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NPTL</a> .  Dans le code glibc, il s'agit du fichier nptl / pthread_mutex_lock.c. <br><br>  Le code est assez compliqu√© en raison de la n√©cessit√© de prendre en charge diff√©rents types de mutex, mais nous pouvons trouver des blocs assez familiers si vous le souhaitez.  Vous pouvez √©galement consulter les fichiers sysdeps / unix / sysv / linux / x86_64 / lowlevellock.h et nptl / lowlevellock.c.  Le code est quelque peu d√©routant, mais la combinaison d'appels de comparaison et d'√©change et de futex est toujours facile. <br><br>  Le commentaire initial du fichier systeds / nptl / lowlevellock.h doit d√©j√† √™tre bien compris par vous: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Low-level locks use a combination of atomic operations (to acquire and release lock ownership) and futex operations (to block until the state of a lock changes). A lock can be in one of three states: 0: not acquired, 1: acquired with no waiters; no other threads are blocked or about to block for changes to the lock state, &gt;1: acquired, possibly with waiters; there may be other threads blocked or about to block for changes to the lock state. We expect that the common case is an uncontended lock, so we just need to transition the lock between states 0 and 1; releasing the lock does not need to wake any other blocked threads. If the lock is contended and a thread decides to block using a futex operation, then this thread needs to first change the state to &gt;1; if this state is observed during lock release, the releasing thread will wake one of the potentially blocked threads. .. */</span></span></code> </pre> <br><h3>  Go Futexes d'ex√©cution </h3><br>  Rantime Go n'utilise pas libc (dans la plupart des cas).  Ainsi, il ne peut pas s'appuyer sur l'impl√©mentation de threads POSIX.  Au lieu de cela, il appelle directement les appels syst√®me de niveau inf√©rieur.  Cela en fait un bon exemple d'utilisation des futex.  Puisqu'il n'y a aucun moyen d'appeler pthread_mutex_t, vous devez √©crire votre propre remplacement.  Voyons comment cela se fait, commen√ßons par le type sync.Mutex visible par l'utilisateur (dans src / sync / mutex.go). <br><br>  La m√©thode Lock de ce type tente d'utiliser l'op√©ration de permutation atomique pour capturer rapidement le verrou.  S'il s'av√®re que vous devez attendre, il appelle runtime_SemacquireMutex, qui appelle runtime.lock.  Cette fonction est d√©finie dans src / runtime / lock_futex.go et elle d√©clare plusieurs constantes qui peuvent vous sembler famili√®res: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( mutex_unlocked = <span class="hljs-number"><span class="hljs-number">0</span></span> mutex_locked = <span class="hljs-number"><span class="hljs-number">1</span></span> mutex_sleeping = <span class="hljs-number"><span class="hljs-number">2</span></span> ... ) <span class="hljs-comment"><span class="hljs-comment">// Possible lock states are mutex_unlocked, mutex_locked and mutex_sleeping. // mutex_sleeping means that there is presumably at least one sleeping thread.</span></span></code> </pre><br>  runtime.lock tente √©galement de capturer le verrou √† l'aide d'une fonction atomique.  Cela a du sens, car runtime.lock est appel√© √† de nombreux endroits de l'ex√©cution Go, mais il me semble qu'il serait possible d'optimiser le code en supprimant deux appels cons√©cutifs de la fonction atomique lors de l'appel de runtime.lock √† Mutex.lock. <br><br>  S'il s'av√®re que vous devez attendre, la fonction d√©pendante de la plate-forme futexsleep est appel√©e, qui est d√©finie pour Linux dans le fichier src / runtime / os_linux.go.  Cette fonction effectue un appel syst√®me futex avec le code FUTEX_WAIT_PRIVATE (dans ce cas, cela convient, car le runtime Go vit dans un processus). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418705/">https://habr.com/ru/post/fr418705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418691/index.html">Rancher: Kubernetes en 5 minutes sur du m√©tal nu</a></li>
<li><a href="../fr418693/index.html">Pourquoi le bonheur est-il si difficile √† d√©tecter dans le cerveau</a></li>
<li><a href="../fr418695/index.html">Anti-Piracy Wars - L'Empire contre-attaque</a></li>
<li><a href="../fr418699/index.html">Cr√©ation d'une machine d'arcade d'√©mulation. 3e partie</a></li>
<li><a href="../fr418701/index.html">Nous √©tudions les analyseurs syntaxiques pour la langue russe</a></li>
<li><a href="../fr418707/index.html">KDispatcher - Eventbus l√©ger et pratique pour une utilisation quotidienne</a></li>
<li><a href="../fr418709/index.html">Besoin de vous forcer: pilotes et barri√®res d'interface</a></li>
<li><a href="../fr418711/index.html">Registres g√©r√©s par jeton 1.0</a></li>
<li><a href="../fr418713/index.html">Jeu pour am√©liorer la qualit√© de Wikipedia</a></li>
<li><a href="../fr418715/index.html">Quelle est l'efficacit√© du syst√®me de fichiers virtuel procfs et est-il possible de l'optimiser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>