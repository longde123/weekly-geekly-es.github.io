<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   SQL Index Manager: una herramienta gratuita para desfragmentar y mantener 铆ndices   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Durante muchos a帽os trabajando como DBA de SQL Server y administrando servidores, luego optimizando el rendimiento. En general, quer铆a hacer algo 煤til...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQL Index Manager: una herramienta gratuita para desfragmentar y mantener 铆ndices</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459914/">  Durante muchos a帽os trabajando como DBA de SQL Server y administrando servidores, luego optimizando el rendimiento.  En general, quer铆a hacer algo 煤til en mi tiempo libre para el Universo y nuestros colegas.  As铆 que al final obtuvimos una peque帽a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramienta de</a> mantenimiento de 铆ndice de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c贸digo abierto</a> para SQL Server y Azure. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/546/8b0/98e/5468b098eea90eb287427b56021c6962.png" alt="Administrador de 铆ndices SQL"><br><br><a name="habracut"></a><h3>  Idea </h3><br>  A veces, cuando se trabaja en sus prioridades, las personas pueden parecerse a una bater铆a tipo dedo: hay suficiente carga de motivaci贸n para un solo flash, y eso es todo.  Y hasta hace poco, no era la excepci贸n a esta observaci贸n de la vida.  A menudo me visitaban las ideas para crear algo propio, pero las prioridades cambiaban y nada llegaba al final. <br><br>  El trabajo en la empresa Jarkov Devart, que se dedicaba a la creaci贸n de software para el desarrollo y administraci贸n de bases de datos SQL Server, MySQL y Oracle, proporcion贸 una influencia bastante fuerte en mi motivaci贸n y desarrollo profesional. <br><br>  Antes de llegar a ellos, ten铆a poca idea de los detalles de la creaci贸n de mi propio producto, pero ya en el proceso adquir铆 muchos conocimientos sobre la estructura interna de SQL Server.  Despu茅s de haber optimizado las solicitudes de metadatos en sus l铆neas de productos durante m谩s de un a帽o, poco a poco comenc茅 a comprender qu茅 funcionalidad tiene m谩s demanda en el mercado que ninguna otra. <br><br>  En cierta etapa, surgi贸 la idea de crear un nuevo producto de nicho, pero debido a las circunstancias, esta idea no despeg贸.  En ese momento, para el nuevo proyecto, no hab铆a recursos curiosos suficientes suficientes dentro de la empresa sin perjuicio del negocio principal. <br><br>  Ya cuando trabajaba en un lugar nuevo e intentaba hacer el proyecto por su cuenta, ten铆a que comprometerse constantemente.  La idea inicial de hacer un producto grande lleno de caracter铆sticas r谩pidamente qued贸 en nada y gradualmente se transform贸 en una direcci贸n diferente: dividir la funcionalidad planificada en mini-herramientas separadas e implementarlas de forma independiente. <br><br>  Como resultado, naci贸 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>SQL Index Manager</b></a> , una herramienta gratuita de mantenimiento de 铆ndices para SQL Server y Azure.  La idea principal era tomar como base alternativas comerciales de RedGate y Devart y tratar de mejorar su funcionalidad.  Proporcionar, tanto para usuarios principiantes como experimentados, la capacidad de analizar y mantener 铆ndices convenientemente. <br><br><h3>  Implementaci贸n </h3><br>  En palabras, todo siempre suena simple ... ech贸 un vistazo a un par de vidosikov motivadores, se par贸 en un estante y comenz贸 a hacer un producto genial.  Pero en la pr谩ctica, no todo es tan optimista, ya que existen muchas dificultades al trabajar con la funci贸n de tabla del sistema sys.dm_db_index_physical_stats y, en combinaci贸n, el 煤nico lugar desde donde puede obtener informaci贸n relevante sobre la fragmentaci贸n del 铆ndice. <br><br>  Desde los primeros d铆as de desarrollo, hubo una gran oportunidad para hacer un camino triste entre los esquemas est谩ndar y copiar la l贸gica ya depurada del trabajo de las aplicaciones competidoras, al tiempo que agregaba una peque帽a mordaza.  Pero despu茅s de analizar las solicitudes de metadatos, quer铆a hacer algo m谩s optimizado, que, debido a la burocracia de las grandes empresas, nunca habr铆a aparecido en sus productos. <br><br>  Al analizar RedGate SQL Index Manager (1.1.9.1378 - $ 155), puede ver que la aplicaci贸n utiliza un enfoque muy simple: con una consulta obtenemos una lista de tablas y vistas de usuarios, y despu茅s de la segunda consulta, se devuelve una lista de todos los 铆ndices dentro de la base de datos seleccionada. <br><br><pre><code class="1c hljs">SELECT objects.name AS tableOrViewName , objects.object_id AS tableOrViewId , schemas.name AS schemaName , CAST(ISNULL(lobs.NumLobs, <span class="hljs-number"><span class="hljs-number">0</span></span>) AS BIT) AS ContainsLobs , o.is_memory_optimized FROM sys.objects AS objects JOIN sys.schemas AS schemas ON schemas.schema_id = objects.schema_id LEFT JOIN ( SELECT object_id , COUNT(*) AS NumLobs FROM sys.columns WITH (NOLOCK) WHERE system_type_id IN (<span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">35</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>) OR max_length = -<span class="hljs-number"><span class="hljs-number">1</span></span> GROUP BY object_id ) AS lobs ON objects.object_id = lobs.object_id LEFT JOIN sys.tables AS o ON o.object_id = objects.object_id WHERE objects.type = 'U' OR objects.type = 'V' SELECT i.object_id AS tableOrViewId , i.name AS indexName , i.index_id AS indexId , i.allow_page_locks AS allowPageLocks , p.partition_number AS partitionNumber , CAST((c.numPartitions - <span class="hljs-number"><span class="hljs-number">1</span></span>) AS BIT) AS belongsToPartitionedIndex FROM sys.indexes AS i JOIN sys.partitions AS p ON p.index_id = i.index_id AND p.object_id = i.object_id JOIN ( SELECT COUNT(*) AS numPartitions , object_id , index_id FROM sys.partitions GROUP BY object_id , index_id ) AS c ON c.index_id = i.index_id AND c.object_id = i.object_id WHERE i.index_id &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> -- ignore heaps AND i.is_disabled = <span class="hljs-number"><span class="hljs-number">0</span></span> AND i.is_hypothetical = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Luego, en un ciclo, para cada secci贸n del 铆ndice, se env铆a una solicitud para determinar su tama帽o y nivel de fragmentaci贸n.  Al final de la exploraci贸n, los 铆ndices que pesan menos que el umbral de entrada se descartan en el cliente. <br><br><pre> <code class="1c hljs">EXEC sp_executesql N' SELECT index_id, avg_fragmentation_in_percent, page_count FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)' , N'@databaseId int,@objectId int,@indexId int,@partitionNr int' , @databaseId = <span class="hljs-number"><span class="hljs-number">7</span></span>, @objectId = <span class="hljs-number"><span class="hljs-number">2133582639</span></span>, @indexId = <span class="hljs-number"><span class="hljs-number">1</span></span>, @partitionNr = <span class="hljs-number"><span class="hljs-number">1</span></span> EXEC sp_executesql N' SELECT index_id, avg_fragmentation_in_percent, page_count FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)' , N'@databaseId int,@objectId int,@indexId int,@partitionNr int' , @databaseId = <span class="hljs-number"><span class="hljs-number">7</span></span>, @objectId = <span class="hljs-number"><span class="hljs-number">2133582639</span></span>, @indexId = <span class="hljs-number"><span class="hljs-number">2</span></span>, @partitionNr = <span class="hljs-number"><span class="hljs-number">1</span></span> EXEC sp_executesql N' SELECT index_id, avg_fragmentation_in_percent, page_count FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)' , N'@databaseId int,@objectId int,@indexId int,@partitionNr int' , @databaseId = <span class="hljs-number"><span class="hljs-number">7</span></span>, @objectId = <span class="hljs-number"><span class="hljs-number">2133582639</span></span>, @indexId = <span class="hljs-number"><span class="hljs-number">3</span></span>, @partitionNr = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Al analizar la l贸gica de esta aplicaci贸n, puede encontrar muchas deficiencias.  Por ejemplo, si encuentra fallas en las peque帽eces, antes de enviar una solicitud, no se verifica si la secci贸n actual contiene cadenas para excluir las secciones vac铆as del escaneo. <br><br>  Pero el problema es m谩s grave en otro aspecto: el n煤mero de solicitudes del servidor ser谩 aproximadamente igual al n煤mero total de l铆neas de sys.partitions.  Dado el hecho de que las bases de datos reales pueden contener decenas de miles de secciones, este matiz puede conducir a una gran cantidad de solicitudes similares al servidor.  En una situaci贸n en la que la base de datos es remota, el tiempo de escaneo se har谩 a煤n m谩s largo debido a mayores retrasos en la red para cada solicitud, incluso la m谩s simple. <br><br>  A diferencia de RedGate, un producto similar desarrollado en Devart: dbForge Index Manager para SQL Server (1.10.38 - $ 99) recibe informaci贸n en una consulta grande y luego muestra todo en el cliente: <br><br><pre> <code class="1c hljs">SELECT SCHEMA_NAME(o.[schema_id]) AS [schema_name] , o.name AS parent_name , o.[type] AS parent_type , i.name , i.type_desc , s.avg_fragmentation_in_percent , s.page_count , p.partition_number , p.[rows] , ISNULL(lob.is_lob_legacy, <span class="hljs-number"><span class="hljs-number">0</span></span>) AS is_lob_legacy , ISNULL(lob.is_lob, <span class="hljs-number"><span class="hljs-number">0</span></span>) AS is_lob , CASE WHEN ds.[type] = 'PS' THEN <span class="hljs-number"><span class="hljs-number">1</span></span> ELSE <span class="hljs-number"><span class="hljs-number">0</span></span> END AS is_partitioned FROM sys.dm_db_index_physical_stats(DB_ID(), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) s JOIN sys.partitions p ON s.[object_id] = p.[object_id] AND s.index_id = p.index_id AND s.partition_number = p.partition_number JOIN sys.indexes i ON i.[object_id] = s.[object_id] AND i.index_id = s.index_id LEFT JOIN ( SELECT c.[object_id] , index_id = ISNULL(i.index_id, <span class="hljs-number"><span class="hljs-number">1</span></span>) , is_lob_legacy = MAX(CASE WHEN c.system_type_id IN (<span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">35</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>) THEN <span class="hljs-number"><span class="hljs-number">1</span></span> END) , is_lob = MAX(CASE WHEN c.max_length = -<span class="hljs-number"><span class="hljs-number">1</span></span> THEN <span class="hljs-number"><span class="hljs-number">1</span></span> END) FROM sys.columns c LEFT JOIN sys.index_columns i ON c.[object_id] = i.[object_id] AND c.column_id = i.column_id AND i.index_id &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> WHERE c.system_type_id IN (<span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">35</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>) OR c.max_length = -<span class="hljs-number"><span class="hljs-number">1</span></span> GROUP BY c.[object_id], i.index_id ) lob ON lob.[object_id] = i.[object_id] AND lob.index_id = i.index_id JOIN sys.objects o ON o.[object_id] = i.[object_id] JOIN sys.data_spaces ds ON i.data_space_id = ds.data_space_id WHERE i.[type] IN (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) AND i.is_disabled = <span class="hljs-number"><span class="hljs-number">0</span></span> AND i.is_hypothetical = <span class="hljs-number"><span class="hljs-number">0</span></span> AND s.index_level = <span class="hljs-number"><span class="hljs-number">0</span></span> AND s.alloc_unit_type_desc = 'IN_ROW_DATA' AND o.[type] IN ('U', 'V')</code> </pre> <br>  Logramos deshacernos del problema principal con el velo del mismo tipo de consultas en un producto de la competencia, pero las desventajas de esta implementaci贸n son que no se pasan par谩metros adicionales a la funci贸n sys.dm_db_index_physical_stats que pueden limitar el escaneo de 铆ndices obviamente innecesarios.  De hecho, esto lleva a obtener informaci贸n sobre todos los 铆ndices en el sistema y cargas de disco adicionales en la etapa de escaneo. <br><br>  Es importante tener en cuenta que los datos obtenidos de sys.dm_db_index_physical_stats no se almacenan en cach茅 de forma permanente en el grupo de b煤feres, por lo tanto, minimizar las lecturas f铆sicas al obtener informaci贸n sobre la fragmentaci贸n del 铆ndice fue una de las tareas prioritarias durante el desarrollo. <br><br>  Despu茅s de varios experimentos, result贸 combinar ambos enfoques, dividiendo el escaneo en dos partes.  Primero, una consulta grande determina el tama帽o de las secciones, prefiltrando aquellas que no est谩n en el rango de filtrado: <br><br><pre> <code class="1c hljs">INSERT INTO <span class="hljs-meta"><span class="hljs-meta">#AllocationUnits (ContainerID, ReservedPages, UsedPages) SELECT [container_id] , SUM([total_pages]) , SUM([used_pages]) FROM sys.allocation_units WITH(NOLOCK) GROUP BY [container_id] HAVING SUM([total_pages]) BETWEEN @MinIndexSize AND @MaxIndexSize</span></span></code> </pre> <br>  A continuaci贸n, obtenemos solo aquellas secciones que contienen datos para evitar operaciones de lectura innecesarias de 铆ndices vac铆os. <br><br><pre> <code class="1c hljs">SELECT [object_id] , [index_id] , [partition_id] , [partition_number] , [rows] , [data_compression] INTO <span class="hljs-meta"><span class="hljs-meta">#Partitions FROM sys.partitions WITH(NOLOCK) WHERE [object_id] &gt; 255 AND [rows] &gt; 0 AND [object_id] NOT IN (SELECT * FROM #ExcludeList)</span></span></code> </pre> <br>  Dependiendo de la configuraci贸n, solo se obtienen los tipos de 铆ndices que el usuario desea analizar (se admite el trabajo con montones, 铆ndices agrupados / no agrupados e indicadores de columna). <br><br><pre> <code class="1c hljs">INSERT INTO <span class="hljs-meta"><span class="hljs-meta">#Indexes SELECT ObjectID = i.[object_id] , IndexID = i.index_id , IndexName = i.[name] , PagesCount = a.ReservedPages , UnusedPagesCount = a.ReservedPages - a.UsedPages , PartitionNumber = p.[partition_number] , RowsCount = ISNULL(p.[rows], 0) , IndexType = i.[type] , IsAllowPageLocks = i.[allow_page_locks] , DataSpaceID = i.[data_space_id] , DataCompression = p.[data_compression] , IsUnique = i.[is_unique] , IsPK = i.[is_primary_key] , FillFactorValue = i.[fill_factor] , IsFiltered = i.[has_filter] FROM #AllocationUnits a JOIN #Partitions p ON a.ContainerID = p.[partition_id] JOIN sys.indexes i WITH(NOLOCK) ON i.[object_id] = p.[object_id] AND p.[index_id] = i.[index_id] WHERE i.[type] IN (0, 1, 2, 5, 6) AND i.[object_id] &gt; 255</span></span></code> </pre> <br>  Despu茅s de esto, comienza un poco de magia: para todos los 铆ndices peque帽os, determinamos el nivel de fragmentaci贸n llamando repetidamente a la funci贸n sys.dm_db_index_physical_stats con una indicaci贸n completa de todos los par谩metros. <br><br><pre> <code class="1c hljs">INSERT INTO <span class="hljs-meta"><span class="hljs-meta">#Fragmentation (ObjectID, IndexID, PartitionNumber, Fragmentation) SELECT i.ObjectID , i.IndexID , i.PartitionNumber , r.[avg_fragmentation_in_percent] FROM #Indexes i CROSS APPLY sys.dm_db_index_physical_stats(@DBID, i.ObjectID, i.IndexID, i.PartitionNumber, 'LIMITED') r WHERE i.PagesCount &lt;= @PreDescribeSize AND r.[index_level] = 0 AND r.[alloc_unit_type_desc] = 'IN_ROW_DATA' AND i.IndexType IN (0, 1, 2)</span></span></code> </pre> <br>  A continuaci贸n, devolvemos toda la informaci贸n posible al cliente, filtrando el exceso de datos: <br><br><pre> <code class="1c hljs">SELECT i.ObjectID , i.IndexID , i.IndexName , ObjectName = o.[name] , SchemaName = s.[name] , i.PagesCount , i.UnusedPagesCount , i.PartitionNumber , i.RowsCount , i.IndexType , i.IsAllowPageLocks , u.TotalWrites , u.TotalReads , u.TotalSeeks , u.TotalScans , u.TotalLookups , u.LastUsage , i.DataCompression , f.Fragmentation , IndexStats = STATS_DATE(i.ObjectID, i.IndexID) , IsLobLegacy = ISNULL(lob.IsLobLegacy, <span class="hljs-number"><span class="hljs-number">0</span></span>) , IsLob = ISNULL(lob.IsLob, <span class="hljs-number"><span class="hljs-number">0</span></span>) , IsSparse = CAST(CASE WHEN p.ObjectID IS <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> THEN <span class="hljs-number"><span class="hljs-number">0</span></span> ELSE <span class="hljs-number"><span class="hljs-number">1</span></span> END AS BIT) , IsPartitioned = CAST(CASE WHEN dds.[data_space_id] IS NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> THEN <span class="hljs-number"><span class="hljs-number">1</span></span> ELSE <span class="hljs-number"><span class="hljs-number">0</span></span> END AS BIT) , FileGroupName = fg.[name] , i.IsUnique , i.IsPK , i.FillFactorValue , i.IsFiltered , a.IndexColumns , a.IncludedColumns FROM <span class="hljs-meta"><span class="hljs-meta">#Indexes i JOIN sys.objects o WITH(NOLOCK) ON o.[object_id] = i.ObjectID JOIN sys.schemas s WITH(NOLOCK) ON s.[schema_id] = o.[schema_id] LEFT JOIN #AggColumns a ON a.ObjectID = i.ObjectID AND a.IndexID = i.IndexID LEFT JOIN #Sparse p ON p.ObjectID = i.ObjectID LEFT JOIN #Fragmentation f ON f.ObjectID = i.ObjectID AND f.IndexID = i.IndexID AND f.PartitionNumber = i.PartitionNumber LEFT JOIN ( SELECT ObjectID = [object_id] , IndexID = [index_id] , TotalWrites = NULLIF([user_updates], 0) , TotalReads = NULLIF([user_seeks] + [user_scans] + [user_lookups], 0) , TotalSeeks = NULLIF([user_seeks], 0) , TotalScans = NULLIF([user_scans], 0) , TotalLookups = NULLIF([user_lookups], 0) , LastUsage = ( SELECT MAX(dt) FROM ( VALUES ([last_user_seek]) , ([last_user_scan]) , ([last_user_lookup]) , ([last_user_update]) ) t(dt) ) FROM sys.dm_db_index_usage_stats WITH(NOLOCK) WHERE [database_id] = @DBID ) u ON i.ObjectID = u.ObjectID AND i.IndexID = u.IndexID LEFT JOIN #Lob lob ON lob.ObjectID = i.ObjectID AND lob.IndexID = i.IndexID LEFT JOIN sys.destination_data_spaces dds WITH(NOLOCK) ON i.DataSpaceID = dds.[partition_scheme_id] AND i.PartitionNumber = dds.[destination_id] JOIN sys.filegroups fg WITH(NOLOCK) ON ISNULL(dds.[data_space_id], i.DataSpaceID) = fg.[data_space_id] WHERE o.[type] IN ('V', 'U') AND ( f.Fragmentation &gt;= @Fragmentation OR i.PagesCount &gt; @PreDescribeSize OR i.IndexType IN (5, 6) )</span></span></code> </pre> <br>  Despu茅s de esto, las consultas de puntos determinan el nivel de fragmentaci贸n para 铆ndices grandes. <br><br><pre> <code class="1c hljs">EXEC sp_executesql N' DECLARE @DBID INT = DB_ID() SELECT [avg_fragmentation_in_percent] FROM sys.dm_db_index_physical_stats(@DBID, @ObjectID, @IndexID, @PartitionNumber, ''LIMITED'') WHERE [index_level] = 0 AND [alloc_unit_type_desc] = ''IN_ROW_DATA''' , N'@ObjectID int,@IndexID int,@PartitionNumber int' , @ObjectId = <span class="hljs-number"><span class="hljs-number">1044198770</span></span>, @IndexId = <span class="hljs-number"><span class="hljs-number">1</span></span>, @PartitionNumber = <span class="hljs-number"><span class="hljs-number">1</span></span> EXEC sp_executesql N' DECLARE @DBID INT = DB_ID() SELECT [avg_fragmentation_in_percent] FROM sys.dm_db_index_physical_stats(@DBID, @ObjectID, @IndexID, @PartitionNumber, ''LIMITED'') WHERE [index_level] = 0 AND [alloc_unit_type_desc] = ''IN_ROW_DATA''' , N'@ObjectID int,@IndexID int,@PartitionNumber int' , @ObjectId = <span class="hljs-number"><span class="hljs-number">1552724584</span></span>, @IndexId = <span class="hljs-number"><span class="hljs-number">0</span></span>, @PartitionNumber = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Debido a este enfoque, al generar consultas, fue posible resolver los problemas con el rendimiento de escaneo que se encontraron en las aplicaciones de la competencia.  Esto podr铆a completarse, pero en el proceso de desarrollo, aparecieron nuevas ideas gradualmente que permitieron ampliar el alcance de la aplicaci贸n de su producto. <br><br>  Inicialmente, se implement贸 el soporte para trabajar con WAIT_AT_LOW_PRIORITY, luego se hizo posible usar DATA_COMPRESSION y FILL_FACTOR para reconstruir 铆ndices. <br><br><img src="https://habrastorage.org/webt/kd/em/xj/kdemxjo8sj0hxa4y_omvv3dph6a.png" alt="Configuraciones de SQL Index Manager"><br><br>  La aplicaci贸n estaba ligeramente cubierta de funcionalidades no planificadas previamente, como el mantenimiento de columnas de columnas: <br><br><pre> <code class="1c hljs">SELECT * FROM ( SELECT IndexID = [index_id] , PartitionNumber = [partition_number] , PagesCount = SUM([size_in_bytes]) / <span class="hljs-number"><span class="hljs-number">8192</span></span> , UnusedPagesCount = ISNULL(SUM(CASE WHEN [state] = <span class="hljs-number"><span class="hljs-number">1</span></span> THEN [size_in_bytes] END), <span class="hljs-number"><span class="hljs-number">0</span></span>) / <span class="hljs-number"><span class="hljs-number">8192</span></span> , Fragmentation = CAST(ISNULL(SUM(CASE WHEN [state] = <span class="hljs-number"><span class="hljs-number">1</span></span> THEN [size_in_bytes] END), <span class="hljs-number"><span class="hljs-number">0</span></span>) * <span class="hljs-number"><span class="hljs-number">100</span></span>. / SUM([size_in_bytes]) AS FLOAT) FROM sys.fn_column_store_row_groups(@ObjectID) GROUP BY [index_id] , [partition_number] ) t WHERE Fragmentation &gt;= @Fragmentation AND PagesCount BETWEEN @MinIndexSize AND @MaxIndexSize</code> </pre> <br>  O la capacidad de crear 铆ndices no agrupados basados en informaci贸n de dm_db_missing_index: <br><br><pre> <code class="1c hljs">SELECT ObjectID = d.[object_id] , UserImpact = gs.[avg_user_impact] , TotalReads = gs.[user_seeks] + gs.[user_scans] , TotalSeeks = gs.[user_seeks] , TotalScans = gs.[user_scans] , LastUsage = ISNULL(gs.[last_user_scan], gs.[last_user_seek]) , IndexColumns = CASE WHEN d.[equality_columns] IS NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AND d.[inequality_columns] IS NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> THEN d.[equality_columns] + ', ' + d.[inequality_columns] WHEN d.[equality_columns] IS NOT <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AND d.[inequality_columns] IS <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> THEN d.[equality_columns] ELSE d.[inequality_columns] END , IncludedColumns = d.[included_columns] FROM sys.dm_db_missing_index_groups g WITH(NOLOCK) JOIN sys.dm_db_missing_index_group_stats gs WITH(NOLOCK) ON gs.[group_handle] = g.[index_group_handle] JOIN sys.dm_db_missing_index_details d WITH(NOLOCK) ON g.[index_handle] = d.[index_handle] WHERE d.[database_id] = DB_ID()</code> </pre> <br><h3>  Resumen </h3><br>  Despu茅s de seis meses de la fase de desarrollo activo, me alegra que los planes no terminen all铆, porque quiero seguir desarrollando este producto.  El siguiente paso es agregar funcionalidad para buscar 铆ndices duplicados o no utilizados, as铆 como implementar soporte completo para servir estad铆sticas dentro de SQL Server. <br><br>  Basado en el hecho de que hay muchas soluciones pagas en el mercado, quiero creer que debido al posicionamiento libre, una descripci贸n de metadatos m谩s optimizada y la presencia de varias peque帽as cosas 煤tiles para alguien, este producto definitivamente ser谩 煤til en las tareas cotidianas. <br><br>  La versi贸n actual de la aplicaci贸n se puede descargar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>GitHub</b></a> .  Las fuentes est谩n en el mismo lugar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459914/">https://habr.com/ru/post/459914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459898/index.html">El plan ha vuelto a la econom铆a.</a></li>
<li><a href="../459900/index.html">Visualizar una columna de un DataFrame usando la biblioteca Seaborn</a></li>
<li><a href="../459902/index.html">Mapa interactivo de regiones rusas para principiantes. Errores que comet铆 y que no debes cometer</a></li>
<li><a href="../459906/index.html">Tic Tac Toe, parte 3: Deshacer / Rehacer con almacenamiento de comandos</a></li>
<li><a href="../459910/index.html">Situaci贸n: las empresas no tienen prisa por desarrollar servicios para asistentes de voz: 驴cu谩les son los riesgos?</a></li>
<li><a href="../459918/index.html">Resoluci贸n de problemas con pwnable.kr 03 - bof. Desbordamiento de b煤fer en la pila</a></li>
<li><a href="../459922/index.html">Eliminar el ruido de alta frecuencia de las se帽ales de los sensores de vibraci贸n durante el diagn贸stico de vibraci贸n de los rodamientos</a></li>
<li><a href="../459924/index.html">Ciclo completo de prueba de reacci贸n. Auto.ru Report</a></li>
<li><a href="../459928/index.html">El camino del estudiante hacia el desarrollo de aplicaciones m贸viles</a></li>
<li><a href="../459930/index.html">Automatizaci贸n de importaci贸n de Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>