<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🚀 👩🏽‍🍳 🏹 Einführung in virtuelle Linux-Schnittstellen: Tunnel 👨‍🏭 👁‍🗨 👨‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Linux unterstützt viele Arten von Tunneln. Dies verwirrt Anfänger, die Schwierigkeiten haben, die technologischen Unterschiede zu verstehen und zu ver...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in virtuelle Linux-Schnittstellen: Tunnel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/457386/"> Linux unterstützt viele Arten von Tunneln.  Dies verwirrt Anfänger, die Schwierigkeiten haben, die technologischen Unterschiede zu verstehen und zu verstehen, welcher Tunnel in einer bestimmten Situation besser zu verwenden ist.  Das Material, dessen Übersetzung wir heute veröffentlichen, gibt einen kurzen Überblick über die häufig verwendeten Tunneling-Schnittstellen des Linux-Kernels.  Wir werden uns nicht eingehend mit diesem Thema befassen, sondern nur die allgemeinen Merkmale von Tunneln und Optionen für ihre Verwendung unter Linux berücksichtigen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/-0/wg/hq/-0wghqvj6hymntfthlttl1xu6tm.jpeg"></a> <br><br>  Der Autor dieses Materials ist der Ansicht, dass das, was hier diskutiert wird, für jeden von Interesse sein kann, der etwas mit der Verwaltung von Computernetzwerken zu tun hat.  Die Liste der Tunnelschnittstellen sowie Referenzinformationen zu einer bestimmten Konfiguration können mit dem Hilfebefehl iproute2 <code>ip link help</code> abgerufen werden. <br><br>  Die folgenden häufig verwendeten Schnittstellen werden hier behandelt: IPIP, SIT, ip6tnl, VTI und VTI6, GRE und GRETAP, GRE6 und GRE6TAP, FOU, GUE, GENEVE, ERSPAN und IP6ERSPAN. <br><br>  Nachdem Sie diesen Artikel gelesen haben, lernen Sie die Funktionen dieser Schnittstellen kennen und die Unterschiede zwischen ihnen herausfinden.  Sie lernen, wie Sie sie erstellen und Situationen kennen, in denen sie am besten verwendet werden. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">IPIP</font> </h2><br>  Der IPIP-Tunnel ist, wie der Name schon sagt, ein Tunnel, der im IP-over-IP-Modus betrieben wird ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC 2003</a> ).  Der IPIP-Tunnelpaket-Header ist wie unten gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/369/49b/92c/36949b92c3d045185f09095a7a23dbfd.png"></div><br>  <i><font color="#999999">IPIP-Tunnelpaket-Header</font></i> <br><br>  Solche Tunnel werden üblicherweise verwendet, um zwei interne IPv4-Subnetze über ein öffentliches IPv4-Netzwerk (Internet) zu verbinden.  Die Verwendung von IPIP führt zu einer minimalen zusätzlichen Belastung des Systems, in einem solchen Tunnel kann jedoch nur eine Einwegdatenübertragung (Unicast) durchgeführt werden.  Das heißt, nachdem ein solcher Tunnel gebaut wurde, wird es nicht möglich sein, ihn für die Multicast-Datenübertragung zu verwenden. <br><br>  IPIP-Tunnel unterstützen die Modi IP over IP und MPLS over IP. <br><br>  Beachten Sie, dass der Linux-Kernel beim Laden des IPIP-Moduls oder beim erstmaligen Erstellen des <code>tunl0</code> Geräts in jedem Namespace ein Standardgerät <code>tunl0</code> mit den Attributen <code>local=any</code> und <code>remote=any</code> .  Beim Empfang von IPIP-Paketen leitet der Kernel diese in bestimmten Fällen an <code>tunl0</code> als Standardgerät um.  Dies geschieht, wenn der Kernel kein anderes Gerät finden kann, dessen <code>local/remote</code> Attribute besser mit den Quell- und Zieladressen der Pakete übereinstimmen. <br><br>  So erstellen Sie einen IPIP-Tunnel: <br><br>  Auf Server A: <br><br><pre> <code class="plaintext hljs"># ip link add name ipip0 type ipip local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR # ip link set ipip0 up # ip addr add INTERNAL_IPV4_ADDR/24 dev ipip0 Add a remote internal subnet route if the endpoints don't belong to the same subnet # ip route add REMOTE_INTERNAL_SUBNET/24 dev ipip0</code> </pre> <br>  Auf Server B: <br><br><pre> <code class="plaintext hljs"># ip link add name ipip0 type ipip local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR # ip link set ipip0 up # ip addr add INTERNAL_IPV4_ADDR/24 dev ipip0 # ip route add REMOTE_INTERNAL_SUBNET/24 dev ipip0</code> </pre> <br>  Bitte beachten Sie, dass diese Konfiguration bei Verwendung mit realen Daten in Einklang gebracht werden muss.  Insbesondere müssen <code>LOCAL_IPv4_ADDR</code> , <code>LOCAL_IPv4_ADDR</code> , <code>REMOTE_IPv4_ADDR</code> und <code>REMOTE_INTERNAL_SUBNET</code> durch die in Ihrer Umgebung verwendeten Adressen ersetzt werden.  Gleiches gilt für andere Konfigurationsbeispiele, die wir später betrachten werden. <br><br><h2>  <font color="#3AC1EF">Setz dich</font> </h2><br>  SIT (Simple Internet Transition) ist eine Tunneling-Technologie, deren Hauptzweck darin besteht, isolierte IPv6-Netzwerke über das Internet mithilfe des IPv4-Protokolls zu verbinden. <br><br>  Anfänglich konnte die SIT-Technologie nur im Tunnelmodus „IPv6 über IPv4“ funktionieren.  Im Laufe der Jahre der Entwicklung hat es jedoch die Unterstützung mehrerer weiterer Modi erhalten.  Insbesondere ist es <code>ipip</code> (dasselbe geschah mit dem IPIP-Tunnel), <code>ip6ip</code> , <code>mplsip</code> und <code>any</code> <code>mplsip</code> . <br><br>  <code>any</code> Modus wird verwendet, um mit IP- und IPv6-Verkehr zu arbeiten, was in einigen Situationen nützlich sein kann.  SIT-Tunnel unterstützen auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ISATAP</a> .  Hier ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel für die</a> Verwendung dieser Technologie. <br><br>  Der Header des SIT-Pakets ist wie unten gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/193/172/49e/19317249ec76200873dabf9aac6bc755.png"></div><br>  <i><font color="#999999">SIT-Tunnelpaket-Header</font></i> <br><br>  Wenn das <code>sit</code> Modul <code>sit0</code> , erstellt der Linux-Kernel das Standardgerät <code>sit0</code> . <br><br>  So erstellen Sie einen SIT-Tunnel (diese Schritte müssen auf den Servern A und B ausgeführt werden): <br><br><pre> <code class="plaintext hljs"># ip link add name sit1 type sit local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR mode any # ip link set sit1 up # ip addr add INTERNAL_IPV4_ADDR/24 dev sit1</code> </pre> <br><h2>  <font color="#3AC1EF">Ip6tnl</font> </h2><br>  Die ip6tnl-Schnittstelle funktioniert im IPv4 / IPv6-über-IPv6-Modus.  Es ähnelt der IPv6-Version des SIT-Tunnels.  So sieht der ip6tnl-Paket-Header aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e7/b3b/1b6/9e7b3b1b6862d0f3100c9c64db2171b7.png"></div><br>  <i><font color="#999999">Ip6tnl Tunnelpaket-Header</font></i> <br><br>  Ip6tnl-Tunnel unterstützen <code>ip6ip6</code> , <code>ipip6</code> und <code>any</code> Modi.  Der <code>ipip6</code> Modus <code>ipip6</code> durch das IPv4-über-IPv6-Schema dargestellt, der <code>ip6ip6</code> Modus ist IPv6 über IPv6.  <code>any</code> Modus unterstützt beide Schemata. <br><br>  Wenn das <code>ip6tnl</code> Modul <code>ip6tnl</code> wird, erstellt der Linux-Kernel ein Standardgerät namens <code>ip6tnl0</code> . <br><br>  So erstellen Sie einen ip6tnl-Tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add name ipip6 type ip6tnl local LOCAL_IPv6_ADDR remote REMOTE_IPv6_ADDR mode any</code> </pre> <br><h2>  <font color="#3AC1EF">VTI und VTI6</font> </h2><br>  Die Linux VTI-Schnittstelle (Virtual Tunnel Interface) ähnelt der Cisco VTI-Schnittstelle und der Juniper-Implementierung eines sicheren Tunnels (st.xx). <br><br>  Dieser Tunneltreiber implementiert die IP-Kapselung, die mit xfrm verwendet werden kann, um sichere Tunnel zu erstellen und dann Routing-Tunnel auf Kernel-Ebene über solche Tunnel zu verwenden. <br><br>  Im Allgemeinen funktionieren VTI-Tunnel ähnlich wie IPIP- oder SIT-Tunnel.  Die Ausnahme ist, dass sie fwmark und IPsec-Kapselung / -Entkapselung verwenden. <br><br>  VTI6 ist das IPv6-Äquivalent von VTI. <br><br>  So erstellen Sie einen VTI-Tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add name vti1 type vti key VTI_KEY local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR # ip link set vti1 up # ip addr add LOCAL_VIRTUAL_ADDR/24 dev vti1 # ip xfrm state add src LOCAL_IPv4_ADDR dst REMOTE_IPv4_ADDR spi SPI PROTO ALGR mode tunnel # ip xfrm state add src REMOTE_IPv4_ADDR dst LOCAL_IPv4_ADDR spi SPI PROTO ALGR mode tunnel # ip xfrm policy add dir in tmpl src REMOTE_IPv4_ADDR dst LOCAL_IPv4_ADDR PROTO mode tunnel mark VTI_KEY # ip xfrm policy add dir out tmpl src LOCAL_IPv4_ADDR dst REMOTE_IPv4_ADDR PROTO mode tunnel mark VTI_KEY</code> </pre> <br>  Darüber hinaus kann IPsec mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Libreswan</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StrongSwan</a> konfiguriert werden. <br><br><h2>  <font color="#3AC1EF">GRE und GRETAP</font> </h2><br>  Die GRE-Technologie (Generic Routing Encapsulation) ist in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC 2784 beschrieben</a> .  Beim GRE-Tunneling wird ein zusätzlicher GRE-Header zwischen den Headern der internen und externen IP-Pakete hinzugefügt. <br><br>  Theoretisch kann GRE Pakete eines beliebigen Layer 3-Protokolls mit einem gültigen Ethernet-Typ kapseln.  Dies unterscheidet die GRE-Technologie von der IPIP-Technologie, die nur die Kapselung von IP-Paketen unterstützt.  So sieht der Paket-Header bei Verwendung der GRE-Technologie aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22d/b74/b09/22db74b090586084bfe845c7df963139.png"></div><br>  <i><font color="#999999">GRE-Tunnelpaket-Header</font></i> <br><br>  Bitte beachten Sie, dass GRE-Tunnel Multicast- und IPv6-Unterstützung ermöglichen. <br><br>  Beim Laden des <code>gre</code> Moduls erstellt der Linux-Kernel das Standardgerät <code>gre0</code> . <br><br>  So erstellen Sie einen GRE-Tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add name gre1 type gre local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR [seq] key KEY</code> </pre> <br>  Während GRE-Tunnel auf OSI-Schicht 3 arbeiten, arbeiten GRETAP-Tunnel auf OSI-Schicht 2.  Dies bedeutet, dass einer der internen Header der jeweiligen Pakete Ethernet-Header sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1da/ec8/099/1daec8099c6cede117df740da4791144.png"></div><br>  <i><font color="#999999">GRETAP-Tunnelpaket-Header</font></i> <br><br>  So erstellen Sie einen GRETAP-Tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add name gretap1 type gretap local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR</code> </pre> <br><h2>  <font color="#3AC1EF">GRE6 und GRE6TAP</font> </h2><br>  GRE6 ist das IPv6-Äquivalent von GRE.  Mit GRE6-Tunneln können Sie jedes Layer 3-Protokoll in IPv6 kapseln.  So sieht der GRE6-Paket-Header aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d8c/69e/45a/d8c69e45aab1f77ea5948cf2a6e81c35.png"></div><br>  <i><font color="#999999">GRE6 Tunnel Package Header</font></i> <br><br>  In GRE6TAP-Tunneln befinden sich wie in GRETAP-Tunneln Ethernet-Header unter den internen Paket-Headern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72c/290/7c7/72c2907c7c649e6390d1e51156bcac57.png"></div><br>  <i><font color="#999999">GRE6TAP-Tunnelpaket-Header</font></i> <br><br>  So erstellen Sie einen GRE-Tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add name gre1 type gre6 local LOCAL_IPv6_ADDR remote REMOTE_IPv6_ADDR # ip link add name gretap1 type gretap6 local LOCAL_IPv6_ADDR remote REMOTE_IPv6_ADDR</code> </pre> <br><h2>  <font color="#3AC1EF">Fou</font> </h2><br>  Das Tunneln kann auf verschiedenen Ebenen des Netzwerkstapels durchgeführt werden.  Auf der IP-Ebene gibt es IPIP-, SIT- und GRE-Tunnel.  Und die FOU-Tunnel (sie sind nach dem Schema „foo over UDP“ angeordnet) arbeiten auf UDP-Ebene. <br><br>  Die Verwendung des UDP-Tunnels gegenüber dem IP-Tunneling bietet einige Vorteile.  Tatsache ist, dass das UDP-Protokoll mit der vorhandenen Hardware-Infrastruktur funktioniert. <br><br>  Dies ist beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RSS</a> in Netzwerkkarten, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ECMP</a> in Switches. Dies sind Technologien zur Berechnung von Prüfsummen ohne Beteiligung eines Zentralprozessors.  Das Anwenden des entsprechenden FOU- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patches</a> auf Entwickler zeigt eine signifikante Leistungssteigerung für SIT und IPIP. <br><br>  Derzeit unterstützen FOU-Tunnel die Protokollkapselung basierend auf IPIP, SIT und GRE.  So könnte der Header eines FOU-Pakets aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90d/a66/cb9/90da66cb92c6e3083f29ed97b952e0b6.png"></div><br>  <i><font color="#999999">FOU Tunnel Paket Header</font></i> <br><br>  So erstellen Sie einen FOU-Tunnel: <br><br><pre> <code class="plaintext hljs"># ip fou add port 5555 ipproto 4 # ip link add name tun1 type ipip remote 192.168.1.1 local 192.168.1.2 ttl 225 encap fou encap-sport auto encap-dport 5555</code> </pre> <br>  Der erste Befehl konfiguriert den empfangenden FOU-Port für IPIP, das an 5555 gebunden ist. Um GRE verwenden zu können, müssen Sie <code>ipproto 47</code> .  Der zweite Befehl konfiguriert die neue virtuelle IPIP-Schnittstelle ( <code>tun1</code> ), die für die FOU-Kapselung ausgelegt ist und deren Zielport 5555 ist. <br><br>  Bitte beachten Sie, dass FOU-Tunnel unter Red Hat Enterprise Linux nicht unterstützt werden. <br><br><h2>  <font color="#3AC1EF">Gue</font> </h2><br>  Eine andere Art des UDP-Tunnelns wird durch die GUE-Technologie ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Generic UDP Encapsulation</a> ) eingeführt.  Der Unterschied zwischen FOU und GUE besteht darin, dass GUE einen eigenen Header hat, der Protokollinformationen und andere Daten enthält. <br><br>  GUE-Tunnel unterstützen derzeit die interne Kapselung von IPIP, SIT und GRE.  So könnte ein GUE-Paket-Header aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/412/d7f/d38/412d7fd38350aa55b24cb0b93865d93c.png"></div><br>  <i><font color="#999999">GUE Tunnel Package Header</font></i> <br><br>  So erstellen Sie einen GUE-Tunnel: <br><br><pre> <code class="plaintext hljs"># ip fou add port 5555 gue # ip link add name tun1 type ipip remote 192.168.1.1 local 192.168.1.2 ttl 225 encap gue encap-sport auto encap-dport 5555</code> </pre> <br>  Dank dieser Befehle werden ein empfangender GUE-Port für IPIP, der an die Nummer 5555 gebunden ist, und ein IPIP-Tunnel erstellt, der für die GUE-Kapselung konfiguriert ist. <br><br>  GUE-Tunnel werden unter Red Hat Enterprise Linux nicht unterstützt. <br><br><h2>  <font color="#3AC1EF">GENF</font> </h2><br>  Die GENEVE-Tunnel (Generic Network Virtualization Encapsulation) unterstützen alle Funktionen von XLAN, NVGRE und STT.  Die GENEVE-Technologie wurde entwickelt, um die identifizierten Einschränkungen dieser drei Technologien zu umgehen.  Viele glauben, dass diese Technologie diese drei älteren Formate langfristig vollständig ersetzen kann.  So sieht der GENEVE-Tunnelpaket-Header aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/767/f30/98e/767f3098ee539caf3f03778143fa6106.png"></div><br>  <i><font color="#999999">GENEVE Tunnel Package Header</font></i> <br><br>  Dieser Header ähnelt dem Header eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VXLAN-</a> Pakets.  Der Hauptunterschied zwischen den beiden besteht darin, dass der GENEVE-Header flexibler ist.  Es macht es sehr einfach, neue Funktionen zu implementieren, indem Header mithilfe von TLV-Feldern (Type-Length-Value) erweitert werden. <br><br>  Details zu GENEVE finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  GENEVE wird in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open Virtual Network</a> (OVN) SDN-Lösung als Standard-Kapselungstool verwendet.  So erstellen Sie einen GENEVE-Tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add name geneve0 type geneve id VNI remote REMOTE_IPv4_ADDR</code> </pre> <br><h2>  <font color="#3AC1EF">ERSPAN und IP6ERSPAN</font> </h2><br>  Die ERSPAN-Technologie (Encapsulated Remote Switched Port Analyzer) verwendet die GRE-Kapselung, um die grundlegenden Funktionen der Portspiegelung von Schicht 2 auf Schicht 3 zu erweitern.  Auf diese Weise können Sie gespiegelten Datenverkehr über ein geroutetes IP-Netzwerk weiterleiten.  So sieht der ERSPAN-Paket-Header aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dee/15d/871/dee15d871a6ee9d433f154b9a6a6e048.png"></div><br>  <i><font color="#999999">ERSPAN Tunnel Package Header</font></i> <br><br>  Mit ERSPAN-Tunneln können Linux-Hosts als ERSPAN-Verkehrsquelle fungieren und gespiegelten ERSPAN-Verkehr entweder an einen Remote-Host oder an ein ERSPAN-Ziel senden, das ERSPAN-Pakete empfängt und verarbeitet, die von Cisco-Switches oder anderen Geräten, die ERSPAN unterstützen, generiert wurden.  Ein ähnliches System kann zur Analyse und Diagnose des Netzwerks verwendet werden, um böswilligen Datenverkehr zu erkennen. <br><br>  Linux unterstützt derzeit die meisten Funktionen der beiden Versionen von ERSPAN - v1 (Typ II) und v2 (Typ III). <br><br>  So erstellen Sie ERSPAN-Tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add dev erspan1 type erspan local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR seq key KEY erspan_ver 1 erspan IDX</code> </pre> <br>  Sie können dies auch tun: <br><br><pre> <code class="plaintext hljs"># ip link add dev erspan1 type erspan local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR seq key KEY erspan_ver 2 erspan_dir DIRECTION erspan_hwid HWID</code> </pre> <br>  Fügen Sie einen TC-Filter hinzu, um den Datenverkehr zu überwachen: <br><br><pre> <code class="plaintext hljs"># tc qdisc add dev MONITOR_DEV handle ffff: ingress # tc filter add dev MONITOR_DEV parent ffff: matchall skip_hw action mirred egress mirror dev erspan1</code> </pre> <br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Wir haben hier einige Tunneltechnologien unter Linux behandelt.  Hier ist eine Übersichtstabelle für sie. <br><br><div class="scrollable-table"><table><tbody><tr><td>  Tunnel- / Verbindungstyp <br></td><td>  Äußerer Header <br></td><td>  Eingekapselter Header <br></td><td>  Innerer Header <br></td></tr><tr><td>  ipip <br></td><td>  IPv4 <br></td><td>  Keine <br></td><td>  IPv4 <br></td></tr><tr><td>  sitzen <br></td><td>  IPv4 <br></td><td>  Keine <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  ip6tnl <br></td><td>  IPv4 <br></td><td>  Keine <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  vti <br></td><td>  IPv4 <br></td><td>  IPsec <br></td><td>  IPv4 <br></td></tr><tr><td>  vti6 <br></td><td>  IPv6 <br></td><td>  IPsec <br></td><td>  IPv6 <br></td></tr><tr><td>  gre <br></td><td>  IPv4 <br></td><td>  GRE <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  gretap <br></td><td>  IPv4 <br></td><td>  GRE <br></td><td>  Ether + IPv4 / IPv6 <br></td></tr><tr><td>  gre6 <br></td><td>  IPv6 <br></td><td>  GRE <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  gre6tap <br></td><td>  IPv6 <br></td><td>  GRE <br></td><td>  Ether + IPv4 / IPv6 <br></td></tr><tr><td>  fou <br></td><td>  IPv4 / IPv6 <br></td><td>  UDP <br></td><td>  IPv4 / IPv6 / GRE <br></td></tr><tr><td>  gue <br></td><td>  IPv4 / IPv6 <br></td><td>  UDP + GUE <br></td><td>  IPv4 / IPv6 / GRE <br></td></tr><tr><td>  genve <br></td><td>  IPv4 / IPv6 <br></td><td>  UDP + Geneve <br></td><td>  Ether + IPv4 / IPv6 <br></td></tr><tr><td>  erspan <br></td><td>  IPv4 <br></td><td>  GRE + ERSPAN <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  ip6erspan <br></td><td>  IPv6 <br></td><td>  GRE + ERSPAN <br></td><td>  IPv4 / IPv6 <br></td></tr></tbody></table></div><br>  Bitte beachten Sie, dass alle Tunnel, deren Erstellungsbeispiele hier gezeigt werden, nur bis zum Neustart des Servers vorhanden sind.  Wenn Sie einen Tunnel erstellen möchten, der nach dem Neustart wiederhergestellt wird, sollten Sie einen Dämon verwenden, um das Netzwerk wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NetworkManager</a> zu konfigurieren, oder den entsprechenden Mechanismus aus der von Ihnen verwendeten Linux-Distribution verwenden. <br><br>  <b>Liebe Leser!</b>  Welche Linux-Tunnel verwenden Sie? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457386/">https://habr.com/ru/post/de457386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457366/index.html">Ein Fanatiker, ein Stück Eisen oder ein Zuschauer - was für ein Spieler bist du?</a></li>
<li><a href="../de457374/index.html">Reduzieren Sie die Erstellungszeit Ihrer Android-Projekte</a></li>
<li><a href="../de457378/index.html">Wie id Software Wolfenstein 3D basierend auf der Technologie von Commander Keen erstellt hat</a></li>
<li><a href="../de457380/index.html">Ultramodernes OpenGL. Teil 2</a></li>
<li><a href="../de457382/index.html">7 Gewohnheiten von Hochleistungsprogrammierern</a></li>
<li><a href="../de457390/index.html">Madagaskar - Insel der Kontraste</a></li>
<li><a href="../de457392/index.html">Einsparungen bei der plattformübergreifenden mobilen Entwicklung: Skyeng-Fallstudie</a></li>
<li><a href="../de457396/index.html">Automatisches Entsperren des Root-LUKS-Containers nach einem Hot-Boot</a></li>
<li><a href="../de457398/index.html">Aber mache ich Bullshit? Warum gehen Entwickler zu gemba?</a></li>
<li><a href="../de457400/index.html">Die Zahl der Opfer von Atomkatastrophen wie Tschernobyl ist für das Drama stark übertrieben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>