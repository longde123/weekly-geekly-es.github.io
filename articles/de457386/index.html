<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚ÄçüöÄ üë©üèΩ‚Äçüç≥ üèπ Einf√ºhrung in virtuelle Linux-Schnittstellen: Tunnel üë®‚Äçüè≠ üëÅ‚Äçüó® üë®‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Linux unterst√ºtzt viele Arten von Tunneln. Dies verwirrt Anf√§nger, die Schwierigkeiten haben, die technologischen Unterschiede zu verstehen und zu ver...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einf√ºhrung in virtuelle Linux-Schnittstellen: Tunnel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/457386/"> Linux unterst√ºtzt viele Arten von Tunneln.  Dies verwirrt Anf√§nger, die Schwierigkeiten haben, die technologischen Unterschiede zu verstehen und zu verstehen, welcher Tunnel in einer bestimmten Situation besser zu verwenden ist.  Das Material, dessen √úbersetzung wir heute ver√∂ffentlichen, gibt einen kurzen √úberblick √ºber die h√§ufig verwendeten Tunneling-Schnittstellen des Linux-Kernels.  Wir werden uns nicht eingehend mit diesem Thema befassen, sondern nur die allgemeinen Merkmale von Tunneln und Optionen f√ºr ihre Verwendung unter Linux ber√ºcksichtigen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/-0/wg/hq/-0wghqvj6hymntfthlttl1xu6tm.jpeg"></a> <br><br>  Der Autor dieses Materials ist der Ansicht, dass das, was hier diskutiert wird, f√ºr jeden von Interesse sein kann, der etwas mit der Verwaltung von Computernetzwerken zu tun hat.  Die Liste der Tunnelschnittstellen sowie Referenzinformationen zu einer bestimmten Konfiguration k√∂nnen mit dem Hilfebefehl iproute2 <code>ip link help</code> abgerufen werden. <br><br>  Die folgenden h√§ufig verwendeten Schnittstellen werden hier behandelt: IPIP, SIT, ip6tnl, VTI und VTI6, GRE und GRETAP, GRE6 und GRE6TAP, FOU, GUE, GENEVE, ERSPAN und IP6ERSPAN. <br><br>  Nachdem Sie diesen Artikel gelesen haben, lernen Sie die Funktionen dieser Schnittstellen kennen und die Unterschiede zwischen ihnen herausfinden.  Sie lernen, wie Sie sie erstellen und Situationen kennen, in denen sie am besten verwendet werden. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">IPIP</font> </h2><br>  Der IPIP-Tunnel ist, wie der Name schon sagt, ein Tunnel, der im IP-over-IP-Modus betrieben wird ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC 2003</a> ).  Der IPIP-Tunnelpaket-Header ist wie unten gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/369/49b/92c/36949b92c3d045185f09095a7a23dbfd.png"></div><br>  <i><font color="#999999">IPIP-Tunnelpaket-Header</font></i> <br><br>  Solche Tunnel werden √ºblicherweise verwendet, um zwei interne IPv4-Subnetze √ºber ein √∂ffentliches IPv4-Netzwerk (Internet) zu verbinden.  Die Verwendung von IPIP f√ºhrt zu einer minimalen zus√§tzlichen Belastung des Systems, in einem solchen Tunnel kann jedoch nur eine Einwegdaten√ºbertragung (Unicast) durchgef√ºhrt werden.  Das hei√üt, nachdem ein solcher Tunnel gebaut wurde, wird es nicht m√∂glich sein, ihn f√ºr die Multicast-Daten√ºbertragung zu verwenden. <br><br>  IPIP-Tunnel unterst√ºtzen die Modi IP over IP und MPLS over IP. <br><br>  Beachten Sie, dass der Linux-Kernel beim Laden des IPIP-Moduls oder beim erstmaligen Erstellen des <code>tunl0</code> Ger√§ts in jedem Namespace ein Standardger√§t <code>tunl0</code> mit den Attributen <code>local=any</code> und <code>remote=any</code> .  Beim Empfang von IPIP-Paketen leitet der Kernel diese in bestimmten F√§llen an <code>tunl0</code> als Standardger√§t um.  Dies geschieht, wenn der Kernel kein anderes Ger√§t finden kann, dessen <code>local/remote</code> Attribute besser mit den Quell- und Zieladressen der Pakete √ºbereinstimmen. <br><br>  So erstellen Sie einen IPIP-Tunnel: <br><br>  Auf Server A: <br><br><pre> <code class="plaintext hljs"># ip link add name ipip0 type ipip local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR # ip link set ipip0 up # ip addr add INTERNAL_IPV4_ADDR/24 dev ipip0 Add a remote internal subnet route if the endpoints don't belong to the same subnet # ip route add REMOTE_INTERNAL_SUBNET/24 dev ipip0</code> </pre> <br>  Auf Server B: <br><br><pre> <code class="plaintext hljs"># ip link add name ipip0 type ipip local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR # ip link set ipip0 up # ip addr add INTERNAL_IPV4_ADDR/24 dev ipip0 # ip route add REMOTE_INTERNAL_SUBNET/24 dev ipip0</code> </pre> <br>  Bitte beachten Sie, dass diese Konfiguration bei Verwendung mit realen Daten in Einklang gebracht werden muss.  Insbesondere m√ºssen <code>LOCAL_IPv4_ADDR</code> , <code>LOCAL_IPv4_ADDR</code> , <code>REMOTE_IPv4_ADDR</code> und <code>REMOTE_INTERNAL_SUBNET</code> durch die in Ihrer Umgebung verwendeten Adressen ersetzt werden.  Gleiches gilt f√ºr andere Konfigurationsbeispiele, die wir sp√§ter betrachten werden. <br><br><h2>  <font color="#3AC1EF">Setz dich</font> </h2><br>  SIT (Simple Internet Transition) ist eine Tunneling-Technologie, deren Hauptzweck darin besteht, isolierte IPv6-Netzwerke √ºber das Internet mithilfe des IPv4-Protokolls zu verbinden. <br><br>  Anf√§nglich konnte die SIT-Technologie nur im Tunnelmodus ‚ÄûIPv6 √ºber IPv4‚Äú funktionieren.  Im Laufe der Jahre der Entwicklung hat es jedoch die Unterst√ºtzung mehrerer weiterer Modi erhalten.  Insbesondere ist es <code>ipip</code> (dasselbe geschah mit dem IPIP-Tunnel), <code>ip6ip</code> , <code>mplsip</code> und <code>any</code> <code>mplsip</code> . <br><br>  <code>any</code> Modus wird verwendet, um mit IP- und IPv6-Verkehr zu arbeiten, was in einigen Situationen n√ºtzlich sein kann.  SIT-Tunnel unterst√ºtzen auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ISATAP</a> .  Hier ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel f√ºr die</a> Verwendung dieser Technologie. <br><br>  Der Header des SIT-Pakets ist wie unten gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/193/172/49e/19317249ec76200873dabf9aac6bc755.png"></div><br>  <i><font color="#999999">SIT-Tunnelpaket-Header</font></i> <br><br>  Wenn das <code>sit</code> Modul <code>sit0</code> , erstellt der Linux-Kernel das Standardger√§t <code>sit0</code> . <br><br>  So erstellen Sie einen SIT-Tunnel (diese Schritte m√ºssen auf den Servern A und B ausgef√ºhrt werden): <br><br><pre> <code class="plaintext hljs"># ip link add name sit1 type sit local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR mode any # ip link set sit1 up # ip addr add INTERNAL_IPV4_ADDR/24 dev sit1</code> </pre> <br><h2>  <font color="#3AC1EF">Ip6tnl</font> </h2><br>  Die ip6tnl-Schnittstelle funktioniert im IPv4 / IPv6-√ºber-IPv6-Modus.  Es √§hnelt der IPv6-Version des SIT-Tunnels.  So sieht der ip6tnl-Paket-Header aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e7/b3b/1b6/9e7b3b1b6862d0f3100c9c64db2171b7.png"></div><br>  <i><font color="#999999">Ip6tnl Tunnelpaket-Header</font></i> <br><br>  Ip6tnl-Tunnel unterst√ºtzen <code>ip6ip6</code> , <code>ipip6</code> und <code>any</code> Modi.  Der <code>ipip6</code> Modus <code>ipip6</code> durch das IPv4-√ºber-IPv6-Schema dargestellt, der <code>ip6ip6</code> Modus ist IPv6 √ºber IPv6.  <code>any</code> Modus unterst√ºtzt beide Schemata. <br><br>  Wenn das <code>ip6tnl</code> Modul <code>ip6tnl</code> wird, erstellt der Linux-Kernel ein Standardger√§t namens <code>ip6tnl0</code> . <br><br>  So erstellen Sie einen ip6tnl-Tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add name ipip6 type ip6tnl local LOCAL_IPv6_ADDR remote REMOTE_IPv6_ADDR mode any</code> </pre> <br><h2>  <font color="#3AC1EF">VTI und VTI6</font> </h2><br>  Die Linux VTI-Schnittstelle (Virtual Tunnel Interface) √§hnelt der Cisco VTI-Schnittstelle und der Juniper-Implementierung eines sicheren Tunnels (st.xx). <br><br>  Dieser Tunneltreiber implementiert die IP-Kapselung, die mit xfrm verwendet werden kann, um sichere Tunnel zu erstellen und dann Routing-Tunnel auf Kernel-Ebene √ºber solche Tunnel zu verwenden. <br><br>  Im Allgemeinen funktionieren VTI-Tunnel √§hnlich wie IPIP- oder SIT-Tunnel.  Die Ausnahme ist, dass sie fwmark und IPsec-Kapselung / -Entkapselung verwenden. <br><br>  VTI6 ist das IPv6-√Ñquivalent von VTI. <br><br>  So erstellen Sie einen VTI-Tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add name vti1 type vti key VTI_KEY local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR # ip link set vti1 up # ip addr add LOCAL_VIRTUAL_ADDR/24 dev vti1 # ip xfrm state add src LOCAL_IPv4_ADDR dst REMOTE_IPv4_ADDR spi SPI PROTO ALGR mode tunnel # ip xfrm state add src REMOTE_IPv4_ADDR dst LOCAL_IPv4_ADDR spi SPI PROTO ALGR mode tunnel # ip xfrm policy add dir in tmpl src REMOTE_IPv4_ADDR dst LOCAL_IPv4_ADDR PROTO mode tunnel mark VTI_KEY # ip xfrm policy add dir out tmpl src LOCAL_IPv4_ADDR dst REMOTE_IPv4_ADDR PROTO mode tunnel mark VTI_KEY</code> </pre> <br>  Dar√ºber hinaus kann IPsec mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Libreswan</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StrongSwan</a> konfiguriert werden. <br><br><h2>  <font color="#3AC1EF">GRE und GRETAP</font> </h2><br>  Die GRE-Technologie (Generic Routing Encapsulation) ist in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC 2784 beschrieben</a> .  Beim GRE-Tunneling wird ein zus√§tzlicher GRE-Header zwischen den Headern der internen und externen IP-Pakete hinzugef√ºgt. <br><br>  Theoretisch kann GRE Pakete eines beliebigen Layer 3-Protokolls mit einem g√ºltigen Ethernet-Typ kapseln.  Dies unterscheidet die GRE-Technologie von der IPIP-Technologie, die nur die Kapselung von IP-Paketen unterst√ºtzt.  So sieht der Paket-Header bei Verwendung der GRE-Technologie aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22d/b74/b09/22db74b090586084bfe845c7df963139.png"></div><br>  <i><font color="#999999">GRE-Tunnelpaket-Header</font></i> <br><br>  Bitte beachten Sie, dass GRE-Tunnel Multicast- und IPv6-Unterst√ºtzung erm√∂glichen. <br><br>  Beim Laden des <code>gre</code> Moduls erstellt der Linux-Kernel das Standardger√§t <code>gre0</code> . <br><br>  So erstellen Sie einen GRE-Tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add name gre1 type gre local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR [seq] key KEY</code> </pre> <br>  W√§hrend GRE-Tunnel auf OSI-Schicht 3 arbeiten, arbeiten GRETAP-Tunnel auf OSI-Schicht 2.  Dies bedeutet, dass einer der internen Header der jeweiligen Pakete Ethernet-Header sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1da/ec8/099/1daec8099c6cede117df740da4791144.png"></div><br>  <i><font color="#999999">GRETAP-Tunnelpaket-Header</font></i> <br><br>  So erstellen Sie einen GRETAP-Tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add name gretap1 type gretap local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR</code> </pre> <br><h2>  <font color="#3AC1EF">GRE6 und GRE6TAP</font> </h2><br>  GRE6 ist das IPv6-√Ñquivalent von GRE.  Mit GRE6-Tunneln k√∂nnen Sie jedes Layer 3-Protokoll in IPv6 kapseln.  So sieht der GRE6-Paket-Header aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d8c/69e/45a/d8c69e45aab1f77ea5948cf2a6e81c35.png"></div><br>  <i><font color="#999999">GRE6 Tunnel Package Header</font></i> <br><br>  In GRE6TAP-Tunneln befinden sich wie in GRETAP-Tunneln Ethernet-Header unter den internen Paket-Headern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72c/290/7c7/72c2907c7c649e6390d1e51156bcac57.png"></div><br>  <i><font color="#999999">GRE6TAP-Tunnelpaket-Header</font></i> <br><br>  So erstellen Sie einen GRE-Tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add name gre1 type gre6 local LOCAL_IPv6_ADDR remote REMOTE_IPv6_ADDR # ip link add name gretap1 type gretap6 local LOCAL_IPv6_ADDR remote REMOTE_IPv6_ADDR</code> </pre> <br><h2>  <font color="#3AC1EF">Fou</font> </h2><br>  Das Tunneln kann auf verschiedenen Ebenen des Netzwerkstapels durchgef√ºhrt werden.  Auf der IP-Ebene gibt es IPIP-, SIT- und GRE-Tunnel.  Und die FOU-Tunnel (sie sind nach dem Schema ‚Äûfoo over UDP‚Äú angeordnet) arbeiten auf UDP-Ebene. <br><br>  Die Verwendung des UDP-Tunnels gegen√ºber dem IP-Tunneling bietet einige Vorteile.  Tatsache ist, dass das UDP-Protokoll mit der vorhandenen Hardware-Infrastruktur funktioniert. <br><br>  Dies ist beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RSS</a> in Netzwerkkarten, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ECMP</a> in Switches. Dies sind Technologien zur Berechnung von Pr√ºfsummen ohne Beteiligung eines Zentralprozessors.  Das Anwenden des entsprechenden FOU- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patches</a> auf Entwickler zeigt eine signifikante Leistungssteigerung f√ºr SIT und IPIP. <br><br>  Derzeit unterst√ºtzen FOU-Tunnel die Protokollkapselung basierend auf IPIP, SIT und GRE.  So k√∂nnte der Header eines FOU-Pakets aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90d/a66/cb9/90da66cb92c6e3083f29ed97b952e0b6.png"></div><br>  <i><font color="#999999">FOU Tunnel Paket Header</font></i> <br><br>  So erstellen Sie einen FOU-Tunnel: <br><br><pre> <code class="plaintext hljs"># ip fou add port 5555 ipproto 4 # ip link add name tun1 type ipip remote 192.168.1.1 local 192.168.1.2 ttl 225 encap fou encap-sport auto encap-dport 5555</code> </pre> <br>  Der erste Befehl konfiguriert den empfangenden FOU-Port f√ºr IPIP, das an 5555 gebunden ist. Um GRE verwenden zu k√∂nnen, m√ºssen Sie <code>ipproto 47</code> .  Der zweite Befehl konfiguriert die neue virtuelle IPIP-Schnittstelle ( <code>tun1</code> ), die f√ºr die FOU-Kapselung ausgelegt ist und deren Zielport 5555 ist. <br><br>  Bitte beachten Sie, dass FOU-Tunnel unter Red Hat Enterprise Linux nicht unterst√ºtzt werden. <br><br><h2>  <font color="#3AC1EF">Gue</font> </h2><br>  Eine andere Art des UDP-Tunnelns wird durch die GUE-Technologie ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Generic UDP Encapsulation</a> ) eingef√ºhrt.  Der Unterschied zwischen FOU und GUE besteht darin, dass GUE einen eigenen Header hat, der Protokollinformationen und andere Daten enth√§lt. <br><br>  GUE-Tunnel unterst√ºtzen derzeit die interne Kapselung von IPIP, SIT und GRE.  So k√∂nnte ein GUE-Paket-Header aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/412/d7f/d38/412d7fd38350aa55b24cb0b93865d93c.png"></div><br>  <i><font color="#999999">GUE Tunnel Package Header</font></i> <br><br>  So erstellen Sie einen GUE-Tunnel: <br><br><pre> <code class="plaintext hljs"># ip fou add port 5555 gue # ip link add name tun1 type ipip remote 192.168.1.1 local 192.168.1.2 ttl 225 encap gue encap-sport auto encap-dport 5555</code> </pre> <br>  Dank dieser Befehle werden ein empfangender GUE-Port f√ºr IPIP, der an die Nummer 5555 gebunden ist, und ein IPIP-Tunnel erstellt, der f√ºr die GUE-Kapselung konfiguriert ist. <br><br>  GUE-Tunnel werden unter Red Hat Enterprise Linux nicht unterst√ºtzt. <br><br><h2>  <font color="#3AC1EF">GENF</font> </h2><br>  Die GENEVE-Tunnel (Generic Network Virtualization Encapsulation) unterst√ºtzen alle Funktionen von XLAN, NVGRE und STT.  Die GENEVE-Technologie wurde entwickelt, um die identifizierten Einschr√§nkungen dieser drei Technologien zu umgehen.  Viele glauben, dass diese Technologie diese drei √§lteren Formate langfristig vollst√§ndig ersetzen kann.  So sieht der GENEVE-Tunnelpaket-Header aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/767/f30/98e/767f3098ee539caf3f03778143fa6106.png"></div><br>  <i><font color="#999999">GENEVE Tunnel Package Header</font></i> <br><br>  Dieser Header √§hnelt dem Header eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VXLAN-</a> Pakets.  Der Hauptunterschied zwischen den beiden besteht darin, dass der GENEVE-Header flexibler ist.  Es macht es sehr einfach, neue Funktionen zu implementieren, indem Header mithilfe von TLV-Feldern (Type-Length-Value) erweitert werden. <br><br>  Details zu GENEVE finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  GENEVE wird in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open Virtual Network</a> (OVN) SDN-L√∂sung als Standard-Kapselungstool verwendet.  So erstellen Sie einen GENEVE-Tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add name geneve0 type geneve id VNI remote REMOTE_IPv4_ADDR</code> </pre> <br><h2>  <font color="#3AC1EF">ERSPAN und IP6ERSPAN</font> </h2><br>  Die ERSPAN-Technologie (Encapsulated Remote Switched Port Analyzer) verwendet die GRE-Kapselung, um die grundlegenden Funktionen der Portspiegelung von Schicht 2 auf Schicht 3 zu erweitern.  Auf diese Weise k√∂nnen Sie gespiegelten Datenverkehr √ºber ein geroutetes IP-Netzwerk weiterleiten.  So sieht der ERSPAN-Paket-Header aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dee/15d/871/dee15d871a6ee9d433f154b9a6a6e048.png"></div><br>  <i><font color="#999999">ERSPAN Tunnel Package Header</font></i> <br><br>  Mit ERSPAN-Tunneln k√∂nnen Linux-Hosts als ERSPAN-Verkehrsquelle fungieren und gespiegelten ERSPAN-Verkehr entweder an einen Remote-Host oder an ein ERSPAN-Ziel senden, das ERSPAN-Pakete empf√§ngt und verarbeitet, die von Cisco-Switches oder anderen Ger√§ten, die ERSPAN unterst√ºtzen, generiert wurden.  Ein √§hnliches System kann zur Analyse und Diagnose des Netzwerks verwendet werden, um b√∂swilligen Datenverkehr zu erkennen. <br><br>  Linux unterst√ºtzt derzeit die meisten Funktionen der beiden Versionen von ERSPAN - v1 (Typ II) und v2 (Typ III). <br><br>  So erstellen Sie ERSPAN-Tunnel: <br><br><pre> <code class="plaintext hljs"># ip link add dev erspan1 type erspan local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR seq key KEY erspan_ver 1 erspan IDX</code> </pre> <br>  Sie k√∂nnen dies auch tun: <br><br><pre> <code class="plaintext hljs"># ip link add dev erspan1 type erspan local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR seq key KEY erspan_ver 2 erspan_dir DIRECTION erspan_hwid HWID</code> </pre> <br>  F√ºgen Sie einen TC-Filter hinzu, um den Datenverkehr zu √ºberwachen: <br><br><pre> <code class="plaintext hljs"># tc qdisc add dev MONITOR_DEV handle ffff: ingress # tc filter add dev MONITOR_DEV parent ffff: matchall skip_hw action mirred egress mirror dev erspan1</code> </pre> <br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Wir haben hier einige Tunneltechnologien unter Linux behandelt.  Hier ist eine √úbersichtstabelle f√ºr sie. <br><br><div class="scrollable-table"><table><tbody><tr><td>  Tunnel- / Verbindungstyp <br></td><td>  √Ñu√üerer Header <br></td><td>  Eingekapselter Header <br></td><td>  Innerer Header <br></td></tr><tr><td>  ipip <br></td><td>  IPv4 <br></td><td>  Keine <br></td><td>  IPv4 <br></td></tr><tr><td>  sitzen <br></td><td>  IPv4 <br></td><td>  Keine <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  ip6tnl <br></td><td>  IPv4 <br></td><td>  Keine <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  vti <br></td><td>  IPv4 <br></td><td>  IPsec <br></td><td>  IPv4 <br></td></tr><tr><td>  vti6 <br></td><td>  IPv6 <br></td><td>  IPsec <br></td><td>  IPv6 <br></td></tr><tr><td>  gre <br></td><td>  IPv4 <br></td><td>  GRE <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  gretap <br></td><td>  IPv4 <br></td><td>  GRE <br></td><td>  Ether + IPv4 / IPv6 <br></td></tr><tr><td>  gre6 <br></td><td>  IPv6 <br></td><td>  GRE <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  gre6tap <br></td><td>  IPv6 <br></td><td>  GRE <br></td><td>  Ether + IPv4 / IPv6 <br></td></tr><tr><td>  fou <br></td><td>  IPv4 / IPv6 <br></td><td>  UDP <br></td><td>  IPv4 / IPv6 / GRE <br></td></tr><tr><td>  gue <br></td><td>  IPv4 / IPv6 <br></td><td>  UDP + GUE <br></td><td>  IPv4 / IPv6 / GRE <br></td></tr><tr><td>  genve <br></td><td>  IPv4 / IPv6 <br></td><td>  UDP + Geneve <br></td><td>  Ether + IPv4 / IPv6 <br></td></tr><tr><td>  erspan <br></td><td>  IPv4 <br></td><td>  GRE + ERSPAN <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  ip6erspan <br></td><td>  IPv6 <br></td><td>  GRE + ERSPAN <br></td><td>  IPv4 / IPv6 <br></td></tr></tbody></table></div><br>  Bitte beachten Sie, dass alle Tunnel, deren Erstellungsbeispiele hier gezeigt werden, nur bis zum Neustart des Servers vorhanden sind.  Wenn Sie einen Tunnel erstellen m√∂chten, der nach dem Neustart wiederhergestellt wird, sollten Sie einen D√§mon verwenden, um das Netzwerk wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NetworkManager</a> zu konfigurieren, oder den entsprechenden Mechanismus aus der von Ihnen verwendeten Linux-Distribution verwenden. <br><br>  <b>Liebe Leser!</b>  Welche Linux-Tunnel verwenden Sie? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457386/">https://habr.com/ru/post/de457386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457366/index.html">Ein Fanatiker, ein St√ºck Eisen oder ein Zuschauer - was f√ºr ein Spieler bist du?</a></li>
<li><a href="../de457374/index.html">Reduzieren Sie die Erstellungszeit Ihrer Android-Projekte</a></li>
<li><a href="../de457378/index.html">Wie id Software Wolfenstein 3D basierend auf der Technologie von Commander Keen erstellt hat</a></li>
<li><a href="../de457380/index.html">Ultramodernes OpenGL. Teil 2</a></li>
<li><a href="../de457382/index.html">7 Gewohnheiten von Hochleistungsprogrammierern</a></li>
<li><a href="../de457390/index.html">Madagaskar - Insel der Kontraste</a></li>
<li><a href="../de457392/index.html">Einsparungen bei der plattform√ºbergreifenden mobilen Entwicklung: Skyeng-Fallstudie</a></li>
<li><a href="../de457396/index.html">Automatisches Entsperren des Root-LUKS-Containers nach einem Hot-Boot</a></li>
<li><a href="../de457398/index.html">Aber mache ich Bullshit? Warum gehen Entwickler zu gemba?</a></li>
<li><a href="../de457400/index.html">Die Zahl der Opfer von Atomkatastrophen wie Tschernobyl ist f√ºr das Drama stark √ºbertrieben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>