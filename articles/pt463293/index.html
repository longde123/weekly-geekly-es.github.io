<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçµ ü§∏üèæ üë¨ Coletor de Lixo. Curso completo + transfer√™ncia do BOTR üÜò ü¶è üóûÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, voc√™ encontrar√° duas fontes de informa√ß√µes ao mesmo tempo: 


1. Conclua o curso Garbage Collector em russo: CLRium # 6 ( workshop atual...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Coletor de Lixo. Curso completo + transfer√™ncia do BOTR</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/463293/"><p>  Neste artigo, voc√™ encontrar√° duas fontes de informa√ß√µes ao mesmo tempo: </p><br><ol><li>  Conclua o curso Garbage Collector em russo: CLRium # 6 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">workshop atual aqui</a> ) </li><li>  Tradu√ß√£o de um artigo do BOTR "Garbage Collector Device" de Maoni Stevens. </li></ol><br><p><img src="https://habrastorage.org/webt/q2/r5/db/q2r5dbgih_azfbdvqe1dxcxsgp8.jpeg"></p><a name="habracut"></a><br><h2 id="1-clrium-5-polnyy-kurs-po-garbage-collector">  1. CLRium # 5: Curso Completo de Coletor de Lixo </h2><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/gx/ef/-t/gxef-ta_pk2ywxouxlgj8zjhhra.png"></a> </p><br><h2 id="2-ustroystvo-sborschika-musora-by-maoni-stephens-maoni0httpsgithubcommaoni0">  2. Dispositivo coletor de lixo por Maoni Stephens ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ maoni0</a> ) </h2><br><p>  Nota: para saber mais sobre a coleta de lixo em geral, consulte <em>O Manual de Coleta de Lixo</em> ;  informa√ß√µes especializadas sobre o coletor de lixo no CLR s√£o fornecidas no livro <em>Pro .NET Memory Management</em> .  Links para os dois recursos s√£o fornecidos no final do documento. </p><br><h3 id="arhitektura-komponentov">  Arquitetura de componentes </h3><br><p>  A coleta de lixo est√° associada a dois componentes: um distribuidor e um coletor.  O alocador √© respons√°vel por alocar mem√≥ria e chamar o coletor, se necess√°rio.  O coletor coleta lixo ou mem√≥ria de objetos que n√£o s√£o mais usados ‚Äã‚Äãpelo programa. </p><br><p>  Existem outras maneiras de chamar o coletor, por exemplo manualmente, usando GC.Collect.  Al√©m disso, o encadeamento do finalizador pode receber uma notifica√ß√£o ass√≠ncrona de que a mem√≥ria est√° acabando (o que causar√° o coletor). </p><br><h3 id="ustroystvo-raspredelitelya">  Dispositivo distribuidor </h3><br><p>  O distribuidor √© chamado pelos componentes auxiliares do tempo de execu√ß√£o com as seguintes informa√ß√µes: </p><br><ul><li>  o tamanho necess√°rio do gr√°fico alocado; </li><li>  contexto de aloca√ß√£o de mem√≥ria para o encadeamento de execu√ß√£o; </li><li>  sinalizadores que indicam, por exemplo, se o objeto √© finaliz√°vel. </li></ul><br><p>  O coletor de lixo n√£o fornece m√©todos de processamento especiais para diferentes tipos de objetos.  Ele recebe informa√ß√µes sobre o tamanho do objeto do tempo de execu√ß√£o. </p><br><p>  Dependendo do tamanho, o coletor divide os objetos em duas categorias: pequeno (&lt;85.000 bytes) e grande (&gt; = 85.000 bytes).  Em geral, a montagem de objetos pequenos e grandes pode ocorrer da mesma maneira.  No entanto, o coletor os separa por tamanho, pois a compacta√ß√£o de objetos grandes requer muitos recursos. </p><br><p>  O coletor de lixo aloca mem√≥ria para o alocador com base em contextos de aloca√ß√£o.  O tamanho do contexto de aloca√ß√£o √© determinado pelos blocos de mem√≥ria alocada. </p><br><ul><li><p>  <strong>Os contextos de sele√ß√£o</strong> s√£o pequenas √°reas de um segmento de heap espec√≠fico, cada qual destinado a um fluxo de execu√ß√£o espec√≠fico.  Em uma m√°quina com um processador (significando 1 processador l√≥gico), um √∫nico contexto de aloca√ß√£o de mem√≥ria √© usado para objetos da gera√ß√£o 0. </p><br></li><li><p>  <strong>Bloco de mem√≥ria alocada</strong> - a quantidade de mem√≥ria alocada pelo alocador sempre que precisar de mais mem√≥ria para posicionar um objeto dentro da √°rea.  O tamanho do bloco geralmente √© de 8 KB e o tamanho m√©dio dos objetos gerenciados √© de 35 bytes.  Portanto, em um bloco voc√™ pode colocar muitos objetos. </p><br></li></ul><br><p>  Objetos grandes n√£o usam contextos e blocos.  Um objeto grande pode ser maior que esses pequenos peda√ßos de mem√≥ria.  Al√©m disso, os benef√≠cios do uso dessas √°reas (descritas abaixo) s√£o evidentes apenas ao trabalhar com objetos pequenos.  O espa√ßo para objetos grandes √© alocado diretamente no segmento de heap. </p><br><p>  O distribuidor √© projetado para que: </p><br><ul><li><p> <strong>chame o coletor de lixo quando necess√°rio: o</strong> alocador chama o coletor quando a quantidade de mem√≥ria alocada para objetos exceder o valor limite (definido pelo coletor) ou se o alocador n√£o puder mais alocar mem√≥ria nesse segmento.  Limiares e segmentos controlados ser√£o descritos em detalhes posteriormente. </p><br></li><li><p>  <strong>salvar localiza√ß√£o dos objetos: os</strong> objetos localizados juntos em um segmento da pilha s√£o armazenados em endere√ßos virtuais pr√≥ximos uns dos outros. </p><br></li><li><p>  <strong>use o cache com efici√™ncia: o</strong> alocador aloca mem√≥ria em <em>blocos</em> , e n√£o para cada objeto.  Zera a quantidade de mem√≥ria necess√°ria para preparar o cache do processador, pois alguns objetos ser√£o colocados diretamente nele.  O bloco de mem√≥ria alocada √© geralmente 8 KB. </p><br></li><li><p>  <strong>efetivamente limitar a √°rea alocada ao encadeamento de execu√ß√£o: a</strong> proximidade dos contextos e blocos de mem√≥ria alocados para o encadeamento garante que apenas um encadeamento grave dados no espa√ßo alocado.  Como resultado, n√£o h√° necessidade de limitar a aloca√ß√£o de mem√≥ria at√© que o espa√ßo no contexto de aloca√ß√£o atual termine. </p><br></li><li><p>  <strong>garantir a integridade da mem√≥ria:</strong> o coletor de lixo sempre zera a mem√≥ria dos objetos rec√©m-alocados para que seus links n√£o aponteem para se√ß√µes arbitr√°rias da mem√≥ria. </p><br></li><li><p>  <strong>garantir a continuidade da pilha: o</strong> alocador cria um objeto livre da mem√≥ria restante em cada bloco alocado.  Por exemplo, se 30 bytes forem deixados no bloco e 40 bytes forem necess√°rios para acomodar o pr√≥ximo objeto, o alocador transformar√° esses 30 bytes em um objeto livre e solicitar√° um novo bloco de mem√≥ria. </p><br></li></ul><br><h2>  API </h2><br><pre><code class="plaintext hljs">Object* GCHeap::Alloc(size_t size,  DWORD); Object* GCHeap::Alloc(alloc_context* acontext, size_t size,  DWORD);</code> </pre> <br><p>  Usando essas fun√ß√µes, voc√™ pode alocar mem√≥ria para objetos pequenos e grandes.  H√° uma fun√ß√£o para alocar espa√ßo diretamente na pilha de objetos grandes (LOH): </p><br><pre> <code class="plaintext hljs"> Object* GCHeap::AllocLHeap(size_t size,  DWORD);</code> </pre> <br><h3 id="ustroystvo-sborschika">  Dispositivo coletor </h3><br><h4 id="zadachi-sborschika-musora">  Tarefas do coletor de lixo </h4><br><p>  O GC foi projetado para gerenciamento eficiente de mem√≥ria.  Os desenvolvedores que escrevem c√≥digo gerenciado podem us√°-lo sem muito esfor√ßo.  Boa governan√ßa significa: </p><br><ul><li>  a coleta de lixo deve ocorrer com frequ√™ncia suficiente para n√£o sobrecarregar a pilha gerenciada com um grande n√∫mero (por propor√ß√£o ou em quantidade absoluta) de objetos n√£o utilizados (lixo) para os quais a mem√≥ria √© alocada; </li><li>  a coleta de lixo deve ocorrer o mais raramente poss√≠vel, para n√£o desperdi√ßar o tempo √∫til do processador, embora uma coleta mais frequente permita menos uso de mem√≥ria; </li><li>  a coleta de lixo deve ser produtiva, porque, como resultado da montagem, apenas uma pequena parte da mem√≥ria foi liberada, a montagem e o tempo gasto do processador foram em v√£o; </li><li>  a coleta de lixo deve ser r√°pida, pois muitas cargas de trabalho exigem um pequeno tempo de atraso; </li><li>  os desenvolvedores que escrevem c√≥digo gerenciado n√£o precisam saber muito sobre a coleta de lixo para obter um uso eficiente da mem√≥ria (em compara√ß√£o com a carga de trabalho); </li><li>  O coletor de lixo deve se adaptar √† natureza diferente do uso da mem√≥ria. </li></ul><br><h4 id="logicheskoe-opisanie-upravlyaemoy-kuchi">  Descri√ß√£o l√≥gica do heap gerenciado </h4><br><p>  O coletor de lixo CLR coleta objetos que s√£o logicamente separados por gera√ß√£o.  Ap√≥s a montagem dos objetos na gera√ß√£o <em>N</em> , os objetos restantes s√£o marcados como pertencentes √† gera√ß√£o <em>N + 1</em> .  Esse processo √© chamado de promo√ß√£o de objetos entre gera√ß√µes.  H√° exce√ß√µes nesse processo quando √© necess√°rio transferir um objeto para uma gera√ß√£o mais baixa ou n√£o avan√ßar de maneira alguma. </p><br><p>  No caso de objetos pequenos, o heap √© dividido em tr√™s gera√ß√µes: gen0, gen1 e gen2.  Para objetos grandes, h√° apenas uma gera√ß√£o - gen3.  Gen0 e gen1 s√£o chamados de gera√ß√µes ef√™meras (objetos vivem neles por um curto per√≠odo de tempo). </p><br><p>  Para v√°rios objetos pequenos, o n√∫mero da gera√ß√£o significa a idade deles.  Por exemplo, gen0 √© a gera√ß√£o mais jovem.  Isso n√£o significa que todos os objetos em gen0 s√£o mais novos que objetos em gen1 ou gen2.  H√° exce√ß√µes descritas abaixo.  Montar uma gera√ß√£o significa montar objetos nesta gera√ß√£o, bem como em todas as gera√ß√µes mais jovens. </p><br><p>  Teoricamente, a montagem de objetos grandes e pequenos pode ocorrer da mesma maneira.  No entanto, como a compacta√ß√£o de objetos grandes requer muitos recursos, sua montagem ocorre de maneira diferente.  Objetos grandes est√£o contidos apenas no gen2 e s√£o coletados apenas durante a coleta de lixo nesta gera√ß√£o por motivos de desempenho.  Tanto o gen2 quanto o gen3 podem ser grandes, e a constru√ß√£o de um objeto em gera√ß√µes ef√™meras (gen0 e gen1) n√£o deve consumir muito recursos. </p><br><p>  Os objetos s√£o colocados na gera√ß√£o mais jovem.  Para objetos pequenos, esse √© gen0, e para objetos grandes, gen3. </p><br><h4 id="fizicheskoe-opisanie-upravlyaemoy-kuchi">  Descri√ß√£o f√≠sica do heap gerenciado </h4><br><p>  Um heap gerenciado consiste em um conjunto de segmentos.  Um segmento √© um bloco cont√≠nuo de mem√≥ria que o sistema operacional passa para o coletor de lixo.  Os segmentos de heap s√£o divididos em se√ß√µes pequenas e grandes para acomodar objetos pequenos e grandes.  Os segmentos de cada heap s√£o conectados juntos.  Pelo menos um segmento para um objeto pequeno e um para um grande s√£o reservados ao carregar o CLR. </p><br><p>  Em cada pilha de objetos pequenos, h√° apenas um segmento ef√™mero, onde as gera√ß√µes gen0 e gen1 est√£o localizadas.  Esse segmento pode ou n√£o conter objetos de gera√ß√£o gen2.  Al√©m dos segmentos ef√™meros, pode existir um ou mais segmentos adicionais, que ser√£o segmentos gen2, pois cont√™m objetos da gera√ß√£o 2. </p><br><p>  Uma pilha de objetos grandes consiste em um ou mais segmentos. </p><br><p>  O segmento de heap √© preenchido de endere√ßos inferiores para superiores.  Isso significa que os objetos localizados nos endere√ßos inferiores do segmento s√£o mais antigos do que aqueles localizados nos idosos.  Tamb√©m h√° exce√ß√µes descritas abaixo. </p><br><p>  Os segmentos de heap s√£o alocados conforme necess√°rio.  Se eles n√£o contiverem objetos usados, os segmentos ser√£o exclu√≠dos.  No entanto, o segmento inicial na pilha sempre existe.  Um segmento √© alocado por vez para cada heap.  No caso de objetos pequenos, isso acontece durante a coleta de lixo e, para objetos grandes, durante a aloca√ß√£o de mem√≥ria para eles.  Esse esquema aumenta a produtividade, pois objetos grandes s√£o montados apenas na gera√ß√£o 2 (o que requer muitos recursos). </p><br><p>  Os segmentos de heap s√£o unidos em sele√ß√µes.  O √∫ltimo segmento da cadeia √© sempre ef√™mero.  Os segmentos em que todos os objetos s√£o coletados podem ser reutilizados, por exemplo, como ef√™meros.  A reutiliza√ß√£o de segmento se aplica apenas a montes de objetos pequenos.  Para acomodar objetos grandes toda vez que todo o conjunto de objetos grandes √© considerado.  Objetos pequenos s√£o colocados apenas em segmentos ef√™meros. </p><br><h4 id="porogovoe-znachenie-obyoma-vydelennoy-pamyati">  Valor limite da mem√≥ria alocada </h4><br><p>  Este √© um conceito l√≥gico relacionado ao tamanho de cada gera√ß√£o.  Se for excedido, a gera√ß√£o inicia a coleta de lixo. </p><br><p>  O valor limite para uma gera√ß√£o espec√≠fica √© definido dependendo do n√∫mero de objetos sobreviventes nessa gera√ß√£o.  Se esse valor for alto, o valor do limite se tornar√° mais alto.  Espera-se que a propor√ß√£o de objetos usados ‚Äã‚Äãe n√£o utilizados seja melhor durante a pr√≥xima gera√ß√£o de sess√£o de coleta de lixo. </p><br><h2>  Sele√ß√£o de gera√ß√£o para coleta de lixo </h2><br><p>  Quando ativado, o coletor deve determinar em qual gera√ß√£o construir.  Al√©m do valor limite, outros fatores influenciam essa escolha: </p><br><ul><li>  fragmenta√ß√£o de uma gera√ß√£o - se uma gera√ß√£o √© altamente fragmentada, √© prov√°vel que a coleta de lixo seja produtiva; </li><li>  se a mem√≥ria da m√°quina estiver muito ocupada, o coletor poder√° realizar uma limpeza mais profunda, se essa limpeza tiver mais chances de liberar espa√ßo e evitar a troca desnecess√°ria de p√°ginas (mem√≥ria em toda a m√°quina); </li><li>  se um segmento ef√™mero ficar sem espa√ßo, o coletor poder√° realizar uma limpeza mais profunda nesse segmento (coletar mais objetos da gera√ß√£o 1) para evitar a aloca√ß√£o de um novo segmento de heap. </li></ul><br><h3 id="process-sborki-musora">  Processo de coleta de lixo </h3><br><h4 id="etap-markirovki">  Fase de marca√ß√£o </h4><br><p>  Durante esta fase, o CLR deve encontrar todos os objetos vivos. </p><br><p>  A vantagem de um colecionador com o apoio de gera√ß√µes √© sua capacidade de limpar o lixo apenas em parte da pilha, em vez de observar constantemente todos os objetos.  Coletando lixo em gera√ß√µes ef√™meras, o coletor deve receber informa√ß√µes do ambiente de tempo de execu√ß√£o sobre quais objetos nessas gera√ß√µes ainda s√£o usados ‚Äã‚Äãpelo programa.  Al√©m disso, objetos nas gera√ß√µes mais antigas podem usar objetos nas gera√ß√µes mais jovens, referindo-se a eles. </p><br><p>  Para marcar objetos antigos que referenciam novos, o coletor de lixo usa bits especiais.  Os bits s√£o definidos pelo mecanismo do compilador JIT durante as opera√ß√µes de atribui√ß√£o.  Se o objeto pertencer √† gera√ß√£o ef√™mera, o compilador JIT definir√° o byte que cont√©m o bit indicando a posi√ß√£o inicial.  Coletando lixo em gera√ß√µes ef√™meras, o coletor pode usar esses bits para toda a pilha restante e exibir apenas os objetos aos quais esses bits correspondem. </p><br><h4 id="etap-planirovaniya">  Est√°gio de planejamento </h4><br><p>  Nesse ponto, a compacta√ß√£o √© modelada para determinar sua efic√°cia.  Se o resultado for produtivo, o coletor inicia a compacta√ß√£o real.  Caso contr√°rio, ele apenas faz a limpeza. </p><br><h4 id="etap-peremescheniya">  Est√°gio em movimento </h4><br><p>  Se o coletor executar compacta√ß√£o, isso far√° com que os objetos se movam.  Nesse caso, voc√™ deve atualizar os links para esses objetos.  Durante a fase de movimenta√ß√£o, o coletor deve encontrar todos os links que apontam para objetos nas gera√ß√µes em que a coleta de lixo ocorre.  Por outro lado, durante o est√°gio de marca√ß√£o, o coletor marca apenas objetos ativos, portanto, n√£o √© necess√°rio considerar links fracos. </p><br><h4 id="etap-szhatiya">  Est√°gio de compress√£o </h4><br><p>  Esse est√°gio √© bastante simples, pois o coletor j√° determinou novos endere√ßos para mover objetos durante o est√°gio de planejamento.  Quando compactados, os objetos ser√£o copiados para esses endere√ßos. </p><br><h4 id="etap-uborki">  Est√°gio de limpeza </h4><br><p>  Durante esta fase, o coletor procura espa√ßo n√£o utilizado entre objetos vivos.  Em vez deste espa√ßo, ele cria objetos livres.  Objetos n√£o utilizados nas proximidades se tornam um objeto livre.  Todos os objetos livres s√£o colocados na <em>lista de objetos livres</em> . </p><br><h3 id="code-flow">  Fluxo de c√≥digo </h3><br><p>  Termos: </p><br><ul><li>  <strong>WKS GC:</strong> Coleta de Lixo no Modo Esta√ß√£o de Trabalho </li><li>  <strong>SVR GC:</strong> Coleta de Lixo no Modo Servidor </li></ul><br><h4 id="funkcionalnoe-povedenie">  Comportamento funcional </h4><br><h5 id="wks-gc-bez-parallelnoy-sborki-musora">  GC WKS sem coleta de lixo paralela </h5><br><ol><li>  O encadeamento do usu√°rio usou toda a mem√≥ria alocada para ele e chama o coletor de lixo. </li><li>  O coletor chama o <code>SuspendEE</code> para suspender todos os encadeamentos gerenciados. </li><li>  O coletor escolhe uma gera√ß√£o para limpeza. </li><li>  A marca√ß√£o dos objetos come√ßa. </li><li>  O coletor vai para a fase de planejamento e determina a necessidade de compacta√ß√£o. </li><li>  Se necess√°rio, o coletor move objetos e realiza a compacta√ß√£o.  Em outro caso, apenas faz a limpeza. </li><li>  O coletor chama <code>RestartEE</code> para reiniciar os encadeamentos gerenciados. </li><li>  Os threads do usu√°rio continuam funcionando. </li></ol><br><h5 id="wks-gc-s-parallelnoy-sborkoy-musora">  GC WKS com coleta de lixo paralela </h5><br><p>  Esse algoritmo descreve a coleta de lixo em segundo plano. </p><br><ol><li>  O encadeamento do usu√°rio usou toda a mem√≥ria alocada para ele e chama o coletor de lixo. </li><li>  O coletor chama o <code>SuspendEE</code> para suspender todos os encadeamentos gerenciados. </li><li>  O coletor determina se deve executar a coleta de lixo em segundo plano. </li><li>  Nesse caso, o encadeamento de coleta de lixo em segundo plano √© ativado.  Esse encadeamento chama <code>RestartEE</code> para retomar os encadeamentos gerenciados. </li><li>  A aloca√ß√£o de mem√≥ria para processos gerenciados continua ao mesmo tempo que a coleta de lixo em segundo plano. </li><li>  Um encadeamento do usu√°rio pode usar toda a mem√≥ria alocada para ele e iniciar a coleta de lixo ef√™mera (tamb√©m conhecida como coleta de lixo de alta prioridade).  √â executado da mesma maneira que no modo de esta√ß√£o de trabalho sem coleta de lixo paralela. </li><li>  O <code>SuspendEE</code> coleta de lixo em segundo plano chama o <code>SuspendEE</code> novamente para concluir a marca√ß√£o e, em seguida, chama <code>RestartEE</code> para iniciar uma limpeza paralela com os threads do usu√°rio em execu√ß√£o. </li><li>  A coleta de lixo em segundo plano est√° conclu√≠da. </li></ol><br><h5 id="svr-gc-bez-parallelnoy-sborki-musora">  GC SVR sem coleta de lixo paralela </h5><br><ol><li>  O encadeamento do usu√°rio usou toda a mem√≥ria alocada para ele e chama o coletor de lixo. </li><li>  Os encadeamentos de coleta de lixo no modo de servidor s√£o ativados e fazem com que o <code>SuspendEE</code> pause a execu√ß√£o dos encadeamentos gerenciados. </li><li>  Os fluxos de coleta de lixo no modo servidor executam as mesmas opera√ß√µes que no modo esta√ß√£o de trabalho sem coleta de lixo paralela. </li><li>  Os threads de coleta de lixo no modo de servidor chamam <code>RestartEE</code> para iniciar os threads gerenciados. </li><li>  Os threads do usu√°rio continuam funcionando. </li></ol><br><h5 id="svr-gc-s-parallelnoy-sborkoy-musora">  GC SVR com coleta de lixo paralela </h5><br><p>  O algoritmo √© o mesmo que no caso da coleta de lixo paralela no modo de esta√ß√£o de trabalho, somente a coleta n√£o-f√¥non √© realizada nos encadeamentos do servidor. </p><br><h2 id="fizicheskaya-arhitektura">  Arquitetura f√≠sica </h2><br><p>  Esta se√ß√£o o ajudar√° a entender o fluxo de c√≥digo. </p><br><p>  Quando o encadeamento do usu√°rio fica sem mem√≥ria, ele pode obter espa√ßo livre usando a fun√ß√£o <code>try_allocate_more_space</code> . </p><br><p>  A fun√ß√£o <code>try_allocate_more_space</code> chama <code>GarbageCollectGeneration</code> quando voc√™ precisa iniciar o coletor de lixo. </p><br><p>  Se a coleta de lixo no modo de esta√ß√£o de trabalho n√£o for paralela, o <code>GarbageCollectGeneration</code> ser√° executado no encadeamento do usu√°rio que o coletor de lixo chamou.  O fluxo de c√≥digo √© o seguinte: </p><br><pre> <code class="plaintext hljs"> GarbageCollectGeneration() { SuspendEE(); garbage_collect(); RestartEE(); } garbage_collect() { generation_to_condemn(); gc1(); } gc1() { mark_phase(); plan_phase(); } plan_phase() { //   ,   //    if (compact) { relocate_phase(); compact_phase(); } else make_free_lists(); }</code> </pre> <br><p>  Se a coleta de lixo paralela for realizada no modo de esta√ß√£o de trabalho (por padr√£o), o fluxo de c√≥digo da coleta de lixo em segundo plano ser√° semelhante a: </p><br><pre> <code class="plaintext hljs"> GarbageCollectGeneration() { SuspendEE(); garbage_collect(); RestartEE(); } garbage_collect() { generation_to_condemn(); //     //      do_background_gc(); } do_background_gc() { init_background_gc(); start_c_gc (); //           . wait_to_proceed(); } bgc_thread_function() { while (1) { //    //  gc1(); } } gc1() { background_mark_phase(); background_sweep(); }</code> </pre> <br><h1>  Links de Recursos </h1><br><ul><li>  <a href="">Implementa√ß√£o do .NET CLR GC</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Manual da Coleta de Lixo: A Arte do Gerenciamento Autom√°tico de Mem√≥ria</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Coleta de lixo (Wikipedia)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gerenciamento de mem√≥ria Pro .NET</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt463293/">https://habr.com/ru/post/pt463293/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt463279/index.html">PHP Digest No. 162 (1 a 12 de agosto de 2019)</a></li>
<li><a href="../pt463281/index.html">Por que existem poucas aplica√ß√µes inovadoras no Google Play ou por que √†s vezes a programa√ß√£o √© m√°gica</a></li>
<li><a href="../pt463285/index.html">ShIoTiny: n√≥s, links e eventos ou recursos de programas de desenho</a></li>
<li><a href="../pt463289/index.html">Matem√°tica discreta para WMS: lotes de armazenamento em cluster</a></li>
<li><a href="../pt463291/index.html">Dados ou Ossos</a></li>
<li><a href="../pt463295/index.html">C ++ e CMake - Brothers Forever, Parte II</a></li>
<li><a href="../pt463297/index.html">Lealdade ao seu gosto</a></li>
<li><a href="../pt463299/index.html">Dicas e truques do Kubernetes: como aumentar a produtividade</a></li>
<li><a href="../pt463301/index.html">Gonkey - Ferramenta de Teste de Microsservi√ßos</a></li>
<li><a href="../pt463303/index.html">Finalmente, o Facebook para de segmentar an√∫ncios para n√∫meros de telefone que as pessoas inserem para o 2FA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>