<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö≤ ‚è∏Ô∏è üìò Sepeda sendiri untuk menyinkronkan MariaDB dan Sphinx üñãÔ∏è üëí ü§∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada 28 Februari, saya membuat presentasi di SphinxSearch-meetup , yang diadakan di kantor kami. Dia berbicara tentang bagaimana kita berasal dari pem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sepeda sendiri untuk menyinkronkan MariaDB dan Sphinx</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/superjob/blog/447526/"><p><img src="https://habrastorage.org/webt/t0/1g/vk/t01gvkcn0zx47xuioqcvfz5bqoc.png"></p><br><p>  Pada 28 Februari, saya membuat presentasi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SphinxSearch-meetup</a> , yang diadakan di kantor kami.  Dia berbicara tentang bagaimana kita berasal dari pembangunan kembali indeks secara teratur untuk pencarian teks lengkap dan mengirimkan pembaruan dalam kode "di tempat" ke indeks waktu rel dan sinkronisasi otomatis keadaan indeks dan basis data MariaDB.  Rekaman video dari laporan saya tersedia melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> , dan bagi mereka yang lebih suka membaca daripada menonton video, saya menulis artikel ini. </p><a name="habracut"></a><br><p>  Saya akan mulai dengan bagaimana pencarian kami diatur, dan mengapa kami memulai semua ini. </p><br><p>  Pencarian kami diatur menurut skema yang sepenuhnya standar. </p><br><p>  Dari ujung depan, permintaan pengguna datang ke server aplikasi yang ditulis dalam PHP, dan dia, pada gilirannya, berkomunikasi dengan database (kami memiliki MariaDB).  Jika kita perlu melakukan pencarian, server aplikasi beralih ke balancer (kami memiliki haproxy), yang menghubungkannya ke salah satu server di mana searchd sedang berjalan, dan server itu sudah melakukan pencarian dan mengembalikan hasilnya. </p><br><p>  Data dari database masuk ke dalam indeks dengan cara yang cukup tradisional: sesuai dengan jadwal, kami membangun kembali indeks setiap beberapa menit dengan dokumen-dokumen yang diperbarui relatif baru-baru ini, dan membangun kembali indeks dengan apa yang disebut dokumen "diarsipkan" (yaitu dokumen yang diarsipkan). Untuk waktu yang lama tidak ada yang terjadi).  Ada beberapa mesin yang dialokasikan untuk pengindeksan, skrip dijalankan di sana pada jadwal, yang pertama membangun indeks, kemudian mengganti nama file indeks dengan cara khusus, dan kemudian meletakkannya di folder yang terpisah.  Dan pada masing-masing server dengan searchd, rsync dimulai sekali dalam satu menit, yang dari folder ini menyalin file ke folder indeks searchd, dan kemudian, jika sesuatu telah disalin, ia menjalankan permintaan RELOAD INDEX. </p><br><p>  Namun, untuk beberapa perubahan dalam resume dan lowongan, mereka diharuskan untuk ‚Äúmencapai‚Äù indeks sesegera mungkin.  Misalnya, jika lowongan yang diposting di domain publik dihapus dari publikasi, maka masuk akal untuk mengharapkan dari sudut pandang pengguna bahwa itu akan hilang dari masalah dalam beberapa detik, tidak lebih.  Karenanya, perubahan semacam ini dikirim langsung melalui searchd menggunakan kueri UPDATE.  Dan agar perubahan ini diterapkan ke semua salinan indeks di semua server kami, indeks terdistribusi disiapkan di setiap searchd, yang mengirimkan pembaruan atribut ke semua instance searchd.  Server aplikasi masih terhubung ke penyeimbang dan mengirimkan satu permintaan untuk memperbarui indeks yang didistribusikan;  dengan demikian, dia tidak perlu tahu sebelumnya baik daftar server dengan searchd, juga tidak akan sampai ke server dengan searchd secara tepat. </p><br><p>  Semua ini bekerja dengan cukup baik, tetapi ada masalah. </p><br><ol><li>  Penundaan rata-rata antara pembuatan dokumen (kami memiliki resume atau lowongan ini) dan entri ke dalam indeks berbanding lurus dengan jumlah mereka dalam database kami. </li><li> Karena kami menggunakan indeks terdistribusi untuk mendistribusikan pembaruan atribut, kami tidak memiliki jaminan bahwa pembaruan ini diterapkan ke semua salinan indeks. </li><li> Perubahan "mendesak" yang terjadi selama pembangunan kembali indeks hilang ketika perintah <code>RELOAD INDEX</code> dijalankan (hanya karena mereka belum dalam indeks yang baru dibangun), dan hanya masuk ke indeks setelah pengindeksan ulang berikutnya. <img src="https://habrastorage.org/webt/rz/t6/v3/rzt6v3lfrnyayc3-texs56vlh48.png"></li><li>  Skrip untuk memperbarui indeks pada server dengan searchd dieksekusi secara independen satu sama lain, tidak ada sinkronisasi di antara mereka.  Karena itu, penundaan antara memperbarui indeks pada server yang berbeda dapat mencapai beberapa menit. </li><li>  Jika perlu untuk menguji sesuatu yang berkaitan dengan pencarian, itu diperlukan untuk membangun kembali indeks setelah setiap perubahan. </li></ol><br><p>  Masing-masing masalah ini secara terpisah tidak layak dikerjakan ulang infrastruktur pencarian, tetapi secara bersama-sama mereka benar-benar merusak kehidupan. </p><br><p>  Kami memutuskan untuk menangani masalah di atas menggunakan indeks realtime Sphinx.  Selain itu, transisi ke indeks RT tidak cukup bagi kami.  Untuk akhirnya menyingkirkan semua perlombaan data, perlu untuk memastikan bahwa semua pembaruan dari aplikasi ke indeks melewati saluran yang sama.  Selain itu, perlu untuk menyimpan di suatu tempat perubahan yang dibuat ke database saat indeks sedang dibangun kembali (karena bagaimanapun, kadang-kadang perlu untuk membangunnya kembali, tetapi prosedurnya tidak instan). </p><br><p>  Kami memutuskan untuk membuat koneksi menggunakan protokol replikasi MySQL seperti saluran transfer data, dan binlog MySQL adalah tempat untuk menyimpan perubahan saat membangun kembali indeks.  Solusi ini memungkinkan kami untuk menghapus penulisan ke Sphinx dari kode aplikasi.  Dan karena kami sudah menggunakan replikasi berbasis baris dengan id transaksi global saat itu, beralih antar replika basis data bisa dilakukan dengan cukup sederhana. </p><br><p>  Gagasan menghubungkan langsung ke database untuk mendapatkan perubahan dari sana untuk mengirim ke indeks, tentu saja, bukan hal baru: pada 2016, rekan-rekan dari Avito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membuat presentasi di</a> mana mereka menggambarkan secara rinci bagaimana mereka memecahkan masalah sinkronisasi data di Sphinx dengan database utama.  Kami memutuskan untuk menggunakan pengalaman mereka dan membuat sistem yang sama untuk diri kami sendiri, dengan perbedaan bahwa kami belum memiliki PostgreSQL, tetapi MariaDB, dan cabang Sphinx lama (yaitu, versi 2.3.2). </p><br><p>  Kami membuat layanan yang berlangganan perubahan di MariaDB dan memperbarui indeks di Sphinx.  Tanggung jawabnya adalah sebagai berikut: </p><br><ul><li>  koneksi ke server MariaDB melalui protokol replikasi dan menerima acara dari binlog; </li><li>  melacak posisi binlog saat ini dan jumlah transaksi terakhir yang diselesaikan; </li><li>  memfilter acara binlog; </li><li>  mencari tahu dokumen mana yang perlu ditambahkan, dihapus atau diperbarui dalam indeks, dan untuk dokumen yang diperbarui - bidang mana yang perlu diperbarui; </li><li>  meminta data yang hilang dari MariaDB; </li><li>  pembuatan dan pelaksanaan permintaan pembaruan indeks; </li><li>  membangun kembali indeks jika perlu. </li></ul><br><p>  Kami membuat koneksi menggunakan protokol replikasi menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">go-mysql</a> .  Dia bertanggung jawab untuk membangun koneksi dengan MariaDB, membaca acara replikasi, dan meneruskannya ke seorang pawang.  Pawang ini dimulai dengan goroutine, yang dikendalikan oleh perpustakaan, tetapi kami menulis sendiri kode pawang.  Dalam kode penangan, acara diverifikasi dengan daftar tabel yang menarik bagi kami, dan perubahan pada tabel ini dikirim untuk diproses.  Pawang kami juga menyimpan status transaksi.  Ini karena peristiwa dalam protokol replikasi berurutan: GTID (mulai transaksi) -&gt; ROW (perubahan data) -&gt; XID (akhir transaksi), dan hanya yang pertama yang berisi informasi tentang nomor transaksi.  Lebih mudah bagi kami untuk mentransfer nomor transaksi bersama dengan penyelesaiannya untuk menyimpan informasi tentang ke posisi mana dalam binlog perubahan telah diterapkan, dan untuk ini kita perlu mengingat jumlah transaksi saat ini antara awal dan selesai. </p><br><pre> <code class="plaintext hljs">MySQL [(none)]&gt; describe sync_state; +-----------------+--------+ | Field | Type | +-----------------+--------+ | id | bigint | | dummy_field | field | | binlog_position | uint | | binlog_name | string | | gtid | string | | flavor | string | +-----------------+--------+</code> </pre> <br><p>  Kami menyimpan jumlah transaksi terakhir yang diselesaikan dalam indeks khusus dari satu dokumen pada setiap server dengan searchd.  Pada awal layanan, kami memverifikasi bahwa indeks diinisialisasi dan memiliki struktur yang diharapkan, serta posisi yang disimpan di semua server ada dan sama di semua server.  Kemudian, jika pemeriksaan ini berhasil dan kami dapat mulai membaca binlog dari posisi yang disimpan, kami memulai prosedur sinkronisasi.  Jika pemeriksaan gagal, atau tidak mungkin untuk mulai membaca binlog dari posisi yang disimpan, maka kami mengatur ulang posisi yang disimpan ke posisi saat ini dari server MariaDB dan membangun kembali indeks. </p><br><p>  Memproses peristiwa replikasi dimulai dengan menentukan dokumen mana yang dipengaruhi oleh perubahan tertentu dalam database.  Untuk melakukan ini, dalam konfigurasi layanan kami, kami melakukan sesuatu seperti perutean untuk acara perubahan baris dalam tabel yang menarik bagi kami, yaitu seperangkat aturan untuk menentukan bagaimana perubahan dalam database harus diindeks. </p><br><pre> <code class="plaintext hljs">[[ingest]] table = "vacancy" id_field = "id" index = "vacancy" [ingest.column_map] user_id = ["user_id"] edited_at = ["date_edited"] profession = ["profession"] latitude = ["latitude_deg", "latitude_rad"] longitude = ["longitude_deg", "longitude_rad"] [[ingest]] table = "vacancy_language" id_field = "vacancy_id" index = "vacancy" [ingest.column_map] language_id = ["languages"] level = ["languages"] [[ingest]] table = "vacancy_metro_station" id_field = "vacancy_id" index = "vacancy" [ingest.column_map] metro_station_id = ["metro"]</code> </pre> <br><p>  Misalnya, dengan seperangkat aturan ini, perubahan pada <code>vacancy_metro_station</code> <code>vacancy</code> , <code>vacancy</code> <code>vacancy_language</code> dan <code>vacancy_metro_station</code> harus ada dalam indeks <code>vacancy</code> .  Nomor dokumen dapat diambil di bidang <code>id</code> untuk tabel <code>vacancy</code> , dan di bidang <code>vacancy_id</code> untuk dua tabel lainnya.  Kolom <code>column_map</code> adalah tabel ketergantungan bidang indeks pada bidang tabel database yang berbeda. </p><br><p>  Lebih lanjut, ketika kami menerima daftar dokumen yang dipengaruhi oleh perubahan, kami perlu memperbaruinya dalam indeks, tetapi kami tidak segera melakukannya.  Pertama, kami mengakumulasikan perubahan untuk setiap dokumen, dan mengirimkan perubahan ke indeks segera setelah waktu singkat (kami memiliki 100 milidetik) dari perubahan terakhir dokumen ini. </p><br><p>  Kami memutuskan untuk melakukan ini untuk menghindari banyak pembaruan indeks yang tidak perlu, karena dalam banyak kasus satu perubahan logis ke dokumen terjadi dengan bantuan beberapa pertanyaan SQL yang mempengaruhi tabel yang berbeda, dan kadang-kadang dieksekusi dalam transaksi yang sama sekali berbeda. </p><br><p>  Saya akan memberikan contoh sederhana.  Misalkan seorang pengguna telah mengedit lowongan.  Kode yang bertanggung jawab untuk menyimpan perubahan sering ditulis untuk kesederhanaan kira-kira dengan cara ini: </p><br><pre> <code class="plaintext hljs">BEGIN; UPDATE vacancy SET edited_at = NOW() WHERE id = 123; DELETE FROM vacancy_language WHERE vacancy_id = 123; INSERT INTO vacancy_language (vacancy_id, language_id, level) VALUES (123, 1, "fluent"), (123, 2, "technical"); DELETE FROM vacancy_metro_station WHERE vacancy_id = 123; INSERT INTO vacancy_metro_station (vacancy_id, metro_station_id) VALUES (123, 55); ... COMMIT;</code> </pre> <br><p>  Dengan kata lain, pertama semua catatan lama dihapus dari tabel tertaut, dan kemudian yang baru dimasukkan.  Pada saat yang sama, masih akan ada entri dalam binlog tentang penghapusan dan penyisipan ini, bahkan jika tidak ada yang berubah dalam dokumen. </p><br><p>  Untuk memperbarui hanya apa yang diperlukan, kami melakukan hal berikut: mengurutkan baris yang diubah sehingga untuk setiap pasangan indeks-dokumen semua perubahan dapat diambil dalam urutan kronologis.  Kemudian kita akan dapat menerapkannya pada gilirannya untuk menentukan bidang mana di mana tabel akhirnya berubah dan mana yang tidak, dan kemudian menggunakan tabel <code>column_map</code> mendapatkan daftar bidang dan atribut indeks yang perlu diperbarui untuk setiap dokumen yang terpengaruh.  Selain itu, peristiwa yang terkait dengan satu dokumen mungkin tidak tiba satu per satu, tetapi seolah-olah "berbeda" jika mereka dieksekusi dalam transaksi yang berbeda.  Tetapi, pada kemampuan kita untuk menentukan dokumen apa yang telah berubah, ini tidak akan mempengaruhi. </p><br><p>  Pada saat yang sama, pendekatan ini memungkinkan kami untuk memperbarui hanya atribut indeks, jika tidak ada perubahan di bidang teks, serta menggabungkan pengiriman perubahan ke Sphinx. </p><br><p>  Jadi, sekarang kita bisa mengetahui dokumen mana yang perlu diperbarui dalam indeks. </p><br><p>  Dalam banyak kasus, data dari binlog tidak cukup untuk membangun permintaan untuk memperbarui indeks, jadi kami mendapatkan data yang hilang dari server yang sama dari tempat kami membaca binlog.  Untuk ini, ada templat permintaan untuk menerima data dalam konfigurasi layanan kami. </p><br><pre> <code class="plaintext hljs">[data_source.vacancy] #               #   -      id     parts = 4 query = """ SELECT vacancy.id AS `:id`, vacancy.profession AS `profession_text:field`, GROUP_CONCAT(DISTINCT vacancy_language.language_id) AS `languages:attr_multi`, GROUP_CONCAT(DISTINCT vacancy_metro_station.metro_station_id) AS `metro:attr_multi` FROM vacancy LEFT JOIN vacancy_language ON vacancy_language.vacancy_id = vacancy.id LEFT JOIN vacancy_metro_station ON vacancy_metro_station.vacancy_id = vacancy.id GROUP BY vacancy.id """</code> </pre> <br><p>  Dalam templat ini, semua bidang ditandai dengan alias khusus: <code>[___]:___</code> . <br>  Ini digunakan baik dalam pembentukan permintaan untuk menerima data yang hilang dan dalam pembangunan indeks (lebih lanjut tentang ini nanti). </p><br><p>  Kami membentuk permintaan jenis ini: </p><br><pre> <code class="plaintext hljs">SELECT vacancy.id AS `id`, vacancy.profession AS `profession_text`, GROUP_CONCAT(DISTINCT vacancy_language.language_id) AS `languages`, GROUP_CONCAT(DISTINCT vacancy_metro_station.metro_station_id) AS `metro` FROM vacancy LEFT JOIN vacancy_language ON vacancy_language.vacancy_id = vacancy.id LEFT JOIN vacancy_metro_station ON vacancy_metro_station.vacancy_id = vacancy.id WHERE vacancy.id IN (&lt; id ,   &gt;) GROUP BY vacancy.id</code> </pre> <br><p>  Kemudian untuk setiap dokumen kami memeriksa apakah itu sebagai hasil dari permintaan ini.  Jika tidak, itu berarti telah dihapus dari tabel utama, dan itu juga dapat dihapus dari indeks (kami menjalankan kueri <code>DELETE</code> untuk dokumen ini).  Jika ya, maka lihat apakah kami perlu memperbarui bidang teks untuk dokumen ini.  Jika bidang teks tidak perlu diperbarui, maka kami membuat kueri <code>UPDATE</code> untuk dokumen ini, jika tidak <code>REPLACE</code> . </p><br><p>  Perlu dicatat bahwa logika mempertahankan posisi dari mana Anda dapat mulai membaca binlog jika terjadi kegagalan harus rumit, karena sekarang situasi mungkin di mana kami tidak menerapkan semua perubahan yang dibaca dari binlog. </p><br><p>  Agar pembacaan kembali binlog berfungsi dengan benar, kami melakukan hal berikut: untuk setiap acara perubahan baris dalam database, ingat id dari transaksi yang diselesaikan terakhir pada saat peristiwa ini terjadi.  Setelah mengirim perubahan ke Sphinx, kami memperbarui nomor transaksi dari mana Anda dapat mulai membaca dengan aman, sebagai berikut.  Jika kami tidak memproses semua akumulasi perubahan (karena beberapa dokumen tidak "dilacak" dalam antrian), maka kami mengambil jumlah transaksi paling awal dari yang terkait dengan perubahan yang belum berhasil kami terapkan.  Dan jika itu terjadi, kami menerapkan semua perubahan yang terakumulasi, maka kami hanya mengambil jumlah transaksi yang terakhir diselesaikan. </p><br><p>  Apa yang terjadi sebagai hasilnya baik-baik saja dengan kami, tetapi ada satu poin yang lebih penting: agar kinerja indeks waktu nyata tetap pada tingkat yang dapat diterima dari waktu ke waktu, perlu bahwa ukuran dan jumlah "potongan" dari indeks ini tetap kecil.  Untuk melakukan ini, Sphinx memiliki permintaan <code>FLUSH RAMCHUNK</code> , yang membuat potongan disk baru, dan permintaan <code>OPTIMIZE INDEX</code> , yang menggabungkan semua potongan disk menjadi satu.  Awalnya, kami berpikir bahwa kami hanya akan melakukannya secara berkala dan itu saja.  Tetapi, sayangnya, ternyata dalam versi 2.3.2 <code>OPTIMIZE INDEX</code> tidak berfungsi (yaitu, dengan probabilitas yang cukup tinggi mengarah pada penurunan dalam pencariand).  Karena itu, kami memutuskan hanya sekali sehari untuk membangun kembali indeks sepenuhnya, terutama karena dari waktu ke waktu kami masih harus melakukannya (misalnya, jika skema indeks atau pengaturan tokenizer berubah). </p><br><p>  Prosedur untuk membangun kembali indeks berlangsung dalam beberapa tahap. </p><br><ol><li><p>  Kami membuat konfigurasi untuk pengindeks </p><br><p>  Seperti disebutkan di atas, ada templat kueri SQL dalam konfigurasi layanan.  Ini juga digunakan untuk membentuk konfigurasi pengindeks. <br>  Juga di konfigurasi ada pengaturan lain yang diperlukan untuk membangun indeks (pengaturan tokenizer, kamus, berbagai pembatasan konsumsi sumber daya). </p><br></li><li><p>  Simpan posisi MariaDB saat ini </p><br><p>  Dari posisi ini, kita akan mulai membaca binlog, setelah indeks baru tersedia di semua server dengan searchd. </p><br></li><li><p>  Kami memulai pengindeks </p><br><p>  <code>indexer --config tmp.vacancy.indexer.0.conf --all</code> perintah form <code>indexer --config tmp.vacancy.indexer.0.conf --all</code> dan tunggu penyelesaiannya.  Apalagi jika indeks dibagi menjadi beberapa bagian, maka kita mulai membangun semua bagian secara paralel. </p><br></li><li><p>  Kami memuat file indeks di server </p><br><p>  Mengunduh ke setiap server juga terjadi secara paralel, tetapi kami secara alami menunggu hingga semua file diunggah ke semua server.  Untuk mengunduh file dalam konfigurasi layanan, ada bagian dengan templat perintah untuk mengunduh file. </p><br><pre> <code class="plaintext hljs">[index_uploader] executable = "rsync" arguments = [ "--files-from=-", "--log-file=&lt;&lt;.DataDir&gt;&gt;/rsync.&lt;&lt;.Host&gt;&gt;.log", "--no-relative", "--times", "--delay-updates", ".", "rsync://&lt;&lt;.Host&gt;&gt;/index/vacancy/", ]</code> </pre> <br><p>  Untuk setiap server, kami cukup mengganti namanya dalam variabel Host dan menjalankan perintah yang dihasilkan.  Kami menggunakan rsync untuk diunduh, tetapi pada prinsipnya program atau skrip apa pun yang menerima daftar file di stdin dan mengunduh file-file ini ke folder tempat searchd mengharapkan untuk melihat file indeks akan dilakukan. </p><br></li><li><p>  Kami menghentikan sinkronisasi </p><br><p>  Kami berhenti membaca binlog, menghentikan goroutine yang bertanggung jawab atas akumulasi perubahan. </p><br></li><li><p>  Ganti indeks lama dengan yang baru </p><br><p>  Untuk setiap server dengan searchd, kami membuat kueri berurutan <code>RELOAD INDEX vacancy_plain</code> , <code>RELOAD INDEX vacancy_plain</code> , <code>TRUNCATE INDEX vacancy_plain</code> , <code>TRUNCATE INDEX vacancy_plain</code> , <code>ATTACH INDEX vacancy_plain TO vacancy</code> .  Jika indeks dibagi menjadi beberapa bagian, maka kami menjalankan kueri ini untuk setiap bagian secara berurutan.  Pada saat yang sama, jika kita berada dalam lingkungan produksi, maka sebelum mengeksekusi kueri ini pada server apa pun, kami menghapus beban dari itu melalui penyeimbang (sehingga tidak ada yang membuat SELECT kueri ke indeks antara <code>TRUNCATE</code> dan <code>ATTACH</code> ), dan segera setelah permintaan <code>ATTACH</code> terakhir selesai, kami mengembalikan beban ke server ini. </p><br></li><li><p>  Melanjutkan sinkronisasi dari posisi yang disimpan </p><br><p>  Segera setelah kami mengganti semua indeks waktu nyata dengan yang baru dibangun, kami melanjutkan membaca dari binlog dan menyinkronkan peristiwa dari binlog, mulai dari posisi yang kami simpan sebelum pengindeksan dimulai. </p><br></li></ol><br><p>  Berikut ini adalah contoh grafik lag indeks dari server MariaDB. </p><br><p><img src="https://habrastorage.org/webt/xs/pq/56/xspq56osyygn1fxx6h5x_oczgpy.png" alt="Backlog setelah pengindeksan ulang"></p><br><p>  Di sini Anda dapat melihat bahwa meskipun keadaan indeks setelah pembangunan kembali kembali pada waktunya, ini terjadi sangat singkat. </p><br><p>  Sekarang semuanya sudah lebih atau kurang siap, saatnya untuk rilis.  Kami melakukannya secara bertahap.  Pertama, kami menuangkan indeks waktu nyata pada beberapa server, dan sisanya pada saat itu bekerja dengan cara yang sama.  Pada saat yang sama, struktur indeks pada server "baru" tidak berbeda dari yang lama, sehingga aplikasi PHP kami masih dapat terhubung ke penyeimbang tanpa khawatir tentang apakah permintaan akan diproses pada indeks realtime atau pada indeks biasa. </p><br><p><img src="https://habrastorage.org/webt/sy/xz/lx/syxzlx_tfmg0-mze5vr1ngt3_tg.png" alt="Distribusi distribusi transisi"></p><br><p>  Pembaruan atribut, yang saya bicarakan sebelumnya, juga dikirim sesuai dengan skema lama, dengan perbedaan bahwa indeks terdistribusi pada semua server dikonfigurasi untuk mengirim permintaan UPDATE hanya ke server dengan indeks biasa.  Selain itu, jika permintaan-UPDATE dari aplikasi mencapai server dengan indeks realtime, maka itu tidak menjalankan permintaan ini di rumah, tetapi mengirimkannya ke server yang dikonfigurasi dengan cara lama. </p><br><p>  Setelah rilis, seperti yang kami harapkan, ternyata secara signifikan mengurangi penundaan antara bagaimana resume atau lowongan berubah dalam database dan bagaimana perubahan yang sesuai masuk ke dalam indeks. </p><br><p>  Setelah beralih ke indeks waktu nyata, tidak perlu membangun kembali indeks setelah setiap perubahan pada server pengujian.  Sehingga menjadi mungkin untuk menulis autotest ujung ke ujung dengan partisipasi pencarian yang relatif tidak mahal.  Namun, karena kami memproses perubahan dari binlog secara tidak sinkron (dari sudut pandang klien yang menulis ke basis data), kami harus memungkinkan untuk menunggu hingga perubahan terkait dokumen yang berpartisipasi dalam autotest diproses oleh layanan kami dan dikirim ke searchd . </p><br><p>  Untuk melakukan ini, kami membuat titik akhir dalam layanan kami, yang melakukan hal itu, yaitu menunggu hingga semua perubahan diterapkan ke nomor transaksi yang ditentukan.  Untuk melakukan ini, segera setelah kami melakukan perubahan yang diperlukan pada database, kami meminta dari MariaDB <code>@@gtid_current_pos</code> dan mentransfernya ke titik akhir layanan kami.  Jika kami sudah menerapkan semua transaksi pada posisi ini saat ini, layanan segera menjawab bahwa kami dapat melanjutkan.  Jika tidak, maka di goroutine yang bertanggung jawab untuk menerapkan perubahan, kami membuat langganan ke GTID ini, dan segera setelah itu (atau yang mengikutinya) diterapkan, kami juga memungkinkan klien untuk melanjutkan autotest. </p><br><p>  Dalam kode PHP, tampilannya seperti ini: </p><br><pre> <code class="plaintext hljs">&lt;?php declare(strict_types=1); use GuzzleHttp\ClientInterface; use GuzzleHttp\RequestOptions; use PDO; class RiverClient { private const REQUEST_METHOD = 'post'; /** * @var ClientInterface */ private $httpClient; public function __construct(ClientInterface $httpClient) { $this-&gt;httpClient = $httpClient; } public function waitForSync(PDO $mysqlConnection, PDO $sphinxConnection, string $riverAddr): void { $masterGTID = $mysqlConnection-&gt;query('SELECT @@gtid_current_pos')-&gt;fetchColumn(); $this-&gt;httpClient-&gt;request( self::REQUEST_METHOD, "http://{$riverAddr}/wait", [RequestOptions::FORM_PARAMS =&gt; ['gtid' =&gt; $masterGTID]] ); } }</code> </pre> <br><h2 id="rezultaty">  Hasil </h2><br><p>  Sebagai hasilnya, kami dapat secara signifikan mengurangi penundaan antara memperbarui MariaDB dan Sphinx. </p><br><p><img src="https://habrastorage.org/webt/lc/rs/rl/lcrsrlzpcw8bzhuptg5s42p6wou.png" alt="Database polos lag dari database"></p><br><p><img src="https://habrastorage.org/webt/7h/ik/ic/7hikichzuaqyszagbenen-9drhk.png" alt="Rt-index lag dari database"></p><br><p>  Kami juga menjadi jauh lebih percaya diri bahwa semua pembaruan menjangkau semua server Sphinx kami tepat waktu. </p><br><p>  Selain itu, pengujian pencarian (baik manual dan otomatis) menjadi jauh lebih menyenangkan. </p><br><p>  Sayangnya, ini tidak diberikan kepada kami secara gratis: kinerja indeks waktu nyata dibandingkan dengan indeks biasa ternyata sedikit lebih buruk. </p><br><p>  Distribusi waktu pemrosesan permintaan pencarian tergantung pada waktu untuk indeks biasa ditunjukkan di bawah ini. </p><br><p><img src="https://habrastorage.org/webt/op/ro/gm/oprogmvvdykt244nlbmzeldufhu.png" alt="Garis waktu eksekusi kueri - polos"></p><br><p>  Dan di sini adalah grafik yang sama untuk indeks realtime. </p><br><p><img src="https://habrastorage.org/webt/07/ii/ce/07iicewkxbb0qvsrrob6dbwoa2i.png" alt="Batas waktu pelaksanaan kueri - waktu nyata"></p><br><p>  Anda dapat melihat bahwa pangsa permintaan "cepat" sedikit menurun, sedangkan pangsa permintaan "lambat" telah meningkat. </p><br><h2 id="vmesto-zaklyucheniya">  Alih-alih sebuah kesimpulan </h2><br><p>  Tetap mengatakan bahwa kode layanan yang dijelaskan dalam artikel ini, kami diposting <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di domain publik</a> .  Sayangnya, belum ada dokumentasi terperinci, tetapi jika Anda mau, Anda dapat menjalankan contoh menggunakan layanan ini melalui <code>docker-compose</code> . </p><br><h2 id="ssylki">  Referensi </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Video</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">slide</a> laporan </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Laporan video oleh Andrey Smirnov dan Vyacheslav Kryukov di Highload ++</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Go-mysql library</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode layanan dengan contoh penggunaan</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447526/">https://habr.com/ru/post/id447526/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447512/index.html">Dan siapa yang melakukan ini? Otomatis audit keamanan informasi</a></li>
<li><a href="../id447514/index.html">7 startup yang menarik di IoT</a></li>
<li><a href="../id447516/index.html">Bagaimana kami melakukan overclock CAD COMPASS-3D ‚Üí Bagian 2</a></li>
<li><a href="../id447520/index.html">Fitur Auto Tiering dalam penyimpanan Qsan XCubeSAN</a></li>
<li><a href="../id447522/index.html">Hal-hal berguna apa yang bisa ditarik dari log workstation berbasis Windows</a></li>
<li><a href="../id447528/index.html">Siapa yang bertanggung jawab atas kualitas?</a></li>
<li><a href="../id447530/index.html">OceanLotus: Pembaruan Malvari untuk macOS</a></li>
<li><a href="../id447532/index.html">Splunk Universal Forwarder di Docker sebagai pengumpul log sistem</a></li>
<li><a href="../id447534/index.html">Cosmonaut Aleksandr Laveykin tentang film ruang angkasa terbaik, G-force 20g, dan soft landing</a></li>
<li><a href="../id447536/index.html">Terapkan IdM. Persiapan untuk implementasi oleh pelanggan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>