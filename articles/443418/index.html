<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐵 👵🏿 🙆🏻 Métodos de prueba de software 👦🏼 🐎 🦋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! La próxima semana vamos a lanzar un nuevo hilo en el curso "Automation Web Testing" . Este será el tema del material de hoy. 

 Este art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Métodos de prueba de software</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/443418/"> Hola a todos!  La próxima semana vamos a lanzar un nuevo hilo en el curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Automation Web Testing"</a> .  Este será el tema del material de hoy. <br><br>  Este artículo analiza varias formas de probar software, como pruebas unitarias, pruebas de integración, pruebas funcionales, pruebas de aceptación, etc. <br><br><img src="https://habrastorage.org/webt/tc/nf/kc/tcnfkcczhmixn92gpm04au1rgdo.png"><br><br>  Hay muchos tipos diferentes de pruebas que puede aplicar para asegurarse de que los cambios en su código estén programados.  No todos los tipos de pruebas son idénticos, aunque aquí vemos cómo las principales prácticas de prueba difieren entre sí. <br><br>  <b>Prueba: manual o automatizada?</b> <br><br>  Primero debe comprender las diferencias entre las pruebas manuales y automatizadas.  Las pruebas manuales son realizadas directamente por una persona que hace clic en los botones de la aplicación o interactúa con el software o la API con las herramientas necesarias.  Esto es bastante costoso, ya que requiere que el probador instale el entorno de desarrollo y ejecute las pruebas manualmente.  Hay una probabilidad de error debido a un factor humano, como un error tipográfico o saltarse pasos en un caso de prueba. <a name="habracut"></a><br><br>  Las pruebas automatizadas, por otro lado, son realizadas por una máquina que ejecuta un script de prueba que se escribió de antemano.  Dichas pruebas pueden variar mucho según la complejidad, desde probar un único método en una clase hasta elaborar una secuencia de acciones complejas en una interfaz de usuario para asegurarse de que funcione correctamente.  Este método se considera más confiable, pero su rendimiento aún depende de qué tan bien se haya escrito bien el script para la prueba. <br><br>  Las pruebas automatizadas son un componente clave de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">integración</a> continua y la entrega continua, así como una buena forma de escalar su proceso de control de calidad al tiempo que agrega nuevas funcionalidades a su aplicación.  Sin embargo, las pruebas manuales todavía tienen su propio valor.  Por lo tanto, en el artículo definitivamente hablaremos sobre las pruebas exploratorias. <br><br>  <b>Diferentes tipos de pruebas</b> <br><br>  <i><b>Pruebas unitarias</b></i> <br><br>  Las pruebas unitarias se consideran de bajo nivel, cercanas al código fuente de su aplicación.  Están dirigidos a probar métodos y funciones individuales dentro de las clases, probando los componentes y módulos utilizados por su programa.  Las pruebas unitarias en general no requieren costos especiales de automatización y pueden funcionar extremadamente rápido si utiliza un servidor de integración continua. <br><br>  <i><b>Pruebas de integración</b></i> <br><br>  Las pruebas de integración verifican si los servicios y módulos utilizados por su aplicación funcionan bien juntos.  Por ejemplo, pueden probar la integración con una base de datos o asegurarse de que los microservicios interactúen correctamente entre sí.  Estas pruebas se ejecutan a un costo mayor, ya que necesitan muchas partes de la aplicación para funcionar simultáneamente. <br><br>  <i><b>Pruebas de funcionamiento</b></i> <br><br>  Las pruebas funcionales se basan en los requisitos comerciales de la aplicación.  Solo verifican la salida después de que se realiza la acción y no verifican los estados intermedios del sistema durante la reproducción de la acción. <br><br>  A veces hay contradicciones entre las pruebas de integración y las pruebas funcionales, como  ambos solicitan múltiples componentes que interactúan entre sí.  La diferencia es que las pruebas de integración simplemente pueden garantizar que la base de datos sea accesible, mientras que una prueba funcional quiere obtener un cierto valor de la base de datos para verificar uno de los requisitos para el producto final. <br><br>  <i><b>Pruebas de punta a punta</b></i> <br><br>  Las pruebas de extremo a extremo simulan el comportamiento del usuario al interactuar con el software.  Comprueba con qué precisión varios usuarios siguen el escenario previsto de la aplicación y puede ser bastante simple, por ejemplo, parecer cargar una página web o ingresar a un sitio web o, en un caso más complicado, confirmar una dirección de correo electrónico, pagos en línea, etc. <br><br>  Las pruebas de extremo a extremo son extremadamente útiles, pero producirlas es costoso y puede ser difícil de automatizar.  Se recomiendan varias pruebas transversales, pero aún confían más en las pruebas de bajo nivel (pruebas unitarias y de integración) para poder reconocer rápidamente los cambios importantes. <br><br>  <i><b>Prueba de aceptación</b></i> <br><br>  Las pruebas de aceptación son pruebas formales que se realizan para garantizar que el sistema satisfaga las necesidades comerciales.  Requieren que la aplicación se ejecute y se ejecuten, e imitan las acciones del usuario.  Las pruebas de aceptación pueden ir más allá y medir el rendimiento del sistema y rechazar los cambios recientes si no se han alcanzado los objetivos de desarrollo finales. <br><br>  <i><b>Pruebas de rendimiento</b></i> <br><br>  Las pruebas de rendimiento prueban el comportamiento de un sistema cuando está bajo una carga significativa.  Estas pruebas no son funcionales y pueden tomar muchas formas para probar la confiabilidad, estabilidad y disponibilidad de la plataforma.  Por ejemplo, puede monitorear el tiempo de respuesta al realizar una gran cantidad de solicitudes u observar cómo se comporta el sistema cuando interactúa con grandes datos. <br><br>  Las pruebas de rendimiento son inherentemente costosas de realizar, pero pueden ayudarlo a comprender qué factores externos pueden afectar su sistema. <br><br>  <i><b>Prueba de humo</b></i> <br><br>  Las pruebas de humo son pruebas básicas que prueban la funcionalidad básica de una aplicación.  Funcionan lo suficientemente rápido y su objetivo es dejar en claro que las funciones principales del sistema funcionan como deberían y nada más.  Dichas pruebas tienen como objetivo identificar errores obvios. <br><br>  Las pruebas de humo pueden ser útiles inmediatamente después de construir una nueva compilación para verificar si puede ejecutar pruebas más costosas, o inmediatamente después de la implementación, para asegurarse de que la aplicación funcione bien en el nuevo entorno. <br><br>  <b>Cómo automatizar pruebas</b> <br><br>  Un probador puede realizar todas las pruebas mencionadas anteriormente manualmente, pero esto será extremadamente costoso e improductivo.  Porque las personas tienen una capacidad limitada para realizar una gran cantidad de acciones repetitivas mientras siguen probando de manera confiable.  Sin embargo, la máquina puede reproducir fácilmente las mismas acciones y verificar, por ejemplo, que la combinación de nombre de usuario / contraseña funcionará por centésima vez sin ninguna queja. <br><br>  Para automatizar las pruebas, primero debe escribirlas en algunos de los lenguajes de programación utilizando un marco de prueba que sea adecuado para su aplicación.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PHPUnit</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mocha</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RSpec</a> son ejemplos de marcos de prueba que puede usar para PHP, Javascript y Ruby, respectivamente.  Tienen muchas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">características</a> para cada idioma, por lo que debe investigar un poco y consultar con las comunidades de desarrolladores para determinar qué marco es el mejor para usted. <br><br>  Si sus pruebas se pueden ejecutar usando scripts desde la terminal, puede automatizarlas usando un servidor de integración continua al estilo Bamboo o el servidor en la nube Bitbucket Pipelines.  Estas herramientas supervisarán sus repositorios y ejecutarán conjuntos de pruebas tan pronto como se introduzcan nuevos cambios en el repositorio principal. <br><br><img src="https://habrastorage.org/webt/ux/1g/ad/ux1gadoiynbuaj_s6k_l_oos1ow.jpeg"><br><br>  Si es nuevo en las pruebas, consulte nuestra guía de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">integración</a> continua para crear su primer conjunto de pruebas. <br><br>  <b>Pruebas de investigación</b> <br><br>  Cuantas más funciones y mejoras se agreguen a su código, mayor será la necesidad de realizar pruebas, ya que en cada etapa debe asegurarse de que el sistema funcione correctamente.  Además, será necesario cada vez que repare un error, ya que no sería superfluo asegurarse de que no vuelva a aparecer después de varios lanzamientos.  La automatización es la clave para hacer esto posible;  Escribir pruebas tarde o temprano se convertirá en parte de su práctica de desarrollador. <br><br>  La pregunta es, ¿es necesario realizar pruebas manuales en este caso?  La respuesta corta es sí, y debe centrarse en lo que se llama prueba exploratoria, que ayuda a identificar errores sutiles. <br><br>  Una sesión de prueba de investigación no debe exceder las dos horas y debe tener un alcance claramente definido para ayudar a los evaluadores a enfocarse en un área específica del software.  Después de informar a todos los evaluadores sobre los límites de las pruebas, queda a su discreción las acciones que tomarán para verificar cómo se comporta el sistema.  Dichas pruebas son de naturaleza costosa, pero muy útiles para identificar problemas con la interfaz de usuario o verificar el estado de los flujos de trabajo complejos para los usuarios.  Es importante realizar tales pruebas siempre que se agregue una función radicalmente nueva a la aplicación para comprender cómo se comportará en condiciones límite. <br><br>  <b>Nota de prueba</b> <br><br>  Antes de terminar este artículo, quiero hablar sobre el propósito de las pruebas.  Por un lado, es muy importante asegurarse de que los usuarios puedan usar su aplicación ("No puedo iniciar sesión", "No puedo guardar datos", etc.), pero por otro lado, es igualmente importante verificar que su sistema No se rompe al ingresar datos incorrectos o acciones inesperadas.  Debe anticipar lo que sucederá cuando un usuario cometa un error tipográfico, intente guardar un formulario incompleto o use la API incorrecta.  Debe verificar si uno de los usuarios puede comprometer fácilmente los datos, obtener acceso a un recurso en particular al que no debería tener acceso.  Un buen conjunto de pruebas debería intentar romper su aplicación y ayudar a comprender el límite de sus capacidades. <br><br>  Y finalmente, ¡las pruebas también son código!  Por lo tanto, no se olvide de ellos durante la revisión del código, ya que pueden ser el último paso antes de lanzar el producto al mercado de consumo. <br><br>  De acuerdo con la tradición establecida, estamos esperando sus comentarios e invitamos a todos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la jornada de puertas abiertas</a> , que se llevará a cabo el 18 de marzo por nuestro maestro, el ingeniero de automatización de pruebas líder en el Grupo IB, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mikhail Samoilov</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443418/">https://habr.com/ru/post/443418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443406/index.html">Los 20 errores principales al trabajar con subprocesos múltiples en C ++ y formas de evitarlos</a></li>
<li><a href="../443408/index.html">Fotones, cuantos y estado de Fock: manipulaciones a nivel cuántico con un resonador de radiofrecuencia</a></li>
<li><a href="../443412/index.html">Por qué los programadores continúan usando Java detallado, aunque hay Python conciso</a></li>
<li><a href="../443414/index.html">Poste indicador: cuando los puntos de interrupción no son suficientes</a></li>
<li><a href="../443416/index.html">Winnti: un ataque a las cadenas de suministro: los desarrolladores de juegos asiáticos están a la vanguardia</a></li>
<li><a href="../443422/index.html">Almacenamiento flexible de datos en MySQL (JSON)</a></li>
<li><a href="../443424/index.html">Reescribiendo el caso de prueba para frontend junior a TypeScript y react-hooks</a></li>
<li><a href="../443426/index.html">Marca negra: cómo OpenShift protege contra las vulnerabilidades del contenedor con SELinux</a></li>
<li><a href="../443428/index.html">Palmer Lucky, el "padre" de Oculus Rift, está desarrollando un sistema virtual de campo de batalla para el Pentágono</a></li>
<li><a href="../443430/index.html">¿Por qué es malo cuando Internet sabe todo sobre ti?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>