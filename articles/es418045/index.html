<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüë¶ üìµ üë©üèª‚ÄçüöÄ Usando funciones de JavaScript para construir modelos 3D üéâ üë©‚Äçüíª üë©üèΩ‚Äçü§ù‚Äçüë®üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo analiza el uso de la biblioteca geom√©trica de funciones de WebGeometry para construir modelos de poliedros complejos. La biblioteca est√°...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usando funciones de JavaScript para construir modelos 3D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418045/">  Este art√≠culo analiza el uso de la biblioteca geom√©trica de funciones de WebGeometry para construir modelos de poliedros complejos.  La biblioteca est√° escrita en Javascript.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un enlace a GitHub</a> con un ejemplo que proporciona un ejemplo simple de uso de la biblioteca.  Comentarios y cr√≠ticas son bienvenidos. <br><br><img src="https://habrastorage.org/webt/u8/6o/95/u86o95ibyus3rjrq5haqqqfipku.png"><br><br>  La biblioteca ThreeJS se usa para mostrar modelos precalculados usando funciones de la biblioteca WebGeometry.  El lienzo HTML5 se usa para mostrar elementos de modelos planos individuales y mostrar informaci√≥n de soporte. <br><a name="habracut"></a><br>  La tecnolog√≠a WebGL y las bibliotecas creadas sobre esta base, como ThreeJS y BadylonJS, se utilizan en Internet para implementar una variedad de prop√≥sitos relacionados con los gr√°ficos 3D.  Pero b√°sicamente se utilizan para mostrar modelos tridimensionales ya preparados en un navegador (previamente creado, por ejemplo, en programas <em>3ds Max</em> o <em>Blender</em> ).  Si nos enfrentamos a la tarea de crear un modelo param√©trico, es decir, un modelo para el cual, en el proceso de mostrar un objeto terminado en el navegador, podemos cambiar sus elementos individuales estableciendo los par√°metros del modelo apropiados (por ejemplo, aumentar el √°ngulo de una determinada cara), necesitamos tener Un conjunto de funciones geom√©tricas que le permitir√°n crear un modelo para que en el futuro exista la posibilidad de variar interactivamente la forma de los elementos individuales del modelo o de todo el modelo.  Para resolver este problema, necesitamos un conjunto de funciones en el lenguaje Javascript que implemente los m√©todos utilizados en geometr√≠a anal√≠tica.  La biblioteca debe tener funciones para crear l√≠neas, planos y c√≠rculos, encontrar puntos (o l√≠neas) de su intersecci√≥n, crear planos inclinados y mucho m√°s.  Las bibliotecas ThreeJS y BadylonJS tienen algunas de estas caracter√≠sticas, pero el n√∫mero de acciones realizadas con ellas no le permitir√° completar todas las tareas que surgen al construir un modelo param√©trico.  Hay varias bibliotecas Javascript m√°s puramente matem√°ticas.  De estos, <em>glMatrix</em> y <em>Sylvester</em> son los m√°s utilizados.  La biblioteca <em>glMatrix</em> est√° dise√±ada principalmente para trabajar con vectores, matrices y cuaterniones, pero no hay funciones para trabajar con l√≠neas y planos en ella.  La biblioteca <em>Sylvester</em> tiene estas funciones, pero est√°n presentes en una cantidad bastante limitada.  Sin embargo, hay varios libros que describen la implementaci√≥n de m√©todos de geometr√≠a anal√≠tica en C / C ++.  Los programas C / C ++ correspondientes pueden usarse como prototipos para crear una biblioteca matem√°tica en Javascript.  Por lo tanto, cuando decid√≠ crear modelos param√©tricos tridimensionales de cortes de diamantes para mostrarlos en un navegador, eleg√≠ la biblioteca ThreeJS solo para mostrar modelos ya calculados; no se us√≥ para calcular la forma de los modelos.  Para el c√°lculo del formulario en s√≠, se cre√≥ la biblioteca WebGeometry.  Esta biblioteca se bas√≥ en las funciones geom√©tricas utilizadas anteriormente en C / C ++, que traduje al lenguaje Javascript.  Consideremos las etapas de la construcci√≥n de un modelo piramidal (corte de diamante del tipo Pir√°mide). <br><br>  En la <b>primera etapa,</b> necesitamos dibujar la vista prevista del modelo y luego numerar sus v√©rtices.  La siguiente figura muestra la numeraci√≥n de los v√©rtices y los nombres de los elementos de corte incluidos en el modelo de corte piramidal. <br><br><img src="https://habrastorage.org/webt/di/_x/vn/di_xvn89nuebeswhpcqh5qmar3a.png"><br><br>  Despu√©s de eso, se requiere formar caras a partir de los v√©rtices numerados.  Por ejemplo, para la cara del sitio y las caras de la corona, escriba la siguiente secuencia de v√©rtices (el primer v√©rtice duplicado de la cara indica que la cara ha terminado): <br><br><pre><code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  0 -  0, 4, 7, 3, 0, //  1 -  1, 5, 4, 0, 1, //  2 -  2, 6, 5, 1, 2, //  3 -  3, 7, 6, 2, 3, //  4 - </span></span></code> </pre> <br>  Las caras deben estar en sentido antihorario.  El archivo pyramid_index.js contiene el c√≥digo fuente para atravesar todas las caras de la pir√°mide y comentarios detallados.  El resultado del rastreo se escribe en la matriz index_cut. <br><br>  En la <b>segunda etapa,</b> podemos colorear las caras del modelo.  Este paso es opcional si no necesitamos un color.  Supongamos que queremos colorear un modelo piramidal de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/o8/h4/zz/o8h4zzu7_zxqbmjnrxqfuvobru4.png"><br><br>  Para este fin, se crea el archivo pyramid_colors.js en el que se encuentra la funci√≥n facet_colors (), que escribe los colores de todas las caras en la matriz de colores. <br><br>  En la <b>tercera etapa</b> , despu√©s de que se numeran todos los v√©rtices y se registran las secuencias transversales de todos los v√©rtices de las caras, es necesario establecer los par√°metros del modelo y luego calcular las coordenadas de todos sus v√©rtices.  Por supuesto, se supone que ya hemos delineado el algoritmo de construcci√≥n para nosotros mismos y descubrimos c√≥mo se ubicar√°n todas las caras del modelo en el espacio.  Para la pir√°mide, elegiremos los siguientes par√°metros, que determinar√°n los tama√±os de sus partes individuales y de todo el modelo en su conjunto: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DEGREE = <span class="hljs-number"><span class="hljs-number">0.01745329251994</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      var lw = 1.2; //  /  var r = 0.06; //     var angleA = 50*DEGREE; //    A  var angleB = 60*DEGREE; //    B  var hCrown = 0.3; //   var anglePav = 60*DEGREE; //    A </span></span></code> </pre><br>  La elecci√≥n de los par√°metros la determina el desarrollador del modelo.  Por ejemplo, en lugar de establecer dos par√°metros para dos √°ngulos de inclinaci√≥n de la corona, puede especificar un solo par√°metro para dos √°ngulos a la vez, entonces estos √°ngulos siempre ser√°n los mismos.  Puede ingresar un par√°metro que determine el tama√±o del sitio.  En este caso, se requiere no establecer la altura de la corona o no establecer la inclinaci√≥n de sus caras.  Otra opci√≥n para elegir par√°metros es hacer que algunos par√°metros sean computables.  En este caso, al cambiar algunos par√°metros, otros pueden cambiar su valor inicial.  Por ejemplo, si suponemos que para la pir√°mide hemos definido un par√°metro para establecer el √°ngulo de inclinaci√≥n de las caras coronales, otro par√°metro para la altura de la corona y otro par√°metro que establecer√° el tama√±o del √°rea, entonces al cambiar el √°ngulo de las caras nos veremos obligados a cambiar el tama√±o del √°rea o altura de la corona  Por otro lado, si cambia el par√°metro que establece el tama√±o de la almohadilla, el valor del par√°metro que establece la altura o la pendiente de las caras coronales cambiar√° autom√°ticamente.  No se utiliza la opci√≥n asociada con la aplicaci√≥n de los par√°metros calculados en este programa, as√≠ como en la construcci√≥n de los otros modelos de corte presentados en el sitio. <br><br>  En la <b>cuarta etapa</b> , se calculan las coordenadas de los v√©rtices del modelo.  Los datos iniciales para el c√°lculo son los valores de los par√°metros del modelo y c√≥mo imaginamos su apariencia.  El archivo pyramid_verts.js contiene el texto fuente (con comentarios detallados) de la funci√≥n de c√°lculo de v√©rtices del modelo, que se llama VerticesCalculation.  Es con este c√°lculo que las funciones de la biblioteca WebGeometry se utilizan en esta funci√≥n.  Los resultados del c√°lculo de las coordenadas de los v√©rtices se ingresan en la matriz de v√©rtices.  Tenga en cuenta que en el programa para encontrar las coordenadas de los v√©rtices, se utilizan secuencias separadas de n√∫meros para los v√©rtices que forman la corona (cuatro v√©rtices), los v√©rtices que forman la faja (cuatro v√©rtices) y los v√©rtices que forman el pabell√≥n (en el modelo de pir√°mide, solo el v√©rtice est√° incluido en el pabell√≥n).  Esta opci√≥n de numeraci√≥n de v√©rtices adicional se usa para una orientaci√≥n m√°s f√°cil por parte del programador entre los v√©rtices de corte, ya que el n√∫mero de v√©rtices suele exceder 100 <br><br>  En la <b>quinta etapa,</b> despu√©s de completar el c√°lculo de las coordenadas de los v√©rtices, se requiere construir mediante programaci√≥n el poliedro (poliedro) del modelo.  Los datos iniciales para su construcci√≥n son matrices creadas previamente de index_cut, colores y v√©rtices.  Un modelo de poliedro puede representarse simplemente como un conjunto de caras que unen un poliedro en el espacio.  La funci√≥n CreatePolyhedron est√° en el archivo polyhedron.js.  Como resultado del trabajo de esta funci√≥n, se crea una matriz de pol√≠gonos (pol√≠gonos) en la que consiste el modelo tridimensional.  Cada pol√≠gono se describe mediante la siguiente funci√≥n (de hecho, es una funci√≥n constructora llamada por el nuevo operador al crear un nuevo pol√≠gono): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Polygon</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.IndexFacet = []; <span class="hljs-comment"><span class="hljs-comment">//      //    this.IndexFacet_1 = []; //      //    this.VertexFacet; // ,    //    this.EdgeFacet = []; // ,  , //    (    //  ) this.IndexTriangle = []; // ,    // ,     this.VertexTriangle = []; // ,    //   ,     this.Faces = []; //      }</span></span></code> </pre><br>  Dado que WebGL y la biblioteca ThreeJS creada sobre su base funcionan con primitivas triangulares, se triangula para cada cara del modelo.  Se supone que todas las caras del modelo son pol√≠gonos convexos.  En √∫ltima instancia, la funci√≥n CreatePolyhedron toma todos los pasos necesarios para crear estructuras de datos que describan completamente todas las caras del poliedro de tal manera que puedan pasarse a las funciones de la biblioteca ThreeJS para mostrar el modelo en la pantalla. <br><br>  En la <b>sexta etapa</b> , el modelo se muestra en la pantalla utilizando las funciones ThreeJS.  De manera est√°ndar, se crean la escena, el renderizador y la c√°mara.  Para examinar el modelo de corte desde todos los lados, el programa Pyramid usa el elemento orbitControls.  Al crear otros modelos de corte, para inspeccionar los cortes desde todos los lados, no utilic√© orbitControls, sino que introduje la capacidad de rotar el modelo en s√≠.  Luego creamos las mallas modelo.  Puedes hacer dos cosas. <br><br>  En el primer m√©todo, consideramos el modelo de corte como un conjunto de mallas de cara separadas.  En este caso, cada cara es un objeto 3D separado.  Con esta representaci√≥n del modelo, el proceso de seleccionar una cara individual usando el elemento Three.JS, que tiene el nombre de raycaster, es bastante simple.  Adem√°s, este m√©todo puede complementarse con la creaci√≥n de mallas de segmentos que bordean cada cara. <br><br>  En la segunda forma, consideramos el modelo de corte como un solo objeto, representado por una sola malla que incluye inmediatamente todas las caras del modelo.  Este m√©todo es conveniente de usar cuando se muestra un modelo usando sombreadores.  Este m√©todo no se usa en el modelo de corte Pyramid, pero se usa para crear oct√°gono, Brilliant y otros modelos de corte que se pueden ver en mi sitio web. <br><br>  En la <b>s√©ptima etapa</b> , se crean botones y funciones adjuntas que les permiten cambiar el valor de los par√°metros que determinan la forma y el tama√±o del modelo.  Cuando se presiona un bot√≥n, se llama a una funci√≥n que aumenta o disminuye el valor del par√°metro correspondiente.  Esto significa que es necesario volver a calcular el valor de las coordenadas de los v√©rtices del modelo.  Despu√©s del recuento, se verifica la correcci√≥n del modelo reci√©n construido.  Por ejemplo, se determina si algunos valores est√°n fuera de tolerancia.  En el caso de los modelos de corte de diamante, esto generalmente se reduce a verificar si el corte convexo permanece despu√©s de su reconstrucci√≥n.  La comprobaci√≥n del bulto es la siguiente.  A trav√©s de cada cara se dibuja un plano en el que se encuentra esta cara, y luego se determina la posici√≥n de cada v√©rtice del modelo en relaci√≥n con este plano.  Todos los v√©rtices deben ubicarse en el mismo lado de este plano.  Si el modelo se considera incorrecto, el par√°metro vuelve a su valor original y el modelo se reconstruye nuevamente.  Para los modelos de corte que tienen una faja no convexa (solo este elemento de algunos cortes, como el Coraz√≥n, puede ser no convexo), la convexidad se verifica por separado para la corona y por separado para el pabell√≥n.  El rundista, sin embargo, est√° excluido del cheque.  Para modelos simples, puede restringirse a una simple verificaci√≥n de par√°metros.  Por ejemplo, si estamos construyendo un modelo de una casa, entonces el techo no debe tener m√°s de una cierta altura de antemano.  Por lo tanto, simplemente configurando la restricci√≥n de este par√°metro en magnitud, obtenemos el resultado deseado.  Despu√©s de agregar los botones de par√°metros, es muy conveniente mostrar visualmente el valor de cada par√°metro cuando cambia despu√©s de hacer clic en el bot√≥n.  Para hacer esto, se crea un lienzo bidimensional HTML5 y al lado del bot√≥n correspondiente se muestra el valor del par√°metro. <br><br>  Por lo tanto, examinamos todas las etapas de la construcci√≥n de un modelo utilizando el ejemplo de la Pir√°mide.  Para la pir√°mide (as√≠ como para todos los dem√°s modelos en el sitio), cre√© otro programa Pyramid_text.html.  El ejemplo de este programa muestra c√≥mo puede mostrar texto tridimensional para numerar los v√©rtices de un modelo.  Si alguien quiere saber c√≥mo se construyen los modelos complejos, entonces deber√≠a considerar construir modelos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">(vea GitHub)</a> en la siguiente secuencia: <br>  <b>Oct√°gono</b>  Un modelo que demuestra la creaci√≥n de planos de varias maneras y trabajando con estos planos.  Al construir un modelo, tambi√©n se utilizan los m√©todos utilizados al trabajar con vectores y l√≠neas en el espacio. <br><br>  <b>Brillante</b>  Este es el corte de diamante cl√°sico y m√°s com√∫n.  Algunos elementos de la construcci√≥n de un modelo tridimensional de este corte se utilizan en el futuro al crear facetas MoonMarquise, MoonPear y Heart.  La forma en que se calcula la faja de este corte, que tiene la forma de un superelipse, se muestra por separado en el programa BrilliantGirdlt.html.  En este programa, la l√≠nea de cintura se construye en un lienzo bidimensional (lienzo). <br><br>  <b>MoonMarquise</b> .  El corte Marquesa, como Brilliant, es uno de los cl√°sicos cortes de diamantes.  A diferencia de una faceta simple de este tipo (Marquesa), las llamadas "facetas lunares" se agregan a la faceta MoonMarquise del Pabell√≥n.  El cortador MoonMarquise est√° formado por dos arcos de elipses.  Una construcci√≥n detallada de esta faja sobre lienzo se muestra en el programa MarquiseGirdle.html.  El texto de este programa tiene comentarios detallados sobre la construcci√≥n.  Observamos un punto con respecto al c√°lculo de la l√≠nea de cintura: usa la propiedad de una tangente a una elipse.  Se considera, por ejemplo, en el libro "Curso de geometr√≠a anal√≠tica" (el autor de este libro es N.I. Muskhelishvili). <br>  <b>MoonPear</b>  El mero de corte MoonPear est√° formado por los arcos de tres elipses.  Su construcci√≥n se basa en la construcci√≥n de la faja de corte Marquesa, pero es m√°s compleja.  Para ver la l√≠nea de cintura de Marquise y c√≥mo dividir la gundist en segmentos, ejecute el programa PearGirdle.html. <br><br>  <b>Corazon</b>  El corte "coraz√≥n" es uno de los cortes cl√°sicos, pero tiene, en contraste con la mayor√≠a de los cortes, una forma de faja no convexa.  El rudista de corte de coraz√≥n est√° formado por dos fajas de corte de pera inclinadas una respecto a la otra.  En el lienzo, puede ver la l√≠nea de cintura ejecutando el programa HeartGirdle.html.  Construir un corte de coraz√≥n es todo un desaf√≠o. <br><br>  <b>Cruz de Malta</b>  El cortador del corte "Cruz de Malta" est√° hecho en forma de "almohada" (coj√≠n).  Los esquejes con tal faja se han generalizado recientemente.  La l√≠nea de esta faja es ocho arcos de c√≠rculos conjugados: cuatro arcos principales que bordean la almohada en cuatro lados y cuatro arcos de menor tama√±o que combinan los arcos principales de la almohada en las esquinas de la faja.  Al ejecutar los programas CushionGirdle_1.html y CushionGirdle_2.html, puede ver la forma de la l√≠nea de la faja, el trabajo de todos los par√°metros que establecen su forma y la divisi√≥n de la faja en segmentos. <br><br>  <b>Estrella pentagonal</b> .  El cortador estelar pentagonal est√° formado por una l√≠nea que lleva el nombre del epitrocoide.  El epitrocoide es una curva relacionada con el cicloide.  En el programa Wavy_Pentagon_Girdle.html, al cambiar los valores de los par√°metros, puede cambiar la "ondulaci√≥n" de la faja e incluso cambiar el pent√°gono a un pol√≠gono con un n√∫mero diferente de salientes ("p√©talos").  Sin embargo, debe recordarse que el modelo de este corte en s√≠ est√° construido para el valor del par√°metro "N√∫mero de p√©talos" igual a 5. <br><br>  Como se mencion√≥ anteriormente, para todos los modelos anteriores, los programas se crean mostrando el n√∫mero de v√©rtices de corte.  En estos programas, se realiza un cambio entre la visualizaci√≥n directa de todos los v√©rtices del modelo y la indicaci√≥n de los n√∫meros de v√©rtice para la corona, la faja y el pabell√≥n por separado.  Suponga que en el modelo de corte malt√©s desea crear un plano que pase por los v√©rtices con los n√∫meros 84, 88 y 145. En lugar de usar estos n√∫meros para identificar los puntos a trav√©s de los cuales pasa el plano al crear un plano usando la funci√≥n CreatePlaneThreePoints, una grabaci√≥n usando un separado Numeraci√≥n de picos para la faja y el pabell√≥n: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> plane = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Plane3D(); plane.CreatePlaneThreePoints(girdle[<span class="hljs-number"><span class="hljs-number">68</span></span>], girdle[<span class="hljs-number"><span class="hljs-number">72</span></span>], crown[<span class="hljs-number"><span class="hljs-number">1</span></span>]);</code> </pre><br>  Cabe se√±alar que los programas que muestran n√∫meros de v√©rtices modelo funcionan muy lentamente (al menos en mi computadora).  Pueden pasar varios segundos antes de que se complete la salida de los n√∫meros de v√©rtice del modelo. <br><br>  Para resumir todo lo anterior, en mi opini√≥n, la elecci√≥n de poliedros (modelos de corte) para demostrar el funcionamiento de las funciones geom√©tricas es una de las mejores opciones.  Despu√©s de examinar el trabajo de los ejemplos anteriores, podemos proceder a la creaci√≥n de objetos geom√©tricos relacionados con campos de actividad completamente diferentes que el modelado de corte de diamante. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418045/">https://habr.com/ru/post/es418045/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418031/index.html">Apilamiento masivo de modelos ML en producci√≥n: ¬øreal o no?</a></li>
<li><a href="../es418035/index.html">Presentando Timeline en Unity</a></li>
<li><a href="../es418037/index.html">Probador m√≥vil prep√°rate. Bienvenido al Avito Mobile Testing Meetup</a></li>
<li><a href="../es418041/index.html">Alrededor de 500 millones de dispositivos IoT son susceptibles de ataque a trav√©s de la suplantaci√≥n de DNS</a></li>
<li><a href="../es418043/index.html">C√≥mo no me fui a los Estados Unidos y me convert√≠ en presidente en Rusia</a></li>
<li><a href="../es418047/index.html">Los mejores empleadores en TI: los primeros resultados del servicio de calificaci√≥n en My Circle</a></li>
<li><a href="../es418049/index.html">¬øC√≥mo revert√≠ el sistema hace un mes y recuper√© todo? Experiencia con ESXi. O como no hacerlo</a></li>
<li><a href="../es418051/index.html">C√≥mo arreglar una oficina abierta: reglas de la biblioteca</a></li>
<li><a href="../es418053/index.html">Entregar en media hora</a></li>
<li><a href="../es418055/index.html">La interfaz del juego y lo que come</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>