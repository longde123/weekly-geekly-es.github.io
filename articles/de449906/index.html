<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥪 🤲🏾 👩🏾‍🏫 Selbstdokumentierender REST-Server (Node.JS, TypeScript, Koa, Joi, Swagger) 🌅 💊 👾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es wurden bereits viele Artikel über die Vor- und Nachteile von REST geschrieben (und noch mehr in den Kommentaren dazu). Und wenn es so passiert ist,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Selbstdokumentierender REST-Server (Node.JS, TypeScript, Koa, Joi, Swagger)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449906/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/tg/hh/en/tghhend0r6amxsxj0mhnr9uy3l4.jpeg"></div><br>  Es wurden bereits viele Artikel über die Vor- und Nachteile von REST geschrieben (und noch mehr in den Kommentaren dazu).  Und wenn es so passiert ist, dass Sie einen Dienst entwickeln müssen, in dem diese Architektur angewendet werden soll, werden Sie sicherlich auf seine Dokumentation stoßen.  Schließlich verstehen wir beim Erstellen jeder Methode, dass andere Programmierer auf diese Methoden verweisen.  Daher sollte die Dokumentation umfassend und vor allem relevant sein. <br><br>  Willkommen bei der Katze, wo ich beschreiben werde, wie wir dieses Problem in unserem Team gelöst haben. <br><a name="habracut"></a><br>  Ein bisschen Kontext. <br><br>  Unser Team wurde beauftragt, in kurzer Zeit ein Backend-Produkt mittlerer Komplexität auf <b>Node.js</b> herauszugeben.  Frontend-Programmierer und Mobilisierer sollten mit diesem Produkt interagieren. <br><br>  Nach einigem Überlegen haben wir uns entschlossen, <b>TypeScript</b> als <b>YaP zu verwenden</b> .  Gut abgestimmte <b>TSLint</b> und <b>Prettier</b> haben uns geholfen, den gleichen <b>Codestil</b> und die <b>genaue</b> Überprüfung in der Codierungs- / Montagephase (und sogar in der Commit-Phase) zu erreichen.  Starke Typisierung führte dazu, dass jeder die Schnittstellen und Typen aller Objekte klar beschrieb.  Es ist leicht zu lesen und zu verstehen, was genau diese Funktion als Eingabeparameter verwendet, was sie schließlich zurückgibt und welche der Eigenschaften des Objekts obligatorisch sind und welche nicht.  Der Code ähnelte ziemlich stark Java.  Und natürlich hat <b>TypeDoc</b> jeder Funktion mehr Lesbarkeit verliehen. <br><br>  So sah der Code aus: <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Interface of all responses */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IResponseData</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ nonce: number; code: number; message?: string; data?: T; } <span class="hljs-comment"><span class="hljs-comment">/** * Utils helper */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransferObjectUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Compose all data to result response package * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> responseCode - 200 | 400 | 500 * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> message - any info text message * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> data - response data object * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> ready object for REST response */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> createResponseObject&lt;T = object&gt;(responseCode: number, message: string, data: T): IResponseData&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result: IResponseData&lt;T&gt; = { code: responseCode || <span class="hljs-number"><span class="hljs-number">200</span></span>, nonce: Date.now() }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message) { result.message = message; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data) { result.data = data; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre> <br>  Wir haben über die Nachkommen nachgedacht, es wird nicht schwierig sein, unseren Code zu pflegen, es ist Zeit, über die Benutzer unseres REST-Servers nachzudenken. <br><br>  Da alles ziemlich schnell erledigt war, haben wir verstanden, dass es sehr schwierig sein würde, Code separat und Dokumentation separat zu schreiben.  Fügen Sie Antworten oder Anfragen entsprechend den Anforderungen von Front-End oder Mobilchiki zusätzliche Parameter hinzu und vergessen Sie nicht, andere davor zu warnen.  Hier zeigte sich eine klare Anforderung: Der <b>Code mit der Dokumentation sollte immer synchronisiert werden</b> .  Dies bedeutete, dass der Faktor Mensch ausgeschlossen werden sollte und die Dokumentation den Code beeinflussen sollte und der Code die Dokumentation beeinflussen sollte. <br><br>  Hier habe ich mich mit der Suche nach geeigneten Werkzeugen dafür befasst.  Glücklicherweise ist das NPM-Repository nur ein Lagerhaus für alle Arten von Ideen und Lösungen. <br><br>  Die Anforderungen an das Werkzeug waren wie folgt: <br><br><ul><li>  Dokumentationssynchronisation mit Code; </li><li>  TypeScript-Unterstützung; </li><li>  Validierung eingehender / ausgehender Pakete; </li><li>  Live und unterstütztes Paket. </li></ul><br>  Ich musste über einen REST-Service mit vielen verschiedenen Paketen schreiben, von denen die beliebtesten sind: tsoa, ​​swagger-node-express, express-openapi, swagger-codegen. <br><br><img src="https://habrastorage.org/webt/fs/dl/7m/fsdl7mmvvi8c64rgqoks-9loh_i.png"><br><br>  In einigen Fällen gab es jedoch keine TypeScript-Unterstützung, in einigen Fällen eine Paketvalidierung, und in einigen Fällen konnte Code basierend auf der Dokumentation generiert werden, es wurde jedoch keine weitere Synchronisierung bereitgestellt. <br><br>  Hier bin ich auf Joi-to-Swagger gestoßen.  Ein großartiges Paket, das das in Joi beschriebene Schema in eine Prahlerdokumentation und sogar mit TypeScript-Unterstützung verwandeln kann.  Alle Elemente außer der Synchronisation werden ausgeführt.  Ich eilte einige Zeit und fand ein verlassenes Depot eines Chinesen, der das <b>Joi-to-Swagger</b> in Verbindung mit dem Koa-Framework verwendete.  Da es in unserem Team keine Vorurteile gegen Koa gab und es keine Gründe gab, blind dem Express-Trend zu folgen, haben wir uns entschlossen, auf diesem Stack zu starten. <br><br>  Ich habe dieses Repository gegabelt, Fehler behoben, einige Dinge erledigt, und jetzt wurde mein erster Beitrag zu OpenSource Koa-Joi-Swagger-TS veröffentlicht.  Wir haben dieses Projekt erfolgreich bestanden und danach gab es bereits mehrere andere.  Das Schreiben und Verwalten von REST-Diensten ist sehr praktisch geworden, und Benutzer dieser Dienste benötigen lediglich einen Link zur Online-Dokumentation von Swagger.  Danach wurde klar, wo dieses Paket entwickelt werden kann, und es wurden mehrere weitere Verbesserungen vorgenommen. <br><br>  Nun wollen wir sehen, wie Sie mit <b>Koa-Joi-Swagger-TS</b> einen selbstdokumentierenden REST-Server schreiben können.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ich habe den fertigen Code hier gepostet</a> . <br><br>  Da es sich bei diesem Projekt um eine Demo handelt, habe ich mehrere Dateien vereinfacht und zu einer zusammengeführt.  Im Allgemeinen ist es gut, wenn der Index die Anwendung initialisiert und die Datei app.ts aufruft, die wiederum Ressourcen, Aufrufe zur Verbindung mit der Datenbank usw. liest.  Der Server sollte mit dem neuesten Befehl beginnen (genau das, was jetzt unten beschrieben wird). <br><br>  Erstellen Sie zunächst <b>index.ts</b> mit folgendem Inhalt: <br><br><div class="spoiler">  <b class="spoiler_title">index.ts</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Koa <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BaseContext } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> bodyParser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-bodyparser"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Router <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-router"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SERVER_PORT = <span class="hljs-number"><span class="hljs-number">3002</span></span>; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Koa(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); app.use(bodyParser()); router.get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, (ctx: BaseContext, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Root loaded!"</span></span>) }); app .use(router.routes()) .use(router.allowedMethods()); app.listen(SERVER_PORT); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Server listening on http://localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${SERVER_PORT}</span></span></span><span class="hljs-string"> ...`</span></span>); })();</code> </pre><br><br></div></div><br>  Wenn Sie diesen Dienst starten, wird ein REST-Server ausgelöst, der bisher nicht weiß, wie.  Nun ein wenig zur Architektur des Projekts.  Da ich von Java zu Node.JS gewechselt bin, habe ich versucht, hier einen Dienst mit denselben Ebenen zu erstellen. <br><br><ul><li>  Controller </li><li>  Dienstleistungen </li><li>  Repositories </li></ul><br>  <b>Beginnen</b> wir mit der Verbindung von <b>Koa-Joi-Swagger-TS</b> .  Natürlich installieren. <br><br><pre> <code class="bash hljs">npm install koa-joi-swagger-ts --save</code> </pre> <br>  Erstellen Sie den Ordner <b>"Controller"</b> und den Ordner <b>"Schemas"</b> .  Erstellen Sie im Controller-Ordner unseren ersten Controller <b>base.controller.ts</b> : <br><br><div class="spoiler">  <b class="spoiler_title">base.controller.ts</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BaseContext } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { controller, description, get, response, summary, tag } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-joi-swagger-ts"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ApiInfoResponseSchema } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./schemas/apiInfo.response.schema"</span></span>; @controller(<span class="hljs-string"><span class="hljs-string">"/api/v1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> abstract <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseController</span></span></span><span class="hljs-class"> </span></span>{ @get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: ApiInfoResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Returns text info about version of API"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Show API index page"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> index(ctx: BaseContext, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"GET /api/v1/"</span></span>); ctx.status = <span class="hljs-number"><span class="hljs-number">200</span></span>; ctx.body = { <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">appVersion</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">build</span></span>: <span class="hljs-string"><span class="hljs-string">"1001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">reqHeaders</span></span>: ctx.request.headers, <span class="hljs-attr"><span class="hljs-attr">apiDoc</span></span>: <span class="hljs-string"><span class="hljs-string">"/api/v1/swagger.json"</span></span> } } }; }</code> </pre><br></div></div><br>  Wie Sie den Dekorateuren (Anmerkungen in Java) entnehmen können, wird diese Klasse dem Pfad "/ api / v1" zugeordnet. Alle darin enthaltenen Methoden sind relativ zu diesem Pfad. <br><br>  Diese Methode enthält eine Beschreibung des Antwortformats, das in der Datei "./schemas/apiInfo.response.schema" beschrieben ist: <br><br><div class="spoiler">  <b class="spoiler_title">apiInfo.response.schema</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Joi <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"joi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { definition } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-joi-swagger-ts"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BaseAPIResponseSchema } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./baseAPI.response.schema"</span></span>; @definition(<span class="hljs-string"><span class="hljs-string">"ApiInfo"</span></span>, <span class="hljs-string"><span class="hljs-string">"Information data about current application and API version"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiInfoResponseSchema</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseAPIResponseSchema</span></span></span><span class="hljs-class"> </span></span>{ public data = Joi.object({ <span class="hljs-attr"><span class="hljs-attr">appVersion</span></span>: Joi.string() .description(<span class="hljs-string"><span class="hljs-string">"Current version of application"</span></span>) .required(), <span class="hljs-attr"><span class="hljs-attr">build</span></span>: Joi.string().description(<span class="hljs-string"><span class="hljs-string">"Current build version of application"</span></span>), <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: Joi.number() .positive() .description(<span class="hljs-string"><span class="hljs-string">"Version of current REST api"</span></span>) .required(), <span class="hljs-attr"><span class="hljs-attr">reqHeaders</span></span>: Joi.object().description(<span class="hljs-string"><span class="hljs-string">"Request headers"</span></span>), <span class="hljs-attr"><span class="hljs-attr">apiDoc</span></span>: Joi.string() .description(<span class="hljs-string"><span class="hljs-string">"URL path to swagger document"</span></span>) .required() }).required(); }</code> </pre><br></div></div><br>  Die Möglichkeiten einer solchen Beschreibung des Schemas in Joi sind sehr umfangreich und werden hier ausführlicher beschrieben: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.npmjs.com/package/joi-to-swagger</a> <br><br>  Und hier ist der Vorfahr der beschriebenen Klasse (tatsächlich ist dies die Basisklasse für alle Antworten unseres Dienstes): <br><br><div class="spoiler">  <b class="spoiler_title">baseAPI.response.schema</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Joi <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"joi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { definition } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-joi-swagger-ts"</span></span>; @definition(<span class="hljs-string"><span class="hljs-string">"BaseAPIResponse"</span></span>, <span class="hljs-string"><span class="hljs-string">"Base response entity with base fields"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseAPIResponseSchema</span></span></span><span class="hljs-class"> </span></span>{ public code = Joi.number() .required() .strict() .only(<span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>) .example(<span class="hljs-number"><span class="hljs-number">200</span></span>) .description(<span class="hljs-string"><span class="hljs-string">"Code of operation result"</span></span>); public message = Joi.string().description(<span class="hljs-string"><span class="hljs-string">"message will be filled in some causes"</span></span>); }</code> </pre><br></div></div><br>  Registrieren Sie nun diese Schaltkreise und Steuerungen im Koa-Joi-Swagger-TS-System. <br>  Erstellen <b>Sie</b> neben index.ts eine weitere <b>routing.ts-</b> Datei: <br><br><div class="spoiler">  <b class="spoiler_title">routing.ts</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { KJSRouter } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-joi-swagger-ts"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BaseController } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./controllers/base.controller"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BaseAPIResponseSchema } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./controllers/schemas/baseAPI.response.schema"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ApiInfoResponseSchema } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./controllers/schemas/apiInfo.response.schema"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SERVER_PORT = <span class="hljs-number"><span class="hljs-number">3002</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loadRoutes = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KJSRouter({ <span class="hljs-attr"><span class="hljs-attr">swagger</span></span>: <span class="hljs-string"><span class="hljs-string">"2.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">info</span></span>: { <span class="hljs-attr"><span class="hljs-attr">version</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">"simple-rest"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">host</span></span>: <span class="hljs-string"><span class="hljs-string">`localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${SERVER_PORT}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">basePath</span></span>: <span class="hljs-string"><span class="hljs-string">"/api/v1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">schemes</span></span>: [<span class="hljs-string"><span class="hljs-string">"http"</span></span>], <span class="hljs-attr"><span class="hljs-attr">paths</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">definitions</span></span>: {} }); router.loadDefinition(ApiInfoResponseSchema); router.loadDefinition(BaseAPIResponseSchema); router.loadController(BaseController); router.setSwaggerFile(<span class="hljs-string"><span class="hljs-string">"swagger.json"</span></span>); router.loadSwaggerUI(<span class="hljs-string"><span class="hljs-string">"/api/docs"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> router.getRouter(); };</code> </pre><br></div></div><br>  Hier erstellen wir eine Instanz der KJSRouter-Klasse, bei der es sich im Wesentlichen um einen Koa-Router handelt, wobei jedoch Middleware und Handler hinzugefügt wurden. <br><br>  Daher ändern <b>wir</b> in der Datei <b>index.ts</b> einfach <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router();</code> </pre> <br>  auf <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = loadRoutes();</code> </pre> <br>  Löschen Sie den unnötigen Handler: <br><br><div class="spoiler">  <b class="spoiler_title">index.ts</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Koa <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> bodyParser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-bodyparser"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { loadRoutes } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./routing"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SERVER_PORT = <span class="hljs-number"><span class="hljs-number">3002</span></span>; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Koa(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = loadRoutes(); app.use(bodyParser()); app .use(router.routes()) .use(router.allowedMethods()); app.listen(SERVER_PORT); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Server listening on http://localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${SERVER_PORT}</span></span></span><span class="hljs-string"> ...`</span></span>); })();</code> </pre><br></div></div><br>  Wenn Sie diesen Dienst starten, stehen uns 3 Routen zur Verfügung: <br>  <b>1. / api / v1</b> - dokumentierte Route <br>  Was in meinem Fall gezeigt wird: <br><br><div class="spoiler">  <b class="spoiler_title">http: // localhost: 3002 / api / v1</b> <div class="spoiler_text"><pre> <code class="json hljs">{ code: <span class="hljs-number"><span class="hljs-number">200</span></span>, data: { appVersion: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, build: <span class="hljs-string"><span class="hljs-string">"1001"</span></span>, apiVersion: <span class="hljs-number"><span class="hljs-number">1</span></span>, reqHeaders: { host: <span class="hljs-string"><span class="hljs-string">"localhost:3002"</span></span>, connection: <span class="hljs-string"><span class="hljs-string">"keep-alive"</span></span>, cache-control: <span class="hljs-string"><span class="hljs-string">"max-age=0"</span></span>, upgrade-insecure-requests: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, user-agent: <span class="hljs-string"><span class="hljs-string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36"</span></span>, accept: <span class="hljs-string"><span class="hljs-string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3"</span></span>, accept-encoding: <span class="hljs-string"><span class="hljs-string">"gzip, deflate, br"</span></span>, accept-language: <span class="hljs-string"><span class="hljs-string">"uk-UA,uk;q=0.9,ru;q=0.8,en-US;q=0.7,en;q=0.6"</span></span> }, apiDoc: <span class="hljs-string"><span class="hljs-string">"/api/v1/swagger.json"</span></span> } }</code> </pre><br></div></div><br>  Und zwei Servicerouten: <br><br>  <b>2. /api/v1/swagger.json</b> <br><br><div class="spoiler">  <b class="spoiler_title">swagger.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ swagger: <span class="hljs-string"><span class="hljs-string">"2.0"</span></span>, info: { version: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, title: <span class="hljs-string"><span class="hljs-string">"simple-rest"</span></span> }, host: <span class="hljs-string"><span class="hljs-string">"localhost:3002"</span></span>, basePath: <span class="hljs-string"><span class="hljs-string">"/api/v1"</span></span>, schemes: [ <span class="hljs-string"><span class="hljs-string">"http"</span></span> ], paths: { /: { get: { tags: [ <span class="hljs-string"><span class="hljs-string">"GET"</span></span> ], summary: <span class="hljs-string"><span class="hljs-string">"Show API index page"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Returns text info about version of API"</span></span>, consumes: [ <span class="hljs-string"><span class="hljs-string">"application/json"</span></span> ], produces: [ <span class="hljs-string"><span class="hljs-string">"application/json"</span></span> ], responses: { 200: { description: <span class="hljs-string"><span class="hljs-string">"Information data about current application and API version"</span></span>, schema: { type: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/ApiInfo"</span></span> } } }, security: [ ] } } }, definitions: { BaseAPIResponse: { type: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, required: [ <span class="hljs-string"><span class="hljs-string">"code"</span></span> ], properties: { code: { type: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, format: <span class="hljs-string"><span class="hljs-string">"float"</span></span>, enum: [ <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span> ], description: <span class="hljs-string"><span class="hljs-string">"Code of operation result"</span></span>, example: { value: <span class="hljs-number"><span class="hljs-number">200</span></span> } }, message: { type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"message will be filled in some causes"</span></span> } } }, ApiInfo: { type: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, required: [ <span class="hljs-string"><span class="hljs-string">"code"</span></span>, <span class="hljs-string"><span class="hljs-string">"data"</span></span> ], properties: { code: { type: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, format: <span class="hljs-string"><span class="hljs-string">"float"</span></span>, enum: [ <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span> ], description: <span class="hljs-string"><span class="hljs-string">"Code of operation result"</span></span>, example: { value: <span class="hljs-number"><span class="hljs-number">200</span></span> } }, message: { type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"message will be filled in some causes"</span></span> }, data: { type: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, required: [ <span class="hljs-string"><span class="hljs-string">"appVersion"</span></span>, <span class="hljs-string"><span class="hljs-string">"apiVersion"</span></span>, <span class="hljs-string"><span class="hljs-string">"apiDoc"</span></span> ], properties: { appVersion: { type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Current version of application"</span></span> }, build: { type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Current build version of application"</span></span> }, apiVersion: { type: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, format: <span class="hljs-string"><span class="hljs-string">"float"</span></span>, minimum: <span class="hljs-number"><span class="hljs-number">1</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Version of current REST api"</span></span> }, reqHeaders: { type: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, properties: { }, description: <span class="hljs-string"><span class="hljs-string">"Request headers"</span></span> }, apiDoc: { type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"URL path to swagger document"</span></span> } } } } } } }</code> </pre><br></div></div><br>  <b>3. / api / docs</b> <br><br>  Diese Seite mit der Swagger-Benutzeroberfläche ist eine sehr praktische visuelle Darstellung des Swagger-Schemas, in der Sie nicht nur bequem sehen, sondern auch Anfragen generieren und echte Antworten vom Server erhalten können. <br><br><img src="https://habrastorage.org/webt/go/zc/fg/gozcfgxxsvy_qu_us6jbpgutxdo.png"><br><br>  Diese Benutzeroberfläche erfordert Zugriff auf die Datei swagger.json, weshalb die vorherige Route enthalten war. <br><br>  Nun, alles scheint da zu sein und alles funktioniert, aber! .. <br><br>  Im Laufe der Zeit haben wir festgestellt, dass in einer solchen Implementierung viele Codes dupliziert werden.  In dem Fall, in dem die Steuerungen dasselbe tun müssen.  Aus diesem Grund habe ich das Paket später fertiggestellt und die Möglichkeit hinzugefügt, den „Wrapper“ für die Controller zu beschreiben. <br><br>  Betrachten Sie ein Beispiel für einen solchen Dienst. <br><br>  Angenommen, wir haben einen "Benutzer" -Controller mit mehreren Methoden. <br><br><div class="spoiler">  <b class="spoiler_title">Holen Sie sich alle Benutzer</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> @get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: UsersResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">400</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">500</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Returns list of all users"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Get all users"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getAllUsers(ctx: BaseContext): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"GET /api/v1/users"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = <span class="hljs-string"><span class="hljs-string">"Get all users error"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> code = <span class="hljs-number"><span class="hljs-number">400</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getAllUsers(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult) { data = serviceResult; code = <span class="hljs-number"><span class="hljs-number">200</span></span>; message = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Error while getting users list"</span></span>); code = <span class="hljs-number"><span class="hljs-number">500</span></span>; } ctx.status = code; ctx.body = TransferObjectUtils.createResponseObject(code, message, data); };</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Benutzer aktualisieren</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> @post(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @parameter(<span class="hljs-string"><span class="hljs-string">"body"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: UsersRequestSchema }, ENUM_PARAM_IN.body) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">400</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">500</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Update user data"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Update user data"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> updateUser(ctx: BaseContext): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"POST /api/v1/users"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = <span class="hljs-string"><span class="hljs-string">"Update user data error"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> code = <span class="hljs-number"><span class="hljs-number">400</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> updateUser(ctx.request.body.data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult) { code = <span class="hljs-number"><span class="hljs-number">200</span></span>; message = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Error while updating user"</span></span>); code = <span class="hljs-number"><span class="hljs-number">500</span></span>; } ctx.status = code; ctx.body = TransferObjectUtils.createResponseObject(code, message, data); };</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Benutzer einfügen</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> @put(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @parameter(<span class="hljs-string"><span class="hljs-string">"body"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: UsersRequestSchema }, ENUM_PARAM_IN.body) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">400</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">500</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Insert new user"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Insert new user"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> insertUser(ctx: BaseContext): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"PUT /api/v1/users"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = <span class="hljs-string"><span class="hljs-string">"Insert new user error"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> code = <span class="hljs-number"><span class="hljs-number">400</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> insertUser(ctx.request.body.data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult) { code = <span class="hljs-number"><span class="hljs-number">200</span></span>; message = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Error while inserting user"</span></span>); code = <span class="hljs-number"><span class="hljs-number">500</span></span>; } ctx.status = code; ctx.body = TransferObjectUtils.createResponseObject(code, message, data); };</code> </pre><br></div></div><br>  Wie Sie sehen können, enthalten die drei Controller-Methoden doppelten Code.  In solchen Fällen nutzen wir jetzt diese Gelegenheit. <br><br>  Erstellen Sie zunächst eine Wrapper-Funktion, z. B. direkt in der Datei <b>routing.ts</b> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> controllerDecorator = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (controller: <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>, <span class="hljs-attr"><span class="hljs-attr">ctx</span></span>: BaseContext, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>, <span class="hljs-attr"><span class="hljs-attr">summary</span></span>: string): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ctx.request.method}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ctx.request.url}</span></span></span><span class="hljs-string">`</span></span>); ctx.body = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; ctx.status = <span class="hljs-number"><span class="hljs-number">400</span></span>; ctx.statusMessage = <span class="hljs-string"><span class="hljs-string">`Error while executing '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${summary}</span></span></span><span class="hljs-string">'`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> controller(ctx); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e, <span class="hljs-string"><span class="hljs-string">`Error while executing '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${summary}</span></span></span><span class="hljs-string">'`</span></span>); ctx.status = <span class="hljs-number"><span class="hljs-number">500</span></span>; } ctx.body = TransferObjectUtils.createResponseObject(ctx.status, ctx.statusMessage, ctx.body); };</code> </pre><br>  Schließen Sie es dann an unseren Controller an. <br><br>  Ersetzen <br><br><pre> <code class="javascript hljs">router.loadController(UserController);</code> </pre> <br>  auf <br><br><pre> <code class="javascript hljs">router.loadController(UserController, controllerDecorator);</code> </pre> <br>  Lassen Sie uns unsere Controller-Methoden vereinfachen <br><br><div class="spoiler">  <b class="spoiler_title">Benutzersteuerung</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> @get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: UsersResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">400</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">500</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Returns list of all users"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Get all users"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getAllUsers(ctx: BaseContext): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getAllUsers(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult) { ctx.body = serviceResult; ctx.status = <span class="hljs-number"><span class="hljs-number">200</span></span>; ctx.statusMessage = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }; @post(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @parameter(<span class="hljs-string"><span class="hljs-string">"body"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: UsersRequestSchema }, ENUM_PARAM_IN.body) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">400</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">500</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Update user data"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Update user data"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> updateUser(ctx: BaseContext): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> updateUser(ctx.request.body.data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult) { ctx.status = <span class="hljs-number"><span class="hljs-number">200</span></span>; ctx.statusMessage = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }; @put(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @parameter(<span class="hljs-string"><span class="hljs-string">"body"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: UsersRequestSchema }, ENUM_PARAM_IN.body) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">400</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">500</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Insert new user"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Insert new user"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> insertUser(ctx: BaseContext): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> insertUser(ctx.request.body.data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult) { ctx.status = <span class="hljs-number"><span class="hljs-number">200</span></span>; ctx.statusMessage = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } };</code> </pre><br></div></div><br>  In diesem <b>controllerDecorator können</b> Sie eine beliebige Logik von Überprüfungen oder detaillierte Protokolle von Ein- / Ausgängen hinzufügen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ich habe den fertigen Code hier gepostet</a> . <br><br>  Jetzt haben wir fast CRUD fertig.  Löschen kann analog geschrieben werden.  Um einen neuen Controller zu schreiben, müssen wir: <br><br><ol><li>  Controller-Datei erstellen </li><li>  Fügen Sie es zu routing.ts hinzu </li><li>  Beschreiben Sie Methoden </li><li>  Verwenden Sie bei jeder Methode Eingangs- / Ausgangsschaltungen </li><li>  Beschreiben Sie diese Schemata </li><li>  Verbinden Sie diese Schemata in routing.ts </li></ol><br>  Wenn das eingehende Paket nicht mit dem Schema übereinstimmt, erhält der Benutzer unseres REST-Dienstes einen 400-Fehler mit einer Beschreibung dessen, was genau falsch ist.  Wenn das ausgehende Paket ungültig ist, wird ein 500-Fehler generiert. <br><br>  Gut und still als angenehme Kleinigkeit.  In der Swagger-Benutzeroberfläche können Sie die Funktion " <b>Ausprobieren</b> " für jede Methode verwenden.  Eine Anfrage wird per Curl an Ihren laufenden Dienst generiert, und natürlich können Sie das Ergebnis sofort sehen.  Und gerade dafür ist es sehr praktisch, den Parameter „ <b>Beispiel</b> “ in der Schaltung zu beschreiben.  Weil die Anfrage sofort mit einem vorgefertigten Paket basierend auf den beschriebenen Beispielen generiert wird. <br><br><img src="https://habrastorage.org/webt/gk/iq/hi/gkiqhirxja87xqofboi5oo9af1w.png"><br><br><h4>  <b>Schlussfolgerungen</b> </h4><br>  Am Ende sehr praktisch und nützlich, stellte sich heraus.  Zuerst wollten sie ausgehende Pakete nicht validieren, aber dann haben sie mit Hilfe dieser Validierung mehrere signifikante Fehler auf ihrer Seite entdeckt.  Natürlich können Sie nicht alle Funktionen von Joi vollständig nutzen (da wir durch Joi-to-Swagger eingeschränkt sind), aber diejenigen, die völlig ausreichen. <br><br>  Jetzt ist die Dokumentation immer online und entspricht immer genau dem Code - und das ist die Hauptsache. <br>  Welche anderen Ideen gibt es? <br><br>  Ist es möglich, Express-Support hinzuzufügen? <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ich habe es gerade gelesen</a> . <br><br>  Es wäre wirklich cool, Entitäten einmal an einem Ort zu beschreiben.  Denn jetzt müssen sowohl Schaltkreise als auch Schnittstellen bearbeitet werden. <br><br>  Vielleicht haben Sie einige interessante Ideen.  Besser noch Pull Requests :) <br>  Willkommen bei den Mitwirkenden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449906/">https://habr.com/ru/post/de449906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449890/index.html">Wie sind die algorithmischen Abschnitte bei Interviews in Yandex?</a></li>
<li><a href="../de449896/index.html">Wie man Katzen weidet oder Ratschläge an einen jungen Programmierer</a></li>
<li><a href="../de449898/index.html">Inside-Out-News</a></li>
<li><a href="../de449902/index.html">Kabelfernsehnetze für die Kleinsten. Teil 2: Zusammensetzung und Wellenform</a></li>
<li><a href="../de449904/index.html">Erstellen einer Proxy-DLL für die Überprüfung von Hijack-DLL-Vorgängen</a></li>
<li><a href="../de449908/index.html">DDR3 oder DDR4? Warum haben wir Dell R420 2x E5-2430 2,2 GHz 6C 128 GB DDR3 2x960 GB SSD 1 Gbit / s für 99 US-Dollar in den Niederlanden angeboten?</a></li>
<li><a href="../de449910/index.html">GitLab Shell Runner. Wettbewerbsfähiger Start von Testdiensten mit Docker Compose</a></li>
<li><a href="../de449916/index.html">5 Möglichkeiten, PHP-Code unter Hochlastbedingungen bereitzustellen</a></li>
<li><a href="../de449918/index.html">Infrarot-Thermometer mit Sensor MLX90614</a></li>
<li><a href="../de449920/index.html">10 nicht standardmäßige Möglichkeiten, um SEO beim Ändern des CMS zu verletzen (+1 Bonus)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>