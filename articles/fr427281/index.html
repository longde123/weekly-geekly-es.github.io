<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😘 🔹 🐌 Développement de classes d'interface en C ++ 🦎 🐐 🙏🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les classes d'interface sont très largement utilisées dans les programmes C ++. Mais, malheureusement, des erreurs sont souvent commises lors de l'imp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Développement de classes d'interface en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427281/"><hr><p>  <i>Les classes d'interface sont très largement utilisées dans les programmes C ++.</i>  <i>Mais, malheureusement, des erreurs sont souvent commises lors de l'implémentation de solutions basées sur des classes d'interface.</i>  <i>L'article décrit comment concevoir correctement les classes d'interface; plusieurs options sont envisagées.</i>  <i>L'utilisation de pointeurs intelligents est décrite en détail.</i>  <i>Un exemple d'implémentation d'une classe d'exception et d'un modèle de classe de collection basé sur des classes d'interface est donné.</i> </p><hr><br><a name="habracut"></a><br><h1>  Table des matières </h1><br><div class="spoiler">  <b class="spoiler_title">Table des matières</b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Présentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1. Fonctions membres spéciales, création et suppression d'objets</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctions spéciales des membres</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Création et suppression d'objets - détails de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Niveau d'accès destructeur</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Créez et supprimez en un seul module</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Suppression polymorphe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Suppression lorsque la déclaration de classe est incomplète</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2. Fonctions purement virtuelles et classes abstraites</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctions virtuelles pures</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classes abstraites</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Destructeur virtuel pur</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3. Classes d'interface</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Implémentations</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Création d'objets</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Supprimer un objet</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation de l'opérateur de suppression</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation d'une fonction virtuelle spéciale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.3.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation d'une fonction externe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.3.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Suppression automatique à l'aide du pointeur intelligent</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Autres options pour gérer la durée de vie d'une instance d'une classe d'implémentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Copier la sémantique</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Constructeur de classe d'interface</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interaction bidirectionnelle</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pointeurs intelligents</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctions membres constantes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interfaces COM</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classes d'interface et bibliothèques</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4. Un exemple de classe d'interface et son implémentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classe d'interface</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classe d'implémentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pointeurs intelligents standard</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Création côté client</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Création côté implémentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Implémentation alternative de la classe de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5. Exceptions et collections implémentées à l'aide de classes d'interface</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5.1 Exceptions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5.2 Collections</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6. Classes d'interface et classes wrapper</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7. Résumé</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les références</a> <br></div></div><br><a name="id-introdaction"></a><br><h1>  Présentation </h1><br><p>  Une classe d'interface est une classe qui n'a pas de données et se compose principalement de fonctions purement virtuelles.  Cette solution vous permet de séparer complètement l'implémentation de l'interface - le client utilise la classe d'interface - à un autre endroit, une classe dérivée est créée dans laquelle les fonctions purement virtuelles sont redéfinies et la fonction d'usine est définie.  Les détails de l'implémentation sont complètement cachés au client.  De cette façon, une véritable encapsulation est implémentée, ce qui est impossible avec la classe habituelle.  Vous pouvez lire sur les classes d'interface de Scott Meyers [Meyers2].  Les classes d'interface sont également appelées classes de protocole. </p><br><p>  L'utilisation de classes d'interface vous permet d'affaiblir les dépendances entre les différentes parties du projet, ce qui simplifie le développement de l'équipe et réduit le temps de compilation / assemblage.  Les classes d'interface facilitent la mise en œuvre de solutions flexibles et dynamiques lorsque les modules sont chargés de manière sélective lors de l'exécution.  L'utilisation des classes d'interface en tant que bibliothèque d'interface (API) (SDK) simplifie la solution des problèmes de compatibilité binaire. </p><br><p>  Les classes d'interface sont utilisées assez largement, avec leur aide, elles implémentent l'interface (API) des bibliothèques (SDK), l'interface des plug-ins (plugins) et bien plus encore.  De nombreux modèles de Gang of Four [GoF] sont naturellement implémentés à l'aide de classes d'interface.  Les classes d'interface incluent les interfaces COM.  Mais, malheureusement, des erreurs sont souvent commises lors de l'implémentation de solutions basées sur des classes d'interface.  Essayons de clarifier ce problème. </p><br><a name="id-1"></a><br><h1>  1. Fonctions membres spéciales, création et suppression d'objets </h1><br><p>  Cette section décrit brièvement un certain nombre de fonctionnalités C ++ que vous devez connaître pour bien comprendre les solutions proposées pour les classes d'interface. </p><br><a name="id-1-1"></a><br><h2>  1.1.  Fonctions spéciales des membres </h2><br><p>  Si le programmeur n'a pas défini les fonctions membres de la classe dans la liste suivante - le constructeur par défaut, le constructeur de copie, l'opérateur d'affectation de copie, le destructeur - alors le compilateur peut le faire pour lui.  C ++ 11 a ajouté un constructeur de déplacement et un opérateur d'affectation de déplacement à cette liste.  Ces fonctions membres sont appelées fonctions membres spéciales.  Ils ne sont générés que s'ils sont utilisés et des conditions supplémentaires spécifiques à chaque fonction sont remplies.  Nous attirons l'attention sur le fait que cette utilisation peut s'avérer assez cachée (par exemple lors de l'implémentation de l'héritage).  Si la fonction requise ne peut pas être générée, une erreur est générée.  (À l'exception des opérations de relocalisation, elles sont remplacées par des opérations de copie.) Les fonctions membres générées par le compilateur sont publiques et intégrables. </p><br><p>  Les fonctions membres spéciales ne sont pas héritées, si une fonction membre spéciale est requise dans la classe dérivée, le compilateur essaiera toujours de la générer; la présence de la fonction membre correspondante définie dans la classe de base par le programmeur n'affecte pas cela. </p><br><p> Le programmeur peut interdire la génération de fonctions membres spéciales, en C ++ 11 il est nécessaire d'utiliser la construction <code>"=delete"</code> lors de la déclaration, en C ++ 98 déclarer la fonction membre correspondante privée et non définir.  Dans l'héritage de classe, l'interdiction de générer une fonction membre spéciale faite dans la classe de base s'applique à toutes les classes dérivées. </p><br><p>  Si le programmeur est à l'aise avec les fonctions membres générées par le compilateur, alors en C ++ 11, il peut l'indiquer explicitement, et pas simplement supprimer la déclaration.  Pour ce faire, vous devez utiliser la construction <code>"=default"</code> lors de la déclaration, tandis que le code est mieux lu et que des fonctionnalités supplémentaires apparaissent liées à la gestion du niveau d'accès. </p><br><p>  Des détails sur les fonctions spéciales des membres peuvent être trouvés dans [Meyers3]. </p><br><a name="id-1-2"></a><br><h2>  1.2.  Création et suppression d'objets - détails de base </h2><br><p>  La création et la suppression d'objets à l'aide des opérateurs <code>new/delete</code> est une opération deux-en-un typique.  Lors de l'appel de <code>new</code> , la mémoire est d'abord allouée à l'objet.  Si la sélection réussit, le constructeur est appelé.  Si le constructeur lève une exception, la mémoire allouée est libérée.  Lorsque l'opérateur de <code>delete</code> est appelé, tout se passe dans l'ordre inverse: d'abord, le destructeur est appelé, puis la mémoire est libérée.  Le destructeur ne doit pas lever d'exceptions. </p><br><p>  Si le <code>new</code> opérateur est utilisé pour créer un tableau d'objets, la mémoire est d'abord allouée à l'ensemble du tableau.  Si la sélection réussit, le constructeur par défaut est appelé pour chaque élément du tableau à partir de zéro.  Si un constructeur lève une exception, alors pour tous les éléments créés du tableau, le destructeur est appelé dans l'ordre inverse de l'appel du constructeur, la mémoire allouée est libérée.  Pour supprimer un tableau, vous devez appeler l'opérateur <code>delete[]</code> (appelé l'opérateur <code>delete</code> pour les tableaux), et pour tous les éléments du tableau, le destructeur est appelé dans l'ordre inverse de l'appel du constructeur, puis la mémoire allouée est libérée. </p><br><p>  Attention!  Vous devez appeler la forme correcte de l'opérateur de <code>delete</code> , selon qu'un seul objet ou tableau est supprimé.  Cette règle doit être strictement respectée, sinon vous pouvez obtenir un comportement indéfini, c'est-à-dire que tout peut arriver: fuites de mémoire, crash, etc.  Voir [Meyers2] pour plus de détails. </p><br><p>  Les fonctions d'allocation de mémoire standard ne <code>std::bad_alloc</code> à satisfaire la requête, <code>std::bad_alloc</code> une exception de type <code>std::bad_alloc</code> . </p><br><p>  Il est sûr d'appliquer n'importe quelle forme de l'opérateur de <code>delete</code> à un pointeur nul. </p><br><p>  Dans la description ci-dessus, une clarification est nécessaire.  Pour les soi-disant types triviaux (types intégrés, structures de style C), le constructeur ne peut pas être appelé et le destructeur ne fait en aucun cas quoi que ce soit.  Voir également la section 1.6. </p><br><a name="id-1-3"></a><br><h2>  1.3.  Niveau d'accès destructeur </h2><br><p>  Lorsque l'opérateur de <code>delete</code> est appliqué à un pointeur sur une classe, le destructeur de cette classe doit être disponible au point d'appel de <code>delete</code> .  (Il existe une exception à cette règle, abordée dans la section 1.6.) Ainsi, en sécurisant ou en fermant le destructeur, le programmeur interdit l'utilisation de l'opérateur de <code>delete</code> lorsque le destructeur n'est pas disponible.  Souvenez-vous que si aucun destructeur n'est défini dans la classe, le compilateur le fera seul et ce destructeur sera ouvert (voir section 1.1). </p><br><a name="id-1-4"></a><br><h2>  1.4.  Créez et supprimez en un seul module </h2><br><p>  Si le <code>new</code> opérateur a créé un objet, alors l'opérateur de <code>delete</code> doit se trouver dans le même module pour le <code>delete</code> .  Au figuré, "mettez-le là où vous l'avez pris".  Cette règle est bien connue, voir par exemple [Sutter / Alexandrescu].  Si cette règle est violée, une «non-concordance» des fonctions d'allocation et de libération de mémoire peut se produire, ce qui, en règle générale, entraîne une interruption anormale du programme. </p><br><a name="id-1-5"></a><br><h2>  1.5.  Suppression polymorphe </h2><br><p>  Si vous concevez une hiérarchie polymorphe de classes dont les instances sont supprimées à l'aide de l'opérateur de <code>delete</code> , il doit y avoir un destructeur virtuel ouvert dans la classe de base, cela garantit que le destructeur du type réel de l'objet est appelé lorsque l'opérateur de <code>delete</code> est appliqué au pointeur sur la classe de base.  Si cette règle est violée, un appel au destructeur de classe de base peut se produire, ce qui peut entraîner une fuite de ressources. </p><br><a name="id-1-6"></a><br><h2>  1.6.  Suppression lorsque la déclaration de classe est incomplète </h2><br><p>  Le caractère omnivore de l'opérateur de <code>delete</code> peut créer certains problèmes; il peut être appliqué à un pointeur de type <code>void*</code> ou à un pointeur sur une classe qui a une déclaration incomplète (préemptive).  Dans ce cas, aucune erreur ne se produit, seul l'appel au destructeur est ignoré, seule la fonction de libération de la mémoire est appelée.  Prenons un exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   X* CreateX(); void Foo() {    X* p = CreateX();    delete p; }</span></span></code> </pre> <br><p>  Ce code se compile même si une déclaration de classe <code>X</code> complète n'est pas disponible sur le pair de <code>delete</code> numérotation.  Vrai, lors de la compilation (Visual Studio), un avertissement est émis: </p><br><p> <code>warning C4150: deletion of pointer to incomplete type 'X'; no destructor called</code> </p> <br><p>  S'il existe une implémentation de <code>X</code> et <code>CreateX()</code> , le code est <code>CreateX()</code> , si <code>CreateX()</code> renvoie un pointeur vers l'objet créé par le <code>new</code> opérateur, alors l'appel <code>Foo()</code> correctement exécuté, le destructeur n'est pas appelé.  Il est clair que cela peut conduire à un épuisement des ressources, donc encore une fois sur la nécessité de faire attention aux avertissements. </p><br><p>  Cette situation n'est pas farfelue, elle peut facilement survenir lors de l'utilisation de classes telles que des pointeurs intelligents ou des classes de descripteurs.  Scott Meyers traite de ce problème dans [Meyers3]. </p><br><a name="id-2"></a><br><h1>  2. Fonctions purement virtuelles et classes abstraites </h1><br><p>  Le concept de classes d'interface est basé sur des concepts C ++ tels que les fonctions virtuelles pures et les classes abstraites. </p><br><a name="id-2-1"></a><br><h2>  2.1.  Fonctions virtuelles pures </h2><br><p>  Une fonction virtuelle déclarée à l'aide de la construction <code>"=0"</code> est appelée virtuelle pure. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...    virtual void Foo() = 0; };</span></span></code> </pre> <br><p>  Contrairement à une fonction virtuelle classique, une fonction purement virtuelle ne peut pas être définie (à l'exception du destructeur, voir section 2.3), mais elle doit être redéfinie dans l'une des classes dérivées. </p><br><p>  Des fonctions purement virtuelles peuvent être définies.  Emblem Sutter propose plusieurs utilisations utiles pour cette fonction [Shutter]. </p><br><a name="id-2-2"></a><br><h2>  2.2.  Classes abstraites </h2><br><p>  Une classe abstraite est une classe qui a au moins une fonction purement virtuelle.  Une classe dérivée d'une classe abstraite et ne remplaçant pas au moins une fonction purement virtuelle sera également abstraite.  La norme C ++ interdit la création d'instances d'une classe abstraite; vous ne pouvez créer que des instances de dérivés de classes non abstraites.  Ainsi, une classe abstraite est créée pour être utilisée comme classe de base.  Par conséquent, si un constructeur est défini dans une classe abstraite, alors cela n'a pas de sens de le rendre ouvert, il doit être protégé. </p><br><a name="id-2-3"></a><br><h2>  2.3.  Destructeur virtuel pur </h2><br><p>  Dans certains cas, il est conseillé de faire un destructeur virtuel pur.  Mais cette solution a deux fonctionnalités. </p><br><ol><li>  Un destructeur purement virtuel doit être défini.  (La définition par défaut est généralement utilisée, c'est-à-dire en utilisant la construction <code>"=default"</code> .) Le destructeur de classe dérivé appelle des destructeurs de classe de base tout au long de la chaîne d'héritage et, par conséquent, la file d'attente est garantie d'atteindre la racine - un destructeur purement virtuel. </li><li>  Si le programmeur n'a pas redéfini un destructeur virtuel pur dans la classe dérivée, le compilateur le fera pour lui (voir section 1.1).  Ainsi, une classe dérivée d'une classe abstraite avec un destructeur purement virtuel peut perdre son caractère abstrait sans écraser explicitement le destructeur. </li></ol><br><p>  Un exemple d'utilisation d'un destructeur virtuel pur peut être trouvé dans la section 4.4. </p><br><a name="id-3"></a><br><h1>  3. Classes d'interface </h1><br><p>  Une classe d'interface est une classe abstraite qui n'a pas de données et se compose principalement de fonctions purement virtuelles.  Une telle classe peut avoir des fonctions virtuelles ordinaires (non purement virtuelles), par exemple, un destructeur.  Il peut également y avoir des fonctions membres statiques, telles que des fonctions d'usine. </p><br><a name="id-3-1"></a><br><h2>  3.1.  Implémentations </h2><br><p>  Une implémentation d'une classe d'interface sera appelée une classe dérivée dans laquelle des fonctions purement virtuelles sont redéfinies.  Il peut y avoir plusieurs implémentations de la même classe d'interface, et deux schémas sont possibles: horizontal, lorsque plusieurs classes différentes héritent de la même classe d'interface, et vertical, lorsque la classe d'interface est la racine de la hiérarchie polymorphe.  Bien sûr, il peut y avoir des hybrides. </p><br><p>  Le point clé du concept de classes d'interface est la séparation complète de l'interface de l'implémentation - le client ne travaille qu'avec la classe d'interface, l'implémentation n'est pas disponible pour elle. </p><br><a name="id-3-2"></a><br><h2>  3.2.  Création d'objets </h2><br><p>  L'inaccessibilité de la classe d'implémentation provoque certains problèmes lors de la création d'objets.  Le client doit créer une instance de la classe d'implémentation et obtenir un pointeur sur la classe d'interface via laquelle l'objet sera accessible.  Étant donné que la classe d'implémentation n'est pas disponible, vous ne pouvez pas utiliser le constructeur, par conséquent, la fonction d'usine est utilisée, qui est définie du côté de l'implémentation.  Cette fonction crée généralement un objet à l'aide du <code>new</code> opérateur et renvoie un pointeur sur l'objet créé, transtypé en pointeur sur une classe d'interface.  Une fonction de fabrique peut être un membre statique d'une classe d'interface, mais elle n'est pas nécessaire, par exemple, elle peut être membre d'une classe de fabrique spéciale (qui, à son tour, peut elle-même être une classe d'interface) ou une fonction libre.  Une fonction d'usine peut renvoyer non pas un pointeur brut vers une classe d'interface, mais un pointeur intelligent.  Cette option est discutée dans les sections 3.3.4 et 4.3.2. </p><br><a name="id-3-3"></a><br><h2>  3.3.  Supprimer un objet </h2><br><p>  La suppression d'un objet est une opération extrêmement critique.  Une erreur entraîne une fuite de mémoire ou une double suppression, ce qui entraîne généralement un plantage du programme.  Ci-dessous, ce problème est considéré aussi détaillé que possible, avec une grande attention portée à la prévention des actions erronées des clients. </p><br><p>  Il existe quatre options principales: </p><br><ol><li>  Utilisation de l'opérateur de <code>delete</code> . </li><li>  Utilisation d'une fonction virtuelle spéciale. </li><li>  Utilisation d'une fonction externe. </li><li>  Suppression automatique à l'aide du pointeur intelligent. </li></ol><br><a name="id-3-3-1"></a><br><h3>  3.3.1.  Utilisation de l'opérateur de <code>delete</code> <br></h3><br><p>  Pour ce faire, vous devez avoir un destructeur virtuel ouvert dans la classe d'interface.  Dans ce cas, l'opérateur de <code>delete</code> , appelé pour un pointeur vers une classe d'interface côté client, fournit un appel au destructeur de la classe d'implémentation.  Cette option peut fonctionner, mais il est difficile de la reconnaître comme réussie.  Nous recevons des appels des <code>new</code> opérateurs et <code>delete</code> différents côtés de la «barrière», <code>new</code> du côté de l'implémentation, <code>delete</code> du côté client.  Et si l'implémentation de la classe d'interface se fait dans un module séparé (ce qui est assez courant), alors nous obtenons une violation de la règle de la section 1.4. </p><br><a name="id-3-3-2"></a><br><h3>  3.3.2.  Utilisation d'une fonction virtuelle spéciale </h3><br><p>  Plus progressive est une autre option: la classe d'interface doit avoir une fonction virtuelle spéciale qui supprime l'objet.  Une telle fonction, au final, revient à appeler <code>delete this</code> , mais cela se produit déjà du côté de l'implémentation.  Une telle fonction peut être appelée de différentes manières, par exemple, <code>Delete()</code> , mais d'autres options sont également utilisées: <code>Release()</code> , <code>Destroy()</code> , <code>Dispose()</code> , <code>Free()</code> , <code>Close()</code> , etc.  En plus de suivre la règle de la section 1.4, cette option présente plusieurs avantages supplémentaires. </p><br><ol><li>  Vous permet d'utiliser des fonctions personnalisées d'allocation / désallocation de mémoire pour la classe d'implémentation. </li><li>  Vous permet d'implémenter un schéma plus complexe pour contrôler la durée de vie de l'objet d'implémentation, par exemple, à l'aide d'un compteur de référence. </li></ol><br><p>  Dans ce mode de réalisation, une tentative de suppression d'un objet à l'aide de l'opérateur de <code>delete</code> peut être compilée et même effectuée, mais il s'agit d'une erreur.  Pour l'empêcher dans la classe d'interface, il suffit d'avoir un destructeur protégé vide ou purement virtuel (voir section 1.3).  Notez que l'utilisation de l'opérateur de <code>delete</code> peut être assez masquée, par exemple, les pointeurs intelligents standard utilisent l'opérateur de suppression pour supprimer un objet par défaut et le code correspondant est profondément enfoui dans leur implémentation.  Un destructeur protégé vous permet de détecter toutes ces tentatives au stade de la compilation. </p><br><a name="id-3-3-3"></a><br><h3>  3.3.3.  Utilisation d'une fonction externe </h3><br><p>  Cette option peut attirer une certaine symétrie des procédures de création et de suppression d'un objet, mais en réalité elle n'a aucun avantage par rapport à la version précédente, mais il existe de nombreux problèmes supplémentaires.  Cette option n'est pas recommandée pour une utilisation et n'est pas envisagée à l'avenir. </p><br><a name="id-3-3-4"></a><br><h3>  3.3.4.  Suppression automatique à l'aide du pointeur intelligent </h3><br><p>  Dans ce cas, la fonction d'usine ne renvoie pas un pointeur brut vers une classe d'interface, mais un pointeur intelligent correspondant.  Ce pointeur intelligent est créé côté implémentation et encapsule l'objet de suppression, qui supprime automatiquement l'objet implémentation lorsque le pointeur intelligent (ou sa dernière copie) sort du domaine côté client.  Dans ce cas, une fonction virtuelle spéciale pour supprimer l'objet d'implémentation peut ne pas être requise, mais un destructeur protégé est toujours nécessaire, il est nécessaire d'empêcher l'utilisation erronée de l'opérateur de <code>delete</code> .  (Certes, il convient de noter que la probabilité d'une telle erreur est sensiblement réduite.) Cette option est examinée plus en détail à la section 4.3.2. </p><br><a name="id-3-4"></a><br><h2>  3.4.  Autres options pour gérer la durée de vie d'une instance d'une classe d'implémentation </h2><br><p>  Dans certains cas, le client peut recevoir un pointeur vers la classe d'interface, mais ne le possède pas.  La gestion de la durée de vie de l'objet d'implémentation est entièrement du côté de l'implémentation.  Par exemple, un objet peut être un objet singleton statique (cette solution est typique pour les usines).  Un autre exemple est lié à l'interaction bidirectionnelle, voir la section 3.7.  Le client ne doit pas supprimer un tel objet, mais un destructeur protégé pour une telle classe d'interface est nécessaire, il est nécessaire d'empêcher l'utilisation erronée de l'opérateur de <code>delete</code> . </p><br><a name="id-3-5"></a><br><h2>  3.5.  Copier la sémantique </h2><br><p>  Pour une classe d'interface, la création d'une copie de l'objet d'implémentation à l'aide du constructeur de copie n'est pas possible, donc si la copie est requise, la classe doit avoir une fonction virtuelle qui crée une copie de l'objet d'implémentation et renvoie un pointeur vers la classe d'interface.  Une telle fonction est souvent appelée constructeur virtuel et son nom traditionnel est <code>Clone()</code> ou <code>Duplicate()</code> . </p><br><p>  L'utilisation de l'opérateur d'affectation de copie n'est pas interdite, mais ne peut pas être considérée comme une bonne idée.  L'opérateur d'affectation de copie est toujours associé; il doit être associé au constructeur de copie.  L'opérateur généré par le compilateur par défaut n'a pas de sens, il ne fait rien.  Il est théoriquement possible de déclarer un opérateur d'affectation purement virtuel avec redéfinition ultérieure, mais l'affectation virtuelle n'est pas une pratique recommandée, des détails peuvent être trouvés dans [Meyers1].  De plus, l'affectation semble très peu naturelle: l'accès aux objets de la classe d'implémentation se fait généralement via un pointeur vers la classe d'interface, donc l'affectation ressemblera à ceci: </p><br><pre> <code class="cpp hljs">* = *;</code> </pre> <br><p>  Il est préférable d'interdire à l'opérateur d'affectation, et si nécessaire, une telle sémantique a dans la classe d'interface la fonction virtuelle correspondante. </p><br><p>  Il existe deux façons d'interdire l'attribution. </p><br><ol><li>  Déclarez l'opérateur d'affectation supprimé ( <code>=delete</code> ).  Si les classes d'interface forment une hiérarchie, cela suffit pour le faire dans la classe de base.  L'inconvénient de cette méthode est qu'elle affecte la classe d'implémentation, l'interdiction s'y applique également. </li><li>  Déclarez une instruction d'affectation protégée avec une définition par défaut ( <code>=default</code> ).  Cela n'affecte pas la classe d'implémentation, mais dans le cas d'une hiérarchie de classes d'interface, une telle annonce doit être faite dans chaque classe. </li></ol><br><a name="id-3-6"></a><br><h2>  3.6.  Constructeur de classe d'interface </h2><br><p>  Souvent, le constructeur d'une classe d'interface n'est pas déclaré.  Dans ce cas, le compilateur génère le constructeur par défaut nécessaire pour implémenter l'héritage (voir section 1.1).  Ce constructeur est ouvert, bien que suffisant pour être sécurisé.  Si dans la classe d'interface le constructeur copiant est déclaré supprimé ( <code>=delete</code> ), alors la génération par le compilateur du constructeur est supprimée par défaut, et un tel constructeur doit être explicitement déclaré.  Il est naturel de le sécuriser avec une définition par défaut ( <code>=default</code> ).  En principe, la déclaration d'un tel constructeur protégé peut toujours se faire.  Un exemple est dans la section 4.4. </p><br><a name="id-3-7"></a><br><h2>  3.7.  Interaction bidirectionnelle </h2><br><p>  Les classes d'interface sont pratiques pour utiliser la communication bidirectionnelle.  Si certains modules sont accessibles via des classes d'interface, le client peut également créer des implémentations de certaines classes d'interface et leur transmettre des pointeurs dans le module.  Grâce à ces pointeurs, le module peut recevoir des services du client et également transmettre des données ou des notifications au client. </p><br><a name="id-3-8"></a><br><h2>  3.8.  Pointeurs intelligents </h2><br><p>  Étant donné que l'accès aux objets de la classe d'implémentation se fait généralement via un pointeur, il est naturel d'utiliser des pointeurs intelligents pour contrôler leur durée de vie.  Mais il faut garder à l'esprit que si la deuxième option pour supprimer des objets est utilisée, alors avec le pointeur intelligent standard, il est nécessaire de transférer un suppresseur utilisateur (type) ou une instance de ce type.  Si cela n'est pas fait, le pointeur intelligent utilisera l'opérateur de suppression pour supprimer l'objet, et le code ne sera tout simplement pas compilé (grâce au destructeur protégé).  Les pointeurs intelligents standard (y compris l'utilisation de dissolvants personnalisés) sont discutés en détail dans [Josuttis], [Meyers3].  Un exemple d'utilisation d'un décapant personnalisé peut être trouvé dans la section 4.3.1. </p><br><p>      ,       ,      ,    . </p><br><a name="id-3-9"></a><br><h2>  3.9.  - </h2><br><p>     -    const.              ,  ,    -,       . </p><br><a name="id-3-10"></a><br><h2>  3.10. COM- </h2><br><p> COM-    ,     ,  COM —      ,  COM-     ,   C,    ,   .  COM-  C++      ,   COM. </p><br><a name="id-3-11"></a><br><h2>  3.11.     </h2><br><p>         (API)    (SDK).       .    -,      -,           .     ,     (Windows DLL),     :  -.          .        ,  ,       .     <code>LoadLibrary()</code>      ,    -,       . </p><br><a name="id-4"></a><br><h1> 4.       </h1><br><a name="id-4-1"></a><br><h2>  4.1.   </h2><br><p>       ,      . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   public:    virtual void Delete() = 0; //      IBase&amp; operator=(const IBase&amp;) = delete; //   };</span></span></code> </pre> <br><p>    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IActivatable</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBase { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    ~IActivatable() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   public:    virtual void Activate(bool activate) = 0;    static IActivatable* CreateInstance(); // - };</span></span></code> </pre> <br><p> ,         ,     .     ,           <code>IBase</code> .     ,            (.  1.3).       ,       . </p><br><a name="id-4-2"></a><br><h2>  4.2.   </h2><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IActivatable { <span class="hljs-comment"><span class="hljs-comment">// ... private:    Activator(); protected:    ~Activator(); public:    void Delete() override;    void Activate(bool activate) override;    friend IActivatable* IActivatable::CreateInstance(); }; Activator::Activator() {/* ... */} Activator::~Activator() {/* ... */} void Activator::Delete() { delete this; } void Activator::Activate(bool activate) {/* ... */} IActivatable* IActivatable::CreateInstance() {    return static_cast&lt;IActivatable*&gt;(new Activator()); }</span></span></code> </pre> <br><p>      , ,        ,  -  ,         . </p><br><a name="id-4-3"></a><br><h2>  4.3.    </h2><br><a name="id-4-3-1"></a><br><h3> 4.3.1.     </h3><br><p>           . -   (     <code>IBase</code> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseDeleter</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IBase* p)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ p-&gt;Delete(); } };</code> </pre> <br><p>  <code>std::unique_ptr&lt;&gt;</code> -   : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> —  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;I, BaseDeleter&gt;;</code> </pre> <br><p> ,   ,  -   ,  <code>UniquePtr</code>    . </p><br><p>   -: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> —  - </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateInstance</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class">&lt;I&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateInstance</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UniquePtr&lt;I&gt;(I::CreateInstance()); }</code> </pre> <br><p>        : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> —  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class">&lt;I&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToPtr</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UniquePtr&lt;I&gt;(p); }</code> </pre> <br><p>  <code>std::shared_ptr&lt;&gt;</code>    <code>std::unique_ptr&lt;&gt;</code> ,   ,  <code>std::shared_ptr&lt;&gt;</code>   .      <code>Activator</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> un1 = CreateInstance&lt;IActivatable&gt;(); un1-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> un2 = ToPtr(IActivatable::CreateInstance()); un2-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IActivatable&gt; sh = CreateInstance&lt;IActivatable&gt;(); sh-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br><p>          (     — -): </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IActivatable&gt; sh2(IActivatable::CreateInstance());</code> </pre> <br><p>     <code>std::make_shared&lt;&gt;()</code> ,      (    ). </p><br><p>    :          ,     .     :     ,  - .     4.4. </p><br><a name="id-4-3-2"></a><br><h3> 4.3.2.     </h3><br><p>       .           -.   <code>std::shared_ptr&lt;&gt;</code>         ,    ,      (         ).     <code>std::shared_ptr&lt;&gt;</code> (  )  -  ,           <code>delete</code>     .  <code>std::shared_ptr&lt;&gt;</code> -       (   )   -      .        . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class IActivatable; using ActPtr = std::shared_ptr&lt;IActivatable&gt;; //   class IActivatable { protected:    virtual ~IActivatable() = default; //      IActivatable&amp; operator=(const IActivatable&amp;) = default; //   public:    virtual void Activate(bool activate) = 0;    static ActPtr CreateInstance(); // - }; //   class Activator : public IActivatable { // ... public:    Activator();  //      ~Activator(); //      void Activate(bool activate) override; }; Activator::Activator() {/* ... */} Activator::~Activator() {/* ... */} void Activator::Activate(bool activate) {/* ... */} ActPtr IActivatable::CreateInstance() {    return ActPtr(new Activator()); }</span></span></span></span></code> </pre> <br><p>  -        <code>std::make_shared&lt;&gt;()</code> : </p><br><pre> <code class="cpp hljs">ActPtr IActivatable::CreateInstance() {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;Activator&gt;(); }</code> </pre> <br><p>      <code>std::unique_ptr&lt;&gt;</code> ,        , -   ,        . </p><br><a name="id-4-4"></a><br><h2> 4.4.     </h2><br><p>    C#  Java  C++    «»,       .        .      <code>IBase</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IBase() = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,       virtual void Delete(); //   public:    IBase(const IBase&amp;) = delete;            //      IBase&amp; operator=(const IBase&amp;) = delete; //      struct Deleter        // -    {        void operator()(IBase* p) const { p-&gt;Delete(); }    };    friend struct IBase::Deleter; };</span></span></code> </pre> <br><p>     , <code>Delete()</code>    ,     . </p><br><pre> <code class="cpp hljs">IBase::~IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IBase::Delete() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>      <code>IBase</code> .         <code>Delete()</code> ,              . -      <code>IBase</code> . <code>Delete()</code>  , - .     <code>Delete()</code>         ,    .       ,    4.3.1. </p><br><a name="id-5"></a><br><h1> 5.   ,      </h1><br><a name="id-5-1"></a><br><h2> 5.1  </h2><br><p>  ,    ,   ,      ,        . </p><br><p>   ,  ,    <code>IException</code>    <code>Exception</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IException</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">;</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IException() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">What</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    IException&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IException&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> {</span></span>    IException* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m_Ptr; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code);    Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Exception&amp; src) : m_Ptr(src.m_Ptr-&gt;Clone()) {}    ~Exception() { m_Ptr-&gt;Delete(); }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Ptr; } };</code> </pre> <br><p>         <code>Exception</code> ,            <code>IException</code> .       ,    <code>throw</code> ,   .    <code>Exception</code>      ,      .  -      ,   . </p><br><p>  <code>Exception</code> , ,  . </p><br><p>   <code>IException</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExcImpl</span></span></span><span class="hljs-class"> :</span></span> IException {    <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">;</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_What;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_Code;    ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code);    ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ExcImpl&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    <span class="hljs-function"><span class="hljs-function">IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    ~ExcImpl() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">What</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; }; ExcImpl::ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code)    : m_What(what), m_Code(code) {} IException* ExcImpl::Clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExcImpl(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ExcImpl::Delete() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ExcImpl::What() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_What.c_str(); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ExcImpl::Code() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Code; }</code> </pre> <br><p>   <code>Exception</code> : </p><br><pre> <code class="cpp hljs">Exception::Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code)    : m_Ptr(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExcImpl(what, code)) {}</code> </pre> <br><p>    ,       — .NET —  , —          ,     C++/CLI.  ,        ,     ,   C++/CLI. </p><br><a name="id-5-2"></a><br><h2> 5.2  </h2><br><p>   -    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICollect</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ICollect() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ICollect&lt;T&gt;* Clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ind)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ind)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    ICollect&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ICollect&lt;T&gt;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>        ,             -,        . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICollect</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Contain</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ICollect&lt;T&gt; CollType;    CollType* m_Coll; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T value_type;    Contain(CollType* coll);    ~Contain(); <span class="hljs-comment"><span class="hljs-comment">//     Contain(const Contain&amp; src);    Contain&amp; operator=(const Contain&amp; src); //     Contain(Contain&amp;&amp; src);    Contain&amp; operator=(Contain&amp;&amp; src);    bool mpty() const;    int size() const;    T&amp; operator[](int ind);    const T&amp; operator[](int ind) const;    Iterator&lt;T&gt; begin();    Iterator&lt;T&gt; end(); };</span></span></code> </pre> <br><p>      .   ,       . ,      ,    ,     ,    - <code>begin()</code>  <code>end()</code> ,   .           (. [Josuttis]),         <code>for</code>   .                .            , ,      . </p><br><a name="id-6"></a><br><h1> 6.    - </h1><br><p>       .         -,      .          .   ,         ++.              ,   .NET, Java  Pyton.              .      ,  ,         .   .NET Framework     C++/CLI          C++.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . </p><br><a name="id-conclusion"></a><br><h1> 7.  </h1><br><p>      -,         . </p><br><p>         . </p><br><ol><li>   <code>delete</code> . </li><li>    . </li><li>      . </li></ol><br><p>          . </p><br><p>         ,       <code>delete</code> .                ,      . </p><br><p>    -   ,           .             ,    ,      <code>delete</code> . </p><br><p>             . </p><br><p>      ,          ,     ,  ,       . </p><br><br><a name="id-refs"></a><br><h1>  Les références </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[GoF] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gamma E., Helm R., Johnson R., Vlissides J. Méthodes de conception orientée objet. </font><font style="vertical-align: inherit;">Modèles de conception.: Per. </font><font style="vertical-align: inherit;">de l'anglais </font><font style="vertical-align: inherit;">- Saint-Pétersbourg: Peter, 2001.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Josuttis] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josattis, Nikolai M. C ++ Standard Library: Reference Guide, 2nd ed.: Per. </font><font style="vertical-align: inherit;">de l'anglais </font><font style="vertical-align: inherit;">- M.: LLC «I.D. </font><font style="vertical-align: inherit;">Williams, 2014.</font></font></p><br><p> [Dewhurst] <br> ,  .   C++.         .: .  . — .:  , 2012. </p><br><p> [Meyers1] <br> , .    C++. 35        .: .  . — .:  , 2000. </p><br><p> [Meyers2] <br> , .   C++. 55        .: .  . — .:  , 2014. </p><br><p> [Meyers3] <br> , .    C++: 42    C++11  C++14.: .  . — .:  «.. », 2016. </p><br><p> [Sutter] <br> , .     C++.: .  . — :  «.. », 2015. </p><br><p> [Sutter/Alexandrescu] <br> , . , .    ++.: .  . — .:  «.. », 2015. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427281/">https://habr.com/ru/post/fr427281/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427271/index.html">Histoire et expérience de l'utilisation de la traduction automatique. Conférence Yandex</a></li>
<li><a href="../fr427273/index.html">L'intelligence artificielle peut-elle laisser les bookmakers sans travail?</a></li>
<li><a href="../fr427275/index.html">Architecture de l'information Internet, partie 3</a></li>
<li><a href="../fr427277/index.html">Un schéma de diffraction se retrouve dans la distribution des nombres premiers, similaire à celui des quasi-cristaux</a></li>
<li><a href="../fr427279/index.html">CoLaboratoire: Android Night #Apple</a></li>
<li><a href="../fr427283/index.html">Comment la haute disponibilité chez Kubernetes est assurée</a></li>
<li><a href="../fr427285/index.html">École sur les bases des circuits numériques: Novossibirsk - Ok, Krasnoyarsk - préparez-vous</a></li>
<li><a href="../fr427289/index.html">Modélisation géologique 3D, diagraphie et technologie d'Aramco Innovations</a></li>
<li><a href="../fr427291/index.html">Réduisez le trafic dans les formulaires Web ASP.NET, les div cliquables et les interrogations périodiques du serveur</a></li>
<li><a href="../fr427293/index.html">Modèles de conception JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>