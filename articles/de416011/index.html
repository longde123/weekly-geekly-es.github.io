<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗃️ 🛌🏽 🏤 BIF-Muster: Sauberer Front-End-Code und bequemes Arbeiten mit Serverdaten 😮 ❄️ 👧🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Material, dessen Übersetzung wir heute veröffentlichen, konzentriert sich darauf, was in einer Situation zu tun ist, in der die vom Server empfang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>BIF-Muster: Sauberer Front-End-Code und bequemes Arbeiten mit Serverdaten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/416011/">  Das Material, dessen Übersetzung wir heute veröffentlichen, konzentriert sich darauf, was in einer Situation zu tun ist, in der die vom Server empfangenen Daten nicht den Anforderungen des Clients entsprechen.  Zuerst werden wir ein typisches Problem dieser Art betrachten und dann verschiedene Wege analysieren, um es zu lösen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/7dc/108/edd/7dc108edd1850ed1da6eb12f865f93a5.jpg" alt="Bild"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Das Problem der ausgefallenen Server-API</font> </h2><br>  Betrachten wir ein bedingtes Beispiel, das auf mehreren realen Projekten basiert.  Angenommen, wir entwickeln eine neue Website für eine Organisation, die seit einiger Zeit besteht.  Sie hat bereits REST-Endpunkte, aber sie sind nicht ganz auf das ausgelegt, was wir erstellen werden.  Hier müssen wir nur auf den Server zugreifen, um den Benutzer zu authentifizieren, Informationen über ihn zu erhalten und eine Liste der nicht angezeigten Benachrichtigungen von diesem Benutzer herunterzuladen.  Aus diesem Grund interessieren uns die folgenden Endpunkte der Server-API: <br><br><ul><li> <code>/auth</code> : Autorisiert den Benutzer und gibt ein Zugriffstoken zurück. </li><li>  <code>/profile</code> : Gibt grundlegende Benutzerinformationen zurück. </li><li>  <code>/notifications</code> : Ermöglicht das Abrufen ungelesener Benutzerbenachrichtigungen. </li></ul><br>  Stellen Sie sich vor, unsere Anwendung muss immer alle diese Daten in einer einzigen Einheit empfangen, das heißt, im Idealfall wäre es schön, wenn wir anstelle von drei Endpunkten nur einen hätten. <br>  Wir haben jedoch viel mehr Probleme als zu viele Endpunkte.  Insbesondere sprechen wir darüber, dass die Daten, die wir erhalten, nicht optimal aussehen. <br><br>  Beispielsweise wurde der Endpunkt <code>/profile</code> in der Antike erstellt und nicht in JavaScript geschrieben. Daher sehen die Namen der Eigenschaften in den zurückgegebenen Daten für eine JS-Anwendung ungewöhnlich aus: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"Profiles"</span></span>: [   {     <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"Christian_Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"David"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"Surname"</span></span>: <span class="hljs-string"><span class="hljs-string">"Gilbertson"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"Photographs"</span></span>: [       {         <span class="hljs-attr"><span class="hljs-attr">"Size"</span></span>: <span class="hljs-string"><span class="hljs-string">"Medium"</span></span>,         <span class="hljs-attr"><span class="hljs-attr">"URLS"</span></span>: [           <span class="hljs-string"><span class="hljs-string">"/images/david.png"</span></span>         ]       }     ],     <span class="hljs-attr"><span class="hljs-attr">"Last_Login"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-01-01"</span></span>   } ] }</code> </pre> <br>  Im Allgemeinen - nichts Gutes. <br><br>  Richtig, wenn Sie sich ansehen, was der Endpunkt <code>/notifications</code> erzeugen, werden die obigen Daten von <code>/profile</code> ziemlich nett erscheinen: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"data"</span></span>: {   <span class="hljs-attr"><span class="hljs-attr">"msg-1234"</span></span>: {     <span class="hljs-attr"><span class="hljs-attr">"timestamp"</span></span>: <span class="hljs-string"><span class="hljs-string">"1529739612"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: {       <span class="hljs-attr"><span class="hljs-attr">"Christian_Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Alice"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"Surname"</span></span>: <span class="hljs-string"><span class="hljs-string">"Guthbertson"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"Enhanced"</span></span>: <span class="hljs-string"><span class="hljs-string">"True"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"Photographs"</span></span>: [         {           <span class="hljs-attr"><span class="hljs-attr">"Size"</span></span>: <span class="hljs-string"><span class="hljs-string">"Medium"</span></span>,           <span class="hljs-attr"><span class="hljs-attr">"URLS"</span></span>: [             <span class="hljs-string"><span class="hljs-string">"/images/alice.png"</span></span>           ]         }       ]     },     <span class="hljs-attr"><span class="hljs-attr">"message_summary"</span></span>: <span class="hljs-string"><span class="hljs-string">"Hey I like your hair, it re"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"Hey I like your hair, it really goes nice with your eyes"</span></span>   },   <span class="hljs-attr"><span class="hljs-attr">"msg-5678"</span></span>: {     <span class="hljs-attr"><span class="hljs-attr">"timestamp"</span></span>: <span class="hljs-string"><span class="hljs-string">"1529731234"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: {       <span class="hljs-attr"><span class="hljs-attr">"Christian_Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"Surname"</span></span>: <span class="hljs-string"><span class="hljs-string">"Smelthsen"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"Photographs"</span></span>: [         {           <span class="hljs-attr"><span class="hljs-attr">"Size"</span></span>: <span class="hljs-string"><span class="hljs-string">"Medium"</span></span>,           <span class="hljs-attr"><span class="hljs-attr">"URLS"</span></span>: [             <span class="hljs-string"><span class="hljs-string">"/images/smelth.png"</span></span>           ]         }       ]     },     <span class="hljs-attr"><span class="hljs-attr">"message_summary"</span></span>: <span class="hljs-string"><span class="hljs-string">"I'm launching my own cryptocu"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"I'm launching my own cryptocurrency soon and many thanks for you to look at and talk about"</span></span>   } } }</code> </pre> <br>  Hier ist die Liste der Nachrichten ein Objekt, kein Array.  Außerdem gibt es hier Benutzerdaten, die genauso unangenehm angeordnet sind wie im Fall des <code>/profile</code> Endpunkts.  Und - hier ist eine Überraschung - die <code>timestamp</code> enthält die Anzahl der Sekunden seit Anfang 1970. <br><br>  Wenn ich ein Diagramm der Architektur dieses höllisch unbequemen Systems zeichnen müsste, über das wir gerade gesprochen haben, würde es wie das in der folgenden Abbildung gezeigte aussehen.  Die rote Farbe wird für diejenigen Teile dieser Schaltung verwendet, die schlecht vorbereiteten Daten für weitere Arbeiten entsprechen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8e1/6c4/42f/8e16c442f3af8ad8ca702875e25207e0.png"><br>  <i><font color="#999999">Systemdiagramm</font></i> <br><br>  Unter diesen Umständen bemühen wir uns möglicherweise nicht, die Architektur dieses Systems zu reparieren.  Sie können einfach Daten von diesen drei APIs laden und diese Daten in der Anwendung verwenden.  Wenn Sie beispielsweise den vollständigen Benutzernamen auf der Seite anzeigen müssen, müssen Sie die Eigenschaften <code>Christian_Name</code> und <code>Surname</code> kombinieren. <br><br>  Hier möchte ich eine Bemerkung zu Namen machen.  Die Idee, den vollständigen Namen einer Person in einen persönlichen Vor- und Nachnamen zu unterteilen, ist charakteristisch für westliche Länder.  Wenn Sie etwas für den internationalen Gebrauch entwickeln, versuchen Sie, den vollständigen Namen der Person als unteilbare Zeichenfolge zu betrachten, und machen Sie keine Annahmen darüber, wie diese Zeichenfolge in kleinere Teile zerlegt werden kann, um zu verwenden, was an Orten passiert ist, an denen brauchen Kürze oder möchten den Benutzer in einem informellen Stil ansprechen. <br><br>  Zurück zu unseren unvollständigen Datenstrukturen.  Das erste offensichtliche Problem, das hier zu sehen ist, drückt sich in der Notwendigkeit aus, unterschiedliche Daten im Benutzeroberflächencode zu kombinieren.  Es besteht in der Tatsache, dass wir diese Aktion möglicherweise an mehreren Stellen wiederholen müssen.  Wenn Sie dies nur gelegentlich tun müssen, ist das Problem nicht so schwerwiegend, aber wenn Sie dies häufig benötigen, ist es viel schlimmer.  Infolgedessen gibt es unerwünschte Phänomene, die durch die Nichtübereinstimmung der Anordnung der vom Server empfangenen Daten und ihrer Verwendung in der Anwendung verursacht werden. <br><br>  Das zweite Problem ist die Komplexität des Codes, der zur Bildung der Benutzeroberfläche verwendet wird.  Ich glaube, dass ein solcher Code zum einen so einfach wie möglich und zum anderen so klar wie möglich sein sollte.  Je mehr interne Datentransformationen Sie auf dem Client durchführen müssen, desto komplexer und komplexer ist der Code, an dem sich normalerweise Fehler verstecken. <br><br>  Das dritte Problem betrifft Datentypen.  Anhand der obigen Codefragmente können Sie erkennen, dass beispielsweise Nachrichtenkennungen Zeichenfolgen und Benutzerkennungen Zahlen sind.  Aus technischer Sicht ist alles in Ordnung, aber solche Dinge können den Programmierer verwirren.  Schauen Sie sich auch die Präsentation der Daten an!  Aber was ist mit dem Durcheinander in dem Teil der Daten, der sich auf das Profilbild bezieht?  Schließlich brauchen wir nur eine URL, die zur entsprechenden Datei führt, und nicht etwas, aus dem wir diese URL selbst erstellen müssen, um durch den Dschungel verschachtelter Datenstrukturen zu waten. <br><br>  Wenn wir diese Daten verarbeiten, an den Benutzeroberflächencode übergeben und dann die Module analysieren, können wir nicht sofort genau verstehen, womit wir dort arbeiten.  Das Konvertieren der internen Datenstruktur und ihres Typs bei der Arbeit mit ihnen führt zu einer zusätzlichen Belastung für den Programmierer.  Aber ohne all diese Schwierigkeiten ist das durchaus möglich. <br><br>  In der Tat wäre es als Option möglich, ein statisches Typsystem zu implementieren, um dieses Problem zu lösen, aber eine strikte Typisierung ist nicht nur aufgrund ihrer Anwesenheit in der Lage, schlechten Code gut zu machen. <br><br>  Nachdem Sie nun den Ernst des Problems sehen können, mit dem wir konfrontiert sind, sprechen wir über Möglichkeiten, es zu lösen. <br><br><h2>  <font color="#3AC1EF">Lösung 1: Ändern der Server-API</font> </h2><br>  Wenn das unbequeme Gerät der vorhandenen API nicht aus wichtigen Gründen vorgegeben ist, hindert Sie nichts daran, eine neue Version zu erstellen, die den Anforderungen des Projekts besser entspricht, und diese neue Version beispielsweise unter <code>/v2</code> .  Vielleicht kann dieser Ansatz als die erfolgreichste Lösung für die oben genannten Probleme bezeichnet werden.  Das Schema eines solchen Systems ist in der folgenden Abbildung dargestellt. Die Datenstruktur, die perfekt zu den Anforderungen des Kunden passt, ist grün hervorgehoben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c59/59d/c18/c5959dc18590ec9bce0368e4b9ba1967.png"><br>  <i><font color="#999999">Die neue Server-API, die genau das produziert, was die Client-Seite des Systems benötigt</font></i> <br><br>  Ich beginne mit der Entwicklung eines neuen Projekts, dessen API zu wünschen übrig lässt, und bin immer an der Möglichkeit interessiert, den gerade beschriebenen Ansatz umzusetzen.  Manchmal hat das API-Gerät jedoch einige wichtige Ziele, obwohl es unpraktisch ist, oder eine Änderung der Server-API ist einfach nicht möglich.  In diesem Fall greife ich auf den folgenden Ansatz zurück. <br><br><h2>  <font color="#3AC1EF">Lösung 2: BFF-Muster</font> </h2><br>  Dies ist ein gutes altes BFF <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-</a> Muster ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Backend-For-the-Frontend</a> ).  Mit diesem Muster können Sie von den komplizierten universellen REST-Endpunkten abstrahieren und dem Frontend genau das geben, was es benötigt.  Hier ist eine schematische Darstellung einer solchen Lösung. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea5/484/437/ea5484437a08ed68db006b5194dd9a9b.png"><br>  <i><font color="#999999">Anwenden des BFF-Musters</font></i> <br><br>  Die Bedeutung der Existenz der BFF-Schicht besteht darin, die Bedürfnisse des Frontends zu befriedigen.  Vielleicht verwendet er zusätzliche REST-Endpunkte oder GraphQL-Dienste oder Web-Sockets oder irgendetwas anderes.  Das Hauptziel besteht darin, alles Mögliche für die Client-Seite der Anwendung zu tun. <br><br>  Meine Lieblingsarchitektur ist NodeJS BFF, mit der Front-End-Entwickler das tun können, was sie benötigen, und großartige APIs für die von ihnen entwickelten Clientanwendungen erstellen.  Im Idealfall befindet sich der entsprechende Code im selben Repository wie der Code des Frontends selbst. Dies vereinfacht die gemeinsame Nutzung von Code, um beispielsweise gesendete Daten sowohl auf dem Client als auch auf dem Server zu überprüfen. <br><br>  Dies bedeutet außerdem, dass Aufgaben, die Änderungen am Client-Teil der Anwendung und ihrer Server-API erfordern, in einem Repository ausgeführt werden.  Eine Kleinigkeit, wie sie sagen, aber nett. <br><br>  BFF wird jedoch möglicherweise nicht immer verwendet.  Und diese Tatsache führt uns zu einer anderen Lösung für das Problem der bequemen Verwendung fehlerhafter Server-APIs. <br><br><h2>  <font color="#3AC1EF">Lösung 3: BIF-Muster</font> </h2><br>  Das BIF-Muster (Backend In the Frontend) verwendet dieselbe Logik, die mit BFF (Kombination mehrerer APIs und Datenbereinigung) angewendet werden kann. Diese Logik wird jedoch auf die Clientseite verschoben.  Eigentlich ist diese Idee nicht neu, sie hätte vor zwanzig Jahren gesehen werden können, aber ein solcher Ansatz kann bei der Arbeit mit schlecht organisierten Server-APIs hilfreich sein. Deshalb sprechen wir darüber.  So sieht es aus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/185/102/d39/185102d39436b6119ead19f230eb8196.png"><br>  <i><font color="#999999">Anwenden des BIF-Musters</font></i> <br><br><h3>  <font color="#3AC1EF">▍ Was ist ein BIF?</font> </h3><br>  Wie aus dem vorherigen Abschnitt ersichtlich ist, ist BIF ein Muster, dh ein Ansatz zum Verständnis des Codes und seiner Organisation.  Seine Verwendung führt nicht dazu, dass Logik aus dem Projekt entfernt werden muss.  Es trennt lediglich die Logik eines Typs (Änderung von Datenstrukturen) von der Logik eines anderen Typs (Bildung der Benutzeroberfläche).  Dies ähnelt der Idee einer „Aufgabentrennung“, die jeder hört. <br><br>  An dieser Stelle möchte ich darauf hinweisen, dass ich, obwohl dies nicht als Katastrophe bezeichnet werden kann, häufig Analphabeten-BIF-Implementierungen sehen musste.  Daher scheint es mir, dass viele daran interessiert sein werden, eine Geschichte darüber zu hören, wie dieses Muster richtig implementiert werden kann. <br><br>  Der BIF-Code sollte als Code betrachtet werden, der einmal genommen und auf den Node.js-Server übertragen werden kann. Danach funktioniert alles auf die gleiche Weise wie zuvor.  Oder übertragen Sie es sogar auf ein privates NPM-Paket, das in mehreren Front-End-Projekten im Rahmen eines Unternehmens verwendet wird, was einfach erstaunlich ist. <br><br>  Denken Sie daran, dass wir oben die Hauptprobleme besprochen haben, die beim Arbeiten mit einer ausgefallenen Server-API auftreten.  Dazu gehört ein zu häufiger Aufruf der API und die Tatsache, dass die von ihnen zurückgegebenen Daten nicht den Anforderungen des Frontends entsprechen. <br><br>  Wir werden die Lösung für jedes dieser Probleme in separate Codeblöcke aufteilen, von denen jeder in einer eigenen Datei abgelegt wird.  Infolgedessen besteht die BIF-Schicht des Client-Teils der Anwendung aus zwei Dateien.  Zusätzlich wird ihnen eine Testdatei angehängt. <br><br><h3>  <font color="#3AC1EF">▍ API-Aufrufe kombinieren</font> </h3><br>  Das Aufrufen der Server-APIs in unserem Client-Code ist kein so ernstes Problem.  Ich möchte es jedoch abstrahieren, um es zu ermöglichen, eine einzelne „Anfrage“ (vom Anwendungscode bis zur BIF-Schicht) zu erfüllen und genau das zu erhalten, was als Antwort benötigt wird. <br><br>  In unserem Fall gibt es natürlich kein Entrinnen, drei HTTP-Anforderungen an den Server zu senden, aber die Anwendung muss nichts darüber wissen. <br><br>  Die API meiner BIF-Schicht wird als Funktionen dargestellt.  Wenn die Anwendung einige Daten über den Benutzer benötigt, ruft sie daher die Funktion <code>getUser()</code> , die diese Daten an sie <code>getUser()</code> .  So sieht diese Funktion aus: <br><br><pre> <code class="hljs powershell">import parseUserData from <span class="hljs-string"><span class="hljs-string">'./parseUserData'</span></span>; import fetchJson from <span class="hljs-string"><span class="hljs-string">'./fetchJson'</span></span>; export const getUser = async () =&gt; { const auth = await fetchJson(<span class="hljs-string"><span class="hljs-string">'/auth'</span></span>); const [ <span class="hljs-type"><span class="hljs-type">profile</span></span>, <span class="hljs-type"><span class="hljs-type">notifications</span></span> ] = await Promise.all([   <span class="hljs-type"><span class="hljs-type">fetchJson</span></span>(`/<span class="hljs-type"><span class="hljs-type">profile</span></span>/<span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-type"><span class="hljs-type">auth.userId</span></span>}`, <span class="hljs-type"><span class="hljs-type">auth.jwt</span></span>),   <span class="hljs-type"><span class="hljs-type">fetchJson</span></span>(`/<span class="hljs-type"><span class="hljs-type">notifications</span></span>/<span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-type"><span class="hljs-type">auth.userId</span></span>}`, <span class="hljs-type"><span class="hljs-type">auth.jwt</span></span>), ]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parseUserData(auth, profile, notifications); };</code> </pre> <br>  Hier wird zunächst eine Anforderung an den Authentifizierungsdienst gestellt, um ein Token zu erhalten, mit dem der Benutzer autorisiert werden kann (wir werden hier nicht über Authentifizierungsmechanismen sprechen, unser Hauptziel ist jedoch BIF). <br><br>  Nach dem Empfang des Tokens können Sie gleichzeitig zwei Anforderungen ausführen, die Benutzerprofildaten und Informationen zu ungelesenen Benachrichtigungen erhalten. <br><br>  Schauen Sie sich übrigens an, wie schön das Konstrukt <code>async/await</code> aussieht, wenn Sie mit <code>Promise.all</code> und destruktiver Zuweisung damit arbeiten. <br><br>  Dies war also der erste Schritt. Hier haben wir von der Tatsache abstrahiert, dass der Zugriff auf den Server drei Anforderungen umfasst.  Der Fall ist jedoch noch nicht abgeschlossen.  <code>parseUserData()</code> nämlich auf den Aufruf der Funktion <code>parseUserData()</code> , die, wie Sie anhand ihres Namens <code>parseUserData()</code> können, die vom Server empfangenen Daten <code>parseUserData()</code> .  Reden wir über sie. <br><br><h3>  <font color="#3AC1EF">▍ Datenbereinigung</font> </h3><br>  Ich möchte sofort eine Empfehlung aussprechen, die meines Erachtens ein Projekt, das zuvor keine BIF-Schicht hatte, ernsthaft beeinträchtigen kann, insbesondere ein neues Projekt.  Denken Sie eine Weile nicht darüber nach, was Sie vom Server erhalten.  Konzentrieren Sie sich stattdessen darauf, welche Daten Ihre Anwendung benötigt. <br><br>  Darüber hinaus ist es am besten, beim Entwerfen der Anwendung nicht zu versuchen, mögliche zukünftige Anforderungen zu berücksichtigen, beispielsweise im Zusammenhang mit 2021.  Versuchen Sie einfach, die Anwendung genau so zu machen, wie sie heute sollte.  Tatsache ist, dass übermäßige Begeisterung für die Planung und Versuche, die Zukunft vorherzusagen, der Hauptgrund für die ungerechtfertigte Komplikation von Softwareprojekten ist. <br><br>  Also zurück zu unserem Geschäft.  Jetzt wissen wir, wie die von den drei Server-APIs empfangenen Daten aussehen, und wir wissen, wie sie nach der Analyse umgewandelt werden sollen. <br><br>  Es scheint, dass hier einer dieser seltenen Fälle ist, in denen die Verwendung von TDD wirklich Sinn macht.  Daher werden wir einen langen Test für die Funktion <code>parseUserData()</code> schreiben: <br><br><pre> <code class="hljs powershell">import parseUserData from <span class="hljs-string"><span class="hljs-string">'./parseUserData'</span></span>; it(<span class="hljs-string"><span class="hljs-string">'should parse the data'</span></span>, () =&gt; { const authApiData = {   userId: <span class="hljs-number"><span class="hljs-number">1234</span></span>,   jwt: <span class="hljs-string"><span class="hljs-string">'the jwt'</span></span>, }; const profileApiData = {   Profiles: [     {       <span class="hljs-type"><span class="hljs-type">id</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>,       <span class="hljs-type"><span class="hljs-type">Christian_Name</span></span>: <span class="hljs-string"><span class="hljs-string">'David'</span></span>,       <span class="hljs-type"><span class="hljs-type">Surname</span></span>: <span class="hljs-string"><span class="hljs-string">'Gilbertson'</span></span>,       <span class="hljs-type"><span class="hljs-type">Photographs</span></span>: [         {           <span class="hljs-type"><span class="hljs-type">Size</span></span>: <span class="hljs-string"><span class="hljs-string">'Medium'</span></span>,           <span class="hljs-type"><span class="hljs-type">URLS</span></span>: [             <span class="hljs-string"><span class="hljs-string">'/images/david.png'</span></span>,           ],         },       ],       <span class="hljs-type"><span class="hljs-type">Last_Login</span></span>: <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>     },   ], }; const notificationsApiData = {   <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: {     <span class="hljs-string"><span class="hljs-string">'msg-1234'</span></span>: {       timestamp: <span class="hljs-string"><span class="hljs-string">'1529739612'</span></span>,       user: {         Christian_Name: <span class="hljs-string"><span class="hljs-string">'Alice'</span></span>,         Surname: <span class="hljs-string"><span class="hljs-string">'Guthbertson'</span></span>,         Enhanced: <span class="hljs-string"><span class="hljs-string">'True'</span></span>,         Photographs: [           {             <span class="hljs-type"><span class="hljs-type">Size</span></span>: <span class="hljs-string"><span class="hljs-string">'Medium'</span></span>,             <span class="hljs-type"><span class="hljs-type">URLS</span></span>: [               <span class="hljs-string"><span class="hljs-string">'/images/alice.png'</span></span>             ]           }         ]       },       message_summary: <span class="hljs-string"><span class="hljs-string">'Hey I like your hair, it re'</span></span>,       message: <span class="hljs-string"><span class="hljs-string">'Hey I like your hair, it really goes nice with your eyes'</span></span>     },     <span class="hljs-string"><span class="hljs-string">'msg-5678'</span></span>: {       timestamp: <span class="hljs-string"><span class="hljs-string">'1529731234'</span></span>,       user: {         Christian_Name: <span class="hljs-string"><span class="hljs-string">'Bob'</span></span>,         Surname: <span class="hljs-string"><span class="hljs-string">'Smelthsen'</span></span>,       },       message_summary: <span class="hljs-string"><span class="hljs-string">'I\'</span></span>m launching my own cryptocu<span class="hljs-string"><span class="hljs-string">',       message: '</span></span>I\<span class="hljs-string"><span class="hljs-string">'m launching my own cryptocurrency soon and many thanks for you to look at and talk about'</span></span>     },   }, }; const parsedData = parseUserData(authApiData, profileApiData, notificationsApiData); expect(parsedData).toEqual({   jwt: <span class="hljs-string"><span class="hljs-string">'the jwt'</span></span>,   id: <span class="hljs-string"><span class="hljs-string">'1234'</span></span>,   name: <span class="hljs-string"><span class="hljs-string">'David Gilbertson'</span></span>,   photoUrl: <span class="hljs-string"><span class="hljs-string">'/images/david.png'</span></span>,   notifications: [     {       <span class="hljs-type"><span class="hljs-type">id</span></span>: <span class="hljs-string"><span class="hljs-string">'msg-1234'</span></span>,       <span class="hljs-built_in"><span class="hljs-built_in">dateTime</span></span>: <span class="hljs-type"><span class="hljs-type">expect.any</span></span>(<span class="hljs-type"><span class="hljs-type">Date</span></span>),       <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Alice Guthbertson'</span></span>,       <span class="hljs-type"><span class="hljs-type">premiumMember</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span>,       <span class="hljs-type"><span class="hljs-type">photoUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'/images/alice.png'</span></span>,       <span class="hljs-type"><span class="hljs-type">message</span></span>: <span class="hljs-string"><span class="hljs-string">'Hey I like your hair, it really goes nice with your eyes'</span></span>     },     {       <span class="hljs-type"><span class="hljs-type">id</span></span>: <span class="hljs-string"><span class="hljs-string">'msg-5678'</span></span>,       <span class="hljs-built_in"><span class="hljs-built_in">dateTime</span></span>: <span class="hljs-type"><span class="hljs-type">expect.any</span></span>(<span class="hljs-type"><span class="hljs-type">Date</span></span>),       <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Bob Smelthsen'</span></span>,       <span class="hljs-type"><span class="hljs-type">premiumMember</span></span>: <span class="hljs-type"><span class="hljs-type">false</span></span>,       <span class="hljs-type"><span class="hljs-type">photoUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'/images/placeholder.jpg'</span></span>,       <span class="hljs-type"><span class="hljs-type">message</span></span>: <span class="hljs-string"><span class="hljs-string">'I\'</span></span><span class="hljs-type"><span class="hljs-type">m</span></span> <span class="hljs-type"><span class="hljs-type">launching</span></span> <span class="hljs-type"><span class="hljs-type">my</span></span> <span class="hljs-type"><span class="hljs-type">own</span></span> <span class="hljs-type"><span class="hljs-type">cryptocurrency</span></span> <span class="hljs-type"><span class="hljs-type">soon</span></span> <span class="hljs-type"><span class="hljs-type">and</span></span> <span class="hljs-type"><span class="hljs-type">many</span></span> <span class="hljs-type"><span class="hljs-type">thanks</span></span> <span class="hljs-type"><span class="hljs-type">for</span></span> <span class="hljs-type"><span class="hljs-type">you</span></span> <span class="hljs-type"><span class="hljs-type">to</span></span> <span class="hljs-type"><span class="hljs-type">look</span></span> <span class="hljs-type"><span class="hljs-type">at</span></span> <span class="hljs-type"><span class="hljs-type">and</span></span> <span class="hljs-type"><span class="hljs-type">talk</span></span> <span class="hljs-type"><span class="hljs-type">about</span></span><span class="hljs-string"><span class="hljs-string">'     },   ], }); });</span></span></code> </pre> <br>  Und hier ist der Code der Funktion selbst: <br><br><pre> <code class="hljs powershell">const getPhotoFromProfile = profile =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> profile.Photographs[<span class="hljs-number"><span class="hljs-number">0</span></span>].URLS[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'/images/placeholder.jpg'</span></span>; //   } }; const getFullNameFromProfile = profile =&gt; `${profile.Christian_Name} <span class="hljs-variable"><span class="hljs-variable">$</span></span>{profile.Surname}`; export default <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseUserData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(authApiData, profileApiData, notificationsApiData)</span></span></span></span> { const profile = profileApiData.Profiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]; const result = {   jwt: authApiData.jwt,   id: authApiData.userId.toString(), // ID        name: getFullNameFromProfile(profile),   photoUrl: getPhotoFromProfile(profile),   notifications: [], //      ,     }; Object.entries(notificationsApiData.data).forEach(([<span class="hljs-type"><span class="hljs-type">id</span></span>, <span class="hljs-type"><span class="hljs-type">notification</span></span>]) =&gt; {   result.notifications.push({     id,     dateTime: new Date(Number(notification.timestamp) * <span class="hljs-number"><span class="hljs-number">1000</span></span>), // ,   ,   ,     Unix,         name: getFullNameFromProfile(notification.user),     photoUrl: getPhotoFromProfile(notification.user),     message: notification.message,     premiumMember: notification.user.Enhanced === <span class="hljs-string"><span class="hljs-string">'True'</span></span>,   }) }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  Ich möchte darauf hinweisen, dass, wenn es möglich ist, zweihundert Codezeilen an einem Ort zu sammeln, die für die Änderung der zuvor in der gesamten Anwendung verteilten Daten verantwortlich sind, dies ein wunderbares Gefühl hervorruft.  Jetzt ist alles in einer Datei, Unit-Tests werden für diesen Code geschrieben und alle mehrdeutigen Momente werden mit Kommentaren versehen. <br><br>  Ich habe vorhin gesagt, dass BFF mein bevorzugter Ansatz zum Kombinieren und Löschen von Daten ist, aber es gibt einen Bereich, in dem BIF BFF überlegen ist.  Die vom Server empfangenen Daten können nämlich JavaScript-Objekte enthalten, die JSON nicht unterstützen, wie z. B. <code>Date</code> oder <code>Map</code> (dies ist möglicherweise eine der am wenigsten genutzten JavaScript-Funktionen).  In unserem Fall müssen wir beispielsweise das Datum, das vom Server kam (ausgedrückt in Sekunden, nicht in Millisekunden), in ein JS-Objekt vom Typ <code>Date</code> konvertieren. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Wenn Sie der Meinung sind, dass Ihr Projekt etwas mit dem gemeinsam hat, bei dem wir die Probleme nicht erfolgreicher APIs untersucht haben, analysieren Sie den Code, indem Sie sich die folgenden Fragen zur Verwendung von Daten vom Server auf dem Client stellen: <br><br><ul><li>  Müssen Sie Eigenschaften kombinieren, die niemals separat verwendet werden (z. B. Vor- und Nachname des Benutzers)? </li><li>  Muss der JS-Code mit Eigenschaftsnamen arbeiten, die so gebildet wurden, dass sie in JS nicht akzeptiert werden (so etwas wie PascalCase)? </li><li>  Was sind die Datentypen der verschiedenen Bezeichner?  Vielleicht sind das manchmal Zeichenfolgen, manchmal Zahlen? </li><li>  Wie werden Termine in Ihrem Projekt dargestellt?  Vielleicht sind dies manchmal <code>Date</code> JS-Objekte, die für die Verwendung in der Benutzeroberfläche bereit sind, und manchmal Zahlen oder sogar Zeichenfolgen? </li><li>  Müssen Sie häufig Eigenschaften auf ihre Existenz überprüfen oder prüfen, ob eine Entität ein Array ist, bevor Sie mit der Aufzählung der Elemente dieser Entität beginnen, um auf ihrer Basis ein Fragment der Benutzeroberfläche zu bilden?  Könnte es sein, dass diese Entität kein Array ist, auch wenn sie leer ist? </li><li>  Müssen Sie beim Bilden der Schnittstelle Arrays sortieren oder filtern, die im Idealfall bereits korrekt sortiert und gefiltert sein sollten? </li><li>  Wenn sich herausstellt, dass beim Überprüfen der Eigenschaften auf ihre Existenz keine gesuchten Eigenschaften gesucht werden, müssen Sie dann auf einige Standardwerte umschalten (verwenden Sie beispielsweise ein Standardbild, wenn die vom Server empfangenen Daten kein Benutzerfoto enthalten)? </li><li>  Sind die Eigenschaften einheitlich benannt?  Kommt es vor, dass dieselbe Entität unterschiedliche Namen haben kann, was möglicherweise durch die gemeinsame Verwendung von relativ alten "alten" und "neuen" Server-APIs verursacht wird? </li><li>  Müssen Sie zusammen mit nützlichen Daten Daten übertragen, die niemals verwendet werden, und zwar nur, weil sie von der Server-API stammen?  Beeinträchtigen diese nicht verwendeten Daten das Debuggen? </li></ul><br>  Wenn Sie eine oder zwei Fragen aus dieser Liste positiv beantworten können, sollten Sie möglicherweise etwas nicht reparieren, das bereits ordnungsgemäß funktioniert. <br><br>  Wenn Sie jedoch beim Lesen dieser Fragen in jedem von ihnen die Probleme Ihres Projekts herausfinden, wenn das Gerät Ihres Codes aufgrund all dessen unnötig kompliziert ist, wenn es schwer zu erkennen und zu testen ist, wenn es Fehler enthält, die schwer zu erkennen sind, schauen Sie sich das BIF-Muster an. <br><br>  Abschließend möchte ich sagen, dass bei der Einführung der BIF-Schicht in vorhandene Anwendungen die Dinge einfacher sind, da dies schrittweise und in kleinen Schritten erfolgen kann.  Nehmen wir an, die erste Version der Funktion zum Vorbereiten von Daten, nennen wir sie <code>parseData()</code> , kann einfach ohne Änderungen zurückgeben, was zu ihrer Eingabe kommt.  Anschließend können Sie die Logik schrittweise vom Code, der für die Erstellung der Benutzeroberfläche verantwortlich ist, zu dieser Funktion verschieben. <br><br>  <b>Liebe Leser!</b>     ,          BIF? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416011/">https://habr.com/ru/post/de416011/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416001/index.html">Nachrichten von einer Site in VK - einfach und effektiv - PHP + CUrl</a></li>
<li><a href="../de416003/index.html">Rendering von HTML-Dateien: Ein Kapitel aus dem Buch ReactPHP for Beginners von Skyeng</a></li>
<li><a href="../de416005/index.html">16 Reaktionstools für Schnittstellenentwickler</a></li>
<li><a href="../de416007/index.html">Fast kompliziert. Der Beginn der Schaffung eines drahtlosen "Smart Home". Basierend auf Linux-Technologie, Z-Wave- und MajorDoMo-Software</a></li>
<li><a href="../de416009/index.html">Probieren Sie Kaninchenkot, er ist kräftig und fängt - Extrakte in der Pharmakologie</a></li>
<li><a href="../de416013/index.html">So fangen Sie an zu investieren und Geld zu sparen: Die Experten von Dow Jones nannten die fünf Hauptfehler von Anfängern</a></li>
<li><a href="../de416015/index.html">Spielen mit Threads in Node.JS 10.5.0</a></li>
<li><a href="../de416017/index.html">Wir sammeln Kohortenanalyse / Analyse von Flüssen am Beispiel von Excel</a></li>
<li><a href="../de416019/index.html">Wie gut ist das Open-Source-Ökosystem von R für die Lösung von Geschäftsproblemen?</a></li>
<li><a href="../de416021/index.html">Entwickeln Sie Ihr eigenes Framework und das berufliche Wachstum eines JS-Programmierers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>