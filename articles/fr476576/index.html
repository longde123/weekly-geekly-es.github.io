<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§õüèº üé≠ üë© JSON-RPC? Prenez le REST d√©licat ‚òÉÔ∏è üö∫ üßòüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je suis s√ªr que le titre a provoqu√© une r√©action saine - "Eh bien, √ßa a recommenc√© ..." 


 La structure de l'article sera la suivante: une d√©claratio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JSON-RPC? Prenez le REST d√©licat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476576/"><p><img src="https://habrastorage.org/webt/q0/at/ek/q0atekvadeakqoxlbkht27oxt8c.jpeg"></p><br><p>  Je suis s√ªr que le titre a provoqu√© une r√©action saine - "Eh bien, √ßa a recommenc√© ..." </p><br><p> La structure de l'article sera la suivante: une d√©claration st√©r√©otyp√©e est prise et la ¬´nature¬ª de l'√©mergence de ce st√©r√©otype est r√©v√©l√©e.  J'esp√®re que cela vous permet de consid√©rer le choix du paradigme d'√©change de donn√©es dans vos projets sous un nouvel angle. </p><br><p>  Afin de clarifier ce qu'est le RPC, je propose de consid√©rer la norme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JSON-RPC 2.0</a> .  Il n'y a aucune clart√© avec REST.  Et √ßa ne devrait pas l'√™tre.  Tout ce que vous devez savoir sur REST - il est impossible de le distinguer de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HTTP</a> . </p><a name="habracut"></a><br><h2 id="rpc-zaprosy-bystree-i-effektivnee-potomu-chto-pozvolyayut-delat-batch-zaprosy">  Les demandes RPC sont plus rapides et plus efficaces car elles autorisent les demandes par lots. </h2><br><p>  Le fait est que dans RPC, il est possible d'appeler plusieurs proc√©dures en une seule demande.  Par exemple, cr√©ez un utilisateur, ajoutez-lui un avatar et, dans la m√™me demande, signez-le sur certains sujets.  Une seule demande, et combien de bien! </p><br><p>  En effet, si vous n'avez qu'un seul n≈ìud backend, cela vous semblera plus rapide avec une requ√™te batch.  Parce que trois demandes REST n√©cessiteront trois fois plus de ressources √† partir d'un n≈ìud pour √©tablir des connexions. </p><br><p><img src="https://habrastorage.org/webt/wd/o9/yy/wdo9yyuiainix3lto2vtfwl4jtu.jpeg"></p><br><p>  Veuillez noter que la premi√®re demande dans le cas de REST doit renvoyer l'ID utilisateur pour les demandes suivantes.  Ce qui affecte √©galement n√©gativement le r√©sultat global. </p><br><p>  Mais de telles infrastructures peuvent √™tre trouv√©es, peut-√™tre, dans des solutions internes et Enterprise.  En dernier recours, dans les petits projets WEB.  Mais les solutions WEB √† part enti√®re, et √©galement appel√©es HighLoad, ne devraient pas √™tre construites comme √ßa.  Leur infrastructure doit r√©pondre aux crit√®res de haute disponibilit√© et de charge de travail.  Et l'image change. </p><br><p><img src="https://habrastorage.org/webt/q5/x_/js/q5x_js3bh9se9vzjejgpyqfeexq.jpeg"></p><br><p>  Le vert indique les canaux d'activit√© d'infrastructure dans le m√™me sc√©nario.  Remarquez comment RPC se comporte maintenant.  La demande n'utilise l'infrastructure qu'une seule √©paule de l'√©quilibreur au serveur principal.  Alors que REST perd toujours dans la premi√®re demande, mais compense le temps perdu en utilisant toute l'infrastructure. </p><br><p>  Il suffit d'entrer dans le script non pas deux demandes d'enrichissement, mais, disons, cinq ou dix ... et la r√©ponse √† la question ¬´qui gagne maintenant?¬ª Ne devient pas √©vidente. </p><br><p>  Je propose d'√©tudier encore plus le probl√®me.  Le diagramme montre comment les canaux d'infrastructure sont utilis√©s, mais l'infrastructure n'est pas limit√©e aux canaux.  Les caches constituent un √©l√©ment important d'une infrastructure fortement charg√©e.  Prenons maintenant un artefact utilisateur.  Plusieurs fois.  Dites 32 fois. </p><br><p><img src="https://habrastorage.org/webt/vp/ts/es/vptseszry2ujpaxxlorxj5dk3gu.jpeg"></p><br><p>  D√©couvrez comment l'infrastructure du RPC s'est visiblement ¬´r√©tablie¬ª pour r√©pondre aux exigences d'une charge √©lev√©e.  Le fait est que REST utilise toute la puissance du protocole HTTP, contrairement √† RPC.  Dans le diagramme ci-dessus, cette puissance est r√©alis√©e par la m√©thode de demande - GET. </p><br><p>  Les m√©thodes HTTP, entre autres, ont des strat√©gies de mise en cache.  Vous pouvez les conna√Ætre dans la documentation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HTTP</a> .  Pour RPC, des requ√™tes POST qui ne sont pas consid√©r√©es comme idempotentes sont utilis√©es, c'est-√†-dire que la r√©p√©tition r√©p√©t√©e des m√™mes requ√™tes POST peut retourner des r√©sultats diff√©rents (par exemple, apr√®s l'envoi de chaque commentaire, une autre copie de ce commentaire appara√Ætra) ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">source</a> ). </p><br><p>  Par cons√©quent, les RPC ne sont pas en mesure d'utiliser efficacement les caches d'infrastructure.  Cela conduit au fait que vous devez ¬´importer¬ª des caches logiciels.  Le diagramme montre Redis dans ce r√¥le.  Le cache virtuel, √† son tour, n√©cessite pour le d√©veloppeur une couche de code suppl√©mentaire et des changements importants dans l'architecture. </p><br><p>  Calculons maintenant combien de demandes "ont donn√© naissance" √† REST et RPC dans l'infrastructure consid√©r√©e? </p><br><div class="scrollable-table"><table><thead><tr><th>  Demandes </th><th>  Bo√Æte de r√©ception </th><th>  soutenir </th><th>  au SGBD </th><th>  vers le cache virtuel (Redis) </th><th>  TOTAL </th></tr></thead><tbody><tr><td>  REPOS </td><td>  1/32 * </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  3/35 </td></tr><tr><td>  Rpc </td><td>  32 </td><td>  32 </td><td>  1 </td><td>  31 </td><td>  96 </td></tr></tbody></table></div><br><p>  [*] dans le meilleur des cas (si le cache local est utilis√©) 1 requ√™te (une!), dans les 32 pires requ√™tes entrantes. </p><br><p>  Par rapport au premier sch√©ma, la diff√©rence est frappante.  La victoire au REST est maintenant apparente.  Mais je propose de ne pas en rester l√†.  L'infrastructure d√©velopp√©e comprend CDN.  Souvent, il r√©sout √©galement le probl√®me de la lutte contre les attaques DDoS et DoS.  Nous obtenons: </p><br><p><img src="https://habrastorage.org/webt/k2/9f/ky/k29fkywcpnld_poisd1s7g9oxhs.jpeg"></p><br><p>  Ici pour RPC, tout devient tr√®s d√©plorable.  RPC n'est tout simplement pas en mesure de d√©l√©guer le travail avec le chargement CDN.  On ne peut compter que sur des syst√®mes pour contrer les attaques. </p><br><p>  Est-il possible de mettre fin √† cela?  Et encore une fois, non.  Les m√©thodes HTTP, comme mentionn√© ci-dessus, ont leur propre ¬´magie¬ª.  Et pour cause, la m√©thode GET est totalement utilis√©e sur Internet.  Veuillez noter que cette m√©thode est capable d'acc√©der √† une partie du contenu, est capable de d√©finir des conditions qui peuvent interpr√©ter les √©l√©ments d'infrastructure avant de transf√©rer le contr√¥le √† votre code, etc.  Tout cela vous permet de cr√©er des infrastructures flexibles et g√©rables qui peuvent dig√©rer de tr√®s gros flux de demandes.  Et dans RPC, cette m√©thode ... est ignor√©e. </p><br><p>  Alors pourquoi le mythe est-il si persistant que les requ√™tes par lots (RPC) sont plus rapides?  Personnellement, il me semble que la plupart des projets n'atteignent tout simplement pas un tel niveau de d√©veloppement lorsque REST est en mesure de montrer sa force.  De plus, dans les petits projets, il est plus susceptible de montrer sa faiblesse. </p><br><p>  Le choix de REST ou RPC n'est pas un choix volontaire d'un individu dans le projet.  Ce choix doit r√©pondre aux exigences du projet.  Si le projet est capable d'extraire de REST tout ce qu'il peut vraiment, et c'est vraiment n√©cessaire, alors REST sera un excellent choix. </p><br><p>  Mais si pour obtenir tous les b√©n√©fices REST, vous devrez embaucher des d√©veloppeurs pour faire √©voluer rapidement l'infrastructure, des administrateurs pour g√©rer l'infrastructure, un architecte pour concevoir toutes les couches du service WEB ... et le projet vendra trois packs de margarine par jour ... I arr√™terait sur RPC depuis  ce protocole est plus utilitaire.  Il ne n√©cessite pas une connaissance approfondie du fonctionnement des caches et de l'infrastructure, mais concentre le d√©veloppeur sur des appels simples et compr√©hensibles aux proc√©dures n√©cessaires.  L'entreprise sera ravie. </p><br><h2 id="rpc-zaprosy-nadezhnee-potomu-chto-mogut-vypolnyat-batch-zaprosy-v-ramkah-odnoy-tranzakcii">  Les demandes RPC sont plus fiables car elles peuvent ex√©cuter des demandes par lots en une seule transaction </h2><br><p>  Cette propri√©t√© de RPC est un avantage certain, car  facile √† maintenir la base de donn√©es dans un √©tat coh√©rent.  Mais avec REST, tout est plus compliqu√©.  Les demandes peuvent arriver de mani√®re incoh√©rente sur diff√©rents n≈ìuds principaux. </p><br><p>  Cet ¬´inconv√©nient¬ª de REST est le revers de ses avantages d√©crits ci-dessus - la capacit√© d'utiliser efficacement toutes les ressources de l'infrastructure.  Si l'infrastructure est mal con√ßue, et encore plus si l'architecture du projet et la base de donn√©es en particulier sont mal con√ßues, alors c'est vraiment une grosse douleur. </p><br><p>  Mais les demandes par lots sont-elles aussi fiables qu'elles le paraissent?  Regardons le cas: cr√©er un utilisateur, enrichir son profil avec une description et lui envoyer un SMS avec un secret pour terminer l'enregistrement.  C'est-√†-dire  trois appels en une seule demande group√©e. </p><br><p><img src="https://habrastorage.org/webt/i5/ry/4k/i5ry4k9evunfpvdeowewzqkpmkm.jpeg"></p><br><p>  Prenons le sch√©ma.  Il pr√©sente l'infrastructure avec des √©l√©ments de haute disponibilit√©.  Il existe deux canaux de communication ind√©pendants avec des passerelles SMS.  Mais ... que voyons-nous?  Lors de l'envoi de SMS, l'erreur 503 se produit - le service est temporairement indisponible.  Parce que  l'envoi de SMS est conditionn√© dans une demande par lots, puis la demande enti√®re doit √™tre annul√©e.  Les actions dans le SGBD sont annul√©es.  Le client re√ßoit une erreur. </p><br><p>  La prochaine tentative est une loterie.  Soit la demande va de nouveau au m√™me n≈ìud et renvoie une erreur, soit vous avez de la chance et elle sera ex√©cut√©e.  Mais l'essentiel est qu'au moins une fois que notre infrastructure a d√©j√† fonctionn√© en vain.  Il y avait une charge, mais pas de profit. </p><br><p>  Eh bien, imaginons que nous avons tendu (!) Et pens√© √† l'option o√π la demande pourrait √™tre partiellement termin√©e avec succ√®s.  Et le reste, nous essaierons √† nouveau de remplir apr√®s un certain intervalle de temps (lequel? D√©cide du front?).  Mais la loterie est rest√©e.  Une demande d'envoi d'un SMS avec une probabilit√© de 50/50 √©chouera √† nouveau. </p><br><p>  D'accord, c√¥t√© client, le service ne semble pas aussi fiable que nous le souhaiterions ... mais qu'en est-il de REST? </p><br><p><img src="https://habrastorage.org/webt/yu/ol/yy/yuolyyficausbg8c3jgzmddc1kk.jpeg"></p><br><p>  REST utilise √† nouveau la magie HTTP, mais maintenant avec des codes de r√©ponse.  Si une erreur 503 se produit sur la passerelle SMS, le backend diffuse cette erreur √† l'√©quilibreur.  L'√©quilibreur recevant cette erreur et sans rompre la connexion avec le client envoie une demande √† un autre n≈ìud qui traite correctement la demande.  C'est-√†-dire  le client obtient le r√©sultat escompt√© et l'infrastructure confirme son rang √©lev√© de ¬´tr√®s accessible¬ª.  L'utilisateur est content. </p><br><p>  Et encore une fois, ce n'est pas tout.  L'√©quilibreur n'a pas simplement re√ßu le code de r√©ponse 503. Il est conseill√© de fournir ce code avec l'en-t√™te "R√©essayer apr√®s" lors de la r√©ponse. L'en-t√™te indique clairement √† l'√©quilibreur que vous ne devez pas perturber ce n≈ìud sur cette route pendant une dur√©e sp√©cifi√©e. Et les SMS suivants envoyant des demandes sera envoy√© imm√©diatement √† un n≈ìud qui n'a aucun probl√®me avec la passerelle SMS. </p><br><p>  Comme nous pouvons le voir, la fiabilit√© de JSON-RPC est sur√©valu√©e.  En effet, il est plus facile d'organiser la coh√©rence de la base de donn√©es.  Mais la victime, dans ce cas, sera la fiabilit√© du syst√®me dans son ensemble. </p><br><p>  La conclusion est largement similaire √† la pr√©c√©dente.  Lorsque l'infrastructure est simple, l'√©vidence de JSON-RPC est sans aucun doute son plus.  Si un projet implique une haute disponibilit√© avec une charge √©lev√©e, REST ressemble √† une solution plus pr√©cise, quoique plus complexe. </p><br><h2 id="porog-vhoda-v-rest-nizhe">  Seuil d'entr√©e REST en dessous </h2><br><p>  Je pense que l'analyse ci-dessus, d√©mystifiant les st√©r√©otypes √©tablis sur le RPC, a clairement montr√© que le seuil d'entr√©e dans le REST est sans aucun doute plus √©lev√© que dans le RPC.  Cela est d√ª √† la n√©cessit√© d'une compr√©hension approfondie de HTTP, ainsi qu'√† la n√©cessit√© d'avoir une connaissance suffisante des √©l√©ments d'infrastructure existants qui peuvent et doivent √™tre utilis√©s dans les projets WEB. </p><br><p>  Alors pourquoi beaucoup de gens pensent que REST sera plus facile?  Mon opinion personnelle est que cette apparente simplicit√© vient du REST qui se manifeste.  C'est-√†-dire  REST n'est pas un protocole, mais un concept ... REST n'a pas de standard, il y a quelques recommandations ... REST n'est pas plus compliqu√© que HTTP.  La libert√© et l'anarchie apparentes attirent les ¬´artistes libres¬ª. </p><br><p>  Sans aucun doute, REST n'est pas plus compliqu√© que HTTP.  Mais HTTP lui-m√™me est un protocole bien con√ßu qui a fait ses preuves depuis des d√©cennies.  S'il n'y a pas de compr√©hension approfondie de HTTP lui-m√™me, alors REST ne peut pas √™tre jug√©. </p><br><p>  Mais √† propos de RPC - vous le pouvez.  Il suffit de prendre sa sp√©cification.  Avez-vous donc besoin d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JSON-RPC stupide</a> ?  Ou est-ce un REST rus√©?  √áa d√©pend de vous. </p><br><p>  J'esp√®re sinc√®rement que je n'ai pas perdu votre temps en vain. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr476576/">https://habr.com/ru/post/fr476576/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr476554/index.html">Streaming WebRTC bas√© sur le cloud sur DigitalOcean</a></li>
<li><a href="../fr476556/index.html">R√©cit et "donjons": comment un concepteur de jeux pour associer des lieux √† une intrigue</a></li>
<li><a href="../fr476558/index.html">Test ONYX BOOX Max 3: lecteur d'√©cran maximum</a></li>
<li><a href="../fr476566/index.html">Comment comprendre si les actifs num√©riques sont des titres? Instruction SEC</a></li>
<li><a href="../fr476570/index.html">Opinion priv√©e sur Yandex.Turbo</a></li>
<li><a href="../fr476578/index.html">9 avantages cl√©s de la technologie Blockchain dans les logiciels de sport</a></li>
<li><a href="../fr476580/index.html">Horizontal vs croissance verticale du d√©veloppeur. Opinions de ivi et Yandex</a></li>
<li><a href="../fr476582/index.html">Compteur DWT</a></li>
<li><a href="../fr476590/index.html">Comment emballer l'application VueJS + NodeJS + MongoDB dans Docker</a></li>
<li><a href="../fr476592/index.html">CLRium # 6: 9 jours restants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>