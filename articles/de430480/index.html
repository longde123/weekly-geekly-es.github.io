<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏊 💫 🙋🏿 Wie wir die Anwendung beim NASA Space Apps Challenge Hackathon geschrieben haben 👩🏻‍💻 🍞 🖕🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vom 20. bis 21. Oktober fand in Moskau der internationale Hackathon der NASA Space Apps Challenge statt. Die Organisatoren in Russland waren Leute aus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir die Anwendung beim NASA Space Apps Challenge Hackathon geschrieben haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/singularis/blog/430480/">  Vom 20. bis 21. Oktober fand in Moskau der internationale Hackathon der <strong>NASA Space Apps Challenge</strong> statt.  Die Organisatoren in Russland waren Leute aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Russian.Hackers-</a> Community.  Im Rahmen der Veranstaltung wurden die Teilnehmer gebeten, 20 Fälle zu verschiedenen Themen zu lösen: von der Aufnahme eines Films über den Hackathon über die Entwicklung von Überwachungsanwendungen bis hin zum Entwurf autonomer Flugzeuge.  Die vollständige Liste der Themen kann durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bezugnahme</a> oder in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel über Habré studiert werden</a> . <br><img src="https://habrastorage.org/webt/zb/xr/n8/zbxrn8ng1jnvhth73omf4dgorbe.png"><br>  Unser Team „Space Monkeys“, zu dem Oleg Borodin (Front-End-Entwickler im Singularis-Labor), Vladislav Plotnikov (QS-Ingenieur im Singularis-Labor), Jegor Shvetsov, Dmitri Petrow, Juri Bederow und Nikolai Denisenko gehörten, beschlossen, das Problem unter dem Eingängigen zu lösen mit dem Titel „Spot that fire!“, der wie folgt lautet: „ <em>Wenden Sie Crowdsourcing an, damit Menschen zur Erkennung, Bestätigung und Verfolgung von Waldbränden beitragen können.</em>  <em>Die Lösung könnte eine mobile oder eine Webanwendung sein.</em>  ” <br><br>  Aufgrund der Tatsache, dass das Team 5 Entwickler mit Erfahrung in der Entwicklung für verschiedene Plattformen gesammelt hat, wurde sofort entschieden, dass der Prototyp unserer Anwendung für Web- und Mobile-Plattformen implementiert wird. <br><a name="habracut"></a><br><h2>  Welche NASA-Daten haben wir verwendet? </h2><br><p>  Trotzdem wurde der Hackathon unter der Schirmherrschaft der National Aeronautics and Space Administration abgehalten, daher wäre es falsch, keine offenen Daten aus den Vorratskammern der NASA zu verwenden.  Außerdem haben wir sofort den benötigten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Active Fire Data-</a> Datensatz gefunden.  Dieser Datensatz enthält Informationen zu den Koordinaten von Bränden auf der ganzen Welt (Sie können Informationen zu einem bestimmten Kontinent herunterladen).  Die Daten werden täglich aktualisiert (Sie können Daten für 24 Stunden, 48 Stunden, 7 Tage erhalten). </p><br><p>  Die Datei enthält Informationen zu folgenden Feldern: Breite, Länge, Helligkeit, Scan, Track, acq_date, acq_time, Satellit, Vertrauen, Version, bright_t31, frp, Tag und Nacht, von denen wir nur die Koordinaten der Feuerpunkte (Breite und Länge) verwendet haben. </p><br><h2>  Das Prinzip der Anwendung </h2><br><p>  Da es sich bei der Anwendung um Crowdsourcing handelt, sollte sie idealerweise von einer großen Anzahl von Benutzern verwendet werden.  Das Prinzip der Anwendung ist wie folgt: </p><br><ol><li><p>  Nachdem der Benutzer ein Feuer entdeckt hat, macht er ein Bild davon (mit Geo-Tagging) und lädt es über den Dienst.  Fotos mit Geo-Tags und Sendekoordinaten werden an den Anwendungsserver gesendet.  Die Fotografie kann aus der Web- oder Mobile-Version der Anwendung heruntergeladen werden. </p></li><li><p>  Das resultierende Foto wird auf dem Server von einem trainierten neuronalen Netzwerk verarbeitet, um zu bestätigen, dass das Foto wirklich in Flammen steht.  Das Ergebnis des Skripts ist die Genauigkeit der Vorhersage. Wenn&gt; 0,7, wird das Foto wirklich ausgelöst.  Andernfalls zeichnen wir diese Informationen nicht auf und bitten den Benutzer, ein weiteres Foto hochzuladen. </p></li><li><p>  Wenn das Bildanalyseskript ein positives Ergebnis liefert, werden die Koordinaten des Geotags mit allen Koordinaten zum Datensatz hinzugefügt.  Als nächstes werden die Abstände zwischen dem <em>i-</em> ten Punkt aus dem NASA-Datensatz und dem Punkt vom Benutzer berechnet.  Wenn der Abstand zwischen den Punkten <strong>≤</strong> 3 km beträgt, wird der Punkt aus dem NASA-Set zum Wörterbuch hinzugefügt.  Also gehen wir alle Punkte durch.  Geben Sie danach json mit Koordinaten, die die Bedingung erfüllen, an die Clientseite der Anwendung zurück.  Wenn durch die gegebene Bedingung keine Koordinaten gefunden werden, geben wir den einzigen Punkt zurück, den wir vom Benutzer erhalten haben. </p></li><li><p>  Wenn der Server ein Array von Punkten zurückgibt, zeichnet der Client-Teil der Anwendung eine Brandzone auf der Karte.  Falls der Server einen Punkt zurückgegeben hat, ist dieser auf der Karte mit einer speziellen Beschriftung gekennzeichnet. </p></li></ol><br><h2>  Verwendeter Technologie-Stack </h2><br><h3>  <em>Front-End-Teil der Webanwendung</em> </h3><br><p>  Die Webanwendung, auf die über einen Browser zugegriffen werden kann, konzentrierte sich auf Computerbildschirme und war nicht anpassungsfähig. Die verwendeten Technologien ermöglichten es jedoch, diesen Aspekt für mobile Geräte zu verfeinern.  Wir haben den folgenden Technologie-Stack auf der Webseite verwendet: </p><br><ul><li>  Googles Angular 6 TypeScript Framework </li><li>  CSS &amp; JS Framework materialisieren </li><li>  Modul zum Herunterladen von Dateien <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ng2-Datei-Upload</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenStreetMap-</a> Karten, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Broschürenbibliothek</a> </li></ul><br><h4>  Arbeitsszenario </h4><br><p>  Der Benutzer öffnet die Anwendung und sieht seinen Standort: </p><br><img src="https://habrastorage.org/webt/p2/j1/uk/p2j1ukxxirwd_5ch-rsaje4sflc.jpeg"><br><br><p>  Initialisierung der Karte und des Benutzer-Geos: </p><br><pre><code class="plaintext hljs">this.map = L.map('map').setView([latitude, longitude], 17); L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&amp; copy; &lt;a href="https://www.openstreetmap.org/copyright"&gt;OpenStreetMap&lt;/a&gt; contributors' }).addTo(this.map); L.circle([latitude, longitude]).addTo(this.map) .bindPopup('You are here') .openPopup();</code> </pre> <br><p>  Wenn im Radius <em>n</em> (benutzerdefinierte Variable) von Kilometern ein Brand auftritt, wird dieser in Form eines Polygons mit einer Zusammenfassung zusätzlicher Informationen angezeigt: </p><br><img src="https://habrastorage.org/webt/6q/1e/k5/6q1ek54slbxacie85pqrdsuwzko.jpeg"><br><br><p>  Der Benutzer wählt einen Brandort auf der Karte aus: </p><br><img src="https://habrastorage.org/webt/1t/qv/p9/1tqvp9ytbpe3r1kmwogvtviii34.jpeg"><br><br><p>  Fire Tag Einstellung: </p><br><pre> <code class="plaintext hljs">let marker; this.map.on('click', function (e) { if (marker) { self.map.removeLayer(marker); } marker = L.circle([e.latlng.lat, e.latlng.lng], { color: 'red', fillColor: '#f03', fillOpacity: 0.5, radius: 15 }).addTo(self.map) .bindPopup(' ') .openPopup(); self.appService.coordinatesStorage.latitude = e.latlng.lat; self.appService.coordinatesStorage.longitude = e.latlng.lng; console.log('fire', self.appService.coordinatesStorage); });</code> </pre><br><p>  Als nächstes lädt der Benutzer ein Foto des Feuers mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ng2-file-upload hoch</a> . </p><br><p>  Infolge dieser Aktionen werden die folgenden Daten an den Server übertragen: </p><br><ul><li>  Benutzerkoordinaten </li><li>  Koordinaten des angegebenen Feuers </li><li>  Feuerfoto </li></ul><br><p>  Die Ausgabe der Anwendung ist das Erkennungsergebnis. </p><br><br><h3>  <em>Mobile-App-Anwendungen</em> </h3><br><h4>  Verwendete Technologien </h4><br><ul><li>  React native - ein Framework für die Entwicklung plattformübergreifender Anwendungen für iOS und Android </li><li>  Redux - Steuerung des Anwendungsdatenflusses </li><li>  Redux-Saga - Bibliothek mit Nebenwirkungen in Redux </li></ul><br><h4>  Arbeitsszenario </h4><br><table><tbody><tr><td><p>  Feuerfotoauswahl <br><img src="https://habrastorage.org/webt/m_/n0/ex/m_n0exwfthzn0-yl3so514frun4.jpeg"><br></p><br></td><td><p>  Kommentar vom Benutzer <br><img src="https://habrastorage.org/webt/wg/u5/yd/wgu5ydugmpmcr0j5yaqg52721ia.jpeg"><br></p><br></td><td><p>  Brandzeichen <br><img src="https://habrastorage.org/webt/4g/hc/et/4ghceta2dtzzj3mwb8ry2ikc5ws.jpeg"><br></p><br></td></tr></tbody></table><br><h3>  <em>Backend-Teil der Anwendung</em> </h3><br><ul><li><p>  Programmiersprache - JAVA 8 </p></li><li><p>  Cloud-Plattform - Microsoft Azure </p></li><li><p>  Webanwendungs-Framework - Play Framework </p></li><li><p>  Objektrelationales Mapping - Ebean-Framework </p></li></ul><br><p>  Der Server verfügt über 2 in Python geschriebene Skripte: Predict.py und GetZone.py. Die folgenden Python-Bibliotheken wurden für ihre Arbeit installiert: </p><br><ul><li>  Pandas - zur Datenverarbeitung und -analyse </li><li>  Geopandas - für die Arbeit mit Geodaten </li><li>  numpy - zum Arbeiten mit mehrdimensionalen Arrays </li><li>  matplotlib - zur Visualisierung von zweidimensionalen (2D) Datengrafiken (3D-Grafiken werden ebenfalls unterstützt) </li><li>  formschön - zur Manipulation und Analyse flacher geometrischer Objekte. </li></ul><br><p>  Server-API: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fire.iconx.app/api</a> </p><br><ul><li>  Ladekoordinaten </li></ul><br><pre> <code class="plaintext hljs">post /pictures {} return { id }</code> </pre><br><ul><li>  Bild hochladen </li></ul><br><pre> <code class="plaintext hljs">post /pictures/:id</code> </pre><br><p>  <strong>Skript predigen.py</strong> </p><br><p>  Ein Eingabeskript erhielt ein Bild, eine einfache Bildvorverarbeitung fand statt (mehr dazu im Abschnitt „Modelltraining“) und basierend auf einer gespeicherten Datei mit Gewichten, die sich ebenfalls auf dem Server befindet, wurde eine Vorhersage ausgegeben.  Wenn das Modell eine Genauigkeit&gt; 0,7 erzeugt, ist das Feuer behoben, andernfalls - nein. </p><br><p>  Das Skript wird auf klassische Weise ausgeführt. </p><pre> <code class="plaintext hljs">$ python predict.py image.jpg</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Codeauflistung:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">import keras import sys from keras.layers import Dense from keras.models import model_from_json from sklearn.externals import joblib from PIL import Image import numpy as np from keras import models, layers, optimizers from keras.applications import MobileNet from keras.models import Sequential from keras.layers import Dense, Dropout, Flatten from keras.layers import Conv2D, MaxPooling2D def crop_resize(img_path, img_size_square): # Get dimensions mysize = img_size_square image = Image.open(img_path) width, height = image.size # resize if (width and height) &gt;= img_size_square: if width &gt; height: wpercent = (mysize/float(image.size[1])) vsize = int((float(image.size[0])*float(wpercent))) image = image.resize((vsize, mysize), Image.ANTIALIAS) else: wpercent = (mysize/float(image.size[0])) hsize = int((float(image.size[1])*float(wpercent))) image = image.resize((mysize, hsize), Image.ANTIALIAS) # crop width, height = image.size left = (width - mysize)/2 top = (height - mysize)/2 right = (width + mysize)/2 bottom = (height + mysize)/2 image=image.crop((left, top, right, bottom)) return image conv_base = MobileNet(weights='imagenet', include_top=False, input_shape=(224, 224, 3)) def build_model(): model = models.Sequential() model.add(conv_base) model.add(layers.Flatten()) model.add(layers.Dense(256, activation='relu')) model.add(layers.Dense(64, activation='relu')) model.add(layers.Dense(1, activation='sigmoid')) model.compile(loss='binary_crossentropy', optimizer=optimizers.RMSprop(lr=2e-5), metrics=['acc']) return model image=crop_resize(sys.argv[1],224) image = np.reshape(image,[1,224,224,3]) #Loading models and text processing model = build_model() print('building a model') model.load_weights('./models/mobile_weights.h5') print('model loaded') pred_cat=model.predict(image) if pred_cat &gt; 0.7: print('fire {}'.format(pred_cat)) else: print('no fire {}'.format(pred_cat))</code> </pre><br></div></div><br><br><p>  <strong>Skript getZone.py</strong> </p><br><p>  Die Eingabe in das Skript sind die Koordinaten des Punkts, der von der Clientseite der Anwendung stammt.  Das Skript verschärft alle Koordinaten der NASA, fügt dieser Datei einen neuen Breiten- und Längengrad hinzu, überschreibt die Originaldatei und sucht nach den nächsten Punkten.  Der Abstand zwischen Punkten wird nach der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haversine-Formel berechnet</a> . </p><br><p>  Dazu werden Breite und Länge der Punkte in Bogenmaß umgerechnet: </p><br><pre> <code class="plaintext hljs">pt1_lon, pt1_lat, pt2_lon, pt2_lat = map(radians, [pt1_lon, pt1_lat, pt2_lon, pt2_lat])</code> </pre><br><p>  Es gibt Unterschiede zwischen Breiten- und Längengrad für jeden der Punkte: </p><br><pre> <code class="plaintext hljs">d_lon = pt2_lon - pt1_lon d_lat = pt2_lat - pt1_lat</code> </pre><br><p>  All dies wird in die Haversinformel eingesetzt: </p><br><pre> <code class="plaintext hljs">a = sin(d_lat/2)**2 + cos(pt1_lat) * cos(pt2_lat) * sin(d_lon/2)**2</code> </pre><br><p>  Wir nehmen die Wurzel des Berechnungsergebnisses, berechnen den Arkussinus und multiplizieren das Ergebnis mit 2. </p><br><pre> <code class="plaintext hljs">c = 2 * asin(sqrt(a))</code> </pre><br><p>  Die Entfernung ergibt sich aus dem Radius der Erde (6371 km) und dem Ergebnis der vorherigen Berechnung. </p><br><h2>  Modelltraining </h2><br><p>  Um das Bild für ein Feuer zu analysieren, brauchten wir einen Trainingssatz mit Fotos mit Feuer.  Fotos wurden mit einem Skript von der Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.flickr.com/</a> gesammelt und manuell markiert. </p><br><p>  Der Download erfolgte mit FlikerAPI.  Das Skript führte Standardvorverarbeitungsvorgänge mit Bildern durch: Zuschneiden - Quadrat mit Zentrierung (Verhältnis 1: 1) und Größenänderung auf das Format 256 × 256. </p><br><div class="spoiler">  <b class="spoiler_title">Codeauflistung:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">import flickrapi import urllib.request from PIL import Image import pathlib import os from tqdm import tqdm # Flickr api access key flickr=flickrapi.FlickrAPI('your API key', 'your secret key', cache=True) def get_links(): search_term = input("Input keywords for images: ") keyword = search_term max_pics=2000 photos = flickr.walk(text=keyword, tag_mode='all', tags=keyword, extras='url_c', per_page=500, # mb you can try different numbers.. sort='relevance') urls = [] for i, photo in enumerate(photos): url = photo.get('url_c') if url is not None: urls.append(url) if i &gt; max_pics: break num_of_pics=len(urls) print('total urls:',len(urls)) # print number of images available for a keywords return urls, keyword, num_of_pics #resizing and cropping output images will be besquare def crop_resize(img_path, img_size_square): # Get dimensions mysize = img_size_square image = Image.open(img_path) width, height = image.size # resize if (width and height) &gt;= img_size_square: if width &gt; height: wpercent = (mysize/float(image.size[1])) vsize = int((float(image.size[0])*float(wpercent))) image = image.resize((vsize, mysize), Image.ANTIALIAS) else: wpercent = (mysize/float(image.size[0])) hsize = int((float(image.size[1])*float(wpercent))) image = image.resize((mysize, hsize), Image.ANTIALIAS) # crop width, height = image.size left = (width - mysize)/2 top = (height - mysize)/2 right = (width + mysize)/2 bottom = (height + mysize)/2 image=image.crop((left, top, right, bottom)) return image def download_images(urls_,keyword_, num_of_pics_): num_of_pics=num_of_pics_ keyword=keyword_ urls=urls_ i=0 base_path='./flickr_data/' # your base folder to save pics for item in tqdm(urls): name=''.join([keyword,'_',str(i),'.jpg']) i+=1 keyword_=''.join([keyword,'_',str(num_of_pics)]) dir_path= os.path.join(base_path,keyword_) file_path=os.path.join(dir_path,name) pathlib.Path(dir_path).mkdir(parents=True, exist_ok=True) urllib.request.urlretrieve(item, file_path) resized_img=crop_resize(file_path, 256) #set output image size try: resized_img.save(file_path) except: pass urls, keyword, num_of_pics =get_links() continue = input("continue or try other keywords (y,n): ") if continue =='y': download_images(urls, keyword, num_of_pics) elif continue =='n': get_links() else: pass</code> </pre><br></div></div><br><p>  Natürlich wurde die Faltungsarchitektur des neuronalen Netzwerks, in der das vorab trainierte Modell verwendet wurde, verwendet, um mit Bildern zu arbeiten.  Die Wahl fiel auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MobileNet</a> (erwartet), weil: </p><br><ul><li>  Leichtgewicht - Es ist wichtig, dass die Reaktionszeit der Anwendung minimal ist. </li><li>  Schnell - Es ist wichtig, dass die Antwortzeit der Anwendung minimal ist. </li><li>  Genau - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>MobileNet</em></a> sagt mit der erforderlichen Genauigkeit voraus. </li></ul><br><p>  Nach dem Training ergab das Netzwerk eine Genauigkeit von ~ 0,85. </p><br><p>  Um das Modell, das Training und die Vorhersage zu erstellen, wurde eine Reihe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Keras</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tensorflow verwendet</a> .  Die Arbeit mit Daten wurde über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pandas durchgeführt</a> . </p><br><p>  Da es sich bei dem NASA DataSet um geografische Daten handelt, wollten wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GeoPandas-</a> Bibliothek verwenden.  Diese Bibliothek ist eine Erweiterung der Funktionen von Pandas zur Bereitstellung räumlicher Methoden und Operationen für geometrische Typen.  Geometrische Operationen werden durch die formschöne Bibliothek implementiert, arbeiten mit Dateien - Fiona, Graphing - Matplotlib. </p><br><p>  Nachdem wir fast anderthalb Tage damit verbracht hatten, diese Bibliothek herauszufinden, gaben wir sie auf, weil wir nicht herausfinden konnten, wo sie uns einen echten Vorteil aus der Arbeit mit ihr verschaffen könnte.  Unsere Aufgabe, die Koordinaten zu berechnen, war sehr klein, so dass am Ende alles nativ implementiert wurde. </p><br><h2>  Was weiter? </h2><br><p>  Alles, was wir als Ergebnis erhalten haben, ist natürlich eine äußerst instabile und grobe Anwendung, die das Recht hat, abgeschlossen zu werden. </p><br><p>  Es ist uns gelungen: </p><br><ol><li>  Implementieren Sie Prototypen von Mobil- und Webanwendungen, die Fotos aufnehmen konnten (nur mobile Version), hochladen und an den Server senden konnten.  Außerdem werden die Koordinaten für das erfolgreiche Senden an den Server gesendet. </li><li>  Auf dem Server konnten zwei Skripte bereitgestellt werden, die die Hauptlogik der Anwendung implementieren.  Der Fluss der Eingabedaten zu diesen Skripten und der Empfang der Ausgabedaten mit anschließendem Senden an den Client-Teil wurde arrangiert. </li><li>  Implementieren Sie den echten „Prototyp“ unserer Anwendung. </li></ol><br><p>  Wir haben es nicht geschafft, es zu implementieren, aber ich möchte die folgenden Probleme lösen und Funktionen hinzufügen (die Elemente richten sich nach der Priorität der Aufgabe): </p><br><ol><li>  Organisieren Sie die Aufzeichnung aller Koordinaten aus dem Datensatz in der Datenbank, um direkt mit der Datenbank zu interagieren. </li><li>  Organisieren Sie das automatische Hochladen einer neuen Datei von der NASA-Website, d. H.  Organisieren Sie automatische tägliche Koordinatenaktualisierungen. </li><li>  Fügen Sie Benachrichtigungen für Benutzer hinzu, die sich in der Nähe des Feuers befinden. </li><li>  Registrierung hinzufügen (erforderlich, um den ersten Absatz zu implementieren). </li><li>  Schreiben Sie den Algorithmus zur Berechnung der Brandzone neu. </li><li>  Lösen Sie Designaufgaben - bringen Sie Schönheit in die Mobil- und Webversionen der Anwendung. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430480/">https://habr.com/ru/post/de430480/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430470/index.html">Warum den Kontext auf dem Kundenkonto pflegen - ehrlich und profitabel</a></li>
<li><a href="../de430472/index.html">DIY nahtloses DECT-Netzwerk</a></li>
<li><a href="../de430474/index.html">CephFS vs GlusterFS</a></li>
<li><a href="../de430476/index.html">NCBI Genome Workbench: Gefährdete Forschung</a></li>
<li><a href="../de430478/index.html">Trading Bots für den Kryptowährungsmarkt. Wo soll ich anfangen?</a></li>
<li><a href="../de430482/index.html">Das Thema der Panzerplatten in der Kultur von Ost und West</a></li>
<li><a href="../de430484/index.html">Typische NGFW-Implementierungsszenarien</a></li>
<li><a href="../de430486/index.html">Wie Freiberufler leben: vom Entwickler zum technischen Texter</a></li>
<li><a href="../de430488/index.html">Asynchroner Datenaustausch mit einer Remote-Anwendung über SSH</a></li>
<li><a href="../de430490/index.html">Vorwegnehmen, aufklären, entscheiden: Wie und warum EPAM das Java Competency Center aufbaut</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>