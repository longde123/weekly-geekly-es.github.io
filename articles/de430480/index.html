<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèä üí´ üôãüèø Wie wir die Anwendung beim NASA Space Apps Challenge Hackathon geschrieben haben üë©üèª‚Äçüíª üçû üñïüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vom 20. bis 21. Oktober fand in Moskau der internationale Hackathon der NASA Space Apps Challenge statt. Die Organisatoren in Russland waren Leute aus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir die Anwendung beim NASA Space Apps Challenge Hackathon geschrieben haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/singularis/blog/430480/">  Vom 20. bis 21. Oktober fand in Moskau der internationale Hackathon der <strong>NASA Space Apps Challenge</strong> statt.  Die Organisatoren in Russland waren Leute aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Russian.Hackers-</a> Community.  Im Rahmen der Veranstaltung wurden die Teilnehmer gebeten, 20 F√§lle zu verschiedenen Themen zu l√∂sen: von der Aufnahme eines Films √ºber den Hackathon √ºber die Entwicklung von √úberwachungsanwendungen bis hin zum Entwurf autonomer Flugzeuge.  Die vollst√§ndige Liste der Themen kann durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bezugnahme</a> oder in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel √ºber Habr√© studiert werden</a> . <br><img src="https://habrastorage.org/webt/zb/xr/n8/zbxrn8ng1jnvhth73omf4dgorbe.png"><br>  Unser Team ‚ÄûSpace Monkeys‚Äú, zu dem Oleg Borodin (Front-End-Entwickler im Singularis-Labor), Vladislav Plotnikov (QS-Ingenieur im Singularis-Labor), Jegor Shvetsov, Dmitri Petrow, Juri Bederow und Nikolai Denisenko geh√∂rten, beschlossen, das Problem unter dem Eing√§ngigen zu l√∂sen mit dem Titel ‚ÄûSpot that fire!‚Äú, der wie folgt lautet: ‚Äû <em>Wenden Sie Crowdsourcing an, damit Menschen zur Erkennung, Best√§tigung und Verfolgung von Waldbr√§nden beitragen k√∂nnen.</em>  <em>Die L√∂sung k√∂nnte eine mobile oder eine Webanwendung sein.</em>  ‚Äù <br><br>  Aufgrund der Tatsache, dass das Team 5 Entwickler mit Erfahrung in der Entwicklung f√ºr verschiedene Plattformen gesammelt hat, wurde sofort entschieden, dass der Prototyp unserer Anwendung f√ºr Web- und Mobile-Plattformen implementiert wird. <br><a name="habracut"></a><br><h2>  Welche NASA-Daten haben wir verwendet? </h2><br><p>  Trotzdem wurde der Hackathon unter der Schirmherrschaft der National Aeronautics and Space Administration abgehalten, daher w√§re es falsch, keine offenen Daten aus den Vorratskammern der NASA zu verwenden.  Au√üerdem haben wir sofort den ben√∂tigten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Active Fire Data-</a> Datensatz gefunden.  Dieser Datensatz enth√§lt Informationen zu den Koordinaten von Br√§nden auf der ganzen Welt (Sie k√∂nnen Informationen zu einem bestimmten Kontinent herunterladen).  Die Daten werden t√§glich aktualisiert (Sie k√∂nnen Daten f√ºr 24 Stunden, 48 Stunden, 7 Tage erhalten). </p><br><p>  Die Datei enth√§lt Informationen zu folgenden Feldern: Breite, L√§nge, Helligkeit, Scan, Track, acq_date, acq_time, Satellit, Vertrauen, Version, bright_t31, frp, Tag und Nacht, von denen wir nur die Koordinaten der Feuerpunkte (Breite und L√§nge) verwendet haben. </p><br><h2>  Das Prinzip der Anwendung </h2><br><p>  Da es sich bei der Anwendung um Crowdsourcing handelt, sollte sie idealerweise von einer gro√üen Anzahl von Benutzern verwendet werden.  Das Prinzip der Anwendung ist wie folgt: </p><br><ol><li><p>  Nachdem der Benutzer ein Feuer entdeckt hat, macht er ein Bild davon (mit Geo-Tagging) und l√§dt es √ºber den Dienst.  Fotos mit Geo-Tags und Sendekoordinaten werden an den Anwendungsserver gesendet.  Die Fotografie kann aus der Web- oder Mobile-Version der Anwendung heruntergeladen werden. </p></li><li><p>  Das resultierende Foto wird auf dem Server von einem trainierten neuronalen Netzwerk verarbeitet, um zu best√§tigen, dass das Foto wirklich in Flammen steht.  Das Ergebnis des Skripts ist die Genauigkeit der Vorhersage. Wenn&gt; 0,7, wird das Foto wirklich ausgel√∂st.  Andernfalls zeichnen wir diese Informationen nicht auf und bitten den Benutzer, ein weiteres Foto hochzuladen. </p></li><li><p>  Wenn das Bildanalyseskript ein positives Ergebnis liefert, werden die Koordinaten des Geotags mit allen Koordinaten zum Datensatz hinzugef√ºgt.  Als n√§chstes werden die Abst√§nde zwischen dem <em>i-</em> ten Punkt aus dem NASA-Datensatz und dem Punkt vom Benutzer berechnet.  Wenn der Abstand zwischen den Punkten <strong>‚â§</strong> 3 km betr√§gt, wird der Punkt aus dem NASA-Set zum W√∂rterbuch hinzugef√ºgt.  Also gehen wir alle Punkte durch.  Geben Sie danach json mit Koordinaten, die die Bedingung erf√ºllen, an die Clientseite der Anwendung zur√ºck.  Wenn durch die gegebene Bedingung keine Koordinaten gefunden werden, geben wir den einzigen Punkt zur√ºck, den wir vom Benutzer erhalten haben. </p></li><li><p>  Wenn der Server ein Array von Punkten zur√ºckgibt, zeichnet der Client-Teil der Anwendung eine Brandzone auf der Karte.  Falls der Server einen Punkt zur√ºckgegeben hat, ist dieser auf der Karte mit einer speziellen Beschriftung gekennzeichnet. </p></li></ol><br><h2>  Verwendeter Technologie-Stack </h2><br><h3>  <em>Front-End-Teil der Webanwendung</em> </h3><br><p>  Die Webanwendung, auf die √ºber einen Browser zugegriffen werden kann, konzentrierte sich auf Computerbildschirme und war nicht anpassungsf√§hig. Die verwendeten Technologien erm√∂glichten es jedoch, diesen Aspekt f√ºr mobile Ger√§te zu verfeinern.  Wir haben den folgenden Technologie-Stack auf der Webseite verwendet: </p><br><ul><li>  Googles Angular 6 TypeScript Framework </li><li>  CSS &amp; JS Framework materialisieren </li><li>  Modul zum Herunterladen von Dateien <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ng2-Datei-Upload</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenStreetMap-</a> Karten, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Brosch√ºrenbibliothek</a> </li></ul><br><h4>  Arbeitsszenario </h4><br><p>  Der Benutzer √∂ffnet die Anwendung und sieht seinen Standort: </p><br><img src="https://habrastorage.org/webt/p2/j1/uk/p2j1ukxxirwd_5ch-rsaje4sflc.jpeg"><br><br><p>  Initialisierung der Karte und des Benutzer-Geos: </p><br><pre><code class="plaintext hljs">this.map = L.map('map').setView([latitude, longitude], 17); L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&amp; copy; &lt;a href="https://www.openstreetmap.org/copyright"&gt;OpenStreetMap&lt;/a&gt; contributors' }).addTo(this.map); L.circle([latitude, longitude]).addTo(this.map) .bindPopup('You are here') .openPopup();</code> </pre> <br><p>  Wenn im Radius <em>n</em> (benutzerdefinierte Variable) von Kilometern ein Brand auftritt, wird dieser in Form eines Polygons mit einer Zusammenfassung zus√§tzlicher Informationen angezeigt: </p><br><img src="https://habrastorage.org/webt/6q/1e/k5/6q1ek54slbxacie85pqrdsuwzko.jpeg"><br><br><p>  Der Benutzer w√§hlt einen Brandort auf der Karte aus: </p><br><img src="https://habrastorage.org/webt/1t/qv/p9/1tqvp9ytbpe3r1kmwogvtviii34.jpeg"><br><br><p>  Fire Tag Einstellung: </p><br><pre> <code class="plaintext hljs">let marker; this.map.on('click', function (e) { if (marker) { self.map.removeLayer(marker); } marker = L.circle([e.latlng.lat, e.latlng.lng], { color: 'red', fillColor: '#f03', fillOpacity: 0.5, radius: 15 }).addTo(self.map) .bindPopup(' ') .openPopup(); self.appService.coordinatesStorage.latitude = e.latlng.lat; self.appService.coordinatesStorage.longitude = e.latlng.lng; console.log('fire', self.appService.coordinatesStorage); });</code> </pre><br><p>  Als n√§chstes l√§dt der Benutzer ein Foto des Feuers mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ng2-file-upload hoch</a> . </p><br><p>  Infolge dieser Aktionen werden die folgenden Daten an den Server √ºbertragen: </p><br><ul><li>  Benutzerkoordinaten </li><li>  Koordinaten des angegebenen Feuers </li><li>  Feuerfoto </li></ul><br><p>  Die Ausgabe der Anwendung ist das Erkennungsergebnis. </p><br><br><h3>  <em>Mobile-App-Anwendungen</em> </h3><br><h4>  Verwendete Technologien </h4><br><ul><li>  React native - ein Framework f√ºr die Entwicklung plattform√ºbergreifender Anwendungen f√ºr iOS und Android </li><li>  Redux - Steuerung des Anwendungsdatenflusses </li><li>  Redux-Saga - Bibliothek mit Nebenwirkungen in Redux </li></ul><br><h4>  Arbeitsszenario </h4><br><table><tbody><tr><td><p>  Feuerfotoauswahl <br><img src="https://habrastorage.org/webt/m_/n0/ex/m_n0exwfthzn0-yl3so514frun4.jpeg"><br></p><br></td><td><p>  Kommentar vom Benutzer <br><img src="https://habrastorage.org/webt/wg/u5/yd/wgu5ydugmpmcr0j5yaqg52721ia.jpeg"><br></p><br></td><td><p>  Brandzeichen <br><img src="https://habrastorage.org/webt/4g/hc/et/4ghceta2dtzzj3mwb8ry2ikc5ws.jpeg"><br></p><br></td></tr></tbody></table><br><h3>  <em>Backend-Teil der Anwendung</em> </h3><br><ul><li><p>  Programmiersprache - JAVA 8 </p></li><li><p>  Cloud-Plattform - Microsoft Azure </p></li><li><p>  Webanwendungs-Framework - Play Framework </p></li><li><p>  Objektrelationales Mapping - Ebean-Framework </p></li></ul><br><p>  Der Server verf√ºgt √ºber 2 in Python geschriebene Skripte: Predict.py und GetZone.py. Die folgenden Python-Bibliotheken wurden f√ºr ihre Arbeit installiert: </p><br><ul><li>  Pandas - zur Datenverarbeitung und -analyse </li><li>  Geopandas - f√ºr die Arbeit mit Geodaten </li><li>  numpy - zum Arbeiten mit mehrdimensionalen Arrays </li><li>  matplotlib - zur Visualisierung von zweidimensionalen (2D) Datengrafiken (3D-Grafiken werden ebenfalls unterst√ºtzt) </li><li>  formsch√∂n - zur Manipulation und Analyse flacher geometrischer Objekte. </li></ul><br><p>  Server-API: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fire.iconx.app/api</a> </p><br><ul><li>  Ladekoordinaten </li></ul><br><pre> <code class="plaintext hljs">post /pictures {} return { id }</code> </pre><br><ul><li>  Bild hochladen </li></ul><br><pre> <code class="plaintext hljs">post /pictures/:id</code> </pre><br><p>  <strong>Skript predigen.py</strong> </p><br><p>  Ein Eingabeskript erhielt ein Bild, eine einfache Bildvorverarbeitung fand statt (mehr dazu im Abschnitt ‚ÄûModelltraining‚Äú) und basierend auf einer gespeicherten Datei mit Gewichten, die sich ebenfalls auf dem Server befindet, wurde eine Vorhersage ausgegeben.  Wenn das Modell eine Genauigkeit&gt; 0,7 erzeugt, ist das Feuer behoben, andernfalls - nein. </p><br><p>  Das Skript wird auf klassische Weise ausgef√ºhrt. </p><pre> <code class="plaintext hljs">$ python predict.py image.jpg</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Codeauflistung:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">import keras import sys from keras.layers import Dense from keras.models import model_from_json from sklearn.externals import joblib from PIL import Image import numpy as np from keras import models, layers, optimizers from keras.applications import MobileNet from keras.models import Sequential from keras.layers import Dense, Dropout, Flatten from keras.layers import Conv2D, MaxPooling2D def crop_resize(img_path, img_size_square): # Get dimensions mysize = img_size_square image = Image.open(img_path) width, height = image.size # resize if (width and height) &gt;= img_size_square: if width &gt; height: wpercent = (mysize/float(image.size[1])) vsize = int((float(image.size[0])*float(wpercent))) image = image.resize((vsize, mysize), Image.ANTIALIAS) else: wpercent = (mysize/float(image.size[0])) hsize = int((float(image.size[1])*float(wpercent))) image = image.resize((mysize, hsize), Image.ANTIALIAS) # crop width, height = image.size left = (width - mysize)/2 top = (height - mysize)/2 right = (width + mysize)/2 bottom = (height + mysize)/2 image=image.crop((left, top, right, bottom)) return image conv_base = MobileNet(weights='imagenet', include_top=False, input_shape=(224, 224, 3)) def build_model(): model = models.Sequential() model.add(conv_base) model.add(layers.Flatten()) model.add(layers.Dense(256, activation='relu')) model.add(layers.Dense(64, activation='relu')) model.add(layers.Dense(1, activation='sigmoid')) model.compile(loss='binary_crossentropy', optimizer=optimizers.RMSprop(lr=2e-5), metrics=['acc']) return model image=crop_resize(sys.argv[1],224) image = np.reshape(image,[1,224,224,3]) #Loading models and text processing model = build_model() print('building a model') model.load_weights('./models/mobile_weights.h5') print('model loaded') pred_cat=model.predict(image) if pred_cat &gt; 0.7: print('fire {}'.format(pred_cat)) else: print('no fire {}'.format(pred_cat))</code> </pre><br></div></div><br><br><p>  <strong>Skript getZone.py</strong> </p><br><p>  Die Eingabe in das Skript sind die Koordinaten des Punkts, der von der Clientseite der Anwendung stammt.  Das Skript versch√§rft alle Koordinaten der NASA, f√ºgt dieser Datei einen neuen Breiten- und L√§ngengrad hinzu, √ºberschreibt die Originaldatei und sucht nach den n√§chsten Punkten.  Der Abstand zwischen Punkten wird nach der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haversine-Formel berechnet</a> . </p><br><p>  Dazu werden Breite und L√§nge der Punkte in Bogenma√ü umgerechnet: </p><br><pre> <code class="plaintext hljs">pt1_lon, pt1_lat, pt2_lon, pt2_lat = map(radians, [pt1_lon, pt1_lat, pt2_lon, pt2_lat])</code> </pre><br><p>  Es gibt Unterschiede zwischen Breiten- und L√§ngengrad f√ºr jeden der Punkte: </p><br><pre> <code class="plaintext hljs">d_lon = pt2_lon - pt1_lon d_lat = pt2_lat - pt1_lat</code> </pre><br><p>  All dies wird in die Haversinformel eingesetzt: </p><br><pre> <code class="plaintext hljs">a = sin(d_lat/2)**2 + cos(pt1_lat) * cos(pt2_lat) * sin(d_lon/2)**2</code> </pre><br><p>  Wir nehmen die Wurzel des Berechnungsergebnisses, berechnen den Arkussinus und multiplizieren das Ergebnis mit 2. </p><br><pre> <code class="plaintext hljs">c = 2 * asin(sqrt(a))</code> </pre><br><p>  Die Entfernung ergibt sich aus dem Radius der Erde (6371 km) und dem Ergebnis der vorherigen Berechnung. </p><br><h2>  Modelltraining </h2><br><p>  Um das Bild f√ºr ein Feuer zu analysieren, brauchten wir einen Trainingssatz mit Fotos mit Feuer.  Fotos wurden mit einem Skript von der Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.flickr.com/</a> gesammelt und manuell markiert. </p><br><p>  Der Download erfolgte mit FlikerAPI.  Das Skript f√ºhrte Standardvorverarbeitungsvorg√§nge mit Bildern durch: Zuschneiden - Quadrat mit Zentrierung (Verh√§ltnis 1: 1) und Gr√∂√üen√§nderung auf das Format 256 √ó 256. </p><br><div class="spoiler">  <b class="spoiler_title">Codeauflistung:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">import flickrapi import urllib.request from PIL import Image import pathlib import os from tqdm import tqdm # Flickr api access key flickr=flickrapi.FlickrAPI('your API key', 'your secret key', cache=True) def get_links(): search_term = input("Input keywords for images: ") keyword = search_term max_pics=2000 photos = flickr.walk(text=keyword, tag_mode='all', tags=keyword, extras='url_c', per_page=500, # mb you can try different numbers.. sort='relevance') urls = [] for i, photo in enumerate(photos): url = photo.get('url_c') if url is not None: urls.append(url) if i &gt; max_pics: break num_of_pics=len(urls) print('total urls:',len(urls)) # print number of images available for a keywords return urls, keyword, num_of_pics #resizing and cropping output images will be besquare def crop_resize(img_path, img_size_square): # Get dimensions mysize = img_size_square image = Image.open(img_path) width, height = image.size # resize if (width and height) &gt;= img_size_square: if width &gt; height: wpercent = (mysize/float(image.size[1])) vsize = int((float(image.size[0])*float(wpercent))) image = image.resize((vsize, mysize), Image.ANTIALIAS) else: wpercent = (mysize/float(image.size[0])) hsize = int((float(image.size[1])*float(wpercent))) image = image.resize((mysize, hsize), Image.ANTIALIAS) # crop width, height = image.size left = (width - mysize)/2 top = (height - mysize)/2 right = (width + mysize)/2 bottom = (height + mysize)/2 image=image.crop((left, top, right, bottom)) return image def download_images(urls_,keyword_, num_of_pics_): num_of_pics=num_of_pics_ keyword=keyword_ urls=urls_ i=0 base_path='./flickr_data/' # your base folder to save pics for item in tqdm(urls): name=''.join([keyword,'_',str(i),'.jpg']) i+=1 keyword_=''.join([keyword,'_',str(num_of_pics)]) dir_path= os.path.join(base_path,keyword_) file_path=os.path.join(dir_path,name) pathlib.Path(dir_path).mkdir(parents=True, exist_ok=True) urllib.request.urlretrieve(item, file_path) resized_img=crop_resize(file_path, 256) #set output image size try: resized_img.save(file_path) except: pass urls, keyword, num_of_pics =get_links() continue = input("continue or try other keywords (y,n): ") if continue =='y': download_images(urls, keyword, num_of_pics) elif continue =='n': get_links() else: pass</code> </pre><br></div></div><br><p>  Nat√ºrlich wurde die Faltungsarchitektur des neuronalen Netzwerks, in der das vorab trainierte Modell verwendet wurde, verwendet, um mit Bildern zu arbeiten.  Die Wahl fiel auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MobileNet</a> (erwartet), weil: </p><br><ul><li>  Leichtgewicht - Es ist wichtig, dass die Reaktionszeit der Anwendung minimal ist. </li><li>  Schnell - Es ist wichtig, dass die Antwortzeit der Anwendung minimal ist. </li><li>  Genau - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>MobileNet</em></a> sagt mit der erforderlichen Genauigkeit voraus. </li></ul><br><p>  Nach dem Training ergab das Netzwerk eine Genauigkeit von ~ 0,85. </p><br><p>  Um das Modell, das Training und die Vorhersage zu erstellen, wurde eine Reihe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Keras</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tensorflow verwendet</a> .  Die Arbeit mit Daten wurde √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pandas durchgef√ºhrt</a> . </p><br><p>  Da es sich bei dem NASA DataSet um geografische Daten handelt, wollten wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GeoPandas-</a> Bibliothek verwenden.  Diese Bibliothek ist eine Erweiterung der Funktionen von Pandas zur Bereitstellung r√§umlicher Methoden und Operationen f√ºr geometrische Typen.  Geometrische Operationen werden durch die formsch√∂ne Bibliothek implementiert, arbeiten mit Dateien - Fiona, Graphing - Matplotlib. </p><br><p>  Nachdem wir fast anderthalb Tage damit verbracht hatten, diese Bibliothek herauszufinden, gaben wir sie auf, weil wir nicht herausfinden konnten, wo sie uns einen echten Vorteil aus der Arbeit mit ihr verschaffen k√∂nnte.  Unsere Aufgabe, die Koordinaten zu berechnen, war sehr klein, so dass am Ende alles nativ implementiert wurde. </p><br><h2>  Was weiter? </h2><br><p>  Alles, was wir als Ergebnis erhalten haben, ist nat√ºrlich eine √§u√üerst instabile und grobe Anwendung, die das Recht hat, abgeschlossen zu werden. </p><br><p>  Es ist uns gelungen: </p><br><ol><li>  Implementieren Sie Prototypen von Mobil- und Webanwendungen, die Fotos aufnehmen konnten (nur mobile Version), hochladen und an den Server senden konnten.  Au√üerdem werden die Koordinaten f√ºr das erfolgreiche Senden an den Server gesendet. </li><li>  Auf dem Server konnten zwei Skripte bereitgestellt werden, die die Hauptlogik der Anwendung implementieren.  Der Fluss der Eingabedaten zu diesen Skripten und der Empfang der Ausgabedaten mit anschlie√üendem Senden an den Client-Teil wurde arrangiert. </li><li>  Implementieren Sie den echten ‚ÄûPrototyp‚Äú unserer Anwendung. </li></ol><br><p>  Wir haben es nicht geschafft, es zu implementieren, aber ich m√∂chte die folgenden Probleme l√∂sen und Funktionen hinzuf√ºgen (die Elemente richten sich nach der Priorit√§t der Aufgabe): </p><br><ol><li>  Organisieren Sie die Aufzeichnung aller Koordinaten aus dem Datensatz in der Datenbank, um direkt mit der Datenbank zu interagieren. </li><li>  Organisieren Sie das automatische Hochladen einer neuen Datei von der NASA-Website, d. H.  Organisieren Sie automatische t√§gliche Koordinatenaktualisierungen. </li><li>  F√ºgen Sie Benachrichtigungen f√ºr Benutzer hinzu, die sich in der N√§he des Feuers befinden. </li><li>  Registrierung hinzuf√ºgen (erforderlich, um den ersten Absatz zu implementieren). </li><li>  Schreiben Sie den Algorithmus zur Berechnung der Brandzone neu. </li><li>  L√∂sen Sie Designaufgaben - bringen Sie Sch√∂nheit in die Mobil- und Webversionen der Anwendung. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430480/">https://habr.com/ru/post/de430480/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430470/index.html">Warum den Kontext auf dem Kundenkonto pflegen - ehrlich und profitabel</a></li>
<li><a href="../de430472/index.html">DIY nahtloses DECT-Netzwerk</a></li>
<li><a href="../de430474/index.html">CephFS vs GlusterFS</a></li>
<li><a href="../de430476/index.html">NCBI Genome Workbench: Gef√§hrdete Forschung</a></li>
<li><a href="../de430478/index.html">Trading Bots f√ºr den Kryptow√§hrungsmarkt. Wo soll ich anfangen?</a></li>
<li><a href="../de430482/index.html">Das Thema der Panzerplatten in der Kultur von Ost und West</a></li>
<li><a href="../de430484/index.html">Typische NGFW-Implementierungsszenarien</a></li>
<li><a href="../de430486/index.html">Wie Freiberufler leben: vom Entwickler zum technischen Texter</a></li>
<li><a href="../de430488/index.html">Asynchroner Datenaustausch mit einer Remote-Anwendung √ºber SSH</a></li>
<li><a href="../de430490/index.html">Vorwegnehmen, aufkl√§ren, entscheiden: Wie und warum EPAM das Java Competency Center aufbaut</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>