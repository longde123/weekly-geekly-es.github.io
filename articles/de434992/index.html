<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌵 ☢️ 💓 IDA Pro aktualisieren. Debugger für Sega Mega Drive (Teil 1) 🏿 🎅🏿 🐀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Grüße! 


 Genossen Umkehrer, Romhacker: Im Grunde wird dieser Artikel Ihnen gewidmet sein. Darin werde ich Ihnen erklären, wie Sie Ihr eigenes Debugg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IDA Pro aktualisieren. Debugger für Sega Mega Drive (Teil 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434992/"><p><img src="https://habrastorage.org/webt/mj/6l/rl/mj6lrl7zl2pq7itjpw3cr3s15fw.png"></p><br><p>  Grüße! </p><br><p> Genossen Umkehrer, Romhacker: Im Grunde wird dieser Artikel Ihnen gewidmet sein.  Darin werde ich Ihnen erklären, wie Sie Ihr eigenes Debugger-Plugin für <code>IDA Pro</code> schreiben.  Ja, es gab bereits den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Versuch, die Geschichte zu beginnen</a> , aber seitdem ist viel Wasser geflossen, viele Prinzipien wurden überarbeitet.  Im Allgemeinen fuhren sie! <a name="habracut"></a></p><br><h4 id="liricheskoe-vstuplenie">  Lyrische Einführung </h4><br><p>  Aus früheren Artikeln ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drei</a> ) geht hervor, dass es kein Geheimnis sein wird, dass mein Lieblingsprozessor das <code>Motorola 68000</code> .  Übrigens arbeitet meine alte Lieblingsfrau <code>Sega Mega Drive</code> / <code>Genesis</code> daran.  Und da ich immer daran interessiert war, wie Segovs Spiele angeordnet sind, habe ich mich von den ersten Monaten meiner Computernutzung an entschlossen, lange Zeit tief in den Dschungel der Demontage zu gehen und umzukehren. </p><br><p>  So sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Smd IDA Tools</a> entstanden. <br>  Das Projekt umfasst verschiedene Hilfsprogramme, die das Studium von Roms auf Sega erheblich erleichtern: einen Loader, einen Debugger, einen Helfer für <code>VDP</code> Befehle.  Alles wurde für <code>IDA 6.8</code> und hat gut funktioniert.  Aber als ich mich entschied, der Welt zu erzählen, wie ich es trotzdem gemacht habe, wurde klar, dass es sehr schwierig sein würde, den Menschen einen solchen Code zu zeigen und noch mehr, ihn zu beschreiben.  Deshalb konnte ich das damals nicht machen. </p><br><p>  Und dann kam <code>IDA 7.0</code> heraus.  Der Wunsch, mein Projekt darauf zu portieren, trat sofort auf, aber die Architektur des <code>Gens</code> Emulators, auf deren Grundlage ich den Debugger schrieb, erwies sich als ungeeignet für die Portierung: zusammengesetzte Einfügungen für <code>x86</code> , Krücken, schwer verständlicher Code und vieles mehr.  Und das Spiel <code>Pier Solar and the Great Architects</code> , das 2010 auf Kassetten veröffentlicht wurde und das ich unbedingt erforschen wollte (und es gibt dort viele Anti-Emulations-Tricks), wurde in <code>Gens</code> nicht gestartet. </p><br><p><img src="https://habrastorage.org/webt/5f/in/pg/5finpgxicxyqorxx1qa50ka7zne.jpeg"></p><br><p>  Auf der Suche nach einer geeigneten Emulatorquelle, die für den Debugger angepasst werden könnte, stieß ich schließlich auf <code>EkeEke</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Genesis Plus GX</a> .  Also erschien dieser Artikel. </p><br><h2 id="chast-pervaya-yadro-otladchika">  Erster Teil: Der Debugger-Kern </h2><br><p>  Musashi übernimmt die Emulation von Motorola-Prozessoranweisungen im <code>Genesis Plus GX</code> .  Die ursprüngliche Quelle verfügt bereits über grundlegende Debugging-Funktionen (ein Hook zum Ausführen von Anweisungen), aber <code>EkeEke</code> beschlossen, sie als unnötig zu entfernen.  Wir kehren zurück. </p><br><p><img src="https://habrastorage.org/webt/qp/1v/ls/qp1vls4m3ghzf3aqmknj-23xulu.png"></p><br><p><img src="https://habrastorage.org/webt/tr/wp/rw/trwprwbfno8tkajpbfaftwyqyu8.png"></p><br><p>  Jetzt das Wichtigste: Sie müssen sich für die Architektur des Debuggers entscheiden.  Die Anforderungen sind wie folgt: </p><br><ul><li>  Pausen (Haltepunkte) zur Ausführung, zum Lesen und Schreiben in den Speicher </li><li>  Funktionalität <code>Step Into</code> <code>Step Over</code> </li><li>  Pause, Emulation fortsetzen </li><li>  Register lesen / setzen, Speicher lesen / schreiben </li></ul><br><p>  Wenn diese vier Punkte die Arbeit des Debuggers von innen sind, müssen Sie dennoch den Zugriff auf diese Funktionalität von außen in Betracht ziehen.  Fügen Sie einen weiteren Artikel hinzu: </p><br><ul><li>  Kommunikationsprotokoll des Debugger-Servers (Kernel) mit dem Debugger-Client (GUI, Benutzer) </li></ul><br><h3 id="yadro-otladchika-spisok-bryakov">  Debugger-Kern: Unterbrechungsliste </h3><br><p>  Um die Liste zu implementieren, starten wir die folgende Struktur: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">breakpoint_s</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">breakpoint_s</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> enabled; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; <span class="hljs-keyword"><span class="hljs-keyword">bpt_type_t</span></span> type; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> address; } <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span>;</code> </pre> <br><p>  In den Feldern <code>next</code> und <code>prev</code> werden Zeiger auf das nächste bzw. vorherige Element gespeichert. <br>  Das <code>enabled</code> Feld speichert <code>0</code> wenn dieser Haltepunkt in den Betriebstests übersprungen werden muss. <br>  <code>width</code> - Die Anzahl der Bytes ab der Adresse im <code>address</code> , die der Leistungsschalter abdeckt. <br>  Nun, im Typfeld speichern wir den Haltepunkttyp (Ausführung, Lesen, Schreiben).  Weitere Details unten. </p><br><p>  Um mit der Liste der Haltepunkte zu arbeiten, habe ich die folgenden Funktionen hinzugefügt: </p><br><div class="spoiler">  <b class="spoiler_title">Haltepunktfunktionen</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *first_bp = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> breakpoint_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_bpt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_type_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *bp = (<span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span>)); bp-&gt;type = type; bp-&gt;address = address; bp-&gt;width = width; bp-&gt;enabled = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_bp) { bp-&gt;next = first_bp; bp-&gt;prev = first_bp-&gt;prev; first_bp-&gt;prev = bp; bp-&gt;prev-&gt;next = bp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { first_bp = bp; bp-&gt;next = bp; bp-&gt;prev = bp; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bp; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete_breakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">breakpoint_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * bp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bp == first_bp) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bp-&gt;next == bp) { first_bp = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { first_bp = bp-&gt;next; } } bp-&gt;next-&gt;prev = bp-&gt;prev; bp-&gt;prev-&gt;next = bp-&gt;next; <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(bp); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> breakpoint_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next_breakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">breakpoint_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bp-&gt;next != first_bp ? bp-&gt;next : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> breakpoint_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_breakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_type_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *p; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = first_bp; p; p = next_breakpoint(p)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((p-&gt;address == address) &amp;&amp; ((p-&gt;type == BPT_ANY) || (p-&gt;type &amp; type))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_bpt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_type_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *bpt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((bpt = find_breakpoint(address, type))) delete_breakpoint(bpt); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count_bpt_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *p; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = first_bp; p; p = next_breakpoint(p)) { ++i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_bpt_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_data_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *p; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = first_bp; p; p = next_breakpoint(p)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == index) { data-&gt;address = p-&gt;address; data-&gt;width = p-&gt;width; data-&gt;type = p-&gt;type; data-&gt;enabled = p-&gt;enabled; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } ++i; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear_bpt_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (first_bp != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) delete_breakpoint(first_bp); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_bpt_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_bp) clear_bpt_list(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_breakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bpt_type_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dbg_req || !dbg_req-&gt;dbg_active || dbg_dont_check_bp) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">breakpoint_t</span></span> *bp; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (bp = first_bp; bp; bp = next_breakpoint(bp)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(bp-&gt;type &amp; type) || !bp-&gt;enabled) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((address &lt;= (bp-&gt;address + bp-&gt;width)) &amp;&amp; ((address + width) &gt;= bp-&gt;address)) { dbg_req-&gt;dbg_paused = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre> </div></div><br><h3 id="yadro-otladchika-osnovnye-peremennye">  Debugger-Kern: Kernvariablen </h3><br><p>  Eigentlich habe ich diese Implementierung in einem anderen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PCSXR-</a> Debugger ausspioniert. </p><br><p>  Fügen Sie die Variablen hinzu, in denen der Emulationsstatus gespeichert wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_first_paused, dbg_trace, dbg_dont_check_bp; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_step_over; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_last_pc; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_step_over_addr; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dbg_active, dbg_paused;</code> </pre> <br><p>  Die Variable <code>dbg_first_paused</code> ist dafür verantwortlich, die Emulation zu Beginn des Debuggens zu stoppen.  Wenn <code>0</code> -, müssen Sie die Emulation anhalten und eine Nachricht an den Client senden, dass die Emulation gestartet wird.  Stellen Sie nach der ersten Pause <code>1</code> . </p><br><p>  Wir benötigen <code>dbg_trace</code> für die Ausführung gemäß einer Anweisung ( <code>Step Into</code> Funktionalität).  Wenn gleich <code>1</code> , führen wir eine Anweisung aus, halten an und setzen den Wert auf <code>0</code> . </p><br><p>  Ich habe die Variable <code>dbg_dont_check_bp</code> so festgelegt, dass die Lese- / Schreibspeicherunterbrechungen nicht funktionieren, wenn der Debugger dies <code>dbg_dont_check_bp</code> . </p><br><p>  <code>dbg_step_over</code> wird bei <code>1</code> gespeichert, wenn wir uns im <code>Step Over</code> Modus befinden, bis der aktuelle <code>PC</code> ( <em>Program Counter</em> , auch bekannt als <em>Instruction Pointer</em> ) der Adresse in <code>dbg_step_over_addr</code> .  Danach werden beide Variablen zurückgesetzt.  Ich werde <code>dbg_step_over_addr</code> Berechnung des Wertes von <code>dbg_step_over_addr</code> später <code>dbg_step_over_addr</code> . </p><br><p>  Ich habe die Variable <code>dbg_last_pc</code> für einen bestimmten Fall eingerichtet: Wenn wir bereits in einer Pause stehen und der Client nach <code>Resume</code> fragt.  Damit der Leistungsschalter nicht wieder funktioniert, vergleiche ich die Adresse des letzten <code>PC</code> in dieser Variablen mit der neuen. Wenn die Werte unterschiedlich sind, können Sie den Haltepunkt auf dem aktuellen <code>PC</code> überprüfen. </p><br><p>  <code>dbg_active</code> - Tatsächlich wird Status <code>1</code> <code>dbg_active</code> , wenn das Debuggen aktiv ist und Sie die Unterbrechungen überprüfen und Anforderungen vom Client verarbeiten müssen. </p><br><p>  Mit der Variablen <code>dbg_paused</code> denke ich, dass alles klar ist: <code>1</code> - wir werden angehalten (zum Beispiel nachdem eine Pause ausgelöst wurde) und erwarten Befehle vom Client, <code>0</code> - wir folgen den Anweisungen. </p><br><p>  Wir schreiben Funktionen für die Arbeit mit diesen Variablen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dbg_trace = <span class="hljs-number"><span class="hljs-number">1</span></span>; dbg_paused = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resume_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dbg_trace = <span class="hljs-number"><span class="hljs-number">0</span></span>; dbg_paused = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detach_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ clear_bpt_list(); resume_debugger(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activate_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dbg_active = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deactivate_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ dbg_active = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Wir sehen, dass ich in der Implementierung von <code>detach_debugger()</code> die Liste der Unterbrechungen <code>detach_debugger()</code> .  Dies ist erforderlich, damit die alten Haltepunkte nach dem Trennen des Clients nicht weiter funktionieren. </p><br><h3 id="yadro-otladchika-realizuem-huk-na-instrukcii">  Debugger-Kern: Wir implementieren einen Hook-on-Befehl </h3><br><p>  Eigentlich wird hier die Hauptarbeit mit einer Pause, fortgesetzter Emulation, <code>Step Into</code> , <code>Step Over</code> . </p><br><p>  Hier ist der Code für die Funktion <code>process_breakpoints()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_breakpoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> handled_event = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> is_step_over = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> is_step_in = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dbg_active) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pc = m68k_get_reg(M68K_REG_PC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dbg_paused &amp;&amp; dbg_first_paused &amp;&amp; !dbg_trace) longjmp(jmp_env, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dbg_first_paused) { dbg_first_paused = <span class="hljs-number"><span class="hljs-number">1</span></span>; dbg_paused = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send emulation started event } if (dbg_trace) { is_step_in = 1; dbg_trace = 0; dbg_paused = 1; // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send event that Step Into has been triggered handled_event = 1; } if (!dbg_paused) { if (dbg_step_over &amp;&amp; pc == dbg_step_over_addr) { is_step_over = 1; dbg_step_over = 0; dbg_step_over_addr = 0; dbg_paused = 1; } if (dbg_last_pc != pc) check_breakpoint(BPT_M68K_E, 1, pc, pc); if (dbg_paused) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send event about Step Over or breakpoint has been triggered handled_event = 1; } } if (dbg_first_paused &amp;&amp; (!handled_event) &amp;&amp; dbg_paused) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send paused event } dbg_last_pc = pc; if (dbg_paused &amp;&amp; (!is_step_in || is_step_over)) { longjmp(jmp_env, 1); } }</span></span></code> </pre> <br><p>  Lassen Sie uns verstehen: </p><br><ol><li>  Wenn das Debuggen nicht aktiviert ist, beenden Sie einfach den Hook </li><li>  Der Trick mit <code>setjmp</code> / <code>longjmp</code> benötigt, da das <code>RetroArch</code> Shell- <code>RetroArch</code> , für das wir unsere eigene Version von <code>Genesis Plus GX</code> , mit dem wir die Emulation ausführen, darauf wartet, dass der Emulator die Frame-Rendering-Funktion beendet.  Ich werde den zweiten Teil des Tricks später zeigen, weil  Es berührt eher die Hülle über dem Emulator als den Kern. </li><li>  Wenn dies unsere erste Operation des Hooks und dementsprechend der Beginn der Emulation ist, halten wir an und senden das Ereignis des Starts der Emulation an den Client. </li><li>  Wenn der Client zuvor den <code>dbg_trace</code> <code>Step Into</code> gesendet hat, setzen wir <code>dbg_trace</code> Wert der Variablen <code>dbg_trace</code> und setzen die Emulation auf pause.  Wir senden die entsprechende Veranstaltung an den Kunden. </li><li>  Wenn wir nicht pausieren, der <code>Step Over</code> Modus <code>dbg_step_over_addr</code> ist und der aktuelle <code>PC</code> der Zieladresse <code>dbg_step_over_addr</code> , setzen wir die erforderlichen Variablen auf <code>dbg_step_over_addr</code> und pausieren. </li><li>  Wir überprüfen den Haltepunkt, wenn wir jetzt nicht darauf sind, und wenn die Unterbrechung funktioniert hat, halten wir an und senden dem Client ein Ereignis über <code>Step Over</code> oder break. </li><li>  Wenn dies keine Panne ist, nicht <code>Step Into</code> und nicht <code>Step Over</code> , hat der Client um eine Pause gebeten.  Wir senden ein Ereignis über die ausgelöste Pause. </li><li>  Wir implementieren den Trick mit <code>longjump</code> als Implementierung einer Endlosschleife, in der während einer Pause auf Aktionen des Clients gewartet wird. </li></ol><br><p>  Der Code zur Berechnung der Adresse für <code>Step Over</code> war nicht so einfach, wie Sie vielleicht zuerst erraten haben.  Der Motorola-Prozessor hat unterschiedliche Befehlslängen, daher müssen Sie die Adresse je nach Opcode als nächstes manuell berücksichtigen.  Darüber hinaus müssen Sie Anweisungen wie <code>bra</code> , <code>jmp</code> , <code>rts</code> bedingten Sprüngen nach vorne vermeiden und sie als <code>Step Into</code> ausführen.  Die Implementierung ist wie folgt: </p><br><div class="spoiler">  <b class="spoiler_title">Funktionscode Calc_step_over ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc_step_over</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pc = m68k_get_reg(M68K_REG_PC); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sp = m68k_get_reg(M68K_REG_SP); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> opc = m68ki_read_imm_16(); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dest_pc = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// jsr if ((opc &amp; 0xFFF8) == 0x4E90) { m68k_op_jsr_32_ai(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFF8) == 0x4EA8) { m68k_op_jsr_32_di(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFF8) == 0x4EB0) { m68k_op_jsr_32_ix(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EB8) { m68k_op_jsr_32_aw(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EB9) { m68k_op_jsr_32_al(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EBA) { m68k_op_jsr_32_pcdi(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EBB) { m68k_op_jsr_32_pcix(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } // bsr else if ((opc &amp; 0xFFFF) == 0x6100) { m68k_op_bsr_16(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x61FF) { m68k_op_bsr_32(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFF00) == 0x6100) { m68k_op_bsr_8(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } // dbf else if ((opc &amp; 0xfff8) == 0x51C8) { dest_pc = m68k_get_reg(M68K_REG_PC) + 2; } m68k_set_reg(M68K_REG_PC, pc); m68k_set_reg(M68K_REG_SP, sp); return dest_pc;</span></span></code> </pre> </div></div><br><h3 id="yadro-otladchika-inicializaciya-i-ostanovka-otladki">  Debugger-Kernel: Debuggen initialisieren und stoppen </h3><br><p>  Hier ist alles einfach: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop_debugging</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Send Stopped event to client detach_debugger(); deactivate_debugger(); dbg_first_paused = dbg_paused = dbg_trace = dbg_dont_check_bp = dbg_step_over = dbg_step_over_addr = dbg_last_pc = 0; } void start_debugging() { if (dbg_active) return; activate_debugger(); init_bpt_list(); dbg_first_paused = dbg_paused = dbg_trace = dbg_dont_check_bp = dbg_step_over = dbg_step_over_addr = dbg_last_pc = 0; }</span></span></code> </pre> <br><h3 id="yadro-otladchika-realizaciya-protokola">  Debugger-Kernel: Protokollimplementierung </h3><br><p>  Das Kommunikationsprotokoll zwischen dem Debug-Server und dem Client-Client kann sicher als das zweite Herzstück des Debugging-Prozesses bezeichnet werden, weil  Es implementiert die Funktionalität der Verarbeitung von Anforderungen vom Client und deren Reaktionen. <br>  Es wurde beschlossen, auf der Basis von <em>Shared Memory</em> zu implementieren, da große Speicherblöcke gesendet werden müssen: <code>VRAM</code> , <code>RAM</code> , <code>ROM</code> , und über das Netzwerk wird dies noch mehr Spaß machen. </p><br><p>  Das Wesentliche ist Folgendes: Der Kernel erstellt einen gemeinsam genutzten Speicher mit einer vordefinierten Struktur und erwartet eingehende Anforderungen vom Client.  Nach der Verarbeitung der Anforderung wird die Antwort im selben Speicher gespeichert und die entsprechenden Informationen werden zur Liste der Debugger-Ereignisse im selben Speicher hinzugefügt. </p><br><p>  Der Prototyp wurde wie folgt ausgewählt: </p><br><div class="spoiler">  <b class="spoiler_title">Laden Sie das Quellpaket debug_wrap.h herunter</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _DEBUG_WRAP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _DEBUG_WRAP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __cplusplus extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Windows.h&gt; #define SHARED_MEM_NAME "GX_PLUS_SHARED_MEM" #define MAX_BREAKPOINTS 1000 #define MAX_DBG_EVENTS 20 #ifndef MAXROMSIZE #define MAXROMSIZE ((unsigned int)0xA00000) #endif #pragma pack(push, 4) typedef enum { BPT_ANY = (0 &lt;&lt; 0), // M68K BPT_M68K_E = (1 &lt;&lt; 0), BPT_M68K_R = (1 &lt;&lt; 1), BPT_M68K_W = (1 &lt;&lt; 2), BPT_M68K_RW = BPT_M68K_R | BPT_M68K_W, // VDP BPT_VRAM_R = (1 &lt;&lt; 3), BPT_VRAM_W = (1 &lt;&lt; 4), BPT_VRAM_RW = BPT_VRAM_R | BPT_VRAM_W, BPT_CRAM_R = (1 &lt;&lt; 5), BPT_CRAM_W = (1 &lt;&lt; 6), BPT_CRAM_RW = BPT_CRAM_R | BPT_CRAM_W, BPT_VSRAM_R = (1 &lt;&lt; 7), BPT_VSRAM_W = (1 &lt;&lt; 8), BPT_VSRAM_RW = BPT_VSRAM_R | BPT_VSRAM_W, // Z80 BPT_Z80_E = (1 &lt;&lt; 11), BPT_Z80_R = (1 &lt;&lt; 12), BPT_Z80_W = (1 &lt;&lt; 13), BPT_Z80_RW = BPT_Z80_R | BPT_Z80_W, // REGS BPT_VDP_REG = (1 &lt;&lt; 9), BPT_M68K_REG = (1 &lt;&lt; 10), } bpt_type_t; typedef enum { REQ_NO_REQUEST, REQ_GET_REGS, REQ_SET_REGS, REQ_GET_REG, REQ_SET_REG, REQ_READ_68K_ROM, REQ_READ_68K_RAM, REQ_WRITE_68K_ROM, REQ_WRITE_68K_RAM, REQ_READ_Z80, REQ_WRITE_Z80, REQ_ADD_BREAK, REQ_TOGGLE_BREAK, REQ_DEL_BREAK, REQ_CLEAR_BREAKS, REQ_LIST_BREAKS, REQ_ATTACH, REQ_PAUSE, REQ_RESUME, REQ_STOP, REQ_STEP_INTO, REQ_STEP_OVER, } request_type_t; typedef enum { REG_TYPE_M68K = (1 &lt;&lt; 0), REG_TYPE_S80 = (1 &lt;&lt; 1), REG_TYPE_Z80 = (1 &lt;&lt; 2), REG_TYPE_VDP = (1 &lt;&lt; 3), } register_type_t; typedef enum { DBG_EVT_NO_EVENT, DBG_EVT_STARTED, DBG_EVT_PAUSED, DBG_EVT_BREAK, DBG_EVT_STEP, DBG_EVT_STOPPED, } dbg_event_type_t; typedef struct { dbg_event_type_t type; unsigned int pc; char msg[256]; } debugger_event_t; typedef struct { int index; unsigned int val; } reg_val_t; typedef struct { unsigned int d0, d1, d2, d3, d4, d5, d6, d7; unsigned int a0, a1, a2, a3, a4, a5, a6, a7; unsigned int pc, sr, sp, usp, isp, ppc, ir; } regs_68k_data_t; typedef enum { REG_68K_D0, REG_68K_D1, REG_68K_D2, REG_68K_D3, REG_68K_D4, REG_68K_D5, REG_68K_D6, REG_68K_D7, REG_68K_A0, REG_68K_A1, REG_68K_A2, REG_68K_A3, REG_68K_A4, REG_68K_A5, REG_68K_A6, REG_68K_A7, REG_68K_PC, REG_68K_SR, REG_68K_SP, REG_68K_USP, REG_68K_ISP, REG_68K_PPC, REG_68K_IR, REG_VDP_00, REG_VDP_01, REG_VDP_02, REG_VDP_03, REG_VDP_04, REG_VDP_05, REG_VDP_06, REG_VDP_07, REG_VDP_08, REG_VDP_09, REG_VDP_0A, REG_VDP_0B, REG_VDP_0C, REG_VDP_0D, REG_VDP_0E, REG_VDP_0F, REG_VDP_10, REG_VDP_11, REG_VDP_12, REG_VDP_13, REG_VDP_14, REG_VDP_15, REG_VDP_16, REG_VDP_17, REG_VDP_18, REG_VDP_19, REG_VDP_1A, REG_VDP_1B, REG_VDP_1C, REG_VDP_1D, REG_VDP_1E, REG_VDP_1F, REG_VDP_DMA_LEN, REG_VDP_DMA_SRC, REG_VDP_DMA_DST, REG_Z80_PC, REG_Z80_SP, REG_Z80_AF, REG_Z80_BC, REG_Z80_DE, REG_Z80_HL, REG_Z80_IX, REG_Z80_IY, REG_Z80_WZ, REG_Z80_AF2, REG_Z80_BC2, REG_Z80_DE2, REG_Z80_HL2, REG_Z80_R, REG_Z80_R2, REG_Z80_IFFI1, REG_Z80_IFFI2, REG_Z80_HALT, REG_Z80_IM, REG_Z80_I, } regs_all_t; typedef struct { unsigned int pc, sp, af, bc, de, hl, ix, iy, wz; unsigned int af2,bc2,de2,hl2; unsigned char r, r2, iff1, iff2, halt, im, i; } regs_z80_data_t; typedef struct { unsigned char regs_vdp[0x20]; unsigned short dma_len; unsigned int dma_src, dma_dst; } vdp_regs_t; typedef struct { int type; // register_type_t regs_68k_data_t regs_68k; reg_val_t any_reg; vdp_regs_t vdp_regs; regs_z80_data_t regs_z80; } register_data_t; typedef struct { int size; unsigned int address; unsigned char m68k_rom[MAXROMSIZE]; unsigned char m68k_ram[0x10000]; unsigned char z80_ram[0x2000]; } memory_data_t; typedef struct { bpt_type_t type; unsigned int address; int width; int enabled; } bpt_data_t; typedef struct { int count; bpt_data_t breaks[MAX_BREAKPOINTS]; } bpt_list_t; typedef struct { request_type_t req_type; register_data_t regs_data; memory_data_t mem_data; bpt_data_t bpt_data; int dbg_events_count; debugger_event_t dbg_events[MAX_DBG_EVENTS]; bpt_list_t bpt_list; int dbg_active, dbg_paused; int is_ida; } dbg_request_t; #pragma pack(pop) dbg_request_t *open_shared_mem(); void close_shared_mem(dbg_request_t **request); int recv_dbg_event(dbg_request_t *request, int wait); void send_dbg_request(dbg_request_t *request, request_type_t type); #ifdef __cplusplus } #endif #endif</span></span></span></span></code> </pre> </div></div><br><p>  Das erste Feld in der Struktur ist die Art der Anforderung: </p><br><ul><li>  Register lesen / setzen </li><li>  Lese- / Schreibspeicher </li><li>  Arbeit mit Haltepunkten </li><li>  Emulation anhalten / fortsetzen, Debugger trennen / stoppen </li><li>  <code>Step Into</code> / <code>Step Over</code> </li></ul><br><p>  Als nächstes kommen die Register <code>M68K</code> , <code>Z80</code> , <code>VDP</code> .  Es folgen die Speicherblöcke <code>ROM</code> , <code>RAM</code> , <code>VRAM</code> , <code>Z80</code> . </p><br><p>  Um einen Riss hinzuzufügen / zu entfernen, habe ich auch die entsprechende Struktur erstellt.  Nun, ihre Liste ist auch hier (zum größten Teil nur zur Anzeige in der GUI, ohne dass alle installierten Unterbrechungen <code>IDA</code> müssen, wie dies bei der <code>IDA</code> Fall ist). </p><br><p>  Das Folgende ist eine Liste von Debugging-Ereignissen: </p><br><ul><li>  Debugging gestartet (erforderlich für <code>IDA Pro</code> ) </li><li>  Das Debuggen wird angehalten (falls der <code>PC</code> gespeichert wird, auf dem die Emulation gerade angehalten ist) </li><li>  Haltepunkt funktioniert (speichert auch den Wert des <code>PC</code> auf dem die Operation ausgeführt wurde) </li><li>  <code>Step Into</code> oder <code>Step Over</code> wurde ausgeführt (auch nur für <code>IDA</code> erforderlich, da Sie mit nur einem Pausenereignis arbeiten können). </li><li>  Der Emulationsprozess wurde gestoppt.  Nachdem Sie in der <code>IDA</code> auf die Schaltfläche <code>Stop</code> geklickt haben, ohne dieses Ereignis zu erhalten, wird endlos auf einen Stopp gewartet </li></ul><br><p>  Ausgerüstet mit der Idee eines Protokolls implementieren wir die Verarbeitung von Clientanforderungen und erhalten so den folgenden Debugger-Kernel-Code: </p><br><div class="spoiler">  <b class="spoiler_title">Laden Sie das Quellpaket debug.c herunter</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"debug.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"shared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> m68ki_cpu m68k #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MUL (7) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> BUILD_TABLES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m68ki_cycles.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m68kconf.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m68kcpu.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m68kops.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"vdp_ctrl.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Z80.h"</span></span></span><span class="hljs-meta"> static int dbg_first_paused, dbg_trace, dbg_dont_check_bp; static int dbg_step_over; static int dbg_last_pc; static unsigned int dbg_step_over_addr; static dbg_request_t *dbg_req = NULL; static HANDLE hMapFile = 0; typedef struct breakpoint_s { struct breakpoint_s *next, *prev; int enabled; int width; bpt_type_t type; unsigned int address; } breakpoint_t; static breakpoint_t *first_bp = NULL; static breakpoint_t *add_bpt(bpt_type_t type, unsigned int address, int width) { breakpoint_t *bp = (breakpoint_t *)malloc(sizeof(breakpoint_t)); bp-&gt;type = type; bp-&gt;address = address; bp-&gt;width = width; bp-&gt;enabled = 1; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (first_bp) { bp-&gt;next = first_bp; bp-&gt;prev = first_bp-&gt;prev; first_bp-&gt;prev = bp; bp-&gt;prev-&gt;next = bp; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { first_bp = bp; bp-&gt;next = bp; bp-&gt;prev = bp; } return bp; } static void delete_breakpoint(breakpoint_t * bp) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (bp == first_bp) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (bp-&gt;next == bp) { first_bp = NULL; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { first_bp = bp-&gt;next; } } bp-&gt;next-&gt;prev = bp-&gt;prev; bp-&gt;prev-&gt;next = bp-&gt;next; free(bp); } static breakpoint_t *next_breakpoint(breakpoint_t *bp) { return bp-&gt;next != first_bp ? bp-&gt;next : 0; } static breakpoint_t *find_breakpoint(unsigned int address, bpt_type_t type) { breakpoint_t *p; for (p = first_bp; p; p = next_breakpoint(p)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((p-&gt;address == address) &amp;&amp; ((p-&gt;type == BPT_ANY) || (p-&gt;type &amp; type))) return p; } return 0; } static void remove_bpt(unsigned int address, bpt_type_t type) { breakpoint_t *bpt; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((bpt = find_breakpoint(address, type))) delete_breakpoint(bpt); } static int count_bpt_list() { breakpoint_t *p; int i = 0; for (p = first_bp; p; p = next_breakpoint(p)) { ++i; } return i; } static void get_bpt_data(int index, bpt_data_t *data) { breakpoint_t *p; int i = 0; for (p = first_bp; p; p = next_breakpoint(p)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (i == index) { data-&gt;address = p-&gt;address; data-&gt;width = p-&gt;width; data-&gt;type = p-&gt;type; data-&gt;enabled = p-&gt;enabled; break; } ++i; } } static void clear_bpt_list() { while (first_bp != NULL) delete_breakpoint(first_bp); } static void init_bpt_list() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (first_bp) clear_bpt_list(); } void check_breakpoint(bpt_type_t type, int width, unsigned int address, unsigned int value) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!dbg_req || !dbg_req-&gt;dbg_active || dbg_dont_check_bp) return; breakpoint_t *bp; for (bp = first_bp; bp; bp = next_breakpoint(bp)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!(bp-&gt;type &amp; type) || !bp-&gt;enabled) continue; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((address </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;= (bp-&gt;address + bp-&gt;width)) &amp;&amp; ((address + width) &gt;= bp-&gt;address)) { dbg_req-&gt;dbg_paused = 1; break; } } } static void pause_debugger() { dbg_trace = 1; dbg_req-&gt;dbg_paused = 1; } static void resume_debugger() { dbg_trace = 0; dbg_req-&gt;dbg_paused = 0; } static void detach_debugger() { clear_bpt_list(); resume_debugger(); } static void activate_debugger() { dbg_req-&gt;dbg_active = 1; } static void deactivate_debugger() { dbg_req-&gt;dbg_active = 0; } int activate_shared_mem() { hMapFile = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, sizeof(dbg_request_t), SHARED_MEM_NAME); if (hMapFile == 0) { return -1; } dbg_req = (dbg_request_t*)MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(dbg_request_t)); if (dbg_req == 0) { CloseHandle(hMapFile); return -1; } memset(dbg_req, 0, sizeof(dbg_request_t)); return 0; } void deactivate_shared_mem() { UnmapViewOfFile(dbg_req); CloseHandle(hMapFile); hMapFile = NULL; dbg_req = NULL; } static unsigned int calc_step_over() { unsigned int pc = m68k_get_reg(M68K_REG_PC); unsigned int sp = m68k_get_reg(M68K_REG_SP); unsigned int opc = m68ki_read_imm_16(); unsigned int dest_pc = (unsigned int)(-1); // jsr if ((opc &amp; 0xFFF8) == 0x4E90) { m68k_op_jsr_32_ai(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFF8) == 0x4EA8) { m68k_op_jsr_32_di(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFF8) == 0x4EB0) { m68k_op_jsr_32_ix(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EB8) { m68k_op_jsr_32_aw(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EB9) { m68k_op_jsr_32_al(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EBA) { m68k_op_jsr_32_pcdi(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x4EBB) { m68k_op_jsr_32_pcix(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } // bsr else if ((opc &amp; 0xFFFF) == 0x6100) { m68k_op_bsr_16(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFFFF) == 0x61FF) { m68k_op_bsr_32(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } else if ((opc &amp; 0xFF00) == 0x6100) { m68k_op_bsr_8(); m68k_op_rts_32(); dest_pc = m68k_get_reg(M68K_REG_PC); } // dbf else if ((opc &amp; 0xfff8) == 0x51C8) { dest_pc = m68k_get_reg(M68K_REG_PC) + 2; } m68k_set_reg(M68K_REG_PC, pc); m68k_set_reg(M68K_REG_SP, sp); return dest_pc; } void process_request() { if (!dbg_req || !dbg_req-&gt;dbg_active) return; if (dbg_req-&gt;req_type == REQ_NO_REQUEST) return; switch (dbg_req-&gt;req_type) { case REQ_GET_REG: { register_data_t *regs_data = &amp;dbg_req-&gt;regs_data; if (regs_data-&gt;type &amp; REG_TYPE_M68K) regs_data-&gt;any_reg.val = m68k_get_reg(regs_data-&gt;any_reg.index); if (regs_data-&gt;type &amp; REG_TYPE_VDP) regs_data-&gt;any_reg.val = reg[regs_data-&gt;any_reg.index]; if (regs_data-&gt;type &amp; REG_TYPE_Z80) { if (regs_data-&gt;any_reg.index &gt;= 0 &amp;&amp; regs_data-&gt;any_reg.index &lt;= 12) // PC &lt;-&gt; HL2 { regs_data-&gt;any_reg.val = ((unsigned int *)&amp;Z80.pc)[regs_data-&gt;any_reg.index]; } else if (regs_data-&gt;any_reg.index &gt;= 13 &amp;&amp; regs_data-&gt;any_reg.index &lt;= 19) // R &lt;-&gt; I { regs_data-&gt;any_reg.val = ((unsigned char *)&amp;Z80.r)[regs_data-&gt;any_reg.index - 13]; } } } break; case REQ_SET_REG: { register_data_t *regs_data = &amp;dbg_req-&gt;regs_data; if (regs_data-&gt;type &amp; REG_TYPE_M68K) m68k_set_reg(regs_data-&gt;any_reg.index, regs_data-&gt;any_reg.val); if (regs_data-&gt;type &amp; REG_TYPE_VDP) reg[regs_data-&gt;any_reg.index] = regs_data-&gt;any_reg.val; if (regs_data-&gt;type &amp; REG_TYPE_Z80) { if (regs_data-&gt;any_reg.index &gt;= 0 &amp;&amp; regs_data-&gt;any_reg.index &lt;= 12) // PC &lt;-&gt; HL2 { ((unsigned int *)&amp;Z80.pc)[regs_data-&gt;any_reg.index] = regs_data-&gt;any_reg.val; } else if (regs_data-&gt;any_reg.index &gt;= 13 &amp;&amp; regs_data-&gt;any_reg.index &lt;= 19) // R &lt;-&gt; I { ((unsigned char *)&amp;Z80.r)[regs_data-&gt;any_reg.index - 13] = regs_data-&gt;any_reg.val &amp; 0xFF; } } } break; case REQ_GET_REGS: case REQ_SET_REGS: { register_data_t *regs_data = &amp;dbg_req-&gt;regs_data; if (regs_data-&gt;type &amp; REG_TYPE_M68K) { regs_68k_data_t *m68kr = &amp;regs_data-&gt;regs_68k; if (dbg_req-&gt;req_type == REQ_GET_REGS) { m68kr-&gt;d0 = m68k_get_reg(M68K_REG_D0); m68kr-&gt;d1 = m68k_get_reg(M68K_REG_D1); m68kr-&gt;d2 = m68k_get_reg(M68K_REG_D2); m68kr-&gt;d3 = m68k_get_reg(M68K_REG_D3); m68kr-&gt;d4 = m68k_get_reg(M68K_REG_D4); m68kr-&gt;d5 = m68k_get_reg(M68K_REG_D5); m68kr-&gt;d6 = m68k_get_reg(M68K_REG_D6); m68kr-&gt;d7 = m68k_get_reg(M68K_REG_D7); m68kr-&gt;a0 = m68k_get_reg(M68K_REG_A0); m68kr-&gt;a1 = m68k_get_reg(M68K_REG_A1); m68kr-&gt;a2 = m68k_get_reg(M68K_REG_A2); m68kr-&gt;a3 = m68k_get_reg(M68K_REG_A3); m68kr-&gt;a4 = m68k_get_reg(M68K_REG_A4); m68kr-&gt;a5 = m68k_get_reg(M68K_REG_A5); m68kr-&gt;a6 = m68k_get_reg(M68K_REG_A6); m68kr-&gt;a7 = m68k_get_reg(M68K_REG_A7); m68kr-&gt;pc = m68k_get_reg(M68K_REG_PC); m68kr-&gt;sr = m68k_get_reg(M68K_REG_SR); m68kr-&gt;sp = m68k_get_reg(M68K_REG_SP); m68kr-&gt;usp = m68k_get_reg(M68K_REG_USP); m68kr-&gt;isp = m68k_get_reg(M68K_REG_ISP); m68kr-&gt;ppc = m68k_get_reg(M68K_REG_PPC); m68kr-&gt;ir = m68k_get_reg(M68K_REG_IR); } else { m68k_set_reg(M68K_REG_D0, m68kr-&gt;d0); m68k_set_reg(M68K_REG_D1, m68kr-&gt;d1); m68k_set_reg(M68K_REG_D2, m68kr-&gt;d2); m68k_set_reg(M68K_REG_D3, m68kr-&gt;d3); m68k_set_reg(M68K_REG_D4, m68kr-&gt;d4); m68k_set_reg(M68K_REG_D5, m68kr-&gt;d5); m68k_set_reg(M68K_REG_D6, m68kr-&gt;d6); m68k_set_reg(M68K_REG_D7, m68kr-&gt;d7); m68k_set_reg(M68K_REG_A0, m68kr-&gt;a0); m68k_set_reg(M68K_REG_A1, m68kr-&gt;a1); m68k_set_reg(M68K_REG_A2, m68kr-&gt;a2); m68k_set_reg(M68K_REG_A3, m68kr-&gt;a3); m68k_set_reg(M68K_REG_A4, m68kr-&gt;a4); m68k_set_reg(M68K_REG_A5, m68kr-&gt;a5); m68k_set_reg(M68K_REG_A6, m68kr-&gt;a6); m68k_set_reg(M68K_REG_A7, m68kr-&gt;a7); m68k_set_reg(M68K_REG_PC, m68kr-&gt;pc); m68k_set_reg(M68K_REG_SR, m68kr-&gt;sr); m68k_set_reg(M68K_REG_SP, m68kr-&gt;sp); m68k_set_reg(M68K_REG_USP, m68kr-&gt;usp); m68k_set_reg(M68K_REG_ISP, m68kr-&gt;isp); } } if (regs_data-&gt;type &amp; REG_TYPE_VDP) { vdp_regs_t *vdp_regs = &amp;regs_data-&gt;vdp_regs; for (int i = 0; i &lt; (sizeof(vdp_regs) / sizeof(vdp_regs-&gt;regs_vdp[0])); ++i) { if (dbg_req-&gt;req_type == REQ_GET_REGS) vdp_regs-&gt;regs_vdp[i] = reg[i]; else reg[i] = vdp_regs-&gt;regs_vdp[i]; } if (dbg_req-&gt;req_type == REQ_GET_REGS) { vdp_regs-&gt;dma_len = (reg[20] &lt;&lt; 8) | reg[19]; if (!vdp_regs-&gt;dma_len) vdp_regs-&gt;dma_len = 0x10000; vdp_regs-&gt;dma_src = vdp_dma_calc_src(); vdp_regs-&gt;dma_dst = vdp_dma_get_dst(); } } if (regs_data-&gt;type &amp; REG_TYPE_Z80) { regs_z80_data_t *z80r = &amp;regs_data-&gt;regs_z80; if (dbg_req-&gt;req_type == REQ_GET_REGS) { z80r-&gt;pc = Z80.pc.d; z80r-&gt;sp = Z80.sp.d; z80r-&gt;af = Z80.af.d; z80r-&gt;bc = Z80.bc.d; z80r-&gt;de = Z80.de.d; z80r-&gt;hl = Z80.hl.d; z80r-&gt;ix = Z80.ix.d; z80r-&gt;iy = Z80.iy.d; z80r-&gt;wz = Z80.wz.d; z80r-&gt;af2 = Z80.af2.d; z80r-&gt;bc2 = Z80.bc2.d; z80r-&gt;de2 = Z80.de2.d; z80r-&gt;hl2 = Z80.hl2.d; z80r-&gt;r = Z80.r; z80r-&gt;r2 = Z80.r2; z80r-&gt;iff1 = Z80.iff1; z80r-&gt;iff2 = Z80.iff2; z80r-&gt;halt = Z80.halt; z80r-&gt;im = Z80.im; z80r-&gt;i = Z80.i; } else { Z80.pc.d = z80r-&gt;pc; Z80.sp.d = z80r-&gt;sp; Z80.af.d = z80r-&gt;af; Z80.bc.d = z80r-&gt;bc; Z80.de.d = z80r-&gt;de; Z80.hl.d = z80r-&gt;hl; Z80.ix.d = z80r-&gt;ix; Z80.iy.d = z80r-&gt;iy; Z80.wz.d = z80r-&gt;wz; Z80.af2.d = z80r-&gt;af2; Z80.bc2.d = z80r-&gt;bc2; Z80.de2.d = z80r-&gt;de2; Z80.hl2.d = z80r-&gt;hl2; Z80.r = z80r-&gt;r; Z80.r2 = z80r-&gt;r2; Z80.iff1 = z80r-&gt;iff1; Z80.iff2 = z80r-&gt;iff2; Z80.halt = z80r-&gt;halt; Z80.im = z80r-&gt;im; Z80.i = z80r-&gt;i; } } } break; case REQ_READ_68K_ROM: case REQ_READ_68K_RAM: case REQ_READ_Z80: { dbg_dont_check_bp = 1; memory_data_t *mem_data = &amp;dbg_req-&gt;mem_data; for (int i = 0; i &lt; mem_data-&gt;size; ++i) { switch (dbg_req-&gt;req_type) { case REQ_READ_68K_ROM: mem_data-&gt;m68k_rom[mem_data-&gt;address + i] = m68ki_read_8(mem_data-&gt;address + i); break; case REQ_READ_68K_RAM: mem_data-&gt;m68k_ram[(mem_data-&gt;address + i) &amp; 0xFFFF] = m68ki_read_8(mem_data-&gt;address + i); break; case REQ_READ_Z80: mem_data-&gt;z80_ram[(mem_data-&gt;address + i) &amp; 0x1FFF] = z80_readmem(mem_data-&gt;address + i); break; default: break; } } dbg_dont_check_bp = 0; } break; case REQ_WRITE_68K_ROM: case REQ_WRITE_68K_RAM: case REQ_WRITE_Z80: { dbg_dont_check_bp = 1; memory_data_t *mem_data = &amp;dbg_req-&gt;mem_data; for (int i = 0; i &lt; mem_data-&gt;size; ++i) { switch (dbg_req-&gt;req_type) { case REQ_WRITE_68K_ROM: m68ki_write_8(mem_data-&gt;address + i, mem_data-&gt;m68k_rom[mem_data-&gt;address + i]); break; case REQ_WRITE_68K_RAM: m68ki_write_8(0xFF0000 | ((mem_data-&gt;address + i) &amp; 0xFFFF), mem_data-&gt;m68k_ram[(mem_data-&gt;address + i) &amp; 0xFFFF]); break; case REQ_WRITE_Z80: z80_writemem(mem_data-&gt;address + i, mem_data-&gt;z80_ram[(mem_data-&gt;address + i) &amp; 0x1FFF]); break; default: break; } } dbg_dont_check_bp = 0; } break; case REQ_ADD_BREAK: { bpt_data_t *bpt_data = &amp;dbg_req-&gt;bpt_data; if (!find_breakpoint(bpt_data-&gt;address, bpt_data-&gt;type)) add_bpt(bpt_data-&gt;type, bpt_data-&gt;address, bpt_data-&gt;width); } break; case REQ_TOGGLE_BREAK: { bpt_data_t *bpt_data = &amp;dbg_req-&gt;bpt_data; breakpoint_t *bp = find_breakpoint(bpt_data-&gt;address, bpt_data-&gt;type); if (bp != NULL) bp-&gt;enabled = !bp-&gt;enabled; } break; case REQ_DEL_BREAK: { bpt_data_t *bpt_data = &amp;dbg_req-&gt;bpt_data; remove_bpt(bpt_data-&gt;address, bpt_data-&gt;type); } break; case REQ_CLEAR_BREAKS: clear_bpt_list(); case REQ_LIST_BREAKS: { bpt_list_t *bpt_list = &amp;dbg_req-&gt;bpt_list; bpt_list-&gt;count = count_bpt_list(); for (int i = 0; i &lt; bpt_list-&gt;count; ++i) get_bpt_data(i, &amp;bpt_list-&gt;breaks[i]); } break; case REQ_ATTACH: activate_debugger(); dbg_first_paused = 0; break; case REQ_PAUSE: pause_debugger(); break; case REQ_RESUME: resume_debugger(); break; case REQ_STOP: stop_debugging(); break; case REQ_STEP_INTO: { if (dbg_req-&gt;dbg_paused) { dbg_trace = 1; dbg_req-&gt;dbg_paused = 0; } } break; case REQ_STEP_OVER: { if (dbg_req-&gt;dbg_paused) { unsigned int dest_pc = calc_step_over(); if (dest_pc != (unsigned int)(-1)) { dbg_step_over = 1; dbg_step_over_addr = dest_pc; } else { dbg_step_over = 0; dbg_step_over_addr = 0; dbg_trace = 1; } dbg_req-&gt;dbg_paused = 0; } } break; default: break; } dbg_req-&gt;req_type = REQ_NO_REQUEST; } void send_dbg_event(dbg_event_type_t type) { dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].type = type; dbg_req-&gt;dbg_events_count += 1; } void stop_debugging() { send_dbg_event(DBG_EVT_STOPPED); detach_debugger(); deactivate_debugger(); dbg_first_paused = dbg_req-&gt;dbg_paused = dbg_trace = dbg_dont_check_bp = dbg_step_over = dbg_step_over_addr = dbg_last_pc = 0; } void start_debugging() { if (dbg_req != NULL &amp;&amp; dbg_req-&gt;dbg_active) return; activate_debugger(); init_bpt_list(); dbg_first_paused = dbg_req-&gt;dbg_paused = dbg_trace = dbg_dont_check_bp = dbg_step_over = dbg_step_over_addr = dbg_last_pc = 0; } int is_debugger_accessible() { return (dbg_req != NULL); } void process_breakpoints() { int handled_event = 0; int is_step_over = 0; int is_step_in = 0; unsigned int pc = m68k_get_reg(M68K_REG_PC); if (!dbg_req || !dbg_req-&gt;dbg_active) return; if (dbg_req-&gt;dbg_paused &amp;&amp; dbg_first_paused &amp;&amp; !dbg_trace) longjmp(jmp_env, 1); if (!dbg_first_paused) { dbg_first_paused = 1; dbg_req-&gt;dbg_paused = 1; dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].pc = pc; strncpy(dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].msg, "gpgx", sizeof(dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].msg)); send_dbg_event(DBG_EVT_STARTED); } if (dbg_trace) { is_step_in = 1; dbg_trace = 0; dbg_req-&gt;dbg_paused = 1; dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].pc = pc; send_dbg_event(DBG_EVT_STEP); handled_event = 1; } if (!dbg_req-&gt;dbg_paused) { if (dbg_step_over &amp;&amp; pc == dbg_step_over_addr) { is_step_over = 1; dbg_step_over = 0; dbg_step_over_addr = 0; dbg_req-&gt;dbg_paused = 1; } if (dbg_last_pc != pc) check_breakpoint(BPT_M68K_E, 1, pc, pc); if (dbg_req-&gt;dbg_paused) { dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].pc = pc; send_dbg_event(is_step_over ? DBG_EVT_STEP : DBG_EVT_BREAK); handled_event = 1; } } if (dbg_first_paused &amp;&amp; (!handled_event) &amp;&amp; dbg_req-&gt;dbg_paused) { dbg_req-&gt;dbg_events[dbg_req-&gt;dbg_events_count].pc = pc; send_dbg_event(DBG_EVT_PAUSED); } dbg_last_pc = pc; if (dbg_req-&gt;dbg_paused &amp;&amp; (!is_step_in || is_step_over)) { longjmp(jmp_env, 1); } } int is_debugger_paused() { return is_debugger_accessible() &amp;&amp; dbg_req-&gt;dbg_paused &amp;&amp; dbg_first_paused &amp;&amp; !dbg_trace; }</span></span></span></span></code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title">  debug.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _DEBUG_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _DEBUG_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __cplusplus extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;setjmp.h&gt; #include "debug_wrap.h" extern void start_debugging(); extern void stop_debugging(); extern int is_debugger_accessible(); extern void process_request(); extern int is_debugger_paused(); extern int activate_shared_mem(); extern void deactivate_shared_mem(); void check_breakpoint(bpt_type_t type, int width, unsigned int address, unsigned int value); extern jmp_buf jmp_env; #ifdef __cplusplus } #endif #endif</span></span></span></span></code> </pre> </div></div><br><p>              . <br> ,    <code>check_breakpoint</code>  <code>VDP</code>       <code>#ifdef LOGVDP</code> .       <code>vdp_ctrl.c</code> : </p><br><pre> <code class="cpp hljs">check_breakpoint(BPT_VRAM_W, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_CRAM_W, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_VSRAM_W, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_VRAM_R, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_CRAM_R, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data); ... check_breakpoint(BPT_VSRAM_R, <span class="hljs-number"><span class="hljs-number">2</span></span>, addr, data);</code> </pre> <br><p>  <code>RAM</code>     ( <code>m68kcpu.h</code> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// m68ki_read_8 check_breakpoint(BPT_M68K_R, 1, address, val); // m68ki_read_16 check_breakpoint(BPT_M68K_R, 2, address, val); // m68ki_read_32 check_breakpoint(BPT_M68K_R, 4, address, val); // m68ki_write_8 check_breakpoint(BPT_M68K_W, 1, address, val); // m68ki_write_16 check_breakpoint(BPT_M68K_W, 2, address, val); // m68ki_write_32 check_breakpoint(BPT_M68K_W, 4, address, val);</span></span></code> </pre> <br><p>      ,      ,      . </p><br><div class="spoiler"> <b class="spoiler_title">  debug_wrap.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Windows.h&gt; #include &lt;process.h&gt; #include "debug_wrap.h" static HANDLE hMapFile = NULL, hStartFunc = NULL; dbg_request_t *open_shared_mem() { hMapFile = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, SHARED_MEM_NAME); if (hMapFile == NULL) { return NULL; } dbg_request_t *request = (dbg_request_t *)MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(dbg_request_t)); if (request == NULL) { CloseHandle(hMapFile); return NULL; } return request; } void close_shared_mem(dbg_request_t **request) { UnmapViewOfFile(*request); CloseHandle(hMapFile); hMapFile = NULL; *request = NULL; } int recv_dbg_event(dbg_request_t *request, int wait) { while (request-&gt;dbg_active || request-&gt;dbg_events_count) { for (int i = 0; i &lt; MAX_DBG_EVENTS; ++i) { if (request-&gt;dbg_events[i].type != DBG_EVT_NO_EVENT) { request-&gt;dbg_events_count -= 1; return i; } } if (!wait) return -1; Sleep(10); } return -1; } void send_dbg_request(dbg_request_t *request, request_type_t type) { if (!request) return; request-&gt;req_type = type; while (request-&gt;dbg_active &amp;&amp; request-&gt;req_type != REQ_NO_REQUEST) { Sleep(10); } }</span></span></span></span></code> </pre> </div></div><br><p>       .   ,  . ,         , ,      . </p><br><h3 id="yadro-otladchika-zapusk">  :  </h3><br><p>          <code>Genesis Plus GX</code> : </p><br><pre> <code class="cpp hljs"> var.key = <span class="hljs-string"><span class="hljs-string">"genesis_plus_gx_debugger"</span></span>; environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &amp;var); { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!var.value || !<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(var.value, <span class="hljs-string"><span class="hljs-string">"disabled"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_debugger_accessible()) { stop_debugging(); stop_gui(); deactivate_shared_mem(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { activate_shared_mem(); start_debugging(); run_gui(); } } ... { <span class="hljs-string"><span class="hljs-string">"genesis_plus_gx_debugger"</span></span>, <span class="hljs-string"><span class="hljs-string">"Debugger; disabled|enabled"</span></span> },</code> </pre> <br><p>    <code>RetroArch</code> : <br>   ,      <code>retro_run()</code> .      (      ),    . ,      <code>retro_run()</code> ,  <code>RetroArch</code>  .      <code>setjmp()</code> / <code>longjmp()</code> .  ,        <code>retro_run()</code> : </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_debugger_paused()) { longjmp(jmp_env, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> is_paused = setjmp(jmp_env); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_paused) { process_request(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>      <code>retro_run()</code>      <code>process_request()</code> ,      ,    . </p><br><h3 id="ps-zatravka-dlya-vtoroy-chasti"> PS     </h3><br><p><img src="https://habrastorage.org/webt/uc/ln/ec/uclnecmakoun2veml3ooxfvaete.png"></p><br><p> <strong>Update</strong> : <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a>      -  <code>IDA Pro</code> ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434992/">https://habr.com/ru/post/de434992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434976/index.html">ITMO University Fablab: DIY-Coworking für kreative Menschen - zeigen Sie, was drin ist</a></li>
<li><a href="../de434978/index.html">Einführung in HealthKit</a></li>
<li><a href="../de434982/index.html">Perspektive: MultiClet S1</a></li>
<li><a href="../de434984/index.html">Warum ich Eloquent ORM hasse</a></li>
<li><a href="../de434986/index.html">Grundlegende Konzepte der Standard-C ++ - Bibliothek</a></li>
<li><a href="../de434994/index.html">Android: Erstellen dynamischer Produktaromen und Signieren von Konfigurationen</a></li>
<li><a href="../de434996/index.html">Wie ich den Standort über die VK-API freigegeben habe</a></li>
<li><a href="../de434998/index.html">Ein weiterer Artikel zur Auswahl eines Smartphones</a></li>
<li><a href="../de435002/index.html">IDA Pro aktualisieren. Debugger für Sega Mega Drive (Teil 2)</a></li>
<li><a href="../de435006/index.html">Wo und wie machen Kernreaktoren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>