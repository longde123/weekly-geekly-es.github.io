<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüè≠ üôéüèª üå¥ Evil Parcel Schwachstellenanalyse ü§¶üèæ üïñ üëáüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Mitte April ver√∂ffentlichten wir Nachrichten √ºber den Trojaner Android.InfectionAds.1 , der mehrere kritische Sicherheitsl√ºcken in Androi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Evil Parcel Schwachstellenanalyse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/drweb/blog/457610/"><h3>  Einf√ºhrung </h3><br>  Mitte April ver√∂ffentlichten wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nachrichten</a> √ºber den Trojaner <b>Android.InfectionAds.1</b> , der mehrere kritische Sicherheitsl√ºcken in Android ausnutzte.  Mit CVE-2017-13156 (auch als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Janus bekannt</a> ) kann Malware APK-Dateien infizieren, ohne die digitale Signatur zu besch√§digen.  Der andere ist CVE-2017-13315.  Es gibt dem Trojaner erweiterte Berechtigungen, sodass er Anwendungen unabh√§ngig vom Benutzer installieren und deinstallieren kann.  Eine detaillierte Analyse von <b>Android.InfectionAds.1 finden Sie</b> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unserer</a> <b>Virenbibliothek</b> .  W√§hrend wir hier sind, werden wir die Sicherheitsanf√§lligkeit CVE-2017-13315 ansprechen und sehen, was sie bewirkt. <br><a name="habracut"></a><br>  CVE-2017-13315 geh√∂rt zur Gruppe der Sicherheitsl√ºcken, die als EvilParcel bezeichnet werden.  Sie sind in verschiedenen Android-Systemklassen zu finden.  Fehler in diesen Klassen erm√∂glichen es, Informationen w√§hrend des Datenaustauschs zwischen Apps und dem System zu ersetzen.  Malware, die die EvilParcel-Schwachstellen ausnutzt, erh√§lt daher h√∂here Berechtigungen und kann Folgendes: <br><br><ul><li>  Installieren und Entfernen von Anwendungen mit Berechtigungen ohne Best√§tigung durch Benutzer; </li><li>  Infizieren von auf dem Ger√§t installierter Software und Ersetzen sauberer Originale durch infizierte Kopien, wenn diese zusammen mit anderen Schwachstellen verwendet werden; </li><li>  Zur√ºcksetzen der Sperrbildschirm-PIN auf Android-Ger√§ten. </li></ul><br>  Derzeit sind uns 7 Sicherheitsl√ºcken dieses Typs bekannt: <br><ul><li>  CVE-2017-0806 (Fehler in der GateKeeperResponse-Klasse), ver√∂ffentlicht im Oktober 2017; </li><li>  CVE-2017-13286 (Fehler in der OutputConfiguration-Klasse, ver√∂ffentlicht im April 2018; </li><li>  CVE-2017-13287 (Fehler in der VerifyCredentialResponse-Klasse), ver√∂ffentlicht im April 2018; </li><li>  CVE-2017-13288 (Fehler in der PeriodicAdvertizingReport-Klasse), ver√∂ffentlicht im April 2018; </li><li>  CVE-2017-13289 (Fehler in der ParcelableRttResults-Klasse), ver√∂ffentlicht im April 2018; </li><li>  CVE-2017-13311 (Fehler in der SparseMappingTable-Klasse), ver√∂ffentlicht im Mai 2018; </li><li>  CVE-2017-13315 (Fehler in der DcParamObject-Klasse), ver√∂ffentlicht im Mai 2018. </li></ul><br>  Alle stellen eine Bedrohung f√ºr Ger√§te dar, auf denen Android 5.0 - 8.1 ausgef√ºhrt wird, ohne dass ein Sicherheitsupdate f√ºr Mai 2018 (oder h√∂her) installiert ist. <br><br><h3>  Voraussetzungen f√ºr EvilParcel-Schwachstellen </h3><br>  Mal sehen, wie EvilParcel-Schwachstellen auftreten k√∂nnen.  Zun√§chst m√ºssen wir uns einige Funktionen der Android-Anwendungen ansehen.  Alle Android-Programme interagieren miteinander und mit dem Betriebssystem, indem sie Intent-Objekte senden und empfangen.  Diese Objekte k√∂nnen eine beliebige Anzahl von Schl√ºssel-Wert-Paaren innerhalb eines Bundle-Objekts enthalten. <br><br>  Beim √úbertragen einer Absicht wird ein Bundle-Objekt in ein in Parcel eingeschlossenes Byte-Array konvertiert (serialisiert) und nach dem Lesen von Schl√ºsseln und Werten aus einem serialisierten Bundle automatisch deserialisiert. <br><br>  Im Bundle ist der Schl√ºssel die Zeichenfolge, und der Wert kann fast alles sein.  Beispielsweise kann es sich um einen primitiven Typ, eine Zeichenfolge oder einen Container mit primitiven Typen oder Zeichenfolgen handeln.  Es kann auch ein Paketobjekt sein. <br><br>  Somit kann das Bundle ein Objekt eines beliebigen Typs enthalten, der die Parcelable-Schnittstelle implementiert.  Dazu m√ºssen wir die Methoden writeToParcel () und createFromParcel () implementieren, um das Objekt zu serialisieren und zu deserialisieren. <br><br>  Um unseren Standpunkt zu veranschaulichen, erstellen wir ein einfaches serialisiertes Bundle.  Wir werden einen Code schreiben, der drei Schl√ºssel-Wert-Paare in das Bundle einf√ºgt und es serialisiert: <br><br><img src="https://habrastorage.org/webt/pf/-9/2j/pf-92jsexpyrb7p2dvi8oj3-vbs.png"><br>  Abbildung 1. Struktur eines serialisierten B√ºndelobjekts <br><br>  Beachten Sie die Besonderheiten der Bundle-Serialisierung: <br><br><ul><li>  Alle Schl√ºssel-Wert-Paare werden nacheinander geschrieben. </li><li>  Der Wertetyp wird vor jedem Wert angegeben (13 f√ºr das Bytearray, 1 f√ºr die Ganzzahl, 0 f√ºr die Zeichenfolge usw.). </li><li>  Datengr√∂√üe variabler L√§nge wird vor den Daten angegeben (L√§nge f√ºr die Zeichenfolge, Anzahl der Bytes f√ºr das Array); </li><li>  Alle Werte sind 4 Byte ausgerichtet. </li></ul><br><br>  Alle Schl√ºssel und Werte werden nacheinander in das Bundle geschrieben, sodass beim Zugriff auf einen Schl√ºssel oder Wert eines serialisierten Bundle-Objekts dieses vollst√§ndig deserialisiert und auch alle enthaltenen Parcelable-Objekte initialisiert werden. <br><br>  Also, was k√∂nnte das Problem sein?  Das Problem ist, dass einige Systemklassen, die Parcelable implementieren, m√∂glicherweise Fehler in den Methoden createFromParcel () und writeToParcel () enthalten.  In diesen Klassen unterscheidet sich die Anzahl der in createFromParcel () gelesenen Bytes von der Anzahl der in writeToParcel () geschriebenen Bytes.  Wenn Sie ein Objekt dieser Klasse in einem Bundle platzieren, √§ndern sich die Objektgrenzen innerhalb des Bundles nach der erneuten Initialisierung.  Dies schafft die Voraussetzungen f√ºr die Ausnutzung einer EvilParcel-Sicherheitsanf√§lligkeit. <br><br>  Sehen wir uns ein Beispiel f√ºr eine Klasse an, die diesen Fehler enth√§lt: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parcelable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel in)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = in.readInt(); data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[length]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { in.readByteArray(data); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Creator&lt;Demo&gt; CREATOR = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Creator&lt;Demo&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Demo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createFromParcel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel in)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Demo(in); } }; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeToParcel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel parcel, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ parcel.writeInt(data.length); parcel.writeByteArray(data); } }</code> </pre> <br>  Wenn die Datenarraygr√∂√üe 0 ist, wird beim Erstellen eines Objekts ein int (4 Byte) in createFromParcel () gelesen und zwei int (8 Byte) in writeToParcel () geschrieben.  Das erste int wird durch expliziten Aufruf von writeInt geschrieben.  Das zweite int wird beim Aufruf von writeByteArray () geschrieben, da die Arrayl√§nge immer vor dem Array in Parcel geschrieben wird (siehe Abbildung 1). <br><br>  Situationen, in denen die Gr√∂√üe des Datenarrays gleich 0 ist, sind ziemlich selten.  Aber selbst wenn dies passiert, l√§uft das Programm weiter, wenn Sie jeweils nur ein serialisiertes Objekt √ºbertragen (in unserem Beispiel das Demo-Objekt).  Daher bleiben solche Fehler in der Regel unbemerkt. <br><br>  Jetzt versuchen wir, ein Demo-Objekt mit einer Array-L√§nge von Null im Bundle zu platzieren: <br><br><img src="https://habrastorage.org/webt/2y/2v/i0/2y2vi0ftdkartg9i01cc-b858g0.png"><br>  Abbildung 2. Das Ergebnis des Hinzuf√ºgens eines Demo-Objekts mit der L√§nge Null zum Bundle <br><br>  Wir serialisieren das Objekt: <br><br><img src="https://habrastorage.org/webt/hv/tw/if/hvtwifj9curkc7ip6jplbdlk-yc.png"><br>  Abbildung 3. Das Bundle-Objekt nach der Serialisierung <br><br>  Versuchen wir nun, es zu deserialisieren: <br><br><img src="https://habrastorage.org/webt/_u/a1/k4/_ua1k4hp34wknsvnppv8zla0jei.png"><br>  Abbildung 4. Das Bundle-Objekt nach der Deserialisierung <br><br>  Was bekommen wir?  Schauen wir uns das Paketfragment an: <br><br><img src="https://habrastorage.org/webt/tf/qa/fn/tfqafnxzmsfujmq2xyo-kwvbc2g.png"><br>  Abbildung 5. Paketstruktur nach Bundle-Deserialisierung <br><br>  In den Abbildungen 4 und 5 sehen wir, dass w√§hrend der Deserialisierung anstelle von zwei int ein int in der createFromParcel-Methode gelesen wurde.  Daher wurden alle nachfolgenden Werte aus dem Bundle falsch gelesen.  Der 0x0-Wert bei 0x60 wurde als L√§nge des n√§chsten Schl√ºssels gelesen.  Der 0x1-Wert bei 0x64 wurde als Schl√ºssel gelesen.  Der 0x31-Wert bei 0x68 wurde als Werttyp gelesen.  Paket hat keine Werte vom Typ 0x31, daher meldet readFromParcel () sorgf√§ltig eine Ausnahme. <br><br>  Wie kann dies im wirklichen Leben genutzt werden und zu einer Verwundbarkeit werden?  Mal sehen!  Der obige Fehler in den Parcelable-Systemklassen erm√∂glicht die Erstellung von Bundles, die sich w√§hrend der ersten und wiederholten Deserialisierung unterscheiden k√∂nnen.  Um dies zu demonstrieren, √§ndern wir das vorherige Beispiel: <br><br><pre> <code class="java hljs">Parcel data = Parcel.obtain(); data.writeInt(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3 entries data.writeString("vuln_class"); data.writeInt(4); // value is Parcelable data.writeString("com.drweb.testbundlemismatch.Demo"); data.writeInt(0); // data.length data.writeInt(1); // key length -&gt; key value data.writeInt(6); // key value -&gt; value is long data.writeInt(0xD); // value is bytearray -&gt; low(long) data.writeInt(-1); // bytearray length dummy -&gt; high(long) int startPos = data.dataPosition(); data.writeString("hidden"); // bytearray data -&gt; hidden key data.writeInt(0); // value is string data.writeString("Hi there"); // hidden value int endPos = data.dataPosition(); int triggerLen = endPos - startPos; data.setDataPosition(startPos - 4); data.writeInt(triggerLen); // overwrite dummy value with the real value data.setDataPosition(endPos); data.writeString("A padding"); data.writeInt(0); // value is string data.writeString("to match pair count"); int length = data.dataSize(); Parcel bndl = Parcel.obtain(); bndl.writeInt(length); bndl.writeInt(0x4C444E42); // bundle magic bndl.appendFrom(data, 0, length); bndl.setDataPosition(0);</span></span></code> </pre> <br>  Dieser Code erstellt ein serialisiertes Bundle, das eine anf√§llige Klasse enth√§lt.  Nun wollen wir sehen, was wir nach der Ausf√ºhrung dieses Codes erhalten: <br><br><img src="https://habrastorage.org/webt/tc/ke/wf/tckewffnaop28wllxnrt7pagdvs.png"><br>  Abbildung 6. Erstellen eines Bundles mit einer anf√§lligen Klasse <br><br>  Nach der ersten Deserialisierung enth√§lt dieses Bundle die folgenden Schl√ºssel: <br><br><img src="https://habrastorage.org/webt/cj/si/l0/cjsil0--g_jsoew8ht-oxely1u4.png"><br>  Abbildung 7. Nach der Deserialisierung eines Bundles mit einer anf√§lligen Klasse <br><br>  Jetzt werden wir das Bundle erneut serialisieren, dann erneut deserialisieren und uns die Liste der Schl√ºssel ansehen: <br><br><img src="https://habrastorage.org/webt/uw/e1/mj/uwe1mjdtywr59oyshaah2q1gkus.png"><br>  Abbildung 8. Ergebnis der Reserialisierung und Deserialisierung eines Bundles mit einer anf√§lligen Klasse <br><br>  Was sehen wir?  Das Bundle enth√§lt jetzt den versteckten Schl√ºssel (mit dem Zeichenfolgenwert "Hi there!"), Der vorher nicht vorhanden war.  Schauen wir uns das Paketfragment dieses Bundles an, um herauszufinden, warum dies passiert ist: <br><br><img src="https://habrastorage.org/webt/i8/up/j1/i8upj1jif-_d41drqii19gw2nce.png"><br>  Abbildung 9. Paketstruktur eines Bundle-Objekts mit einer anf√§lligen Klasse nach zwei Serialisierungs- und Deserialisierungszyklen <br><br>  Hier k√∂nnen wir den ganzen Punkt der EvilParcel-Schwachstellen erkennen.  Wir k√∂nnen speziell ein Bundle erstellen, das eine anf√§llige Klasse enth√§lt.  Durch √Ñndern der Grenzen dieser Klasse k√∂nnen beliebige Objekte in diesem Bundle platziert werden.  Zum Beispiel eine Absicht, die erst nach der zweiten Deserialisierung im Bundle erscheint.  Dies hilft, eine Absicht vor den Sicherheitsmechanismen des Betriebssystems zu verbergen. <br><br><h3>  EvilParcel ausnutzen </h3><br>  <b>Android.InfectionAds.1</b> nutzte CVE-2017-13315, um Software unabh√§ngig von Ger√§tebesitzern zu installieren und zu entfernen.  Aber wie? <br><br>  Im Jahr 2013 wurde der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehler 7699048</a> , auch als Launch AnyWhere bekannt, entdeckt.  Es erm√∂glichte Anwendungen von Drittanbietern, beliebige Aktivit√§ten f√ºr einen privilegierteren Systembenutzer zu starten.  In der folgenden Abbildung finden Sie den Aktionsmechanismus: <br><br><img src="https://habrastorage.org/webt/in/d8/-m/ind8-mnyp5urfsndbkycy3l42f8.png"><br>  Abbildung 10. Bedienung des Fehlers 7699048 <br><br>  Eine ausnutzende Anwendung kann diese Sicherheitsanf√§lligkeit verwenden, um den Kontoauthentifizierungsdienst zu implementieren, mit dem dem Betriebssystem neue Konten hinzugef√ºgt werden sollen.  Der Fehler 7699048 hilft den Exploit-Startaktivit√§ten beim Installieren, Entfernen, Ersetzen von Anwendungen sowie beim Zur√ºcksetzen der PIN oder der Mustersperre und verursacht viel mehr Probleme. <br><br>  Google Inc.  hat diesen Versto√ü beseitigt, indem der Start willk√ºrlicher Aktivit√§ten von AccountManager verboten wurde.  Jetzt erm√∂glicht AccountManager nur das Starten von Aktivit√§ten, die von derselben Anwendung stammen.  Zu diesem Zweck wird die digitale Signatur der Software, die die Aktivit√§t initiiert hat, √ºberpr√ºft und mit der Signatur der Anwendung abgeglichen, in der sich die Aktivit√§t befindet.  Es sieht so aus: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; (intent = result.getParcelable(AccountManager.KEY_INTENT)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* * The Authenticator API allows third party authenticators to * supply arbitrary intents to other apps that they can run, * this can be very bad when those apps are in the system like * the System Settings. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> authenticatorUid = Binder.getCallingUid(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> bid = Binder.clearCallingIdentity(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { PackageManager pm = mContext.getPackageManager(); ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, <span class="hljs-number"><span class="hljs-number">0</span></span>, mAccounts.userId); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetUid = resolveInfo.activityInfo.applicationInfo.uid; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PackageManager.SIGNATURE_MATCH != pm.checkSignatures(authenticatorUid, targetUid)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecurityException( <span class="hljs-string"><span class="hljs-string">"Activity to be started with KEY_INTENT must "</span></span> + <span class="hljs-string"><span class="hljs-string">"share Authenticator's signatures"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { Binder.restoreCallingIdentity(bid); } }</code> </pre><br>  Es scheint, dass das Problem gel√∂st wurde, aber es ist nicht so einfach.  Es stellte sich heraus, dass die bekannte Sicherheitsanf√§lligkeit EvilParcel CVE-2017-13315 eine Problemumgehung bietet!  Wie wir bereits wissen, √ºberpr√ºft das System nach dem Reparieren von Launch AnyWhere die digitale Signatur der Anwendung.  Wenn es erfolgreich √ºberpr√ºft wurde, wird das Bundle an IAccountManagerResponse.onResult () √ºbertragen.  Gleichzeitig wird onResult () √ºber den IPC-Mechanismus aufgerufen, sodass das Bundle erneut serialisiert wird.  W√§hrend der Implementierung von onResult () geschieht Folgendes: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** Handles the responses from the AccountManager */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAccountManagerResponse</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stub</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ Intent intent = bundle.getParcelable(KEY_INTENT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; mActivity != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// since the user provided an Activity we will silently start intents // that we see mActivity.startActivity(intent); // leave the Future running to wait for the real response to this request } //&lt;.....&gt; } //&lt;.....&gt; }</span></span></code> </pre><br>  Anschlie√üend extrahiert das Bundle den Intent-Schl√ºssel und die Aktivit√§t wird ohne √úberpr√ºfung gestartet. <br>  Um eine beliebige Aktivit√§t mit Systemberechtigungen zu starten, m√ºssen Sie lediglich ein Bundle mit dem Feld Intent erstellen, das bei der ersten Deserialisierung ausgeblendet wird und w√§hrend der wiederholten Deserialisierung angezeigt wird. <br>  Wie wir bereits wissen, k√∂nnen EvilParcel-Schwachstellen diese Aufgabe tats√§chlich ausf√ºhren. <br><br>  Im Moment wurden alle bekannten Schwachstellen dieses Typs innerhalb der anf√§lligen Parcelable-Klassen behoben.  In Zukunft werden jedoch m√∂glicherweise neue anf√§llige Klassen angezeigt.  Die Bundle-Implementierung und der Mechanismus zum Hinzuf√ºgen neuer Konten sind weiterhin dieselben wie zuvor.  Sie erm√∂glichen es uns weiterhin, genau diesen Exploit zu erstellen, wenn wir alte oder neue anf√§llige Paketklassen erkennen.  Dar√ºber hinaus werden diese Klassen immer noch manuell implementiert, und der Programmierer muss sicherstellen, dass die L√§nge des serialisierten Parcelable-Objekts gleich bleibt, was bei allem, was dies impliziert, ein menschlicher Faktor ist.  Wir hoffen jedoch, dass es so wenige Fehler wie m√∂glich gibt und die EvilParcel-Schwachstellen keine Bedrohung f√ºr Android-Benutzer darstellen. <br><br>  Sie k√∂nnen Ihr Mobilger√§t mithilfe unseres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dr.Web Security Space</a> f√ºr Android auf EvilParcel-Schwachstellen √ºberpr√ºfen.  Der integrierte Sicherheitspr√ºfer meldet die erkannten Probleme und empfiehlt M√∂glichkeiten, sie zu beheben. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457610/">https://habr.com/ru/post/de457610/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457596/index.html">OSDay 19 oder warum die C-Sprache noch lebt</a></li>
<li><a href="../de457600/index.html">Headsets - √úbersicht Snom A150, Snom A100M und D.</a></li>
<li><a href="../de457602/index.html">Untersuchung der Leistung von DBMS MS SQL Server Developer 2016 und PostgreSQL 10.5 f√ºr 1C</a></li>
<li><a href="../de457606/index.html">Alan Kay: Was kann man als das Erstaunlichste bezeichnen, was Computer m√∂glich gemacht haben?</a></li>
<li><a href="../de457608/index.html">So visualisieren Sie Daten zu einer √ºberzeugenden Geschichte</a></li>
<li><a href="../de457612/index.html">Wie kann die LZ4-Dekomprimierung in ClickHouse beschleunigt werden?</a></li>
<li><a href="../de457614/index.html">Geheimnisse der Arbeitssuche im Ausland bei einem praktizierenden Headhunter</a></li>
<li><a href="../de457616/index.html">Mein "Wow, das wusste ich nicht!" Momente mit Scherz</a></li>
<li><a href="../de457618/index.html">Ein moderner Full-Stack-Entwickler sein</a></li>
<li><a href="../de457622/index.html">Qt-Leistung messen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>