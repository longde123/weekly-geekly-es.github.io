<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🏭 🙎🏻 🌴 Evil Parcel Schwachstellenanalyse 🤦🏾 🕖 👇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 
 Mitte April veröffentlichten wir Nachrichten über den Trojaner Android.InfectionAds.1 , der mehrere kritische Sicherheitslücken in Androi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Evil Parcel Schwachstellenanalyse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/drweb/blog/457610/"><h3>  Einführung </h3><br>  Mitte April veröffentlichten wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nachrichten</a> über den Trojaner <b>Android.InfectionAds.1</b> , der mehrere kritische Sicherheitslücken in Android ausnutzte.  Mit CVE-2017-13156 (auch als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Janus bekannt</a> ) kann Malware APK-Dateien infizieren, ohne die digitale Signatur zu beschädigen.  Der andere ist CVE-2017-13315.  Es gibt dem Trojaner erweiterte Berechtigungen, sodass er Anwendungen unabhängig vom Benutzer installieren und deinstallieren kann.  Eine detaillierte Analyse von <b>Android.InfectionAds.1 finden Sie</b> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unserer</a> <b>Virenbibliothek</b> .  Während wir hier sind, werden wir die Sicherheitsanfälligkeit CVE-2017-13315 ansprechen und sehen, was sie bewirkt. <br><a name="habracut"></a><br>  CVE-2017-13315 gehört zur Gruppe der Sicherheitslücken, die als EvilParcel bezeichnet werden.  Sie sind in verschiedenen Android-Systemklassen zu finden.  Fehler in diesen Klassen ermöglichen es, Informationen während des Datenaustauschs zwischen Apps und dem System zu ersetzen.  Malware, die die EvilParcel-Schwachstellen ausnutzt, erhält daher höhere Berechtigungen und kann Folgendes: <br><br><ul><li>  Installieren und Entfernen von Anwendungen mit Berechtigungen ohne Bestätigung durch Benutzer; </li><li>  Infizieren von auf dem Gerät installierter Software und Ersetzen sauberer Originale durch infizierte Kopien, wenn diese zusammen mit anderen Schwachstellen verwendet werden; </li><li>  Zurücksetzen der Sperrbildschirm-PIN auf Android-Geräten. </li></ul><br>  Derzeit sind uns 7 Sicherheitslücken dieses Typs bekannt: <br><ul><li>  CVE-2017-0806 (Fehler in der GateKeeperResponse-Klasse), veröffentlicht im Oktober 2017; </li><li>  CVE-2017-13286 (Fehler in der OutputConfiguration-Klasse, veröffentlicht im April 2018; </li><li>  CVE-2017-13287 (Fehler in der VerifyCredentialResponse-Klasse), veröffentlicht im April 2018; </li><li>  CVE-2017-13288 (Fehler in der PeriodicAdvertizingReport-Klasse), veröffentlicht im April 2018; </li><li>  CVE-2017-13289 (Fehler in der ParcelableRttResults-Klasse), veröffentlicht im April 2018; </li><li>  CVE-2017-13311 (Fehler in der SparseMappingTable-Klasse), veröffentlicht im Mai 2018; </li><li>  CVE-2017-13315 (Fehler in der DcParamObject-Klasse), veröffentlicht im Mai 2018. </li></ul><br>  Alle stellen eine Bedrohung für Geräte dar, auf denen Android 5.0 - 8.1 ausgeführt wird, ohne dass ein Sicherheitsupdate für Mai 2018 (oder höher) installiert ist. <br><br><h3>  Voraussetzungen für EvilParcel-Schwachstellen </h3><br>  Mal sehen, wie EvilParcel-Schwachstellen auftreten können.  Zunächst müssen wir uns einige Funktionen der Android-Anwendungen ansehen.  Alle Android-Programme interagieren miteinander und mit dem Betriebssystem, indem sie Intent-Objekte senden und empfangen.  Diese Objekte können eine beliebige Anzahl von Schlüssel-Wert-Paaren innerhalb eines Bundle-Objekts enthalten. <br><br>  Beim Übertragen einer Absicht wird ein Bundle-Objekt in ein in Parcel eingeschlossenes Byte-Array konvertiert (serialisiert) und nach dem Lesen von Schlüsseln und Werten aus einem serialisierten Bundle automatisch deserialisiert. <br><br>  Im Bundle ist der Schlüssel die Zeichenfolge, und der Wert kann fast alles sein.  Beispielsweise kann es sich um einen primitiven Typ, eine Zeichenfolge oder einen Container mit primitiven Typen oder Zeichenfolgen handeln.  Es kann auch ein Paketobjekt sein. <br><br>  Somit kann das Bundle ein Objekt eines beliebigen Typs enthalten, der die Parcelable-Schnittstelle implementiert.  Dazu müssen wir die Methoden writeToParcel () und createFromParcel () implementieren, um das Objekt zu serialisieren und zu deserialisieren. <br><br>  Um unseren Standpunkt zu veranschaulichen, erstellen wir ein einfaches serialisiertes Bundle.  Wir werden einen Code schreiben, der drei Schlüssel-Wert-Paare in das Bundle einfügt und es serialisiert: <br><br><img src="https://habrastorage.org/webt/pf/-9/2j/pf-92jsexpyrb7p2dvi8oj3-vbs.png"><br>  Abbildung 1. Struktur eines serialisierten Bündelobjekts <br><br>  Beachten Sie die Besonderheiten der Bundle-Serialisierung: <br><br><ul><li>  Alle Schlüssel-Wert-Paare werden nacheinander geschrieben. </li><li>  Der Wertetyp wird vor jedem Wert angegeben (13 für das Bytearray, 1 für die Ganzzahl, 0 für die Zeichenfolge usw.). </li><li>  Datengröße variabler Länge wird vor den Daten angegeben (Länge für die Zeichenfolge, Anzahl der Bytes für das Array); </li><li>  Alle Werte sind 4 Byte ausgerichtet. </li></ul><br><br>  Alle Schlüssel und Werte werden nacheinander in das Bundle geschrieben, sodass beim Zugriff auf einen Schlüssel oder Wert eines serialisierten Bundle-Objekts dieses vollständig deserialisiert und auch alle enthaltenen Parcelable-Objekte initialisiert werden. <br><br>  Also, was könnte das Problem sein?  Das Problem ist, dass einige Systemklassen, die Parcelable implementieren, möglicherweise Fehler in den Methoden createFromParcel () und writeToParcel () enthalten.  In diesen Klassen unterscheidet sich die Anzahl der in createFromParcel () gelesenen Bytes von der Anzahl der in writeToParcel () geschriebenen Bytes.  Wenn Sie ein Objekt dieser Klasse in einem Bundle platzieren, ändern sich die Objektgrenzen innerhalb des Bundles nach der erneuten Initialisierung.  Dies schafft die Voraussetzungen für die Ausnutzung einer EvilParcel-Sicherheitsanfälligkeit. <br><br>  Sehen wir uns ein Beispiel für eine Klasse an, die diesen Fehler enthält: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parcelable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel in)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = in.readInt(); data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[length]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { in.readByteArray(data); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Creator&lt;Demo&gt; CREATOR = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Creator&lt;Demo&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Demo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createFromParcel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel in)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Demo(in); } }; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeToParcel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel parcel, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ parcel.writeInt(data.length); parcel.writeByteArray(data); } }</code> </pre> <br>  Wenn die Datenarraygröße 0 ist, wird beim Erstellen eines Objekts ein int (4 Byte) in createFromParcel () gelesen und zwei int (8 Byte) in writeToParcel () geschrieben.  Das erste int wird durch expliziten Aufruf von writeInt geschrieben.  Das zweite int wird beim Aufruf von writeByteArray () geschrieben, da die Arraylänge immer vor dem Array in Parcel geschrieben wird (siehe Abbildung 1). <br><br>  Situationen, in denen die Größe des Datenarrays gleich 0 ist, sind ziemlich selten.  Aber selbst wenn dies passiert, läuft das Programm weiter, wenn Sie jeweils nur ein serialisiertes Objekt übertragen (in unserem Beispiel das Demo-Objekt).  Daher bleiben solche Fehler in der Regel unbemerkt. <br><br>  Jetzt versuchen wir, ein Demo-Objekt mit einer Array-Länge von Null im Bundle zu platzieren: <br><br><img src="https://habrastorage.org/webt/2y/2v/i0/2y2vi0ftdkartg9i01cc-b858g0.png"><br>  Abbildung 2. Das Ergebnis des Hinzufügens eines Demo-Objekts mit der Länge Null zum Bundle <br><br>  Wir serialisieren das Objekt: <br><br><img src="https://habrastorage.org/webt/hv/tw/if/hvtwifj9curkc7ip6jplbdlk-yc.png"><br>  Abbildung 3. Das Bundle-Objekt nach der Serialisierung <br><br>  Versuchen wir nun, es zu deserialisieren: <br><br><img src="https://habrastorage.org/webt/_u/a1/k4/_ua1k4hp34wknsvnppv8zla0jei.png"><br>  Abbildung 4. Das Bundle-Objekt nach der Deserialisierung <br><br>  Was bekommen wir?  Schauen wir uns das Paketfragment an: <br><br><img src="https://habrastorage.org/webt/tf/qa/fn/tfqafnxzmsfujmq2xyo-kwvbc2g.png"><br>  Abbildung 5. Paketstruktur nach Bundle-Deserialisierung <br><br>  In den Abbildungen 4 und 5 sehen wir, dass während der Deserialisierung anstelle von zwei int ein int in der createFromParcel-Methode gelesen wurde.  Daher wurden alle nachfolgenden Werte aus dem Bundle falsch gelesen.  Der 0x0-Wert bei 0x60 wurde als Länge des nächsten Schlüssels gelesen.  Der 0x1-Wert bei 0x64 wurde als Schlüssel gelesen.  Der 0x31-Wert bei 0x68 wurde als Werttyp gelesen.  Paket hat keine Werte vom Typ 0x31, daher meldet readFromParcel () sorgfältig eine Ausnahme. <br><br>  Wie kann dies im wirklichen Leben genutzt werden und zu einer Verwundbarkeit werden?  Mal sehen!  Der obige Fehler in den Parcelable-Systemklassen ermöglicht die Erstellung von Bundles, die sich während der ersten und wiederholten Deserialisierung unterscheiden können.  Um dies zu demonstrieren, ändern wir das vorherige Beispiel: <br><br><pre> <code class="java hljs">Parcel data = Parcel.obtain(); data.writeInt(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3 entries data.writeString("vuln_class"); data.writeInt(4); // value is Parcelable data.writeString("com.drweb.testbundlemismatch.Demo"); data.writeInt(0); // data.length data.writeInt(1); // key length -&gt; key value data.writeInt(6); // key value -&gt; value is long data.writeInt(0xD); // value is bytearray -&gt; low(long) data.writeInt(-1); // bytearray length dummy -&gt; high(long) int startPos = data.dataPosition(); data.writeString("hidden"); // bytearray data -&gt; hidden key data.writeInt(0); // value is string data.writeString("Hi there"); // hidden value int endPos = data.dataPosition(); int triggerLen = endPos - startPos; data.setDataPosition(startPos - 4); data.writeInt(triggerLen); // overwrite dummy value with the real value data.setDataPosition(endPos); data.writeString("A padding"); data.writeInt(0); // value is string data.writeString("to match pair count"); int length = data.dataSize(); Parcel bndl = Parcel.obtain(); bndl.writeInt(length); bndl.writeInt(0x4C444E42); // bundle magic bndl.appendFrom(data, 0, length); bndl.setDataPosition(0);</span></span></code> </pre> <br>  Dieser Code erstellt ein serialisiertes Bundle, das eine anfällige Klasse enthält.  Nun wollen wir sehen, was wir nach der Ausführung dieses Codes erhalten: <br><br><img src="https://habrastorage.org/webt/tc/ke/wf/tckewffnaop28wllxnrt7pagdvs.png"><br>  Abbildung 6. Erstellen eines Bundles mit einer anfälligen Klasse <br><br>  Nach der ersten Deserialisierung enthält dieses Bundle die folgenden Schlüssel: <br><br><img src="https://habrastorage.org/webt/cj/si/l0/cjsil0--g_jsoew8ht-oxely1u4.png"><br>  Abbildung 7. Nach der Deserialisierung eines Bundles mit einer anfälligen Klasse <br><br>  Jetzt werden wir das Bundle erneut serialisieren, dann erneut deserialisieren und uns die Liste der Schlüssel ansehen: <br><br><img src="https://habrastorage.org/webt/uw/e1/mj/uwe1mjdtywr59oyshaah2q1gkus.png"><br>  Abbildung 8. Ergebnis der Reserialisierung und Deserialisierung eines Bundles mit einer anfälligen Klasse <br><br>  Was sehen wir?  Das Bundle enthält jetzt den versteckten Schlüssel (mit dem Zeichenfolgenwert "Hi there!"), Der vorher nicht vorhanden war.  Schauen wir uns das Paketfragment dieses Bundles an, um herauszufinden, warum dies passiert ist: <br><br><img src="https://habrastorage.org/webt/i8/up/j1/i8upj1jif-_d41drqii19gw2nce.png"><br>  Abbildung 9. Paketstruktur eines Bundle-Objekts mit einer anfälligen Klasse nach zwei Serialisierungs- und Deserialisierungszyklen <br><br>  Hier können wir den ganzen Punkt der EvilParcel-Schwachstellen erkennen.  Wir können speziell ein Bundle erstellen, das eine anfällige Klasse enthält.  Durch Ändern der Grenzen dieser Klasse können beliebige Objekte in diesem Bundle platziert werden.  Zum Beispiel eine Absicht, die erst nach der zweiten Deserialisierung im Bundle erscheint.  Dies hilft, eine Absicht vor den Sicherheitsmechanismen des Betriebssystems zu verbergen. <br><br><h3>  EvilParcel ausnutzen </h3><br>  <b>Android.InfectionAds.1</b> nutzte CVE-2017-13315, um Software unabhängig von Gerätebesitzern zu installieren und zu entfernen.  Aber wie? <br><br>  Im Jahr 2013 wurde der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehler 7699048</a> , auch als Launch AnyWhere bekannt, entdeckt.  Es ermöglichte Anwendungen von Drittanbietern, beliebige Aktivitäten für einen privilegierteren Systembenutzer zu starten.  In der folgenden Abbildung finden Sie den Aktionsmechanismus: <br><br><img src="https://habrastorage.org/webt/in/d8/-m/ind8-mnyp5urfsndbkycy3l42f8.png"><br>  Abbildung 10. Bedienung des Fehlers 7699048 <br><br>  Eine ausnutzende Anwendung kann diese Sicherheitsanfälligkeit verwenden, um den Kontoauthentifizierungsdienst zu implementieren, mit dem dem Betriebssystem neue Konten hinzugefügt werden sollen.  Der Fehler 7699048 hilft den Exploit-Startaktivitäten beim Installieren, Entfernen, Ersetzen von Anwendungen sowie beim Zurücksetzen der PIN oder der Mustersperre und verursacht viel mehr Probleme. <br><br>  Google Inc.  hat diesen Verstoß beseitigt, indem der Start willkürlicher Aktivitäten von AccountManager verboten wurde.  Jetzt ermöglicht AccountManager nur das Starten von Aktivitäten, die von derselben Anwendung stammen.  Zu diesem Zweck wird die digitale Signatur der Software, die die Aktivität initiiert hat, überprüft und mit der Signatur der Anwendung abgeglichen, in der sich die Aktivität befindet.  Es sieht so aus: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; (intent = result.getParcelable(AccountManager.KEY_INTENT)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* * The Authenticator API allows third party authenticators to * supply arbitrary intents to other apps that they can run, * this can be very bad when those apps are in the system like * the System Settings. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> authenticatorUid = Binder.getCallingUid(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> bid = Binder.clearCallingIdentity(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { PackageManager pm = mContext.getPackageManager(); ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, <span class="hljs-number"><span class="hljs-number">0</span></span>, mAccounts.userId); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetUid = resolveInfo.activityInfo.applicationInfo.uid; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PackageManager.SIGNATURE_MATCH != pm.checkSignatures(authenticatorUid, targetUid)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecurityException( <span class="hljs-string"><span class="hljs-string">"Activity to be started with KEY_INTENT must "</span></span> + <span class="hljs-string"><span class="hljs-string">"share Authenticator's signatures"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { Binder.restoreCallingIdentity(bid); } }</code> </pre><br>  Es scheint, dass das Problem gelöst wurde, aber es ist nicht so einfach.  Es stellte sich heraus, dass die bekannte Sicherheitsanfälligkeit EvilParcel CVE-2017-13315 eine Problemumgehung bietet!  Wie wir bereits wissen, überprüft das System nach dem Reparieren von Launch AnyWhere die digitale Signatur der Anwendung.  Wenn es erfolgreich überprüft wurde, wird das Bundle an IAccountManagerResponse.onResult () übertragen.  Gleichzeitig wird onResult () über den IPC-Mechanismus aufgerufen, sodass das Bundle erneut serialisiert wird.  Während der Implementierung von onResult () geschieht Folgendes: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** Handles the responses from the AccountManager */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAccountManagerResponse</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stub</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ Intent intent = bundle.getParcelable(KEY_INTENT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; mActivity != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// since the user provided an Activity we will silently start intents // that we see mActivity.startActivity(intent); // leave the Future running to wait for the real response to this request } //&lt;.....&gt; } //&lt;.....&gt; }</span></span></code> </pre><br>  Anschließend extrahiert das Bundle den Intent-Schlüssel und die Aktivität wird ohne Überprüfung gestartet. <br>  Um eine beliebige Aktivität mit Systemberechtigungen zu starten, müssen Sie lediglich ein Bundle mit dem Feld Intent erstellen, das bei der ersten Deserialisierung ausgeblendet wird und während der wiederholten Deserialisierung angezeigt wird. <br>  Wie wir bereits wissen, können EvilParcel-Schwachstellen diese Aufgabe tatsächlich ausführen. <br><br>  Im Moment wurden alle bekannten Schwachstellen dieses Typs innerhalb der anfälligen Parcelable-Klassen behoben.  In Zukunft werden jedoch möglicherweise neue anfällige Klassen angezeigt.  Die Bundle-Implementierung und der Mechanismus zum Hinzufügen neuer Konten sind weiterhin dieselben wie zuvor.  Sie ermöglichen es uns weiterhin, genau diesen Exploit zu erstellen, wenn wir alte oder neue anfällige Paketklassen erkennen.  Darüber hinaus werden diese Klassen immer noch manuell implementiert, und der Programmierer muss sicherstellen, dass die Länge des serialisierten Parcelable-Objekts gleich bleibt, was bei allem, was dies impliziert, ein menschlicher Faktor ist.  Wir hoffen jedoch, dass es so wenige Fehler wie möglich gibt und die EvilParcel-Schwachstellen keine Bedrohung für Android-Benutzer darstellen. <br><br>  Sie können Ihr Mobilgerät mithilfe unseres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dr.Web Security Space</a> für Android auf EvilParcel-Schwachstellen überprüfen.  Der integrierte Sicherheitsprüfer meldet die erkannten Probleme und empfiehlt Möglichkeiten, sie zu beheben. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457610/">https://habr.com/ru/post/de457610/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457596/index.html">OSDay 19 oder warum die C-Sprache noch lebt</a></li>
<li><a href="../de457600/index.html">Headsets - Übersicht Snom A150, Snom A100M und D.</a></li>
<li><a href="../de457602/index.html">Untersuchung der Leistung von DBMS MS SQL Server Developer 2016 und PostgreSQL 10.5 für 1C</a></li>
<li><a href="../de457606/index.html">Alan Kay: Was kann man als das Erstaunlichste bezeichnen, was Computer möglich gemacht haben?</a></li>
<li><a href="../de457608/index.html">So visualisieren Sie Daten zu einer überzeugenden Geschichte</a></li>
<li><a href="../de457612/index.html">Wie kann die LZ4-Dekomprimierung in ClickHouse beschleunigt werden?</a></li>
<li><a href="../de457614/index.html">Geheimnisse der Arbeitssuche im Ausland bei einem praktizierenden Headhunter</a></li>
<li><a href="../de457616/index.html">Mein "Wow, das wusste ich nicht!" Momente mit Scherz</a></li>
<li><a href="../de457618/index.html">Ein moderner Full-Stack-Entwickler sein</a></li>
<li><a href="../de457622/index.html">Qt-Leistung messen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>