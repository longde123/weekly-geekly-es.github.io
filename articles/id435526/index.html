<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥘 ☹️ 🤑 Petualangan dengan Cluster Rumah Kubernetes 🏧 🚿 🎸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan perev. : Penulis artikel, Marshall Brekka, menempati posisi direktur desain sistem di Fair.com, yang menawarkan aplikasinya untuk penyewaan mo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Petualangan dengan Cluster Rumah Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/435526/">  <i><b>Catatan</b></i>  <i><b>perev.</b></i>  <i>: Penulis artikel, Marshall Brekka, menempati posisi direktur desain sistem di Fair.com, yang menawarkan aplikasinya untuk penyewaan mobil.</i>  <i>Di waktu luangnya, ia suka menggunakan pengalamannya yang luas untuk memecahkan masalah "rumah" yang tidak mungkin mengejutkan geek mana pun (oleh karena itu, pertanyaan "Mengapa?" - sehubungan dengan tindakan yang dijelaskan di bawah ini - dihilangkan secara apriori).</i>  <i>Jadi, dalam terbitannya, Marshall membagikan hasil penyebaran Kubernet baru-baru ini di ... papan ARM.</i> <br><br><img src="https://habrastorage.org/webt/ul/nj/do/ulnjdoyysctwv-34jhuyn-wvsp8.png"><br><br>  Seperti banyak Geeks lainnya, selama bertahun-tahun saya telah mengumpulkan berbagai papan pengembangan seperti Raspberry Pi.  Dan seperti banyak geek, mereka membersihkan debu di rak dengan pikiran bahwa suatu hari mereka akan berguna.  Dan sekarang bagiku hari ini akhirnya tiba! <a name="habracut"></a><br><br>  Selama liburan musim dingin, beberapa minggu di luar pekerjaan muncul, di mana ada cukup waktu untuk inventaris semua besi yang terakumulasi dan memutuskan apa yang harus dilakukan dengannya.  Inilah yang saya miliki: <br><br><ul><li>  Penutup RAID 5-drive dengan koneksi USB3; </li><li>  Raspberry Pi Model B (model OG); </li><li>  CubbieBoard 1; </li><li>  Pisang Pi M1; </li><li>  Netbook HP (2012?). </li></ul><br>  Dari 5 komponen besi yang terdaftar, saya menggunakan kecuali RAID dan netbook sebagai NAS sementara.  Namun, karena kurangnya dukungan USB3 di netbook, RAID tidak menggunakan potensi kecepatan penuh. <br><br><h2>  Tujuan hidup </h2><br>  Karena bekerja dengan RAID tidak optimal saat menggunakan netbook, saya menetapkan tujuan berikut untuk mendapatkan konfigurasi terbaik: <br><br><ol><li>  NAS dengan USB3 dan gigabit ethernet; </li><li>  Cara terbaik untuk mengelola perangkat lunak di perangkat Anda </li><li>  (bonus) kemampuan untuk melakukan streaming konten multimedia dari RAID ke Fire TV. </li></ol><br>  Karena tidak ada perangkat yang mendukung USB3 dan gigabit ethernet, sayangnya, saya harus melakukan pembelian tambahan.  Pilihan jatuh pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ROC-RK3328-CC</a> .  Dia memiliki semua spesifikasi yang diperlukan dan dukungan yang memadai untuk sistem operasi. <br><br>  Setelah menyelesaikan kebutuhan perangkat keras saya (dan menunggu kedatangan solusi ini), saya beralih ke tujuan kedua. <br><br><h2>  Mengelola perangkat lunak pada perangkat </h2><br>  Sebagian, proyek-proyek masa lalu saya yang terkait dengan papan pengembangan telah gagal karena kurangnya perhatian terhadap masalah reproduksi dan dokumentasi.  Saat membuat konfigurasi berikutnya untuk kebutuhan saya saat ini, saya tidak repot untuk menuliskan langkah-langkah yang diambil atau tautan ke posting blog yang saya ikuti.  Dan ketika, setelah berbulan-bulan atau bertahun-tahun, ada yang tidak beres dan saya mencoba memperbaiki masalahnya, saya tidak memiliki pemahaman tentang bagaimana semuanya pada awalnya diatur. <br><br>  Jadi aku berkata pada diriku sendiri bahwa kali ini semuanya akan berbeda! <br><br><img src="https://habrastorage.org/webt/dm/vb/iv/dmvbivkoa65wfd1ve5mo5wh5jdc.jpeg"><br><br>  Dan dia beralih ke fakta bahwa saya cukup tahu - untuk Kubernetes. <br><br>  Meskipun K8 adalah solusi yang terlalu sulit untuk masalah yang agak sederhana, setelah hampir tiga tahun mengelola cluster menggunakan berbagai alat (saya sendiri, kops, dll.) Di pekerjaan utama saya, saya sangat akrab dengan sistem ini.  Selain itu, menyebarkan K8 di luar lingkungan cloud, dan bahkan pada perangkat ARM - semua ini sepertinya tugas yang menarik. <br><br>  Saya juga berpikir bahwa karena perangkat keras yang tersedia tidak memenuhi persyaratan yang diperlukan untuk NAS, saya akan mencoba untuk setidaknya mengumpulkan gugus dari itu dan, mungkin, beberapa perangkat lunak yang tidak begitu menuntut sumber daya akan dapat bekerja pada perangkat yang lebih tua. <br><br><h2>  Kubernet di ARM </h2><br>  Di tempat kerja, saya tidak memiliki kesempatan untuk menggunakan utilitas <code>kubeadm</code> untuk menyebarkan cluster, jadi saya memutuskan bahwa sekarang adalah waktu untuk mencobanya dalam tindakan. <br><br>  Raspbian dipilih sebagai sistem operasi, karena terkenal akan dukungan terbaik untuk papan saya. <br><br>  Saya menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang bagus</a> tentang pengaturan Kubernetes pada Raspberry Pi menggunakan HypriotOS.  Karena saya tidak yakin tentang ketersediaan HypriotOS untuk semua board saya, saya mengadaptasi instruksi ini untuk Debian / Raspbian. <br><br><h3>  Komponen yang Diperlukan </h3><br>  Pertama, instalasi alat-alat berikut diperlukan: <br><br><ul><li>  Docker, </li><li>  kubelet </li><li>  kubeadm, </li><li>  kubectl. </li></ul><br>  Docker harus diinstal menggunakan skrip khusus - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skrip kenyamanan</a> (seperti yang ditunjukkan untuk kasus menggunakan Raspbian). <br><br><pre> <code class="bash hljs">curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh</code> </pre> <br>  Setelah itu, saya menginstal komponen Kubernetes sesuai dengan instruksi dari blog Hypriot, mengadaptasinya sehingga versi spesifik digunakan untuk semua dependensi: <br><br><pre> <code class="bash hljs">curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add - <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"deb http://apt.kubernetes.io/ kubernetes-xenial main"</span></span> &gt; /etc/apt/sources.list.d/kubernetes.list apt-get update apt-get install -y kubelet=1.13.1-00 kubectl=1.13.1-00 kubeadm=1.13.1-00</code> </pre> <br><h3>  Raspberry pi b </h3><br>  Kesulitan pertama muncul ketika mencoba untuk mem-bootstrap sebuah cluster pada Raspberry Pi B: <br><br><pre> <code class="bash hljs">$ kubeadm init Illegal instruction</code> </pre> <br>  Ternyata Kubernetes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menghapus dukungan untuk ARMv6</a> .  Yah, saya juga punya CubbieBoard dan Banana Pi. <br><br><h3>  Pi pisang </h3><br>  Awalnya, urutan tindakan yang sama untuk Pisang Pi tampaknya lebih berhasil, namun, perintah <code>kubeadm init</code> saat mencoba menunggu pesawat kontrol bekerja: <br><br><pre> <code class="plaintext hljs">error execution phase wait-control-plane: couldn't initialize a Kubernetes cluster</code> </pre> <br>  Mencari tahu dengan <code>docker ps</code> apa yang terjadi dengan wadah, saya melihat bahwa <code>kube-controller-manager</code> dan <code>kube-scheduler</code> telah bekerja setidaknya 4-5 menit, tetapi <code>kube-api-server</code> bangun hanya 1-2 menit yang lalu: <br><br><pre> <code class="bash hljs">$ docker ps CONTAINER ID COMMAND CREATED STATUS de22427ad594 <span class="hljs-string"><span class="hljs-string">"kube-apiserver --au…"</span></span> About a minute ago Up About a minute dc2b70dd803e <span class="hljs-string"><span class="hljs-string">"kube-scheduler --ad…"</span></span> 5 minutes ago Up 5 minutes 60b6cc418a66 <span class="hljs-string"><span class="hljs-string">"kube-controller-man…"</span></span> 5 minutes ago Up 5 minutes 1e1362a9787c <span class="hljs-string"><span class="hljs-string">"etcd --advertise-cl…"</span></span> 5 minutes ago Up 5 minutes</code> </pre> <br>  Jelas, <code>api-server</code> sedang sekarat atau proses strontium mematikan dan me-restart itu. <br><br>  Memeriksa log, saya melihat prosedur start-up yang sangat standar - ada catatan awal mendengarkan port aman dan jeda panjang sebelum munculnya banyak kesalahan dalam jabat tangan TLS: <br><br><pre> <code class="plaintext hljs">20:06:48.604881 naming_controller.go:284] Starting NamingConditionController 20:06:48.605031 establishing_controller.go:73] Starting EstablishingController 20:06:50.791098 log.go:172] http: TLS handshake error from 192.168.1.155:50280: EOF 20:06:51.797710 log.go:172] http: TLS handshake error from 192.168.1.155:50286: EOF 20:06:51.971690 log.go:172] http: TLS handshake error from 192.168.1.155:50288: EOF 20:06:51.990556 log.go:172] http: TLS handshake error from 192.168.1.155:50284: EOF 20:06:52.374947 log.go:172] http: TLS handshake error from 192.168.1.155:50486: EOF 20:06:52.612617 log.go:172] http: TLS handshake error from 192.168.1.155:50298: EOF 20:06:52.748668 log.go:172] http: TLS handshake error from 192.168.1.155:50290: EOF</code> </pre> <br>  Dan segera setelah itu, server mengakhiri kerjanya.  Googling menyebabkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah seperti itu</a> , menunjukkan kemungkinan alasan lambatnya operasi algoritma kriptografi pada beberapa perangkat ARM. <br><br>  Saya melangkah lebih jauh dan berpikir bahwa mungkin <code>api-server</code> mendapatkan terlalu banyak permintaan berulang dari <code>scheduler</code> dan <code>controller-manager</code> . <br><br>  Menghapus file-file ini dari direktori manifes akan memberitahu kubelet untuk menghentikan eksekusi pod yang sesuai: <br><br><pre> <code class="bash hljs">mkdir /etc/kubernetes/manifests.bak mv /etc/kubernetes/manifests/kube-scheduler.yaml /etc/kubernetes/manifests.bak/ mv /etc/kubernetes/manifests/kube-controller-mananger.yaml /etc/kubernetes/manifests.bak/</code> </pre> <br>  Melihat log <code>api-server</code> terbaru menunjukkan bahwa sekarang prosesnya berjalan lebih jauh, namun, itu masih mati setelah sekitar 2 menit.  Kemudian saya ingat bahwa manifes dapat berisi sampel live dengan timeout yang memiliki nilai terlalu rendah untuk perangkat yang lambat. <br><br>  Oleh karena itu, saya memeriksa <code>/etc/kubernetes/manifests/kube-api-server.yaml</code> - dan di dalamnya, tentu saja ... <br><br><pre> <code class="plaintext hljs">livenessProbe: failureThreshold: 8 httpGet: host: 192.168.1.155 path: /healthz port: 6443 scheme: HTTPS initialDelaySeconds: 15 timeoutSeconds: 15</code> </pre> <br>  Pod terbunuh setelah 135 detik ( <code>initialDelaySeconds</code> + <code>timeoutSeconds</code> * <code>failureThreshold</code> ).  Tingkatkan <code>initialDelaySeconds</code> ke 120 ... <br><br>  <b>Sukses!</b>  Yah, kesalahan jabat tangan masih terjadi (mungkin dari kubelet), namun peluncuran masih terjadi: <br><br><pre> <code class="plaintext hljs">20:06:54.957236 log.go:172] http: TLS handshake error from 192.168.1.155:50538: EOF 20:06:55.004865 log.go:172] http: TLS handshake error from 192.168.1.155:50384: EOF 20:06:55.118343 log.go:172] http: TLS handshake error from 192.168.1.155:50292: EOF 20:06:55.252586 cache.go:39] Caches are synced for autoregister controller 20:06:55.253907 cache.go:39] Caches are synced for APIServiceRegistrationController controller 20:06:55.545881 controller_utils.go:1034] Caches are synced for crd-autoregister controller ... 20:06:58.921689 storage_rbac.go:187] created clusterrole.rbac.authorization.k8s.io/cluster-admin 20:06:59.049373 storage_rbac.go:187] created clusterrole.rbac.authorization.k8s.io/system:discovery 20:06:59.214321 storage_rbac.go:187] created clusterrole.rbac.authorization.k8s.io/system:basic-user</code> </pre> <br>  Ketika <code>api-server</code> bangkit, saya memindahkan file YAML untuk controller dan scheduler kembali ke direktori manifes, setelah itu mereka mulai secara normal juga. <br><br>  Sekarang saatnya memastikan bahwa unduhan akan berhasil jika Anda meninggalkan semua file di direktori sumber: apakah cukup untuk mengubah penundaan yang diizinkan dalam inisialisasi <code>livenessProbe</code> ? <br><br><pre> <code class="plaintext hljs">20:29:33.306983 reflector.go:134] k8s.io/client-go/informers/factory.go:132: Failed to list *v1.Service: Get https://192.168.1.155:6443/api/v1/services?limit=500&amp;resourceVersion=0: dial tcp 192.168.1.155:6443: i/o timeout 20:29:33.434541 reflector.go:134] k8s.io/client-go/informers/factory.go:132: Failed to list *v1.ReplicationController: Get https://192.168.1.155:6443/api/v1/replicationcontrollers?limit=500&amp;resourceVersion=0: dial tcp 192.168.1.155:6443: i/o timeout 20:29:33.435799 reflector.go:134] k8s.io/client-go/informers/factory.go:132: Failed to list *v1.PersistentVolume: Get https://192.168.1.155:6443/api/v1/persistentvolumes?limit=500&amp;resourceVersion=0: dial tcp 192.168.1.155:6443: i/o timeout 20:29:33.477405 reflector.go:134] k8s.io/client-go/informers/factory.go:132: Failed to list *v1beta1.PodDisruptionBudget: Get https://192.168.1.155:6443/apis/policy/v1beta1/poddisruptionbudgets?limit=500&amp;resourceVersion=0: dial tcp 192.168.1.155:6443: i/o timeout 20:29:33.493660 reflector.go:134] k8s.io/client-go/informers/factory.go:132: Failed to list *v1.PersistentVolumeClaim: Get https://192.168.1.155:6443/api/v1/persistentvolumeclaims?limit=500&amp;resourceVersion=0: dial tcp 192.168.1.155:6443: i/o timeout 20:29:37.974938 controller_utils.go:1027] Waiting for caches to sync for scheduler controller 20:29:38.078558 controller_utils.go:1034] Caches are synced for scheduler controller 20:29:38.078867 leaderelection.go:205] attempting to acquire leader lease kube-system/kube-scheduler 20:29:38.291875 leaderelection.go:214] successfully acquired lease kube-system/kube-scheduler</code> </pre> <br>  Ya, semuanya berfungsi, meskipun perangkat lama tersebut, tampaknya, tidak dimaksudkan untuk meluncurkan pesawat kontrol, karena koneksi TLS yang berulang menyebabkan rem yang signifikan.  Satu atau lain cara - instalasi K8 yang aktif di ARM diterima!  Mari kita melangkah lebih jauh ... <br><br><h3>  Pemasangan RAID </h3><br>  Karena kartu SD tidak cocok untuk direkam dalam jangka panjang, saya memutuskan untuk menggunakan penyimpanan yang lebih andal untuk bagian sistem file yang paling tidak stabil - dalam hal ini, RAID.  4 bagian disorot di atasnya: <br><br><ul><li>  50 GB; </li><li>  2 × 20 GB; </li><li>  3,9 Tb. </li></ul><br>  Saya belum datang dengan tujuan khusus untuk partisi 20-gigabyte, tetapi saya ingin meninggalkan peluang tambahan untuk masa depan. <br><br>  Dalam file <code>/etc/fstab</code> untuk partisi 50 GB, titik mount ditentukan sebagai <code>/mnt/root</code> , dan untuk 3,9 TB - <code>/mnt/raid</code> .  Setelah itu, saya memasang direktori dengan etcd dan docker ke partisi 50 GB: <br><br><pre> <code class="plaintext hljs">UUID=655a39e8-9a5d-45f3-ae14-73b4c5ed50c3 /mnt/root ext4 defaults,rw,user,auto,exec 0 0 UUID=0633df91-017c-4b98-9b2e-4a0d27989a5c /mnt/raid ext4 defaults,rw,user,auto 0 0 /mnt/root/var/lib/etcd /var/lib/etcd none defaults,bind 0 0 /mnt/root/var/lib/docker /var/lib/docker none defaults,bind 0 0</code> </pre> <br><h3>  Kedatangan ROC-RK3328-CC </h3><br>  Ketika papan baru dikirim, saya menginstal komponen yang diperlukan untuk K8 di atasnya <i>(lihat bagian awal artikel)</i> dan meluncurkan <code>kubeadm init</code> .  Beberapa menit menunggu adalah keberhasilan dan keluaran dari perintah <code>join</code> untuk dijalankan pada node lain. <br><br>  Hebat!  Tidak repot dengan timeout. <br><br>  Dan karena RAID juga akan digunakan pada board ini, mount perlu dikonfigurasikan lagi.  Untuk merangkum semua langkah: <br><br><h4>  1. Pasang disk di / etc / fstab </h4><br><pre> <code class="plaintext hljs">UUID=655a39e8-9a5d-45f3-ae14-73b4c5ed50c3 /mnt/root ext4 defaults,rw,user,auto,exec 0 0 UUID=0633df91-017c-4b98-9b2e-4a0d27989a5c /mnt/raid ext4 defaults,rw,user,auto 0 0 /mnt/root/var/lib/etcd /var/lib/etcd none defaults,bind 0 0 /mnt/root/var/lib/docker /var/lib/docker none defaults,bind 0 0</code> </pre> <br><h4>  2. Menginstal Docker dan binari K8 </h4><br><pre> <code class="bash hljs">curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh</code> </pre> <br><pre> <code class="bash hljs">curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add - <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"deb http://apt.kubernetes.io/ kubernetes-xenial main"</span></span> &gt; /etc/apt/sources.list.d/kubernetes.list apt-get update apt-get install -y kubelet=1.13.1-00 kubectl=1.13.1-00 kubeadm=1.13.1-00</code> </pre> <br><h4>  3. Mengkonfigurasi nama host yang unik (penting karena banyak node ditambahkan) </h4><br><pre> <code class="bash hljs">hostnamectl <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-hostname k8s-master-1</code> </pre> <br><h4>  4. Inisialisasi Kubernetes </h4><br>  Saya menghilangkan fase dengan bidang kontrol, karena saya ingin dapat merencanakan pod yang normal pada simpul ini: <br><br><pre> <code class="bash hljs">kubeadm init --skip-phases mark-control-plane</code> </pre> <br><h4>  5. Menginstal plugin jaringan </h4><br>  Informasi tentang ini dalam artikel Hypriot sedikit tertanggal karena plugin jaringan Weave sekarang juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">didukung di ARM</a> : <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> KUBECONFIG=/etc/kubernetes/admin.conf kubectl apply -f <span class="hljs-string"><span class="hljs-string">"https://cloud.weave.works/k8s/net?k8s-version=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(kubectl version | base64 | tr -d '\n')</span></span></span><span class="hljs-string">"</span></span></code> </pre> <br><h4>  6. Menambahkan label host </h4><br>  Pada simpul ini, saya akan memulai server NAS, jadi saya akan menandainya dengan label untuk kemungkinan penggunaan di masa depan dalam penjadwal: <br><br><pre> <code class="bash hljs">kubectl label nodes k8s-master-1 marshallbrekka.raid=<span class="hljs-literal"><span class="hljs-literal">true</span></span> kubectl label nodes k8s-master-1 marshallbrekka.network=gigabit</code> </pre> <br><h3>  Menghubungkan node lain ke cluster </h3><br>  Menyiapkan perangkat lain (Banana Pi, CubbieBoard) sama mudahnya.  Bagi mereka, Anda perlu mengulangi 3 langkah pertama (mengubah pengaturan untuk memasang disk / media flash, tergantung pada ketersediaannya) dan menjalankan perintah <code>kubeadm join</code> bukan <code>kubeadm init</code> . <br><br><h2>  Menemukan Wadah Docker untuk ARM </h2><br>  Sebagian besar wadah Docker yang diperlukan dibuat secara normal di Mac, tetapi untuk ARM itu sedikit lebih rumit.  Setelah menemukan banyak artikel tentang cara menggunakan QEMU untuk keperluan ini, saya sampai pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kesimpulan</a> bahwa sebagian besar aplikasi yang saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">butuhkan</a> sudah dirakit, dan banyak di antaranya tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">server linux</a> . <br><br><h2>  Langkah selanjutnya </h2><br>  Masih tidak mendapatkan konfigurasi awal perangkat dalam bentuk otomatis / scripted seperti yang saya inginkan, saya setidaknya menyusun seperangkat perintah dasar (mounts, <code>docker</code> dan <code>kubeadm</code> ) dan mendokumentasikannya dalam repositori Git.  Sisa dari aplikasi yang digunakan juga menerima konfigurasi YAML untuk K8 yang disimpan dalam repositori yang sama, jadi sekarang sangat mudah untuk mendapatkan konfigurasi yang diperlukan dari awal. <br><br>  Di masa depan, saya ingin mencapai yang berikut: <br><br><ol><li>  Jadikan situs master sangat tersedia </li><li>  tambahkan pemantauan / pemberitahuan untuk mengetahui tentang kegagalan dalam komponen apa pun; </li><li>  Ubah pengaturan DCHP router untuk menggunakan server DNS dari cluster untuk menyederhanakan penemuan aplikasi (siapa yang ingin mengingat alamat IP internal?); </li><li>  menjalankan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MetalLB</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">meneruskan</a> layanan cluster ke jaringan pribadi (DNS, dll.) </li></ol><br><br><h2>  PS dari penerjemah </h2><br>  Baca juga di blog kami: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes tips &amp; trik: tentang alokasi node dan beban pada aplikasi web</a> "; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kiat &amp; trik Kubernetes: akses ke situs dev</a> ”; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes tips &amp; trik: mempercepat bootstrap dari database besar</a> ”; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">11 Cara untuk (Tidak) Menjadi Korban Peretasan Kubernetes</a> ”; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bermain dengan Kubernetes adalah layanan untuk mengenal K8 dalam praktiknya</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435526/">https://habr.com/ru/post/id435526/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435510/index.html">Mikroelektronika, neurofisiologi dan pembelajaran mesin, goyang tetapi tidak tercampur</a></li>
<li><a href="../id435512/index.html">Pengembang Royole Menunjukkan Smartphone Fleksibel yang Dapat Dilipat</a></li>
<li><a href="../id435514/index.html">Di Rusia, mereka mengembangkan prosesor untuk mempercepat jaringan saraf</a></li>
<li><a href="../id435520/index.html">Kami menulis bahasa pemrograman kami, bagian 3: Arsitektur penerjemah. Analisis struktur bahasa dan ekspresi matematika</a></li>
<li><a href="../id435522/index.html">Snapshot acara di Axonframework 3, meningkatkan kinerja</a></li>
<li><a href="../id435528/index.html">5 alasan untuk sukses: mengapa Amazon telah menjadi perusahaan paling mahal di dunia</a></li>
<li><a href="../id435530/index.html">Langganan Berbayar - Ketergantungan Koneksi Otomatis pada Perangkat Seluler</a></li>
<li><a href="../id435532/index.html">Tornado vs Aiohttp: sebuah perjalanan ke belantara kerangka asinkron</a></li>
<li><a href="../id435534/index.html">Ilmu Data: Buku-Buku Tingkat Awal</a></li>
<li><a href="../id435536/index.html">Robot humanoid: manfaat dan masalah mekanisme antropomorfik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>