<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🔧 👞 🤲🏻 通过将Angular库分为几部分来提高SPA性能 🏂🏼 🚁 👩🏾‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 我向您介绍Kevin Kreuzer的文章“通过将Angular库分成多个块来改善SPA性能”的翻译。 


 Angular是一个很好的框架。 我们都爱他<3。 


 同时使Angular成功和美观的因素之一是广泛的社区及其承载的价值。 有许多会议，博客，会议，当然还有Angular库...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>通过将Angular库分为几部分来提高SPA性能</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482646/"><p>  <i>哈Ha！</i>  <i>我向您介绍<a href="https://medium.com/%40kevinkreuzer">Kevin Kreuzer</a>的文章<a href="https://medium.com/angular-in-depth/improve-spa-performance-by-splitting-your-angular-libraries-in-multiple-chunks-8c68103692d0">“通过将Angular库分成多个块来改善SPA性能”</a>的翻译。</i> </p><br><p>  Angular是一个很好的框架。 我们都爱他&lt;3。 </p><br><p> 同时使Angular成功和美观的因素之一是广泛的社区及其承载的价值。 有许多会议，博客，会议，当然还有Angular库。 </p><br><p> 多亏了Angular CLI，库现在很容易创建。 它们非常适合在多个应用程序之间共享代码。 </p><br><p> 由于它们可以在许多地方使用，因此性能至关重要。 性能不佳的库可能会使多个应用程序变慢！ </p><br><p> 前端具有不同类型的性能。 运行时-性能和初始负载。 在本文中，我们将重点关注初始负载。 </p><br><p> 通过为一家大型企业提供并支持各种库和用户界面框架，我遇到了一些不太明显的陷阱和解决方法。 我认为值得分享其中的一些。 </p><a name="habracut"></a><br><h3 id="eto-takaya-prostaya-biblioteka-ona-ne-mozhet-povliyat-na-proizvoditelnost-verno">  “这是一个简单的库。它不会影响性能，对吗？” </h3><br><p> 让我们从将使用Angular CLI创建的简单库开始。 如果您从未创建过Angular库，那么阅读以下文章可能会有所帮助： </p><br><p> <a href="https://medium.com/angular-in-depth/the-ultimate-guide-to-set-up-your-angular-library-project-399d95b63500%3F"><img src="https://habrastorage.org/getpro/habr/post_images/ea9/10e/e94/ea910ee94b4ae1fb97629d1992986f07.png" alt="图片"></a> </p><br><p> 一旦使用CLI配置了许多项目工作区，就可以开始添加代码。 </p><br><p> 该库称为<em>howdy</em> ，其唯一目的是用您的名字打招呼或告诉您当地时间。 它包含两个模块，每个模块都有一个。 一种模式欢迎，另一种说话时间。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1f4/e9d/462/1f4e9d4625a98a62e53a92a01d734011.png" alt="图片"></p><br><p> 只是一个常规的Angular and Component模块，该模块在Input绑定的顶部具有一个name属性并显示它。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/54c/962/78a/54c96278a3e56081b10523c38ee9b5ca.png" alt="图片"></p><br><p>  <em>HowdyTimeComponent</em>负责使用第三方<em>矩量</em>库显示时间。 </p><br><p> 太好了！ 我们的<em>howdy</em>库<em>已</em>准备好发布！ 它是如此简单。 她将不会影响表现，对吗？ </p><br><h3 id="potreblenie-biblioteki-howdy"> 你好图书馆消费 </h3><br><p> 现在我们有了一个<em>howdy</em>库！ 不利用这一点是可耻的。 要使用<em>howdy</em>库，我们将使用Angular CLI创建一个新的SPA。 </p><br><pre><code class="javascript hljs">ng <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> greeting-app</code> </pre> <br><p> 由于我们对性能感兴趣，因此我们还要安装称为<em>webpack-bundle-analyzer</em>的dev依赖<em>项</em> 。 </p><br><pre> <code class="javascript hljs">npm i -D webpack-bundle-analyzer</code> </pre> <br><p>  <em>Webpack-bundle-analyzer</em>允许您使用交互式，可伸缩的树图可视化webpack输出文件的大小。 </p><br><p> 分析我们的软件包的最好方法是将以下分析脚本添加到我们的<em>package.json中</em> 。 </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"analyze"</span></span>: <span class="hljs-string"><span class="hljs-string">"ng build --prod --stats-json &amp;&amp; webpack-bundle-analyzer ./dist/greeting-app/stats-es2015.json"</span></span></code> </pre> <br><p> 如果我们运行此命令，Angular将进行生产构建，并输出<em>stats-es2015.json</em> ，然后将由<em>webpack-bundle-anlyzer</em>选择并呈现<em>它</em> 。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2a2/fea/202/2a2fea202a8def6d1aba232ad3dafa1e.png" alt="图片"></p><br><p> 由于我们尚未编写任何代码，因此我们的主程序包主要由Angular组成。 我们还可以看到<em>zone.js</em>包含在我们的<em>polyfill</em>包中。 </p><br><p> 通常，我们的应用程序大小现在为<em>207 KB</em> 。 </p><br><p> 但是我们还没有包括我们的Howdy库！ 让我们继续吧。 </p><br><pre> <code class="javascript hljs">npm i howdy</code> </pre> <br><p> 我们安装了<em>howdy</em>库，因为我们想承载带有名称的问候语。 我们对时间的展示不感兴趣。 因此，我们将仅使用<em>HowdyNameModule</em>模块，而不包括<em>HowdyTimeModule</em> 。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/377/046/8cf/3770468cf443e8bcdc4a34012f4807be.png" alt="图片"></p><br><p>  <strong>在这里需要注意的重要一点是，我们仅导入</strong> <em>HowdyNameModule</em> 。 让我们再次运行分析脚本。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f12/152/3d6/f121523d6ca2c14dcc8ec7c57ca77527.png" alt="图片"></p><br><p> 哇！ 太酷了！ 我们从207 KB切换到511.15 KB。 大小增加了一倍以上。 真是... </p><br><p> 一看就足以找到罪魁祸首。  <em>瞬间是</em>巨大的！ 它带来了其主要的实现代码和所有区域设置。 </p><br><p> 当然，可以用其他包（例如<em>date-fns</em>或<em>moment-mini）</em>替换<em>一下moment</em> 。 但是问题是不同的。 为什么他甚至在那里？ 记住，我们只导入了<em>HowdyNameModule</em> ，而不是<em>HodwyTimeModule</em> 。 我以为<em>发生树抖动时</em> ，只有未使用的模块会抖动吗？ 这是怎么回事？ </p><br><h3 id="tree-shaking-mozhet-ubrat-ne-vse"> 摇树不一定能消除一切 </h3><br><p> 为使<em>Tree Shaking</em>发生，Angular构建启动了许多高级优化。 但是，尽管<em>HowdyTimeModule</em>不存在，但工具包中存在<em>此刻</em> 。 <br> 问题是当下的包装方式。 让我们快速浏览一下<em>node_modules</em>文件夹中的<em>moment.js</em>文件。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0b9/6e2/4c6/0b96e24c644878e7e722500fd719fea9.png" alt="图片"></p><br><p> 由于<em>moment</em>可以在许多地方使用，例如Node JS后端，Angular应用程序或普通的JavaScript，因此它捆绑在<em>UMD中，</em>而不是作为<em>ES</em>模块。 </p><br><p> 链接的<em>UMD</em>库包装在IFFE函数中，这意味着无法使用<em>ModuleConcatenation，</em>程序集优化工具无法<em>确定</em>将使用此代码还是有副作用。 </p><br><p> 简而言之，此类模块可防止Angular启动更高级的优化工具包。 </p><br><p> 不幸的是，我们无法控制这一<em>时刻的</em>完成方式。 这是否意味着我们不得不忍受包装的庞大尺寸？ </p><br><h3 id="vtorichnye-tochki-vhoda-dlya-pobedy"> 胜利的次要切入点 </h3><br><p> 我们无法控制<em>力矩</em>的产生方式。 但是我们可以管理我们的图书馆。 确实，有一种方法可以防止这种情况。 次要切入点！ </p><br><p> 目前几乎所有Angular库都使用<em>ng-packagr</em>打包。  <em>ng-packagr</em>允许您将<em>ng-package.json</em>与<em>public-api</em>结合使用，最终将成为应用程序的入口点。 </p><br><p> 顾名思义，其他入口点允许您为应用程序指定多个入口点。 </p><br><p> 听起来不错！ 如何激活辅助入口点？ </p><br><p> 使用<em>ng-packagr</em>动态检测辅助入口点。  <em>ng-packagr</em>在<em>package.json</em>文件主文件夹的子目录中查找<em>package.json</em>文件 </p><br><p> 好酷！ 让我们通过添加以下文件来利用我们的<em>howdy</em>库中的辅助入口点。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e6d/7b1/64a/e6d7b164afbe291983055aea26a808bc.png" alt="图片"></p><br><p> 对于每个模块，我们添加了<em>index.ts</em> ， <em>package.json</em>和<em>public_api.ts</em> 。 </p><br><ul><li>  <em>index.ts</em>在那里，仅指向<em>public_api</em> ，在导入期间很有用。 </li><li>  <em>public_api</em>导出模块中的所有模块和组件。 </li><li>  <em>package.json</em>包含特定的<em>ng-packagr配置</em> 。 在我们的例子中，这足以指定<em>entryFile</em> 。 </li></ul><br><blockquote>  <em>Package.json</em>也可能包含其他属性，例如<em>cssUrl</em>等。请注意，这些属性的范围仅是当前子项目。 </blockquote><p> 如果现在运行程序集，我们将得到三个块。  <em>howdy.js</em> ， <em>howdy-src-lib-name.js</em>和<em>howdy-src-lib-time.js</em> 。 </p><br><p>  <em>Howdy-src-lib-name.js</em>现在仅包含与<em>HowdyNameModule</em>相关的代码，而<em>howdy-src-lib-time.js</em>现在仅包含特定于<em>HowdyTimeModule的</em>代码。 </p><br><p> 但是，让我们看一下<em>howdy.js</em> 。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e41/e81/9b1/e41e819b1fa5c3ea4cb7d6f897aa4b65.png" alt="图片"></p><br><p>  <em>howdy.js</em>片段仍包含<em>HowdyNameComponent</em>和<em>HowdyTimeComponent</em> 。 这意味着即使我们仅导入<em>HowdyNameModule</em> <em>，</em>我们也能<em>把握时机</em> 。 </p><br><blockquote> 如果我们想用这种方法摆脱<em>HowdyTimeModule</em> ，我们需要使用深度导入。 所以我们不是从<em>howdy.js</em>导入，而是直接从<em>howdy-src-lib-time.js导入。</em> <br>  <strong>不推荐什么！</strong>  <strong>大量进口是危险的，应始终避免！</strong> </blockquote><p> 我们如何解决这些问题？ 即使使用标准导入，我们如何保证也可以删除<em>HowdyTimeModule</em> ？ 好吧，我们需要建立一种创建<em>howdy.js的方法</em> 。 </p><br><h3 id="ispolzuyte-signpost"> 使用“路标” </h3><br><p> 这个想法是从<em>howdy.js</em>块中删除代码，而是让它充当一种“路标”“指针”，将您指向其他块。 </p><br><p> 因此，让我们仔细看一下<em>src / public_api.ts</em> 。 </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Public API Surface of howdy */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./lib/name/howdy-name.component'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./lib/name/howdy-name.module'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./lib/time/howdy-time.component'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./lib/time/howdy-time.module'</span></span>;</code> </pre> <br><p> 这些行负责在<em>howdy.js</em>块中包括<em>名称</em>和<em>时间</em>在内的所有内容。 我们需要从<em>howdydy.js中</em>删除代码，并使其指向包含实现的其他片段。 让我们更改其内容。 </p><br><pre> <code class="javascript hljs">/ * Public API Surface <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> howdy *<span class="hljs-regexp"><span class="hljs-regexp">/ export * from 'howdy/</span></span>src/lib/name<span class="hljs-string"><span class="hljs-string">'; export * from '</span></span>howdy/src/lib/time<span class="hljs-string"><span class="hljs-string">';</span></span></code> </pre> <br><p> 我们没有输出实际的实现，而是指示了各个部分的相对路径。 进行此更改后， <em>howdy.js</em>仅指向其他软件包，并且不包含任何“真实”代码。 <br> 让我们运行<em>ng</em>并分析<em>dist</em>文件夹。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7fa/cdd/771/7facdd77175baa79d8f7200b0ec7a224.png" alt="图片"></p><br><p>  <em>Howdy.js</em>现在充当指向包含实现的片段的“路标”“指针”。  howdy-src-lib-name.js块仅包含<em>名称</em>文件夹中的代码， <em>howdy-src-lib-time.js文件</em>仅包含<em>time</em>文件夹中的代码。 </p><br><h3 id="zavershit-paket-s-podstatyami"> 用替代品完成包装 </h3><br><p> 让我们更新欢迎应用程序中的<em>howdy</em>包，然后重新运行分析脚本。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/975/fdf/a2f/975fdfa2fb79a01af0bf5937af75bc60.png" alt="图片"></p><br><p> 好酷 软件包大小现在为<em>170.94 KB</em> 。 比最初略高。 让我们看看<em>Howdy</em>模块在最终捆绑包中的外观。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f6d/7e5/e86/f6d7e5e860609add4fddc0b13640d5a5.png" alt="图片"></p><br><p> 太好了！ 这项调整使我们可以将占用包装尺寸的SPA保持在较小的水平。  SPA只满足他们的需求！ </p><br><blockquote> 将辅助入口点与延迟加载结合使用时，它们非常好。 如果我们在延迟加载的模块中使用<em>HowdyTimeModule</em> ，则<em>力矩</em> <em>最终</em>会在延迟加载的块中结束，而不是基本结束。 </blockquote><br><h3 id="realnyy-opyt"> 真实经验 </h3><br><p> 上面的例子很简单。 </p><br><p> 但是，在现有公司项目中引入辅助入口点之后，一切都会有所不同。 您必须处理更大的复杂性，而<em>ng-packagr的</em>错误消息并不总是有用。 </p><br><p> 最可能的是，您将需要在<em>tsconfig.json</em>文件中配置一些导入路径或指定一些路径。 您还将遇到一个块中的模块，这些模块使用另一块中的模块。 </p><br><p> 但是请相信我，一旦您处理了这个负担，就值得了。 </p><br><p> 在广泛的公司环境中，我们发现包含我们提供的某些库之后，新创建的SPA的包装大小爆炸了。 </p><br><p> 在某个时候，它甚至达到了<em>5 MB</em> 。 每个SPA都会收到<em>时刻</em> ， <em>@ swimlane /数据表</em>以及他甚至没有使用的其他信息。 我们开始专注于优化这种包装尺寸。 </p><br><p> 我们从<em>date-fns中</em>删除了<em>力矩</em> ，并开始使用辅助入口点。 目前，我们为新创建的SPA收到了662KB的主体单元，其中包括几个库。 这仍然很多，但是我们还没有完成。 优化尚未完成-我们可以进一步减少数据包的大小。 </p><br><p> 看到我们在哪里，来自哪里，这真是太酷了。 </p><br><p> 但是，尽管事实上在上面的示例中使用其他入口点非常容易，但是在更重要的项目中很难想象它们。 </p><br><h3 id="zaklyuchenie"> 结论 </h3><br><p> 在优化包装尺寸方面，Angular做得很棒。 尽管优化的组装步骤非常复杂，但它们无法撼动树木。 </p><br><p> 以<em>ESModules</em>以外的格式打包的模块不能摇晃。 </p><br><p> 因此，作为库的创建者，当我们包含第三方库时，我们必须仔细监视库对包大小的影响。 <br> 我们无法控制第三方库的包装。 但是我们可以很好地控制图书馆的包装。 </p><br><p> 子部分为我们提供了一种很好的方式来分几部分交付我们的库。 这些零件可以在优化Angulars的装配过程中摇动（可摇树）。 通过这种方法，即使包装不正确的第三方库也只有在使用时才包含在最终包装中。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN482646/">https://habr.com/ru/post/zh-CN482646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN482626/index.html">使用Logger.Backends监视应用程序</a></li>
<li><a href="../zh-CN482628/index.html">观看“时间的小绿蜘蛛”</a></li>
<li><a href="../zh-CN482636/index.html">在德国接受治安法官的经验（详细分析）</a></li>
<li><a href="../zh-CN482642/index.html">OSCD：威胁检测Sprint＃1，结果</a></li>
<li><a href="../zh-CN482644/index.html">Windows的Keylogger，具有DACL中的权利更改</a></li>
<li><a href="../zh-CN482648/index.html">Arthur Khachuyan：“广告中的真正大数据”</a></li>
<li><a href="../zh-CN482650/index.html">将Yealink W80B微蜂窝IP-DECT系统连接到3CX</a></li>
<li><a href="../zh-CN482652/index.html">给初学者的信，以学习数据科学</a></li>
<li><a href="../zh-CN482656/index.html">喷气机翼伊夫·罗西（Yves Rossi）：自主垂直起降</a></li>
<li><a href="../zh-CN482664/index.html">回顾过去十年的技术</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>