<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüéì üëû üë©üèΩ‚ÄçüöÄ Sperren in PostgreSQL: 1. Beziehungssperren üç∞ üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø üë©üèæ‚Äçü§ù‚Äçüë©üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die beiden vorherigen Artikelserien haben sich auf Isolation, Multiversionismus und Journaling konzentriert . 

 In dieser Serie werden wir √ºber Schl√∂...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sperren in PostgreSQL: 1. Beziehungssperren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/462877/">  Die beiden vorherigen Artikelserien haben sich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isolation, Multiversionismus</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Journaling konzentriert</a> . <br><br>  In dieser Serie werden wir √ºber Schl√∂sser sprechen.  Ich werde mich an diesen Begriff halten, aber in der Literatur kann es auch einen anderen geben: <em>Schloss</em> . <br><br>  Der Zyklus besteht aus vier Teilen: <br><br><ol><li>  Beziehungssperren (dieser Artikel); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihenschl√∂sser</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sperren anderer Objekte</a> und Pr√§dikatsperren; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sperrt den Arbeitsspeicher</a> . </li></ol><br>  Das Material aller Artikel basiert auf administrativen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schulungen</a> , die Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">pluzanov</a> und ich durchf√ºhren, aber nicht w√∂rtlich wiederholen und f√ºr nachdenkliches Lesen und unabh√§ngiges Experimentieren gedacht sind. <br><br><img src="https://habrastorage.org/webt/rx/jt/bz/rxjtbz_s6otkhbwcm6agmmtldxe.png"><br><br><h1>  Allgemeine Informationen zu Schl√∂ssern </h1><br>  PostgreSQL verwendet viele verschiedene Mechanismen, die verwendet werden, um etwas zu blockieren (oder zumindest so genannt werden).  Daher beginne ich mit den allgemeinsten Worten dar√ºber, warum Schl√∂sser √ºberhaupt ben√∂tigt werden, was sie sind und wie sie sich voneinander unterscheiden.  Dann werden wir sehen, was von dieser Sorte in PostgreSQL zu finden ist, und erst danach werden wir uns im Detail mit verschiedenen Arten von Sperren befassen. <br><a name="habracut"></a><br>  Sperren werden verwendet, um den gleichzeitigen Zugriff auf freigegebene Ressourcen zu optimieren. <br><br>  Wettbewerbszugriff bezieht sich auf den gleichzeitigen Zugriff mehrerer Prozesse.  Die Prozesse selbst k√∂nnen sowohl parallel (sofern das Ger√§t dies zul√§sst) als auch nacheinander im Time-Sharing-Modus ausgef√ºhrt werden - dies ist nicht wichtig. <br><br>  Wenn keine Konkurrenz besteht, sind keine Sperren erforderlich (z. B. erfordert ein gemeinsam genutzter Puffercache Sperren, ein lokaler jedoch nicht). <br><br>  Vor dem Zugriff auf eine Ressource muss ein Prozess die dieser Ressource zugeordnete Sperre erwerben.  Das hei√üt, wir sprechen von einer bestimmten Disziplin: Alles funktioniert, solange alle Prozesse den festgelegten Regeln f√ºr den Zugriff auf eine gemeinsam genutzte Ressource entsprechen.  Wenn das DBMS die Sperren verwaltet, √ºberwacht es selbst die Reihenfolge.  Wenn die Sperrung durch den Antrag festgelegt wird, liegt diese Verpflichtung bei ihm. <br><br>  Auf einer niedrigen Ebene wird eine Sperre durch einen Abschnitt des gemeinsam genutzten Speichers dargestellt, in dem auf irgendeine Weise festgestellt wird, ob die Sperre frei oder erfasst ist (und m√∂glicherweise zus√§tzliche Informationen aufgezeichnet werden: Prozessnummer, Erfassungszeit usw.). <br><br><blockquote>  M√∂glicherweise stellen Sie fest, dass ein solcher gemeinsam genutzter Speicher an sich eine Ressource ist, auf die ein wettbewerbsf√§higer Zugriff m√∂glich ist.  Wenn wir auf eine niedrigere Ebene gehen, werden wir sehen, dass spezielle Zusatzprimitive (wie Semaphore oder Mutexe), die vom Betriebssystem bereitgestellt werden, verwendet werden, um den Zugriff zu organisieren.  Ihre Bedeutung ist, dass der Code, der auf die gemeinsam genutzte Ressource zugreift, jeweils nur in einem Prozess ausgef√ºhrt werden sollte.  Auf der untersten Ebene werden diese Grundelemente basierend auf atomaren Prozessoranweisungen (wie Test-and-Set oder Compare-and-Swap) implementiert. <br></blockquote><br>  Nachdem die Ressource vom Prozess nicht mehr ben√∂tigt wird, <em>wird die</em> Sperre aufgehoben, damit andere Benutzer die Ressource verwenden k√∂nnen. <br><br>  Das Sperren der Sperre ist nat√ºrlich nicht immer m√∂glich: Die Ressource wird m√∂glicherweise bereits von einer anderen Person belegt.  Dann tritt der Prozess entweder in die Warteschlange ein (wenn der Sperrmechanismus diese M√∂glichkeit bietet) oder versucht erneut, die Sperre nach einer bestimmten Zeit zu erfassen.  Auf die eine oder andere Weise f√ºhrt dies dazu, dass der Prozess gezwungen ist, im Vorgriff auf die Freigabe der Ressource unt√§tig zu bleiben. <br><br><blockquote>  Manchmal ist es m√∂glich, andere nicht blockierende Strategien anzuwenden.  Beispielsweise erm√∂glicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Multiversionsmechanismus</a> in einigen F√§llen, dass mehrere Prozesse gleichzeitig mit verschiedenen Datenversionen arbeiten, ohne sich gegenseitig zu blockieren. <br></blockquote><br>  Im Prinzip kann eine gesch√ºtzte Ressource alles sein, wenn nur diese Ressource eindeutig identifiziert und mit einer Sperradresse abgeglichen werden k√∂nnte. <br><br>  Die Ressource kann beispielsweise das Objekt sein, mit dem das DBMS arbeitet, z. B. eine Datenseite (identifiziert durch den Dateinamen und die Position in der Datei), eine Tabelle (oid im Systemverzeichnis), eine Tabellenzeile (Seite und Offset innerhalb der Seite).  Eine Ressource kann eine Struktur im Speicher sein, z. B. eine Hash-Tabelle, ein Puffer usw. (gekennzeichnet durch eine vorab zugewiesene Nummer).  Manchmal ist es sogar bequem, abstrakte Ressourcen zu verwenden, die keine physikalische Bedeutung haben (sie werden einfach durch eine eindeutige Nummer identifiziert). <br><br>  Die Wirksamkeit von Schl√∂ssern wird von vielen Faktoren beeinflusst, von denen wir zwei unterscheiden. <br><br><ul><li>  <strong>Granularit√§t</strong> (Granularit√§t) ist wichtig, wenn Ressourcen eine Hierarchie bilden. <br><br>  Eine Tabelle besteht beispielsweise aus Seiten, die Tabellenzeilen enthalten.  Alle diese Objekte k√∂nnen als Ressourcen fungieren.  Wenn Prozesse normalerweise nur an wenigen Zeilen interessiert sind und die Sperre auf Tabellenebene festgelegt ist, k√∂nnen andere Prozesse nicht gleichzeitig mit anderen Zeilen arbeiten.  Je h√∂her die Granularit√§t ist, desto besser ist daher die M√∂glichkeit einer Parallelisierung. <br><br>  Dies f√ºhrt jedoch zu einer Erh√∂hung der Anzahl der Sperren (Informationen dar√ºber m√ºssen gespeichert werden).  In diesem Fall kann eine <em>Erh√∂hung der Ebene</em> (Eskalation) von Sperren angewendet werden: Wenn die Anzahl der granularen Sperren auf niedriger Ebene eine bestimmte Grenze √ºberschreitet, werden sie durch eine Sperre auf einer h√∂heren Ebene ersetzt. <br></li><li>  Sperren k√∂nnen in verschiedenen <strong>Modi</strong> erfasst <strong>werden</strong> . <br><br>  Die Namen der Modi k√∂nnen absolut willk√ºrlich sein, nur die Matrix ihrer Kompatibilit√§t untereinander ist wichtig.  Ein Modus, der mit keinem Modus (einschlie√ülich mit sich selbst) kompatibel ist, wird normalerweise als <em>exklusiv</em> oder exklusiv bezeichnet.  Wenn die Modi kompatibel sind, kann die Sperre von mehreren Prozessen gleichzeitig erfasst werden.  Solche Modi werden als gemeinsam genutzt bezeichnet.  Im Allgemeinen werden umso mehr M√∂glichkeiten f√ºr Parallelit√§t geschaffen, je mehr verschiedene Modi unterschieden werden k√∂nnen, die miteinander kompatibel sind. <br></li></ul><br>  Je nach Nutzungsdauer k√∂nnen Schl√∂sser in lange und kurze Schl√∂sser unterteilt werden. <br><br><ul><li>  <strong>Langzeitsperren</strong> werden f√ºr eine m√∂glicherweise lange Zeit (normalerweise bis zum Ende der Transaktion) erfasst und beziehen sich meist auf Ressourcen wie Tabellen (Beziehungen) und Zeilen.  PostgreSQL verwaltet diese Sperren normalerweise automatisch, der Benutzer hat jedoch eine gewisse Kontrolle √ºber diesen Prozess. <br><br>  Lange Sperren zeichnen sich durch eine Vielzahl von Modi aus, so dass m√∂glichst viele gleichzeitige Aktionen an den Daten ausgef√ºhrt werden k√∂nnen.  Typischerweise gibt es f√ºr solche Sperren eine entwickelte Infrastruktur (z. B. Unterst√ºtzung von Warteschlangen und Erkennung von Deadlocks) und √úberwachungstools, da die Kosten f√ºr die Wartung all dieser Annehmlichkeiten im Vergleich zu den Betriebskosten f√ºr gesch√ºtzte Daten immer noch unvergleichlich niedriger sind. <br></li><li>  <strong>Kurzzeitsperren</strong> werden f√ºr kurze Zeit erfasst (von einigen Prozessoranweisungen bis zu Sekundenbruchteilen) und beziehen sich normalerweise auf Datenstrukturen im gemeinsam genutzten Speicher.  PostgreSQL verwaltet solche Sperren vollautomatisch - Sie m√ºssen nur √ºber ihre Existenz Bescheid wissen. <br><br>  Kurze Sperren zeichnen sich durch ein Minimum an Modi (exklusiv und gemeinsam genutzt) und eine einfache Infrastruktur aus.  In einigen F√§llen sind m√∂glicherweise nicht einmal √úberwachungstools verf√ºgbar. <br></li></ul><br>  PostgreSQL verwendet verschiedene Arten von Sperren. <br><br>  <strong>Sperren auf Objektebene</strong> sind langfristige ‚Äûschwere‚Äú <strong>Sperren</strong> .  Die Ressourcen hier sind Beziehungen und andere Objekte.  Wenn das Wort Blockierung ohne Klarstellung im Text erscheint, bedeutet dies eine solche ‚Äûnormale‚Äú Blockierung. <br><br>  Bei Langzeitsperren fallen Sperren auf Zeilenebene separat auf.  Ihre Implementierung unterscheidet sich von anderen Langzeitsperren aufgrund ihrer potenziell gro√üen Anzahl (stellen Sie sich vor, Sie aktualisieren eine Million Zeilen in einer Transaktion).  Solche Sperren werden im n√§chsten Artikel behandelt. <br><br>  Der dritte Artikel der Reihe befasst sich mit den verbleibenden Sperren auf Objektebene sowie mit <strong>Pr√§dikatsperren</strong> (da Informationen zu all diesen Sperren auf dieselbe Weise im RAM gespeichert werden). <br><br>  Kurze Sperren umfassen verschiedene <strong>Sperren von RAM-Strukturen</strong> .  Wir werden sie im letzten Artikel des Zyklus betrachten. <br><br><h1>  Objekt sperrt </h1><br>  Wir beginnen also mit Sperren auf Objektebene.  Hier wird ein Objekt in erster Linie als <em>Relationen</em> verstanden, dh als Tabellen, Indizes, Sequenzen, materialisierte Darstellungen, aber auch als einige andere Entit√§ten.  Diese Sperren sch√ºtzen Objekte normalerweise davor, gleichzeitig ge√§ndert zu werden oder w√§hrend des Objektwechsels verwendet zu werden, aber auch f√ºr andere Zwecke. <br><br>  Verschwommene Formulierung?  Dies liegt daran, dass Sperren aus dieser Gruppe f√ºr eine Vielzahl von Zwecken verwendet werden.  Was sie verbindet, ist, wie sie angeordnet sind. <br><br><h2>  Ger√§t </h2><br>  Die Objektsperren befinden sich im gemeinsam genutzten Speicher des Servers.  Ihre Anzahl wird durch das Produkt der Werte zweier Parameter begrenzt: <em>max_locks_per_transaction</em> √ó <em>max_connections</em> . <br><br>  Der <em>Sperrpool</em> ist f√ºr alle Transaktionen gleich, <em>dh</em> eine Transaktion kann mehr Sperren erfassen als <em>max_locks_per_transaction</em> : Es ist nur wichtig, dass die Gesamtzahl der Sperren im System das festgelegte Limit nicht √ºberschreitet.  Der Pool wird beim Start erstellt. Wenn Sie also eine der beiden angegebenen Optionen √§ndern, m√ºssen Sie den Server neu starten. <br><br>  Alle Sperren k√∂nnen in der Ansicht pg_locks angezeigt werden. <br><br>  Wenn die Ressource bereits im inkompatiblen Modus gesperrt ist, wird eine Transaktion, die versucht, diese Ressource zu erfassen, in die Warteschlange gestellt und wartet auf die Freigabe der Sperre.  Ausstehende Transaktionen verbrauchen keine Prozessorressourcen: Die entsprechenden Serviceprozesse ‚Äûschlafen ein‚Äú und werden vom Betriebssystem aktiviert, wenn die Ressource freigegeben wird. <br><br>  Eine <em>Deadlock-</em> oder <em>Deadlock-</em> Situation ist m√∂glich, in der f√ºr eine Transaktion eine von der zweiten Transaktion belegte Ressource erforderlich ist, um fortzufahren, und f√ºr die zweite eine von der ersten belegte Ressource erforderlich ist (im Allgemeinen k√∂nnen ein Deadlock und mehr als zwei Transaktionen auftreten).  In diesem Fall wird das Warten auf unbestimmte Zeit fortgesetzt, sodass PostgreSQL solche Situationen automatisch erkennt und eine der Transaktionen abbricht, damit andere weiterarbeiten k√∂nnen.  (Wir werden im n√§chsten Artikel mehr √ºber Deadlocks sprechen.) <br><br><h2>  Objekttypen </h2><br>  Hier ist eine Liste der Arten von Sperren (oder, wenn Sie m√∂chten, der Arten von Objekten), mit denen wir uns in diesem und im n√§chsten Artikel befassen werden.  Die Namen werden gem√§√ü der Spalte locktype in der Ansicht pg_locks angegeben. <br><br><ul><li>  <strong>Beziehung</strong> <br><br>  Beziehungssperren. <br></li><li>  <strong>Transaktions-</strong> <strong>ID</strong> und <strong>VirtualXID</strong> <br><br>  Blockieren einer Transaktionsnummer (real oder virtuell).  Jede Transaktion selbst verf√ºgt √ºber eine exklusive Sperre mit einer eigenen Nummer. Daher k√∂nnen solche Sperren bequem verwendet werden, wenn Sie bis zum Ende einer anderen Transaktion warten m√ºssen. <br></li><li>  <strong>Tupel</strong> <br><br>  String-Versionssperre.  In einigen F√§llen wird es verwendet, um die Priorit√§t f√ºr mehrere Transaktionen festzulegen, bei denen erwartet wird, dass dieselbe Zeile gesperrt wird. <br></li></ul><br>  Wir werden die Diskussion der verbleibenden Arten von Sperren auf den dritten Artikel im Zyklus verschieben.  Alle von ihnen werden entweder nur im Ausnahmemodus oder exklusiv und gemeinsam erfasst. <br><br><ul><li>  <strong>verl√§ngern</strong> <br><br>  Wird verwendet, wenn einer Datei einer Beziehung Seiten hinzugef√ºgt werden. <br></li><li>  <strong>Objekt</strong> <br><br>  Sperren von Objekten, die keine Beziehungen sind (Datenbanken, Schemas, Abonnements usw.). <br></li><li>  <strong>Seite</strong> <br><br>  Die Seitensperre wird selten und nur von einigen Arten von Indizes verwendet. <br></li><li>  <strong>Beratung</strong> <br><br>  Empfohlene Blockierung, vom Benutzer manuell eingestellt. <br></li></ul><br><h1>  Beziehungssperren </h1><br>  Um den Kontext nicht zu verlieren, werde ich auf einem solchen Bild die Arten von Schl√∂ssern markieren, auf die sp√§ter noch eingegangen wird. <br><br><img src="https://habrastorage.org/webt/od/wc/ne/odwcnenfvjv_ikwmqw8x-vaexqi.png"><br><br><h2>  Modi </h2><br>  Wenn nicht das Wichtigste, dann sicherlich das ‚Äûverzweigteste‚Äú Blockieren - Blockieren von Beziehungen.  F√ºr sie sind bis zu 8 verschiedene Modi definiert.  Eine solche Menge ist notwendig, damit die gr√∂√ütm√∂gliche Anzahl von Befehlen, die zu einer Tabelle geh√∂ren, gleichzeitig ausgef√ºhrt werden kann. <br><br>  Es macht keinen Sinn, diese Modi auswendig zu lernen oder zu versuchen, die Bedeutung ihrer Namen zu verstehen.  Die Hauptsache ist, zur richtigen Zeit eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Matrix</a> vor Ihren Augen zu haben, die zeigt, welche Sperren miteinander in Konflikt stehen.  Der Einfachheit halber wird es hier zusammen mit Beispielen von Befehlen wiedergegeben, f√ºr die geeignete Sperrstufen erforderlich sind: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Sperrmodus </th><th>  Wie </th><th>  RS </th><th>  RE </th><th>  Sue </th><th>  S. </th><th>  SRE </th><th>  E. </th><th>  Ae </th><th>  Beispiel <nobr>SQL-Befehle</nobr> </th></tr><tr><td>  Zugriffsfreigabe </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X. </td><td>  AUSW√ÑHLEN </td></tr><tr><td>  Zeilenfreigabe </td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X. </td><td>  X. </td><td>  F√úR UPDATE / SHARE AUSW√ÑHLEN </td></tr><tr><td>  Zeile exklusiv </td><td></td><td></td><td></td><td></td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  INSERT, UPDATE, DELETE </td></tr><tr><td>  Update exklusiv teilen </td><td></td><td></td><td></td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  VAKUUM, ALTER TABELLE <sup>*</sup> , INDEX KONZURRENT ERSTELLEN </td></tr><tr><td>  Teilen </td><td></td><td></td><td>  X. </td><td>  X. </td><td></td><td>  X. </td><td>  X. </td><td>  X. </td><td>  INDEX ERSTELLEN </td></tr><tr><td>  Zeile exklusiv teilen </td><td></td><td></td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  TRIGGER ERSTELLEN, TABELLE √ÑNDERN <sup>*</sup> </td></tr><tr><td>  Exklusiv </td><td></td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  REFRESH MAT.  KONZURRENT ANZEIGEN </td></tr><tr><td>  Zugriff exklusiv </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  DROP, TRUNCATE, VACUUM FULL, LOCK TABLE, ALTER TABLE <sup>*</sup> , REFRESH MAT.  ANSICHT </td></tr></tbody></table></div><br>  Einige Kommentare: <br><br><ul><li>  Die ersten 4 Modi erm√∂glichen gleichzeitige Daten√§nderungen in der Tabelle, die n√§chsten 4 nicht. </li><li>  Der erste Modus (Access Share) ist der schw√§chste und mit allen anderen als dem letzten kompatibel (Access Exclusive).  Dieser letzte Modus ist exklusiv und mit keinem Modus kompatibel. </li><li>  Der Befehl ALTER TABLE verf√ºgt √ºber viele Optionen, f√ºr die unterschiedliche Sperrstufen erforderlich sind.  Daher wird dieser Befehl in der Matrix in verschiedenen Zeilen angezeigt und mit einem Sternchen markiert. </li></ul><br><h2>  Zum Beispiel </h2><br>  Geben Sie ein Beispiel.  Was passiert, wenn ich den Befehl CREATE INDEX ausf√ºhre? <br><br>  In der Dokumentation finden wir, dass dieser Befehl die Sperre in den Freigabemodus setzt.  Gem√§√ü der Matrix stellen wir fest, dass der Befehl mit sich selbst (dh Sie k√∂nnen gleichzeitig mehrere Indizes erstellen) und mit Lesebefehlen kompatibel ist.  Somit funktionieren die SELECT-Befehle weiterhin, aber die UPDATE-, DELETE- und INSERT-Befehle werden blockiert. <br><br>  Und umgekehrt - unvollst√§ndige Transaktionen, die Daten in der Tabelle √§ndern, blockieren die Operation des Befehls CREATE INDEX.  Daher gibt es eine Variante des Befehls - INDEX CONCURRENTLY ERSTELLEN.  Es funktioniert l√§nger (und kann sogar fehlerhaft sein), erm√∂glicht jedoch gleichzeitige Daten√§nderungen. <br><br>  Dies kann in der Praxis gesehen werden.  F√ºr Experimente verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Zyklus</a> bekannte Tabelle der Bankkonten, in der wir die Kontonummer und den Betrag speichern. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( acc_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3000.00</span></span>);</code> </pre> <br>  Starten Sie in der zweiten Sitzung die Transaktion.  Wir ben√∂tigen eine Serviceprozessnummer. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| pg_backend_pid | ---------------- | 4746 | (1 row)</code> </pre><br>  Welche Sperren h√§lt die neu gestartete Transaktion?  Wir schauen in pg_locks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">REGCLASS</span></span>, virtualxid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> virtxid, transactionid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">4746</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ------------+----------+---------+-----+---------------+--------- virtualxid | | 5/15 | | ExclusiveLock | t (1 row)</code> </pre><br>  Wie ich bereits sagte, enth√§lt eine Transaktion immer eine exklusive (ExclusiveLock) Sperre ihrer eigenen Nummer, in diesem Fall eine virtuelle.  Es gibt keine weiteren Sperren f√ºr diesen Prozess. <br><br>  Aktualisieren Sie nun die Tabellenzeile.  Wie wird sich die Situation √§ndern? <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ---------------+---------------+---------+--------+------------------+--------- relation | accounts_pkey | | | RowExclusiveLock | t relation | accounts | | | RowExclusiveLock | t virtualxid | | 5/15 | | ExclusiveLock | t transactionid | | | 529404 | ExclusiveLock | t (4 rows)</code> </pre><br>  Jetzt gibt es Sperren f√ºr die ver√§nderbare Tabelle und den Index (erstellt f√ºr den Prim√§rschl√ºssel), die vom Befehl UPDATE verwendet werden.  Beide Sperren werden im RowExclusiveLock-Modus ausgef√ºhrt.  Zus√§tzlich wurde eine exklusive Sperrung der realen Transaktionsnummer hinzugef√ºgt (die angezeigt wurde, sobald die Transaktion begann, Daten zu √§ndern). <br><br>  In einer anderen Sitzung versuchen wir nun, einen Index f√ºr eine Tabelle zu erstellen. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| pg_backend_pid || ---------------- || 4782 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> accounts(acc_no);</code> </pre><br>  Der Befehl friert in Erwartung der Freigabe der Ressource ein.  Welche Art von Schloss versucht sie zu erobern?  √úberpr√ºfen Sie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">REGCLASS</span></span>, virtualxid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> virtxid, transactionid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">4782</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ------------+----------+---------+-----+---------------+--------- virtualxid | | 6/15 | | ExclusiveLock | t relation | accounts | | | ShareLock | f (2 rows)</code> </pre><br>  Wir sehen, dass die Transaktion versucht, die Tabellensperre im ShareLock-Modus zu erhalten, dies jedoch nicht kann (gew√§hrt = f). <br><br>  Es ist praktisch, die Nummer des Blockierungsprozesses und im Allgemeinen mehrere Nummern mithilfe der in Version 9.6 angegebenen Funktion zu ermitteln (zuvor musste ich Schlussfolgerungen ziehen, indem ich den gesamten Inhalt von pg_locks sorgf√§ltig betrachtete): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_blocking_pids(<span class="hljs-number"><span class="hljs-number">4782</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_blocking_pids ------------------ {4746} (1 row)</code> </pre><br>  Um die Situation zu verstehen, k√∂nnen Sie Informationen zu den Sitzungen abrufen, einschlie√ülich der gefundenen Zahlen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-keyword"><span class="hljs-keyword">ANY</span></span>(pg_blocking_pids(<span class="hljs-number"><span class="hljs-number">4782</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+------------------------------------------------------------ datid | 16386 datname | test pid | 4746 usesysid | 16384 usename | student application_name | psql client_addr | client_hostname | client_port | -1 backend_start | 2019-08-07 15:02:53.811842+03 xact_start | 2019-08-07 15:02:54.090672+03 query_start | 2019-08-07 15:02:54.10621+03 state_change | 2019-08-07 15:02:54.106965+03 wait_event_type | Client wait_event | ClientRead state | idle in transaction backend_xid | 529404 backend_xmin | query | UPDATE accounts SET amount = amount + 100 WHERE acc_no = 1; backend_type | client backend</code> </pre><br>  Nach Abschluss der Transaktion werden die Sperren aufgehoben und der Index erstellt. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br><pre> <code class="plaintext hljs">|| CREATE INDEX</code> </pre><br><h2>  In der Warteschlange! .. </h2><br>  Um sich besser vorstellen zu k√∂nnen, wozu das Auftreten einer inkompatiblen Sperre f√ºhrt, werden wir sehen, was passiert, wenn der Befehl VACUUM FULL w√§hrend des Systembetriebs ausgef√ºhrt wird. <br><br>  Lassen Sie den Befehl SELECT zuerst in unserer Tabelle ausgef√ºhrt werden.  Sie erh√§lt eine Sperre f√ºr die schw√§chste Stufe von Access Share.  Um die Freigabezeit der Sperre zu steuern, f√ºhren wir diesen Befehl innerhalb der Transaktion aus. Bis zum Ende der Transaktion wird die Sperre nicht freigegeben.  In der Realit√§t k√∂nnen mehrere Befehle die Tabelle lesen (und √§ndern), und einige der Abfragen k√∂nnen eine Weile dauern. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> acc_no | amount --------+--------- 2 | 2000.00 3 | 3000.00 1 | 1100.00 (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+-----------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} (1 row)</code> </pre><br>  Anschlie√üend f√ºhrt der Administrator den Befehl VACUUM FULL aus, f√ºr den eine Zugriffssperrung auf exklusiver Ebene erforderlich ist, die auch mit Access Share nicht kompatibel ist.  (Der Befehl LOCK TABLE erfordert ebenfalls dieselbe Sperre.) Die Transaktionswarteschlangen. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">LOCK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">--  VACUUM FULL</span></span></code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} relation | AccessExclusiveLock | f | 4746 | {4710} (2 rows)</code> </pre><br>  Die Anwendung gibt jedoch weiterhin Anforderungen aus, und jetzt wird der Befehl SELECT im System angezeigt.  Rein theoretisch h√§tte sie "ausrutschen" k√∂nnen, w√§hrend VACUUM FULL wartet, aber nein - sie nimmt ehrlich gesagt einen Platz in der Warteschlange f√ºr VACUUM FULL ein. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} relation | AccessExclusiveLock | f | 4746 | {4710} relation | AccessShareLock | f | 4782 | {4746} (3 rows)</code> </pre><br>  Nachdem die erste Transaktion mit dem Befehl SELECT abgeschlossen und die Sperre aufgehoben wurde, beginnt der Befehl VACUUM FULL (den wir mit dem Befehl LOCK TABLE simuliert haben). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><br><pre> <code class="plaintext hljs">| LOCK TABLE</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessExclusiveLock | t | 4746 | {} relation | AccessShareLock | f | 4782 | {4746} (2 rows)</code> </pre><br>  Und erst wenn VACUUM FULL seine Arbeit abgeschlossen und die Sperre aufgehoben hat, k√∂nnen alle in der Warteschlange gesammelten Befehle (in unserem Beispiel SELECT) die entsprechenden Sperren erfassen (Access Share) und ausf√ºhren. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br><pre> <code class="plaintext hljs">|| acc_no | amount || --------+--------- || 2 | 2000.00 || 3 | 3000.00 || 1 | 1100.00 || (3 rows)</code> </pre><br>  Somit kann ein ungenauer Befehl den Betrieb des Systems f√ºr eine Zeit l√§hmen, die erheblich l√§nger ist als die Ausf√ºhrungszeit des Befehls selbst. <br><br><h1>  √úberwachungstools </h1><br>  Nat√ºrlich sind Schl√∂sser f√ºr den korrekten Betrieb notwendig, k√∂nnen aber zu unerw√ºnschten Erwartungen f√ºhren.  Solche Erwartungen k√∂nnen √ºberwacht werden, um ihre Ursache zu verstehen und wenn m√∂glich zu beseitigen (z. B. durch √Ñndern des Anwendungsalgorithmus). <br><br>  Wir haben bereits eine M√∂glichkeit kennengelernt: Im Moment einer langen Sperre k√∂nnen wir eine Anforderung an die Ansicht pg_locks ausf√ºhren, die sperrbaren und blockierenden Transaktionen (Funktion pg_blocking_pids) anzeigen und sie mit pg_stat_activity entschl√ºsseln. <br><br>  Eine andere M√∂glichkeit besteht darin, den Parameter <em>log_lock_waits</em> zu aktivieren.  In diesem Fall werden Informationen im Nachrichtenprotokoll des Servers angezeigt, wenn die Transaktion l√§nger als <em>deadlock_timeout</em> gewartet hat (obwohl der Parameter f√ºr Deadlocks verwendet wird, handelt es sich um normale Erwartungen). <br><br>  Lass es uns versuchen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_lock_waits = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Der Standardparameterwert f√ºr <em>deadlock_timeout</em> betr√§gt eine Sekunde: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> deadlock_timeout;</code> </pre><pre> <code class="plaintext hljs"> deadlock_timeout ------------------ 1s (1 row)</code> </pre><br>  Spielen Sie das Schloss. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">UPDATE 1</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Der zweite UPDATE-Befehl erwartet eine Sperre.  Warten Sie eine Sekunde und schlie√üen Sie die erste Transaktion ab. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><br>  Jetzt kann die zweite Transaktion abgeschlossen werden. <br><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br>  Und alle wichtigen Informationen kamen ins Tagebuch: <br><br><pre> <code class="plaintext hljs">postgres$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-08-07 15:26:30.827 MSK [5898] student@test LOG: process 5898 still waiting for ShareLock on transaction 529427 after 1000.186 ms 2019-08-07 15:26:30.827 MSK [5898] student@test DETAIL: Process holding the lock: 5862. Wait queue: 5898. 2019-08-07 15:26:30.827 MSK [5898] student@test CONTEXT: while updating tuple (0,4) in relation "accounts" 2019-08-07 15:26:30.827 MSK [5898] student@test STATEMENT: UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;</code> </pre><pre> <code class="plaintext hljs">2019-08-07 15:26:30.836 MSK [5898] student@test LOG: process 5898 acquired ShareLock on transaction 529427 after 1009.536 ms 2019-08-07 15:26:30.836 MSK [5898] student@test CONTEXT: while updating tuple (0,4) in relation "accounts" 2019-08-07 15:26:30.836 MSK [5898] student@test STATEMENT: UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462877/">https://habr.com/ru/post/de462877/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462859/index.html">Wie ein europ√§isches Busunternehmen in Russland operiert: Wie unterscheiden sich Busse und Fahrg√§ste?</a></li>
<li><a href="../de462863/index.html">21. August Sendung Zabbix Moscow Meetup # 5</a></li>
<li><a href="../de462867/index.html">Ausw√§hlen eines Farbschemas f√ºr Ihre App: Wie machen Sie es einfach?</a></li>
<li><a href="../de462869/index.html">Agileanisches Projektmanagementsystem</a></li>
<li><a href="../de462875/index.html">So senken Sie Kosten und bieten optimalen IT-Support f√ºr das Gesch√§ftsmodell. Wir suchen den ‚Äûmittleren Weg der Erl√∂sung‚Äú</a></li>
<li><a href="../de462879/index.html">Slurm DevOps: von Git bis SRE mit allen Register</a></li>
<li><a href="../de462881/index.html">Warum ist es so schwierig zu entscheiden, welchen Film man sehen m√∂chte (und was getan werden k√∂nnte)?</a></li>
<li><a href="../de462883/index.html">Entwerfen eines Online-Shops f√ºr SEO: (Theorie + Checkliste)</a></li>
<li><a href="../de462885/index.html">Fehlertolerantes IPoE-Netzwerk zur Hand</a></li>
<li><a href="../de462887/index.html">Die Erfahrung der Personalisierung eines Online-Shops am Beispiel einer dynamischen Empfehlung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>