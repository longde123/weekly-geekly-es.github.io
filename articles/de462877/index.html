<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🎓 👞 👩🏽‍🚀 Sperren in PostgreSQL: 1. Beziehungssperren 🍰 🏴󠁧󠁢󠁥󠁮󠁧󠁿 👩🏾‍🤝‍👩🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die beiden vorherigen Artikelserien haben sich auf Isolation, Multiversionismus und Journaling konzentriert . 

 In dieser Serie werden wir über Schlö...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sperren in PostgreSQL: 1. Beziehungssperren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/462877/">  Die beiden vorherigen Artikelserien haben sich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isolation, Multiversionismus</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Journaling konzentriert</a> . <br><br>  In dieser Serie werden wir über Schlösser sprechen.  Ich werde mich an diesen Begriff halten, aber in der Literatur kann es auch einen anderen geben: <em>Schloss</em> . <br><br>  Der Zyklus besteht aus vier Teilen: <br><br><ol><li>  Beziehungssperren (dieser Artikel); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihenschlösser</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sperren anderer Objekte</a> und Prädikatsperren; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sperrt den Arbeitsspeicher</a> . </li></ol><br>  Das Material aller Artikel basiert auf administrativen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schulungen</a> , die Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">pluzanov</a> und ich durchführen, aber nicht wörtlich wiederholen und für nachdenkliches Lesen und unabhängiges Experimentieren gedacht sind. <br><br><img src="https://habrastorage.org/webt/rx/jt/bz/rxjtbz_s6otkhbwcm6agmmtldxe.png"><br><br><h1>  Allgemeine Informationen zu Schlössern </h1><br>  PostgreSQL verwendet viele verschiedene Mechanismen, die verwendet werden, um etwas zu blockieren (oder zumindest so genannt werden).  Daher beginne ich mit den allgemeinsten Worten darüber, warum Schlösser überhaupt benötigt werden, was sie sind und wie sie sich voneinander unterscheiden.  Dann werden wir sehen, was von dieser Sorte in PostgreSQL zu finden ist, und erst danach werden wir uns im Detail mit verschiedenen Arten von Sperren befassen. <br><a name="habracut"></a><br>  Sperren werden verwendet, um den gleichzeitigen Zugriff auf freigegebene Ressourcen zu optimieren. <br><br>  Wettbewerbszugriff bezieht sich auf den gleichzeitigen Zugriff mehrerer Prozesse.  Die Prozesse selbst können sowohl parallel (sofern das Gerät dies zulässt) als auch nacheinander im Time-Sharing-Modus ausgeführt werden - dies ist nicht wichtig. <br><br>  Wenn keine Konkurrenz besteht, sind keine Sperren erforderlich (z. B. erfordert ein gemeinsam genutzter Puffercache Sperren, ein lokaler jedoch nicht). <br><br>  Vor dem Zugriff auf eine Ressource muss ein Prozess die dieser Ressource zugeordnete Sperre erwerben.  Das heißt, wir sprechen von einer bestimmten Disziplin: Alles funktioniert, solange alle Prozesse den festgelegten Regeln für den Zugriff auf eine gemeinsam genutzte Ressource entsprechen.  Wenn das DBMS die Sperren verwaltet, überwacht es selbst die Reihenfolge.  Wenn die Sperrung durch den Antrag festgelegt wird, liegt diese Verpflichtung bei ihm. <br><br>  Auf einer niedrigen Ebene wird eine Sperre durch einen Abschnitt des gemeinsam genutzten Speichers dargestellt, in dem auf irgendeine Weise festgestellt wird, ob die Sperre frei oder erfasst ist (und möglicherweise zusätzliche Informationen aufgezeichnet werden: Prozessnummer, Erfassungszeit usw.). <br><br><blockquote>  Möglicherweise stellen Sie fest, dass ein solcher gemeinsam genutzter Speicher an sich eine Ressource ist, auf die ein wettbewerbsfähiger Zugriff möglich ist.  Wenn wir auf eine niedrigere Ebene gehen, werden wir sehen, dass spezielle Zusatzprimitive (wie Semaphore oder Mutexe), die vom Betriebssystem bereitgestellt werden, verwendet werden, um den Zugriff zu organisieren.  Ihre Bedeutung ist, dass der Code, der auf die gemeinsam genutzte Ressource zugreift, jeweils nur in einem Prozess ausgeführt werden sollte.  Auf der untersten Ebene werden diese Grundelemente basierend auf atomaren Prozessoranweisungen (wie Test-and-Set oder Compare-and-Swap) implementiert. <br></blockquote><br>  Nachdem die Ressource vom Prozess nicht mehr benötigt wird, <em>wird die</em> Sperre aufgehoben, damit andere Benutzer die Ressource verwenden können. <br><br>  Das Sperren der Sperre ist natürlich nicht immer möglich: Die Ressource wird möglicherweise bereits von einer anderen Person belegt.  Dann tritt der Prozess entweder in die Warteschlange ein (wenn der Sperrmechanismus diese Möglichkeit bietet) oder versucht erneut, die Sperre nach einer bestimmten Zeit zu erfassen.  Auf die eine oder andere Weise führt dies dazu, dass der Prozess gezwungen ist, im Vorgriff auf die Freigabe der Ressource untätig zu bleiben. <br><br><blockquote>  Manchmal ist es möglich, andere nicht blockierende Strategien anzuwenden.  Beispielsweise ermöglicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Multiversionsmechanismus</a> in einigen Fällen, dass mehrere Prozesse gleichzeitig mit verschiedenen Datenversionen arbeiten, ohne sich gegenseitig zu blockieren. <br></blockquote><br>  Im Prinzip kann eine geschützte Ressource alles sein, wenn nur diese Ressource eindeutig identifiziert und mit einer Sperradresse abgeglichen werden könnte. <br><br>  Die Ressource kann beispielsweise das Objekt sein, mit dem das DBMS arbeitet, z. B. eine Datenseite (identifiziert durch den Dateinamen und die Position in der Datei), eine Tabelle (oid im Systemverzeichnis), eine Tabellenzeile (Seite und Offset innerhalb der Seite).  Eine Ressource kann eine Struktur im Speicher sein, z. B. eine Hash-Tabelle, ein Puffer usw. (gekennzeichnet durch eine vorab zugewiesene Nummer).  Manchmal ist es sogar bequem, abstrakte Ressourcen zu verwenden, die keine physikalische Bedeutung haben (sie werden einfach durch eine eindeutige Nummer identifiziert). <br><br>  Die Wirksamkeit von Schlössern wird von vielen Faktoren beeinflusst, von denen wir zwei unterscheiden. <br><br><ul><li>  <strong>Granularität</strong> (Granularität) ist wichtig, wenn Ressourcen eine Hierarchie bilden. <br><br>  Eine Tabelle besteht beispielsweise aus Seiten, die Tabellenzeilen enthalten.  Alle diese Objekte können als Ressourcen fungieren.  Wenn Prozesse normalerweise nur an wenigen Zeilen interessiert sind und die Sperre auf Tabellenebene festgelegt ist, können andere Prozesse nicht gleichzeitig mit anderen Zeilen arbeiten.  Je höher die Granularität ist, desto besser ist daher die Möglichkeit einer Parallelisierung. <br><br>  Dies führt jedoch zu einer Erhöhung der Anzahl der Sperren (Informationen darüber müssen gespeichert werden).  In diesem Fall kann eine <em>Erhöhung der Ebene</em> (Eskalation) von Sperren angewendet werden: Wenn die Anzahl der granularen Sperren auf niedriger Ebene eine bestimmte Grenze überschreitet, werden sie durch eine Sperre auf einer höheren Ebene ersetzt. <br></li><li>  Sperren können in verschiedenen <strong>Modi</strong> erfasst <strong>werden</strong> . <br><br>  Die Namen der Modi können absolut willkürlich sein, nur die Matrix ihrer Kompatibilität untereinander ist wichtig.  Ein Modus, der mit keinem Modus (einschließlich mit sich selbst) kompatibel ist, wird normalerweise als <em>exklusiv</em> oder exklusiv bezeichnet.  Wenn die Modi kompatibel sind, kann die Sperre von mehreren Prozessen gleichzeitig erfasst werden.  Solche Modi werden als gemeinsam genutzt bezeichnet.  Im Allgemeinen werden umso mehr Möglichkeiten für Parallelität geschaffen, je mehr verschiedene Modi unterschieden werden können, die miteinander kompatibel sind. <br></li></ul><br>  Je nach Nutzungsdauer können Schlösser in lange und kurze Schlösser unterteilt werden. <br><br><ul><li>  <strong>Langzeitsperren</strong> werden für eine möglicherweise lange Zeit (normalerweise bis zum Ende der Transaktion) erfasst und beziehen sich meist auf Ressourcen wie Tabellen (Beziehungen) und Zeilen.  PostgreSQL verwaltet diese Sperren normalerweise automatisch, der Benutzer hat jedoch eine gewisse Kontrolle über diesen Prozess. <br><br>  Lange Sperren zeichnen sich durch eine Vielzahl von Modi aus, so dass möglichst viele gleichzeitige Aktionen an den Daten ausgeführt werden können.  Typischerweise gibt es für solche Sperren eine entwickelte Infrastruktur (z. B. Unterstützung von Warteschlangen und Erkennung von Deadlocks) und Überwachungstools, da die Kosten für die Wartung all dieser Annehmlichkeiten im Vergleich zu den Betriebskosten für geschützte Daten immer noch unvergleichlich niedriger sind. <br></li><li>  <strong>Kurzzeitsperren</strong> werden für kurze Zeit erfasst (von einigen Prozessoranweisungen bis zu Sekundenbruchteilen) und beziehen sich normalerweise auf Datenstrukturen im gemeinsam genutzten Speicher.  PostgreSQL verwaltet solche Sperren vollautomatisch - Sie müssen nur über ihre Existenz Bescheid wissen. <br><br>  Kurze Sperren zeichnen sich durch ein Minimum an Modi (exklusiv und gemeinsam genutzt) und eine einfache Infrastruktur aus.  In einigen Fällen sind möglicherweise nicht einmal Überwachungstools verfügbar. <br></li></ul><br>  PostgreSQL verwendet verschiedene Arten von Sperren. <br><br>  <strong>Sperren auf Objektebene</strong> sind langfristige „schwere“ <strong>Sperren</strong> .  Die Ressourcen hier sind Beziehungen und andere Objekte.  Wenn das Wort Blockierung ohne Klarstellung im Text erscheint, bedeutet dies eine solche „normale“ Blockierung. <br><br>  Bei Langzeitsperren fallen Sperren auf Zeilenebene separat auf.  Ihre Implementierung unterscheidet sich von anderen Langzeitsperren aufgrund ihrer potenziell großen Anzahl (stellen Sie sich vor, Sie aktualisieren eine Million Zeilen in einer Transaktion).  Solche Sperren werden im nächsten Artikel behandelt. <br><br>  Der dritte Artikel der Reihe befasst sich mit den verbleibenden Sperren auf Objektebene sowie mit <strong>Prädikatsperren</strong> (da Informationen zu all diesen Sperren auf dieselbe Weise im RAM gespeichert werden). <br><br>  Kurze Sperren umfassen verschiedene <strong>Sperren von RAM-Strukturen</strong> .  Wir werden sie im letzten Artikel des Zyklus betrachten. <br><br><h1>  Objekt sperrt </h1><br>  Wir beginnen also mit Sperren auf Objektebene.  Hier wird ein Objekt in erster Linie als <em>Relationen</em> verstanden, dh als Tabellen, Indizes, Sequenzen, materialisierte Darstellungen, aber auch als einige andere Entitäten.  Diese Sperren schützen Objekte normalerweise davor, gleichzeitig geändert zu werden oder während des Objektwechsels verwendet zu werden, aber auch für andere Zwecke. <br><br>  Verschwommene Formulierung?  Dies liegt daran, dass Sperren aus dieser Gruppe für eine Vielzahl von Zwecken verwendet werden.  Was sie verbindet, ist, wie sie angeordnet sind. <br><br><h2>  Gerät </h2><br>  Die Objektsperren befinden sich im gemeinsam genutzten Speicher des Servers.  Ihre Anzahl wird durch das Produkt der Werte zweier Parameter begrenzt: <em>max_locks_per_transaction</em> × <em>max_connections</em> . <br><br>  Der <em>Sperrpool</em> ist für alle Transaktionen gleich, <em>dh</em> eine Transaktion kann mehr Sperren erfassen als <em>max_locks_per_transaction</em> : Es ist nur wichtig, dass die Gesamtzahl der Sperren im System das festgelegte Limit nicht überschreitet.  Der Pool wird beim Start erstellt. Wenn Sie also eine der beiden angegebenen Optionen ändern, müssen Sie den Server neu starten. <br><br>  Alle Sperren können in der Ansicht pg_locks angezeigt werden. <br><br>  Wenn die Ressource bereits im inkompatiblen Modus gesperrt ist, wird eine Transaktion, die versucht, diese Ressource zu erfassen, in die Warteschlange gestellt und wartet auf die Freigabe der Sperre.  Ausstehende Transaktionen verbrauchen keine Prozessorressourcen: Die entsprechenden Serviceprozesse „schlafen ein“ und werden vom Betriebssystem aktiviert, wenn die Ressource freigegeben wird. <br><br>  Eine <em>Deadlock-</em> oder <em>Deadlock-</em> Situation ist möglich, in der für eine Transaktion eine von der zweiten Transaktion belegte Ressource erforderlich ist, um fortzufahren, und für die zweite eine von der ersten belegte Ressource erforderlich ist (im Allgemeinen können ein Deadlock und mehr als zwei Transaktionen auftreten).  In diesem Fall wird das Warten auf unbestimmte Zeit fortgesetzt, sodass PostgreSQL solche Situationen automatisch erkennt und eine der Transaktionen abbricht, damit andere weiterarbeiten können.  (Wir werden im nächsten Artikel mehr über Deadlocks sprechen.) <br><br><h2>  Objekttypen </h2><br>  Hier ist eine Liste der Arten von Sperren (oder, wenn Sie möchten, der Arten von Objekten), mit denen wir uns in diesem und im nächsten Artikel befassen werden.  Die Namen werden gemäß der Spalte locktype in der Ansicht pg_locks angegeben. <br><br><ul><li>  <strong>Beziehung</strong> <br><br>  Beziehungssperren. <br></li><li>  <strong>Transaktions-</strong> <strong>ID</strong> und <strong>VirtualXID</strong> <br><br>  Blockieren einer Transaktionsnummer (real oder virtuell).  Jede Transaktion selbst verfügt über eine exklusive Sperre mit einer eigenen Nummer. Daher können solche Sperren bequem verwendet werden, wenn Sie bis zum Ende einer anderen Transaktion warten müssen. <br></li><li>  <strong>Tupel</strong> <br><br>  String-Versionssperre.  In einigen Fällen wird es verwendet, um die Priorität für mehrere Transaktionen festzulegen, bei denen erwartet wird, dass dieselbe Zeile gesperrt wird. <br></li></ul><br>  Wir werden die Diskussion der verbleibenden Arten von Sperren auf den dritten Artikel im Zyklus verschieben.  Alle von ihnen werden entweder nur im Ausnahmemodus oder exklusiv und gemeinsam erfasst. <br><br><ul><li>  <strong>verlängern</strong> <br><br>  Wird verwendet, wenn einer Datei einer Beziehung Seiten hinzugefügt werden. <br></li><li>  <strong>Objekt</strong> <br><br>  Sperren von Objekten, die keine Beziehungen sind (Datenbanken, Schemas, Abonnements usw.). <br></li><li>  <strong>Seite</strong> <br><br>  Die Seitensperre wird selten und nur von einigen Arten von Indizes verwendet. <br></li><li>  <strong>Beratung</strong> <br><br>  Empfohlene Blockierung, vom Benutzer manuell eingestellt. <br></li></ul><br><h1>  Beziehungssperren </h1><br>  Um den Kontext nicht zu verlieren, werde ich auf einem solchen Bild die Arten von Schlössern markieren, auf die später noch eingegangen wird. <br><br><img src="https://habrastorage.org/webt/od/wc/ne/odwcnenfvjv_ikwmqw8x-vaexqi.png"><br><br><h2>  Modi </h2><br>  Wenn nicht das Wichtigste, dann sicherlich das „verzweigteste“ Blockieren - Blockieren von Beziehungen.  Für sie sind bis zu 8 verschiedene Modi definiert.  Eine solche Menge ist notwendig, damit die größtmögliche Anzahl von Befehlen, die zu einer Tabelle gehören, gleichzeitig ausgeführt werden kann. <br><br>  Es macht keinen Sinn, diese Modi auswendig zu lernen oder zu versuchen, die Bedeutung ihrer Namen zu verstehen.  Die Hauptsache ist, zur richtigen Zeit eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Matrix</a> vor Ihren Augen zu haben, die zeigt, welche Sperren miteinander in Konflikt stehen.  Der Einfachheit halber wird es hier zusammen mit Beispielen von Befehlen wiedergegeben, für die geeignete Sperrstufen erforderlich sind: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Sperrmodus </th><th>  Wie </th><th>  RS </th><th>  RE </th><th>  Sue </th><th>  S. </th><th>  SRE </th><th>  E. </th><th>  Ae </th><th>  Beispiel <nobr>SQL-Befehle</nobr> </th></tr><tr><td>  Zugriffsfreigabe </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X. </td><td>  AUSWÄHLEN </td></tr><tr><td>  Zeilenfreigabe </td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X. </td><td>  X. </td><td>  FÜR UPDATE / SHARE AUSWÄHLEN </td></tr><tr><td>  Zeile exklusiv </td><td></td><td></td><td></td><td></td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  INSERT, UPDATE, DELETE </td></tr><tr><td>  Update exklusiv teilen </td><td></td><td></td><td></td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  VAKUUM, ALTER TABELLE <sup>*</sup> , INDEX KONZURRENT ERSTELLEN </td></tr><tr><td>  Teilen </td><td></td><td></td><td>  X. </td><td>  X. </td><td></td><td>  X. </td><td>  X. </td><td>  X. </td><td>  INDEX ERSTELLEN </td></tr><tr><td>  Zeile exklusiv teilen </td><td></td><td></td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  TRIGGER ERSTELLEN, TABELLE ÄNDERN <sup>*</sup> </td></tr><tr><td>  Exklusiv </td><td></td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  REFRESH MAT.  KONZURRENT ANZEIGEN </td></tr><tr><td>  Zugriff exklusiv </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  DROP, TRUNCATE, VACUUM FULL, LOCK TABLE, ALTER TABLE <sup>*</sup> , REFRESH MAT.  ANSICHT </td></tr></tbody></table></div><br>  Einige Kommentare: <br><br><ul><li>  Die ersten 4 Modi ermöglichen gleichzeitige Datenänderungen in der Tabelle, die nächsten 4 nicht. </li><li>  Der erste Modus (Access Share) ist der schwächste und mit allen anderen als dem letzten kompatibel (Access Exclusive).  Dieser letzte Modus ist exklusiv und mit keinem Modus kompatibel. </li><li>  Der Befehl ALTER TABLE verfügt über viele Optionen, für die unterschiedliche Sperrstufen erforderlich sind.  Daher wird dieser Befehl in der Matrix in verschiedenen Zeilen angezeigt und mit einem Sternchen markiert. </li></ul><br><h2>  Zum Beispiel </h2><br>  Geben Sie ein Beispiel.  Was passiert, wenn ich den Befehl CREATE INDEX ausführe? <br><br>  In der Dokumentation finden wir, dass dieser Befehl die Sperre in den Freigabemodus setzt.  Gemäß der Matrix stellen wir fest, dass der Befehl mit sich selbst (dh Sie können gleichzeitig mehrere Indizes erstellen) und mit Lesebefehlen kompatibel ist.  Somit funktionieren die SELECT-Befehle weiterhin, aber die UPDATE-, DELETE- und INSERT-Befehle werden blockiert. <br><br>  Und umgekehrt - unvollständige Transaktionen, die Daten in der Tabelle ändern, blockieren die Operation des Befehls CREATE INDEX.  Daher gibt es eine Variante des Befehls - INDEX CONCURRENTLY ERSTELLEN.  Es funktioniert länger (und kann sogar fehlerhaft sein), ermöglicht jedoch gleichzeitige Datenänderungen. <br><br>  Dies kann in der Praxis gesehen werden.  Für Experimente verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Zyklus</a> bekannte Tabelle der Bankkonten, in der wir die Kontonummer und den Betrag speichern. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( acc_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3000.00</span></span>);</code> </pre> <br>  Starten Sie in der zweiten Sitzung die Transaktion.  Wir benötigen eine Serviceprozessnummer. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| pg_backend_pid | ---------------- | 4746 | (1 row)</code> </pre><br>  Welche Sperren hält die neu gestartete Transaktion?  Wir schauen in pg_locks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">REGCLASS</span></span>, virtualxid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> virtxid, transactionid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">4746</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ------------+----------+---------+-----+---------------+--------- virtualxid | | 5/15 | | ExclusiveLock | t (1 row)</code> </pre><br>  Wie ich bereits sagte, enthält eine Transaktion immer eine exklusive (ExclusiveLock) Sperre ihrer eigenen Nummer, in diesem Fall eine virtuelle.  Es gibt keine weiteren Sperren für diesen Prozess. <br><br>  Aktualisieren Sie nun die Tabellenzeile.  Wie wird sich die Situation ändern? <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ---------------+---------------+---------+--------+------------------+--------- relation | accounts_pkey | | | RowExclusiveLock | t relation | accounts | | | RowExclusiveLock | t virtualxid | | 5/15 | | ExclusiveLock | t transactionid | | | 529404 | ExclusiveLock | t (4 rows)</code> </pre><br>  Jetzt gibt es Sperren für die veränderbare Tabelle und den Index (erstellt für den Primärschlüssel), die vom Befehl UPDATE verwendet werden.  Beide Sperren werden im RowExclusiveLock-Modus ausgeführt.  Zusätzlich wurde eine exklusive Sperrung der realen Transaktionsnummer hinzugefügt (die angezeigt wurde, sobald die Transaktion begann, Daten zu ändern). <br><br>  In einer anderen Sitzung versuchen wir nun, einen Index für eine Tabelle zu erstellen. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| pg_backend_pid || ---------------- || 4782 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> accounts(acc_no);</code> </pre><br>  Der Befehl friert in Erwartung der Freigabe der Ressource ein.  Welche Art von Schloss versucht sie zu erobern?  Überprüfen Sie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">REGCLASS</span></span>, virtualxid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> virtxid, transactionid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">4782</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ------------+----------+---------+-----+---------------+--------- virtualxid | | 6/15 | | ExclusiveLock | t relation | accounts | | | ShareLock | f (2 rows)</code> </pre><br>  Wir sehen, dass die Transaktion versucht, die Tabellensperre im ShareLock-Modus zu erhalten, dies jedoch nicht kann (gewährt = f). <br><br>  Es ist praktisch, die Nummer des Blockierungsprozesses und im Allgemeinen mehrere Nummern mithilfe der in Version 9.6 angegebenen Funktion zu ermitteln (zuvor musste ich Schlussfolgerungen ziehen, indem ich den gesamten Inhalt von pg_locks sorgfältig betrachtete): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_blocking_pids(<span class="hljs-number"><span class="hljs-number">4782</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_blocking_pids ------------------ {4746} (1 row)</code> </pre><br>  Um die Situation zu verstehen, können Sie Informationen zu den Sitzungen abrufen, einschließlich der gefundenen Zahlen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-keyword"><span class="hljs-keyword">ANY</span></span>(pg_blocking_pids(<span class="hljs-number"><span class="hljs-number">4782</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+------------------------------------------------------------ datid | 16386 datname | test pid | 4746 usesysid | 16384 usename | student application_name | psql client_addr | client_hostname | client_port | -1 backend_start | 2019-08-07 15:02:53.811842+03 xact_start | 2019-08-07 15:02:54.090672+03 query_start | 2019-08-07 15:02:54.10621+03 state_change | 2019-08-07 15:02:54.106965+03 wait_event_type | Client wait_event | ClientRead state | idle in transaction backend_xid | 529404 backend_xmin | query | UPDATE accounts SET amount = amount + 100 WHERE acc_no = 1; backend_type | client backend</code> </pre><br>  Nach Abschluss der Transaktion werden die Sperren aufgehoben und der Index erstellt. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br><pre> <code class="plaintext hljs">|| CREATE INDEX</code> </pre><br><h2>  In der Warteschlange! .. </h2><br>  Um sich besser vorstellen zu können, wozu das Auftreten einer inkompatiblen Sperre führt, werden wir sehen, was passiert, wenn der Befehl VACUUM FULL während des Systembetriebs ausgeführt wird. <br><br>  Lassen Sie den Befehl SELECT zuerst in unserer Tabelle ausgeführt werden.  Sie erhält eine Sperre für die schwächste Stufe von Access Share.  Um die Freigabezeit der Sperre zu steuern, führen wir diesen Befehl innerhalb der Transaktion aus. Bis zum Ende der Transaktion wird die Sperre nicht freigegeben.  In der Realität können mehrere Befehle die Tabelle lesen (und ändern), und einige der Abfragen können eine Weile dauern. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> acc_no | amount --------+--------- 2 | 2000.00 3 | 3000.00 1 | 1100.00 (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+-----------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} (1 row)</code> </pre><br>  Anschließend führt der Administrator den Befehl VACUUM FULL aus, für den eine Zugriffssperrung auf exklusiver Ebene erforderlich ist, die auch mit Access Share nicht kompatibel ist.  (Der Befehl LOCK TABLE erfordert ebenfalls dieselbe Sperre.) Die Transaktionswarteschlangen. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">LOCK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">--  VACUUM FULL</span></span></code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} relation | AccessExclusiveLock | f | 4746 | {4710} (2 rows)</code> </pre><br>  Die Anwendung gibt jedoch weiterhin Anforderungen aus, und jetzt wird der Befehl SELECT im System angezeigt.  Rein theoretisch hätte sie "ausrutschen" können, während VACUUM FULL wartet, aber nein - sie nimmt ehrlich gesagt einen Platz in der Warteschlange für VACUUM FULL ein. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} relation | AccessExclusiveLock | f | 4746 | {4710} relation | AccessShareLock | f | 4782 | {4746} (3 rows)</code> </pre><br>  Nachdem die erste Transaktion mit dem Befehl SELECT abgeschlossen und die Sperre aufgehoben wurde, beginnt der Befehl VACUUM FULL (den wir mit dem Befehl LOCK TABLE simuliert haben). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><br><pre> <code class="plaintext hljs">| LOCK TABLE</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessExclusiveLock | t | 4746 | {} relation | AccessShareLock | f | 4782 | {4746} (2 rows)</code> </pre><br>  Und erst wenn VACUUM FULL seine Arbeit abgeschlossen und die Sperre aufgehoben hat, können alle in der Warteschlange gesammelten Befehle (in unserem Beispiel SELECT) die entsprechenden Sperren erfassen (Access Share) und ausführen. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br><pre> <code class="plaintext hljs">|| acc_no | amount || --------+--------- || 2 | 2000.00 || 3 | 3000.00 || 1 | 1100.00 || (3 rows)</code> </pre><br>  Somit kann ein ungenauer Befehl den Betrieb des Systems für eine Zeit lähmen, die erheblich länger ist als die Ausführungszeit des Befehls selbst. <br><br><h1>  Überwachungstools </h1><br>  Natürlich sind Schlösser für den korrekten Betrieb notwendig, können aber zu unerwünschten Erwartungen führen.  Solche Erwartungen können überwacht werden, um ihre Ursache zu verstehen und wenn möglich zu beseitigen (z. B. durch Ändern des Anwendungsalgorithmus). <br><br>  Wir haben bereits eine Möglichkeit kennengelernt: Im Moment einer langen Sperre können wir eine Anforderung an die Ansicht pg_locks ausführen, die sperrbaren und blockierenden Transaktionen (Funktion pg_blocking_pids) anzeigen und sie mit pg_stat_activity entschlüsseln. <br><br>  Eine andere Möglichkeit besteht darin, den Parameter <em>log_lock_waits</em> zu aktivieren.  In diesem Fall werden Informationen im Nachrichtenprotokoll des Servers angezeigt, wenn die Transaktion länger als <em>deadlock_timeout</em> gewartet hat (obwohl der Parameter für Deadlocks verwendet wird, handelt es sich um normale Erwartungen). <br><br>  Lass es uns versuchen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_lock_waits = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Der Standardparameterwert für <em>deadlock_timeout</em> beträgt eine Sekunde: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> deadlock_timeout;</code> </pre><pre> <code class="plaintext hljs"> deadlock_timeout ------------------ 1s (1 row)</code> </pre><br>  Spielen Sie das Schloss. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">UPDATE 1</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Der zweite UPDATE-Befehl erwartet eine Sperre.  Warten Sie eine Sekunde und schließen Sie die erste Transaktion ab. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><br>  Jetzt kann die zweite Transaktion abgeschlossen werden. <br><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br>  Und alle wichtigen Informationen kamen ins Tagebuch: <br><br><pre> <code class="plaintext hljs">postgres$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-08-07 15:26:30.827 MSK [5898] student@test LOG: process 5898 still waiting for ShareLock on transaction 529427 after 1000.186 ms 2019-08-07 15:26:30.827 MSK [5898] student@test DETAIL: Process holding the lock: 5862. Wait queue: 5898. 2019-08-07 15:26:30.827 MSK [5898] student@test CONTEXT: while updating tuple (0,4) in relation "accounts" 2019-08-07 15:26:30.827 MSK [5898] student@test STATEMENT: UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;</code> </pre><pre> <code class="plaintext hljs">2019-08-07 15:26:30.836 MSK [5898] student@test LOG: process 5898 acquired ShareLock on transaction 529427 after 1009.536 ms 2019-08-07 15:26:30.836 MSK [5898] student@test CONTEXT: while updating tuple (0,4) in relation "accounts" 2019-08-07 15:26:30.836 MSK [5898] student@test STATEMENT: UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462877/">https://habr.com/ru/post/de462877/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462859/index.html">Wie ein europäisches Busunternehmen in Russland operiert: Wie unterscheiden sich Busse und Fahrgäste?</a></li>
<li><a href="../de462863/index.html">21. August Sendung Zabbix Moscow Meetup # 5</a></li>
<li><a href="../de462867/index.html">Auswählen eines Farbschemas für Ihre App: Wie machen Sie es einfach?</a></li>
<li><a href="../de462869/index.html">Agileanisches Projektmanagementsystem</a></li>
<li><a href="../de462875/index.html">So senken Sie Kosten und bieten optimalen IT-Support für das Geschäftsmodell. Wir suchen den „mittleren Weg der Erlösung“</a></li>
<li><a href="../de462879/index.html">Slurm DevOps: von Git bis SRE mit allen Register</a></li>
<li><a href="../de462881/index.html">Warum ist es so schwierig zu entscheiden, welchen Film man sehen möchte (und was getan werden könnte)?</a></li>
<li><a href="../de462883/index.html">Entwerfen eines Online-Shops für SEO: (Theorie + Checkliste)</a></li>
<li><a href="../de462885/index.html">Fehlertolerantes IPoE-Netzwerk zur Hand</a></li>
<li><a href="../de462887/index.html">Die Erfahrung der Personalisierung eines Online-Shops am Beispiel einer dynamischen Empfehlung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>