<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÉ ü§öüèø üõ¨ Das Interessanteste in PHP 8 üéê üöº üèÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PHP 7.4 wurde gerade f√ºr stabil erkl√§rt und wir haben bereits weitere Verbesserungen vorgelegt. Und das Beste daran, worauf PHP wartet, ist Dmitry Sto...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Interessanteste in PHP 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/481092/">  PHP 7.4 wurde gerade f√ºr stabil erkl√§rt und wir haben bereits weitere Verbesserungen vorgelegt.  Und das Beste daran, worauf PHP wartet, ist Dmitry Stogov - einer der f√ºhrenden Entwickler von Open Source PHP und wahrscheinlich der √§lteste aktive Mitwirkende. <br><br>  In allen Berichten von Dmitry geht es nur um die Technologien und L√∂sungen, an denen er pers√∂nlich arbeitet.  In den besten Traditionen von Ontiko, unter dem Schnitt, eine Textversion der <a href="https://youtu.be/7UOWus-5yxg">Geschichte</a> √ºber die interessantesten aus der Sicht von Dmitry Innovationen von PHP 8, die neue Anwendungsf√§lle er√∂ffnen k√∂nnen.  Zuallererst JIT und FFI - nicht in den Schl√ºssel der ‚Äûerstaunlichen Aussichten‚Äú, sondern mit Implementierungsdetails und Fallstricken. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h9/o1/xd/h9o1xdb-wntc2xl0eipeb4bd7du.png" width="500"></div><br>  <i>Als Referenz:</i> Dmitry Stogov lernte die Programmierung 1984 kennen, als nicht alle Leser geboren wurden, und konnte einen bedeutenden Beitrag zur Entwicklung von Entwicklungswerkzeugen und insbesondere PHP leisten (obwohl Dmitry die PHP-Leistung nicht speziell f√ºr russische Entwickler verbessert, <a href="https://habr.com/ru/company/oleg-bunin/blog/477426/">√§u√üerten</a> sie <a href="https://habr.com/ru/company/oleg-bunin/blog/477426/">sich</a> Mein Dank geht an den HighLoad ++ Award.  Dmitry ist der Autor von Turck MMCache f√ºr PHP (eAccelerator), Zend OPcache-Betreuer, Leiter des PHPNG-Projekts, das die Basis von PHP 7 bildete, und Leiter der Entwicklung von JIT f√ºr PHP. <br><a name="habracut"></a><br><h2>  PHP-Performance-Entwicklung </h2><br>  Ich habe vor 15 Jahren angefangen, an PHP-Performance zu arbeiten, als ich zu Zend kam.  Dann haben wir Version 5.0 ver√∂ffentlicht - die erste, in der die Sprache wirklich objektorientiert wurde.  Seitdem konnten wir die Leistung bei synthetischen Tests um das 40-fache und bei realen Anwendungen um das 6-fache verbessern. <br><br><img src="https://habrastorage.org/webt/xp/gc/xe/xpgcxedjqqy7_ay7vzrocx2cl3y.jpeg"><br><br>  In dieser Zeit gab es zwei Durchbruchsmomente: <br><br><ul><li>  Version 5.1, mit der wir die Interpretationsgeschwindigkeit deutlich steigern konnten.  Wir haben einen spezialisierten Dolmetscher implementiert, der sich haupts√§chlich auf die synthetischen Tests auswirkte. </li><li>  Version 7.0, in der alle wichtigen Datenstrukturen verarbeitet und damit die Arbeit mit Speicher und Prozessor-Cache optimiert wurden (mehr zu diesen Optimierungen <a href="https://habr.com/ru/company/oleg-bunin/blog/444508/">hier</a> ).  Dies f√ºhrte sowohl in synthetischen Tests als auch in realen Anwendungen zu einer mehr als zweifachen Beschleunigung. </li></ul><br>  Bei allen anderen Versionen wurde die Produktivit√§t schrittweise gesteigert, indem viele weniger effektive Ideen umgesetzt wurden.  In Version 7.1 wurde beispielsweise viel Wert auf die Optimierung des Bytecodes gelegt ( <a href="https://habr.com/ru/company/oleg-bunin/blog/445512/">ein Artikel</a> zu diesen L√∂sungen). <br><br>  Das Diagramm zeigt, dass wir sowohl am Ende der Entwicklung der 5. Version als auch am Ende des Entwicklungszyklus der 7. Version auf ein Plateau gehen und langsamer werden.  Im letzten Jahr der Arbeit an v7.4 wurde daher nur eine Produktivit√§tssteigerung von 2% erzielt.  Und das ist nicht schlecht, weil neue Funktionen wie typisierte Eigenschaften und kovariante Typen aufgetaucht sind, die PHP verlangsamen (Nikita Popov <a href="https://youtu.be/teKnckg5x7I">sprach</a> √ºber diese neuen Produkte in PHP Russland). <br><br>  Und jetzt wundert sich jeder, was von der 8. Version zu erwarten ist. Kann sie den Erfolg von v7 wiederholen? <br><br><h3>  JIT oder nicht JIT </h3><br>  Die Ideen zur Verbesserung des Dolmetschers sind noch nicht ausgesch√∂pft, aber alle erfordern eine sehr gr√ºndliche Untersuchung.  Viele von ihnen m√ºssen im Stadium des Proof-of-Concept abgelehnt werden, da sich herausstellt, dass der erzielbare Gewinn mit der Komplikation oder den auferlegten technischen Einschr√§nkungen nicht vereinbar ist. <br><br>  Es bleibt jedoch Hoffnung auf eine neue bahnbrechende Technologie - nat√ºrlich erinnere ich mich an die JIT und die Erfolgsgeschichte von JavaScript-Engines. <br><br>  Tats√§chlich wird seit 2012 an JIT f√ºr PHP gearbeitet.  Es gab drei oder vier Implementierungen, wir arbeiteten mit Intel-Kollegen und JavaScript-Hackern zusammen, aber irgendwie war es nicht m√∂glich, JIT in den Hauptzweig aufzunehmen.  Letztendlich haben wir in PHP 8 JIT in den Compiler aufgenommen und eine doppelte Beschleunigung festgestellt, jedoch nur bei synthetischen Tests, im Gegenteil bei realen Anwendungen. <br><br><img src="https://habrastorage.org/webt/no/ly/58/noly58x1blcmkwv80nd8n60yu3q.jpeg"><br><br>  Das ist nat√ºrlich nicht das, wonach wir streben. <br><br>  Was ist los  Vielleicht machen wir etwas falsch, vielleicht ist WordPress so schlecht und kein JIT wird ihm helfen (ja, eigentlich ist es das).  Vielleicht haben wir den Interpreter schon zu gut gemacht, aber in JavaScript ist es schlimmer.  In Rechentests ist dies wahr: <strong>Der PHP-Interpreter ist einer der besten</strong> . <br><br><img src="https://habrastorage.org/webt/fi/ya/lc/fiyalccpg18n2aieqgj7bmy-nho.jpeg"><br><br>  Beim Mandelbrot-Test √ºberholt er sogar Juwelen wie LuaJIT, einen in Assemblersprache geschriebenen Dolmetscher.  In diesem Test sind wir nur viermal hinter dem optimierenden GCC-5.3-Compiler zur√ºck.  Mit JIT konnten wir im Mandelbrot-Test bessere Ergebnisse erzielen.  Tats√§chlich tun wir dies bereits, das hei√üt, wir k√∂nnen Code generieren, der mit dem C-Compiler konkurriert. <br><br>  Warum k√∂nnen wir dann reale Anwendungen nicht beschleunigen?  Zum besseren Verst√§ndnis erkl√§re ich Ihnen, wie wir JIT durchf√ºhren.  Beginnen wir mit den Grundlagen. <br><br><h3>  So funktioniert PHP </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r3/u7/zz/r3u7zzdgmpo37fihs44l6jl29wq.jpeg" width="300"></div><br>  Der Server akzeptiert die Anforderung, kompiliert sie in Bytecode, der wiederum zur Ausf√ºhrung an die virtuelle Maschine gesendet wird.  Durch die Ausf√ºhrung des Bytecodes kann die virtuelle Maschine auch andere PHP-Dateien aufrufen, die erneut in Bytecode √ºbersetzt und erneut ausgef√ºhrt werden. <br><br>  Nach Abschluss der Abfrage werden alle diesbez√ºglichen Informationen, einschlie√ülich des Bytecodes, aus dem Speicher gel√∂scht.  Das hei√üt, jedes PHP-Skript muss bei jeder Anforderung erneut kompiliert werden.  Nat√ºrlich ist es einfach unm√∂glich, die JIT-Kompilierung in ein solches Schema einzubetten, da der Compiler sehr schnell sein muss. <br><br>  Aber h√∂chstwahrscheinlich benutzt niemand PHP in seiner blo√üen Form, jeder benutzt es mit OPcache. <br><br><h3>  PHP + OPcache </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w4/cg/wr/w4cgwrta9e7mdka4mzsylnfzbqa.jpeg" width="484"></div><br>  Das Hauptziel von OPcache ist es, das Neukompilieren von Skripten bei jeder Anforderung zu vermeiden.  Es ist in einen speziell daf√ºr entwickelten Punkt eingebettet, f√§ngt alle Kompilierungsanforderungen ab und speichert den kompilierten Bytecode im gemeinsamen Speicher. <br><br>  Gleichzeitig wird nicht nur die Kompilierungszeit, sondern auch der Speicherplatz gespart, da zuvor im Adressraum jedes Prozesses Bytecode-Speicher zugewiesen wurde und dieser jetzt in einer einzigen Kopie vorhanden ist. <br><br>  Sie k√∂nnen JIT bereits in diese Schaltung einbetten, was wir tun werden.  Aber zuerst zeige ich Ihnen, wie der Dolmetscher funktioniert. <br><br><img src="https://habrastorage.org/webt/jt/d5/50/jtd550mfh4al9klurcdde6yfzce.jpeg"><br><br>  Ein Interpreter ist zuallererst eine Schleife, die f√ºr jede Anweisung einen eigenen Handler aufruft. <br><br>  Wir verwenden zwei Register: <br><br><ul><li>  execute_data - Zeiger auf den aktuellen Aktivierungsrahmen; </li><li>  opline - Zeiger auf die aktuelle ausf√ºhrbare virtuelle Anweisung. </li></ul><br>  Mit der Erweiterung gcc werden diese beiden Registertypen auf reale Hardwareregister abgebildet, und aufgrund dessen arbeiten sie sehr schnell. <br><br>  In der Schleife rufen wir einfach den Handler f√ºr jede Anweisung auf, wonach wir am Ende jeder Prozedur den Zeiger auf die n√§chste Anweisung bewegen. <br><br>  Es ist wichtig zu beachten, dass die Adresse des Handlers direkt in den Bytecode geschrieben wird.  Es kann mehrere verschiedene Handler f√ºr eine einzelne Anweisung geben.  Dies wurde urspr√ºnglich zur Spezialisierung erfunden, damit sich Handler auf Operandentypen spezialisieren k√∂nnen.  Dieselbe Technologie wird f√ºr JIT verwendet, denn wenn Sie die Adresse als Handler in den neu generierten Code schreiben, werden JIT-Handler ohne √Ñnderungen im Interpreter gestartet. <br><br>  Im obigen Beispiel ist der f√ºr die Additionsanweisung geschriebene Handler rechts dargestellt.  Es werden Operanden ben√∂tigt (hier k√∂nnen die erste und die zweite Variable eine Konstante, eine tempor√§re oder eine lokale Variable sein), Operanden gelesen, Typen √ºberpr√ºft, eine direkte Logik erzeugt - Addition - und dann zur Schleife zur√ºckgekehrt, die die Steuerung an den n√§chsten Handler √ºbergibt. <br><br>  Aus dieser Beschreibung werden spezielle Funktionen generiert.  Da es drei m√∂gliche erste Operanden gab, drei m√∂gliche zweite, erhalten wir 9 verschiedene Funktionen. <br><br><img src="https://habrastorage.org/webt/sx/ac/ud/sxacudlzwpaetj0jdqlj-n-udqm.jpeg"><br><br>  In diesen Funktionen werden anstelle universeller Methoden zum Abrufen von Operanden bestimmte Methoden verwendet, die keine Pr√ºfungen durchf√ºhren. <br><br><h3>  Hybrid Virtual Machine </h3><br>  Eine weitere Komplikation, die wir in Version 7.2 gemacht haben, ist die sogenannte hybride virtuelle Maschine. <br><br>  Wenn wir den Handler fr√ºher immer √ºber einen indirekten Aufruf direkt in der Interpreter-Schleife aufgerufen haben, haben wir jetzt f√ºr jeden Handler zus√§tzlich ein Label in den Rumpf der Schleife eingetragen, zu dem wir √ºber den indirekten Sprung springen und den Handler selbst direkt aufrufen. <br><br><img src="https://habrastorage.org/webt/ym/ve/1r/ymve1rgaxks_48lgcgt_m2zf3xm.jpeg"><br><br>  Fr√ºher schienen sie einen indirekten Anruf zu t√§tigen, jetzt zwei: einen indirekten √úbergang und einen direkten Anruf, und ein solches System sollte langsamer arbeiten.  Tats√§chlich funktioniert es jedoch schneller, da wir dem Prozessor helfen, √úberg√§nge vorherzusagen.  Zuvor gab es einen Punkt, von dem aus der √úbergang zu verschiedenen Orten durchgef√ºhrt wurde.  Der Prozessor hat sich oft geirrt, weil er sich einfach nicht erinnern konnte, dass es notwendig war, zuerst auf einen Befehl zu springen, dann auf einen anderen.  Nach jedem direkten Aufruf erfolgt nun ein indirekter √úbergang zum n√§chsten Label.  Wenn die PHP-Schleife ausgef√ºhrt wird, sind die virtuellen PHP-Anweisungen daher in stabilen Sequenzen angeordnet, die dann fast linear ausgef√ºhrt werden. <br><br>  Die hybride virtuelle Maschine konnte die Produktivit√§t um weitere 5-10% steigern. <br><br><h3>  PHP + OPcache + JIT </h3><br>  JIT wird als Teil von OPcache implementiert. <br><br><img src="https://habrastorage.org/webt/ye/ad/ad/yeadadf8b-tvejykkpdgpf3pacq.jpeg"><br><br>  Nachdem der Bytecode kompiliert und optimiert wurde, wird ein JIT-Compiler daf√ºr gestartet, der nicht mehr mit dem Quellcode funktioniert.  Aus dem PHP-Bytecode generiert der JIT-Compiler nativen Code, wonach die Adresse des ersten Befehls (eigentlich die Funktion) im Bytecode ge√§ndert wird. <br><br>  Danach wird der native, bereits generierte Code unver√§ndert vom vorhandenen Interpreter aufgerufen.  Ich zeige Ihnen ein einfaches Beispiel. <br><br><img src="https://habrastorage.org/webt/y8/zs/jz/y8zsjz7rzbiuvct-l146whbcotw.jpeg"><br><br>  Links ist eine bestimmte Funktion in PHP geschrieben, die die Summe der Zahlen von 0 bis 100 z√§hlt. Rechts der generierte Bytecode.  Der erste Befehl weist der Summe 0 zu, der zweite macht dasselbe f√ºr i und dann einen unbedingten Sprung zum Label.  Auf dem Etikett L1 wird die Bedingung zum Verlassen des Zyklus √ºberpr√ºft: Wenn sie erf√ºllt ist, verlassen Sie den Zyklus, wenn nicht, gehen Sie zum Zyklus.  Addiere als n√§chstes die Summe i, schreibe das Ergebnis in den Betrag und erh√∂he i um 1. <br><br>  Direkt von hier aus generieren wir Assembler-Code, der sich als ziemlich gut herausstellt. <br><br><img src="https://habrastorage.org/webt/_g/q2/8b/_gq28bxpchqg3bc5duu7tysvpsq.jpeg"><br><br>  Die erste <code>QM_ASSIGN</code> Anweisung <code>QM_ASSIGN</code> in nur zwei Maschinenanweisungen (2-3 Zeilen) kompiliert.  Das <code>%esi</code> Register enth√§lt einen Zeiger auf den aktuellen Aktivierungsrahmen.  Bei Versatz 30 liegt ein variabler Betrag.  Der erste Befehl schreibt den Wert 0, der zweite 4 - dies ist ein Bezeichner eines Integer-Typs ( <code>IS_LONG</code> ).  F√ºr die Variable <code>i</code> Compiler erkannt, dass sie immer lang ist und es nicht erforderlich ist, den Typ zu speichern.  Dar√ºber hinaus kann es in einem Maschinenregister gespeichert werden.  Daher ist hier einfach XOR des Registers bei sich die einfachste und billigste Anweisung zum Zur√ºcksetzen. <br><br>  Dann √ºberpr√ºfen wir auf die gleiche Weise, einen bedingungslosen √úbergang, ob ein externes Ereignis aufgetreten ist, wir √ºberpr√ºfen den Zustand des Zyklus, wir gehen in den Zyklus.  In der Schleife wird gepr√ºft, ob die Summe eine Ganzzahl ist: Wenn ja, lesen wir den Ganzzahlwert, addieren den Wert i dazu, pr√ºfen, ob ein √úberlauf <code>%edx</code> , schreiben das Ergebnis zur√ºck in die Summe und addieren 1 zu <code>%edx</code> . <br><br>  Es ist zu sehen, dass der Code nahezu optimal ist.  Es w√§re m√∂glich, es noch weiter zu optimieren und die Summe f√ºr den Typ bei jeder Iteration der Schleife nicht mehr zu √ºberpr√ºfen.  Dies ist aber schon ziemlich umst√§ndlich, eine solche Optimierung machen wir noch nicht.  <strong>Wir entwickeln JIT als relativ einfache Technologie</strong> . Wir versuchen nicht, das zu tun, was Java HotSpot versucht, V8 - wir haben weniger Leistung. <br><br><h2>  Was ist los mit jit </h2><br>  Warum k√∂nnen wir mit einem so guten Assembler-Code keine echten Anwendungen beschleunigen? <br><br>  Eigentlich sollten sie? <br><br><ul><li>  Wenn der Engpass nicht in der CPU liegt, hilft JIT nicht. </li><li>  Es wird zu viel Code generiert (Code bloat). </li><li>  Statische Typinferenz funktioniert nicht immer. </li><li>  Ehrlicher Code (f√ºr F√§lle, die niemals ausgef√ºhrt werden). </li><li>  Unterst√ºtzung f√ºr den konsistenten Status der virtuellen Maschine (und pl√∂tzlich eine Ausnahme). </li><li>  Klassen leben nur f√ºr eine Anfrage. </li></ul><br>  Wenn die Anwendung 80% der Zeit auf eine Antwort aus der Datenbank wartet, hilft JIT nicht.  Wenn wir externe ressourcenintensive Funktionen aufrufen, zum Beispiel Matching mit einem regul√§ren Ausdruck, ruft JIT dieselben Funktionen auf dieselbe Weise auf.  Wenn eine Anwendung gro√üe Datenstrukturen erstellt - B√§ume, Diagramme und diese dann gelesen werden, generieren wir mit JIT Code, der weniger Anweisungen einliest. Das Laden der Daten selbst dauert jedoch genauso lange Sie m√ºssen auch den Code laden. <br><br>  Wie Sie bereits gesehen haben, kann JIT eine echte Anwendung sogar verlangsamen, da sie viel Code generiert und das Lesen zu einem Problem wird. Wenn Sie gro√üe Mengen Code lesen, werden andere Daten aus dem Cache entfernt, was zu einer Verlangsamung f√ºhrt. <br><br><h2>  Bescheidene Pl√§ne f√ºr PHP 8 </h2><br>  Eine der Verbesserungen, die wir in PHP 8 erreichen wollen, ist, <strong>weniger Code</strong> zu <strong>generieren</strong> .  Jetzt generieren wir, wie gesagt, systemeigenen Code f√ºr das gesamte Skript, den wir beim Laden laden.  Aber die H√§lfte der Funktionen wird sicherlich nicht aufgerufen.  Also sind wir noch einen Schritt weiter gegangen und haben einen Ausl√∂ser eingef√ºhrt, mit dem wir konfigurieren k√∂nnen, wann JIT ausgef√ºhrt werden soll.  Es kann ausgef√ºhrt werden: <br><br><ul><li>  f√ºr alle Funktionen; </li><li>  Nur f√ºr Funktionen, wenn sie zum ersten Mal aufgerufen werden. </li><li>  Sie k√∂nnen jeder Funktion einen Z√§hler hinzuf√ºgen und nur die Funktionen kompilieren, die wirklich aktuell sind. </li></ul><br>  Ein solches Schema funktioniert vielleicht etwas besser, ist aber immer noch nicht optimal, da es in jeder Funktion Pfade gibt, die ausgef√ºhrt werden, und Pfade, die niemals ausgef√ºhrt werden.  Da PHP eine dynamische Programmiersprache ist, dh jede Variable unterschiedliche Typen haben kann, m√ºssen Sie alle Typen unterst√ºtzen, die der statische Analysator vorhersagt.  Und er tut dies oft mit Vorsicht, wenn er nicht beweisen konnte, dass der andere Typ es nicht konnte. <br><br>  <strong>Unter diesen Umst√§nden werden wir uns von der ehrlichen Zusammenstellung verabschieden und beginnen, dies spekulativ zu tun.</strong> <br><br><img src="https://habrastorage.org/webt/cf/fu/2z/cffu2zfla_l00cqpouzm-ldteoi.jpeg"><br><br>  In Zukunft planen wir zun√§chst, die "hei√üesten" Funktionen f√ºr einige Zeit w√§hrend der Arbeit der Anwendung zu analysieren, die Pfade des Programms zu untersuchen, welche Arten von Variablen es sind, vielleicht sogar die Randbedingungen zu ber√ºcksichtigen und erst dann den f√ºr den Strom optimalen Funktionscode zu generieren Ausf√ºhrungsweise - nur f√ºr die Abschnitte, die tats√§chlich ausgef√ºhrt werden. <br><br>  F√ºr alles andere werden wir Stubs setzen.  Trotzdem wird es √úberpr√ºfungen und m√∂gliche Ausgaben geben, bei denen der Deoptimierungsprozess beginnt, dh wir werden den f√ºr die Interpretation erforderlichen Zustand der virtuellen Maschine wiederherstellen und ihn dem Interpreter zur Ausf√ºhrung √ºbergeben. <br><br>  Ein √§hnliches Schema wird sowohl in HotSpot Java VM als auch in V8 verwendet.  Die Anpassung der Technologie an PHP ist jedoch mit einer Reihe von Schwierigkeiten verbunden.  Zun√§chst einmal haben wir Bytecode und nativen Code gemeinsam genutzt, die von verschiedenen Prozessen verwendet wurden.  Wir k√∂nnen sie nicht direkt im gemeinsam genutzten Speicher √§ndern. Wir m√ºssen sie zuerst kopieren, √§ndern und dann wieder in den gemeinsam genutzten Speicher √ºbertragen. <br><br><h2>  Vorladen.  Das Problem der Klassenbindung </h2><br>  Tats√§chlich stammen viele der Ideen f√ºr PHP-Verbesserungen, die seit langem in PHP 7 und sogar in PHP 5 enthalten sind, aus JIT-bezogenen Arbeiten.  Heute werde ich √ºber eine andere derartige Technologie sprechen - dies ist das Vorladen.  Diese Technologie ist bereits in PHP 7.4 enthalten und erm√∂glicht es, eine Reihe von Dateien anzugeben, diese beim Serverstart zu laden und alle Funktionen dieser Dateien permanent zu machen. <br><br>  Eines der Probleme, die durch die Preloading-Technologie gel√∂st werden, ist das Problem der Klassenbindung.  Tatsache ist, dass beim einfachen Kompilieren von Dateien in PHP jede Datei separat von den anderen kompiliert wird.  Dies geschieht, weil jeder von ihnen separat ge√§ndert werden kann.  Sie k√∂nnen eine Klasse aus einem Skript nicht mit einer Klasse aus einem anderen Skript verkn√ºpfen, da sich bei der n√§chsten Anforderung m√∂glicherweise eine Klasse √§ndert und ein Fehler auftritt.  Dar√ºber hinaus kann es in mehreren Dateien eine Klasse mit demselben Namen geben, und bei einer Anforderung wird eine von ihnen als √ºbergeordnete Klasse verwendet, und bei der anderen wird eine andere Klasse aus einer anderen Datei verwendet (mit demselben Namen, aber mit einer v√∂llig anderen).  Es stellt sich heraus, dass Sie beim Generieren von Code, der f√ºr mehrere Anforderungen ausgef√ºhrt wird, nicht auf Klassen oder Methoden verweisen k√∂nnen, da diese jedes Mal neu erstellt werden (die Codelebensdauer √ºberschreitet die Klassenlebensdauer). <br><br>  Durch das Vorladen k√∂nnen Sie Klassen anf√§nglich binden und entsprechend den Code optimaler generieren.  Zumindest f√ºr Frameworks, die mit Preloading geladen werden. <br><br>  Diese Technologie hilft nicht nur bei der Klassenbindung.  √Ñhnliches ist in Java als Class Data Sharing implementiert.  Dort soll diese Technologie in erster Linie den Start von Anwendungen beschleunigen und den Gesamtspeicherbedarf reduzieren.  Die gleichen Vorteile werden in PHP erzielt, da die Klassenbindung jetzt nicht mehr zur Laufzeit, sondern nur einmal ausgef√ºhrt wird.  Au√üerdem werden die zugeh√∂rigen Klassen jetzt nicht im Adressraum jedes Prozesses, sondern im gemeinsam genutzten Speicher gespeichert, sodass der Gesamtspeicherverbrauch sinkt. <br><br>  Die Verwendung von Preloading hilft auch bei der globalen Optimierung aller PHP-Skripte, beseitigt den OPcache-Overhead vollst√§ndig und erm√∂glicht Ihnen die Generierung von effizienterem JIT-Code. <br><br>  Es gibt aber auch Nachteile.  <strong>Beim Start geladene Skripte k√∂nnen nicht ersetzt werden, ohne PHP neu zu starten.</strong>  Wenn wir etwas heruntergeladen und dauerhaft gemacht haben, k√∂nnen wir es nicht mehr entladen.  Aus diesem Grund kann die Technologie mit stabilen Frameworks verwendet werden. Wenn Sie die Anwendung jedoch mehrmals t√§glich bereitstellen, funktioniert sie h√∂chstwahrscheinlich nicht f√ºr Sie. <br><br>  Die Technologie wurde als transparent konzipiert, das hei√üt, vorhandene Anwendungen (oder Teile davon) konnten unver√§ndert geladen werden.  Nach der Implementierung stellte sich jedoch heraus, dass dies nicht vollst√§ndig zutrifft. <strong>Nicht alle Anwendungen funktionieren wie beabsichtigt, wenn sie mithilfe von Preload geladen wurden</strong> .  Wenn beispielsweise ein Code in der Anwendung basierend auf den Ergebnissen der √úberpr√ºfung der <code>function_exists</code> oder <code>class_exists</code> wird und die Funktion konstant wird, gibt <code>function_exists</code> immer <code>true</code> , und es wurde angenommen, dass der zuvor aufgerufene Code nicht aufgerufen wurde. <br><br>  Technisch gesehen wird das Preloading mit nur einer Konfigurationsanweisung opcache.preload aktiviert, zu deren Eingabe Sie eine Skriptdatei angeben - eine regul√§re PHP-Datei, die beim Start der Anwendung gestartet (nicht nur geladen, sondern ausgef√ºhrt) wird. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_preload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $preload, string $pattern = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"/\.php$/"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_file($path) &amp;&amp; preg_match($pattern, $path)) { opcache_compile_file($path) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">"Preloading failed"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_dir($path)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($dh = opendir($path)) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (($file = readdir($dh)) !== <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($file !== <span class="hljs-string"><span class="hljs-string">"."</span></span> &amp;&amp; $file !== <span class="hljs-string"><span class="hljs-string">".."</span></span>) { _preload($path . <span class="hljs-string"><span class="hljs-string">"/"</span></span> . $file, $pattern); } } closedir($dh); } } } _preload(<span class="hljs-string"><span class="hljs-string">"/usr/local/lib/ZendFramework"</span></span>);</code> </pre> <br>  Dies ist eines der m√∂glichen Szenarien, in denen alle Dateien in einem bestimmten Verzeichnis (in diesem Fall ZendFramework) rekursiv gelesen werden.  Sie k√∂nnen absolut jedes Skript in PHP implementieren: mit einer Liste lesen, Ausnahmen hinzuf√ºgen oder sogar mit Composer kreuzen, so dass es Podsoval-Dateien enth√§lt, die zum Vorabladen ben√∂tigt werden.  Das ist alles eine Frage der Technologie, und interessanter ist nicht, wie man versendet, sondern was man versendet. <br><br><h3>  Was beim Vorladen zu laden ist </h3><br>  Ich habe diese Technologie auf WordPress ausprobiert.  Wenn Sie nur alle * .php-Dateien hochladen, funktioniert WordPress aufgrund der zuvor erw√§hnten Funktion nicht mehr: Es verf√ºgt √ºber eine Funktion_exists-Pr√ºfung, die immer wahr wird.  Daher musste ich das Skript aus dem vorherigen Beispiel leicht modifizieren (Ausnahmen hinzuf√ºgen), und dann funktionierte es ohne √Ñnderungen in WordPress. <br><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  Geschwindigkeit [req / seq] </td><td>  Speicher [MB] </td><td>  Anzahl der Skripte </td><td>  Anzahl der Funktionen </td><td>  Anzahl der Klassen </td></tr><tr><td>  Nichts </td><td>  378 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  Alle (fast *) </td><td>  395 </td><td>  7.5 </td><td>  254 </td><td>  1770 </td><td>  148 </td></tr><tr><td>  Nur verwendete Skripte </td><td>  396 </td><td>  4,5 </td><td>  84 </td><td>  1532 </td><td>  51 </td></tr></tbody></table></div><br>  Infolgedessen haben <strong>wir durch Vorspannung eine Beschleunigung von ~ 5%</strong> , was ohnehin nicht schlecht ist. <br><br>  Ich habe fast alle Dateien heruntergeladen, aber die H√§lfte davon wurde nicht verwendet.  Sie k√∂nnen es noch besser machen - fahren Sie die Anwendung, und sehen Sie, welche Dateien heruntergeladen wurden.  Sie k√∂nnen dies mit der Funktion <code>opcache_get_status()</code> tun, die alle zwischengespeicherten OPcache-Dateien zur√ºckgibt und eine Liste f√ºr sie zum Vorabladen erstellt.  Auf diese Weise k√∂nnen Sie 3 MB einsparen und etwas mehr Beschleunigung erzielen.  Tatsache ist, dass je mehr Speicher ben√∂tigt wird, desto mehr der Prozessor-Cache verschmutzt und desto weniger effizient ist er.  <strong>Je weniger Speicher verwendet wird, desto h√∂her ist die Geschwindigkeit.</strong> <br><br><h2>  FFI - Foreign Function Interface </h2><br>  Eine weitere JIT-bezogene Technologie, die f√ºr PHP entwickelt wurde, ist FFI (Foreign Function Interface) oder auf Russisch die F√§higkeit, Funktionen, die in anderen kompilierten Programmiersprachen geschrieben wurden, ohne Kompilierung aufzurufen.  Die Implementierung einer solchen Technologie in Python hat meinen Chef (Zeev Surazki) beeindruckt, und ich war sehr beeindruckt, als ich anfing, sie an PHP anzupassen. <br><br>  Es gab bereits mehrere Versuche in PHP, eine Erweiterung f√ºr FFI zu erstellen, aber alle verwendeten ihre eigene Sprache oder API, um die Schnittstellen zu beschreiben.  Ich habe die Idee in LuaJIT ausspioniert, wo die C-Sprache (eine Teilmenge) verwendet wird, um die Schnittstellen zu beschreiben, und das Ergebnis ist ein sehr cooles Spielzeug.  Wenn ich jetzt √ºberpr√ºfen muss, wie etwas in C funktioniert, schreibe ich es in PHP - es passiert direkt in der Befehlszeile. <br><br>  Mit FFI k√∂nnen Sie mit in C definierten Datenstrukturen arbeiten und in JIT integriert werden, um effizienteren Code zu generieren.  Die libffi-basierte Implementierung ist bereits in PHP 7.4 enthalten. <br><br>  Aber: <br><br><ul><li>  Dies sind 1000 neue M√∂glichkeiten, sich in den Fu√ü zu schie√üen. </li><li>  Erfordert C-Kenntnisse und manchmal manuelle Speicherverwaltung. </li><li>  Unterst√ºtzt C-Pr√§prozessor (#include, #define, ...) und C ++ nicht. </li><li>  Die Leistung ohne JIT ist ziemlich niedrig. </li></ul><br>  Obwohl, vielleicht f√ºr einige wird es bequem sein, weil der Compiler nicht ben√∂tigt wird.  Dies funktioniert auch unter Windows ohne Visual-C von PHP. <br><br>  Ich zeige Ihnen, wie Sie mit FFI eine echte GUI-Anwendung f√ºr Linux implementieren. <br><br>  Lassen Sie sich vom C-Code nicht beunruhigen. Ich selbst habe vor ungef√§hr 20 Jahren eine grafische Benutzeroberfl√§che in C geschrieben, aber dieses Beispiel wurde im Internet gefunden. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;gtk/gtk.h&gt; static void activate(GtkApplication* app, gpointer user_data) { GtkWidget *window = gtk_application_window_new(app); gtk_window_set_title(GTK_WINDOW(window), "Hello from C"); gtk_window_set_default_size(GTK_WINDOW(window), 200, 200); gtk_widget_show_all(window); } int main() { int status; GtkApplication *app; app = gtk_application_new("org.gtk.example", G_APPLICATION_FLAGS_NONE); g_signal_connect(app, "activate", G_CALLBACK(activate), NULL); status = g_application_run(G_APPLICATION(app), 0, NULL); g_object_unref(app); return status; }</span></span></span></span></code> </pre> <br>  Das Programm erstellt die Anwendung, bleibt beim R√ºckrufaktivierungsereignis h√§ngen und startet die Anwendung.  Erstellen Sie im R√ºckruf ein Fenster, weisen Sie ihm die Titelgr√∂√üe zu und zeigen Sie es an. <br><br>  Und jetzt dasselbe in PHP umgeschrieben: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $ffi = FFI::cdef(<span class="hljs-string"><span class="hljs-string">" ‚Ä¶ // #include &lt;gtk/gtk.h&gt; "</span></span>, <span class="hljs-string"><span class="hljs-string">"libgtk-3.so.0"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app, $user_data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> $ffi; $window = $ffi-&gt;gtk_application_window_new($app); $ffi-&gt;gtk_window_set_title($window, <span class="hljs-string"><span class="hljs-string">"Hello from PHP"</span></span>); $ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); $ffi-&gt;gtk_widget_show_all($window); } $app = $ffi-&gt;gtk_application_new(<span class="hljs-string"><span class="hljs-string">"org.gtk.example"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); $ffi-&gt;g_signal_connect_data($app, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); $ffi-&gt;g_application_run($app, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); $ffi-&gt;g_object_unref($app);</code> </pre> <br>  Hier wird zuerst das FFI-Objekt angelegt.  Eine Beschreibung der Schnittstelle wird ihm als Eingabe gesendet - im Wesentlichen eine h-Datei - und die Bibliothek, die wir herunterladen m√∂chten.  Danach stehen alle in der Oberfl√§che beschriebenen Funktionen als Methoden des ffi-Objekts zur Verf√ºgung und alle √ºbergebenen Parameter werden automatisch und absolut transparent in die notwendige Maschinendarstellung √ºbersetzt. <br><br>  Es ist zu sehen, dass alles genau so ist wie im vorherigen Beispiel.  Der einzige Unterschied besteht darin, dass wir in C einen R√ºckruf als Adresse gesendet haben und in PHP die Verbindung √ºber den durch die Zeichenfolge angegebenen Namen hergestellt wird. <br><br>  Nun wollen wir sehen, wie die Benutzeroberfl√§che aussieht.  Im ersten Teil bestimmen wir die Typen und Funktionen in C und in der letzten Zeile laden wir die gemeinsam genutzte Bibliothek: <br><br><pre> <code class="cpp hljs">&lt;?php $ffi = FFI::cdef(<span class="hljs-string"><span class="hljs-string">" typedef struct _GtkApplication GtkApplication; typedef struct _GtkWidget GtkWidget; typedef void (*GCallback)(void*,void*); int g_application_run (GtkApplication *app, int argc, char **argv); unsigned long * g_signal_connect_data (void *ptr, const char *signal, GCallback handler, void *data, GCallback *destroy, int flags); void g_object_unref (void *ptr); GtkApplication * gtk_application_new (const char *app_id, int flags); GtkWidget * gtk_application_window_new (GtkApplication *app); void gtk_window_set_title (GtkWidget *win, const char *title); void gtk_window_set_default_size (GtkWidget *win, int width, int height); void gtk_widget_show_all (GtkWidget *win); "</span></span>, <span class="hljs-string"><span class="hljs-string">"libgtk-3.so.0"</span></span>); ...</code> </pre> <br>  In diesem Fall werden diese C-Definitionen nahezu unver√§ndert aus den h-Dateien der GTK-Bibliothek kopiert. <br><br>  Um C und PHP in derselben Datei nicht zu beeintr√§chtigen, k√∂nnen Sie den gesamten C-Code in eine separate Datei packen, z. B. mit dem Namen gtk-ffi.h, und am Anfang ein paar spezielle define'ov hinzuf√ºgen, die den Namen der Schnittstelle und die zu ladende Bibliothek angeben: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FFI_SCOPE </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GTK"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FFI_LIB </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"libgtk-3.so.0"</span></span></span></span></code> </pre> <br>  Daher haben wir die gesamte Beschreibung der C-Schnittstelle in einer Datei ausgew√§hlt.  Diese gtk-ffi.h ist fast real, aber leider haben wir noch keinen C-Pr√§prozessor implementiert, was bedeutet, dass Makros und Includes nicht funktionieren. <br><br>  Laden wir nun diese Schnittstelle in PHP: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GTK</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $ffi = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_window</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_null(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi)) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi = FFI::load(<span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">"/gtk_ffi.h"</span></span>); $app = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_new(<span class="hljs-string"><span class="hljs-string">"org.gtk.example"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_signal_connect_data($app, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app, $data)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ $window = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_window_new($app); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_title($window, $title); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_widget_show_all($window); }, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_application_run($app, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_object_unref($app); } }</code> </pre> <br>  Da FFI eine ziemlich gef√§hrliche Technologie ist, m√∂chten wir sie nicht an Dritte weitergeben.  Lassen Sie uns zumindest das FFI-Objekt ausblenden, dh es innerhalb der Klasse als privat kennzeichnen.  Und wir werden ein FFI-Objekt erstellen, das nicht <code>FFI::cdef</code> , sondern <code>FFI::load</code> und nur unsere h-Datei aus dem vorherigen Beispiel liest. <br><br>  Der Rest des Codes hat sich nicht wesentlich ge√§ndert, nur als Event-Handler haben wir begonnen, eine unbenannte Funktion zu verwenden und den Titel mit lexikalischer Bindung weiterzugeben.  Das hei√üt, wir verwenden sowohl C als auch die St√§rken von PHP, die in C nicht verf√ºgbar sind. <br><br>  Eine auf diese Weise erstellte Bibliothek kann bereits in Ihrer Anwendung verwendet werden.  Aber es ist gut, wenn es <strong>nur in der Befehlszeile</strong> funktioniert und wenn Sie es in den Webserver einf√ºgen, wird die Datei gtk_ffi.h bei jeder Anforderung gelesen, eine Bibliothek erstellt und geladen, die Bindung wird durchgef√ºhrt ... Und all diese sich wiederholenden Arbeiten werden Ihren Server laden. <br><br>  Um dies zu vermeiden und das Schreiben von PHP-Erweiterungen in PHP selbst zu erm√∂glichen, haben wir uns entschieden, FFI mit Preloading zu kreuzen. <br><br><h3>  FFI + Vorspannung </h3><br>  Der Code hat sich nicht wesentlich ge√§ndert, erst jetzt geben wir die h-Dateien zum Vorladen an und f√ºhren <code>FFI::load</code> direkt zum Zeitpunkt des Vorladens aus und nicht, wenn wir das Objekt erstellen.  Das hei√üt, beim Laden der Bibliothek werden alle Analysen und Bindungen einmal ausgef√ºhrt (beim Serverstart), und mit Hilfe von <code>FFI::scope("GTK")</code> wir in unserem Skript Zugriff auf eine vorinstallierte Schnittstelle nach Namen. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> FFI::load(<span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">"/gtk_ffi.h"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GTK</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $ffi = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_window</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_null(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi)) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi = FFI::scope(<span class="hljs-string"><span class="hljs-string">"GTK"</span></span>); $app = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_new(<span class="hljs-string"><span class="hljs-string">"org.gtk.example"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_signal_connect_data($app, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app, $data)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ $window = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_window_new($app); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_title($window, $title); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_widget_show_all($window); }, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_application_run($app, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_object_unref($app); } }</code> </pre> <br>  In dieser Ausf√ºhrungsform kann FFI von einem Webserver verwendet werden.  Dies gilt nat√ºrlich nicht f√ºr die GUI, aber auf diese Weise k√∂nnen Sie beispielsweise Bindungen an die Datenbank schreiben. <br><br>  Eine auf diese Weise erstellte Erweiterung kann direkt √ºber die Befehlszeile verwendet werden: <br><pre> <code class="xml hljs">$ php -d opcache.preload=gtk.php -r 'GTK::create_window(" !");'</code> </pre> <br>  Ein weiteres Plus von FFI Crossbreeding und Preloading ist die M√∂glichkeit, die Verwendung von FFI f√ºr alle Skripte auf Benutzerebene zu verbieten.  Sie k√∂nnen ffi.enable = preload angeben, was bedeutet, dass wir vorinstallierten Dateien vertrauen, aber das Aufrufen von FFI aus regul√§ren PHP-Skripten ist verboten. <br><br><h3>  Arbeiten mit Datenstrukturen C </h3><br>  Ein weiteres interessantes Merkmal von FFI ist, dass es mit nativen Datenstrukturen arbeiten kann.  Sie k√∂nnen jederzeit eine in C beschriebene Datenstruktur im Speicher anlegen. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $points = FFI::new(<span class="hljs-string"><span class="hljs-string">"struct {int x,y;} [100]"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($x = <span class="hljs-number"><span class="hljs-number">0</span></span>; $x &lt; count($points); $x++) { $points[$x]-&gt;x = $x; $points[$x]-&gt;y = $x * $x; } var_dump($points[<span class="hljs-number"><span class="hljs-number">25</span></span>]-&gt;y); <span class="hljs-comment"><span class="hljs-comment">// 625 var_dump(FFI::sizeof($points)); // 800  foreach ($points as &amp;$p) { $p-&gt;x += 10; } var_dump($points[25]-&gt;x); // 35</span></span></code> </pre> <br>  Wir erstellen ein Array von 100 Strukturen (Anmerkung FFI :: new! = New FFI) mit zwei Ganzzahlen.       ,    C.             PHP,     .     count, /        foreach  .      800 ,      PHP      PHP'   ,       10 . <br><br>   FFI: <br><br><ul><li> <a href="https://github.com/dstogov/php-tensorflow"> </a>  PHP. </li><li> <a href="https://github.com/ircmaxell/libgccffi"></a>  PHP. </li></ul><br> Python/CFFI    :  (Cario, JpegTran),  (ffmpeg),  (LibreOfficeKit),   (SDL)    (TensorFlow). <br><br> <strong> ,   FFI    .</strong> <br><br>   -   PHP.    ,      ,      callback'        ,      .         FFI.  ,   .    FFI c JIT, ,   LuaJIT,    .      ,    ,     . <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($k=<span class="hljs-number"><span class="hljs-number">0</span></span>; $k&lt;<span class="hljs-number"><span class="hljs-number">1000</span></span>; $k++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i=$n<span class="hljs-number"><span class="hljs-number">-1</span></span>; $i&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span>; $i--) { $Y[$i] += $X[$i]; } }</code> </pre> <br>      FFI   . <br><div class="scrollable-table"><table><tbody><tr><td></td><td> Native Arrays </td><td> FFI Arrays </td></tr><tr><td> PyPy </td><td> 0,010 </td><td> 0,081 </td></tr><tr><td>  Python </td><td> 0,212 </td><td> 0,343 </td></tr><tr><td> LuaJIt -joff </td><td> 0,037 </td><td> 0,412 </td></tr><tr><td> LuaJit -jon </td><td> 0,003 </td><td> 0,002 </td></tr><tr><td>  Php </td><td> 0,040 </td><td> 0,093 </td></tr><tr><td> PHP + JIT </td><td> 0,016 </td><td> 0,087 </td></tr></tbody></table></div><br> <em>  : Zeev Surasky (Zend), Andi Gutmans (ex-Zend, Amazon), Xinchen Hui (ex-Weibo, ex-Zend, Lianjia), Nikita Popov (JetBrains), Anatol Belsky (Microsoft), Anthony Ferrara (ex-Google, Lingo Live), Joe Watkins, Mohammad Reza Haghighat (Intel)   Intel, Andy Wingo (JS hacker, Igalia), Mike Pall ( LuaJIT).</em> <br><br>        ,       ,    <a href="https://www.youtube.com/watch%3Fv%3D7UOWus-5yxg%26amp%3Bfeature%3Dyoutu.be%26amp%3Bt%3D1804"></a> . <br><br><blockquote> <a href="https://phprussia.ru/moscow/2020">PHP Russia 2020</a> !     <a href="http://eepurl.com/VYVaf"></a>  <a href="https://t.me/PHPRussiaConfChannel">telegram-</a> ,    2019     <a href="https://www.youtube.com/channel/UCxLQ9eT6YHnc6dMLRFzEc7Q">youtube-</a>  ,       , ‚Äî <a href="https://conf.ontico.ru/lectures/propose%3Fconference%3Dpc2020"> </a>  . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481092/">https://habr.com/ru/post/de481092/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481074/index.html">Python-Rechner</a></li>
<li><a href="../de481078/index.html">Die Wahlbeteiligung ist gescheitert: Wir bringen AgentTesla zu sauberem Wasser. Teil 3</a></li>
<li><a href="../de481082/index.html">Mohnatiki erobern den Markt f√ºr die Spielebranche! Peregrine Labs gibt Zusammenarbeit mit Epic Games bekannt</a></li>
<li><a href="../de481084/index.html">Python, Einf√ºhrung in die Datenbank</a></li>
<li><a href="../de481086/index.html">Vivaldi 2.10 - Undercover Agent</a></li>
<li><a href="../de481094/index.html">√úber JBL Funkkopfh√∂rer mit Solarenergie und was ist mit ihnen los</a></li>
<li><a href="../de481100/index.html">Winkel 9, was ist neu?</a></li>
<li><a href="../de481102/index.html">Plattform√ºbergreifende .NET UI-Toolkit-Version AvaloniaUI 0.9</a></li>
<li><a href="../de481104/index.html">Mischen von OpenJDK und NodeJS: Sprach√ºbergreifende Interaktionen und vertikale Architektur</a></li>
<li><a href="../de481106/index.html">Wie LANIT eine DIY-Sitcom in seinem B√ºro drehte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>