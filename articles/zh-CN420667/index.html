<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💅🏻 😎 🕟 EIGRP协议的操作原理 🚃 👨🏼‍🏫 💪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文将讨论EIGRP，并讨论该协议如何工作。 EIGRP是一种距离矢量协议，有时被称为混合协议，但事实并非如此。 阅读有关OSPF 的文章的开头，您将了解为什么EIGRP是远程矢量协议。 EIGRP是思科开发的高级距离矢量动态路由协议。 让我们做对。 我们将使用以下拓扑： 

  

 在vIOS1...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EIGRP协议的操作原理</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420667/">本文将讨论EIGRP，并讨论该协议如何工作。  EIGRP是一种距离矢量协议，有时被称为混合协议，但事实并非如此。 阅读有关OSPF <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的文章</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开头，</a>您将了解为什么EIGRP是远程矢量协议。  EIGRP是思科开发的高级距离矢量动态路由协议。 让我们做对。 我们将使用以下拓扑： <br><br><a href=""></a><a href=""></a><a href=""></a><a href=""></a><a href=""></a><a href=""></a><a href=""></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/4ed/cbb/733/4edcbb7335c70442a6ad9c1e4754e851.jpg" alt="我的形象"></a> <a name="habracut"></a><br><br> 在vIOS1和vIOS2上运行EIGRP，了解如何在路由器之间传输信息。 一旦在路由器上激活EIGRP，路由器便开始发送Hello数据包。 我们还列出了EIGRP中使用的其他类型的消息。 <br><br><ul><li> 您好-路由器使用hello数据包发现邻居。 组播数据包已发送，不需要确认接收。 </li><li> 更新-包含有关更改路线的信息。 它们仅发送到受更新影响的路由器。 这些数据包可以发送到特定路由器（单播）或路由器组（多播）。 通过发送ACK确认接收到更新包。 </li><li> 查询-路由器计算路由且没有可行的后继路由器时，它将向其邻居发送查询数据包，以确定它们是否对此目的地具有可行的后继路由器。 通常，查询数据包是通过多播发送的，但也可能是单播的。 查询数据包的接收是通过数据包的接收方发送ACK来确认的。 </li><li> 回复-路由器发送回复数据包以响应查询数据包。 答复数据包被单播发送给发送查询数据包的人。 通过发送ACK确认接收到答复数据包。 </li><li>  ACK-确认收到更新，查询，回复数据包的软件包。  ACK数据包以单播方式发送，并包含一个确认号。 实际上，这些是不传输数据的hello数据包。 使用了非保证的交付。 </li></ul><br> 也有SIA软件包，但我们将在下面讨论它们。 <br> 每5秒钟将数据包发送到多播地址224.0.0.10（Hello计时器），Hold计时器为15秒= 3个hello间隔，如果在此计时器期间未从邻居接收到hello数据包，则将该邻居从邻居列表中删除。 该软件包如下所示： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/144/cd2/7a5/144cd27a50a78ca0aeb70c7e4b15cfae.jpg" alt="我的形象"><br><br> 该软件包包含系数（K1，K2，K3，K4，K5，K6），保持计时器和自治系统编号的参数。 系数（K1，K2，K3，K4，K5，K6）用于计算指标，稍后我们将介绍它们以及EIGRP计时器。 现在，重要的是要讨论自治系统（AS）。 要激活EIGRP，必须为特定的EIGRP进程分配一个编号，如OSPF。 但是，与OSPF不同，不能为每个路由器随机选择此选项，对于所有路由器，该选项都必须相同。 如果路由器收到带有与它不同的AS的Hello数据包，则将没有邻居关系。 <br><br> 为了使路由器成为邻居，必须满足以下条件： <br><br><ul><li> 路由器必须经过验证， </li><li> 路由器必须位于同一AS中， </li><li> 邻居关系应该在主地址上建立（当hello数据包到达时，路由器检查网络的发送方地址是否属于接口的主地址）， </li><li>  K系数的值必须匹配。 </li></ul><br> 为了使路由器成为EIGRP邻居，它们不必匹配Hello和Hold时间。 路由器使用从邻居收到的计时器值。 如果在其中一台路由器上更改了Hello或Hold计时器，则该路由器的邻居将使用这些值。 为了使路由器使用其他值，必须在邻居的相应接口上更改计时器。 交换Hello数据包后，将发送一个Update数据包，但它尚未包含路由，它包含Init标志，该标志告知路由器有关开始交换路由信息的信息。 该数据包直接发送到路由器的地址。 交换了此类消息后，每个路由器都会发送一个更新数据包，其中包含到多播地址224.0.0.10的路由： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd9/0da/c1c/dd90dac1c80680d40681289160f1898b.jpg" alt="我的形象"><br><br> 如您所见，Update包不包含任何度量标准，仅包含带宽，延迟，MTU等信息。路由器收到此信息后，便会使用K1-K6系数来计算度量标准。 这些数据包可以发送到特定路由器或多播。 通常，有三种更新类型： <br><br><ul><li> 非周期性（Nonperiodic）-更新不是定期发送，而是在拓扑或度量发生更改时发送； </li><li> 部分（部分）-并非路由表中的所有信息都以更新的形式传输，而仅以更改的形式传输； </li><li> 有界-更新仅发送到相关路由器。 </li></ul><br> 数据包级邻居如下所示： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/68a/588/fe6/68a588fe6adbe793d98c2b57b7da301e.jpg" alt="我的形象"><br><br> 您可能会注意到，除了我们列出的Hello和Update，还有Hello（ACK），其数量等于发送到多播地址的Update数据包的数量。 这都是关于RTP协议的。  RTP协议控制EIGRP数据包的传输过程，并提供： <br><br><ul><li> 保证包裹运送。 </li><li> 保留数据包的顺序。 </li></ul><br> 这些就是这些。 我们有什么？ 路由交换了更新数据包，现在是时候建立路由表了。 每次更新都会被处理，并将数据（带宽，延迟等）代入一个特殊公式，该度量将被计算： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc6/0ab/062/cc60ab0622cbe1abb96521c2520b96ee.jpg" alt="我的形象"><br><br> 这样的公式看起来很棒，但是关于它的最好的事情是您可能不知道，只是知道存在类似的东西。 另一个不错的技巧是，默认EIGRP系数为： <br><br><ul><li>  K1 = 1 </li><li>  K2 = 0 </li><li>  K3 = 1 </li><li>  K4 = 0 </li><li>  K5 = 0 </li></ul><br> 公式变成度量=带宽+延迟。 因此，所有路由器上的系数都相同非常重要，因此不会因路由器上的度量不同而出现问题。 让我们更详细地讨论更新中的数据。 <br><br><ul><li> 带宽-选择通向网络的带宽通道中的最小值，并将其发送到更新。 </li><li> 延迟-汇总通往该网络的所有通道的延迟。 </li><li> 可靠性-基于Keepalive的最差的可靠性度量 </li><li> 负载-根据接口上的数据包速率和配置的带宽，最糟糕的链路负载指示 </li><li>  MTU一直是最小的MTU。 尽管在更新中使用了它，但它并不参与度量标准本身的计算。 </li></ul><br> 如上所述，默认情况下使用带宽和延迟。 其余参数很少在需要时是必需的，但是借助它们，可以对度量进行更精细的调整。 因此，在Update数据包中，路由器通过了路由以及与之关联的数据，但路由器本身并未传输度量。 收到更新的路由器会根据公式计算指标，并根据指标决定是否将路由路由到路由表。 同样重要的是要注意， <b>路由器仅传输其使用的那些路由。</b> 让我们看看如何构建拓扑表。 <br><br>  <b>拓扑表</b> -从每个邻居学到的路由列表。 拓扑表还存储每个邻居针对每个路由（AD）报告的度量标准，以及本地路由器将用于通过邻居（FD）到达路由的度量标准。 <br><br> 有必要解释什么是AD和FD。 我们将在所有路由器上配置EIGRP。 另外，为避免度量中使用复数，我们将系数从K1 = 1 K2 = 0 K3 = 1 K4 = 0 K5 = 0更改为K1 = 0 K2 = 0 K3 = 1 K4 = 0 K5 = 0。 256 *延迟公式，通过更改接口上的延迟参数，我们还获得了一种简便的方法来度量指标。 考虑到接口上的延迟= 1秒，那么，如果使用OSPF术语，则每个链接的开销为256。让我们看看vIOS1上的拓扑表是什么： <br><blockquote>  vIOS1＃显示ip eigrp拓扑 <br>  AS（1）/ ID（192.168.1.1）的EIGRP-IPv4拓扑表 <br> 代码：P-被动，A-主动，U-更新，Q-查询，R-回复， <br>  r-回复状态，s-sia状态 <br><br>  P 192.168.3.0/24，1个后继，FD为512 <br> 通过192.168.13.3（512/256），GigabitEthernet0 / 0 <br>  P 192.168.2.0/24，1个后继，FD为512 <br> 通过192.168.12.2（512/256），GigabitEthernet0 / 3 <br>  P 192.168.25.0/24，1个后继，FD为512 <br> 通过192.168.12.2（512/256），GigabitEthernet0 / 3 <br>  P 192.168.35.0/24，1个后继，FD为512 <br> 通过192.168.13.3（512/256），GigabitEthernet0 / 0 <br>  P 192.168.12.0/24，1个后继，FD为256 <br> 通过Connected，GigabitEthernet0 / 3 <br>  P 192.168.45.0/24，1个后继，FD为512 <br> 通过192.168.14.4（512/256），GigabitEthernet0 / 2 <br>  P 192.168.0.0/24，1个后继，FD为256 <br> 通过Connected，GigabitEthernet0 / 1 <br>  P 192.168.13.0/24，1个后继，FD为256 <br> 通过Connected，GigabitEthernet0 / 0 <br>  P 192.168.14.0/24，1个后继，FD为256 <br> 通过已连接的GigabitEthernet0 / 2 <br>  P 192.168.5.0/24，3个后继，FD为768 <br> 通过192.168.12.2（768/512），GigabitEthernet0 / 3 <br> 通过192.168.13.3（768/512），GigabitEthernet0 / 0 <br> 通过192.168.14.4（768/512），GigabitEthernet0 / 2 </blockquote><br> 例如，如果您查看网络-192.168.5.0/24，您会注意到通过vIOS2，vIOS3和vIOS4的三个路径具有相同的度量。 对于192.168.5.0/24 FD，对于所有路径，它均等于-768和AD-512。让我们从另一篇文章中给出一个定义，并尝试解释一下： <br><br><ul><li>  <b>广告距离（AD）</b> ，也称为报告距离（RD），是广告路由的相邻路由器与目标网络之间的距离成本。 </li><li>  <b>可行距离（FD）</b> -从本地路由器到目标网络的距离的成本= AD，它宣布相邻路由器+本地路由器与相邻路由器之间的距离的成本。 </li></ul><br><blockquote>  P 192.168.5.0/24，3个后续版本，FD通过192.168.14.4（768/512）为768，GigabitEthernet0 / 2 </blockquote><br> 让我们从vIOS1的拓扑表中检查这一行。  vIOS1了解了来自vIOS4（192.168.14.4）的路由。 由于vIOS1从192.168.5.0/24分离出三个链接，因此采用我们设置的FD指标为3 * 256 = 768。  AD是相对于宣布该网络的路由器（vIOS4）的路由度量。  AD是vIOS4上此路由的FD度量。 让我们看一下vIOS4上的拓扑表： <br><blockquote>  P 192.168.5.0/24，1个后继，FD通过192.168.45.5（512/256）为512，GigabitEthernet0 / 1 </blockquote><br>  vIOS1上的AD = vIOS4上的FD。 沉默混乱，但尝试解释工作逻辑。 宣告路由的路由器在“更新”消息中发送该路由的参数（Bandwithd，Delay等），而不考虑宣告的路由器之间的链接。 也就是说，vIOS4仅考虑两个链接的参数：vIOS4 Gi0 / 1-vIOS5 Gi0 / 1和vIOS5 Gi0 / 0-VPC。 收到Update之后，vIOS1将获得的参数替换为公式，将计算出什么？ 没错-AD = 512。 在获取路由来自的链接参数后，vIOS1 Gi0 / 2-vIOS4 Gi0 / 2并将其再次代入公式。 计数，得到数字256并与AD（512）相加，得出FD-768。这些就是这些！ 但是为什么所有这些仪式呢？ <br> 所有这些都是为了创建一个称为<b>可行条件</b>的特殊规则，这是防止环路形成和快速收敛的一种手段。 <br> 让我们定义以下术语： <br><br><ul><li> 后继路由器是具有无环路径和到达目标网络的成本最低的路径的相邻路由器。 </li><li> 可行后继路由器-具有无环路径的备用路由器（AD可行后继路由器应小于当前后继路由器的FD）。 </li><li> 可行条件-AD可行后继必须小于当前后继路线的FD。 </li></ul><br> 为了解释它们的工作原理并显示其细微差别，您需要更改一些指标。 让我们执行以下操作，更改延迟，以便获得此类链接指标： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/678/c11/c2b/678c11c2b0f9b1dabb87a01ac62ff9e4.jpg" alt="我的形象"><br><br> 这是使用接口上的delay命令完成的。 现在，我们说-delay = 1，度量标准为256。让我们看看在vIOS1路由器上针对网络192.168.5.0/24获得的度量标准： <br><br><ul><li> 通过vIOS2-FD = 2304，AD = 1280 </li><li> 通过vIOS4-FD = 1024，AD = 768 </li><li> 通过vIOS3-FD = 1536，AD = 768 </li></ul><br> 如我们所见，最好的FD将是通过vIOS4的路由，它将被添加到常规路由表中，该路由称为<b>Successor</b> ： <br><blockquote>  vIOS1＃显示IP路由eigrp <br> 代码：L-本地，C-已连接，S-静态，R-RIP，M-移动，B-BGP <br>  D-EIGRP，EX-EIGRP外部，O-OSPF，IA-OSPF区域间 <br>  N1-OSPF NSSA外部类型1，N2-OSPF NSSA外部类型2 <br>  E1-OSPF外部类型1，E2-OSPF外部类型2 <br>  i-IS-IS，su-IS-IS摘要，L1-IS-IS 1级，L2-IS-IS 2级 <br>  ia-IS-IS中间区域，*-候选默认值，U-每用户静态路由 <br>  o-ODR，P-定期下载的静态路由，H-NHRP，l-LISP <br>  a-申请途径 <br>  +-复制路由，％-下一跳覆盖，p-来自PfR的覆盖 <br><br> 没有设置不得已的网关 <br><br>  D 192.168.2.0/24 [90/512]通过192.168.12.2，06:01:31，GigabitEthernet0 / 3 <br>  D 192.168.3.0/24 [90/1024]通过192.168.13.3，06:01:28，GigabitEthernet0 / 0 <br>  D 192.168.5.0/24 [90/1024]通过192.168.14.4，06:01:28，GigabitEthernet0 / 2 <br>  D 192.168.25.0/24 [90/1024]通过192.168.14.4，06:01:28，GigabitEthernet0 / 2 <br>  D 192.168.35.0/24 [90/1024]通过192.168.14.4，06:01:28，GigabitEthernet0 / 2 <br>  D 192.168.45.0/24 [90/768]通过192.168.14.4，06:01:28，GigabitEthernet0 / 2 </blockquote><br> 其他两条路线将发生什么情况-将检查它们的FS条件（可行条件）。 通过vIOS3的路由通过此条件AD（通过vIOS3）= 768 &lt;1024 = FD（通过vIOS1）。 因此，此路由尽管不会添加到常规路由表中，但将存储在拓扑表中： <br><blockquote>  vIOS1＃显示ip eigrp拓扑 <br>  AS（1）/ ID（192.168.1.1）的EIGRP-IPv4拓扑表 <br> 代码：P-被动，A-主动，U-更新，Q-查询，R-回复， <br>  r-回复状态，s-sia状态 <br><br>  P 192.168.3.0/24，1个后继，FD为1024 <br> 通过192.168.13.3（1024/256），GigabitEthernet0 / 0 <br>  P 192.168.2.0/24，1个后继，FD为1024 <br> 通过192.168.12.2（1024/256），GigabitEthernet0 / 3 <br>  P 192.168.25.0/24，1个后继，FD为1024 <br> 通过192.168.14.4（1024/768），GigabitEthernet0 / 2 <br> 通过192.168.13.3（1536/768），GigabitEthernet0 / 0 <br>  P 192.168.35.0/24，1个后继，FD为1024 <br> 通过192.168.14.4（1024/768），GigabitEthernet0 / 2 <br> 通过192.168.13.3（1280/512），GigabitEthernet0 / 0 <br>  P 192.168.12.0/24，1个后继，FD为768 <br> 通过Connected，GigabitEthernet0 / 3 <br>  P 192.168.45.0/24，1个后继，FD为768 <br> 通过192.168.14.4（768/512），GigabitEthernet0 / 2 <br>  P 192.168.0.0/24，1个后继，FD为512 <br> 通过Connected，GigabitEthernet0 / 1 <br>  P 192.168.13.0/24，1个后继，FD为768 <br> 通过Connected，GigabitEthernet0 / 0 <br>  P 192.168.14.0/24，1个后继，FD为256 <br> 通过已连接的GigabitEthernet0 / 2 <br>  <b>P 192.168.5.0/24，1个后继，FD为1024</b> <br> 通过192.168.14.4（1024/768），GigabitEthernet0 / 2 <br>  <b>通过192.168.13.3（1536/768），GigabitEthernet0 / 0</b> </blockquote><br> 它没有最佳路由的度量标准，也就是说，它不是后继路由，但它扮演着备用路由的角色，如果后继路由丢失，它将立即取代它。 这样可以实现协议的非常快速的收敛，但稍后会更多。 这条路线称为<b>可行后继</b>路线。 第三条路线会怎样？ 没什么，它不满足FC条件（1280&gt; 1024），并且为了保护它不会循环而不会被考虑在内。 可以使用show ip eigrp topology all-links命令查看通过Update收到但未经FC测试的所有路由。 目前尚不清楚为什么FS条件可以防止形成循环，现在让我们来解释一下。 重要的是要知道，在研究EIGRP协议时，了解FC条件的原理及其使用目的至关重要。 考虑稍微修改的拓扑（在vIOS2和vIOS4之间添加了链接），并且还使用了最原始的指标： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/734/050/472/7340504727cf56fa62300883800f363f.jpg" alt="我的形象"><br><br> 到网络192.168.5.0/24的路由与AD和FD相同： <br><br><ul><li>  vIOS4-通过vIOS5，AD = 5，FD = 10。 </li><li>  vIOS1-通过vIOS4，AD = 10，FD = 11。 </li><li>  vIOS3-通过vIOS1，AD = 11，FD = 12。 </li></ul><br> 但是vIOS4将收到来自vIOS2的更新，其中将包含通过vIOS2到网络192.168.5.0/24的路由，其度量标准为AD = 12，FD = 15。 显然，它不可能是后继者，如果可行的后继者突然选择了该路由，则如果后继者落入vIOS4，然后后继者选择了此路由，则会发生循环。 但是FC不允许将此路由设置为FS，因为AD = 12&gt; 10 = FD。 通往vIOS2的路由包含通过vIOS4的路径，无论如何，其AD也包括FD vIOS4。 也就是说，vIOS2上的AD包含以下链接： <br><blockquote>  12 = vIOS2上的AD = Gi0 / 3 vIOS3 + Gi0 / 2 vIOS4 + Gi0 / 1 vIOS5 + eth0 VPC5，其中Gi0 / 1 vIOS5 + eth0 VPC5 = FD = 10-这是FD vIOS4，AD &lt;FD不可能是更少。 </blockquote><br> 因此，条件FC在该路由中检查路由是否存在自身。 只有满足此条件的路由才能保证没有环路。 在某些情况下，路由不会创建环路，但同时又不满足FC条件，我们将不使用它，在这种情况下，我们选择网络稳定性。 如果您深入研究，则条件非常简单直观。 在EIGRP协议中选择最佳路由的算法称为<b>DUAL</b> 。 现在将EIGRP协议考虑到主路径丢失中的收敛问题。 让我们回到旧的大拓扑中，想象一下vIOS4消失了。 根据vIOS4丢失的方式，行为会稍有不同，但是触发触发器时会有所不同。 例如，如果我们在vIOS1上禁用了Gi 0/2接口，则vIOS1会立即检测到邻居丢失并开始采取行动，如果邻居在没有警告的情况下消失，则在15秒钟内未收到Hello数据包后，Hold Timer将工作： <br><blockquote>  D 192.168.2.0/24 [90/512]通过192.168.12.2，06:01:31，GigabitEthernet0 / 3 <br>  D 192.168.3.0/24 [90/1024]通过192.168.13.3，06:01:28，GigabitEthernet0 / 0 <br>  D 192.168.5.0/24 [90/1024]通过192.168.14.4，06:01:28，GigabitEthernet0 / 2 <br>  D 192.168.25.0/24 [90/1024]通过192.168.14.4，06:01:28，GigabitEthernet0 / 2 <br>  D 192.168.35.0/24 [90/1024]通过192.168.14.4，06:01:28，GigabitEthernet0 / 2 <br>  D 192.168.45.0/24 [90/768]通过192.168.14.4，06:01:28，GigabitEthernet0 / 2 <br><br>  P 192.168.3.0/24，1个后继，FD为1024 <br> 通过192.168.13.3（1024/256），GigabitEthernet0 / 0 <br>  P 192.168.2.0/24，1个后继，FD为1024 <br> 通过192.168.12.2（1024/256），GigabitEthernet0 / 3 <br>  P 192.168.25.0/24，1个后继，FD为1024 <br> 通过192.168.14.4（1024/768），GigabitEthernet0 / 2 <br> 通过192.168.13.3（1536/768），GigabitEthernet0 / 0 <br>  P 192.168.35.0/24，1个后继，FD为1024 <br> 通过192.168.14.4（1024/768），GigabitEthernet0 / 2 <br> 通过192.168.13.3（1280/512），GigabitEthernet0 / 0 <br>  P 192.168.12.0/24，1个后继，FD为768 <br> 通过Connected，GigabitEthernet0 / 3 <br>  P 192.168.45.0/24，1个后继，FD为768 <br> 通过192.168.14.4（768/512），GigabitEthernet0 / 2 <br>  P 192.168.0.0/24，1个后继，FD为512 <br> 通过Connected，GigabitEthernet0 / 1 <br>  P 192.168.13.0/24，1个后继，FD为768 <br> 通过Connected，GigabitEthernet0 / 0 <br>  P 192.168.14.0/24，1个后继，FD为256 <br> 通过已连接的GigabitEthernet0 / 2 <br>  P 192.168.5.0/24，1个后继，FD为1024 <br> 通过192.168.14.4（1024/768），GigabitEthernet0 / 2 <br> 通过192.168.13.3（1536/768），GigabitEthernet0 / 0 </blockquote><br> 为了方便起见，我再次带来了路由和拓扑表，以便了解路由器在每个路由上的作用，您需要知道它们之前处于什么状态。 例如，我们前面讨论的路由，192.168.5.0 / 24路由将丢失，但是在拓扑表中具有FS，因此，一旦主路由丢失，它将在路由表中取代它。 一个有趣的问题是没有FS的路由将会发生什么。 但是一点硬件： <br><br> 拓扑表中的条目可以处于两种状态：主动和被动。 当路由稳定且未搜索最佳路由时，该路由处于被动状态。 处于活动状态-如果您正在寻找最佳路线。 当目标网络没有可行的后继路由器时，将执行路由搜索。 为了寻找更好的路由，路由器向每个相邻路由器发送请求（发送查询包）。 如果邻居有到目的网络的路由，则他回答（发送答复包），如果没有路由，则邻居向他的邻居发送请求。 路由器比较所有FD到达特定网络，选择FD最小的路由，并将其放置在路由表中。 拓扑表可以存储到收件人网络的6条路由（主要和备用）。 <br><br> 丢失且没有FS的路由将切换到Active，而vIOS1将开始询问剩余的邻居。 这是使用查询消息完成的。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS1将向vIOS2和vIOS3路由器发送查询消息，在其中将明确指出所需的路由-在我们的示例中，此类路由将为192.168.14.0/24、192.168.45.0/24。通过此消息，vIOS1还通知路由器通过vIOS1到这些网络的路由不可用。这是通过在此路由的度量标准中指定“延迟：无限性”参数来完成的，也就是说，度量标准是无限大的。路由器一收到此类消息，便会通过vIOS1删除这些路由。这项技术被称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">毒逆转。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。毒性逆转也用于更新消息，我将在稍后讨论。收到带有路由192.168.14.0/24、192.168.45.0/24的请求的查询后，vIOS2和vIOS3将查看它们是否使用了这些路由（如果有的话），它们将立即发送带有这些路由新度量的回复。我们知道，vIOS2和vIOS3并未丢失其路由，因此它们将立即发送Reply。如果询问的路由器没有此路由，则它将把查询转发到其邻居，依此类推。 vIOS1将等待来自vIOS2，vIOS3的答复，然后活动计时器进入现场，该现场在发送查询后立即开始：</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">活动计时器</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-路由可以保持活动状态的时间间隔。如果计时器在接收到来自邻居的所有响应之前都已到期（答复），则路由器会将路由置于“处于活动状态”。另外，邻居的关系与那些没有收到答复的邻居破裂。默认情况下，此计时器为3分钟。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，如果尽管Hello数据包在3分钟内仍未收到Reply，则邻居将被破坏，这非常糟糕。尽管事实证明3分钟对于此类协议来说是永恒的，但在大型拓扑中仍可能出现这种情况。为了防止邻居关系被错误地切断，发明了特殊消息-SIA-Query和SIA-Reply。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为了提高路由器对活动路由状态的响应，还引入了两种消息： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIA-Query-在1.5分钟（默认）后调度，以检查直接连接的路由器的状态。</font><font style="vertical-align: inherit;">因此，如果丢失了邻居后面的路由（与邻居的连接正常），则不会重置与直接连接的路由器的邻居关系。</font><font style="vertical-align: inherit;">不需要确认收货。</font><font style="vertical-align: inherit;">发送三个消息且未收到响应后，邻居将被视为处于故障状态，并且将从拓扑表中删除路由。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIA-Reply-为响应SIA-Query而调度。</font><font style="vertical-align: inherit;">不需要确认收货。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.5分钟后，如果未收到对任何查询的答复，则发送SIA-Query，它不需要新路由，而仅需要发送SIA-Reply，以确保邻居井井有条，根本找不到正确的一个路线</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我考虑了路由器在有无FS的情况下对路由丢失的反应，我们已经足够说了。只需要对以下内容进行更改。我们没有完全正确地定义FD的定义，FD是我们在初次收到路线时或根据路线状态进一步变化时根据公式计算的度量，将CD称为计算距离是正确的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FD是迄今为止已获得的给定路线的最佳指标，并且是参加FC检查的人。</font><font style="vertical-align: inherit;">通常，FD = CD是最好的路线，但是让我们看看在vIOS4邻域崩溃之后FD是如何变化的：</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P 192.168.5.0/24，1个接班人，FD是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1024</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">经由192.168.13.3（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1536个</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / 768），接口GigabitEthernet0 / 0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不再拥有CD = 1024的路由，通过vIOS3的最佳路由是CD = 1536，但是正如您所看到的，FD = 1024，当存在通过vIOS4的路由时，它是固定的。</font><font style="vertical-align: inherit;">仅当此路由进入活动状态时，FD才会更新。</font><font style="vertical-align: inherit;">在状态从“被动”变为“主动”之前，FD也不会更改。</font><font style="vertical-align: inherit;">定期更新不适用于它。</font><font style="vertical-align: inherit;">再说一遍。</font><font style="vertical-align: inherit;">让我们做一个实验：通过vIOS3 = 1536，通过vIOS2 = 2048，返回带有vIOS4，CD的邻域。我们增加了vIOS1和vIOS3之间的通道延迟，使其大于vIOS2 CD：</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P 192.168.5.0/24，1个接班人，FD是1024 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">经由192.168.14.4（1024/768），接口GigabitEthernet0 / 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">经由192.168.13.3（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2304</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> /768），接口GigabitEthernet0 / 0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正如我们通过vIOS3 = 2304看到的CD一样，它仍然是FS，因为AD保持不变，并且FC条件也得到了满足。</font><font style="vertical-align: inherit;">我们问自己一个问题：通过vIOS2丢失路由时会发生什么？</font><font style="vertical-align: inherit;">正如我们所教导的那样，预期的逻辑答案是FS，但是没有！</font><font style="vertical-align: inherit;">由于仍有一条通过vIOS2的路由，其CD = 2048 &lt;2304，因此该路由将进入“活动”状态并为其重新计算度量标准，并选择最佳路由，即使它具有备用路由。</font><font style="vertical-align: inherit;">我们查看拓扑表并获得：</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P 192.168.5.0/24，1个后继，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FD</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过192.168.12.2（2048/1280）</font><b><font style="vertical-align: inherit;">为2048</font></b><font style="vertical-align: inherit;">，GigabitEthernet0 / 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过192.168.13.3（2304/768），GigabitEthernet0 / 0</font></font><br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将使用通过vIOS2的路由，并且正如FD所指出的，由于路由到活动状态的转换，它也已更改。</font><font style="vertical-align: inherit;">而通过vIOS3的路由再次共享了备用节点的命运。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EIGRP中的水平分割和毒性逆转规则 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像在RIP中一样，EIGRP使用“水平分割”规则-如果通过特定接口可到达路由，则此路由不包括在通过此接口发送的更新中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，如果vIOS4从vIOS1接收到到网络192.168.0.0/24的路由，它将不会通过vIOS1所连接的接口将此路由发送到Update。更准确地说，假设vIOS1开始谈论192.168.0.0/24网络。我已将更新发送到vIOS4，vIOS4会收到它，并且通常，水平分割不应使用此路由将其更新发送到vIOS1，但实际上它将以无限量度发送它。好像vIOS4说vIOS1-一样：“您不敢通过我使用通往192.168.0.0/24的网络的路由，我从您那里得到了这条路由，如果您使用它，将会出现环路。”</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">毒性逆转-使用度量标准指示丢失时无法到达的路由。</font><font style="vertical-align: inherit;">在EIGRP中，这是使用Delay参数完成的。</font><font style="vertical-align: inherit;">我们在上面指出了当vIOS1与vIOS4失去联系时如何使用该技术。</font><font style="vertical-align: inherit;">从以上有关“水平分割”的结论中，我们可以得出结论，“毒性逆转”技术不仅用于查询消息中，而且还用于更新中。</font><font style="vertical-align: inherit;">另外，Poison Reverse可能会违反“水平分割”规则，并从接收此更新的接口以无限量度发送更新。</font><font style="vertical-align: inherit;">这两个规则与FC子句一起为环路提供了EIGRP协议保护。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 存根路由器 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为一种优化，协议中引入了路由器的特殊角色-Stub。</font><font style="vertical-align: inherit;">类似于OSPF中的Stub区域，但是这里的操作原理略有不同。</font><font style="vertical-align: inherit;">将路由器配置为存根模式时，它将立即在Hello数据包中向邻居报告其存根状态，并且根据存根模式，它可以发送某些类型的路由：</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS5＃eigrp存根[已连接| </font><font style="vertical-align: inherit;">泄漏图| </font><font style="vertical-align: inherit;">仅接收| </font><font style="vertical-align: inherit;">重新分配 </font><font style="vertical-align: inherit;">静态 </font><font style="vertical-align: inherit;">摘要]</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eigrp存根命令选项： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 没有选项（默认）-连接和汇总； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 已连接-允许存根路由器发送已连接的路由，但仅适用于地址在network命令指定的网络上的接口； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 泄漏图-允许基于泄漏图的动态前缀； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 仅接收-阻止存根路由器发送任何路由； </font></font></li><li> redistributed —  stub   redistributed ; </li><li> static —  stub   static ,  ,      ; </li><li> summary —  stub     (   ). </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是此设置的主要特征是，如果路由器知道其邻居处于Stub角色，则不会将已激活的路由发送给它的Query。</font><font style="vertical-align: inherit;">例如，如果我们将vIOS5配置为Stub，则vIOS2-4将对此进行查找，并且如果路由丢失，它们将不会毒害Query。</font><font style="vertical-align: inherit;">考虑到在没有Reply的情况下可能会出现什么问题，最好仅在有意义的地方发送Query。</font><font style="vertical-align: inherit;">这在大型拓扑中很重要，在大型拓扑中，收敛可能是一个复杂的过程。</font><font style="vertical-align: inherit;">因此，如果有一台最终路由器，并且仅用户网络连接到它（相对而言，它只有一个邻居），那么最好考虑将其设置为Stub。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 关于计时器的几句话 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们讨论了其中一些，如果您查看show ip eigrp neighbors命令的输出，我们将看到以下内容： </font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS1＃show ip eigrp邻居</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AS的EIGRP-IPv4邻居（1）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H地址接口保持正常运行时间SRTT RTO Q Seq </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（sec）（ms）Cnt Num </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 192.168.14.4 Gi0 / 2 11 00:48:43 23 138 0 168 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 192.168.12.2 Gi0 / 3 12 02:31:12 6 100 0 258 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 192.168.13.3 Gi0 / 0 10 2d13h 7 100 0 291 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vIOS1＃</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是需要说明的计时器。</font><font style="vertical-align: inherit;">如果响应于任何需要确认接收的多播数据包的发送而未发送确认（ACK），则单播数据包将被发送到未响应的邻居。</font><font style="vertical-align: inherit;">如果即使在发送16个单播数据包后仍未收到确认，则认为邻居处于非活动状态。</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平滑往返时间（SRTT）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -从向邻居发送数据包到收到邻居确认的时间。</font><font style="vertical-align: inherit;">以毫秒为单位。</font><font style="vertical-align: inherit;">计算公式是专有的。</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组播流计时器</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -间隔的最大值（以秒为单位），路由器将EIGRP数据包发送到组播地址后，将切换到单播发送之前，它将等待ACK数据包。</font><font style="vertical-align: inherit;">它是根据SRTT计算的，计算公式本身是专有的。</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重传超时（RTO）-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发送单播数据包之间</font><b><font style="vertical-align: inherit;">的</font></b><font style="vertical-align: inherit;">间隔。</font><font style="vertical-align: inherit;">它是根据SRTT计算的，计算公式本身是专有的。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于这一点，我想完成本文。</font><font style="vertical-align: inherit;">以下是有用的链接：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cisconinja.wordpress.com/2009/09/18/eigrp-sia-query-and-sia-reply </font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xgu.ru/wiki/EIGRP</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.youtube.com/watch?v=FYUK7blhCZk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是有关EIGRP的网络研讨会，时间约为4个半小时。</font><font style="vertical-align: inherit;">需要查看）</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.cisco.com/c/en/us/support/docs/ip/enhanced-interior-gateway-routing-protocol-eigrp/16406-eigrp-toc.html#anc9</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN420667/">https://habr.com/ru/post/zh-CN420667/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN420657/index.html">分析：埃隆·马斯克（Elon Musk）可以用谁的钱从交易所撤回特斯拉</a></li>
<li><a href="../zh-CN420659/index.html">HRF（人权基金会）的USB活动“自由闪存盘”</a></li>
<li><a href="../zh-CN420661/index.html">连续云基础架构</a></li>
<li><a href="../zh-CN420663/index.html">查找基础架构中的问题时，简单的指标和节省时间的方法</a></li>
<li><a href="../zh-CN420665/index.html">在.NET Core和Kubernetes上构建应用程序：我们的经验</a></li>
<li><a href="../zh-CN420669/index.html">企业自动化市场概述：住房和公用事业建设与管理公司的解决方案</a></li>
<li><a href="../zh-CN420671/index.html">[Ekaterinburg，公告] UralJS＃9-有关前端微服务，测试和错误记录的三份报告</a></li>
<li><a href="../zh-CN420673/index.html">适用于Symfony 4的Docker-从LAN到生产</a></li>
<li><a href="../zh-CN420675/index.html">SOC是人。 “您好，我们正在寻找人才”，或者网络攻击监控和响应中心的分析师来自哪里？</a></li>
<li><a href="../zh-CN420677/index.html">爱普生如何为地球提供3000万个“工厂”的故事</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>