<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ›€ğŸ½ âš“ï¸ ğŸ’ Nama Implementasi dan Nama Hasil ğŸš ğŸ‘©ğŸ¼â€ğŸ’¼ ğŸ§‘ğŸ¾â€ğŸ¤â€ğŸ§‘ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya ingin menulis posting ini kembali pada bulan Juli, tetapi saya tidak bisa, oh ironi , memutuskan apa namanya. Istilah-istilah yang sukses muncul ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nama Implementasi dan Nama Hasil</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484860/"><p><img src="https://habrastorage.org/webt/sw/9a/fb/sw9afbxo38dofpspvffb0c_jrq4.jpeg"></p><br><p>  Saya ingin menulis posting ini kembali pada bulan Juli, tetapi saya tidak bisa, <em>oh ironi</em> , memutuskan apa namanya.  Istilah-istilah yang sukses muncul di benak saya hanya setelah <a href="https://www.youtube.com/watch%3Fv%3DMBRoCdtZOYg">pembicaraan Kate Gregory di CppCon</a> , dan sekarang saya akhirnya dapat memberi tahu Anda cara memanggil fungsi. </p><br><p> Tentu saja, ada nama yang sama sekali tidak membawa informasi, seperti <code>int f(int x)</code> .  Mereka juga tidak perlu digunakan, tetapi ini bukan tentang mereka.  Kadang-kadang terjadi bahwa tampaknya informasi dalam judul sudah penuh, tetapi sama sekali tidak ada manfaatnya. </p><a name="habracut"></a><br><h2 id="primer-1-stdlog2p1">  Contoh 1: std :: log2p1 () </h2><br><p>  Dalam C ++ 20, beberapa fungsi baru untuk operasi bit ditambahkan ke header, antara lain <code>std::log2p1</code> .  Ini terlihat seperti ini: <br><br><br></p><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log2p1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::log2(x)); }</code> </pre><br><p>  Yaitu, untuk setiap bilangan alami, fungsi mengembalikan logaritma binernya ditambah 1, dan untuk 0 mengembalikannya 0. Dan ini bukan masalah sekolah untuk operator if / else, ini benar-benar hal yang berguna - jumlah bit minimum yang sesuai dengan nilai ini.  Hanya menebak tentangnya dengan nama fungsinya hampir tidak mungkin. </p><br><h2 id="primer-2-stdbless">  Contoh 2: std :: bless () </h2><br><p>  <em>Sekarang bukan tentang namanya</em> </p><br><p>  Penyimpangan kecil: dalam C ++, pointer aritmatika hanya berfungsi dengan pointer ke elemen array.  Yang, pada prinsipnya, adalah logis: dalam kasus umum, himpunan objek tetangga tidak diketahui dan "apa pun dapat terjadi dalam sepuluh byte di sebelah kanan variabel <code>i</code> ".  Ini adalah perilaku yang jelas-jelas kabur. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> obj = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = &amp;obj; ++ptr; <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br><p>  Tetapi pembatasan seperti itu menyatakan sejumlah besar perilaku tidak terbatas kode yang ada.  Sebagai contoh, berikut ini adalah implementasi sederhana <code>std::vector&lt;T&gt;::reserve()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      auto new_memory = (T*) ::operator new(n * sizeof(T)); //    â€¦ //   auto size = this-&gt;size(); begin_ = new_memory; //   end_ = new_memory + size; //     end_capacity_ = new_memory + n; //    }</span></span></code> </pre> <br><p>  Kami telah mengalokasikan memori, memindahkan semua objek, dan sekarang mencoba memastikan bahwa pointer menunjukkan ke mana harus pergi.  Berikut ini hanya tiga baris terakhir yang tidak terdefinisi, karena mengandung operasi aritmatika pada pointer di luar array! </p><br><p>  Tentu saja, bukan programmer yang harus disalahkan.  Masalahnya adalah dengan standar C ++ itu sendiri, yang menyatakan sepotong kode yang jelas masuk akal ini sebagai perilaku yang tidak terdefinisi.  Oleh karena itu, <a href="https://wg21.link/p0593">P0593</a> menyarankan untuk memperbaiki standar dengan menambahkan beberapa fungsi (seperti <code>::operator new</code> dan <code>std::malloc</code> ) kemampuan untuk membuat array sesuai kebutuhan.  Semua pointer yang dibuat oleh mereka secara ajaib akan menjadi pointer ke array, dan operasi aritmatika dapat dilakukan dengannya. </p><br><p>  <em>Masih belum tentang nama, tunggu sebentar.</em> </p><br><p>  Tetapi kadang-kadang, operasi pada pointer diperlukan ketika bekerja dengan memori yang salah satu fungsi ini tidak mengalokasikan.  Sebagai contoh, fungsi <code>deallocate()</code> pada dasarnya bekerja dengan memori mati, di mana tidak ada objek sama sekali, tetapi masih harus menjumlahkan pointer dan ukuran area.  Untuk kasus ini, P0593 menawarkan fungsi <code>std::bless(void* ptr, std::size_t n)</code> (ada fungsi lain di sana, yang juga disebut <code>bless</code> , tetapi ini bukan tentang itu).  Ini tidak berpengaruh pada komputer fisik kehidupan nyata, tetapi menciptakan objek untuk mesin abstrak yang akan memungkinkan penggunaan aritmatika pointer. </p><br><p>  Nama <code>std::bless</code> bersifat sementara. </p><br><p>  <em>Jadi namanya.</em> </p><br><p>  Di Cologne, LEWG diberi tugas untuk membuat nama untuk fungsi ini.  Opsi <code>implicitly_create_objects()</code> dan <code>implicitly_create_objects_as_needed()</code> diusulkan, karena ini adalah apa fungsi tidak. </p><br><p>  Saya tidak suka opsi ini. </p><br><h2 id="primer-3-stdpartial_sort_copy">  Contoh 3: std :: partial_sort_copy () </h2><br><p>  <em>Contoh diambil dari <a href="https://www.youtube.com/watch%3Fv%3DMBRoCdtZOYg">presentasi Kate</a></em> </p><br><p>  Ada fungsi <code>std::sort</code> , yang mengurutkan elemen-elemen dari wadah: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(vec.begin(), vec.end()); <span class="hljs-comment"><span class="hljs-comment">// vec == {1, 2, 3, 4, 5}</span></span></code> </pre> <br><p>  Ada juga <code>std::partial_sort</code> , yang hanya mengurutkan bagian dari elemen: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::partial_sort(vec.begin(), vec.begin() + <span class="hljs-number"><span class="hljs-number">3</span></span>, vec.end()); <span class="hljs-comment"><span class="hljs-comment">// vec == {1, 2, 3, ?, ?} ( ...4,5,  ...5,4)</span></span></code> </pre> <br><p>  Dan masih ada <code>std::partial_sort_copy</code> , yang juga mengurutkan bagian dari elemen, tetapi pada saat yang sama wadah lama tidak berubah, tetapi mentransfer nilainya ke yang baru: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; out; out.resize(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::partial_sort_copy(vec.begin(), vec.end(), out.begin(), out.end()); <span class="hljs-comment"><span class="hljs-comment">// out == {1, 2, 3}</span></span></code> </pre> <br><p>  Kate mengklaim bahwa <code>std::partial_sort_copy</code> adalah nama yang biasa saja, dan saya setuju dengannya. </p><br><h2 id="nazvanie-implementacii-i-nazvanie-rezultata">  Nama Implementasi dan Nama Hasil </h2><br><p>  Tidak satu pun dari nama-nama yang tercantum, secara tegas, <em>salah</em> : mereka semua dengan sempurna menggambarkan apa fungsi tidak.  <code>std::log2p1()</code> benar-benar menghitung logaritma biner dan menambahkannya;  <code>implicitly_create_objects()</code> secara implisit membuat objek, dan <code>std::partial_sort_copy()</code> sebagian mengurutkan wadah dan menyalin hasilnya.  Namun, saya tidak suka semua nama ini, karena mereka tidak <em>berguna</em> . </p><br><p>  Tidak ada programmer yang duduk dan berpikir â€œSaya berharap saya bisa mengambil logaritma biner dan menambahkannyaâ€.  Dia perlu tahu berapa banyak bit nilai yang diberikan akan cocok, dan dia gagal mencari dermaga untuk sesuatu seperti <code>bit_width</code> .  Pada saat ia mencapai pengguna perpustakaan, apa yang harus dilakukan dengan logaritma biner dengannya, ia sudah menulis implementasinya (dan kemungkinan besar melewatkan cek nol).  Bahkan jika <code>std::log2p1</code> ternyata merupakan keajaiban dalam kode, yang berikutnya untuk melihat kode ini harus kembali memahami apa itu dan mengapa itu diperlukan.  <code>bit_width(max_value)</code> tidak akan memiliki masalah seperti itu. </p><br><p>  Demikian pula, tidak ada yang perlu "secara implisit membuat objek" atau "mengurutkan sebagian salinan vektor" - mereka perlu menggunakan kembali memori atau mendapatkan 5 nilai terbesar dalam urutan menurun.  Sesuatu seperti <code>recycle_storage()</code> (yang juga disarankan sebagai nama <code>std::bless</code> ) dan <code>top_n_sorted()</code> akan jauh lebih jelas. </p><br><p>  Kate menggunakan <em>nama implementasi</em> istilah untuk <code>std::partial_sort_copy()</code> , tetapi cocok dengan dua fungsi lainnya juga.  Implementasi nama mereka benar-benar digambarkan dengan sempurna.  Itu hanya pengguna membutuhkan nama hasilnya - apa yang didapatnya dengan memanggil fungsi.  Untuk struktur internalnya, dia tidak peduli, dia hanya ingin mengetahui ukuran dalam bit atau menggunakan kembali memori. </p><br><p>  <strong>Memberi nama fungsi berdasarkan spesifikasinya berarti menciptakan kesalahpahaman antara pengembang perpustakaan dan penggunanya.</strong>  <strong>Anda harus selalu ingat kapan dan bagaimana fungsi akan digunakan.</strong> </p><br><p>  Kedengarannya klise, ya.  Tapi dilihat dari <code>std::log2p1()</code> , ini jauh dari jelas bagi semua orang.  Selain itu, terkadang tidak sesederhana itu. </p><br><h2 id="primer-4-stdpopcount">  Contoh 4: std :: popcount () </h2><br><p>  <code>std::popcount()</code> , seperti <code>std::log2p1()</code> , di C ++ 20 diusulkan untuk ditambahkan ke <code>&lt;bit&gt;</code> .  Dan ini, tentu saja, adalah nama yang sangat buruk.  Jika Anda tidak tahu apa fungsi ini, tidak mungkin untuk menebak.  Tidak hanya singkatannya yang membingungkan (ada pop di namanya, tetapi pop / push tidak ada hubungannya dengan itu) - menguraikan jumlah populasi (menghitung populasi? Jumlah populasi?) Juga tidak membantu. </p><br><p>  Di sisi lain, <code>std::popcount()</code> ideal untuk fungsi ini karena memanggil instruksi assembly popcount.  Ini bukan hanya <em>nama</em> implementasinya - ini adalah deskripsi lengkapnya. </p><br><p>  Namun, dalam hal ini, kesenjangan antara pengembang bahasa dan pemrogram tidak terlalu besar.  Instruksi yang menghitung jumlah unit dalam kata biner disebut popcount dari tahun enam puluhan.  Untuk orang yang tahu apa-apa tentang operasi bit, nama seperti itu sangat jelas. </p><br><p>  <em>Ngomong-ngomong, pertanyaan yang bagus: apakah Anda memikirkan nama yang sesuai untuk pemula, atau membuat mereka terbiasa dengan barang lama?</em> </p><br><h2 id="heppi-end">  Selamat akhir? </h2><br><p>  <a href="https://wg21.link/P1956">P1956</a> menyarankan mengubah nama <code>std::log2p1()</code> menjadi <code>std::bit_width()</code> .  Proposal ini kemungkinan akan diterima di C ++ 20.  <code>std::ceil2</code> dan <code>std::floor2</code> juga akan diganti namanya menjadi std :: bit_ceil () dan std :: bit_floor ().  Nama lama mereka juga tidak terlalu, tetapi karena alasan lain. </p><br><p>  LEWG di Cologne tidak memilih <code>implicitly_create_objects[_as_needed]</code> atau <code>recycle_storage</code> sebagai nama untuk <code>std::bless</code> .  Mereka memutuskan untuk tidak memasukkan fungsi ini dalam standar sama sekali.  Efek yang sama dapat dicapai dengan secara eksplisit membuat array byte, oleh karena itu, kata mereka, fungsi tersebut tidak diperlukan.  Saya tidak suka ini karena memanggil <code>std::recycle_storage()</code> akan lebih mudah dibaca.  <code>std::bless()</code> masih ada, tetapi sekarang disebut <code>start_lifetime_as</code> .  Saya suka itu.  Itu harus masuk ke C ++ 23. </p><br><p>  Tentu saja, <code>std::partial_sort_copy()</code> tidak <code>std::partial_sort_copy()</code> lagi diganti namanya - dengan nama ini ia masuk ke standar kembali pada tahun 1998. Tapi setidaknya <code>std::log2p1</code> diperbaiki, dan itu tidak buruk. </p><br><p>  Dalam menemukan nama fungsi, Anda perlu memikirkan siapa yang akan menggunakannya dan apa yang dia inginkan dari mereka.  Seperti kata Kate, <strong>penamaan membutuhkan empati</strong> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484860/">https://habr.com/ru/post/id484860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484836/index.html">Perhitungan profitabilitas dari Tarif Hijau pada tahun 2020, Ukraina</a></li>
<li><a href="../id484838/index.html">13 contoh pengaturan aturan dalam Iklan Google [instruksi]</a></li>
<li><a href="../id484840/index.html">Pengembalian GOTO</a></li>
<li><a href="../id484846/index.html">Hubungan saya dengan open source</a></li>
<li><a href="../id484854/index.html">Jalankan game dalam C # di MS-DOS</a></li>
<li><a href="../id484862/index.html">Bermigrasi dari AngularJS ke Angular7 melalui aplikasi hybrid</a></li>
<li><a href="../id484866/index.html">Menggunakan Astra Linux pada Komputer Tertanam ARM</a></li>
<li><a href="../id484868/index.html">Bagaimana cara mengukur peningkatan tim? Bagian 2</a></li>
<li><a href="../id484870/index.html">Bagaimana bahasa Inggris telah mengubah Topeng Ilona selama 20 tahun</a></li>
<li><a href="../id484874/index.html">"Spesialis IT Anda rusak, bawa yang baru": bagaimana membangun karier di bidang TI dan tidak menjadi gila</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>