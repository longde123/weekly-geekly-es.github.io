<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∑Ô∏è üë©‚Äçüë¶ üàØÔ∏è Sobre a LL Parsing: uma abordagem para analisar atrav√©s do conceito de corte de cordas ü§¶üèΩ üÜñ ‚ú®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sauda√ß√µes √† comunidade ilustre! 

 A repeti√ß√£o √© a m√£e da aprendizagem, e a compreens√£o da an√°lise √© uma habilidade muito √∫til para qualquer programad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sobre a LL Parsing: uma abordagem para analisar atrav√©s do conceito de corte de cordas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412905/"> Sauda√ß√µes √† comunidade ilustre! <br><br>  A repeti√ß√£o √© a m√£e da aprendizagem, e a compreens√£o da an√°lise √© uma habilidade muito √∫til para qualquer programador. Por isso, quero abordar esse t√≥pico novamente e falar desta vez sobre an√°lise usando o m√©todo de descida recursiva (LL), sem formalismos (voc√™ sempre pode us√°-los posteriormente volte). <br><br>  Como escreve o grande D. Strogov, "entender √© simplificar".  Portanto, para entender o conceito de an√°lise usando o m√©todo de descida recursiva (tamb√©m conhecido como an√°lise LL), simplificamos a tarefa o m√°ximo poss√≠vel e escrevemos manualmente um analisador de um formato semelhante ao JSON, mas mais simples (se desejar, voc√™ pode expandi-lo para um analisador JSON completo, se quer se exercitar).  Vamos escrever, tendo como base a ideia de <b>cortar o barbante</b> . <br><a name="habracut"></a><br>  Nos livros cl√°ssicos e nos cursos de design de compiladores, eles geralmente come√ßam a explicar o t√≥pico de an√°lise e interpreta√ß√£o, destacando v√°rias fases: <br><br><ul><li>  An√°lise lexical: dividindo o texto de origem em uma matriz de substrings (tokens ou tokens) </li><li>  An√°lise: construindo uma √°rvore de an√°lise a partir de uma matriz de tokens </li><li>  Interpreta√ß√£o (ou compila√ß√£o): percorrendo a √°rvore resultante na ordem desejada (direta ou reversa) e executando algumas a√ß√µes de interpreta√ß√£o ou gera√ß√£o de c√≥digo em algumas etapas desta travessia </li></ul><br><div class="spoiler">  <b class="spoiler_title">realmente n√£o √© assim</b> <div class="spoiler_text">  porque no processo de an√°lise, j√° temos uma sequ√™ncia de etapas, que √© uma sequ√™ncia de visitas aos n√≥s da √°rvore, a pr√≥pria √°rvore de forma expl√≠cita pode n√£o existir, mas ainda n√£o iremos aprofundar.  Para quem quer ir mais fundo, existem links no final. <br></div></div><br>  Agora, quero usar uma abordagem ligeiramente diferente para o mesmo conceito (an√°lise de LL) e mostrar como voc√™ pode construir um analisador de LL com base na id√©ia de cortar uma string: os fragmentos s√£o cortados da string original durante a an√°lise, tornam-se menores e depois analisados exposto o resto da linha.  Como resultado, chegamos ao mesmo conceito de descida recursiva, mas de uma maneira ligeiramente diferente do que normalmente √© feito.  Talvez esse caminho seja mais conveniente para entender a ess√™ncia da ideia.  E se n√£o, ainda √© uma oportunidade de observar uma descida recursiva de um √¢ngulo diferente. <br><br>  Vamos come√ßar com uma tarefa mais simples: existe uma linha com delimitadores e quero escrever uma itera√ß√£o sobre seus valores.  Algo como: <br><br><pre><code class="java hljs">String names = <span class="hljs-string"><span class="hljs-string">"ivanov;petrov;sidorov"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name in names) { echo(<span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> + name); }</code> </pre> <br>  Como isso pode ser feito?  A maneira padr√£o √© converter a sequ√™ncia delimitada em uma matriz ou lista usando String.split (em Java) ou names.split (",") (em javascript) e iterar atrav√©s da matriz.  Mas vamos imaginar que n√£o queremos ou n√£o podemos usar a convers√£o em uma matriz (por exemplo, de repente, se programarmos na linguagem de programa√ß√£o AVAJ ++, na qual n√£o h√° estrutura de dados de "matriz").  Voc√™ ainda pode escanear a string e rastrear os delimitadores, mas tamb√©m n√£o usarei esse m√©todo, porque torna o c√≥digo do loop de itera√ß√£o complicado e, mais importante, vai contra o conceito que quero mostrar.  Portanto, relacionaremos a uma string delimitada da mesma maneira que relacionamos a listas na programa√ß√£o funcional.  E l√° eles sempre definem as fun√ß√µes head (obt√©m o primeiro elemento da lista) e tail (obt√©m o restante da lista).  A partir dos primeiros dialetos do Lisp, onde essas fun√ß√µes eram chamadas de maneira horr√≠vel e n√£o intuitiva: car e cdr (car = conte√∫do do registro de endere√ßos, cdr = conte√∫do do registro de decr√©scimo. Lendas antigas s√£o profundas, sim, eheheh.). <br><br>  Nossa linha √© uma linha delimitada.  Destaque os divisores em roxo: <br><br><img src="https://habrastorage.org/webt/kv/ua/ws/kvuaws-dfokcoad2styfhf2hkmc.png"><br><br>  E realce os itens da lista em amarelo: <br><br><img src="https://habrastorage.org/webt/mf/_s/_q/mf_s_q1hwfwdnnvtsgfoziiwmis.png"><br><br>  Assumimos que nossa linha √© mut√°vel (pode ser alterada) e escrevemos uma fun√ß√£o: <br><br><img src="https://habrastorage.org/webt/ca/ai/en/caaientt_wwjxvcgegbn-ntkx7y.png"><br><br>  Sua assinatura, por exemplo, pode ser: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder svList, String separator, StringBuilder token)</span></span></span></span></code> </pre><br>  Na entrada da fun√ß√£o, fornecemos uma lista (na forma de uma string com delimitadores) e, de fato, o valor do delimitador.  Na sa√≠da, a fun√ß√£o retorna o primeiro elemento da lista (segmento de linha para o primeiro separador), o restante da lista e o sinal de se o primeiro elemento foi retornado.  Nesse caso, o restante da lista √© colocado na mesma vari√°vel em que estava a lista original. <br><br>  Como resultado, tivemos a oportunidade de escrever assim: <br><br><pre> <code class="java hljs">StringBuilder names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(<span class="hljs-string"><span class="hljs-string">"ivanov;petrov;sidorov"</span></span>); StringBuilder name = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(cutNextToken(names, <span class="hljs-string"><span class="hljs-string">";"</span></span>, name)) { System.out.println(name); }</code> </pre><br>  Sa√≠das conforme o esperado: <br><br>  ivanov <br>  Petrov <br>  sidorov <br><br>  Fizemos sem convers√£o para ArrayList, mas estragamos a vari√°vel names, e agora ela possui uma string vazia.  Ainda n√£o parece muito √∫til, como se eles mudassem o furador de sab√£o.  Mas vamos mais longe.  L√° veremos por que era necess√°rio e para onde nos levaria. <br><br>  Agora vamos analisar algo mais interessante: uma lista de pares de valores-chave.  Essa tamb√©m √© uma tarefa muito comum. <br><br><pre> <code class="java hljs">StringBuilder pairs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(<span class="hljs-string"><span class="hljs-string">"name=ivan;surname=ivanov;middlename=ivanovich"</span></span>); StringBuilder pair = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cutNextToken(pairs, <span class="hljs-string"><span class="hljs-string">";"</span></span>, pair)) { StringBuilder paramName = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); StringBuilder paramValue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); cutNextToken(pair, <span class="hljs-string"><span class="hljs-string">"="</span></span>, paramName); cutNextToken(pair, <span class="hljs-string"><span class="hljs-string">"="</span></span>, paramValue); System.out.println(<span class="hljs-string"><span class="hljs-string">"param with name \""</span></span> + paramName + <span class="hljs-string"><span class="hljs-string">"\" has value of \""</span></span> + paramValue + <span class="hljs-string"><span class="hljs-string">"\""</span></span>); }</code> </pre><br>  Conclus√£o: <br><br><pre> <code class="hljs pgsql">param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "name" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivan" param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "surname" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivanov" param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "middlename" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivanovich"</code> </pre> <br>  Tamb√©m √© esperado.  E o mesmo pode ser alcan√ßado com o String.split, sem cortar as linhas. <br>  Mas digamos que agora quer√≠amos complicar nosso formato e passar de um valor-chave simples para um formato aninhado que lembra o JSON.  Agora queremos ler algo assim: <br><br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>}}</code> </pre><br>  Que separador separa?  Se for uma v√≠rgula, em um dos tokens teremos a linha <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span></code> </pre> <br>  Obviamente n√£o √© o que precisamos.  Portanto, devemos prestar aten√ß√£o √† estrutura da linha que queremos analisar. <br><br>  Come√ßa com uma chaveta e termina com uma chaveta (combinada com ela, o que √© importante).  Dentro desses colchetes h√° uma lista de pares 'chave': 'valor', cada par √© separado do pr√≥ximo par por v√≠rgula.  A chave e o valor s√£o separados por dois pontos.  Uma chave √© uma sequ√™ncia de letras entre ap√≥strofos.  O valor pode ser uma sequ√™ncia de caracteres entre ap√≥strofos ou a mesma estrutura, come√ßando e terminando com chaves emparelhadas.  Chamamos essa estrutura de palavra "objeto", como √© habitual em JSON. <br><br>  Acabamos de descrever informalmente a gram√°tica do nosso formato semelhante a JSON.  Normalmente, as gram√°ticas s√£o descritas de maneira inversa, formal e a nota√ß√£o BNF ou suas varia√ß√µes s√£o usadas para escrev√™-las.  Mas agora eu posso ficar sem ele e veremos como voc√™ pode "cortar" essa linha para que ela possa ser analisada de acordo com as regras desta gram√°tica. <br><br>  De fato, nosso "objeto" come√ßa com uma chave de abertura e termina com um par que a fecha.  O que uma fun√ß√£o que analisa esse formato pode fazer?  Provavelmente, o seguinte: <br><br><ul><li>  verifique se a sequ√™ncia passada come√ßa com uma chave de abertura </li><li>  verifique se a sequ√™ncia passada termina com um par de chaves de fechamento </li><li>  se ambas as condi√ß√µes forem verdadeiras, corte os colchetes de abertura e fechamento e o que resta, passe para a fun√ß√£o que analisa a lista de pares 'chave': 'valor' </li></ul><br>  Observe: as palavras ‚Äúfun√ß√£o analisando este formato‚Äù e ‚Äúfun√ß√£o analisando a lista de pares 'chave': 'valor'‚Äù apareceram.  Temos dois recursos!  Essas s√£o as mesmas fun√ß√µes que, na descri√ß√£o cl√°ssica do algoritmo de descida recursiva, s√£o chamadas de ‚Äúfun√ß√µes de an√°lise de s√≠mbolos n√£o-terminais‚Äù e que dizem que ‚Äúpara cada s√≠mbolo n√£o-terminal, √© criada sua pr√≥pria fun√ß√£o de an√°lise‚Äù.  O que, de fato, analisa isso.  Podemos nomear eles, digamos, parseJsonObject e parseJsonPairList. <br><br>  Agora tamb√©m precisamos prestar aten√ß√£o, pois temos o conceito de "par√™nteses", al√©m do conceito de "separador".  Se cortar uma linha para o pr√≥ximo separador (dois pontos entre uma chave e um valor, uma v√≠rgula entre os pares ‚Äúchave: valor‚Äù), a fun√ß√£o cutNextToken foi suficiente para n√≥s, agora que podemos usar n√£o apenas uma string, mas tamb√©m um objeto, precisamos fun√ß√£o ‚Äúcortar para o pr√≥ximo par de colchetes‚Äù.  Algo assim: <br><br><img src="https://habrastorage.org/webt/dr/5-/p0/dr5-p0qmt__fcae_ucs2iskx5xe.png"><br><br>  Essa fun√ß√£o corta um fragmento da linha do colchete de abertura para o par que o fecha, dados os par√™nteses, se houver.  Obviamente, voc√™ n√£o pode se limitar a colchetes, mas use uma fun√ß√£o semelhante para cortar v√°rias estruturas de blocos que podem ser aninhadas: blocos de operadores come√ßam..end, if..endif, for..endfor e similares. <br><br>  Vamos desenhar graficamente o que acontecer√° com a string.  Cor turquesa - isso significa que digitalizamos a linha para o s√≠mbolo destacado em turquesa para determinar o que devemos fazer em seguida.  Violeta √© ‚Äúo que cortar, √© quando cortamos os fragmentos destacados em violeta da linha e continuamos analisando o que resta dela ainda mais. <br><br><img src="https://habrastorage.org/webt/kq/pw/ze/kqpwze0fuzqcpxql01amxmvrdnq.png"><br><br>  Para compara√ß√£o, a sa√≠da do programa (o texto do programa √© fornecido no ap√™ndice) que analisa esta linha: <br><br>  Demonstra√ß√£o de an√°lise de estrutura semelhante a JSON <br><br><pre> <code class="hljs pgsql">ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> {<span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>}} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'surname'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'birthdate'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OBJECT</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> {<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'year'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'1984'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'month'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'october'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'day'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'06'</span></span></code> </pre> <br>  A qualquer momento, sabemos o que esperamos encontrar em nossa linha de entrada.  Se inserimos a fun√ß√£o parseJsonObject, esperamos que o objeto tenha sido passado para l√°, e podemos verificar isso pela presen√ßa de um par√™ntese de abertura e fechamento no in√≠cio e no final.  Se inserimos a fun√ß√£o parseJsonPairList, esperamos uma lista de pares "chave: valor" l√° e depois de "mordermos" a chave (antes do separador ":"), esperamos que a pr√≥xima coisa que "mordamos" seja valor.  Podemos observar o primeiro caractere do valor e tirar uma conclus√£o sobre seu tipo (se for o ap√≥strofo, ent√£o o valor ser√° do tipo "string", se o colchete de abertura for o valor do tipo "objeto"). <br><br>  Assim, cortando fragmentos da cadeia, podemos analis√°-la pelo m√©todo de an√°lise de cima para baixo (descida recursiva).  E quando podemos analisar, podemos analisar o formato que precisamos.  Ou crie seu pr√≥prio formato conveniente para n√≥s e desmonte-o.  Ou crie uma linguagem espec√≠fica de dom√≠nio (DSL) para nossa √°rea espec√≠fica e crie um int√©rprete para ela.  E para constru√≠-lo corretamente, sem decis√µes torturadas em regexp ou m√°quinas de estado criadas por si mesmo que surgem para programadores que est√£o tentando resolver algum problema que requer an√°lise, mas que n√£o possuem o material. <br><br>  Aqui.  Parab√©ns a todos pelo pr√≥ximo ver√£o e desejo-lhe felicidades, amor e parsers funcionais :) <br><br>  Para leitura adicional: <br><br>  Ideol√≥gico: alguns artigos longos, mas que valem a pena, por Steve Yeegge: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Comida rica para programadores</a> <br><br>  Algumas cita√ß√µes de l√°: <br><blockquote>  Voc√™ aprende compiladores e come√ßa a escrever suas pr√≥prias DSLs ou obt√©m um idioma melhor </blockquote><blockquote>  A primeira grande fase do pipeline de compila√ß√£o √© a an√°lise </blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O problema de Pin√≥quio</a> <br><br>  Cita√ß√£o de l√°: <br><blockquote>  Convers√µes de tipo, estreitamento e amplia√ß√£o de convers√µes, fun√ß√µes de amigo para ignorar as prote√ß√µes de classe padr√£o, <b>colocando minilangues em strings e analisando-as manualmente</b> , existem dezenas de maneiras de ignorar os sistemas de tipos em Java e C ++ e os programadores as usam o tempo todo , porque (pouco eles sabem) eles est√£o realmente tentando criar software, n√£o hardware. </blockquote>  T√©cnico: dois artigos sobre an√°lise sobre a diferen√ßa entre as abordagens LL e LR: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">An√°lise LL e LR Desmistificada</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LL e LR no contexto: por que as ferramentas de an√°lise s√£o dif√≠ceis</a> <br><br>  E ainda mais profundamente no t√≥pico: como escrever um int√©rprete Lisp em C ++ <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Int√©rprete Lisp em 90 linhas de C ++</a> <br><br><div class="spoiler">  <b class="spoiler_title">Aplica√ß√£o.</b>  <b class="spoiler_title">C√≥digo de exemplo (java) que implementa o analisador descrito no artigo:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> demoll; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DemoLL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder svList, String separator, StringBuilder token)</span></span></span><span class="hljs-function"> </span></span>{ String s = svList.toString(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s.trim().isEmpty()){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sepIndex = s.indexOf(separator); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sepIndex == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   ,    token.setLength(0); token.append(s); svList.setLength(0); } else { String t = s.substring(0, sepIndex); String restOfString = s.substring(sepIndex + separator.length(), s.length()); svList.setLength(0); svList.append(restOfString); token.setLength(0); token.append(t); } return true; } // "{hello world}:again" -&gt; "{hello world}", ":again" //"{'year':'1980','month':'october','day':'06'},'key1':'value1','key2':'value2'" -&gt; "{'year':'1980','month':'october','day':'06'}", ",'key1':'value1','key2':'value2'" public void cutTillMatchingParen(StringBuilder sbSrc, String openParen, String closeParen, StringBuilder matchPart){ String src = sbSrc.toString(); matchPart.setLength(0); int openParenCount = 0; String state = "not_copying"; for (int i = 0; i &lt; src.length(); i++){ String cs = String.valueOf(src.charAt(i)); // cs - current symbol if (state.equals("not_copying")){ if (cs.equals(openParen)) { state = "copying"; } } if (state.equals("copying")){ matchPart.append(cs); if (cs.equals(openParen)){ openParenCount = openParenCount + 1; } if (cs.equals(closeParen)) { openParenCount = openParenCount - 1; } if (openParenCount == 0) { break; } } } sbSrc.setLength(0); sbSrc.append(src.substring(matchPart.length(), src.length())); } public void parseJsonObject(String s) { System.out.println("ok, about to parse JSON object " + s); if (s.charAt(0) == '{' &amp;&amp; s.charAt(s.length() - 1) == '}') { String pairList = s.substring(1, s.length() - 1).trim(); parseJsonPairList(pairList); } else { System.out.println("Syntax error: not a JSON object. Must start with { and end with }"); } } public void parseJsonPairList(String pairList) { pairList = pairList.trim(); if (pairList.isEmpty()) { //System.out.println("pairList is empty"); return; } System.out.println("ok, about to parse pair list " + pairList); if (pairList.charAt(0) != '\'') { System.out.println("syntax error: key must be of type STRING, input: + pairList"); return; } StringBuilder key = new StringBuilder(); StringBuilder sbPairList = new StringBuilder(pairList); this.cutNextToken(sbPairList, ":", key); // sbPairList  ,   "name":"ivan"...,   "ivan"... System.out.println("found KEY: " + key); // checking type of value - may be String or Object StringBuilder value = new StringBuilder(); if (sbPairList.charAt(0) == '{') { cutTillMatchingParen(sbPairList, "{", "}", value); System.out.println("found VALUE of type OBJECT:" + value); parseJsonObject(value.toString()); StringBuilder emptyString = new StringBuilder(); cutNextToken(sbPairList, ",", emptyString); } else if (sbPairList.charAt(0) == '\'') { this.cutNextToken(sbPairList, ",", value); System.out.println("found VALUE of type STRING:" + value); } else { System.out.println("syntax error: VALUE must be either STRING or OBJECT"); return; } parseJsonPairList(sbPairList.toString()); } public static void main(String[] args){ DemoLL d = new DemoLL(); System.out.println("   \"=\""); StringBuilder pairs = new StringBuilder("name=ivan;surname=ivanov;middlename=ivanovich"); StringBuilder pair = new StringBuilder(); while (d.cutNextToken(pairs, ";", pair)) { StringBuilder paramName = new StringBuilder(); StringBuilder paramValue = new StringBuilder(); d.cutNextToken(pair, "=", paramName); d.cutNextToken(pair, "=", paramValue); System.out.println("param with name \"" + paramName + "\" has value of \"" + paramValue + "\""); } System.out.println("  JSON- "); String s = "{'name':'ivan','surname':'ivanov','birthdate':{'year':'1984','month':'october','day':'06'}}"; d.parseJsonObject(s); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt412905/">https://habr.com/ru/post/pt412905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt412895/index.html">Vesta Matveeva: a luta contra o cibercrime √© uma escolha moral</a></li>
<li><a href="../pt412897/index.html">Monitorando produtos Atlassian com Prometheus</a></li>
<li><a href="../pt412899/index.html">Leitura de fim de semana: 30 materiais sobre som, a hist√≥ria das marcas de √°udio e a ind√∫stria cinematogr√°fica</a></li>
<li><a href="../pt412901/index.html">Monitoramento e Kubernetes (revis√£o e reportagem em v√≠deo)</a></li>
<li><a href="../pt412903/index.html">Como pintamos Habr</a></li>
<li><a href="../pt412911/index.html">Desenvolvedores falam sobre recursos cortados de jogos</a></li>
<li><a href="../pt412913/index.html">"Baikal-T1" foi colocado √† venda por 3990 rublos</a></li>
<li><a href="../pt412915/index.html">Determina√ß√£o da densidade do g√°s a partir dos resultados da medi√ß√£o de press√£o e temperatura com sensores Arduino</a></li>
<li><a href="../pt412917/index.html">O Russian Post come√ßar√° a usar classificadores rob√≥ticos. Como vai funcionar</a></li>
<li><a href="../pt412921/index.html">Assinaturas de rede Monero</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>