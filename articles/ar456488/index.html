<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿 👩🏿‍🎨 💪🏻 تسجيل سريع 🔝 👆🏾 👆🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="في هذه المقالة ، وضعت معايير لمعظم مكالمات الحطابين الخاصة. لقد أجريت جميع التجارب على log4net و NLog ، على Intel Windows 10 x64 مع M.2 SSD. 


 يمكن ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>تسجيل سريع</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456488/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  في هذه المقالة ، وضعت معايير لمعظم مكالمات الحطابين الخاصة.  لقد أجريت جميع التجارب على log4net و NLog ، على Intel Windows 10 x64 مع M.2 SSD. </p><br><p style=";text-align:right;direction:rtl">  يمكن الاطلاع على النتائج الأولية على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">جيثب</a> .  الكود في نفس المستودع (للتشغيل ، ستحتاج .Net 4.7.2 + Microsoft Visual Studio 2017+). </p><br><p style=";text-align:right;direction:rtl">  ماذا وكيف ولماذا - تحت خفض. </p><a name="habracut"></a><br><p style=";text-align:right;direction:rtl">  من أجل عدم القراءة لفترة طويلة ، جدول النتائج: </p><br><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><thead><tr><th>  طريقة </th><th>  متوسط </th><th>  خطأ </th><th>  StdDev </th></tr></thead><tbody><tr><td>  KeepFileOpen = true ، ConcurrentWrites = false ، Async = true </td><td>  1164.677 ن </td><td>  26.3805 ن </td><td>  77.7835 ن </td></tr><tr><td>  KeepFileOpen = true ، ConcurrentWrites = true ، Async = true </td><td>  1106.691 ن </td><td>  31.4041 ن </td><td>  87.5421 ن </td></tr><tr><td>  KeepFileOpen = false ، ConcurrentWrites = false ، Async = true </td><td>  484.426 ن </td><td>  110.3406 ns </td><td>  103.2126 ن </td></tr><tr><td>  KeepFileOpen = false ، ConcurrentWrites = true ، Async = true </td><td>  5،303.602 ن </td><td>  104.3022 ن </td><td>  102.4387 ن </td></tr><tr><td>  KeepFileOpen = true ، ConcurrentWrites = false ، Async = false </td><td>  5642.301 ن </td><td>  73.2291 ن </td><td>  68.4986 ن </td></tr><tr><td>  KeepFileOpen = true ، ConcurrentWrites = true ، Async = false </td><td>  11،834.892 ن </td><td>  82.7578 ن </td><td>  77.4117 ن </td></tr><tr><td>  KeepFileOpen = false ، ConcurrentWrites = false ، Async = false </td><td>  731250.539 ن </td><td>  14،612.0117 ن </td><td>  27444.8998 ن </td></tr><tr><td>  KeepFileOpen = false ، ConcurrentWrites = true ، Async = false </td><td>  730271.927 ن </td><td>  1130.0172 ن </td><td>  10598.1051 ن </td></tr><tr><td>  CreateLog4NetFromString </td><td>  1470.662 ن </td><td>  19.9492 ن </td><td>  18.6605 ن </td></tr><tr><td>  CreateNLogFromString </td><td>  228.774 ن </td><td>  2.1315 ن </td><td>  1.8895 ن </td></tr><tr><td>  CreateLog4NetLogger </td><td>  21،046.294 ن </td><td>  284.1171 ن </td><td>  265.7633 ن </td></tr><tr><td>  CreateNLogTypeOfLogger </td><td> 164،487.931 ن </td><td>  3240.4372 ن </td><td>  3031.1070 ن </td></tr><tr><td>  CreateNLogDynamicLogger </td><td>  134459.092 ن </td><td>  1،882.8663 ن </td><td>  1761.2344 ن </td></tr><tr><td>  FileLoggingLog4NetNoParams </td><td>  8251.032 ن </td><td>  109.3075 ن </td><td>  102.2463 ن </td></tr><tr><td>  FileLoggingLog4NetSingleReferenceParam </td><td>  8260.452 ن </td><td>  145.9028 ن </td><td>  136.4776 ن </td></tr><tr><td>  FileLoggingLog4NetSingleValueParam </td><td>  8378.693 ن </td><td>  121.3003 ن </td><td>  113.4643 ن </td></tr><tr><td>  FileLoggingLog4NetMultipleReferencesParam </td><td>  9،133.136 ن </td><td>  89.7420 ن </td><td>  79.5539 ن </td></tr><tr><td>  FileLoggingLog4NetMultipleValuesParam </td><td>  9،393.989 ن </td><td>  166.0347 ن </td><td>  155.3089 ن </td></tr><tr><td>  FileLoggingNLogNetNoParams </td><td>  6061.837 ن </td><td>  69.5666 ن </td><td>  65.0726 ن </td></tr><tr><td>  FileLoggingNLogNetSingleReferenceParam </td><td>  6،458.201 ن </td><td>  94.5617 ن </td><td>  88.4530 ن </td></tr><tr><td>  FileLoggingNLogNetSingleValueParam </td><td>  6460.859 ن </td><td>  95.5435 ن </td><td>  84.6969 ن </td></tr><tr><td>  FileLoggingNLogNetMultipleReferencesParam </td><td>  7236.886 ن </td><td>  89.7334 ن </td><td>  83.9367 ن </td></tr><tr><td>  FileLoggingNLogNetMultipleValuesParam </td><td>  7524.876 ن </td><td>  82.8979 ن </td><td>  77.5427 ن </td></tr><tr><td>  NoOpLog4NetNoParams </td><td>  12.684 ن </td><td>  0.0795 ن </td><td>  0.0743 ن </td></tr><tr><td>  NoOpLog4NetSingleReferenceParam </td><td>  10.506 ن </td><td>  0.0571 ن </td><td>  0.0506 ن </td></tr><tr><td>  NoOpLog4NetSingleValueParam </td><td>  12.608 ن </td><td>  0.1012 ن </td><td>  0.0946 ن </td></tr><tr><td>  NoOpLog4NetMultipleReferencesParam </td><td>  48.858 ن </td><td>  0.3988 ن </td><td>  0.3730 ن </td></tr><tr><td>  NoOpLog4NetMultipleValuesParam </td><td>  69.463 ن </td><td>  0.9444 ن </td><td>  0.8834 ن </td></tr><tr><td>  NoOpNLogNetNoParams </td><td>  2.073 ن </td><td>  0.0253 ن </td><td>  0.0225 ن </td></tr><tr><td>  NoOpNLogNetSingleReferenceParam </td><td>  2.625 ن </td><td>  0.0364 ن </td><td>  0.0340 ن </td></tr><tr><td>  NoOpNLogNetSingleValueParam </td><td>  2.281 ن </td><td>  0.0222 ن </td><td>  0.0208 ن </td></tr><tr><td>  NoOpNLogNetMultipleReferencesParam </td><td>  41.525 ن </td><td>  0.4481 ن </td><td>  0.4191 ن </td></tr><tr><td>  NoOpNLogNetMultipleValuesParam </td><td>  57.622 ن </td><td>  0.5341 ن </td><td>  0.4996 ن </td></tr></tbody></table></div><br><h1 id="nooplogging" style=";text-align:right;direction:rtl">  NoOpLogging </h1><br><p style=";text-align:right;direction:rtl">  أولاً ، دعنا نقدر كم نقضي وقتًا في استدعاء طريقة للتسجيل ، الأمر الذي لن يؤدي في النهاية إلى شيء.  في معظم الحالات (في تجربتي) ، يتم تعطيل تصحيح المطوّل على خوادم المعركة ، لكن لا أحد يزيل المكالمات. </p><br><p style=";text-align:right;direction:rtl">  أولاً ، النتيجة: </p><br><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><thead><tr><th>  طريقة </th><th>  متوسط </th><th>  خطأ </th><th>  StdDev </th></tr></thead><tbody><tr><td>  NoOpLog4NetNoParams </td><td>  12.684 ن </td><td>  0.0795 ن </td><td>  0.0743 ن </td></tr><tr><td>  NoOpLog4NetSingleReferenceParam </td><td>  10.506 ن </td><td>  0.0571 ن </td><td>  0.0506 ن </td></tr><tr><td>  NoOpLog4NetSingleValueParam </td><td>  12.608 ن </td><td>  0.1012 ن </td><td>  0.0946 ن </td></tr><tr><td>  NoOpLog4NetMultipleReferencesParam </td><td>  48.858 ن </td><td>  0.3988 ن </td><td>  0.3730 ن </td></tr><tr><td>  NoOpLog4NetMultipleValuesParam </td><td>  69.463 ن </td><td>  0.9444 ن </td><td>  0.8834 ن </td></tr><tr><td>  NoOpNLogNetNoParams </td><td>  2.073 ن </td><td>  0.0253 ن </td><td>  0.0225 ن </td></tr><tr><td>  NoOpNLogNetSingleReferenceParam </td><td>  2.625 ن </td><td>  0.0364 ن </td><td>  0.0340 ن </td></tr><tr><td>  NoOpNLogNetSingleValueParam </td><td>  2.281 ن </td><td>  0.0222 ن </td><td>  0.0208 ن </td></tr><tr><td>  NoOpNLogNetMultipleReferencesParam </td><td>  41.525 ن </td><td>  0.4481 ن </td><td>  0.4191 ن </td></tr><tr><td>  NoOpNLogNetMultipleValuesParam </td><td>  57.622 ن </td><td>  0.5341 ن </td><td>  0.4996 ن </td></tr></tbody></table></div><br><p style=";text-align:right;direction:rtl">  و الكود: </p><br><pre style=";text-align:right;direction:rtl"><code class="plaintext hljs">void Log4NetNoParams() =&gt; _log4Net.Debug("test"); void Log4NetSingleReferenceParam() =&gt; _log4Net.DebugFormat("test {0}", _stringArgument); void Log4NetSingleValueParam() =&gt; _log4Net.DebugFormat("test {0}", _intArgument); void Log4NetMultipleReferencesParam() =&gt; _log4Net.DebugFormat( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument); void Log4NetMultipleValuesParam() =&gt; _log4Net.DebugFormat( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument); void NLogNetNoParams() =&gt; _nlog.Debug("test"); void NLogNetSingleReferenceParam() =&gt; _nlog.Debug("test {0}", _stringArgument); void NLogNetSingleValueParam() =&gt; _nlog.Debug("test {0}", _intArgument); void NLogNetMultipleReferencesParam() =&gt; _nlog.Debug( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument); void NLogNetMultipleValuesParam() =&gt; _nlog.Debug( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument);</code> </pre> <br><p style=";text-align:right;direction:rtl">  أولاً ، دعونا نحدد سبب اختيار مثل هذه الاختبارات: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تم إجراء التجارب على المكتبات الأكثر شعبية. </li><li style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  NLog و log4net لهما تواقيع دالة مختلفة لعدد صغير من الوسائط: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  log4net: </li></ul><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">void DebugFormat(string format, object arg0)</code> </pre> <br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  NLog: </li></ul><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">void Debug(string message, string argument) void Debug&lt;TArgument&gt;(string message, TArgument argument)</code> </pre> <br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  النظرية: عند نقل نوع مهم إلى log4net ، يجب أن تحدث الملاكمة ، والتي تقضي ببساطة وقت المعالج ولا تؤدي إلى أي شيء.  في حالة NLog ، لا يوجد مثل هذا السلوك ، لذلك يجب أن يعمل الأخير بشكل أسرع. </li></ul><br></li><li style=";text-align:right;direction:rtl">  تواقيع عدد كبير من الوسائط في المكتبات هي نفسها تقريبًا ، لذلك أود أن أعرف: <br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  كم أكثر كفاءة لاستدعاء الأساليب مع عدد صغير من المعلمات. </li><li style=";text-align:right;direction:rtl">  هل هناك اختلاف في سرعة استدعاء الأسلوب "Is ... ممكّن" بين المكتبتين </li></ul></li></ul><br><p style=";text-align:right;direction:rtl">  والآن تحليل النتائج: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  نظرًا لاستخدام الوسائط العامة في NLog ، فهو يعمل بشكل أسرع للحالة عندما لا يكون التسجيل المباشر ضروريًا.  وهذا هو الحال في حالة تمكين المستوى في برنامج Debug فقط على نظام الاختبار ، يمكن فقط لتغيير المكتبة تسريع البرنامج (وتحسين حياة المستخدمين). </li><li style=";text-align:right;direction:rtl">  إذا تم إيقاف تشغيل التسجيل وتريد استدعاء طريقة تحتوي على عدد كبير من الوسائط ، فمن الأفضل تقسيمها إلى قسمين.  نتيجة لهذا ، ستعمل المكالمات المذكورة أعلاه بشكل أسرع عشر مرات. </li><li style=";text-align:right;direction:rtl">  عندما تكتب وظيفة يمكن أن تأخذ أي شيء ، فغالبًا ما يكون الشعور بالارتباك وإحداث وظيفة عامة أكثر فاعلية.  نظرًا لمثل هذا التحسين البسيط ، سيعمل الرمز بشكل أسرع (يظهر هذا بوضوح في الفارق الزمني بين المكالمات إلى <code>Log4NetSingleReferenceParam</code> و <code>Log4NetSingleValueParam</code> ) </li></ul><br><h1 id="filelogging" style=";text-align:right;direction:rtl">  FileLogging </h1><br><p style=";text-align:right;direction:rtl">  لا تزال معظم البرامج (وفقًا لملاحظاتي) تسجل النتائج في ملف ، لذلك نختار هذه العملية للمقارنة.  للبساطة ، نحن فقط نأخذ التكوين من قطع الاشجار عندما يتم كتابة ملف إلى الملف دون التخزين المؤقت ، دون أقفال إضافية ، الخ </p><br><p style=";text-align:right;direction:rtl">  النتائج: </p><br><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><thead><tr><th>  طريقة </th><th>  متوسط </th><th>  خطأ </th><th>  StdDev </th></tr></thead><tbody><tr><td>  FileLoggingLog4NetNoParams </td><td>  8251.032 ن </td><td>  109.3075 ن </td><td>  102.2463 ن </td></tr><tr><td>  FileLoggingLog4NetSingleReferenceParam </td><td>  8260.452 ن </td><td>  145.9028 ن </td><td>  136.4776 ن </td></tr><tr><td>  FileLoggingLog4NetSingleValueParam </td><td>  8378.693 ن </td><td>  121.3003 ن </td><td>  113.4643 ن </td></tr><tr><td>  FileLoggingLog4NetMultipleReferencesParam </td><td>  9،133.136 ن </td><td>  89.7420 ن </td><td>  79.5539 ن </td></tr><tr><td>  FileLoggingLog4NetMultipleValuesParam </td><td>  9،393.989 ن </td><td>  166.0347 ن </td><td>  155.3089 ن </td></tr><tr><td>  FileLoggingNLogNetNoParams </td><td>  6061.837 ن </td><td>  69.5666 ن </td><td>  65.0726 ن </td></tr><tr><td>  FileLoggingNLogNetSingleReferenceParam </td><td>  6،458.201 ن </td><td>  94.5617 ن </td><td>  88.4530 ن </td></tr><tr><td>  FileLoggingNLogNetSingleValueParam </td><td>  6460.859 ن </td><td>  95.5435 ن </td><td>  84.6969 ن </td></tr><tr><td>  FileLoggingNLogNetMultipleReferencesParam </td><td>  7236.886 ن </td><td>  89.7334 ن </td><td>  83.9367 ن </td></tr><tr><td>  FileLoggingNLogNetMultipleValuesParam </td><td>  7524.876 ن </td><td>  82.8979 ن </td><td>  77.5427 ن </td></tr></tbody></table></div><br><p style=";text-align:right;direction:rtl">  كود مستخدم: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  log4net: </li></ul><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">var roller = new RollingFileAppender(); roller.ImmediateFlush = true; roller.RollingStyle = RollingFileAppender.RollingMode.Once; roller.MaxFileSize = 128 * 1000 * 1000;</code> </pre> <br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  NLog: </li></ul><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">new FileTarget($"target_{_logIndex++}") { ArchiveAboveSize = 128 * 1000 * 1000, MaxArchiveFiles = 16, AutoFlush = true, ConcurrentWrites = false, KeepFileOpen = false };</code> </pre><br><p style=";text-align:right;direction:rtl">  كما ترى ، فإن تكوين أدوات قطع الأشجار يشبه إلى حد ما ، ووفقًا للنتائج: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  NLog أسرع قليلاً من log4net ، في مكان ما حوالي 15٪. </li><li style=";text-align:right;direction:rtl">  وفقا للاختبارات ، اتضح أنه أكثر كفاءة لتسجيل عدد أقل من المعلمات.  ومع ذلك ، لا ينبغي لأحد أن ينسى أنه مع عدد أكبر من المعلمات ، تم توسيع السلسلة الناتجة أيضًا.  لذلك ، يقارن الجدول بشكل صحيح NLog مقابل log4net. </li></ul><br><h1 id="nlog---raznye-sposoby-blokirovok" style=";text-align:right;direction:rtl">  NLog - أنواع مختلفة من الأقفال </h1><br><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><thead><tr><th>  طريقة </th><th>  متوسط </th><th>  خطأ </th><th>  StdDev </th></tr></thead><tbody><tr><td>  KeepFileOpen = true ، ConcurrentWrites = false ، Async = false </td><td>  5642.301 ن </td><td>  73.2291 ن </td><td>  68.4986 ن </td></tr><tr><td>  KeepFileOpen = true ، ConcurrentWrites = true ، Async = false </td><td>  11،834.892 ن </td><td>  82.7578 ن </td><td>  77.4117 ن </td></tr><tr><td>  KeepFileOpen = false ، ConcurrentWrites = false ، Async = false </td><td>  731250.539 ن </td><td>  14،612.0117 ن </td><td>  27444.8998 ن </td></tr><tr><td>  KeepFileOpen = false ، ConcurrentWrites = true ، Async = false </td><td>  730271.927 ن </td><td>  1130.0172 ن </td><td>  10598.1051 ن </td></tr></tbody></table></div><br><p style=";text-align:right;direction:rtl">  كود المصدر: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">new FileTarget($"target_{_logIndex++}") { ArchiveAboveSize = 128 * 1000 * 1000, MaxArchiveFiles = 16, AutoFlush = true, ConcurrentWrites = XXXXX, KeepFileOpen = YYYYY };</code> </pre><br><p style=";text-align:right;direction:rtl">  إذا وضعنا جميع المجموعات الممكنة بدلاً من XXXXX و YYYYY ، فسنحصل على الاختبار من الجدول. </p><br><p style=";text-align:right;direction:rtl">  النتائج يمكن التنبؤ بها إلى حد ما: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  إذا قمت بتمكين ConcurrentWrites ، فسيقوم النظام باستمرار بإعطاء Mutex ، وهو غير مجاني.  ولكن ، كما نرى ، فإن كتابة سطر واحد إلى ملف يكافئ تقريبًا قفل نظام واحد. </li><li style=";text-align:right;direction:rtl">  إغلاق وفتح ملف ، كما نرى ، يؤثر على أداء النظام أكثر.  في الأمثلة مع <code>KeepFileOpen=true</code> لكل عملية تسجيل ، أنشأنا ملفًا (جنبًا إلى جنب مع Handle) ، وكتبنا على القرص ، يسمى Flush ، و <code>KeepFileOpen=true</code> ، وقمنا أيضًا بالكثير من عمليات غطاء المحرك.  نتيجة لذلك ، تنخفض السرعة مئات المرات. </li></ul><br><h1 id="asinhronnoe-loggirovanie-i-raznye-sposoby-blokirovok" style=";text-align:right;direction:rtl">  تسجيل غير متزامن وأساليب قفل مختلفة </h1><br><p style=";text-align:right;direction:rtl">  مكتبة NLog هي أيضا قادرة على أداء جميع عمليات الإدخال / الإخراج على مؤشر ترابط آخر ، على الفور تحرير واحد الحالي.  وهو يفعل ذلك بكفاءة ، مع الحفاظ على ترتيب الأحداث ، وإسقاط جميع البيانات في الكتل ، وفي كل كتلة عدد صحيح هو رقم الحدث (بحيث لا يتم الحصول على خطوط اقتصاص) ، وهلم جرا. </p><br><p style=";text-align:right;direction:rtl">  نتائج الطرق غير المحظورة المختلفة: </p><br><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><thead><tr><th>  طريقة </th><th>  متوسط </th><th>  خطأ </th><th>  StdDev </th></tr></thead><tbody><tr><td>  KeepFileOpen = true ، ConcurrentWrites = false ، Async = true </td><td>  1164.677 ن </td><td>  26.3805 ن </td><td>  77.7835 ن </td></tr><tr><td>  KeepFileOpen = true ، ConcurrentWrites = true ، Async = true </td><td>  1106.691 ن </td><td>  31.4041 ن </td><td>  87.5421 ن </td></tr><tr><td>  KeepFileOpen = false ، ConcurrentWrites = false ، Async = true </td><td>  484.426 ن </td><td>  110.3406 ns </td><td>  103.2126 ن </td></tr><tr><td>  KeepFileOpen = false ، ConcurrentWrites = true ، Async = true </td><td>  5،303.602 ن </td><td>  104.3022 ن </td><td>  102.4387 ن </td></tr></tbody></table></div><br><p style=";text-align:right;direction:rtl">  سوف تكون المقارنة بين الحجب والنهج غير المتزامنة أكثر ، ولكن هنا - فقط الأخير. </p><br><p style=";text-align:right;direction:rtl">  رمز <code>AsyncTargetWrapper</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">new AsyncTargetWrapper(fileTargetWithConcurrentWritesAndCloseFileAsync) { OverflowAction = AsyncTargetWrapperOverflowAction.Block, QueueLimit = 10000 }</code> </pre> <br><p style=";text-align:right;direction:rtl">  كما ترون ، فإن إعدادات المجمّع لا تستغرق وقتًا طويلاً حتى تفريغ مباشر للملف.  وبالتالي ، يتم تخزين مخزن مؤقت كبير ، مما يعني أن جميع العمليات كثيفة الاستخدام للموارد مثل "ملف مفتوح" يتم تنفيذها مرة واحدة للكتلة بأكملها.  ومع ذلك ، فإن مثل هذه الخوارزمية تتطلب ذاكرة إضافية (والكثير). </p><br><p style=";text-align:right;direction:rtl">  الاستنتاجات: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  إذا تم استخدام الإخراج غير المتزامن ، فلا يهم نوع إعدادات الإخراج التي يتم استخدامها مع الملف.  يمكنك فتح وإغلاق الملف في كل مرة ، مع وجود مخزن مؤقت كبير سيكون غير محسوس تقريبًا. </li><li style=";text-align:right;direction:rtl">  جميع القياسات صحيحة فقط للحالة عند مسح البيانات على القرص بنفس سرعة ملء المخازن المؤقتة (قمت بهذا بسبب نظام الملفات السريع + الإيقاف المؤقت الطبيعي بين القياسات). </li></ul><br><h1 id="sinhronnoe-i-asinhronnoe-loggirovanie" style=";text-align:right;direction:rtl">  تسجيل متزامن وغير متزامن </h1><br><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><thead><tr><th>  النتائج: </th><th>  طريقة </th><th>  متوسط </th><th>  خطأ </th><th>  StdDev </th><th>  متوسط </th></tr></thead><tbody><tr><td>  KeepFileOpen = true ، ConcurrentWrites = false ، Async = true </td><td>  1835.730 ن </td><td>  55.3980 ن </td><td>  163.3422 ن </td><td>  1791.901 ن </td></tr><tr><td>  FileLoggingLog4NetNoParams </td><td>  7076.251 ن </td><td>  41.5518 ن </td><td>  38.8676 ن </td><td>  7075.394 ن </td></tr><tr><td>  FileLoggingNLogNetNoParams </td><td>  5438.306 ن </td><td>  42.0170 ن </td><td>  37.2470 ن </td><td>  5427.805 ن </td></tr><tr><td>  NoOpLog4NetNoParams </td><td>  11.063 ن </td><td>  0.0141 ن </td><td>  0.0125 ن </td><td>  11.065 ن </td></tr><tr><td>  NoOpNLogNetNoParams </td><td>  1.045 ن </td><td>  0.0037 ن </td><td>  0.0033 ن </td><td>  1.045 ن </td></tr></tbody></table></div><br><p style=";text-align:right;direction:rtl">  الاستنتاجات: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  على الرغم من القرص السريع (في حالتي - M.2 SSD) ، تؤدي الكتابة إلى ملف في دفق آخر إلى تسريع العمل عدة مرات.  إذا كان التطبيق الخاص بك يكتب على الأقراص الصلبة ، وحتى يعمل على جهاز افتراضي ، فإن المكسب سيكون أكبر. </li><li style=";text-align:right;direction:rtl">  ومع ذلك ، على الرغم من التشغيل السريع للرمز غير المتزامن ، فإن الافتقار إلى قطع الأشجار يعطي ربحًا أكبر (وإن كان مختلفًا قليلاً ، حسب المكتبة). </li></ul><br><h1 id="sozdanie-loggerov" style=";text-align:right;direction:rtl">  إنشاء قطع الاشجار </h1><br><p style=";text-align:right;direction:rtl">  النتائج: </p><br><div class="scrollable-table" style=";text-align:right;direction:rtl"><table style=";text-align:right;direction:rtl"><thead><tr><th>  طريقة </th><th>  متوسط </th><th>  خطأ </th><th>  StdDev </th></tr></thead><tbody><tr><td>  CreateLog4NetFromString </td><td>  1470.662 ن </td><td>  19.9492 ن </td><td>  18.6605 ن </td></tr><tr><td>  CreateNLogFromString </td><td>  228.774 ن </td><td>  2.1315 ن </td><td>  1.8895 ن </td></tr><tr><td>  CreateLog4NetLogger </td><td>  21،046.294 ن </td><td>  284.1171 ن </td><td>  265.7633 ن </td></tr><tr><td>  CreateNLogTypeOfLogger </td><td>  164،487.931 ن </td><td>  3240.4372 ن </td><td>  3031.1070 ن </td></tr><tr><td>  CreateNLogDynamicLogger </td><td>  134459.092 ن </td><td>  1،882.8663 ن </td><td>  1761.2344 ن </td></tr></tbody></table></div><br><p style=";text-align:right;direction:rtl">  ما تم اختباره: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">[Benchmark] public object CreateLog4NetFromString() { return LogManager.GetLogger("my-logger_" + (Interlocked.Increment(ref _log4NetStringLogIndex) % 1000)); } [Benchmark] public object CreateNLogFromString() { return NLog.LogManager.GetLogger("my-logger_" + (Interlocked.Increment(ref _nLogStringLogIndex) % 1000)); } [Benchmark] public object CreateLog4NetLogger() { return new [] { LogManager.GetLogger(typeof(BaseTest)), // x16 times }; } [Benchmark] public object CreateNLogTypeOfLogger() { return new[] { NLog.LogManager.GetCurrentClassLogger(typeof(BaseTest)), // x16 times }; } [Benchmark] public object CreateNLogDynamicLogger() { return new[] { NLog.LogManager.GetCurrentClassLogger(), // x16 times }; }</code> </pre> <br><p style=";text-align:right;direction:rtl">  ملاحظة مهمة: لسوء الحظ ، كان من الصعب بالنسبة لي وضع معيار استنساخي لم يؤد إلى "نفاد الذاكرة" ، ولكنه من شأنه أن ينشئ أجهزة تسجيل مختلفة (أي لأنواع مختلفة ولخطوط مختلفة وما إلى ذلك). </p><br><p style=";text-align:right;direction:rtl">  ومع ذلك ، بعد دراسة عمل المكتبات ، وجدت أنه يتم تنفيذ معظم العمليات الصعبة تقريبًا لإنشاء مفتاح تسجيل (على سبيل المثال ، تحديد اسم ، ومسح الوسائط العامة ، وما إلى ذلك). <br>  علاوة على ذلك ، من أجل تثبيت معيار إنشاء مسجل لـ log4net ، كان من الضروري إجراء عملية واحدة ، ولكن ليس هناك 16 عملية (أي يتم إرجاع مجموعة مكونة من 16 كائنًا متطابقًا).  إذا لم تقم بإرجاع أي شيء ، فقم بتحسين التنفيذ بالنسبة لي (على ما يبدو ، عدم إرجاع النتيجة) ، مما أدى إلى نتائج غير صحيحة. </p><br><p style=";text-align:right;direction:rtl">  والاستنتاجات: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يتم إنشاء قطع الأشجار بسرعة أكبر من الأوتار (NLog أسرع مرة أخرى ، ومع ذلك ، فإن الفرق بين المكتبات صغير ، مع الأخذ في الاعتبار أن قطع الأشجار يتم إنشاؤه ليس هكذا فحسب ، ولكن للعمل اللاحق معهم). </li><li style=";text-align:right;direction:rtl">  log4net أسرع من NLog عند تهيئة المشروع.  ربما يكون هذا بسبب التخزين المؤقت الإضافي على جانب NLog ، مما يساعد على تسريع المكالمات المباشرة إلى <code>Debug</code> أو <code>Info</code> ، إلخ.  في الواقع ، يعرف كل <code>ILogger</code> الإجابة على نفسه: ما إذا كان يجب استدعاء الطرق التالية أم لا (وهذا يتطلب نوعًا من الربط على الأقل للتكوين العام).  بسبب نظام العمل هذا ، تم استخدام Out Of Memory بواسطتي في معظم الاختبارات (إذا كنت تستخدم خطوطًا مختلفة ، إلخ). </li><li style=";text-align:right;direction:rtl">  <code>LogManager.GetCurrentClassLogger()</code> أبطأ من <code>LogManager.GetLogget(typeof(XXX))</code> .  هذا منطقي ، حتى مطوري NLog لا ينصحون باستدعاء الطريقة الأولى في حلقة. </li><li style=";text-align:right;direction:rtl">  والأهم من ذلك: غالبًا ما تؤثر سرعة كل هذه الطرق على البداية الباردة للتطبيق عند <code>private static readonly ILogger Log = LogManager.GetCurrentClassLogger()</code> حقول النموذج <code>private static readonly ILogger Log = LogManager.GetCurrentClassLogger()</code> .  وهذا يعني أنه لا يؤثر بشكل مباشر على أداء النظام. </li></ul><br><h1 id="vyvod" style=";text-align:right;direction:rtl">  استنتاج </h1><br><p style=";text-align:right;direction:rtl">  ما هي أفضل طريقة للتعامل مع السجلات: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  إذا كان من الممكن عدم تسجيل الدخول على الإطلاق ، فسيكون هذا هو الأسرع (وهو أمر واضح حتى الآن). </li><li style=";text-align:right;direction:rtl">  إذا كان للمشروع العديد من مكالمات المسجل التي لا تفريغ البيانات إلى ملف (إلى وحدة التحكم ، وما إلى ذلك) ، فإن NLog يكون أسرع.  بالإضافة إلى ذلك ، فإنه يخصص كائنات أقل على كومة الذاكرة المؤقتة. </li><li style=";text-align:right;direction:rtl">  إذا كنت لا تزال بحاجة إلى الكتابة إلى ملف ، فإن NLog يعمل بشكل أسرع بشكل غير متزامن.  نعم ، إنها تستهلك ذاكرة أكبر (مقارنة بـ NLog في الوضع المتزامن ، حيث أنه وفقًا لقياساتي السابقة ، لا تحاول log4net حتى إعادة استخدام المصفوفات و <code>Stream</code> 's).  ومع ذلك ، سيتمكن البرنامج من العمل بشكل أسرع. </li><li style=";text-align:right;direction:rtl">  إنشاء مسجل ليست عملية مجانية ، لذلك من الأفضل في كثير من الأحيان إنشاء ذلك باستخدام حقل ثابت.  لا ينطبق هذا على الإنشاء من سلسلة ، أي شيء مثل <code>LogManager.GetLogger("123")</code> .  تعمل مثل هذه الاستدعاءات بشكل أسرع ، مما يعني أنه يمكن إنشاء مسجل لحالات كبيرة من الكائنات (على سبيل المثال ، "مسجل واحد لسياق الاستعلام"). </li><li style=";text-align:right;direction:rtl">  إذا كنت ترغب في إخراج الكثير من المعلمات إلى السجل ، ولكن في معظم الحالات لن يكون هناك تفريغ بيانات مباشر إلى الملف ، فمن الأفضل إجراء عدة مكالمات.  لذلك ، لن تنشئ NLog كائنات إضافية على الكومة إذا لم تكن هناك حاجة إليها. </li></ul><br><p style=";text-align:right;direction:rtl">  استنتاجات الكود: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  إذا قبلت طريقتك كائنًا اعتباطيًا (أي <code>object</code> ) ولم تفعل شيئًا في معظم الحالات (وهذا صحيح بالنسبة للعقود / المصادقون) ، فمن الأكثر <code>Something&lt;TArg&gt;(TArg arg)</code> التفاف المكالمات في نموذج عام (على سبيل المثال ، إجراء طرق من النموذج <code>Something&lt;TArg&gt;(TArg arg)</code> ).  هذا سوف يعمل بشكل أسرع حقا. </li><li style=";text-align:right;direction:rtl">  إذا كانت إعادة تعيين بيانات الملف في الكود الخاص بك مسموحًا بها وفي الوقت نفسه تعمل مع شيء آخر ، فمن الأفضل أن تحصل على الخلط ودعم ذلك.  نعم ، يبدو من الواضح أن التنفيذ الموازي يمكن أن يسرع العمل ، ومع ذلك ، في حالة عمليات الإدخال / الإخراج ، فإن هذا النهج يعطي أيضًا زيادة في الأداء على الأجهزة ذات الأقراص البطيئة. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar456488/">https://habr.com/ru/post/ar456488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar456466/index.html">PHP الوراثة اليوم (جيدًا ، تقريبًا)</a></li>
<li><a href="../ar456470/index.html">مطبات ناشر حزمة WSUS</a></li>
<li><a href="../ar456472/index.html">تقديم Go و Mggo Framework</a></li>
<li><a href="../ar456474/index.html">تيك تاك تو الجزء 0: مقارنة Svelte والتفاعل</a></li>
<li><a href="../ar456482/index.html">امسكني اذا استطعت. نسخة الملك</a></li>
<li><a href="../ar456490/index.html">محاضرات عن الدماغ ، الجزء 1. تطور الدماغ البشري. وظائف الدماغ في كل مرحلة من مراحل تطورها</a></li>
<li><a href="../ar456492/index.html">الجيش القزم</a></li>
<li><a href="../ar456494/index.html">في الولايات ، GOSTs هي أيضا على هذا النحو. YubiKey FIPS الضعف القاتل الذي كان يمكن تجنبه</a></li>
<li><a href="../ar456500/index.html">كيفية تعليم كيفية التغلب على الصعوبات ، وفي الوقت نفسه لكتابة دورات</a></li>
<li><a href="../ar456502/index.html">اقصر المقالات العلمية</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>