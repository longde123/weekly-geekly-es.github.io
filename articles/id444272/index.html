<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗺️ 🚟 👏🏿 PyDERASN: ketika saya menulis perpustakaan ASN.1 dengan slot dan gumpalan 🌏 👨🏽‍🔬 📶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ASN.1 adalah standar (ISO, ITU-T, GOST) dari bahasa yang menggambarkan informasi terstruktur, serta aturan penyandian untuk informasi ini. Bagi saya s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PyDERASN: ketika saya menulis perpustakaan ASN.1 dengan slot dan gumpalan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444272/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ASN.1</a> adalah standar (ISO, ITU-T, GOST) dari bahasa yang menggambarkan informasi terstruktur, serta aturan penyandian untuk informasi ini.  Bagi saya sebagai seorang programmer, ini hanyalah format lain untuk membuat serial dan menyajikan data, bersama dengan JSON, XML, XDR dan lainnya.  Ini sangat umum dalam kehidupan kita sehari-hari, dan banyak orang menjumpainya: dalam seluler, telepon, komunikasi VoIP (UMTS, LTE, WiMAX, SS7, H.323), dalam protokol jaringan (LDAP, SNMP, Kerberos), dalam segala hal Mengenai kriptografi (X.509, CMS, standar PKCS), dalam kartu bank dan paspor biometrik, dan banyak lagi. <br><br>  Artikel ini membahas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka PyDERASN</a> : Python ASN.1 yang digunakan secara aktif dalam proyek-proyek yang terkait dengan kriptografi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Atlas</a> . <br><br><div style="text-align:center;"><img alt="Saya sendiri" src="https://habrastorage.org/getpro/habr/post_images/7da/d0f/755/7dad0f755070999a4333d0206e830205.jpg"></div><a name="habracut"></a><br>  Bahkan, tidak layak merekomendasikan ASN.1 untuk tugas kriptografi: ASN.1 dan codec-nya yang kompleks.  Ini berarti bahwa kode tidak akan sederhana, tetapi selalu merupakan vektor serangan tambahan.  Lihat saja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar</a> kerentanan di pustaka ASN.1.  Bruce Schneier, dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rekayasa Kriptografinya,</a> juga tidak merekomendasikan penggunaan standar ini karena kerumitannya: "Pengkodean TLV yang paling terkenal adalah ASN.1, tetapi sangat rumit dan kami menghindarinya."  Tetapi, sayangnya, saat ini kami memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">infrastruktur kunci publik</a> di mana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sertifikat X.509</a> , CRL, OCSP, TSP, CMP, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CMC</a> , pesan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CMS</a> , dan banyak standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PKCS</a> digunakan secara aktif.  Oleh karena itu, Anda harus dapat bekerja dengan ASN.1 jika Anda melakukan sesuatu yang berhubungan dengan kriptografi. <br><br>  ASN.1 dapat dikodekan dalam berbagai cara / codec: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BER</a> (Aturan Pengkodean Dasar) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CER</a> (Aturan Penyandian Canonical) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DER</a> (Aturan Pengodean Terhormat) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GSER</a> (Aturan Penyandian String Generik) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JER</a> (JSON Encoding Rules) </li><li>  LWER (Aturan Pengodean Ringan) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OER</a> (Aturan Penyandian Oktet) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PER</a> (Aturan Pengkodean Terkemas) </li><li>  SER (Signaling Rules Encoding Rules) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">XER</a> (Aturan Pengkodean XML) </li></ul><br>  dan sejumlah lainnya.  Namun dalam tugas kriptografis dalam praktiknya, dua digunakan: BER dan DER.  Bahkan dalam dokumen XML yang ditandatangani ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">XMLDSig</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">XAdES</a> ) masih akan ada objek ASN.1 DER yang dikodekan oleh Base64, serta dalam protokol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ACME</a> berbasis JSON dari Let's Encrypt.  Anda dapat lebih memahami semua codec ini dan prinsip pengkodean BER / CER / DER dalam artikel dan buku: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ASN.1 dengan kata-kata sederhana</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ASN.1 - Komunikasi antara sistem heterogen oleh Olivier Dubuisson</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ASN.1 Lengkap oleh Prof John Larmouth</a> . <br><br>  BER adalah format TLV yang berorientasi byte biner (misalnya, PER, populer dalam komunikasi seluler - berorientasi bit).  Setiap elemen dikodekan dalam bentuk: tag ( <strong>T</strong> ag) yang mengidentifikasi jenis elemen yang dikodekan (integer, string, tanggal, dll.), Panjang ( <strong>L</strong> ength) dari konten dan konten itu sendiri ( <strong>V</strong> alue).  BER opsional memungkinkan Anda untuk tidak menentukan nilai panjang dengan menetapkan nilai panjang tak terbatas khusus dan berakhir dengan pesan Akhir Oktet.  Selain pengkodean panjang, BER memiliki banyak variabilitas dalam cara pengkodean tipe data, seperti: <br><br><ul><li>  INTEGER, IDENTIFIER OBYEK, BIT STRING dan panjang elemen mungkin tidak dinormalisasi (tidak dikodekan dalam bentuk minimal); </li><li>  BOOLEAN berlaku untuk semua konten yang bukan nol; </li><li>  BIT STRING mungkin mengandung "ekstra" nol bit; </li><li>  BIT STRING, OCTET STRING, dan semua jenis string turunannya, termasuk tanggal / waktu, dapat dibagi menjadi beberapa bagian (panjang) dengan panjang variabel, panjang yang selama (de) pengkodean tidak diketahui sebelumnya; </li><li>  UTCTime / GeneralizedTime dapat memiliki metode berbeda untuk mengatur offset zona waktu dan "ekstra" nol fraksi detik; </li><li>  Nilai-nilai URUTAN DEFAULT mungkin dikodekan atau tidak; </li><li>  Nilai yang disebutkan dari bit terakhir dalam BIT STRING dapat secara opsional dikodekan; </li><li>  URUTAN (OF) / SET (OF) dapat memiliki urutan elemen yang sewenang-wenang. </li></ul><br>  Untuk semua hal di atas, tidak selalu mungkin untuk menyandikan data sehingga identik dengan bentuk aslinya.  Oleh karena itu, bagian dari aturan diciptakan: DER adalah peraturan ketat dari hanya satu metode pengkodean yang valid, yang sangat penting untuk tugas kriptografi, di mana, misalnya, mengubah satu bit akan membatalkan tanda tangan atau checksum.  DER memiliki kelemahan yang signifikan: panjang semua elemen harus diketahui sebelumnya selama penyandian, yang tidak memungkinkan aliran serialisasi data.  Codec CER bebas dari kelemahan ini, juga menjamin penyajian data yang jelas.  Sayangnya (atau untungnya, kami tidak memiliki decoder yang lebih kompleks?), Itu tidak menjadi populer.  Oleh karena itu, dalam praktiknya, kami menemukan penggunaan data ber-enkode BER dan DER "campuran".  Karena CER dan DER adalah subset dari BER, setiap decoder BER dapat memprosesnya. <br><br><h2>  Masalah dengan pyasn1 </h2><br>  Di tempat kerja, kami menulis banyak program Python yang terkait dengan kriptografi.  Dan beberapa tahun yang lalu praktis tidak ada pilihan perpustakaan gratis: baik ini perpustakaan tingkat sangat rendah yang memungkinkan Anda untuk menyandikan / mendekode, misalnya, bilangan bulat dan header struktur, atau ini adalah perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pyasn1</a> .  Kami hidup di sana selama beberapa tahun dan pada awalnya sangat puas, karena memungkinkan Anda untuk bekerja dengan struktur ASN.1 sebagai objek tingkat tinggi: misalnya, objek sertifikat X.509 yang didekodekan memungkinkan Anda untuk mengakses bidangnya melalui antarmuka kamus: cert ["tbsCertificate"] ["SerialNumber"] akan menunjukkan nomor seri sertifikat ini kepada kami.  Demikian pula, Anda dapat "mengumpulkan" objek kompleks dengan bekerja dengannya seperti dengan daftar, kamus, dan kemudian cukup memanggil fungsi pyasn1.codec.der.encoder.encode dan mendapatkan representasi serial dokumen. <br><br>  Namun, kelemahan, masalah dan keterbatasan terungkap.  Ada dan, sayangnya, kesalahan masih tetap ada di pyasn1: pada saat penulisan, di pyasn1, salah satu tipe dasar, GeneralizedTime, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">salah</a> didekodekan dan disandikan. <br><br>  Dalam proyek kami, untuk menghemat ruang, kami sering menyimpan hanya path ke file, offset dan panjang dalam byte dari objek yang ingin kita rujuk.  Misalnya, file bertanda tangan sewenang-wenang kemungkinan besar akan terletak di struktur CMS SignedData ASN.1: <br><br><pre><code class="plaintext hljs">0 [1,3,1018] ContentInfo SEQUENCE 4 [1,1, 9] . contentType: ContentType OBJECT IDENTIFIER 1.2.840.113549.1.7.2 (id_signedData) 19-4 [0,0,1003] . content: [0] EXPLICIT [UNIV 16] ANY 19 [1,3, 999] . . DEFINED BY id_signedData: SignedData SEQUENCE 23 [1,1, 1] . . . version: CMSVersion INTEGER v3 (03) 26 [1,1, 19] . . . digestAlgorithms: DigestAlgorithmIdentifiers SET OF [...] 47 [1,3, 769] . . . encapContentInfo: EncapsulatedContentInfo SEQUENCE 51 [1,1, 8] . . . . eContentType: ContentType OBJECT IDENTIFIER 1.3.6.1.5.5.7.12.2 (id_cct_PKIData) 65-4 [1,3, 751] . . . . eContent: [0] EXPLICIT OCTET STRING 751 bytes OPTIONAL      751  820 [1,2, 199] . . . signerInfos: SignerInfos SET OF 823 [1,2, 196] . . . . 0: SignerInfo SEQUENCE 826 [1,1, 1] . . . . . version: CMSVersion INTEGER v3 (03) 829 [0,0, 22] . . . . . sid: SignerIdentifier CHOICE subjectKeyIdentifier [...] 956 [1,1, 64] . . . . . signature: SignatureValue OCTET STRING 64 bytes . . . . . . C1:B3:88:BA:F8:92:1C:E6:3E:41:9B:E0:D3:E9:AF:D8 . . . . . . 47:4A:8A:9D:94:5D:56:6B:F0:C1:20:38:D2:72:22:12 . . . . . . 9F:76:46:F6:51:5F:9A:8D:BF:D7:A6:9B:FD:C5:DA:D2 . . . . . . F3:6B:00:14:A4:9D:D7:B5:E1:A6:86:44:86:A7:E8:C9</code> </pre> <br>  dan kita bisa mendapatkan file yang ditandatangani asli dengan offset 65 byte, panjang 751 byte.  pyasn1 tidak menyimpan informasi ini dalam objek yang diterjemahkan.  Yang disebut TLVSeeker ditulis - perpustakaan kecil yang memungkinkan Anda untuk men-decode tag dan panjang objek, di antarmuka yang kami pesan "pergi ke tag berikutnya", "masuk ke dalam tag" (masuk ke dalam URUTAN objek), "buka tag berikutnya", "beri tahu Anda mengimbangi dan panjang objek di mana kita berada. "  Itu adalah "manual" berjalan pada ASN.1 data DER-serial.  Tetapi tidak mungkin untuk bekerja dengan data berseri-BER dengan cara ini, karena, misalnya, string byte OCTET STRING dapat dikodekan sebagai beberapa chunk-s. <br><br>  Kelemahan lain untuk tugas pyasn1 kami adalah ketidakmampuan untuk memahami dari objek yang didekodekan apakah bidang yang diberikan hadir dalam URUTAN atau tidak.  Misalnya, jika struktur berisi bidang URUTAN KETIGA Bidang OPSIONAL, maka bisa sepenuhnya tidak ada dalam data yang diterima (OPSIONAL), tetapi bisa hadir, tetapi pada saat yang sama menjadi panjang nol (daftar kosong).  Dalam kasus umum, ini tidak dapat diklarifikasi.  Dan ini diperlukan untuk pemeriksaan ketat keabsahan data yang diterima.  Bayangkan bahwa beberapa otoritas sertifikasi akan mengeluarkan sertifikat dengan data yang "tidak sepenuhnya" valid dari sudut pandang skema ASN.1!  Sebagai contoh, otoritas sertifikasi TÜRKTRUST Elektronik Sertifika Hizmet Sağlayıcısı dalam sertifikat rootnya melampaui batas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC 5280 yang</a> diizinkan untuk panjang komponen subjek - tidak dapat secara jujur ​​didekodekan sesuai dengan skema.  Codec DER mensyaratkan bahwa bidang yang nilainya DEFAULT tidak dikodekan selama transmisi - dokumen tersebut ditemukan dalam kehidupan, dan versi pertama PyDERASN bahkan secara sadar mengizinkan perilaku yang tidak valid (dari sudut pandang DER) demi kompatibilitas ke belakang. <br><br>  Keterbatasan lain adalah ketidakmampuan untuk dengan mudah menemukan dalam bentuk mana (BER / DER) satu atau objek lain dikodekan dalam struktur.  Sebagai contoh, standar CMS mengatakan bahwa pesan dikodekan BER, tetapi bidang signedAttrs, di mana tanda tangan kriptografi terbentuk, harus dalam DER.  Jika kita mendekode dengan DER, maka kita akan jatuh pada pemrosesan CMS itu sendiri, jika kita decode dengan BER, kita tidak akan tahu dalam bentuk apa yang ditandatangani Autodes.  Akibatnya, TLVSeeker perlu (analog yang tidak ada dalam pyasn1) untuk mencari lokasi masing-masing bidang yang ditandatangani, dan harus diterjemahkan secara terpisah oleh DER dari tampilan serial. <br><br>  Kemungkinan pemrosesan otomatis bidang DEFINED BY, yang sangat umum, sangat diinginkan bagi kami.  Setelah mendekode struktur ASN.1, kami mungkin memiliki banyak bidang APA PUN yang tersisa, yang harus diproses lebih lanjut sesuai dengan skema yang dipilih berdasarkan OBJECT IDENTIFIER yang ditentukan dalam bidang struktur.  Dalam kode Python, ini berarti menulis jika dan kemudian memanggil dekoder untuk bidang APA PUN. <br><br><h2>  Munculnya PyDERASN </h2><br>  Di Atlas, kami secara teratur, setelah menemukan masalah atau memodifikasi program gratis yang digunakan, mengirim tambalan ke atas.  Di pyasn1, kami mengirim perbaikan beberapa kali, tetapi kode pyasn1 bukan yang termudah untuk dipahami, dan terkadang perubahan API yang tidak kompatibel terjadi di dalamnya, yang langsung menimpa kami.  Plus, kita terbiasa menulis tes dengan pengujian generatif, yang tidak terjadi di pyasn1. <br><br>  Suatu hari, saya memutuskan bahwa saya harus menanggung ini dan sudah waktunya untuk mencoba menulis perpustakaan saya sendiri dengan __slot __s, offset s, dan gumpalan yang ditampilkan dengan indah!  Hanya membuat ASN.1 codec tidak akan cukup - Anda perlu mentransfer semua proyek dependen kami ke sana, dan ini adalah ratusan ribu baris kode di mana ada banyak pekerjaan dengan struktur ASN.1.  Itu adalah salah satu persyaratan untuk itu: kemudahan terjemahan kode pyasn1 saat ini.  Setelah menghabiskan seluruh liburan saya, saya menulis perpustakaan ini, memindahkan semua proyek ke sana.  Karena mereka memiliki cakupan hampir 100% melalui tes, ini juga berarti perpustakaan itu sepenuhnya operasional. <br><br>  PyDERASN, juga, memiliki cakupan tes hampir 100%.  Pengujian generatif digunakan dengan pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hipotesis yang</a> luar biasa.  Juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengelabui piringan</a> pada 32 mesin nuklir juga dilakukan.  Terlepas dari kenyataan bahwa kita hampir tidak memiliki kode Python2 yang tersisa, PyDERASN masih mempertahankan kompatibilitas dengannya dan karena ini ia memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">enam</a> ketergantungan tunggal.  Selain itu, ini diuji terhadap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ASN.1: 2008 test suite kepatuhan</a> . <br><br>  Prinsip bekerja dengannya mirip dengan pyasn1 - bekerja dengan objek Python tingkat tinggi.  Deskripsi sirkuit ASN.1 serupa. <br><br><pre> <code class="plaintext hljs">class TBSCertificate(Sequence): schema = ( ("version", Version(expl=tag_ctxc(0), default="v1")), ("serialNumber", CertificateSerialNumber()), ("signature", AlgorithmIdentifier()), ("issuer", Name()), ("validity", Validity()), ("subject", Name()), ("subjectPublicKeyInfo", SubjectPublicKeyInfo()), ("issuerUniqueID", UniqueIdentifier(impl=tag_ctxp(1), optional=True)), ("subjectUniqueID", UniqueIdentifier(impl=tag_ctxp(2), optional=True)), ("extensions", Extensions(expl=tag_ctxc(3), optional=True)), )</code> </pre><br>  Namun, PyDERASN memiliki kemiripan dalam pengetikan yang kuat.  Dalam pyasn1, jika bidangnya bertipe CMSVersion (INTEGER), maka itu bisa diberikan int atau INTEGER.  PyDERASN secara ketat mensyaratkan bahwa objek yang ditugaskan tepat CMSVersion.  Selain menulis kode Python3, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">anotasi pengetikan</a> , sehingga fungsi kami tidak akan memiliki argumen yang tidak dapat dipahami seperti def func (serial, konten), tetapi def func (serial: CertificateSerialNumber, konten: EncapsulatedContentInfo), dan PyDERASN membantu melacak kode. <br><br>  Pada saat yang sama, PyDERASN memiliki konsesi yang sangat nyaman untuk mengetik ini.  pyasn1 tidak mengizinkan subtitle SubjectKeyIdentifier (). (implitTag = Tag (...)) untuk menetapkan objek SubjectKeyIdentifier () (tanpa TAG IMPLICIT yang diperlukan) dan sering harus menyalin dan membuat ulang objek hanya karena tag IMPLICIT / EXPLICIT yang diubah.  PyDERASN secara ketat hanya mengamati tipe dasar - itu akan secara otomatis mengganti tag dari struktur ASN.1 yang ada.  Ini sangat menyederhanakan kode aplikasi. <br><br>  Jika kesalahan terjadi selama decoding, maka dalam pyasn1 tidak mudah untuk memahami persis di mana itu terjadi.  Sebagai contoh, dalam sertifikat Turki yang telah disebutkan, kita mendapatkan kesalahan ini: UTF8String (tbsCertificate: penerbit: rdnSequence: 3: 0: value: DEFINED OLEH 2.5.4.10:utf8String) (at 138) batas tidak puas: 1 ⇐ 77 ⇐ 64 Saat menulis ASN .1 struktur orang dapat membuat kesalahan, dan itu membantu lebih mudah untuk men-debug aplikasi atau menemukan masalah dokumen yang disandikan dari sisi yang berlawanan. <br><br>  Versi pertama PyDERASN tidak mendukung pengkodean BER.  Itu muncul jauh kemudian dan pemrosesan UTCTime / GeneralizedTime dengan zona waktu masih tidak didukung.  Ini akan datang di masa depan, karena proyek ini ditulis terutama di waktu luang. <br><br>  Juga di versi pertama tidak ada pekerjaan dengan bidang DEFINED BY.  Beberapa bulan kemudian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kesempatan</a> ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">muncul</a> dan mulai digunakan secara aktif, secara signifikan mengurangi kode aplikasi - dalam satu operasi decoding, dimungkinkan untuk membuat seluruh struktur dibongkar sampai sangat dalam.  Untuk melakukan ini, dalam skema, bidang mana yang didefinisikan yang "menentukan".  Misalnya, deskripsi skema CMS: <br><br><pre> <code class="plaintext hljs">class ContentInfo(Sequence): schema = ( ("contentType", ContentType(defines=((("content",), { id_authenticatedData: AuthenticatedData(), id_digestedData: DigestedData(), id_encryptedData: EncryptedData(), id_envelopedData: EnvelopedData(), id_signedData: SignedData(), }),))), ("content", Any(expl=tag_ctxc(0))), )</code> </pre><br>  mengatakan bahwa jika contentType berisi OID dengan id_signedData, maka bidang konten (terletak di SEQUENCE yang sama) perlu diterjemahkan dengan menggunakan skema SignedData.  Mengapa ada begitu banyak tanda kurung?  Bidang dapat "mendefinisikan" beberapa bidang sekaligus, seperti halnya dalam struktur EnvelopedData.  Bidang yang ditentukan diidentifikasi oleh yang disebut jalur decode - ini menetapkan lokasi yang tepat dari setiap elemen di semua struktur. <br><br>  Tidak selalu diinginkan atau tidak selalu memungkinkan untuk segera memperkenalkan definisi ini ke dalam rangkaian.  Mungkin ada kasus khusus aplikasi di mana OID dan struktur hanya diketahui dalam proyek pihak ketiga.  PyDERASN menyediakan kemampuan untuk menentukan definisi ini tepat pada saat mendekode struktur: <br><br><pre> <code class="plaintext hljs">ContentInfo().decode(data, ctx={"defines_by_path": (( ( "content", DecodePathDefBy(id_signedData), "certificates", any, "certificate", "tbsCertificate", "extensions", any, "extnID", ), ((("extnValue",), { id_ce_authorityKeyIdentifier: AuthorityKeyIdentifier(), id_ce_basicConstraints: BasicConstraints(), [...] id_ru_subjectSignTool: SubjectSignTool(), }),), ),)})</code> </pre><br>  Di sini kita mengatakan bahwa dalam CMS SignedData untuk semua sertifikat yang dilampirkan, dekode semua ekstensi mereka (AuthorityKeyIdentifier, BasicConstraints, SubjectSignTool, dll.).  Kami menunjukkan melalui jalur decode yang elemen untuk "menggantikan" mendefinisikan, seolah-olah itu didefinisikan dalam rangkaian. <br><br>  Akhirnya, PyDERASN memiliki kemampuan untuk bekerja dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">baris perintah</a> untuk memecahkan kode file ASN.1 dan memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencetakan yang cukup</a> kaya.  Anda dapat mendekodekan ASN.1 yang sewenang-wenang, atau Anda dapat menentukan skema yang jelas dan melihat sesuatu seperti ini: <br><br><img alt="Contoh pencetakan yang cantik" src="https://habrastorage.org/getpro/habr/post_images/3dc/981/000/3dc981000f30512bf2ca9488332345d4.png"><br><br>  Informasi yang ditampilkan: offset objek, panjang tag, panjang tag, panjang konten, keberadaan EOC (akhir oktet), bendera enkode BER, bendera enkode panjang tidak terbatas, panjang tag EXPLICIT dan offset (jika ada), kedalaman objek bersarang di struktur, nilai tag IMPLICIT / EXPLICIT, nama objek sesuai dengan skema, tipe ASN.1 dasarnya, nomor seri di dalam URUTAN / SET, nilai PILIHAN (jika ada), nama yang dapat dibaca manusia INTEGER / ENUMERATED / BIT STRING sesuai dengan skema, nilai dari semua tipe dasar , Bendera DEFAULT / OPTIONAL dari sirkuit, tanda bahwa objek secara otomatis diterjemahkan sebagai DITETAPKAN oleh dan setelah  gm dari OID-dan itu terjadi, chelovekochitaemy OID. <br><br>  Sistem pencetakan cantik dibuat khusus sehingga menghasilkan urutan objek PP yang sudah divisualisasikan dengan cara yang terpisah.  Tangkapan layar memperlihatkan renderer dalam teks berwarna polos.  Ada renderers dalam format JSON / HTML sehingga ini dapat dilihat dengan menyoroti di browser ASN.1 seperti dalam proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">asn1js</a> . <br><br><h2>  Perpustakaan lain </h2><br>  Ini bukan tujuan, tetapi PyDERASN secara signifikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih cepat</a> daripada pyasn1.  Misalnya, mendekode file CRL dengan ukuran megabyte dapat berlangsung sangat lama sehingga Anda harus memikirkan format perantara untuk menyimpan data (cepat) dan mengubah arsitektur aplikasi.  pyasn1 menerjemahkan CRL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CACert.org</a> di laptop saya selama lebih dari 20 menit, sementara PyDERASN hanya dalam 28 detik!  Ada proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">asn1crypto yang</a> bertujuan untuk bekerja dengan cepat dengan struktur kriptografi: ia menerjemahkan (sepenuhnya, tidak malas) CRL yang sama dalam 29 detik, tetapi mengkonsumsi RAM hampir dua kali lebih banyak ketika berjalan di bawah Python3 (983 MiB versus 498), dan 3,5 kali di bawah Python2 (1677 melawan 488), sementara pyasn1 mengkonsumsi sebanyak 4,3 kali lebih banyak (2093 melawan 488). <br><br>  asn1crypto, yang saya sebutkan, kami tidak mempertimbangkan, karena proyek ini masih dalam masa pertumbuhan, dan kami belum pernah mendengarnya.  Sekarang mereka tidak akan mulai melihat ke arahnya juga, karena saya segera menemukan bahwa GeneralizedTime yang sama tidak mengambil tampilan sewenang-wenang, dan ketika serialisasi, diam-diam menghilangkan sebagian kecil dari satu detik.  Ini dapat diterima untuk bekerja dengan sertifikat X.509, tetapi secara umum itu tidak akan berfungsi. <br><br>  Saat ini, PyDERASN adalah yang paling ketat dari dekoder Python / Go DER gratis yang saya tahu.  Di perpustakaan pengkodean / asn1 Go favorit saya, tidak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada pemeriksaan ketat pada</a> OBJECT IDENTIFIER dan string UTCTime / GeneralizedTime.  Kadang-kadang keketatan dapat mengganggu (pertama-tama, karena kompatibilitas ke belakang dengan aplikasi lama yang tidak akan diperbaiki oleh siapa pun), sehingga dalam PyDERASN selama decoding Anda dapat melewati <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbagai pengaturan yang</a> melemahkan pemeriksaan. <br><br>  Kode proyek berusaha sesederhana mungkin.  Seluruh perpustakaan adalah satu file.  Kode ini ditulis dengan penekanan pada kemudahan pemahaman, tanpa kinerja yang tidak perlu dan optimasi kode KERING.  Itu tidak, seperti yang sudah saya katakan, mendukung decoding BER penuh dari string UTCTime / GeneralizedTime, serta REAL, OEL RELATIF, EKSTERNAL, MASING-MASING, EMBEDDED PDV, CHARACTER STRING tipe data.  Dalam semua kasus lain, secara pribadi, saya tidak melihat alasan untuk menggunakan perpustakaan lain dengan Python. <br><br>  Seperti semua proyek saya, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PyGOST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GoGOST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NNCP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GoVPN</a> , PyDERASN benar-benar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perangkat lunak gratis yang</a> didistribusikan di bawah ketentuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LGPLv3 +</a> , dan tersedia untuk diunduh gratis.  Contoh penggunaan ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tes PyGOST</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sergey Matveev</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bank sandi</a> , anggota <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yayasan Yayasan</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masyarakat Terbuka</a> , Pengembang Python / Go, kepala spesialis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FSUE "Pusat Ilmiah dan Teknis" Atlas "</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444272/">https://habr.com/ru/post/id444272/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444260/index.html">Kami sedang mengembangkan sistem untuk mengevaluasi pekerjaan agen pendukung</a></li>
<li><a href="../id444262/index.html">Kode sumber Markdown2pdf untuk Linux</a></li>
<li><a href="../id444264/index.html">Bagaimana menjadi pengendara dan apakah Anda benar-benar membutuhkannya</a></li>
<li><a href="../id444268/index.html">Minggu Keamanan 12: Serangan Keyboard</a></li>
<li><a href="../id444270/index.html">Group-IB Webinar "Pendekatan Grup-IB untuk Pendidikan Dunia Maya: Tinjauan Umum Program Saat Ini dan Kasus Praktis"</a></li>
<li><a href="../id444274/index.html">Sebuah jawaban terperinci untuk komentar tersebut, serta sedikit tentang kehidupan penyedia di Federasi Rusia</a></li>
<li><a href="../id444276/index.html">Pengenalan Arsitektur Fiber</a></li>
<li><a href="../id444278/index.html">Cara membuat puluhan ribu orang membaca artikel berbahasa Inggris Anda untuk Habr: 3 tips sederhana</a></li>
<li><a href="../id444282/index.html">7 Ekstensi Chrome Untuk Belajar Bahasa Inggris</a></li>
<li><a href="../id444284/index.html">komposer dan penyelesaian baris perintah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>