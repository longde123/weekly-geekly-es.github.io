<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😛 🔵 🦁 我们在Go中处理接口 💡 👦🏿 🐪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在过去的几个月中，我一直在进行一项研究，询问人们在Go中难于理解的内容。 而且我注意到答案中经常提到接口的概念。 Go是我使用的第一种界面语言，我记得那时这个概念似乎很混乱。 在本指南中，我想这样做： 



1. 用人类语言解释什么是接口。 
2. 解释它们的用处以及如何在代码中使用它们。 
3....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们在Go中处理接口</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/463063/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_f/w7/1l/_fw71luza3o_kj1bh6t015wlp4c.jpeg"></div><br> 在过去的几个月中，我一直在进行一项<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">研究，</a>询问人们在Go中难于理解的内容。 而且我注意到答案中经常提到接口的概念。  Go是我使用的第一种界面语言，我记得那时这个概念似乎很混乱。 在本指南中，我想这样做： <br><br><ol><li> 用人类语言解释什么是接口。 </li><li> 解释它们的用处以及如何在代码中使用它们。 </li><li>讨论<code>interface{}</code>什么（一个空接口）。 </li><li> 并逐步介绍一些在标准库中可以找到的有用的接口类型。 </li></ol><a name="habracut"></a><br><h2> 那么什么是接口？ </h2><br>  Go中的接口类型是一种<i>定义</i> 。 它定义并描述了<i>某些其他类型应具有</i>的特定方法。 <br><br> 标准库中的接口类型之一是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">fmt.Stringer</a>接口： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Stringer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { String() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br> 我们说，如果某个“东西”具有带有特定签名字符串值<code>String()</code>的方法，则<i>满足该接口</i> （或<i>实现此接口</i> ）的东西。 <br><br> 例如， <code>Book</code>类型满足接口，因为它具有<code>String()</code>字符串方法： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Book <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Author <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b Book)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">String</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"Book: %s - %s"</span></span>, b.Title, b.Author) }</code> </pre> <br>  <code>Book</code>类型或功能无关紧要。 重要的是它具有一个称为<code>String()</code>的方法，该方法返回字符串值。 <br><br> 这是另一个例子。  <code>Count</code>类型也<i>满足</i> <code>fmt.Stringer</code> <i>接口，</i>因为它具有具有相同签名字符串值<code>String()</code> 。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Count <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c Count)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">String</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strconv.Itoa(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(c)) }</code> </pre> <br> 在这里必须了解，我们有两种不同类型的<code>Book</code>和<code>Count</code> ，它们的行为不同。 但是它们都满足于<code>fmt.Stringer</code>接口这一事实使它们团结在一起。 <br><br> 您可以从另一侧看它。 如果知道对象满足<code>fmt.Stringer</code>接口，则可以假定它具有可以调用的带有签名字符串值<code>String()</code>的方法。 <br><br> 现在最重要的是。 <br><br>  <i>当您在Go（变量，函数参数或结构字段的声明）中看到具有接口类型的声明时，可以使用任何类型的对象，只要它满足该接口。</i> <br><br> 假设我们有一个函数： <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s fmt.Stringer)</span></span></span></span> { log.Println(s.String()) }</code> </pre> <br> 由于<code>WriteLog()</code>在参数<code>fmt.Stringer</code>使用接口类型<code>fmt.Stringer</code> ，因此我们可以传递任何满足<code>fmt.Stringer</code>接口的对象。 例如，我们可以传递之前在<code>WriteLog()</code>方法中创建的<code>Book</code>和<code>Count</code>类型，代码可以正常工作。 <br><br> 另外，由于传递的对象满足<code>fmt.Stringer</code>接口，因此我们<i>知道</i>它具有<code>String()</code>方法，可以通过<code>WriteLog()</code>函数安全地调用该方法。 <br><br> 让我们将其汇总为一个示例，以演示接口的功能。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//   Book,    fmt.Stringer. type Book struct { Title string Author string } func (b Book) String() string { return fmt.Sprintf("Book: %s - %s", b.Title, b.Author) } //   Count,    fmt.Stringer. type Count int func (c Count) String() string { return strconv.Itoa(int(c)) } //   WriteLog(),    , //   fmt.Stringer   . func WriteLog(s fmt.Stringer) { log.Println(s.String()) } func main() { //   Book    WriteLog(). book := Book{"Alice in Wonderland", "Lewis Carrol"} WriteLog(book) //   Count    WriteLog(). count := Count(3) WriteLog(count) }</span></span></code> </pre> <br> 太棒了 在主函数中，我们创建了不同类型的<code>Book</code>和<code>Count</code> ，但是将它们传递给了<i>相同的</i> <code>WriteLog()</code>函数。 她调用了适当的<code>String()</code>函数，并将结果写入日志。 <br><br> 如果<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">执行代码</a> ，您将得到类似的结果： <br><br><pre> <code class="plaintext hljs">2009/11/10 23:00:00 Book: Alice in Wonderland - Lewis Carrol 2009/11/10 23:00:00 3</code> </pre> <br> 我们将不对此进行详细介绍。 要记住的主要事情：在<code>WriteLog()</code>函数的声明中使用接口类型，我们使函数对接收到的对象的<i>类型</i>无动于衷（或灵活）。 重要的是<i>他有什么方法</i> 。 <br><br><h2> 什么是有用的界面？ </h2><br> 您可以在Go中开始使用界面的原因有很多。 以我的经验，最重要的是： <br><br><ol><li> 接口有助于减少重复，即减少样板代码的数量。 </li><li> 它们使在单元测试中代替实际对象更容易使用存根。 </li><li> 作为一种架构工具，界面可帮助解开部分代码库。 </li></ol><br> 让我们仔细看看这些使用接口的方式。 <br><br><h3> 减少样板代码量 </h3><br> 假设我们有一个包含某种客户数据的<code>Customer</code>结构。 在代码的一部分中，我们希望将此信息写入<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bytes.Buffer</a> ，在另一部分中，我们要将客户端数据写入磁盘上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">os.File</a> 。 但是，在两种情况下，我们都希望首先将<code>ustomer</code>结构序列化为JSON。 <br><br> 在这种情况下，我们可以使用Go接口减少样板代码的数量。 <br><br>  Go具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">io.Writer</a>接口类型： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Writer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Write(p []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (n <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, err error) }</code> </pre> <br> 我们可以利用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bytes.Buffer</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">os.File</a>类型满足此接口的事实，因为它们分别具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bytes.Buffer.Write（）</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">os.File.Write（）</a>方法。 <br><br> 简单实施： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//   Customer. type Customer struct { Name string Age int } //   WriteJSON,   io.Writer   . //    ustomer  JSON,     // ,     Write()  io.Writer. func (c *Customer) WriteJSON(w io.Writer) error { js, err := json.Marshal(c) if err != nil { return err } _, err = w.Write(js) return err } func main() { //   Customer. c := &amp;Customer{Name: "Alice", Age: 21} //    Buffer    WriteJSON var buf bytes.Buffer err := c.WriteJSON(buf) if err != nil { log.Fatal(err) } //   . f, err := os.Create("/tmp/customer") if err != nil { log.Fatal(err) } defer f.Close() err = c.WriteJSON(f) if err != nil { log.Fatal(err) } }</span></span></code> </pre> <br> 当然，这只是一个虚构的示例（我们可以以不同的方式构造代码以获得相同的结果）。 但这很好地说明了使用接口的优点：我们可以创建一次<code>Customer.WriteJSON()</code>方法，并在每次需要写入满足<code>io.Writer</code>接口的内容时调用它。 <br><br> 但是，如果您<i>不熟悉</i> Go，您将有两个问题：“ <i>我怎么知道io.Writer接口是否存在？</i>  <i>以及您如何预先知道他对<code>bytes.Buffer</code>和<code>os.File</code>感到满意？</i>  ” <br><br> 恐怕没有简单的解决方案。 您只需要获取经验，熟悉标准库中的接口和不同类型即可。 这将有助于阅读该库的文档并查看其他人的代码。 为了快速参考，我在文章结尾添加了最有用的接口类型。 <br><br> 但是，即使您不使用标准库中的接口，也不会阻止您创建和使用<i>自己的接口类型</i> 。 我们将在下面讨论。 <br><br><h3> 单元测试和存根 </h3><br> 要了解接口如何在单元测试中提供帮助，我们来看一个更复杂的示例。 <br><br> 假设您有一家商店，并在PostgreSQL中存储有关销售和客户数量的信息。 您想编写一个代码，计算最后一天的销售份额（每个客户的特定销售数量），四舍五入到小数点后两位。 <br><br> 最小的实现如下所示： <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// : main.go package main import ( "fmt" "log" "time" "database/sql" _ "github.com/lib/pq" ) type ShopDB struct { *sql.DB } func (sdb *ShopDB) CountCustomers(since time.Time) (int, error) { var count int err := sdb.QueryRow("SELECT count(*) FROM customers WHERE timestamp &gt; $1", since).Scan(&amp;count) return count, err } func (sdb *ShopDB) CountSales(since time.Time) (int, error) { var count int err := sdb.QueryRow("SELECT count(*) FROM sales WHERE timestamp &gt; $1", since).Scan(&amp;count) return count, err } func main() { db, err := sql.Open("postgres", "postgres://user:pass@localhost/db") if err != nil { log.Fatal(err) } defer db.Close() shopDB := &amp;ShopDB{db} sr, err := calculateSalesRate(shopDB) if err != nil { log.Fatal(err) } fmt.Printf(sr) } func calculateSalesRate(sdb *ShopDB) (string, error) { since := time.Now().Sub(24 * time.Hour) sales, err := sdb.CountSales(since) if err != nil { return "", err } customers, err := sdb.CountCustomers(since) if err != nil { return "", err } rate := float64(sales) / float64(customers) return fmt.Sprintf("%.2f", rate), nil }</span></span></code> </pre> <br> 现在，我们要为<code>calculateSalesRate()</code>函数创建一个单元测试，以验证计算是否正确。 <br><br> 现在有问题了。 我们将需要配置PostgreSQL的测试实例，以及创建和删除脚本以用假数据填充数据库。 如果我们真的想测试我们的计算，我们还有很多工作要做。 <br><br> 接口可以解救！ <br><br> 我们将创建自己的接口类型，以描述<code>CountSales()</code>和<code>CountCustomers()</code>方法， <code>calculateSalesRate()</code>函数所依赖的接口类型。 然后更新签名<code>calculateSalesRate()</code>以将此接口类型用作参数，而不是指定的<code>*ShopDB</code>类型。 <br><br> 像这样： <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// : main.go package main import ( "fmt" "log" "time" "database/sql" _ "github.com/lib/pq" ) //    ShopModel.     //     ,     //  -,     . type ShopModel interface { CountCustomers(time.Time) (int, error) CountSales(time.Time) (int, error) } //  ShopDB    ShopModel,   //       -- CountCustomers()  CountSales(). type ShopDB struct { *sql.DB } func (sdb *ShopDB) CountCustomers(since time.Time) (int, error) { var count int err := sdb.QueryRow("SELECT count(*) FROM customers WHERE timestamp &gt; $1", since).Scan(&amp;count) return count, err } func (sdb *ShopDB) CountSales(since time.Time) (int, error) { var count int err := sdb.QueryRow("SELECT count(*) FROM sales WHERE timestamp &gt; $1", since).Scan(&amp;count) return count, err } func main() { db, err := sql.Open("postgres", "postgres://user:pass@localhost/db") if err != nil { log.Fatal(err) } defer db.Close() shopDB := &amp;ShopDB{db} sr := calculateSalesRate(shopDB) fmt.Printf(sr) } //       ShopModel    //    *ShopDB. func calculateSalesRate(sm ShopModel) string { since := time.Now().Sub(24 * time.Hour) sales, err := sm.CountSales(since) if err != nil { return "", err } customers, err := sm.CountCustomers(since) if err != nil { return "", err } rate := float64(sales) / float64(customers) return fmt.Sprintf("%.2f", rate), nil }</span></span></code> </pre> <br> 完成此操作后，我们将只创建一个满足<code>ShopModel</code>接口的存根。 然后，您可以在函数<code>calculateSalesRate()</code>对数学逻辑的正确操作进行单元测试时使用它。 像这样： <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// : main_test.go package main import ( "testing" ) type MockShopDB struct{} func (m *MockShopDB) CountCustomers() (int, error) { return 1000, nil } func (m *MockShopDB) CountSales() (int, error) { return 333, nil } func TestCalculateSalesRate(t *testing.T) { //  . m := &amp;MockShopDB{} //     calculateSalesRate(). sr := calculateSalesRate(m) // ,        //   . exp := "0.33" if sr != exp { t.Fatalf("got %v; expected %v", sr, exp) } }</span></span></code> </pre> <br> 现在运行测试，一切正常。 <br><br><h3> 应用架构 </h3><br> 在前面的示例中，我们看到了如何使用接口将代码的某些部分与使用特定类型分离。 例如，只要满足<code>ShopModel</code>接口，那么<code>calculateSalesRate()</code>函数对您传递的内容<code>ShopModel</code> 。 <br><br> 您可以扩展这个想法，并在大型项目中创建整个“统一”级别。 <br> 假设您正在创建一个与数据库交互的Web应用程序。 如果您创建一个描述与数据库交互的特定方法的接口，则可以通过HTTP处理程序而不是特定类型来引用该接口。 由于HTTP处理程序仅引用该接口，因此这将有助于彼此断开HTTP级别和与数据库的交互级别的链接。 独立处理关卡将更加容易，并且将来您将能够替换某些关卡而不会影响其他关卡的工作。 <br><br> 我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在之前的一篇文章中</a>介绍了这种模式， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其中</a>有更多详细信息和实际示例。 <br><br><h2> 什么是空接口？ </h2><br> 如果您已经在Go上编程了一段时间，那么您可能会遇到一个<i>空的接口类型</i> <code>interface{}</code> 。 我将尝试解释它是什么。 在本文开头，我写道： <br><br><blockquote>  Go中的接口类型是一种<i>定义</i> 。 它定义并描述了<i>某些其他类型应具有</i>的特定方法。 </blockquote><br> 空的接口类型<i>不能描述方法</i> 。 他没有规矩。 因此，任何对象都满足一个空接口。 <br><br> 本质上，空接口类型<code>interface{}</code>是一种玩笑。 如果在声明（变量，函数参数或结构字段）中遇到它，则可以使用<i>任何类型</i>的对象。 <br><br> 考虑以下代码： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { person := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, <span class="hljs-number"><span class="hljs-number">0</span></span>) person[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"Alice"</span></span> person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = <span class="hljs-number"><span class="hljs-number">21</span></span> person[<span class="hljs-string"><span class="hljs-string">"height"</span></span>] = <span class="hljs-number"><span class="hljs-number">167.64</span></span> fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%+v"</span></span>, person) }</code> </pre> <br> 在这里，我们将地图初始化为<code>person</code> ，它使用字符串类型的键和空接口类型的<code>interface{}</code>作为值。 我们为映射值分配了三种不同类型（字符串，整数和float32），这没有问题。 由于任何类型的对象都满足空接口，因此代码可以很好地工作。 <br><br> 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处运行此代码</a> ，您将看到类似的结果： <br><br><pre> <code class="plaintext hljs">map[age:21 height:167.64 name:Alice]</code> </pre> <br> 在从地图中提取和使用值时，请务必牢记这一点。 假设您要获取<code>age</code>值并将其增加1。如果您编写类似的代码，则它将无法编译： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { person := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, <span class="hljs-number"><span class="hljs-number">0</span></span>) person[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"Alice"</span></span> person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = <span class="hljs-number"><span class="hljs-number">21</span></span> person[<span class="hljs-string"><span class="hljs-string">"height"</span></span>] = <span class="hljs-number"><span class="hljs-number">167.64</span></span> person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span> fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%+v"</span></span>, person) }</code> </pre> <br> 您将收到一条错误消息： <br><br><pre> <code class="plaintext hljs">invalid operation: person["age"] + 1 (mismatched types interface {} and int)</code> </pre> <br> 原因是存储在map中的值采用<code>interface{}</code>类型，并失去了其原始的基本int类型。 并且由于该值不再是整数，因此我们无法对其加1。 <br><br> 为了解决这个问题，您需要再次使该值成为整数，然后才可以使用它： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { person := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}, <span class="hljs-number"><span class="hljs-number">0</span></span>) person[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"Alice"</span></span> person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = <span class="hljs-number"><span class="hljs-number">21</span></span> person[<span class="hljs-string"><span class="hljs-string">"height"</span></span>] = <span class="hljs-number"><span class="hljs-number">167.64</span></span> age, ok := person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>].(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { log.Fatal(<span class="hljs-string"><span class="hljs-string">"could not assert value to int"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } person[<span class="hljs-string"><span class="hljs-string">"age"</span></span>] = age + <span class="hljs-number"><span class="hljs-number">1</span></span> log.Printf(<span class="hljs-string"><span class="hljs-string">"%+v"</span></span>, person) }</code> </pre> <br> 如果<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">运行this</a> ，一切将按预期工作： <br><br><pre> <code class="plaintext hljs">2009/11/10 23:00:00 map[age:22 height:167.64 name:Alice]</code> </pre> <br> 那么什么时候应该使用空接口类型呢？ <br><br> 也许<i>不是太经常</i> 。 如果您遇到这种情况，请停下来考虑<code>interface{}</code>使用<code>interface{}</code>是否正确。 作为一般建议，我可以说，使用特定类型（即非空接口类型）将更加清晰，安全和高效。 在上面的示例中，最好使用适当类型的字段定义<code>Person</code>结构： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Age <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Height <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> }</code> </pre> <br> 另一方面，当您需要访问和使用不可预测或用户定义的类型时，空接口非常有用。 出于某种原因，此类接口在标准库的不同位置使用，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gob.Encode</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">fmt.Print</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">template.Execute</a>函数。 <br><br><h2> 有用的接口类型 </h2><br> 这是标准库中最需要和最有用的接口类型的简短列表。 如果您还不熟悉它们，则建议阅读相关文档。 <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内建错误</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">fmt.Stringer</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">io.Reader</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">作家</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">io.ReadWriteCloser</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://golang.org/pkg/net/">http.ResponseWriter</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://golang.org/pkg/net/">http.Handler</a> <br></li></ul><br> 标准库的详细列表也可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处找到</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN463063/">https://habr.com/ru/post/zh-CN463063/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN463045/index.html">使用神经网络自动检测文本对话中的情绪</a></li>
<li><a href="../zh-CN463055/index.html">关于公司内部的管理员，开发人员，无休止的混乱和DevOps转型</a></li>
<li><a href="../zh-CN463057/index.html">Yii Framework 2自定义权限</a></li>
<li><a href="../zh-CN463059/index.html">IT中的三者</a></li>
<li><a href="../zh-CN463061/index.html">在Figma中准备布局的规则</a></li>
<li><a href="../zh-CN463067/index.html">首先是正面，然后是背面（某天）</a></li>
<li><a href="../zh-CN463069/index.html">React Basic动画指南</a></li>
<li><a href="../zh-CN463071/index.html">互联网中断有什么影响？</a></li>
<li><a href="../zh-CN463073/index.html">QUIC的实际应用：Uber如何实施以优化性能</a></li>
<li><a href="../zh-CN463075/index.html">新的开源许可证</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>