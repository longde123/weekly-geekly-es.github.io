<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖌️ ⛎ 🐯 Pelatihan Cisco 200-125 CCNA v3.0. Hari 18. Dasar-dasar Routing 🥕 👩🏻‍🌾 🚣🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kita akan mulai mempelajari router. Jika Anda mengikuti kursus video saya dari pelajaran pertama hingga ke-17, maka Anda sudah mempelajari da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pelatihan Cisco 200-125 CCNA v3.0. Hari 18. Dasar-dasar Routing</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/463559/"> Hari ini kita akan mulai mempelajari router.  Jika Anda mengikuti kursus video saya dari pelajaran pertama hingga ke-17, maka Anda sudah mempelajari dasar-dasar sakelar.  Sekarang kita pindah ke perangkat berikutnya - router.  Seperti yang Anda ketahui dari tutorial video sebelumnya, salah satu topik kursus CCNA disebut Cisco Switching &amp; Routing. <br><br>  Dalam seri ini, kami tidak akan mempelajari router Cisco, tetapi mempertimbangkan konsep routing secara keseluruhan.  Kami akan memiliki tiga topik.  Yang pertama adalah ulasan tentang apa yang sudah Anda ketahui tentang router dan percakapan tentang bagaimana hal ini dapat diterapkan bersamaan dengan pengetahuan yang Anda peroleh dalam proses mempelajari switch.  Kita harus memahami apa pekerjaan gabungan switch dan router. <br><br><img src="https://habrastorage.org/webt/jb/y8/dg/jby8dgnlbyixxtltjwi7gezkwsm.jpeg"><br><br>  Selanjutnya, kita melihat apa itu routing, apa artinya dan bagaimana cara kerjanya, dan kemudian beralih ke jenis protokol routing.  Hari ini saya menggunakan topologi yang sudah Anda lihat dalam pelajaran sebelumnya. <a name="habracut"></a><br><br>  Kami melihat bagaimana data bergerak melintasi jaringan dan bagaimana jabat tangan TCP tiga langkah dibuat.  Pesan pertama yang dikirim melalui jaringan adalah paket SYN.  Mari kita lihat bagaimana jabat tangan tiga tahap terjadi ketika komputer dengan alamat IP 10.1.1.10 ingin menghubungi server 30.1.1.10, yaitu mencoba untuk membuat koneksi FTP. <br>  Untuk memulai koneksi, komputer membuat port sumber dengan nomor acak 25113. Jika Anda lupa bagaimana ini terjadi, saya menyarankan Anda untuk meninjau tutorial video sebelumnya yang membahas masalah ini. <br><br><img src="https://habrastorage.org/webt/dh/cm/cp/dhcmcp806ovdnz5ezywa46pet4u.jpeg"><br><br>  Kemudian ia memasukkan nomor port tujuan ke dalam bingkai, karena ia tahu bahwa ia perlu terhubung ke port 21, lalu ia menambahkan informasi OSI tingkat ketiga, yaitu alamat IP-nya sendiri dan alamat IP tujuan.  Data bertitik tidak berubah hingga titik akhir tercapai.  Setelah mencapai server, mereka juga tidak berubah, tetapi server menambah informasi bingkai tingkat kedua, yaitu, alamat MAC.  Hal ini disebabkan oleh fakta bahwa switch hanya menerima informasi tingkat kedua OSI.  Dalam skenario ini, router adalah satu-satunya perangkat jaringan yang mempertimbangkan informasi tingkat 3, tentu saja, komputer juga bekerja dengan informasi ini.  Jadi, switch hanya berfungsi dengan informasi level 2, dan router - level 3. <br><br>  Switch mengetahui sumber alamat MAC XXXX: XXXX: 1111 dan ingin mengetahui alamat MAC server yang diakses komputer.  Ia membandingkan alamat IP sumber dengan alamat tujuan, memahami bahwa perangkat ini terletak pada subnet yang berbeda, dan memutuskan untuk menggunakan gateway untuk menuju ke subnet lain. <br><br>  Saya sering ditanya siapa yang memutuskan alamat IP gateway yang seharusnya.  Pertama, tergantung pada administrator jaringan untuk membuat jaringan dan memberikan alamat IP untuk setiap perangkat.  Sebagai administrator, Anda dapat menetapkan alamat apa pun yang berada dalam kisaran alamat yang diizinkan dari subnet kepada perute. Biasanya ini adalah alamat pertama atau terakhir yang valid, tetapi tidak ada aturan ketat mengenai tujuannya.  Dalam kasus kami, administrator menetapkan alamat gateway, atau router, 10.1.1.1 dan menetapkannya ke port F0 / 0. <br><br>  Saat Anda mengkonfigurasi jaringan pada komputer dengan alamat IP statis 10.1.1.10, Anda menetapkan subnet mask 255.255.255.0 dan gateway default 10.1.1.1.  Jika Anda tidak menggunakan alamat statis, maka komputer menggunakan DHCP, yang menetapkan alamat dinamis.  Apa pun alamat IP yang digunakan komputer, statis atau dinamis, alamat gateway harus ada untuk mengakses jaringan lain. <br><br>  Dengan demikian, komputer 10.1.1.10 tahu bahwa ia harus mengirim frame ke router 10.1.1.1.  Transfer ini terjadi di dalam jaringan lokal, di mana alamat IP tidak masalah, hanya alamat MAC yang penting di sini.  Misalkan komputer tidak pernah menghubungi router dan tidak tahu alamat MAC-nya, jadi ia harus terlebih dahulu mengirim permintaan ARP, yang menanyakan semua perangkat di subnet: "Hei, siapa di antara Anda yang memiliki alamat 10.1.1.1?  Tolong beri tahu saya alamat MAC Anda! "  Karena ARP adalah pesan siaran, ia tiba di semua port semua perangkat, termasuk router. <br><br>  Komputer 10.1.1.12, setelah menerima ARP, berpikir: "tidak, alamat saya bukan 10.1.1.1", dan menolak permintaan, komputer 10.1.1.13 melakukan hal yang sama.  Router, setelah menerima permintaan itu, memahami bahwa mereka memintanya, dan mengirimkan alamat MAC port F0 / 0 - dan semua port memiliki alamat MAC yang berbeda - ke komputer 10.1.1.10.  Sekarang, mengetahui alamat gateway XXXX: AAAA, yang dalam hal ini adalah alamat tujuan, komputer menambahkannya ke akhir bingkai yang ditujukan ke server.  Bersamaan dengan ini, ia menetapkan header frame FCS / CRC, yang merupakan mekanisme untuk memeriksa kesalahan transmisi. <br><br><img src="https://habrastorage.org/webt/px/uw/ht/pxuwhtqppalqe_l5chqlho39hiy.jpeg"><br><br>  Setelah itu, frame komputer 10.1.1.10 dikirim melalui kabel ke router 10.1.1.1.  Setelah menerima frame, router menghapus FCS / CRC, menggunakan algoritma yang sama seperti komputer untuk verifikasi.  Data tidak lebih dari kumpulan angka nol dan angka.  Jika data rusak, yaitu, 1 menjadi 0 atau 0 menjadi satu, atau ada kebocoran data yang sering terjadi saat menggunakan hub, maka perangkat harus meneruskan frame lagi. <br><br>  Jika pemeriksaan FCS / CRC berhasil, router melihat sumber dan tujuan alamat MAC dan menghapusnya, karena ini adalah informasi level 2, dan pergi ke tubuh frame, yang berisi informasi level 3.  Dari situ, ia mengetahui bahwa informasi yang terkandung dalam frame adalah untuk perangkat dengan alamat IP 30.1.1.10. <br><br>  Perute entah bagaimana tahu di mana perangkat ini berada.  Kami tidak membahas masalah ini ketika kami mempertimbangkan pengoperasian sakelar, jadi kami akan mempertimbangkannya sekarang.  Router memiliki 4 port, jadi saya menambahkan beberapa koneksi lagi.  Jadi, bagaimana router mengetahui bahwa data untuk perangkat dengan alamat IP 30.1.1.10 perlu dikirim melalui port F0 / 1?  Kenapa dia tidak mengirim mereka melalui port F0 / 3 atau F0 / 2? <br><br>  Faktanya adalah bahwa router bekerja dengan tabel routing.  Setiap router memiliki tabel yang memungkinkan Anda memutuskan port mana untuk mengirimkan frame tertentu. <br><br><img src="https://habrastorage.org/webt/o7/tp/f6/o7tpf6nkd5iniclvajhvvqzpw5u.jpeg"><br><br>  Dalam hal ini, port F0 / 0 dikonfigurasikan ke alamat IP 10.1.1.1 dan ini berarti terhubung ke jaringan 10.1.1.10/24.  Demikian pula, port F0 / 1 dikonfigurasikan ke alamat 20.1.1.1, yaitu, terhubung ke jaringan 20.1.1.0/24.  Router mengetahui kedua jaringan ini karena mereka terhubung langsung ke port-portnya.  Dengan demikian, informasi bahwa lalu lintas untuk jaringan 10.1.10 / 24 harus melalui port F0 / 0, dan untuk jaringan 20.1.1.0/24 harus melalui port F0 / 1, diketahui secara default.  Bagaimana router mengetahui melalui port mana untuk bekerja dengan jaringan lain? <br><br>  Kita melihat bahwa jaringan 40.1.1.0/24 terhubung ke port F0 / 2, jaringan 50.1.1.0/24 terhubung ke port F0 / 3, dan jaringan 30.1.1.0/24 menghubungkan router kedua ke server.  Router kedua juga memiliki tabel routing, yang mengatakan bahwa jaringan 30. terhubung ke port-nya, kami menyatakan 0/1, dan terhubung ke router pertama melalui port 0/0.  Router ini tahu bahwa port 0/0-nya terhubung ke jaringan 20., dan port 0/1 terhubung ke jaringan 30., dan tidak tahu apa-apa lagi. <br><br>  Demikian pula, router pertama tahu tentang jaringan 40. dan 50. terhubung ke port 0/2 dan 0/3, tetapi tidak tahu apa-apa tentang jaringan 30. Protokol perutean memberikan router informasi yang tidak mereka miliki secara default.  Mekanisme dimana router-router ini berinteraksi satu sama lain adalah dasar dari perutean, dan ada perutean yang dinamis dan statis. <br><br>  Routing statis adalah bahwa router pertama diberi informasi: jika Anda perlu terhubung ke jaringan 30.1.1.0/24, maka Anda perlu menggunakan port F0 / 1.  Namun, ketika router kedua menerima lalu lintas dari server yang dirancang untuk komputer 10.1.1.10, ia tidak tahu apa yang harus dilakukan dengannya, karena dalam tabel peruteannya hanya ada informasi tentang jaringan 30. dan 20. Oleh karena itu, router ini juga perlu mendaftarkan perutean statis : jika menerima lalu lintas untuk jaringan 10., maka itu harus mengirimkannya melalui port 0/0. <br><br>  Masalah dengan routing statis adalah bahwa saya harus secara manual mengkonfigurasi router pertama untuk bekerja dengan jaringan 30. dan router kedua untuk bekerja dengan jaringan 10. Ini sederhana jika saya hanya memiliki 2 router, tetapi ketika saya memiliki 10 router, mengatur statis Routing membutuhkan banyak waktu.  Dalam hal ini, masuk akal untuk menggunakan perutean dinamis. <br>  Jadi, setelah menerima frame dari komputer, router pertama melihat tabel routing-nya dan memutuskan untuk mengirimnya melalui port F0 / 1.  Pada saat yang sama, itu menambahkan alamat MAC sumber XXXX.BBBB dan alamat MAC tujuan XXXX.SSCC ke bingkai. <br><br><img src="https://habrastorage.org/webt/zf/ue/yg/zfueygka2ioa7csij5leupwh4pc.jpeg"><br><br>  Setelah menerima frame ini, router kedua "memotong" alamat MAC yang terkait dengan level kedua OSI, dan melanjutkan ke informasi level ketiga.  Dia melihat bahwa alamat IP tujuan 30.1.1.10 milik jaringan yang sama dengan port 0/1 dari router, menambahkan sumber alamat MAC dan alamat MAC dari perangkat tujuan ke bingkai dan mengirimkan bingkai ke server. <br><br><img src="https://habrastorage.org/webt/tw/4h/-o/tw4h-oouecat_yq4568dgisula4.jpeg"><br><br>  Seperti yang sudah saya katakan, kemudian proses serupa diulangi dalam arah yang berlawanan, yaitu, tahap jabat tangan kedua dilakukan, di mana server mengirimkan kembali pesan SYN ACK.  Sebelum itu, ia membuang semua informasi yang tidak perlu dan hanya menyisakan paket SYN. <br><br><img src="https://habrastorage.org/webt/ba/ki/my/bakimy_lojii5shhhtgw0tlj-9i.jpeg"><br><br>  Setelah menerima paket ini, router kedua mempertimbangkan informasi yang diterima, melengkapi dan mengirimkannya lebih lanjut. <br><br>  Jadi, dalam pelajaran sebelumnya, kami mempelajari cara kerja saklar, dan sekarang kami mempelajari cara kerja router.  Mari kita jawab pertanyaan tentang apa itu routing dalam arti global.  Misalkan Anda menemukan plang yang dipasang di bundaran.  Anda melihat bahwa cabang pertama mengarah ke pangkalan Fairfax Royal Air Force, yang kedua ke bandara, yang ketiga ke selatan.  Jika Anda memilih jalan keluar keempat, Anda akan berakhir di jalan buntu, dan setelah yang kelima Anda dapat berkendara melalui pusat kota ke Kastil Braxby. <br><br><img src="https://habrastorage.org/webt/wv/ya/24/wvya24lrq4i_ddnmrflggy_uk08.jpeg"><br><br>  Secara umum, routing adalah apa yang membuat router memutuskan kemana harus mengarahkan traffic.  Dalam hal ini, Anda, sebagai pengemudi, harus memutuskan keluar mana dari persimpangan yang harus Anda ambil.  Dalam jaringan, router harus membuat keputusan ke mana harus mengirim paket atau bingkai.  Anda harus memahami bahwa perutean memungkinkan Anda membuat tabel berdasarkan perute mana yang mengambil keputusan ini. <br><br>  Seperti yang saya katakan, ada routing statis dan dinamis.  Pertimbangkan perutean statis, di mana saya akan menggambar 3 perangkat yang terhubung satu sama lain, dengan perangkat pertama dan ketiga terhubung ke jaringan.  Misalkan satu jaringan 10.1.1.0 ingin terhubung ke jaringan 40.1.1.0, dan di antara router ada jaringan 20.1.1.0 dan 30.1.1.0. <br><br><img src="https://habrastorage.org/webt/gt/ua/t1/gtuat1qujcp3ck7s7gaftctvsco.jpeg"><br><br>  Dalam hal ini, port-port dari router-router tersebut harus milik subnet yang berbeda.  Router 1 secara default hanya tahu tentang jaringan 10. dan 20. dan tidak tahu apa-apa tentang jaringan lain.  Router 2 hanya tahu tentang jaringan 20. dan 30. karena mereka terhubung ke sana, dan router 3 hanya tahu tentang jaringan 30. dan 40. Jika jaringan 10. ingin terhubung ke jaringan 40., saya harus memberi tahu router 1 tentang jaringan 30. dan bahwa jika dia ingin mentransfer bingkai jaringan 40., dia harus menggunakan antarmuka untuk jaringan 20. dan mengirim bingkai melalui jaringan yang sama 20. <br><br>  Saya harus menetapkan 2 rute ke router kedua: jika dia ingin mentransfer paket dari jaringan 40. ke jaringan 10., saya harus menggunakan port jaringan 20., dan untuk mentransfer paket dari jaringan 10. jaringan 40. - port jaringan 30. Demikian pula, saya harus menyediakan router 3 dengan informasi tentang jaringan 10. dan 20. <br><br>  Jika Anda memiliki jaringan kecil, maka perutean statis sangat mudah diatur.  Namun, semakin banyak jaringan tumbuh, semakin banyak masalah muncul dengan routing statis.  Bayangkan Anda membuat koneksi baru yang secara langsung menghubungkan router pertama dan ketiga.  Dalam hal ini, protokol perutean dinamis akan secara otomatis memperbarui tabel perutean router 1, yang menunjukkan hal-hal berikut: "jika Anda perlu menghubungi router 3, gunakan rute langsung"! <br><br><img src="https://habrastorage.org/webt/jg/sp/cn/jgspcn_c5nlc_-e91rbyknbkode.jpeg"><br><br>  Ada dua jenis protokol routing: protokol gateway internal IGP dan protokol gateway eksternal EGP.  Protokol pertama bekerja dengan sistem otonom terpisah yang dikenal sebagai domain perutean.  Bayangkan Anda memiliki organisasi kecil dengan hanya 5 router.  Jika kami hanya berbicara tentang koneksi antara router-router ini, yang kami maksud adalah IGP, tetapi jika Anda menggunakan jaringan Anda untuk berkomunikasi dengan Internet, seperti yang dilakukan penyedia ISP, maka gunakan EGP. <br><br><img src="https://habrastorage.org/webt/gg/ot/uc/ggotuchtprrj_lfnovx_p0fefz8.jpeg"><br><br>  IGP menggunakan 3 protokol populer: RIP, OSPF dan EIGRP.  Kurikulum CCNA hanya menyebutkan dua protokol terakhir karena RIP sudah usang.  Ini adalah protokol routing yang paling sederhana, yang masih digunakan dalam beberapa kasus, tetapi tidak memberikan keamanan jaringan yang diperlukan.  Ini adalah salah satu alasan mengapa Cisco mengeluarkan RIP dari kursus.  Namun, saya masih akan memberi tahu Anda tentang hal itu, karena mempelajari itu membantu untuk memahami dasar-dasar perutean. <br><br><img src="https://habrastorage.org/webt/-w/yd/00/-wyd00ggywretxv6t3drxrgal0i.jpeg"><br><br>  Klasifikasi protokol EGP menggunakan dua protokol: BGP dan protokol EGP yang sebenarnya.  Saat mempelajari kursus CCNA, kami hanya akan mempertimbangkan BGP, OSPF dan EIGRP.  Anda dapat mempertimbangkan cerita tentang informasi bonus RIP, yang akan tercermin dalam salah satu tutorial video. <br>  Ada 2 lebih banyak jenis protokol routing: protokol distance vector distance dan protokol Link State link state routing. <br><br><img src="https://habrastorage.org/webt/md/x7/ff/mdx7ffe6zakej1nn1e3w_qwgama.jpeg"><br><br>  Tusukan pertama mempertimbangkan jarak dan arah vektor.  Sebagai contoh, saya dapat membuat koneksi langsung antara R1 dan R4, dan saya dapat membuat koneksi di sepanjang jalur R1-R2-R3-R4.  Jika kita berbicara tentang protokol routing menggunakan metode vektor jarak jauh, maka dalam hal ini koneksi akan selalu dilakukan di sepanjang jalur terpendek.  Tidak masalah bahwa koneksi ini akan memiliki kecepatan minimum.  Dalam kasus kami, ini adalah 128 kbit / s, yang jauh lebih lambat daripada koneksi di sepanjang rute R1-R2-R3-R4, di mana kecepatannya adalah 100 Mbps. <br><br>  Pertimbangkan RIP protokol distance-vektor.  Saya akan menyelesaikan jaringan 10 di depan R1, dan jaringan 40 di belakang R4. Misalkan ada banyak komputer di jaringan ini.  Jika saya ingin membuat koneksi antara jaringan 10. R1 dan jaringan 40. R4, maka saya akan menetapkan R1 routing statis tipe: "jika Anda perlu terhubung ke jaringan 40., gunakan komunikasi langsung dengan router R4".  Dalam hal ini, pada semua 4 router, saya harus mengkonfigurasi RIP secara manual.  Maka tabel routing R1 akan secara otomatis melaporkan bahwa jika jaringan 10. ingin terhubung ke jaringan 40., Anda harus menggunakan koneksi langsung R1-R4.  Bahkan jika solusinya lebih cepat, protokol Distance Vector masih akan memilih jalur terpendek dengan jarak transmisi terkecil. <br><br>  OSPF adalah protokol perutean status saluran yang selalu melihat status bagian jaringan.  Dalam hal ini, ia memperkirakan kecepatan saluran, dan jika ia melihat bahwa tingkat lalu lintas transmisi pada saluran R1-R4 sangat rendah, ia memilih jalur dengan kecepatan lebih tinggi R1-R2-R3-R4, bahkan jika panjangnya melebihi jalur terpendek.  Jadi, jika saya mengkonfigurasi protokol OSPF pada semua router, ketika saya mencoba menghubungkan jaringan 40. ke jaringan 10., lalu lintas akan dikirim di sepanjang rute R1-R2-R3-R4.  Jadi, RIP adalah protokol vektor jarak, dan OSPF adalah protokol routing status saluran. <br><br>  Ada protokol lain - EIGRP, protokol routing milik Cisco.  Jika kita berbicara tentang perangkat jaringan dari pabrikan lain, misalnya, Juniper, maka mereka tidak mendukung EIGRP.  Ini adalah protokol perutean yang sangat baik yang jauh lebih efisien daripada RIP dan OSPF, tetapi hanya dapat digunakan pada jaringan berbasis perangkat Cisco.  Nanti saya akan memberi tahu Anda lebih banyak tentang mengapa protokol ini begitu baik.  Sejauh ini, saya perhatikan bahwa EIGRP menggabungkan fitur protokol distance-vektor dan protokol routing state channel, mewakili protokol hybrid. <br><br>  Dalam tutorial video berikutnya, kita akan membahas tentang router Cisco, saya akan memberi tahu Anda sedikit tentang sistem operasi Cisco IOS, yang dirancang untuk switch dan router.  Saya berharap bahwa dalam pelajaran hari ke-19 atau ke-20 kita akan memulai studi rinci tentang protokol routing, dan saya akan menunjukkan cara mengkonfigurasi router Cisco menggunakan contoh jaringan kecil. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mJgPcB7ndbk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Terima kasih telah tinggal bersama kami.  Apakah Anda suka artikel kami?  Ingin melihat materi yang lebih menarik?  Dukung kami dengan melakukan pemesanan atau merekomendasikannya kepada teman-teman Anda, <b>diskon 30% untuk pengguna Habr pada analog unik dari server entry-level yang kami temukan untuk Anda:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seluruh kebenaran tentang VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps dari $ 20 atau bagaimana membagi server?</a>  (opsi tersedia dengan RAID1 dan RAID10, hingga 24 core dan hingga 40GB DDR4). <br><br>  <b>Dell R730xd 2 kali lebih murah?</b>  Hanya kami yang memiliki <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV dari $ 199</a> di Belanda!</b>  <b><b>Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - mulai dari $ 99!</b></b>  Baca tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Membangun Infrastruktur Bldg.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463559/">https://habr.com/ru/post/id463559/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463535/index.html">Memeriksa .NET Core Libraries Source Code oleh PVS-Studio Static Analyzer</a></li>
<li><a href="../id463537/index.html">Verifikasi kode sumber pustaka .NET Core oleh penganalisa statis PVS-Studio</a></li>
<li><a href="../id463541/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 17. Ringkasan dan peta jalan kursus CCNA</a></li>
<li><a href="../id463551/index.html">Bagaimana berhubungan dengan karyawan dan mengatur alur kerja di perusahaan IT besar</a></li>
<li><a href="../id463553/index.html">"Apakah kamu orang google?" atau 5 hal yang kami lakukan saat merekrut (tetapi tidak lagi)</a></li>
<li><a href="../id463563/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 19. Memulai dengan router</a></li>
<li><a href="../id463567/index.html">Penyesuaian yang tepat dari tawaran kontekstual tergantung pada waktu tampilan [+ templat]</a></li>
<li><a href="../id463569/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 20. Routing Statis</a></li>
<li><a href="../id463571/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 21. RIP Routing Vektor Jarak Jauh</a></li>
<li><a href="../id463573/index.html">Chip pertama untuk pusat data berdasarkan arsitektur Zen 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>